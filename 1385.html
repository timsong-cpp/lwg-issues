<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 1385: tuple_cat should be a single variadic signature</title>
<meta property="og:title" content="Issue 1385: tuple_cat should be a single variadic signature">
<meta property="og:description" content="C++ library issue. Status: C++11">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/1385.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="1385"><a href="lwg-defects.html#1385">1385</a>. <code>tuple_cat</code> should be a single variadic signature</h3>
<p><b>Section:</b> 22.4.5 <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a> <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.creation">issues</a> in [tuple.creation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-88</b></p>
<p>
The <code>tuple_cat</code> template consists of four overloads and that
can concatenate only two <code>tuple</code>s. A single variadic
signature that can concatenate an arbitrary number of
<code>tuple</code>s would be preferred.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote><p>
Adopt a simplified form of the proposal in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2975.pdf">n2975</a>,
restricted to <code>tuple</code>s and neither requiring nor outlawing support for other <code>tuple</code>-like types.
</p></blockquote>

<p><i>[
2010 Rapperswil: Alisdair to provide wording.
]</i></p>


<p><i>[
2010-11-06: Daniel comments and proposes some alternative wording:
]</i></p>


<p>
There are some problems in the wording: First, even though the result type <code>tuple&lt;<i>see below</i>&gt;</code>
implies it, the specification of the contained tuple element types is missing. Second, the term &quot;<code>tuple</code> 
protocol&quot; is not defined anywhere and I see no reason why this normative wording should not be a non-normative
note. We could at least give a better approximation, maybe "tuple-like protocol" as indicated from header
<code>&lt;utility&gt;</code> synopsis. Further, it seems to me that the effects need to contain a combination of <code>std::forward</code>
with the call of <code>get</code>. Finally I suggest to replace the requirements <code>Move/CopyConstructible</code>
by proper usage of <code>is_constructible</code>, as indicated by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
Moved to Ready with Daniel's improved wording.
</p>


<p id="res-1385"><b>Proposed resolution:</b></p>
<p>Note: This alternate proposed resolution works only if <a href="1191" title="tuple get API should respect rvalues (Status: C++11)">1191</a> has been accepted.</p>

<ol>
<li>Change 22.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a> p. 2, header <code>&lt;tuple&gt;</code> synopsis, as indicated:
<blockquote><pre>
namespace std {

...

// <i>20.4.2.4, tuple creation functions:</i>
const unspecified ignore;

template &lt;class... Types&gt;
  tuple&lt;<i>VTypes</i>...&gt; make_tuple(Types&amp;&amp;...);
  template &lt;class... Types&gt;
  tuple&lt;<i>ATypes</i>...&gt; forward_as_tuple(Types&amp;&amp;...);
  
template&lt;class... Types&gt;
  tuple&lt;Types&amp;...&gt; tie(Types&amp;...);
  
<del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp;, const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp;, tuple&lt;UTypes...&gt;&amp;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp;, tuple&lt;UTypes...&gt;&amp;&amp;);</del>
<ins>template &lt;class... Tuples&gt;
  tuple&lt;<i>CTypes</i>...&gt; tuple_cat(Tuples&amp;&amp;...);</ins>

...

</pre></blockquote>
</li>
<li>Change 22.4.5 <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a> as indicated:
<blockquote>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></pre>
<blockquote><p><del>
8 <i>Requires</i>: All the types in <code>TTypes</code> shall be <code>CopyConstructible</code> (Table 35). All the types in 
<code>UTypes</code> shall be <code>CopyConstructible</code> (Table 35).
</del></p></blockquote>
<blockquote><p><del>
9 <i>Returns</i>: A <code>tuple</code> object constructed by copy constructing its first <code>sizeof...(TTypes)</code> elements 
from the corresponding elements of <code>t</code> and copy constructing its last <code>sizeof...(UTypes)</code> elements from the 
corresponding elements of <code>u</code>.
</del></p></blockquote>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></pre>
<blockquote><p><del>
10 <i>Requires</i>: All the types in <code>TTypes</code> shall be <code>MoveConstructible</code> (Table 34). All the types in 
<code>UTypes</code> shall be <code>CopyConstructible</code> (Table 35).
</del></p></blockquote>
<blockquote><p><del>
11 <i>Returns</i>: A <code>tuple</code> object constructed by move constructing its first <code>sizeof...(TTypes)</code> elements 
from the corresponding elements of <code>t</code> and copy constructing its last <code>sizeof...(UTypes)</code> elements from the 
corresponding elements of <code>u</code>.
</del></p></blockquote>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);</del></pre>
<blockquote><p><del>
12 <i>Requires</i>: All the types in <code>TTypes</code> shall be <code>CopyConstructible</code> (Table 35). All the types in 
<code>UTypes</code> shall be <code>MoveConstructible</code> (Table 34).
</del></p></blockquote>
<blockquote><p><del>
13 <i>Returns</i>: A <code>tuple</code> object constructed by copy constructing its first <code>sizeof...(TTypes)</code> elements 
from the corresponding elements of <code>t</code> and move constructing its last <code>sizeof...(UTypes)</code> elements from the 
corresponding elements of <code>u</code>.
</del></p></blockquote>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);</del></pre>
<blockquote><p><del>
14 <i>Requires</i>: All the types in <code>TTypes</code> shall be <code>MoveConstructible</code> (Table 34). All the types in 
<code>UTypes</code> shall be <code>MoveConstructible</code> (Table 34).
</del></p></blockquote>
<blockquote><p><del>
15 <i>Returns</i>: A <code>tuple</code> object constructed by move constructing its first <code>sizeof...(TTypes)</code> elements 
from the corresponding elements of <code>t</code> and move constructing its last <code>sizeof...(UTypes)</code> elements from the 
corresponding elements of <code>u</code>.
</del></p></blockquote>
<pre><ins>template &lt;class... Tuples&gt;
  tuple&lt;<i>CTypes</i>...&gt; tuple_cat(Tuples&amp;&amp;... tpls);
</ins></pre>
<blockquote><p><ins>
8 Let <code>Ti</code> be the <code><i>i</i></code><sup>th</sup> type in <code>Tuples</code>, <code>Ui</code> be <code>remove_reference&lt;Ti&gt;::type</code>,
and <code>tp<sub><i>i</i></sub></code> be the <code><i>i</i></code><sup>th</sup> parameter in the function parameter pack <code>tpls</code>, where all 
indexing is zero-based in the following paragraphs of this sub-clause [tuple.creation].
</ins></p></blockquote>
<blockquote><p><ins>
9 <i>Requires</i>: For all <code><i>i</i></code>, <code>Ui</code> shall be the type <i>cv<sub><code>i</code></sub>&nbsp;</i><code>tuple&lt;Args<sub><i>i</i></sub>...&gt;</code>, 
where <i>cv<sub><code>i</code></sub></i> is the (possibly empty) <code><i>i</i></code><sup>th</sup> <i>cv</i>-qualifier-seq, and 
<code>Args<sub><i>i</i></sub></code> is the parameter pack representing the element types in <code>Ui</code>. Let <code>Aik</code> be the 
<code><i>k<sub>i</sub></i></code><sup>th</sup> type in <code>Args<sub><i>i</i></sub></code>, then for all <code>Aik</code> the following 
requirements shall be satisfied: If <code>Ti</code> is deduced as an lvalue reference type, then 
<code>is_constructible&lt;Aik, <i>cv<sub>i</sub>&nbsp;</i>Aik&amp;&gt;::value == true</code>, otherwise 
<code>is_constructible&lt;Aik, <i>cv<sub>i</sub>&nbsp;</i>Aik&amp;&amp;&gt;::value == true</code>.
</ins></p></blockquote>
<blockquote><p><ins>
10 <i>Remarks</i>: The types in <code><i>CTypes</i></code> shall be equal to the ordered sequence of the expanded types
<code>Args<sub>0</sub>..., Args<sub>1</sub>..., Args<sub><i>n</i>-1</sub>...</code>, where <code><i>n</i></code> equals 
<code>sizeof...(Tuples)</code>. Let <code><i>e<sub>i</sub></i>...</code> be the <code><i>i</i></code><sup>th</sup> ordered 
sequence of tuple elements of the result <code>tuple</code> object corresponding to the type sequence 
<code>Args<sub><i>i</i></sub></code>.
</ins></p></blockquote>
<blockquote><p><ins>
11 <i>Returns</i>: A <code>tuple</code> object constructed by initializing
the <code><i>k<sub>i</sub></i></code><sup>th</sup> type element <code>eik</code> in <code><i>e<sub>i</sub></i>...</code>
with <code>get&lt;<i>k<sub>i</sub></i>&gt;(std::forward&lt;Ti&gt;(tp<sub>i</sub>))</code>
for each valid <code><i>k<sub>i</sub></i></code> and each element group <code><i>e<sub>i</sub></i></code> in order. 
</ins></p></blockquote>
<blockquote><p><ins>
12 [<i>Note</i>: An implementation may support additional types in the parameter pack <code>Tuples</code>, such as
<code>pair</code> and <code>array</code> that support the <code>tuple</code>-like protocol. &mdash; <i>end note</i>]
</ins></p></blockquote>
</blockquote>
</li>
</ol>






</body>
</html>
