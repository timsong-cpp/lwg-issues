<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 775: Tuple indexing should be unsigned?</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-15 at 21:11:18 UTC</p>
<hr>
<h3><a name="775" href="775">775.</a> Tuple indexing should be unsigned?</h3>
<p><b>Section:</b> 20.5.2.6 [tuple.helper] <b>Status:</b> <a href="lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-01-16 <b>Last modified:</b> 2016-11-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The tuple element access API identifies the element in the sequence
using signed integers, and then goes on to enforce the requirement that
I be &gt;= 0.  There is a much easier way to do this - declare I as
<tt>unsigned</tt>.
</p>
<p>
In fact the proposal is to use <code>std::size_t</code>, matching the 
type used in the <tt>tuple_size</tt> API.
</p>
<p>
A second suggestion is that it is hard to imagine an API that deduces
and index at compile time and returns a reference throwing an exception.
Add a specific <em>Throws:</em> Nothing paragraph to each element
access API.
</p>
<p>
In addition to <code>tuple</code>, update the API applies to
<code>pair</code> and <code>array</code>, and should be updated
accordingly.
</p>

<p>
A third observation is that the return type of the <code>get</code>
functions for <code>std::pair</code> is pseudo-code, but it is not
clearly marked as such.  There is actually no need for pseudo-code as
the return type can be specified precisely with a call to
<code>tuple_element</code>.  This is already done for
<code>std::tuple</code>, and <code>std::array</code> does not have a
problem as all elements are of type <code>T</code>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Update header &lt;utility&gt; synopsis in 20.2 [utility]
</p>
<pre>
<em>// 20.2.3, tuple-like access to pair:</em>
template &lt;class T&gt; class tuple_size;
template &lt;<del>int</del><ins>size_t</ins> I, class T&gt; class tuple_element;

template &lt;class T1, class T2&gt; struct tuple_size&lt;std::pair&lt;T1, T2&gt; &gt;;
template &lt;class T1, class T2&gt; struct tuple_element&lt;0, std::pair&lt;T1, T2&gt; &gt;;
template &lt;class T1, class T2&gt; struct tuple_element&lt;1, std::pair&lt;T1, T2&gt; &gt;;

template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(std::pair&lt;T1, T2&gt;&amp;);
template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  const <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(const std::pair&lt;T1, T2&gt;&amp;);
</pre>
<p>
Update <strong>20.4 [pairs] Pairs</strong>
</p>
<pre>
template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(pair&lt;T1, T2&gt;&amp;);
template&lt;<del>int</del><ins>size_t</ins> I, class T1, class T2&gt;
  const <del>P</del><ins>typename tuple_element&lt;I, std::pair&lt;T1, T2&gt; &gt;::type </ins>&amp; get(const pair&lt;T1, T2&gt;&amp;);
</pre>
<p>
<del>24 <em>Return type:</em> If <code>I == 0</code> then <code>P</code> is <code>T1</code>, if <code>I == 1</code> then <code>P</code> is <code>T2</code>, and otherwise the program is ill-formed.</del>
</p>
<p>
25 <em>Returns:</em> If <code>I == 0</code> returns <code>p.first</code>, <del>otherwise</del> <ins>if <code>I == 1</code></ins> returns <code>p.second</code><ins>, and otherwise the program is ill-formed</ins>.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p>
Update header &lt;tuple&gt; synopsis in 20.5 [tuple] with a APIs as below:
</p>
<pre>
template &lt;<del>int</del><ins>size_t</ins> I, class T&gt; class tuple_element; <em>// undefined</em>
template &lt;<del>int</del><ins>size_t</ins> I, class... Types> class tuple_element&lt;I, tuple&lt;Types...> >;

<em>// 20.3.1.4, element access:</em>
template &lt;<del>int</del><ins>size_t</ins> I, class... Types&gt;
  typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp; get(tuple&lt;Types...&gt;&amp;);
template &lt;<del>int</del><ins>size_t</ins> I, class ... types&gt;
  typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type const&amp; get(const tuple&lt;Types...&gt;&amp;);
</pre>

<p>
Update <strong>20.5.2.6 [tuple.helper] Tuple helper classes</strong>
</p>
<pre>template &lt;<del>int</del><ins>size_t</ins> I, class... Types&gt;
class tuple_element&lt;I, tuple&lt;Types...&gt; &gt; {
public:
  typedef TI type;
};</pre>
<p>
1 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
2 <em>Type:</em> <code>TI</code> is the type of the <code>I</code>th element of <code>Types</code>, where indexing is zero-based.
</p>
<p>
Update <strong>20.5.2.7 [tuple.elem] Element access</strong>
</p>
<pre>
template &lt;<del>int</del><ins>size_t</ins> I, class... types &gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type&amp; get(tuple&lt;Types...&gt;&amp; t);
</pre>
<p>
1 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
<p/>
2 <em>Returns:</em> A reference to the <code>I</code>th element of <code>t</code>, where indexing is zero-based.
</p>
<ins><em>Throws:</em> Nothing.</ins>
<pre>
template &lt;<del>int</del><ins>size_t</ins> I, class... types&gt;
typename tuple_element&lt;I, tuple&lt;Types...&gt; &gt;::type const&amp; get(const tuple&lt;Types...&gt;&amp; t);
</pre>
<p>
3 <em>Requires:</em> <code><del>0 &lt;= I and </del>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
4 <em>Returns:</em> A const reference to the <code>I</code>th element of <code>t</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p>
Update header &lt;array&gt; synopsis in 20.2 [utility]
</p>
<pre>
template &lt;class T&gt; class tuple_size; <em>// forward declaration</em>
template &lt;<del>int</del><ins>size_t</ins> I, class T> class tuple_element; <em>// forward declaration</em>
template &lt;class T, size_t N&gt;
  struct tuple_size&lt;array&lt;T, N&gt; &gt;;
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  struct tuple_element&lt;I, array&lt;T, N&gt; &gt;;
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  T&amp; get(array&lt;T, N&gt;&amp;);
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt;
  const T&amp; get(const array&lt;T, N&gt;&amp;);
</pre>

<p>
Update <strong>23.3.7.9 [array.tuple] Tuple interface to class template array</strong>
</p>
<pre>
tuple_element&lt;<ins>size_t </ins>I, array&lt;T, N&gt; &gt;::type
</pre>
<p>
3 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N.</code> The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
4 <em>Value:</em> The type <code>T</code>.
</p>
<pre>
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt; T&amp; get(array&lt;T, N&gt;&amp; a);
</pre>
<p>
5 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
<em>Returns:</em> A reference to the <code>I</code>th element of <code>a</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>
<pre>
template &lt;<del>int</del><ins>size_t</ins> I, class T, size_t N&gt; const T&amp; get(const array&lt;T, N&gt;&amp; a);
</pre>
<p>
6 <em>Requires:</em> <code><del>0 &lt;= </del>I &lt; N</code>. The program is ill-formed if <code>I</code> is out of bounds.
</p>
<p>
7 <em>Returns:</em> A const reference to the <code>I</code>th element of <code>a</code>, where indexing is zero-based.
</p>
<p>
<ins><em>Throws:</em> Nothing.</ins>
</p>


<p><i>[
Bellevue: Note also that the phrase "The program is ill-formed if I is
out of bounds" in the requires clauses are probably unnecessary, and
could be removed at the editor's discretion. Also std:: qualification
for pair is also unnecessary.
]</i></p>




</body>
</html>
