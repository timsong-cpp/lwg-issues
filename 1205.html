<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 1205: Some algorithms could more clearly document their handling of empty ranges</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="1205" href="1205">1205.</a> Some algorithms could more clearly document their handling of empty ranges</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-13 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are a number of algorithms whose result might depend on the
handling of an empty range.  In some cases the result is not clear,
while in others it would help readers to clearly mention the result
rather than require some subtle intuition of the supplied wording.
</p>

<p>
25.3.1 [alg.all_of]
</p>

<blockquote><p>
<i>Returns:</i> <tt>true</tt> if <tt>pred(*i)</tt> is <tt>true</tt> for every
iterator <tt>i</tt> in the range <tt>[first,last)</tt>, ...
</p></blockquote>

<p>
What does this mean if the range is empty?
</p>

<p>
I believe that we intend this to be <tt>true</tt> and suggest a
non-normative note to clarify:
</p>

<p>
Add to p1 25.3.1 [alg.all_of]:
</p>

<blockquote><p>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&mdash; <i>end note</i>]
</p></blockquote>

<p>
25.3.3 [alg.none_of]
</p>

<blockquote><p>
<i>Returns:</i> <tt>true</tt> if <tt>pred(*i)</tt> is <tt>false</tt> for every
iterator <tt>i</tt> in the range <tt>[first,last)</tt>, ...
</p></blockquote>

<p>
What does this mean if the range empty?
</p>

<p>
I believe that we intend this to be <tt>true</tt> and suggest a
non-normative note to clarify:
</p>

<p>
Add to p1 25.3.3 [alg.none_of]:
</p>

<blockquote><p>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&mdash; <i>end note</i>]
</p></blockquote>

<p>
25.3.2 [alg.any_of]
</p>

<p>
The specification for an empty range is actually fairly clear in this
case, but a note wouldn't hurt and would be consistent with proposals
for <tt>all_of</tt>/<tt>none_of</tt> algorithms.
</p>

<p>
Add to p1 25.3.2 [alg.any_of]:
</p>

<blockquote><p>
[<i>Note:</i> Returns <tt>false</tt> if <tt>[first,last)</tt> is empty. 
&mdash; <i>end note</i>]
</p></blockquote>

<p>
25.3.6 [alg.find.end]
</p>

<p>
what does this mean if <tt>[first2,last2)</tt> is empty?
</p>

<p>
I believe the wording suggests the algorithm should return
<tt>last1</tt> in this case, but am not 100% sure. Is this in fact the
correct result anyway? Surely an empty range should always match and the
naive expected result would be <tt>first1</tt>?
</p>

<p>
My proposed wording is a note to clarify the current semantic:
</p>

<p>
Add to p2 25.3.6 [alg.find.end]:
</p>

<blockquote><p>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty. &mdash; <i>end note</i>]
</p></blockquote>

<p>
I would prefer a normative wording treating empty ranges specially, but
do not believe we can change semantics at this point in the process,
unless existing implementations actually yield this result:
</p>

<p>
Alternative wording: (NOT a note)
</p>
<p>
Add to p2 25.3.6 [alg.find.end]:
</p>
<blockquote><p>
Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty.
</p></blockquote>

<p>
25.3.7 [alg.find.first.of]
</p>

<p>
The phrasing seems precise when <tt>[first2, last2)</tt> is empty, but a small
note to confirm the reader's understanding might still help.
</p>

<p>
Add to p2 25.3.7 [alg.find.first.of]
</p>
<blockquote><p>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty. &mdash; <i>end note</i>]
</p></blockquote>

<p>
25.3.13 [alg.search]
</p>

<p>
What is the expected result if <tt>[first2, last2)</tt> is empty?
</p>

<p>
I believe the wording suggests the algorithm should return <tt>last1</tt> in this
case, but am not 100% sure. Is this in fact the correct result anyway? 
Surely an empty range should always match and the naive expected result
would be <tt>first1</tt>?
</p>

<p>
My proposed wording is a note to clarify the current semantic:
</p>

<p>
Add to p2 25.3.13 [alg.search]:
</p>

<blockquote><p>
[<i>Note:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty. &mdash; <i>end note</i>]
</p></blockquote>

<p>
Again, I would prefer a normative wording treating empty ranges
specially, but do not believe we can change semantics at this point in
the process, unless existing implementations actually yield this result:
</p>

<p>
Alternative wording: (NOT a note)
</p>
<p>
Add to p2 25.3.13 [alg.search]:
</p>

<blockquote><p>
Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty.
</p></blockquote>

<p>
25.4.14 [alg.partitions]
</p>

<p>
Is an empty range partitioned or not?
</p>

<p>
Proposed wording:
</p>

<p>
Add to p1 25.4.14 [alg.partitions]:
</p>

<blockquote><p>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
&mdash; <i>end note</i>]
</p></blockquote>

<p>
25.5.5.1 [includes]
</p>

<blockquote><p>
<i>Returns:</i> <tt>true</tt> if every element in the range
<tt>[first2,last2)</tt> is contained in the range
<tt>[first1,last1)</tt>. ...
</p></blockquote>

<p>
I really don't know what this means if <tt>[first2,last2)</tt> is empty.
I could loosely guess that this implies empty ranges always match, and
my proposed wording is to clarify exactly that:
</p>

<p>
Add to p1 25.5.5.1 [includes]:
</p>

<blockquote><p>
[<i>Note:</i> Returns <tt>true</tt> if <tt>[first2,last2)</tt> is empty.
&mdash; <i>end note</i>]
</p></blockquote>

<p>
25.5.6.2 [pop.heap]
</p>

<p>
The effects clause is invalid if the range <tt>[first,last)</tt> is empty, unlike
all the other heap alogorithms.  The should be called out in the
requirements.
</p>

<p>
Proposed wording:
</p>
<p>
Revise p2 25.5.6.2 [pop.heap]
</p>

<blockquote><p>
<i>Requires:</i> The range <tt>[first,last)</tt> shall be a valid
<ins>non-empty</ins> heap.
</p></blockquote>

<p>
[Editorial] Reverse order of 25.5.6.2 [pop.heap] p1 and p2.
</p>

<p>
25.5.7 [alg.min.max]
</p>

<p>
<tt>minmax_element</tt> does not clearly specify behaviour for an empty
range in the same way that <tt>min_element</tt> and <tt>max_element</tt> do.
</p>

<p>
Add to p31 25.5.7 [alg.min.max]:
</p>

<blockquote><p>
Returns <tt>make_pair(first, first)</tt> if <tt>first == last</tt>.
</p></blockquote>

<p>
25.5.9 [alg.lex.comparison]
</p>

<p>
The wording here seems quite clear, especially with the sample algorithm
implementation.  A note is recommended purely for consistency with the
rest of these issue resolutions:
</p>

<p>
Add to p1 25.5.9 [alg.lex.comparison]:
</p>

<blockquote><p>
[<i>Note:</i> An empty sequence is lexicographically less than any other
non-empty sequence, but not to another empty sequence. &mdash; <i>end note</i>]
</p></blockquote>

<p><i>[
2009-11-11 Howard changes Notes to Remarks and changed <tt>search</tt> to
return <tt>first1</tt> instead of <tt>last1</tt>.
]</i></p>


<p><i>[
2009-11-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Add to 25.3.1 [alg.all_of]:
</p>
<blockquote><p><ins>
<i>Remarks:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
</ins></p></blockquote>

<p>
Add to 25.3.2 [alg.any_of]:
</p>

<blockquote><p><ins>
<i>Remarks:</i> Returns <tt>false</tt> if <tt>[first,last)</tt> is empty. 
</ins></p></blockquote>

<p>
Add to 25.3.3 [alg.none_of]:
</p>
<blockquote><p><ins>
<i>Remarks:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
</ins></p></blockquote>

<p>
Add to 25.3.6 [alg.find.end]:
</p>
<blockquote><p><ins>
<i>Remarks:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.
</ins></p></blockquote>

<p>
Add to 25.3.7 [alg.find.first.of]
</p>
<blockquote><p><ins>
<i>Remarks:</i> Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is
empty.
</ins></p></blockquote>

<p>
Add to 25.3.13 [alg.search]:
</p>
<blockquote><p><ins>
<i>Remarks:</i> Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is
empty.
</ins></p></blockquote>

<p>
Add to 25.4.14 [alg.partitions]:
</p>
<blockquote><p><ins>
<i>Remarks:</i> Returns <tt>true</tt> if <tt>[first,last)</tt> is empty. 
</ins></p></blockquote>

<p>
Add to 25.5.5.1 [includes]:
</p>
<blockquote><p><ins>
<i>Remarks:</i> Returns <tt>true</tt> if <tt>[first2,last2)</tt> is empty. 
</ins></p></blockquote>

<p>
Revise p2 25.5.6.2 [pop.heap]
</p>
<blockquote><p>
<i>Requires:</i> The range <tt>[first,last)</tt> shall be a valid
<ins>non-empty</ins> heap.
</p></blockquote>

<p>
[Editorial] 
</p>
<blockquote><p>
Reverse order of 25.5.6.2 [pop.heap] p1 and p2.
</p></blockquote>

<p>
Add to p35 25.5.7 [alg.min.max]:
</p>
<blockquote><pre>
template&lt;class ForwardIterator, class Compare&gt;
  pair&lt;ForwardIterator, ForwardIterator&gt;
    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
</pre>
<blockquote><p>
<i>Returns:</i> <tt>make_pair(m, M)</tt>, where <tt>m</tt> is the first iterator in
<tt>[first,last)</tt> such that no iterator in the range refers to a smaller
element, and where <tt>M</tt> is the last iterator in <tt>[first,last)</tt> such that no
iterator in the range refers to a larger element. 
<ins>Returns <tt>make_pair(first, first)</tt> if <tt>first == last</tt>.</ins>
</p></blockquote>
</blockquote>

<p>
Add to 25.5.9 [alg.lex.comparison]:
</p>
<blockquote><p><ins>
<i>Remarks:</i> An empty sequence is lexicographically less than any other
non-empty sequence, but not less than another empty sequence.
</ins></p></blockquote>






</body>
</html>
