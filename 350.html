<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 350: allocator&lt;&gt;::address</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="350" href="#350">350.</a> allocator&lt;&gt;::address</h3>
<p><b>Section:</b> 20.10.9.1 [allocator.members], 17.6.3.5 [allocator.requirements], 17.6.1.1 [contents] <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2001-10-25 <b>Last modified:</b> 2016-11-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-defects.html#634">634</a></p>
<p><b>Discussion:</b></p>
<p>See c++std-lib-9006 and c++std-lib-9007.  This issue is taken
verbatim from -9007.</p>

<p>
The core language feature allowing definition of operator&amp;() applied 
to any non-builtin type makes that operator often unsafe to use in 
implementing libraries, including the Standard Library.  The result
is that many library facilities fail for legal user code, such as
the fragment</p>
<pre>
  class A { private: A* operator&amp;(); };
  std::vector&lt;A&gt; aa;

  class B { };
  B* operator&amp;(B&amp;) { return 0; }
  std::vector&lt;B&gt; ba;
</pre>

<p>
In particular, the requirements table for Allocator (Table 32) specifies
no semantics at all for member address(), and allocator&lt;&gt;::address is 
defined in terms of unadorned operator &amp;.
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 20.6.1.1, Change the definition of allocator&lt;&gt;::address from:</p>
<blockquote><p>
  Returns: &amp;x
</p></blockquote>

<p>to:</p>

<p>
  Returns: The value that the built in operator&amp;(x) would return if not 
  overloaded.
</p>

<p>
In 20.1.6, Table 32, add to the Notes column of the a.address(r) and
a.address(s) lines, respectively: 
</p>

<pre>
  allocator&lt;T&gt;::address(r)
  allocator&lt;T&gt;::address(s)
</pre> 

<p>In addition, in clause 17.4.1.1, add a statement:</p>

<blockquote><p>
 The Standard Library does not apply operator&amp; to any type for which
 operator&amp; may be overloaded.
</p></blockquote> 



<p><b>Rationale:</b></p>
<p>The LWG believes both examples are ill-formed.  The contained type
is required to be CopyConstructible (17.6.3.1 [utility.arg.requirements]), and that
includes the requirement that &amp;t return the usual types and
values. Since allocators are intended to be used in conjunction with
containers, and since the CopyConstructible requirements appear to
have been written to deal with the concerns of this issue, the LWG
feels it is NAD unless someone can come up with a well-formed example
exhibiting a problem.</p>

<p>It may well be that the CopyConstructible requirements are too
  restrictive and that either the container requirements or the
  CopyConstructive requirements should be relaxed, but that's a far
  larger issue.  Marking this issue as "future" as a pointer to that
  larger issue.</p>





</body>
</html>
