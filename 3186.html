<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 3186: ranges removal, partition, and partial_sort_copy algorithms discard useful information</title>
<meta property="og:title" content="Issue 3186: ranges removal, partition, and partial_sort_copy algorithms discard useful information">
<meta property="og:description" content="C++ library issue. Status: C++20">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/3186.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="3186"><a href="lwg-defects.html#3186">3186</a>. <code>ranges</code> removal, partition, and <code>partial_sort_copy</code> algorithms discard useful information</h3>
<p><b>Section:</b> 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>, 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a>, 26.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/partial.sort.copy">[partial.sort.copy]</a>, 26.8.5 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> <b>Status:</b> <a href="lwg-active.html#C++20">C++20</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2019-02-05 <b>Last modified:</b> 2021-02-25</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++20">C++20</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is direct follow-up on the LWG issue <a href="3169" title="ranges permutation generators discard useful information (Status: C++20)">3169</a>, that proposed to change additional algorithms that drop the 
iterator value equal to sentinel, that needs to be always computed. These set include removal (<code>remove</code>, 
<code>remove_if</code>, and <code>unique</code>), partition (<code>partition</code>, <code>stable_partition</code>), 
and <code>partial_sort_copy</code>.
<p/>
For removal algorithms, the end of "not-erased" objects, and the "end-of-range" iterator forms a valid range of objects 
with unspecified value (that can be overwritten), thus we propose to return <code>subrange</code>.
<p/>
For partition algorithms, the end of "true" object, and the "end-of-range" iterator forms a valid range of objects for 
which predicate returns "false", thus we propose to return <code>subrange</code>.
<p/>
For <code>partial_sort_copy</code> we propose to return <code>partial_sort_copy_result</code> as an alias to 
<code>copy_result</code> to match other copy algorithms.
</p>

<p><i>[2019-02-12; Tomasz comments and improves proposed wording]</i></p>

<p>
Proposed wording is updated to incorporate wording comments from Casey Carter:
</p>
<ul>
<li><p>We don't need to repeat the definition of <code>partial_sort_copy_result</code> in 26.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/partial.sort.copy">[partial.sort.copy]</a>; 
the single definition in the synopsis is sufficient.</p></li>
<li><p><code><i>e</i></code> is a potentially confusing choice of placeholder name for the end of the output range, given that 
we use a placeholder <code><i>E</i></code> for predicates in the algorithm specifications.</p></li>
</ul>
<p>
The placeholder <code><i>e</i></code> is replaced with <code><i>j</i></code> that seems not to be used in the specification of 
above algorithms.
</p>

<p><i>[2019-02 Priority set to 1 after reflector discussion]</i></p>

<p><i>[2019-02; Kona Wednesday night issue processing]</i></p>

<p>Status to Ready</p>


<p id="res-3186"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4800">N4800</a>.</p>

<ol>
<li><p>Change header <code>&lt;algorithm&gt;</code> synopsis, 26.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a>, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
<i>//26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>, remove</i>
[&hellip;]
namespace ranges {
template&lt;Permutable I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;ranges::equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> remove(I first, S last, const T&amp; value, Proj proj = {});
template&lt;ForwardRange R, class T, class Proj = identity&gt;
  requires Permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
           IndirectRelation&lt;ranges::equal_to&lt;&gt;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
  constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
    remove(R&amp;&amp; r, const T&amp; value, Proj proj = {});
template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> remove_if(I first, S last, Pred pred, Proj proj = {});
template&lt;ForwardRange R, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;R&gt;&gt;
  constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
    remove_if(R&amp;&amp; r, Pred pred, Proj proj = {});
}
[&hellip;]
<i>// 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a>, unique</i>
[&hellip;]
namespace ranges {
  template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&lt;&gt;&gt;
    constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> unique(I first, S last, C comp = {}, Proj proj = {});
  template&lt;ForwardRange R, class Proj = identity,
           IndirectRelation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&lt;&gt;&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
    constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
      unique(R&amp;&amp; r, C comp = {}, Proj proj = {});
}
[&hellip;]
<i>// 26.8.2 <a href="https://timsong-cpp.github.io/cppwp/alg.sort">[alg.sort]</a>, sorting</i>
[&hellip;]
namespace ranges {
  <ins>template&lt;class I, class O&gt; using partial_sort_copy_result = copy_result&lt;I, O&gt;;</ins>

  template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, RandomAccessIterator I2, Sentinel&lt;I2&gt; S2,
           class Comp = ranges::less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;I1, I2&gt; &amp;&amp; Sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
             IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
    constexpr <ins>partial_sort_copy_result&lt;I1, </ins>I2<ins>&gt;</ins>
      partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template&lt;InputRange R1, RandomAccessRange R2, class Comp = ranges::less&lt;&gt;,
           class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt; &amp;&amp;
             Sortable&lt;iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;
             IndirectStrictWeakOrder&lt;Comp, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                     projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;
    constexpr <ins>partial_sort_copy_result&lt;safe_iterator_t&lt;R1&gt;, </ins>safe_iterator_t&lt;R2&gt;<ins>&gt;</ins>
      partial_sort_copy(R1&amp;&amp; r, R2&amp;&amp; result_r, Comp comp = {},
                        Proj1 proj1 = {}, Proj2 proj2 = {});
}
[&hellip;]
<i>// 26.8.5 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a>, partitions</i>
[&hellip;]
namespace ranges {
  template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins>
      partition(I first, S last, Pred pred, Proj proj = {});
  template&lt;ForwardRange R, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
    constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
      partition(R&amp;&amp; r, Pred pred, Proj proj = {});
}
[&hellip;]
namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;I&gt;
      <ins>subrange&lt;</ins>I<ins>&gt;</ins> stable_partition(I first, S last, Pred pred, Proj proj = {});
  template&lt;BidirectionalRange R, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt; stable_partition(R&amp;&amp; r, Pred pred, Proj proj = {});
}
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
namespace ranges {
template&lt;Permutable I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;ranges::equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> remove(I first, S last, const T&amp; value, Proj proj = {});
template&lt;ForwardRange R, class T, class Proj = identity&gt;
  requires Permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
           IndirectRelation&lt;ranges::equal_to&lt;&gt;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
  constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
    remove(R&amp;&amp; r, const T&amp; value, Proj proj = {});
template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> remove_if(I first, S last, Pred pred, Proj proj = {});
template&lt;ForwardRange R, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;R&gt;&gt;
  constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
    remove_if(R&amp;&amp; r, Pred pred, Proj proj = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Returns:</i> <ins>Let <code><i>j</i></code> be t</ins><del>T</del>he end of the resulting range. <ins>Returns:</ins>
<ol style="list-style-type: none">
<li><p><ins>(4.?) &mdash; <code><i>j</i></code> for the overloads in namespace <code>std</code>, or</ins></p></li>
<li><p><ins>(4.?) &mdash; <code>{<i>j</i>, last}</code> for the overloads in namespace <code>ranges</code>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&lt;&gt;&gt;
    constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> unique(I first, S last, C comp = {}, Proj proj = {});
  template&lt;ForwardRange R, class Proj = identity,
           IndirectRelation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&lt;&gt;&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
    constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
      unique(R&amp;&amp; r, C comp = {}, Proj proj = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Returns:</i> <ins>Let <code><i>j</i></code> be t</ins><del>T</del>he end of the resulting range. <ins>Returns:</ins>
<ol style="list-style-type: none">
<li><p><ins>(4.?) &mdash; <code><i>j</i></code> for the overloads in namespace <code>std</code>, or</ins></p></li>
<li><p><ins>(4.?) &mdash; <code>{<i>j</i>, last}</code> for the overloads in namespace <code>ranges</code>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 26.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/partial.sort.copy">[partial.sort.copy]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, RandomAccessIterator I2, Sentinel&lt;I2&gt; S2,
           class Comp = ranges::less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;I1, I2&gt; &amp;&amp; Sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
             IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
    constexpr <ins>partial_sort_copy_result&lt;I1, </ins>I2<ins>&gt;</ins>
      partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template&lt;InputRange R1, RandomAccessRange R2, class Comp = ranges::less&lt;&gt;,
           class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt; &amp;&amp;
             Sortable&lt;iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;
             IndirectStrictWeakOrder&lt;Comp, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                     projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;
    constexpr <ins>partial_sort_copy_result&lt;safe_iterator_t&lt;R1&gt;, </ins>safe_iterator_t&lt;R2&gt;<ins>&gt;</ins>
      partial_sort_copy(R1&amp;&amp; r, R2&amp;&amp; result_r, Comp comp = {},
                        Proj1 proj1 = {}, Proj2 proj2 = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Returns:</i> 
<ol style="list-style-type: none">
<li><p><ins>(4.?) &mdash;</ins> <code>result_first + <i>N</i></code> <ins>for the overloads in namespace <code>std</code>, or</ins></p></li>
<li><p><ins>(4.?) &mdash; <code>{last, result_first + <i>N</i>}</code> for the overloads in namespace <code>ranges</code>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 26.8.5 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins>
      partition(I first, S last, Pred pred, Proj proj = {});
  template&lt;ForwardRange R, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
    constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
      partition(R&amp;&amp; r, Pred pred, Proj proj = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Returns:</i> <ins>Let <code>i</code> be a</ins><del>A</del>n iterator <del><code>i</code></del> such that <code><i>E</i>(*j)</code> is 
<code>true</code> for every iterator <code>j</code> in <code>[first, i)</code> and <code>false</code> for every iterator <code>j</code> in 
<code>[i, last)</code>. <ins>Returns:</ins>
<ol style="list-style-type: none">
<li><p><ins>(7.?) &mdash; <code>i</code> for the overloads in namespace <code>std</code>, or</ins></p></li>
<li><p><ins>(7.?) &mdash; <code>{i, last}</code> for the overloads in namespace <code>ranges</code>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;I&gt;
      <ins>subrange&lt;</ins>I<ins>&gt;</ins> stable_partition(I first, S last, Pred pred, Proj proj = {});
  template&lt;BidirectionalRange R, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt; stable_partition(R&amp;&amp; r, Pred pred, Proj proj = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-11- <i>Returns:</i> <ins>Let <code>i</code> be a</ins><del>A</del>n iterator <del><code>i</code></del> such that for every iterator 
<code>j</code> in <code>[first, i)</code>, <code><i>E</i>(*j)</code> is <code>true</code>, and for every iterator <code>j</code> in the range 
<code>[i, last)</code>, <code><i>E</i>(*j)</code> is <code>false</code><del>,</del><ins>. Returns:</ins>
<ol style="list-style-type: none">
<li><p><ins>(11.?) &mdash; <code>i</code> for the overloads in namespace <code>std</code>, or</ins></p></li>
<li><p><ins>(11.?) &mdash; <code>{i, last}</code> for the overloads in namespace <code>ranges</code>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>




</body>
</html>
