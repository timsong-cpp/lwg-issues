<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2398: type_info's destructor shouldn't be required to be virtual</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-27 at 15:11:00 UTC</p>
<hr>
<h3><a name="2398" href="2398">2398.</a> <tt>type_info</tt>'s destructor shouldn't be required to be virtual</h3>
<p><b>Section:</b> 18.7.2 [type.info] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-06-14 <b>Last modified:</b> 2016-08-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#type.info">issues</a> in [type.info].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>type_info</tt>'s destructor is depicted as being <tt>virtual</tt>, which is nearly unobservable to users (since they can't construct 
or copy this class, they can't usefully derive from it). However, it's technically observable (via <tt>is_polymorphic</tt> and 
<tt>has_virtual_destructor</tt>). It also imposes real costs on implementations, requiring them to store one vptr per 
<tt>type_info</tt> object, when RTTI space consumption is a significant concern.
<p/>
Making this implementation-defined wouldn't affect users (who can observe this only if they're specifically looking for it) and 
wouldn't affect implementations who need <tt>virtual</tt> here, but it would allow other implementations to drop <tt>virtual</tt> 
and improve their RTTI space consumption.
<p/>
Richard Smith:
<p/>
It's observable in a few other ways.
</p>
<blockquote><pre>
std::map&lt;void*, something&gt; m;
m[dynamic_cast&lt;void*&gt;(&amp;typeid(blah))] = stuff;
</pre></blockquote>
<p>
... is broken by this change, because you can't <tt>dynamic_cast</tt> a non-polymorphic class type to <tt>void*</tt>.
</p>
<blockquote><pre>
type_info&amp; f();
typeid(f());
</pre></blockquote>
<p>
... evaluates <tt>f()</tt> at runtime without this change, and might not do so with this change.
<p/>
These are probably rare things, but I can imagine at least some forms of the latter being used in SFINAE tricks.
</p>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Marshall to poll LEWG for their opinion</p>

<p><i>[2016-06]</i></p>
 
<p>
On the <a href="http://lists.isocpp.org/lib-ext/2016/06/2451.php">reflector</a>, STL wrote:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>We'll prototype this change and report back with data in the future.</p></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>No update from STL. Set priority to P3</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 18.7.2 [type.info] as indicated:</p>

<blockquote>
<pre>
namespace std {
  class type_info {
  public:
    <del>virtual</del><ins><i>see below</i></ins> ~type_info();
    [&hellip;]
  };
}
</pre>
<p>
-1- The class <tt>type_info</tt> describes type information generated by the implementation. Objects of this class
effectively store a pointer to a name for the type, and an encoded value suitable for comparing two types for
equality or collating order. The names, encoding rule, and collating sequence for types are all unspecified
and may differ between programs. <ins>Whether <tt>~type_info()</tt> is <tt>virtual</tt> is implementation-defined.</ins>
</p>
</blockquote>
</li>
</ol>





</body>
</html>
