<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2963: Algorithms with underspecified iterator requirements</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="2963" href="2963">2963.</a> Algorithms with underspecified iterator requirements</h3>
<p><b>Section:</b> 28 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>, 29 <a href="https://timsong-cpp.github.io/cppwp/numerics">[numerics]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ga&scaron;per A&zcaron;man <b>Opened:</b> 2017-05-10 <b>Last modified:</b> 2017-05-13 13:53:08 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While researching whether the proposed resolution of Iterators of Containers of move-only types do not model <tt>InputIterator</tt>
(LWG <a href="2962">2962</a>), I came across several algorithms that underspecify their requirements, mostly with regard to some associated type of the iterator type they operate on. A list can be found below.
<p/>
The list of algorithms with underspecified requirements from <tt>&lt;algorithm&gt;</tt> and <tt>&lt;numeric&gt;</tt> follows.
<p/>
With the advent of concepts, these algorithms will need better specifications if we are ever hoping to be allowed to overload based on them. I want this issue to bring the standard algorithms closer to having their concept requirements directly transcribable to library annotations.
<p/>
Suggested resolution:
</p>
<ol>
<li>
<p><tt>copy</tt>, <tt>copy_if</tt>, <tt>copy_n</tt>, <tt>copy_backward</tt></p>
<p>Add to description: <tt>reference</tt> of <tt>first</tt> must be <tt>CopyAssignable</tt> to <tt>*result</tt>.</p>
</li>
<li>
<p><tt>move</tt>, <tt>move_if</tt>, <tt>move_backward</tt></p>
<p>Add to description: <tt>reference</tt> of <tt>first</tt> must be <tt>CopyAssignable</tt> to <tt>*result</tt>.</p>
</li>
<li>
<p><tt>transform</tt></p>
<p>Add to description: <tt>OutputIterator</tt> must be writable with <tt>op</tt> or <tt>binary_op</tt>'s return type.</p>
</li>
<li>
<p><tt>rotate_copy</tt></p>
<p>Add to description: <tt>reference</tt> of <tt>InputIterator</tt> must be writable to <tt>OutputIterator</tt>.</p>
</li>
<li>
<p><tt>merge</tt></p>
<p>Add to description: <tt>reference</tt> of both <tt>InputIterator1</tt> and <tt>InputIterator2</tt> must be writable 
to <tt>OutputIterator</tt>.</p>
</li>
<li>
<p><tt>set_union</tt>, <tt>set_intersection</tt>, <tt>set_difference</tt>, <tt>set_symmetric_difference</tt></p>
<p>Add to description: <tt>reference</tt> of both <tt>InputIterator1</tt> and <tt>InputIterator2</tt> must be writable to 
<tt>OutputIterator</tt>.</p>
</li>
<li>
<p><tt>partial_sum</tt></p>
<p>
<tt>acc</tt> is not defined.
<p/>
Change description: <tt>acc</tt>, a variable of <tt>InputIterator</tt>'s value type, shall be constructible
</p>
</li>
<li>
<p><tt>exclusive_scan</tt>, <tt>inclusive_scan</tt></p>
<p>Forgets to specify that <tt>OutputIterator</tt> must be assignable from the result type of <tt>BinaryOperation</tt>. Also, 
forgets to specify the traversal characteristic of <tt>OutputIterator</tt>.</p>
</li>
<li>
<p><tt>adjacent_difference</tt></p>
<p>
<tt>acc</tt> is not defined.
<p/>
Change description: <tt>acc</tt>, a variable of <tt>InputIterator</tt>'s value type, shall be <tt>MoveAssignable</tt> and shall be 
<tt>constructible</tt> from the type of <tt>*first</tt>.
</p>
</li>
<li>
<p><tt>iota</tt></p>
<p>
<tt>iota</tt> is mis-specified. Since the expression we need to support is <tt>*first = value</tt>: <tt>*first</tt> 
is required to be of type <tt>InputIterator::reference</tt>, and value is an lvalue of type <tt>T</tt>. The current 
specification allows calling iota with a non-mutable iterator. More-over this description needn't change if we ever 
get smart references.
<p/>
<del><tt>T</tt> shall be convertible to <tt>ForwardIterator</tt>'s value type</del><ins><tt>ForwardIterator</tt>'s 
<tt>reference</tt> type shall be <tt>CopyAssignable</tt> from <tt>T</tt></ins>.
</p>
</li>
</ol>


<p><b>Proposed resolution:</b></p>





</body>
</html>
