<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3120: Unclear behavior of monotonic_buffer_resource::release()</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="3120" href="lwg-active.html#3120">3120.</a> Unclear behavior of <tt>monotonic_buffer_resource::release()</tt></h3>
<p><b>Section:</b> 19.12.6.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.monotonic.buffer.mem">[mem.res.monotonic.buffer.mem]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2018-06-10 <b>Last modified:</b> 2018-06-25 00:47:25 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.res.monotonic.buffer.mem">issues</a> in [mem.res.monotonic.buffer.mem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects of <tt>monotonic_buffer_resource::release()</tt> are defined as:
</p>
<blockquote>
<p>
Calls <tt>upstream_rsrc-&gt;deallocate()</tt> as necessary to release all allocated memory.
</p>
</blockquote>
<p>
This doesn't give any instruction on what to do with the memory controlled by the <tt>monotonic_buffer_resource</tt> which 
was not allocated, i.e., what to do with the initial buffer provided to its constructor.
<p/>
Boost.Container's pmr implementation expels its initial buffer after a <tt>release()</tt>.
Arthur O'Dwyer's proposed pmr implementation for libc++ reuses the initial buffer after a <tt>release()</tt>, on the 
assumption that this is what the average library user will be expecting.
</p>
<blockquote>
<pre>
#include &lt;memory_resource&gt;

int main() 
{
  char buffer[100];
  {
    std::pmr::monotonic_buffer_resource mr(buffer, 100, std::pmr::null_memory_resource());
    mr.release();
    mr.allocate(60);  // A
  }
  {
    std::pmr::monotonic_buffer_resource mr(buffer, 100, std::pmr::null_memory_resource());
    mr.allocate(60);  // B
    mr.release();
    mr.allocate(60);  // C
  }
}
</pre>
</blockquote>
<p>
Assume that allocation "B" always succeeds.<br/>
With the proposed libc++ implementation, allocations "A" and "C" both succeed.<br/>
With Boost.Container's implementation, allocations "A" and "C" both fail.<br/>
Using another plausible implementation strategy, allocation "A" could succeed but allocation "C" 
could fail. I have been informed that MSVC's implementation does this.
<p/>
Which of these strategies should be permitted by the Standard?
<p/>
Arthur considers "A and C both succeed" to be the obviously most user-friendly strategy, and really 
really hopes it's going to be permitted. Requiring "C" to succeed is unnecessary (and would render MSVC's 
current implementation non-conforming) but could help programmers concerned with portability between 
different implementations.
<p/>
Another side-effect of <tt>release()</tt> which goes underspecified by the Standard is the effect of 
<tt>release()</tt> on <tt>next_buffer_size</tt>. As currently written, my interpretation is that 
<tt>release()</tt> is not permitted to decrease <tt>current_buffer_size</tt>; I'm not sure if this 
is a feature or a bug.
<p/>
Consider this test case (taken from <a href="https://reviews.llvm.org/D47111#inline-421469">here</a>):
</p>
<blockquote>
<pre>
std::pmr::monotonic_buffer_resource mr(std::pmr::new_delete_resource());
for (int i=0; i &lt; 100; ++i) {
  mr.allocate(1);  // D
  mr.release();
}
</pre>
</blockquote>
<p>
Arthur believes it is important that the 100<sup>th</sup> invocation of line "D" does not attempt to allocate 
2<sup>100</sup> bytes from the upstream resource.
</p>

<p><i>[2018-06-23 after reflector discussion]</i></p>

<p>Priority set to 2</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The resolution depicted below would make MSVC's and my-proposed-libc++'s implementations 
both conforming.]</p>
</blockquote>

<ol>
<li><p>Modify 19.12.6.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.monotonic.buffer.mem">[mem.res.monotonic.buffer.mem]</a> as indicated:</p>
<blockquote>
<pre>
void release();
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <tt>upstream_rsrc-&gt;deallocate()</tt> as necessary to release all allocated memory. 
<ins>Resets the state of the initial buffer.</ins>
<p/>
-2- [<i>Note:</i> The memory is released back to <tt>upstream_rsrc</tt> even if some blocks that were allocated from
this have not been deallocated from this. <ins>This function has an unspecified effect on <tt>next_buffer_size</tt>.</ins> 
&mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
