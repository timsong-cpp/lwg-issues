<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 2484: rethrow_if_nested() is doubly unimplementable</title>
<meta property="og:title" content="Issue 2484: rethrow_if_nested() is doubly unimplementable">
<meta property="og:description" content="C++ library issue. Status: C++17">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/2484.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="2484"><a href="lwg-defects.html#2484">2484</a>. <code>rethrow_if_nested()</code> is doubly unimplementable</h3>
<p><b>Section:</b> 17.9.8 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> <b>Status:</b> <a href="lwg-active.html#C++17">C++17</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2015-03-27 <b>Last modified:</b> 2017-07-30</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++17">C++17</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>rethrow_if_nested()</code> wants to determine "If the dynamic type of <code>e</code> is publicly and unambiguously derived 
from <code>nested_exception</code>", but 7.6.1.7 <a href="https://timsong-cpp.github.io/cppwp/expr.dynamic.cast">[expr.dynamic.cast]</a> specifies that <code>dynamic_cast</code> has a couple 
of limitations.
<p/>
First, nonpolymorphic inputs. These could be non-classes, or nonpolymorphic classes. The Standardese handles non-classes, 
although implementers need special logic. (If <code>E</code> is <code>int</code>, the dynamic type can't possibly derive from 
<code>nested_exception</code>. Implementers need to detect this and avoid <code>dynamic_cast</code>, which would be ill-formed 
due to 7.6.1.7 <a href="https://timsong-cpp.github.io/cppwp/expr.dynamic.cast">[expr.dynamic.cast]</a>/2.) The Standardese is defective when <code>E</code> is a nonpolymorphic class.  
Consider the following example:
</p>
<blockquote>
<pre>
struct Nonpolymorphic { };
struct MostDerived : Nonpolymorphic, nested_exception { };
MostDerived md;
const Nonpolymorphic&amp; np = md;
rethrow_if_nested(np);
</pre>
</blockquote>
<p>
According to 3.19 <a href="https://timsong-cpp.github.io/cppwp/defns.dynamic.type">[defns.dynamic.type]</a>, the dynamic type of <code>np</code> is <code>MostDerived</code>. However, it's 
physically impossible to discover this, and attempting to do so will lead to an ill-formed <code>dynamic_cast</code> 
(7.6.1.7 <a href="https://timsong-cpp.github.io/cppwp/expr.dynamic.cast">[expr.dynamic.cast]</a>/6). The Standardese must be changed to say that if <code>E</code> is nonpolymorphic, nothing happens.
<p/>
Second, statically good but dynamically bad inputs. Consider the following example:
</p>
<blockquote>
<pre>
struct Nested1 : nested_exception { };
struct Nested2 : nested_exception { };
struct Ambiguous : Nested1, Nested2 { };
Ambiguous amb;
const Nested1&amp; n1 = amb;
rethrow_if_nested(n1);
</pre>
</blockquote>
<p>
Here, the static type <code>Nested1</code> is good (i.e. publicly and unambiguously derived from <code>nested_exception</code>), but 
the dynamic type <code>Ambiguous</code> is bad. The Standardese currently says that we have to detect the dynamic badness, but 
<code>dynamic_cast</code> won't let us. 7.6.1.7 <a href="https://timsong-cpp.github.io/cppwp/expr.dynamic.cast">[expr.dynamic.cast]</a>/3 and /5 are special cases (identity-casting and upcasting, 
respectively) that activate before the "run-time check" behavior that we want (/6 and below). Statically good inputs succeed 
(regardless of the dynamic type) and statically bad inputs are ill-formed (implementers must use type traits to avoid this).
<p/>
It might be possible to implement this with clever trickery involving virtual base classes, but implementers shouldn't be asked 
to do that.  It would definitely be possible to implement this with a compiler hook (a special version of <code>dynamic_cast</code>), 
but implementers shouldn't be asked to do so much work for such an unimportant case. (This case is pathological because the 
usual way of adding <code>nested_exception</code> inheritance is <code>throw_with_nested()</code>, which avoids creating bad inheritance.)  
The Standardese should be changed to say that statically good inputs are considered good.
<p/>
Finally, we want <code>is_base_of</code>'s "base class or same class" semantics. If the static type is <code>nested_exception</code>, 
we have to consider it good due to <code>dynamic_cast</code>'s identity-casting behavior. And if the dynamic type is 
<code>nested_exception</code>, it is definitely good.
</p>

<p><i>[2015-05, Lenexa]</i></p>

<p>
WB: so the <code>is_polymorphic</code> trait must be used?<br/>
STL and JW: yes, that must be used to decide whether to try using <code>dynamic_cast</code> or not.<br/>
JW: I'd already made this fix in our implementation<br/>
STL: the harder case also involves <code>dynamic_cast</code>. should not try using <code>dynamic_cast</code> if we can 
statically detect it is OK, doing the <code>dynamic_cast</code> might fail.<br/>
STL: finally, want "is the same or derived from" behaviour of <code>is_base_of</code><br/>
WB: should there be an "else no effect" at the end? We have "Otherwise, if ..." and nothing saying what if the condition is false.<br/>
TP I agree.<br/>
MC: move to Ready and bring to motion on Friday<br/>
7 in favor, none opposed 
</p>


<p id="res-2484"><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 17.9.8 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> as depicted:</p>

<blockquote>
<pre>
template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
<p>
-9- <i>Effects</i>: If <ins><code>E</code> is not a polymorphic class type, there is no effect. Otherwise, if the static 
type or</ins> the dynamic type of <code>e</code> <ins>is <code>nested_exception</code> or</ins> is publicly and unambiguously 
derived from <code>nested_exception</code>, calls <code>dynamic_cast&lt;const nested_exception&amp;&gt;(e).rethrow_nested()</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






</body>
</html>
