<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2484: rethrow_if_nested() is doubly unimplementable</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-12-02 at 05:12:32 UTC</p>
<hr>
<h3><a name="2484" href="2484">2484.</a> <tt>rethrow_if_nested()</tt> is doubly unimplementable</h3>
<p><b>Section:</b> 18.8.7 [except.nested] <b>Status:</b> <a href="lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2015-03-27 <b>Last modified:</b> 2015-10-27</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>rethrow_if_nested()</tt> wants to determine "If the dynamic type of <tt>e</tt> is publicly and unambiguously derived 
from <tt>nested_exception</tt>", but 5.2.7 [expr.dynamic.cast] specifies that <tt>dynamic_cast</tt> has a couple 
of limitations.
<p/>
First, nonpolymorphic inputs. These could be non-classes, or nonpolymorphic classes. The Standardese handles non-classes, 
although implementers need special logic. (If <tt>E</tt> is <tt>int</tt>, the dynamic type can't possibly derive from 
<tt>nested_exception</tt>. Implementers need to detect this and avoid <tt>dynamic_cast</tt>, which would be ill-formed 
due to 5.2.7 [expr.dynamic.cast]/2.) The Standardese is defective when <tt>E</tt> is a nonpolymorphic class.  
Consider the following example:
</p>
<blockquote>
<pre>
struct Nonpolymorphic { };
struct MostDerived : Nonpolymorphic, nested_exception { };
MostDerived md;
const Nonpolymorphic&amp; np = md;
rethrow_if_nested(np);
</pre>
</blockquote>
<p>
According to 1.3.9 [defns.dynamic.type], the dynamic type of <tt>np</tt> is <tt>MostDerived</tt>. However, it's 
physically impossible to discover this, and attempting to do so will lead to an ill-formed <tt>dynamic_cast</tt> 
(5.2.7 [expr.dynamic.cast]/6). The Standardese must be changed to say that if <tt>E</tt> is nonpolymorphic, nothing happens.
<p/>
Second, statically good but dynamically bad inputs. Consider the following example:
</p>
<blockquote>
<pre>
struct Nested1 : nested_exception { };
struct Nested2 : nested_exception { };
struct Ambiguous : Nested1, Nested2 { };
Ambiguous amb;
const Nested1&amp; n1 = amb;
rethrow_if_nested(n1);
</pre>
</blockquote>
<p>
Here, the static type <tt>Nested1</tt> is good (i.e. publicly and unambiguously derived from <tt>nested_exception</tt>), but 
the dynamic type <tt>Ambiguous</tt> is bad. The Standardese currently says that we have to detect the dynamic badness, but 
<tt>dynamic_cast</tt> won't let us. 5.2.7 [expr.dynamic.cast]/3 and /5 are special cases (identity-casting and upcasting, 
respectively) that activate before the "run-time check" behavior that we want (/6 and below). Statically good inputs succeed 
(regardless of the dynamic type) and statically bad inputs are ill-formed (implementers must use type traits to avoid this).
<p/>
It might be possible to implement this with clever trickery involving virtual base classes, but implementers shouldn't be asked 
to do that.  It would definitely be possible to implement this with a compiler hook (a special version of <tt>dynamic_cast</tt>), 
but implementers shouldn't be asked to do so much work for such an unimportant case. (This case is pathological because the 
usual way of adding <tt>nested_exception</tt> inheritance is <tt>throw_with_nested()</tt>, which avoids creating bad inheritance.)  
The Standardese should be changed to say that statically good inputs are considered good.
<p/>
Finally, we want <tt>is_base_of</tt>'s "base class or same class" semantics. If the static type is <tt>nested_exception</tt>, 
we have to consider it good due to <tt>dynamic_cast</tt>'s identity-casting behavior. And if the dynamic type is 
<tt>nested_exception</tt>, it is definitely good.
</p>

<p><i>[2015-05, Lenexa]</i></p>

<p>
WB: so the <tt>is_polymorphic</tt> trait must be used?<br/>
STL and JW: yes, that must be used to decide whether to try using <tt>dynamic_cast</tt> or not.<br/>
JW: I'd already made this fix in our implementation<br/>
STL: the harder case also involves <tt>dynamic_cast</tt>. should not try using <tt>dynamic_cast</tt> if we can 
statically detect it is OK, doing the <tt>dynamic_cast</tt> might fail.<br/>
STL: finally, want "is the same or derived from" behaviour of <tt>is_base_of</tt><br/>
WB: should there be an "else no effect" at the end? We have "Otherwise, if ..." and nothing saying what if the condition is false.<br/>
TP I agree.<br/>
MC: move to Ready and bring to motion on Friday<br/>
7 in favor, none opposed 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 18.8.7 [except.nested] as depicted:</p>

<blockquote>
<pre>
template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
<p>
-9- <i>Effects</i>: If <ins><tt>E</tt> is not a polymorphic class type, there is no effect. Otherwise, if the static 
type or</ins> the dynamic type of <tt>e</tt> <ins>is <tt>nested_exception</tt> or</ins> is publicly and unambiguously 
derived from <tt>nested_exception</tt>, calls <tt>dynamic_cast&lt;const nested_exception&amp;&gt;(e).rethrow_nested()</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






</body>
</html>
