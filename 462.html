<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 462: Destroying objects with static storage duration</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-28 at 17:11:16 UTC</p>
<hr>
<h3><a name="462" href="462">462.</a> Destroying objects with static storage duration</h3>
<p><b>Section:</b> 3.6.4 [basic.start.term], 18.4 [cstdint] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-03-23 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
3.6.3 Termination spells out in detail the interleaving of static
destructor calls and calls to functions registered with atexit. To
match this behavior requires intimate cooperation between the code
that calls destructors and the exit/atexit machinery. The former
is tied tightly to the compiler; the latter is a primitive mechanism
inherited from C that traditionally has nothing to do with static
construction and destruction. The benefits of intermixing destructor
calls with atexit handler calls is questionable at best, and <i>very</i>
difficult to get right, particularly when mixing third-party C++
libraries with different third-party C++ compilers and C libraries
supplied by still other parties.
</p>

<p>
I believe the right thing to do is defer all static destruction
until after all atexit handlers are called. This is a change in
behavior, but one that is likely visible only to perverse test
suites. At the very least, we should <i>permit</i> deferred destruction
even if we don't require it.
</p>

<p><i>[If this is to be changed, it should probably be changed by CWG.
  At this point, however, the LWG is leaning toward NAD.  Implementing
  what the standard says is hard work, but it's not impossible and
  most vendors went through that pain years ago.  Changing this
  behavior would be a user-visible change, and would break at least
  one real application.]</i></p>


<p><i>[
Batavia:  Send to core with our recommendation that we should permit deferred
destruction but not require it.
]</i></p>


<p><i>[
Howard:  The course of action recommended in Batavia would undo LWG
issue <a href="3">3</a> and break current code implementing the "phoenix
singleton". Search the net for "phoenix singleton atexit" to get a feel
for the size of the adverse impact this change would have.  Below is
sample code which implements the phoenix singleton and would break if
<tt>atexit</tt> is changed in this way:
]</i></p>


<blockquote><pre>
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;new&gt;

class A
{
    bool alive_;
    A(const A&amp;);
    A&amp; operator=(const A&amp;);
public:
    A() : alive_(true) {std::cout &lt;&lt; "A()\n";}
    ~A() {alive_ = false; std::cout &lt;&lt; "~A()\n";}
    void use()
    {
        if (alive_)
            std::cout &lt;&lt; "A is alive\n";
        else
            std::cout &lt;&lt; "A is dead\n";
    }
};

void deallocate_resource();

// This is the phoenix singleton pattern
A&amp; get_resource(bool create = true)
{
    static std::aligned_storage&lt;sizeof(A), std::alignment_of&lt;A&gt;::value&gt;::type buf;
    static A* a;
    if (create)
    {
        if (a != (A*)&amp;buf)
        {
            a = ::new (&amp;buf) A;
            std::atexit(deallocate_resource);
        }
    }
    else
    {
        a-&gt;~A();
        a = (A*)&amp;buf + 1;
    }
    return *a;
}

void deallocate_resource()
{
    get_resource(false);
}

void use_A(const char* message)
{
    A&amp; a = get_resource();
    std::cout &lt;&lt; "Using A " &lt;&lt; message &lt;&lt; "\n";
    a.use();
}

struct B
{
    ~B() {use_A("from ~B()");}
};

B b;

int main()
{
    use_A("from main()");
}
</pre></blockquote>

<p>
The correct output is:
</p>

<blockquote><pre>
A()
Using A from main()
A is alive
~A()
A()
Using A from ~B()
A is alive
~A()
</pre></blockquote>

<p><i>[
Bellevue: Confirmed no interaction with <tt>quick_exit</tt>.
Strong feeling against mandating the change. Leaning towards NAD rather than permitting the change,
as this would make common implementations of pheonix-singleton pattern implementation defined, as noted by Howard.
Bill agrees issue is no longer serious, and accepts NAD.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





</body>
</html>
