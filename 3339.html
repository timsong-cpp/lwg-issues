<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 3339: Move-constructed empty-container capacity</title>
<meta property="og:title" content="Issue 3339: Move-constructed empty-container capacity">
<meta property="og:description" content="C++ library issue. Status: New">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/3339.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="3339"><a href="lwg-active.html#3339">3339</a>. Move-constructed empty-container capacity</h3>
<p><b>Section:</b> 27.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, 23.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a>, 23.5.3 <a href="https://timsong-cpp.github.io/cppwp/unord.map">[unord.map]</a>, 23.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a>, 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2019-11-17 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Standard leaves unspecified the <code>capacity()</code> of a <code>string</code> or <code>vector</code>, 
and <code>bucket_count()</code> of an <code>unordered_(multi)set</code> or <code>unordered_(multi)map</code>, 
constructed by move from an empty <code>other</code>.
<p/>
For a non-empty <code>other</code>, normative language in the Standard constrains the new object to 
use (mostly) the same storage as the other, by way of lifetime of iterators and pointers
to elements.
<p/>
For an empty <code>other</code>, there can be no such pointers or iterators. However, the empty 
container may have a non-zero <code>capacity()</code> or <code>bucket_count()</code>, and having reserved 
storage there, one naturally expects that storage to be delivered to the new object in the same 
way as if it had elements.
<p/>
Existing implementations, in fact, do move storage to the new container, provided it can be 
deallocated using the new object's allocator. It is likely that existing programs have come to 
depend on this behavior.
<p/>
The resolution proposed is to add language to the Standard specifying that, if the allocators 
of the existing and new container objects are compatible, the storage of the new object is the 
same as of the old, so that no allocations or deallocations are performed in the process, as 
existing implementations in fact do.
<p/>
This appears to affect only <code>string</code>, <code>vector</code>, <code>unordered_set</code>, 
<code>unordered_multiset</code>, <code>unordered_map</code>, and <code>unordered_multimap</code>, but any 
new container types may also need similar attention.
<p/>
Note that in the case of the hashed containers, the array of buckets appears not to be required 
to be moved, even when elements contained are. This seems to be a similar oversight; extant 
implementations do move the bucket array. The resolution should cover this case as well.
<p/>
It is expected and intended that the proposed resolution does not require changes to the behavior 
of implementations.
<p/>
See also LWG <a href="2321" title="Moving containers should (usually) be required to preserve iterators (Status: Open)">2321</a> and <a href="https://wg21.link/p0966r1">P0966R1</a>.
</p>

<p><i>[2019-11-30 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3339"><b>Proposed resolution:</b></p>




</body>
</html>
