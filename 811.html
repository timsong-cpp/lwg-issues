<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 811: pair of pointers no longer works with literal 0</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-15 at 21:11:26 UTC</p>
<hr>
<h3><a name="811" href="#811">811.</a> <tt>pair</tt> of pointers no longer works with literal 0</h3>
<p><b>Section:</b> 20.4 [pairs] <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2008-03-14 <b>Last modified:</b> 2016-11-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>
#include &lt;utility&gt;

int main()
{
   std::pair&lt;char *, char *&gt; p (0,0);
}
</pre></blockquote>

<p>
I just got a bug report about that, because it's valid C++03, but not
C++0x. The important realization, for me, is that the emplace
proposal---which made <tt>push_back</tt> variadic, causing the <tt>push_back(0)</tt>
issue---didn't cause this break in backward compatibility. The break
actually happened when we added this pair constructor as part of adding
rvalue references into the language, long before variadic templates or
emplace came along:
</p>

<blockquote><pre>
template&lt;class U, class V&gt; pair(U&amp;&amp; x, V&amp;&amp; y);
</pre></blockquote>

<p>
Now, concepts will address this issue by constraining that <tt>pair</tt>
constructor to only <tt>U</tt>'s and <tt>V</tt>'s that can properly construct "first" and
"second", e.g. (from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2322.pdf">N2322</a>):
</p>

<blockquote><pre>
template&lt;class U , class V &gt;
requires Constructible&lt;T1, U&amp;&amp;&gt; &amp;&amp; Constructible&lt;T2, V&amp;&amp;&gt;
pair(U&amp;&amp; x , V&amp;&amp; y );
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Suggested to resolve using pass-by-value for that case.
</p>
<p>
Side question: Should pair interoperate with tuples? Can construct a
tuple of a pair, but not a pair from a two-element tuple.
</p>
<p>
Related to <a href="lwg-defects.html#885">885</a>.
</p>
</blockquote>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave as open. Howard to provide wording.
</p></blockquote>

<p><i>[
2010-02-06 Howard provided wording.
]</i></p>


<p><i>[
2010-02-09 Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</p></blockquote>

<p><i>[
The rationale is obsolete.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph to 20.4 [pairs]:
</p>

<blockquote>
<pre>
template&lt;class U, class V&gt; pair(U&amp;&amp; x, V&amp;&amp; y);
</pre>
<blockquote>
<p>
6 <i>Effects:</i> The constructor initializes <tt>first</tt> with
<tt>std::forward&lt;U&gt;(x)</tt> and second with
<tt>std::forward&lt;V&gt;(y)</tt>.
</p>

<p>
<ins><i>Remarks:</i> <tt>U</tt> shall be implicitly convertible to
<tt>first_type</tt> and <tt>V</tt> shall be implicitly convertible to
<tt>second_type</tt>, else this constructor shall not participate in overload
resolution.</ins>
</p>
</blockquote>
</blockquote>






</body>
</html>
