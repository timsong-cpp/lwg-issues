<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3149: DefaultConstructible should require default initialization</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3><a name="3149" href="lwg-defects.html#3149">3149.</a> <tt>DefaultConstructible</tt> should require default initialization</h3>
<p><b>Section:</b> 18.4.12 <a href="https://timsong-cpp.github.io/cppwp/concept.default.init">[concept.default.init]</a> <b>Status:</b> <a href="lwg-active.html#C++20">C++20</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-08-09 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.default.init">issues</a> in [concept.default.init].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++20">C++20</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>DefaultConstructible&lt;T&gt;</tt> is equivalent to
<tt>Constructible&lt;T&gt;</tt> (18.4.11 <a href="https://timsong-cpp.github.io/cppwp/concept.constructible">[concept.constructible]</a>), which
is equivalent to <tt>is_constructible_v&lt;T&gt;</tt>
(20.15.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>). Per 20.15.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>
<a href="https://wg21.link/meta.unary.prop#8">paragraph 8</a>:
<blockquote>
<p>The predicate condition for a template specialization
<tt>is_Â­constructible&lt;T, Args...&gt;</tt> shall be satisfied if and only if
the following variable definition would be well-formed for some invented
variable <tt>t</tt>:</p>
<blockquote>
<pre>
T t(declval&lt;Args&gt;()...);
</pre>
</blockquote>
</blockquote>
<tt>DefaultConstructible&lt;T&gt;</tt> requires that objects of type <tt>T</tt>
can be
<a href="https://wg21.link/dcl.init#8"><i>value-initialized</i></a>,
rather than
<a href="https://wg21.link/dcl.init#7"><i>default-initialized</i></a>
as intended.
</p>
<p>
The library needs a constraint that requires object types to be
default-initializable: the "rangified" versions of the algorithms in
25.11.3 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.construct.default">[uninitialized.construct.default]</a> proposed in
<a href="https://wg21.link/p0896">P0896 "The One Ranges Proposal"</a>, for
example. Users will also want a mechanism to provide such a constraint, and
they're likely to choose <tt>DefaultConstructible</tt> despite its subtle
unsuitability.
</p>
<p>
There are two alternative solutions: (1) change <tt>DefaultConstructible</tt>
to require <i>default-initialization</i>, (2) change
<tt>is_default_constructible_v</tt> to require default-initializaton and specify
the concept in terms of the trait. (2) is probably too breaking a change to be
feasible.
</p>

<p><i>[2018-08-20 Priority set to 2 after reflector discussion]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<ol>
<li><p>Modify  [concept.defaultconstructible] as follows:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  concept DefaultConstructible = Constructible&lt;T&gt; <ins>&amp;&amp; see below</ins>;
</pre>
<p>
<ins>-?- Type <tt>T</tt> models <tt>DefaultConstructible</tt> only if the variable
definition</ins>
<blockquote>
<pre>
<ins>T t;</ins>
</pre>
</blockquote>
<ins>is well-formed for some invented variable <tt>t</tt>. Access checking is
performed as if in a context unrelated to <tt>T</tt>. Only the validity of the
immediate context of the variable initialization is considered.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-08-23 Tim provides updated P/R based on Batavia discussion]</i></p>


<p><i>[2018-10-28 Casey expands the problem statement and the P/R]</i></p>

<p>
During Batavia review of <a href="https://wg21.link/p0896r3">P0896R3</a>, Tim
Song noted that <tt>{}</tt> is not necessarily a valid initializer for a
<tt>DefaultConstructible</tt> type. In this sample program
(see <a href="https://godbolt.org/z/I64p_E">Compiler Explorer</a>):
<blockquote>
<pre>
struct S0 { explicit S0() = default; };
struct S1 { S0 x; }; // Note: aggregate
S1 x;   // Ok
S1 y{}; // ill-formed; copy-list-initializes x from {}
</pre>
</blockquote>
<tt>S1</tt> can be default-initialized, but not list-initialized from an empty
<i>braced-init-list</i>. The consensus among those present was that
<tt>DefaultConstructible</tt> should prohibit this class of pathological types
by requiring that initialization form to be valid.
</p>

<p><i>[2019 Cologne Wednesday night]</i></p>

<p>Status to Ready</p>

<p><i>[2019-10-07 Casey rebases P/R onto N4830 and incorporates WG21-approved changes from P1754R1]</i></p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>
<ol>
<li><p>Modify  [concept.defaultconstructible] as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;
  inline constexpr bool <i>is-default-initializable</i> = <i>see below</i>; // <i>exposition only</i></ins>

template&lt;class T&gt;
  concept DefaultConstructible = Constructible&lt;T&gt; <ins>&amp;&amp; requires { T{}; } &amp;&amp; <i>is-default-initializable</i>&lt;T&gt;</ins>;
</pre>
<p>
<ins>-?- For a type <tt>T</tt>, <tt><i>is-default-initializable</i>&lt;T&gt;</tt> is <tt>true</tt>
if and only if the variable definition</ins>
<blockquote>
<pre>
<ins>T t;</ins>
</pre>
</blockquote>
<ins>is well-formed for some invented variable <tt>t</tt>; otherwise it is <tt>false</tt>. Access checking is
performed as if in a context unrelated to <tt>T</tt>. Only the validity of the
immediate context of the variable initialization is considered.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>
<a href="https://wg21.link/p1754r1">P1754R1 "Rename concepts to <tt>standard_case</tt> for
C++20"</a> - as approved by both LEWG and LWG in Cologne - contained instructions to rename the
<tt>DefaultConstructible</tt> concept to <tt>default_initializable</tt> "If LWG 3151 is accepted."
<a href="3151">3151</a> is the unrelated "<tt>ConvertibleTo</tt> rejects conversion from array and
function types"; this issue is intended by P1754R1. Since P1754R1 was applied to the working draft
in Cologne, whereas this issue was only made Ready, we should apply the desired renaming to the P/R
of this issue.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 18.3 <a href="https://timsong-cpp.github.io/cppwp/concepts.syn">[concepts.syn]</a>, header <tt>&lt;concepts&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>//  [concept.defaultconstructible], concept default_<del>constructible</del><ins>initializable</ins></i>
template&lt;class T&gt;
concept default_<del>constructible</del><ins>initializable</ins> = <i>see below</i>;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify  [concept.defaultconstructible] as indicated:</p>

<blockquote>
<p>
<b>18.4.12 Concept <tt>default_<del>constructible</del><ins>initializable</ins></tt> [concept.default<del>constructible</del><ins>initializable</ins>]</b>
</p>
<pre>
<ins>template&lt;class T&gt;
  inline constexpr bool <i>is-default-initializable</i> = <i>see below</i>; // <i>exposition only</i></ins>

template&lt;class T&gt;
  concept default_<del>constructible</del><ins>initializable</ins> = constructible_from&lt;T&gt; <ins>&amp;&amp; requires { T{}; } &amp;&amp; <i>is-default-initializable</i>&lt;T&gt;</ins>;
</pre>
<p>
<ins>-?- For a type <tt>T</tt>, <tt><i>is-default-initializable</i>&lt;T&gt;</tt> is <tt>true</tt>
if and only if the variable definition</ins>
<blockquote>
<pre>
<ins>T t;</ins>
</pre>
</blockquote>
<ins>is well-formed for some invented variable <tt>t</tt>; otherwise it is <tt>false</tt>. Access checking is
performed as if in a context unrelated to <tt>T</tt>. Only the validity of the
immediate context of the variable initialization is considered.</ins>
</p>
</blockquote>
</li>

<li><p>Modify 18.6 <a href="https://timsong-cpp.github.io/cppwp/concepts.object">[concepts.object]</a> as indicated:</p>

<blockquote>
<p>
-1- This subclause describes concepts that specify the basis of the value-oriented programming style on which
the library is based.
</p>
<pre>
template&lt;class T&gt;
concept movable = is_object_v&lt;T&gt; &amp;&amp; move_constructible&lt;T&gt; &amp;&amp;
[&hellip;]
template&lt;class T&gt;
concept semiregular = copyable&lt;T&gt; &amp;&amp; default_<del>constructible</del><ins>initializable</ins>&lt;T&gt;;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.10.2 <a href="https://timsong-cpp.github.io/cppwp/memory.syn">[memory.syn]</a>, header <tt>&lt;memory&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;<i>no-throw-forward-iterator</i> I, <i>no-throw-sentinel</i>&lt;I&gt; S&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;iter_value_t&lt;I&gt;&gt;
      I uninitialized_default_construct(I first, S last);
  template&lt;<i>no-throw-forward-range</i> R&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;range_value_t&lt;R&gt;&gt;
      safe_iterator_t&lt;R&gt; uninitialized_default_construct(R&amp;&amp; r);

  template&lt;<i>no-throw-forward-iterator</i> I&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;iter_value_t&lt;I&gt;&gt;
      I uninitialized_default_construct_n(I first, iter_difference_t&lt;I&gt; n);
}
[&hellip;]
namespace ranges {
  template&lt;<i>no-throw-forward-iterator</i> I, <i>no-throw-sentinel</i>&lt;I&gt; S&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;iter_value_t&lt;I&gt;&gt;
     I uninitialized_value_construct(I first, S last);
  template&lt;<i>no-throw-forward-range</i> R&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;range_value_t&lt;R&gt;&gt;
      safe_iterator_t&lt;R&gt; uninitialized_value_construct(R&amp;&amp; r);

  template&lt;<i>no-throw-forward-iterator</i> I&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;iter_value_t&lt;I&gt;&gt;
      I uninitialized_value_construct_n(I first, iter_difference_t&lt;I&gt; n);
}
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 25.11.3 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.construct.default">[uninitialized.construct.default]</a> as indicated:</p>

<blockquote>
<pre>
namespace ranges {
  template&lt;<i>no-throw-forward-iterator</i> I, <i>no-throw-sentinel</i>&lt;I&gt; S&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;iter_value_t&lt;I&gt;&gt;
      I uninitialized_default_construct(I first, S last);
  template&lt;<i>no-throw-forward-range</i> R&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;range_value_t&lt;R&gt;&gt;
      safe_iterator_t&lt;R&gt; uninitialized_default_construct(Ramp;&amp; r);
}
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Equivalent to:
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
namespace ranges {
  template&lt;<i>no-throw-forward-iterator</i> I&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;iter_value_t&lt;I&gt;&gt;
      I uninitialized_default_construct_n(I first, iter_difference_t&lt;I&gt; n);
}
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to:
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>


<li><p>Modify 25.11.4 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.construct.value">[uninitialized.construct.value]</a> as indicated:</p>

<blockquote>
<pre>
namespace ranges {
  template&lt;<i>no-throw-forward-iterator</i> I, <i>no-throw-sentinel</i>&lt;I&gt; S&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;iter_value_t&lt;I&gt;&gt;
      I uninitialized_value_construct(I first, S last);
  template&lt;<i>no-throw-forward-range</i> R&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;range_value_t&lt;R&gt;&gt;
      safe_iterator_t&lt;R&gt; uninitialized_value_construct(R&amp;&amp; r);
}
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Equivalent to:
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
namespace ranges {
  template&lt;<i>no-throw-forward-iterator</i> I&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;iter_value_t&lt;I&gt;&gt;
      I uninitialized_value_construct_n(I first, iter_difference_t&lt;I&gt; n);
}
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to:
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 99 [range.semi.wrap] as indicated:</p>

<blockquote>
<p>
-1- Many types in this subclause are specified in terms of an exposition-only class template <tt><i>semiregular-box</i></tt>.
<tt><i>semiregular-box</i>&lt;T&gt;</tt> behaves exactly like <tt>optional&lt;T&gt;</tt> with the following differences:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; [&hellip;]</p></li>
<li><p>(1.2) &mdash; If <tt>T</tt> models <tt>default_<del>constructible</del><ins>initializable</ins></tt>, the default constructor of
<tt><i>semiregular-box</i>&lt;T&gt;</tt> is equivalent to:</p>
<blockquote><pre>
constexpr <i>semiregular-box</i>() noexcept(is_nothrow_default_constructible_v&lt;T&gt;)
  : <i>semiregular-box</i>{in_place}
{ }
</pre></blockquote>
</li>
<li><p>(1.3) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify 24.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.istream.view">[range.istream.view]</a>, Class template <tt>basic_istream_view</tt> synopsis,
as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;movable Val, class CharT, class Traits&gt;
    requires default_<del>constructible</del><ins>initializable</ins>&lt;Val&gt; &amp;&amp;
      <i>stream-extractable</i>&lt;Val, CharT, Traits&gt;
  class basic_istream_view : public view_interface&lt;basic_istream_view&lt;Val, CharT, Traits&gt;&gt; {
    [&hellip;]
  }
  [&hellip;]
}
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-11-17; Daniel comments and restores wording]</i></p>

<p>
During the Belfast 2019 meeting the concept renaming was not voted in by this issue, but
separately, the accepted wording can be found in <a href="https://wg21.link/p1917r0#3149">P1917R0#3149</a>.
To prevent confusion, the here presented proposed wording has been synchronized with that of the voted in
document.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ol>
<li><p>Modify  [concept.defaultconstructible] as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;
  inline constexpr bool <i>is-default-initializable</i> = <i>see below</i>; // <i>exposition only</i></ins>

template&lt;class T&gt;
  concept DefaultConstructible = Constructible&lt;T&gt; <ins>&amp;&amp; requires { T{}; } &amp;&amp; <i>is-default-initializable</i>&lt;T&gt;</ins>;
</pre>
<p>
<ins>-?- For a type <tt>T</tt>, <tt><i>is-default-initializable</i>&lt;T&gt;</tt> is <tt>true</tt>
if and only if the variable definition</ins>
<blockquote>
<pre>
<ins>T t;</ins>
</pre>
</blockquote>
<ins>is well-formed for some invented variable <tt>t</tt>; otherwise it is <tt>false</tt>. Access checking is
performed as if in a context unrelated to <tt>T</tt>. Only the validity of the
immediate context of the variable initialization is considered.</ins>
</p>
</blockquote>
</li>
</ol>





</body>
</html>
