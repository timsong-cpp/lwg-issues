<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 2116: is_nothrow_constructible and destructors</title>
<meta property="og:title" content="Issue 2116: is_nothrow_constructible and destructors">
<meta property="og:description" content="C++ library issue. Status: Open">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/2116.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="2116"><a href="lwg-active.html#2116">2116</a>. <code>is_nothrow_constructible</code> and destructors</h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2023-05-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
IMO if we specified <code>is_[nothrow_]constructible</code> in terms of a variable
declaration whose validity requires destructibility, it is clearly a bug
in our specification and a failure to realize the actual original
intent. The specification should have been in terms of placement-new.
<p/>
Daniel:<br/>
At the time of the specification this was intended and the solution is
<em>not</em> done by removing the destruction semantics of <code>is_constructible</code>.
<p/>
The design of <code>is_constructible</code> was also impacted by the previous
<code>Constructible</code> concept that <em>explicitly</em> contained destruction semantics,
because during conceptification of the library it turned out to simplify
the constraints  in the library because you did not need to add
<code>Destructible</code> all the time. It often was implied but never spoken out
in C++03.
<p/>
Pure construction semantics was considered as useful as well, so <code>HasConstructor</code>
did also exist and would surely be useful as trait as well.
<p/>
Another example that is often overlooked: This also affects wrapper types like <code>pair</code>,
<code>tuple</code>, <code>array</code> that contain potentially more than one type:
This is easy to understand if you think of <code>T1</code> having a deleted destructor
and <code>T2</code> having a constructor that may throw: Obviously the compiler has
potentially need to use the <code>destructor</code> of <code>T1</code> in the <em>constructor</em>
of <code>std::pair&lt;T1, T2&gt;</code> to ensure that the core language requirements
are satisfied (All previous fully constructed sub-objects must be destructed).
<p/>
The core language also honors this fact in  [class.copy] p11:
</p>
<blockquote><p>
A defaulted copy&#47;move constructor for a class <code>X</code> is defined as deleted (9.6.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.fct.def.delete">[dcl.fct.def.delete]</a>)
if <code>X</code> has:<br/>
[&hellip;]<br/>
&mdash; any direct or virtual base class or non-static data member of a type with a destructor that is deleted
or inaccessible from the defaulted constructor,<br/>
[&hellip;]
</p></blockquote>
<p>
Dave:<br/>
This is about <code>is_nothrow_constructible</code> in particular. The fact that it is
foiled by not having a <code>noexcept</code> dtor is a defect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
<code>is_nothrow_constructible</code> is defined in terms of <code>is_constructible</code>, which is defined
by looking at a hypothetical variable and asking whether the variable definition is known not to
throw exceptions. The issue claims that this also examines the type's destructor, given the context,
and thus will return <code>false</code> if the destructor can potentially throw. At least one
implementation (Howard's) does return <code>false</code> if the constructor is <code>noexcept(true)</code>
and the destructor is <code>noexcept(false)</code>. So that's not a strained interpretation.
The issue is asking for this to be defined in terms of placement <code>new</code>, instead of in terms
of a temporary object, to make it clearer that <code>is_nothrow_constructible</code> looks at the
<code>noexcept</code> status of only the constructor, and not the destructor.
</p>
<p>
Sketch of what the wording would look like:
</p>
<p>
require <code>is_constructible</code>, and then also require that a placement <code>new</code> operation
does not throw. (Remembering the title of this issue... What does this imply for <code>swap</code>?
</p>
<p>
If we accept this resolution, do we need any changes to <code>swap</code>?
</p>
<p> STL argues: no, because you are already forbidden from passing anything with a throwing
destructor to <code>swap</code>.
</p>
<p>
Dietmar argues: no, not true. Maybe statically the destructor can conceivably throw for some
values, but maybe there are some values known not to throw. In that case, it's correct to
pass those values to <code>swap</code>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Gave the issue a better title</p>
<p>This issue interacts with <a href="2827" title="is_trivially_constructible and non-trivial destructors (Status: New)">2827</a></p>
<p>Ville would like "an evolution group" to take a look at this issue.</p>


<p><i>[2020-08; LWG reflector]</i></p>

<p>
A poll was taken to close the issue as NAD, but only gained three votes in favour
(and one vote against, which was subsequently withdrawn).
</p>

<p><i>[2022-03; LWG reflector]</i></p>

<p>
A poll was taken to close the issue as NAD, with six votes in favour.
(and one vote against, subsequently withdrawn).
</p>
<p>
"Write a paper if you want something else. These traits have well established meaning now."
"Minimizing requirements is not as important a concern for standard library concepts as as minimizing the number of concepts.
Requirements like 'I need to construct but not destroy an object' are niche enough that we don't need to support them."
</p>

<p><i>[2022-11-30; LWG telecon]</i></p>

<p>Alisdair intends to write a paper for this.</p>

<p><i>[2023-05-25; May 2023 mailing]</i></p>

<p>Alisdair provided <a href="https://wg21.link/P2842R0" title=" Destructor Semantics Do Not Affect Constructible Traits">P2842R0</a>.</p>



<p id="res-2116"><b>Proposed resolution:</b></p>





</body>
</html>
