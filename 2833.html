<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 2833: Library needs to specify what it means when it declares a function constexpr</title>
<meta property="og:title" content="Issue 2833: Library needs to specify what it means when it declares a function constexpr">
<meta property="og:description" content="C++ library issue. Status: Open">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/2833.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="2833"><a href="lwg-active.html#2833">2833</a>. Library needs to specify what it means when it declares a function <code>constexpr</code></h3>
<p><b>Section:</b> 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-28 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.ctor">active issues</a> in [variant.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.ctor">issues</a> in [variant.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library has lots of functions declared <code>constexpr</code>, but it's not clear what that means. The <code>constexpr</code> 
keyword implies that there needs to be <em>some</em> invocation of the function, for <em>some</em> set of template 
arguments and function arguments, that is valid in a constant expression (otherwise the program would be ill-formed, 
with no diagnostic required), along with a few side conditions. I suspect the library intends to require something a 
lot stronger than that from implementations (something along the lines of "all calls that could reasonably be constant 
subexpressions are in fact constant subexpressions, unless otherwise stated").
<p/>
[variant.ctor]/1 contains this, which should also be fixed:
</p>
<blockquote><p>
"This function shall be <code>constexpr</code> if and only if the value-initialization of the alternative type <code>T0</code> 
would satisfy the requirements for a <code>constexpr</code> function."
</p></blockquote>
<p>
This is the wrong constraint: instead of constraining whether the function is <code>constexpr</code>, we should constrain 
whether a call to it is a constant subexpression.
</p>
<p>
<b>Daniel:</b>
<p/>
This is has some considerable overlap with LWG <a href="2289" title="constexpr guarantees of defaulted functions still insufficient (Status: Open)">2289</a> but is phrased in a more general way.
</p>

<p><i>[2016-12-16, Issues Telecon]</i></p>

<p>Priority 2; this is also the general case of <a href="2829" title="LWG 2740 leaves behind vacuous words (Status: Open)">2829</a>.</p>

<p><i>[2017-02-20, Alisdair comments and suggests concrete wording]</i></p>

<p>
Below is is draft wording I was working on at Issaquah to try to address both issues.
</p>

<p><i>[2017-11 Albuquerque Wednesday issue processing]</i></p>

<p>Status to Open; really needs a paper.</p>
<p>STL says "What about <code>plus&lt;T&gt;</code>?"  <code>plus&lt;int&gt;</code> needs to be usable in a constexpr context, but <code>plus&lt;string&gt;</code> can't be.</p>

<p><i>[2017-11 Albuquerque Saturday issues processing]</i></p>

<p>Geoffrey to write a paper resolving this.</p>

<p><i>[2018-06 Rapperswil Thursday issues processing]</i></p>

<p>Geoffrey has been unable to write this paper due to time constraints. He wrote up his progress
<a href="http://lists.isocpp.org/lib/2018/04/6587.php">here</a>. Daniel has offered to help someone
to write this paper; he's willing to be a co-author.</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Michael Wong to investigate.</p>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li>
<p>
Modify 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:
</p>
<blockquote>
<h3>17.6.5.6 <code>constexpr</code> functions and constructors [constexpr.functions]</h3>
<p>
-1- This International Standard explicitly requires that certain standard library functions are
<code>constexpr</code> (9.2.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>).  <ins>If the specification for a templated entity
requires that it shall be a <code>constexpr</code> templated entity, then that
templated entity shall be usable in a constant expression.</ins>.  An
implementation <del>shall not</del><ins>may</ins> declare
<del>any</del><ins>additional</ins> standard library function signature as
<code>constexpr</code> <del>except for those where it is explicitly required</del>.
Within any header that provides any non-defining declarations of
<code>constexpr</code> functions or constructors an implementation shall provide
corresponding definitions.
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-06-08 Nina Dinka Ranns comments and provides alternative wording]</i></p>

<p>
The revised wording draft also resolves LWG <a href="2289" title="constexpr guarantees of defaulted functions still insufficient (Status: Open)">2289</a>, LWG <a href="2829" title="LWG 2740 leaves behind vacuous words (Status: Open)">2829</a>, and LWG <a href="3215" title="variant default constructor has vague constexpr requirements (Status: New)">3215</a>.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol style="list-style-type: none">
<li>
<p>
1. Modify 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:
</p>
<blockquote>
<p>
-1- This document explicitly requires that certain standard library functions are <code>constexpr</code> 
(9.2.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>). An implementation shall not declare any standard library function signature 
as <code>constexpr</code> except for those where it is explicitly required. Within any header 
that provides any non-defining declarations of constexpr functions or constructors an implementation 
shall provide corresponding definitions.
<p/>
<ins>-?- Let <code>F</code> denote a standard library function template or member function of a class
template. If the specification of <code>F</code> declares it to be <code>constexpr</code>, unless otherwise specified, 
then <code>F</code> can be used in a constant expression if and only if all the expressions that are evaluated as 
specified in the description of <code>F</code>'s semantics can be used in a constant expression.</ins>
</p>
</blockquote>
</li>

<li>
<p>
2. - 10. [&hellip;] // Remainder of Nina's update
</p>
</li>
</ol>
</blockquote>

<p><i>[2020-10-02 Jens Maurer improves wording]</i></p>

<p>
Specifically the wording for 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> needs improvement and is updated below.
</p>

<p><i>[2020-10-02 Tim Song comments]</i></p>

<p>
The new wording doesn't cover the following example:
</p>
<blockquote><pre>
// global scope
int x;
int y;

constexpr int j = (std::swap(x, y), 0); // error
</pre></blockquote>
<ul>
<li><p><code>swap</code> is a "standard library function template...declared <code>constexpr</code>"</p></li>
<li><p><code>x</code> and <code>y</code> are (lvalue) constant expressions</p></li>
<li><p><code>std::swap(x, y)</code> is plainly not a constant expression</p></li>
</ul>

<p><i>[2020-10-04 Jens Maurer comments]</i></p>

<p>
Yes, we're still lacking text for that (and maybe Nina's old text helps for that).
</p>

<p><i>[2020-12-14; Jiang An comments]</i></p>

<p>
The item "constexpr functions" is also used in 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/14 and 
24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>/16, and such usage should also be modified by this issue here.
</p>

<p><i>[St. Louis 2024-06-24;
Re-confirmed Tim's previous observation, new P/R needed.
Jens says there are two ways that <code class='backtick'>swap</code> could work, and the library doesn't
actually say how it does what it does, so it's not possible for a reader to
know whether they can expect it to be usable in a constant expression.
]</i></p>




<p id="res-2833"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li>
<p>
Modify 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:
</p>
<blockquote>
<p>
-1- This document explicitly requires that certain standard library functions are <code>constexpr</code> 
(9.2.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>). An implementation shall not declare any standard library function signature 
as <code>constexpr</code> except for those where it is explicitly required. Within any header 
that provides any non-defining declarations of constexpr functions or constructors an implementation 
shall provide corresponding definitions.
<p/>
<ins>-?- Let <code>F</code> denote a standard library function template or member function of a class template 
declared <code>constexpr</code>. Unless otherwise specified, a function call expression (7.6.1.3 <a href="https://timsong-cpp.github.io/cppwp/expr.call">[expr.call]</a>) 
whose <i>postfix-expression</i> names <code>F</code> is a constant expression if all of the argument subexpressions 
are constant expressions.</ins>
</p>
</blockquote>
</li>

<li>
<p>
Modify 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> as indicated:
</p>
<blockquote>
<p>
-2- The defaulted <del>move and copy</del> constructor<ins>s</ins><del>, respectively,</del> of 
<code>pair</code> <del>is a constexpr function</del><ins>can be used in a constant expression</ins> if and only if all
required element-wise initializations <del>for move and copy, respectively, would satisfy the requirements for a
constexpr function</del><ins>can be used in a constant expression</ins>.
</p>
</blockquote>
</li>

<li>
<p>
Modify 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:
</p>
<blockquote>
<p>
-3- The defaulted <del>move and copy</del> constructor<ins>s</ins><del>, respectively,</del> of <code>tuple</code> 
<del>is a constexpr function</del><ins>can be used in a constant expression</ins> if and only if all
required element-wise initializations <del>for move and copy, respectively, would satisfy the requirements for a
constexpr function</del><ins>can be used in a constant expression</ins>. The defaulted <del>move and copy</del> 
constructor<ins>s</ins> of <code>tuple&lt;&gt;</code> <del>are constexpr functions</del><ins>can be used in a constant 
expression</ins>. 
</p>
</blockquote>
</li>

<li>
<p>
Modify 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:
</p>
<blockquote>
<pre>
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- <i>Remarks:</i> No contained value is initialized. <del>For every object type <code>T</code> these constructors 
are constexpr constructors (9.2.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>).</del>
</p>
</blockquote>
[&hellip;]
<pre>
template&lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-12- [&hellip;]
<p/>
-13- [&hellip;]
<p/>
-14- [&hellip;]
<p/>
-15- [&hellip;]
<p/>
<del>-16- <i>Remarks:</i> If <code>T</code>'s constructor selected for the initialization is a constexpr constructor, 
this constructor is a constexpr constructor.</del> 
</p>
</blockquote>
<pre>
template&lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-17- [&hellip;]
<p/>
-18- [&hellip;]
<p/>
-19- [&hellip;]
<p/>
-20- [&hellip;]
<p/>
<del>-21- <i>Remarks:</i> If <code>T</code>'s constructor selected for the initialization is a constexpr constructor, 
this constructor is a constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;class U = T&gt; constexpr explicit(<i>see below</i>) optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-22- [&hellip;]
<p/>
-23- [&hellip;]
<p/>
-24- [&hellip;]
<p/>
-25- [&hellip;]
<p/>
-26- <i>Remarks:</i> <del>If <code>T</code>'s constructor selected for the initialization is a constexpr constructor, 
this constructor is a constexpr constructor.</del> The expression inside <code>explicit</code> is equivalent to:
</p>
<blockquote><pre>
!is_convertible_v&lt;U, T&gt;
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> as indicated:
</p>
<blockquote>
<pre>
constexpr const T* operator-&gt;() const;
constexpr T* operator-&gt;();
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- [&hellip;]
<p/>
-3- [&hellip;]
<p/>
<del>-4- <i>Remarks:</i> These functions are constexpr functions.</del>
</p>
</blockquote>
<pre>
constexpr const T&amp; operator*() const&amp;;
constexpr T&amp; operator*() &amp;;
</pre>
<blockquote>
<p>
-5- [&hellip;]
<p/>
-6- [&hellip;]
<p/>
-7- [&hellip;]
<p/>
<del>-8- <i>Remarks:</i> These functions are constexpr functions.</del>
</p>
</blockquote>
[&hellip;]
<pre>
constexpr explicit operator bool() const noexcept;
</pre>
<blockquote>
<p>
-11- <i>Returns:</i> <code>true</code> if and only if <code>*this</code> contains a value.
<p/>
<del>-12- <i>Remarks:</i> This function is a constexpr function.</del>
</p>
</blockquote>
<pre>
constexpr bool has_value() const noexcept;
</pre>
<blockquote>
<p>
-13- <i>Returns:</i> <code>true</code> if and only if <code>*this</code> contains a value.
<p/>
<del>-14- <i>Remarks:</i> This function is a constexpr function.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 22.5.6 <a href="https://timsong-cpp.github.io/cppwp/optional.relops">[optional.relops]</a> as indicated:
</p>
<blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- [&hellip;]
<p/>
<del>-3- <i>Remarks:</i> Specializations of this function template for which <code>*x == *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-4- [&hellip;]
<p/>
-5- [&hellip;]
<p/>
<del>-6- <i>Remarks:</i> Specializations of this function template for which <code>*x != *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-7- [&hellip;]
<p/>
-8- [&hellip;]
<p/>
<del>-9- <i>Remarks:</i> Specializations of this function template for which <code>*x &lt; *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-10- [&hellip;]
<p/>
-11- [&hellip;]
<p/>
<del>-12- <i>Remarks:</i> Specializations of this function template for which <code>*x &gt; *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-13- [&hellip;]
<p/>
-14- [&hellip;]
<p/>
<del>-15- <i>Remarks:</i> Specializations of this function template for which <code>*x &lt;= *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-16- [&hellip;]
<p/>
-17- [&hellip;]
<p/>
<del>-18- <i>Remarks:</i> Specializations of this function template for which <code>*x &gt;= *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
  constexpr compare_three_way_result_t&lt;T,U&gt;
    operator&lt;=&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-19- <i>Returns:</i> If <code>x &amp;&amp; y</code>, <code>*x &lt;=&gt; *y</code>; otherwise <code>bool(x) &lt;=&gt; bool(y)</code>.
<p/>
<del>-20- <i>Remarks:</i> Specializations of this function template for which <code>*x &lt;=&gt; *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> as indicated:
</p>
<blockquote>
<pre>
constexpr variant() noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- [&hellip;]
<p/>
-3- [&hellip;]
<p/>
-4- [&hellip;]
<p/>
-5- [&hellip;]
<p/>
-6- <i>Remarks:</i> <del>This function is <code>constexpr</code> if and only if the value-initialization of the 
alternative type <code>T<sub>0</sub></code> would satisfy the requirements for a constexpr function.</del> The 
expression inside <code>noexcept</code> is equivalent to <code>is_nothrow_default_constructible_v&lt;T<sub>0</sub>&gt;</code>. 
[<i>Note:</i> See also class <code>monostate</code>. &mdash; <i>end note</i>]
</p>
</blockquote>
[&hellip;]
<pre>
template&lt;class T&gt; constexpr variant(T&amp;&amp; t) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-14- [&hellip;]
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The expression inside <code>noexcept</code> is equivalent to 
<code>is_nothrow_constructible_v&lt;T<sub><i>j</i></sub>, T&gt;</code>. <del>If <code>T<sub><i>j</i></sub></code>'s 
selected constructor is a constexpr constructor, this constructor is a constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class... Args&gt; constexpr explicit variant(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-20- [&hellip;]
<p/>
[&hellip;]
<p/>
<del>-24- <i>Remarks:</i> If <code>T</code>'s selected constructor is a constexpr constructor, this constructor is a 
constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U, class... Args&gt;
  constexpr explicit variant(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-25- [&hellip;]
<p/>
[&hellip;]
<p/>
<del>-29- <i>Remarks:</i> If <code>T</code>'s selected constructor is a constexpr constructor, this constructor is 
a constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;size_t I, class... Args&gt; constexpr explicit variant(in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-30- [&hellip;]
<p/>
[&hellip;]
<p/>
<del>-34- <i>Remarks:</i> If <code>T<sub><i>I</i></sub></code>'s selected constructor is a constexpr constructor, 
this constructor is a constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;size_t I, class U, class... Args&gt;
  constexpr explicit variant(in_place_index_t&lt;I&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-35- [&hellip;]
<p/>
[&hellip;]
<p/>
<del>-38- <i>Remarks:</i> If <code>T<sub><i>I</i></sub></code>'s selected constructor is a constexpr constructor, 
this constructor is a constexpr constructor.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 24.5.4.11 <a href="https://timsong-cpp.github.io/cppwp/move.sent.ops">[move.sent.ops]</a> as indicated:
</p>
<blockquote>
<pre>
constexpr move_sentinel();
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Value-initializes <code>last</code>. <del>If <code>is_trivially_default_constructible_v&lt;S&gt;</code> is 
<code>true</code>, then this constructor is a constexpr constructor.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 22.11.3 <a href="https://timsong-cpp.github.io/cppwp/bit.cast">[bit.cast]</a> as indicated:
</p>
<blockquote>
<pre>
template&lt;class To, class From&gt;
  constexpr To bit_cast(const From&amp; from) noexcept;
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-3- <i>Remarks:</i> This function <del>is <code>constexpr</code></del><ins>can be used in a constant expression</ins> 
if and only if <code>To</code>, <code>From</code>, and the types of all subobjects of <code>To</code> and From are types 
<code>T</code> such that:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; <code>is_union_v&lt;T&gt;</code> is <code>false</code>;</p></li>
<li><p>(3.2) &mdash; <code>is_pointer_v&lt;T&gt;</code> is <code>false</code>;</p></li>
<li><p>(3.3) &mdash; <code>is_member_pointer_v&lt;T&gt;</code> is <code>false</code>;</p></li>
<li><p>(3.4) &mdash; <code>is_volatile_v&lt;T&gt;</code> is <code>false</code>; and</p></li>
<li><p>(3.5) &mdash; <code>T</code> has no non-static data members of reference type.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 30.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a> as indicated:
</p>

<blockquote>
<p>
-5- The defaulted <del>copy</del> constructor<ins>s</ins> of duration <del>shall be a constexpr 
function</del><ins>can be used in a constant expression</ins> if and only if the required initialization
of the member <code>rep_</code> <del>for copy and move, respectively, would satisfy the requirements for 
a constexpr function</del><ins>can be used in a constant expression</ins>.
</p>
</blockquote>

</li>

</ol>





</body>
</html>
