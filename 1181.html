<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 1181: Invalid sub_match comparison operators</title>
<meta property="og:title" content="Issue 1181: Invalid sub_match comparison operators">
<meta property="og:description" content="C++ library issue. Status: C++11">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/1181.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="1181"><a href="lwg-defects.html#1181">1181</a>. Invalid <code>sub_match</code> comparison operators</h3>
<p><b>Section:</b> 28.6.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.op">[re.submatch.op]</a> <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-07-25 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.submatch.op">issues</a> in [re.submatch.op].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several heterogeneous comparison operators of class template
<code>sub_match</code> are specified by return clauses that are not valid
in general. E.g. 28.6.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.op">[re.submatch.op]</a>/7:
</p>

<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
bool operator==(
  const basic_string&lt;
    typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
  const sub_match&lt;BiIter&gt;&amp; rhs);
</pre>
<blockquote><p>
<i>Returns:</i> <code>lhs == rhs.str()</code>.
</p></blockquote>
</blockquote>

<p>
The returns clause would be ill-formed for all cases where
<code>ST != std::char_traits&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;</code>
or <code>SA != std::allocator&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;</code>.
</p>
<p>
The generic character of the comparison was intended, so
there are basically two approaches to fix the problem: The
first one would define the semantics of the comparison
using the traits class <code>ST</code> (The semantic of <code>basic_string::compare</code>
is defined in terms of the compare function of the corresponding
traits class), the second one would define the semantics of the
comparison using the traits class
</p>

<blockquote><pre>
std::char_traits&lt;iterator_traits&lt;BiIter&gt;::value_type&gt;
</pre></blockquote>

<p>
which is essentially identical to
</p>

<blockquote><pre>
std::char_traits&lt;sub_match&lt;BiIter&gt;::value_type&gt;
</pre></blockquote>

<p>
I suggest to follow the second approach, because
this emphasizes the central role of the <code>sub_match</code>
object as part of the comparison and would also
make sure that a <code>sub_match</code> comparison using some
<code>basic_string&lt;char_t, ..&gt;</code> always is equivalent to
a corresponding comparison with a string literal
because of the existence of further overloads (beginning
from 28.6.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.op">[re.submatch.op]</a>/19). If users really want to
take advantage of their own <code>traits::compare</code>, they can
simply write a corresponding compare function that
does so.
</p>

<p><i>[
Post-Rapperswil
]</i></p>


<p>
The following update is a result of the discussion during the Rapperswil meeting, the P/R expresses all comparisons by 
delegating to sub_match's compare functions. The processing is rather mechanical: Only <code>==</code> and <code>&lt;</code>
where defined by referring to <code>sub_match</code>'s compare function, all remaining ones where replaced by the canonical
definitions in terms of these two.
</p>

<blockquote><p>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</p></blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p id="res-1181"><b>Proposed resolution:</b></p>
<p>
<i>The wording refers to N3126.</i>
</p>

<ol>
<li>Change 28.9.2 [re.submatch.op]/7 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator==(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
7 <em>Returns</em>: <code><del>lhs == rhs.str()</del><ins>rhs.compare(lhs.c_str()) == 0</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/8 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator!=(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
8 <em>Returns</em>: <code><del>lhs != rhs.str()</del><ins>!(lhs == rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/9 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator&lt;(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
9 <em>Returns</em>: <code><del>lhs &lt; rhs.str()</del><ins>rhs.compare(lhs.c_str()) &gt; 0</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/10 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator&gt;(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
10 <em>Returns</em>: <code><del>lhs &gt; rhs.str()</del><ins>rhs &lt; lhs</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/11 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator&gt;=(
   const basic_string&lt;
   typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
 const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
11 <em>Returns</em>: <code><del>lhs &gt;= rhs.str()</del><ins>!(lhs &lt; rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/12 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator&lt;=(
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
12 <em>Returns</em>: <code><del>lhs &lt;= rhs.str()</del><ins>!(rhs &lt; lhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/13 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre><p>
13 <em>Returns</em>: <code><del>lhs.str() == rhs</del><ins>lhs.compare(rhs.c_str()) == 0</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/14 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre><p>
14 <em>Returns</em>: <code><del>lhs.str() != rhs</del><ins>!(lhs == rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/15 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre><p>
15 <em>Returns</em>: <code><del>lhs.str() &lt; rhs</del><ins>lhs.compare(rhs.c_str()) &lt; 0</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/16 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator>(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre><p>
16 <em>Returns</em>: <code><del>lhs.str() &gt; rhs</del><ins>rhs &lt; lhs</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/17 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre><p>
17 <em>Returns</em>: <code><del>lhs.str() &gt;= rhs</del><ins>!(lhs &lt; rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/18 as indicated:
<blockquote><pre>
template &lt;class BiIter, class ST, class SA&gt;
 bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   const basic_string&lt;
     typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
</pre><p>
18 <em>Returns</em>: <code><del>lhs.str() &lt;= rhs</del><ins>!(rhs &lt; lhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/19 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator==(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
19 <em>Returns</em>: <code><del>lhs == rhs.str()</del><ins>rhs.compare(lhs) == 0</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/20 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator!=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
20 <em>Returns</em>: <code><del>lhs != rhs.str()</del><ins>!(lhs == rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/21 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&lt;(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
21 <em>Returns</em>: <code><del>lhs &lt; rhs.str()</del><ins>rhs.compare(lhs) &gt; 0</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/22 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&gt;(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
22 <em>Returns</em>: <code><del>lhs &gt; rhs.str()</del><ins>rhs &lt; lhs</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/23 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&gt;=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
23 <em>Returns</em>: <code><del>lhs &gt;= rhs.str()</del><ins>!(lhs &lt; rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/24 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&lt;=(typename iterator_traits&lt;BiIter&gt;::value_type const* lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
24 <em>Returns</em>: <code><del>lhs &lt;= rhs.str()</del><ins>!(rhs &lt; lhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/25 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre><p>
25 <em>Returns</em>: <code><del>lhs.str() == rhs</del><ins>lhs.compare(rhs) == 0</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/26 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre><p>
26 <em>Returns</em>: <code><del>lhs.str() != rhs</del><ins>!(lhs == rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/27 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre><p>
27 <em>Returns</em>: <code><del>lhs.str() &lt; rhs</del><ins>lhs.compare(rhs) &lt; 0</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/28 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre><p>
28 <em>Returns</em>: <code><del>lhs.str() &gt; rhs</del><ins>rhs &lt; lhs</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/29 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre><p>
29 <em>Returns</em>: <code><del>lhs.str() &gt;= rhs</del><ins>!(lhs &lt; rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/30 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const* rhs);
</pre><p>
30 <em>Returns</em>: <code><del>lhs.str() &lt;= rhs</del><ins>!(rhs &lt; lhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/31 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator==(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
<del>31 <em>Returns</em>: <code>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1,	lhs) == rhs.str()</code>.</del><br/>
<ins>31 <em>Returns</em>: <code>rhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, lhs)) == 0</code>.</ins>
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/32 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator!=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
32 <em>Returns</em>: <code><del>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, lhs) !=
rhs.str()</del><ins>!(lhs == rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/33 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&lt;(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
<del>33 <em>Returns</em>: <code>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type>(1, lhs) &lt; rhs.str()</code>.</del><br/>
<ins>33 <em>Returns</em>: <code>rhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, lhs)) &gt; 0</code>.</ins>
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/34 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&gt;(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
34 <em>Returns</em>: <code><del>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, lhs) &gt; rhs.str()</del><ins>rhs &lt; lhs</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/35 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&gt;=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
35 <em>Returns</em>: <code><del>basic_string&lt;typename iterator_traits&lt;BiIter>::value_type>(1, lhs) &gt;= rhs.str()</del><ins>!(lhs &lt; rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/36 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&lt;=(typename iterator_traits&lt;BiIter&gt;::value_type const&amp; lhs,
   const sub_match&lt;BiIter&gt;&amp; rhs);
</pre><p>
36 <em>Returns</em>: <code><del>basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, lhs) &lt;= rhs.str()</del><ins>!(rhs &lt; lhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/37 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre><p>
<del>37 <em>Returns</em>: <code>lhs.str() == basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</code>.</del><br/>
<ins>37 <em>Returns</em>: <code>lhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, rhs)) == 0</code>.</ins>
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/38 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator!=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre><p>
38 <em>Returns</em>: <code><del>lhs.str() != basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</del><ins>!(lhs == rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/39 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&lt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre><p>
<del>39 <em>Returns</em>: <code>lhs.str() &lt; basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</code>.</del><br/>
<ins>39 <em>Returns</em>: <code>lhs.compare(typename sub_match&lt;BiIter&gt;::string_type(1, rhs)) &lt; 0</code>.</ins>
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/40 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre><p>
40 <em>Returns</em>: <code><del>lhs.str() &gt; basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</del><ins>rhs &lt; lhs</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/41 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre><p>
41 <em>Returns</em>: <code><del>lhs.str() &gt;= basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</del><ins>!(lhs &lt; rhs)</ins></code>.
</p></blockquote>
</li>
<li>Change 28.9.2 [re.submatch.op]/42 as indicated:
<blockquote><pre>
template &lt;class BiIter&gt;
 bool operator&lt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
   typename iterator_traits&lt;BiIter&gt;::value_type const&amp; rhs);
</pre><p>
42 <em>Returns</em>: <code><del>lhs.str() &lt;= basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type&gt;(1, rhs)</del><ins>!(rhs &lt; lhs)</ins></code>.
</p></blockquote>
</li>
</ol>






</body>
</html>
