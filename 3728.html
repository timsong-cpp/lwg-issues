<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3728: Can't make neither head nor tail of the description of operator&lt;=&gt;(tuple, tuple)</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3><a name="3728" href="lwg-active.html#3728">3728.</a> Can't make neither head nor tail of the description of <tt>operator&lt;=&gt;(tuple, tuple)</tt></h3>
<p><b>Section:</b> 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Corentin Jabot <b>Opened:</b> 2022-06-28 <b>Last modified:</b> 2022-07-08 20:04:38 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>operator&lt;=&gt;(tuple, tuple)</tt> (22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>) is described in 
terms of imaginary tuples (<tt>t<sub>tail</sub></tt>, <tt>u<sub>tail</sub></tt>, <tt>r<sub>tail</sub></tt>) 
which is a bit confusing. Indeed, It is not clear that these imaginary tuples need to respect the order of 
elements of <tt>u</tt> and <tt>t</tt>, nor whether the value category of the elements in these imaginary 
tuples can or should be conserved. It is possible to reformulate and simplify that description so that  
no imaginary tuple is involved.
<p/>
The remark is copied from the similar wording of <tt>operator==</tt>
</p>

<p><i>[2022-07-08; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Some votes for NAD and preference for the current wording, adding "in order"
to clarify the order of elements in <code>r<sub>tail</sub></code>.
</p>



<p id="res-3728"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
    operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-4- <i><del>Effects</del><ins>Returns</ins></i>: <ins><tt><i>synth-three-way</i>(get&lt;i&gt;(t), get&lt;i&gt;(u))</tt> 
for the first <tt>i</tt> for which the result of that expression does not compare equal to <tt>0</tt>. If no such <tt>i</tt> 
exists, <tt>strong_ordering::equal</tt>.</ins><del>Performs a lexicographical comparison between <tt>t</tt> and <tt>u</tt>. 
For any two zero-length tuples <tt>t</tt> and <tt>u</tt>, <tt>t &lt;=&gt; u</tt> returns 
<tt>strong_ordering::equal</tt>. Otherwise, equivalent to:</del>
</p>
<blockquote><pre>
<del>if (auto c = <i>synth-three-way</i>(get&lt;0&gt;(t), get&lt;0&gt;(u)); c != 0) return c;
return t<sub>tail</sub> &lt;=&gt; u<sub>tail</sub>;</del>
</pre></blockquote>
<p>
<del>where <tt>r<sub>tail</sub></tt> for some tuple <tt>r</tt> is a tuple containing all but the first 
element of <tt>r</tt>.</del>
<p/>
<ins>-?- <i>Remarks</i>: The elementary <tt><i>synth-three-way</i>(get&lt;i&gt;(t), get&lt;i&gt;(u))</tt> 
expressions are evaluated in order from the zeroth index upwards. No element accesses are performed after 
the first invocation that results in a value that does not compare equal to <tt>0</tt>.</ins>
<p/>
<del>-5- [<i>Note 1</i>: The above definition does not require <tt>t<sub>tail</sub></tt> (or <tt>u<sub>tail</sub></tt>) 
to be constructed. It might not even be possible, as <tt>t</tt> and <tt>u</tt> are not required to be copy 
constructible. Also, all comparison operator functions are short circuited; they do not perform element 
accesses beyond what is required to determine the result of the comparison. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</blockquote>
</li>

</ol>





</body>
</html>
