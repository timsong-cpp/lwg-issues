<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 4509: std::optional&lt;T&gt;::transform cannot be implemented while supporting program-defined specializations</title>
<meta property="og:title" content="Issue 4509: std::optional&lt;T&gt;::transform cannot be implemented while supporting program-defined specializations">
<meta property="og:description" content="C++ library issue. Status: LEWG">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/4509.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="4509"><a href="lwg-active.html#4509">4509</a>. <code>std::optional&lt;T&gt;::transform</code> cannot be implemented while supporting program-defined specializations</h3>
<p><b>Section:</b> 22.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/optional.monadic">[optional.monadic]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Rasheeq Azad <b>Opened:</b> 2025-12-24 <b>Last modified:</b> 2026-02-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.monadic">issues</a> in [optional.monadic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently (that is, as of the draft at <a href="https://wg21.link/N5032" title=" Working Draft, Standard for Programming Language C++">N5032</a>), 22.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/optional.monadic">[optional.monadic]</a> 
specifies that <code>std::optional&lt;T&gt;::transform(F&amp;&amp;f)&amp;</code> shall do the following 
(and similar for the other overloads):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Let <code class='backtick'>U</code> be <code>remove_cv_t&lt;invoke_result_t&lt;F, decltype((<i>val</i>))&gt;&gt;</code>.
<p/>
<i>Mandates</i>: [&hellip;]
<p/>
[<i>Note 1</i>: There is no requirement that <code class='backtick'>U</code> is movable (9.5.1 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.general">[dcl.init.general]</a>).
&mdash; <i>end note</i>]
<p/>
<i>Returns</i>: If <code class='backtick'>*this</code> contains a value, an <code>optional&lt;U&gt;</code> object whose
contained value is direct-non-list-initialized with <code>invoke(std::forward&lt;F&gt;(f), <i>val</i>)</code>; 
otherwise, <code>optional&lt;U&gt;()</code>.
</p>
</blockquote>
<p>
However, none of the standard constructors or other member functions of
<code>optional&lt;U&gt;</code> provide a surefire way to initialize the contained <code class='backtick'>U</code> value with
an expression like <code>invoke(std::forward&lt;F&gt;(f), <i>val</i>)</code>. The closest are the
<code class='backtick'>in_place_t</code>/<code class='backtick'>emplace</code> overloads, which almost but not quite admit a generic
implementation of <code class='backtick'>transform</code>. This looks roughly like:
</p>
<blockquote><pre>
namespace std {
  template&lt;class _F&gt; struct __later {
    _F __f;
    operator decltype(std::move(__f)())() &amp;&amp; { return std::move(__f)(); }
  };

  template&lt;class _T&gt; class optional {
    // etc.
  public:
    template&lt;class _F&gt; constexpr auto transform(_F &amp;&amp;__f) &amp; {
      using _U = remove_cv_t&lt;invoke_result_t&lt;_F, _T&amp;&gt;&gt;;
      if(!has_value()) return optional&lt;_U&gt;();
      return optional&lt;_U&gt;(in_place, __later([&amp;] -&gt; _U {
        return std::invoke(std::forward&lt;_F&gt;(__f), value());
      }));
    }
  };
}
</pre></blockquote>
<p>
Unfortunately, this does not quite meet the specification. The issue is if <code class='backtick'>U</code>
is a type with a <code>U(auto&amp;&amp;)</code> constructor:
</p>
<blockquote><pre>
struct oops {
  oops() = default;
  oops(auto&amp;&amp;) { std::cout &lt;&lt; "launching missiles\n"; }
};

int main() {
  std::optional&lt;int&gt; oi(5);
  oi.transform([](auto&amp; i) { return oops(); });
  // missiles get launched when they shouldn't
}
</pre></blockquote>
<p>
In this case, the rules for direct-initialization (see 9.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a> bullet 16.6.2) 
will select the template constructor over the conversion function on the <code class='backtick'>__later</code>
specialization. [<a href="https://godbolt.org/z/G6vjM4K63">Complete example 1</a>]
<p/>
To avoid this problem, standard library implementors generally implement
<code>std::optional&lt;T&gt;::transform</code> with a non-standard constructor on their
<code>std::optional&lt;T&gt;</code> primary template; roughly:
</p>
<blockquote><pre>
namespace std {
  struct __optional_from_invocable_tag {
    constexpr explicit __optional_from_invocable_tag() { }
  };
  
  template&lt;typename _T&gt;
  class optional {
    // etc.
  public:
    template&lt;typename _F, typename _V&gt;
    constexpr optional(__optional_from_invocable_tag, _F &amp;&amp;__f, _V &amp;&amp;__v)
      : __present(true)
      , __val(std::invoke(std::forward&lt;_F&gt;(__f), std::forward&lt;_V&gt;(__v)))
    { }

    template&lt;class _F&gt; constexpr auto transform(_F &amp;&amp;__f) &amp; {
      using _U = remove_cv_t&lt;invoke_result_t&lt;_F, _T&amp;&gt;&gt;;
      if(!has_value()) return optional&lt;_U&gt;();
      return optional&lt;_U&gt;(
        __optional_from_invocable_tag(),
        std::forward&lt;_F&gt;(__f), value());
    }
  };
}
</pre></blockquote>
<p>
[<a href="https://godbolt.org/z/5qsnesbdh">Complete example 2</a>]. Note that the missiles are not launched.
<p/>
Now for the real issue: if a user program wants to specialize <code class='backtick'>std::optional</code>
for a program-defined type, it will have to explicitly rely on these details of
its standard library implementation in order to be supported by the standard
library's <code class='backtick'>transform</code> implementation. Specifically, it will have to provide a
non-standard constructor with a signature matching the library implementation's
expectations. (A portable implementation of <code class='backtick'>transform</code> itself is more-or-less
possible for a program-defined specialization by using a circumlocution like
<code>std::optional&lt;std::monostate&gt;(std::in_place).transform(/* ... */)</code>.)
<p/>
The root problem is that the standard interface of <code>std::optional&lt;U&gt;</code> 
provides for direct-initialization of the contained <code class='backtick'>U</code> by arbitrary glvalues, but not
by an arbitrary prvalue (that is, by calling an arbitrary invocable). This
forces library implementations to invent their own non-standard interfaces for
doing so, which then makes it impossible for those implementations to support
program-defined specializations of <code class='backtick'>std::optional</code> that only meet the minimal
requirements of the standard, and do not support those non-standard interfaces.
<p/>
The fact that <code>std::optional&lt;T&gt;::transform</code> makes implementing <code class='backtick'>std::optional</code>
while supporting program-defined specializations basically impossible does not
appear to be intentional. <a href="https://wg21.link/P0798R8" title=" Monadic operations for std::optional">P0798R8</a>, which introduced
<code>std::optional&lt;T&gt;::transform</code>, does not mention this side-effect of its
standardization.
<p/>
There are at least two different resolutions that immediately come to mind.
<p/>
<b>Option A</b>: Forbid program-defined <code>std::optional&lt;T&gt;</code> specializations
<p/>
Taking this option would immediately solve the problem. However, in my opinion,
this would be unnecessarily restrictive. Specializing <code class='backtick'>std::optional</code> is a
useful thing to allow, as it allows replacing the common <code>struct optional&lt;T&gt; {
union { T val; }; bool present; }</code> representation with something more compact
when <code class='backtick'>T</code> has unused values/unused bits.
<p/>
<b>Option B</b>: Add a <code>std::optional&lt;T&gt;</code> constructor taking an invocable
<p/>
This option more-or-less formalizes existing practice, using a type tag to gate
the new constructor. It would be ideal to extend this idea to <code class='backtick'>emplace</code> and
then to the various <code class='backtick'>in_place_t</code> constructors and <code class='backtick'>emplace</code> functions in other
parts of the standard, but the wording presented here is restricted to fixing
this issue.
<p/>
Changing <code>std::optional&lt;T&amp;&gt;</code> doesn't seem strictly necessary, 
but introducing a nonuniformity seems like a bad idea. I'm not 100% certain about 
the wording for the new constructors.
</p>

<p><i>[2026-02-18; Reflector poll.]</i></p>

<p>
Set status to LEWG and priority to 3 after reflector poll.
</p>
<p>
Either option needs LEWG confirmation. Option A reflects existing practice.
</p>


<p id="res-4509"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5032" title=" Working Draft, Standard for Programming Language C++">N5032</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A</b>: Forbid program-defined <code>std::optional&lt;T&gt;</code> specializations
</p>

<ol>
<li><p>Modify 22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a> as indicated:</p>

<blockquote>
<p>
-2- A type <code class='backtick'>X</code> is a <i>valid contained type</i> for <code class='backtick'>optional</code> [&hellip;]. If <code class='backtick'>T</code> is an object type, 
<code class='backtick'>T</code> shall meet the <i>Cpp17Destructible</i> requirements (Table 35).
<p/>
<ins>-?- The behavior of a program that adds a specialization for <code class='backtick'>optional</code> is undefined.</ins>
</p>
</blockquote>
</li>

</ol>

<p>
<b>Option B</b>: Add a <code>std::optional&lt;T&gt;</code> constructor taking an invocable
</p>

<ol>
<li><p>Modify 22.2.1 <a href="https://timsong-cpp.github.io/cppwp/utility.syn">[utility.syn]</a>, header <code>&lt;utility&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std {
  [&hellip;]
  template&lt;size_t I&gt;
    struct in_place_index_t {
      explicit in_place_index_t() = default;
    };
  template&lt;size_t I&gt; constexpr in_place_index_t&lt;I&gt; in_place_index{};
  
  <ins><i>// construction from arbitrary initializers</i></ins>
  
  <ins>struct from_continuation_t {
    explicit from_continuation_t() = default;
  };
  inline constexpr from_continuation_t from_continuation{};</ins>
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T&gt;
  class optional {
  public:
    [&hellip;]
    <i>// 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>, constructors</i>
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    [&hellip;]
    template&lt;class... Args&gt;
      constexpr explicit optional(in_place_t, Args&amp;&amp;...);
    template&lt;class U, class... Args&gt;
      constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    <ins>template&lt;class F, class... Args&gt;
      constexpr explicit optional(from_continuation_t, F&amp;&amp;, Args&amp;&amp;...);</ins>
    template&lt;class U = remove_cv_t&lt;T&gt;&gt;
      constexpr explicit(<i>see below</i>) optional(U&amp;&amp;);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-18- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-22- <i>Remarks</i>: If <code class='backtick'>T</code>'s constructor selected for the initialization is a constexpr constructor, 
this constructor is a constexpr constructor.
</p>
</blockquote>
<pre>
<ins>template&lt;class F, class... Args&gt;
  constexpr explicit optional(from_continuation_t, F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates</i>: <code>decltype(std::invoke(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</code> is <code class='backtick'>T</code>.</ins>
<p/>
<ins>-?- <i>Effects</i>:  Direct-non-list-initializes <code><i>val</i></code> with 
<code>std::invoke(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</code>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <code class='backtick'>*this</code> contains a value.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.ref.general">[optional.optional.ref.general]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T&gt;
  class optional&lt;T&amp;&gt; {
  public:
    [&hellip;]
    <i>// 22.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.ctor">[optional.ref.ctor]</a>, constructors</i>
    constexpr optional() noexcept = default;
    constexpr optional(nullopt_t) noexcept : optional() {}
    [&hellip;]
    template&lt;class Arg&gt;
      constexpr explicit optional(in_place_t, Arg&amp;&amp; arg);
    <ins>template&lt;class F, class... Args&gt;
      constexpr explicit optional(from_continuation_t, F&amp;&amp; f, Args&amp;&amp;... args);</ins>
    template&lt;class U&gt;
      constexpr explicit(<i>see below</i>) optional(U&amp;&amp; u) noexcept(<i>see below</i>);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.ctor">[optional.ref.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U, class Arg&gt;
  constexpr explicit optional(in_place_t, Arg&amp;&amp; arg);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: [&hellip;]
<p/>
-2- <i>Effects</i>: [&hellip;]
<p/>
-3- <i>Postconditions</i>: [&hellip;]
</p>
</blockquote>
<pre>
<ins>template&lt;class F, class Arg&gt;
  constexpr explicit optional(from_continuation_t, F&amp;&amp; f, Arg&amp;&amp; arg);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates</i>: <code>decltype(std::invoke(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...))</code> 
is <code>T&amp;</code>.</ins>
<p/>
<ins>-?- <i>Effects</i>: Equivalent to: <code><i>convert-ref-init-val</i>(std::invoke(std::forward&lt;F&gt;(f), 
std::forward&lt;Args&gt;(args)...))</code>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <code class='backtick'>*this</code> contains a value.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>







</body>
</html>
