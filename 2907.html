<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 2907: Semantics for destroying the deleter and the control-block of a shared_ptr are unclear</title>
<meta property="og:title" content="Issue 2907: Semantics for destroying the deleter and the control-block of a shared_ptr are unclear">
<meta property="og:description" content="C++ library issue. Status: NAD">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/2907.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="2907"><a href="lwg-closed.html#2907">2907</a>. Semantics for destroying the deleter and the control-block of a <code>shared_ptr</code> are unclear</h3>
<p><b>Section:</b> 20.3.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.dest">issues</a> in [util.smartptr.shared.dest].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 134</b>

<p>The semantics for destroying the deleter and the control-block are unclear. In particular, it is not clear that we 
guarantee a lack of race conditions destroying the control-block and deleter. Possible race-free implementations might 
destroy the deleter after running <code>d(p)</code>, and before giving up the weak reference held by this <code>shared_ptr</code>; 
running the destructor for <code>d</code> only when the last <code>weak_ptr</code> is destroyed, potentially at a much later date, 
but ensuring that <code>d(p)</code> completes before the <code>shared_ptr</code> gives up its weak reference; making a copy of 
<code>d</code> in the destructor before manipulating the weak count, and then using this copy to run <code>d(p)</code>, even while 
the control-block could be concurrently reclaimed with an expiring <code>weak_ptr</code> in another thread. Note that this 
may be related to LWG <a href="2751" title="shared_ptr deleter not specified to observe expired weak_ptr instances (Status: New)">2751</a>. (Also, see the note in 20.11.2.2.10 p1 [util.smartptr.getdeleter])</p>

<p>Proposed change: Clarify that the <code>shared_ptr</code> weak ownership of the control block is released at the end of the 
destructor, and not as the destructor begins. Otherwise, the deleter might be destroyed even before the destructor gets to 
move a copy to call safely.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>NAD; Alisdair to provide rationale</p>


<p id="res-2907"><b>Proposed resolution:</b></p>
<p>
</p>





</body>
</html>
