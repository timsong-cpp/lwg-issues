<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2010: is_* traits for binding operations can't be meaningfully specialized</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-15 at 21:11:26 UTC</p>
<hr>
<h3><a name="2010" href="#2010">2010.</a> <tt>is_* traits</tt> for binding operations can't be meaningfully specialized</h3>
<p><b>Section:</b> 20.14.10.1 [func.bind.isbind] <b>Status:</b> <a href="lwg-active.html#C++14">C++14</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2010-07-19 <b>Last modified:</b> 2016-11-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.bind.isbind">issues</a> in [func.bind.isbind].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++14">C++14</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.14.10.1 [func.bind.isbind] says for <tt>is_bind_expression</tt>:
</p>

<blockquote><p>
Users may specialize this template to indicate that a type should be
treated as a subexpression in a <tt>bind</tt> call.
</p></blockquote>

<p>
But it also says:
</p>

<blockquote><p>
If <tt>T</tt> is a type returned from <tt>bind</tt>,
<tt>is_bind_expression&lt;T&gt;</tt> shall be publicly derived from
<tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from
<tt>integral_constant&lt;bool, false&gt;</tt>.
</p></blockquote>

<p>
This means that while the user is free to specialize, any specialization
would have to be <tt>false</tt> to avoid violating the second
requirement. A similar problem exists for <tt>is_placeholder</tt>.
</p>

<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Alisdair recognises this is clearly a bug introduced by some wording he
wrote, the sole purpose of this metafunction is as a customization point
for users to write their own <tt>bind</tt>-expression types that participate
in the standard library <tt>bind</tt> protocol.  The consensus was that this
should be fixed in Madrid, moved to Open.
</p>

<p><i>[2011-05-13 Jonathan Wakely comments and provides proposed wording]</i></p>


<p>
The requirements are that <tt>is_bind_expression&lt;T&gt;::value</tt> is true when <tt>T</tt>
is a type returned from <tt>bind</tt>, false for any other type, except when
there's a specialization involving a user-defined type (N.B. 17.6.4.2.1 [namespace.std] 
means we don't need to say e.g. <tt>is_bind_expression&lt;string&gt;</tt> is false.)
<p/>
The obvious way to meet the requirements is for the primary template
to derive from <tt>integral_constant&lt;bool, false&gt;</tt> and for implementations
to provide specializations for the unspecified types returned from
<tt>bind</tt>.  User-defined specializations can do whatever they like, as long
as <tt>is_bind_expression::value</tt> is sane. There's no reason to forbid
users from defining <tt>is_bind_expression&lt;<i>user_defined_type</i>&gt;::value=false</tt>
if that's what they want to do.
<p/>
Similar reasoning applies to <tt>is_placeholder</tt>, but a further issue is
that 20.14.10.1 [func.bind.isbind] contains wording for <tt>is_placeholder</tt> but
contains no definition of it and the sub-clause name only refers to
<tt>is_bind_expression</tt>. The wording below proposes splitting paragraphs 3
and 4 of 20.14.10.1 [func.bind.isbind] into a new sub-clause covering
<tt>is_placeholder</tt>.
<p/>
If the template specializations added by the proposed wording are too
vague then they could be preceded by "for exposition only" comments
</p>

<p><i>[2011-05-18 Daniel comments and provides some refinements to the P&#47;R]</i></p>


<p>
Both <tt>bind</tt>-related type traits should take advantage of the
UnaryTypeTrait requirements. Additionally, the updated wording does not
imply that the implementation provides several specializations. Wording was 
used similar to the specification of the <tt>uses_allocator</tt> type trait 
(which unfortunately is not expressed in terms of BinaryTypeTrait requirements).
</p>

<p><i>[Bloomington, 2011]</i></p>

<p>
Move to Ready
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Change 20.14.10.1 [func.bind.isbind] to:</p>

<blockquote><pre>
namespace std {
  template&lt;class T&gt; struct is_bind_expression<ins>; <i>// see below</i></ins>
    <del>: integral_constant&lt;bool, <i>see below</i>&gt; { };</del>
}
</pre><blockquote><p>
-1- <tt>is_bind_expression</tt> can be used to detect function objects generated by <tt>bind</tt>. <tt>bind</tt> 
uses <tt>is_bind_expression</tt> to detect subexpressions. <del>Users may specialize this template to indicate 
that a type should be treated as a subexpression in a <tt>bind</tt> call.</del>
<p/>
-2- <del>If <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>is_bind_expression&lt;T&gt;</tt> shall 
be publicly derived from <tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from 
<tt>integral_constant&lt;bool, false&gt;</tt></del><ins>Instantiations of the <tt>is_bind_expression</tt> template
shall meet the UnaryTypeTrait requirements ([meta.rqmts]). The implementation shall provide a definition
that has a BaseCharacteristic of <tt>true_type</tt> if <tt>T</tt> is a type returned from <tt>bind</tt>, otherwise 
it shall have a BaseCharacteristic of <tt>false_type</tt>. A program may specialize this template for a user-defined 
type <tt>T</tt> to have a BaseCharacteristic of <tt>true_type</tt> to indicate that <tt>T</tt> should be treated 
as a subexpression in a <tt>bind</tt> call.</ins>.
<p/>
<del>-3- <tt>is_placeholder</tt> can be used to detect the standard placeholders <tt>_1</tt>, <tt>_2</tt>, and so on. 
<tt>bind</tt> uses <tt>is_placeholder</tt> to detect placeholders. Users may specialize this template to indicate 
a placeholder type.</del>
<p/>
<del>-4- If <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, <tt>is_placeholder&lt;T&gt;</tt> shall be 
publicly derived from <tt>integral_constant&lt;int, J&gt;</tt>, otherwise from <tt>integral_constant&lt;int, 0&gt;</tt>.</del>
</p></blockquote></blockquote>
</li>
<li><p>Insert a new sub-clause immediately following sub-clause 20.14.10.1 [func.bind.isbind], the suggested
sub-clause tag is [func.bind.isplace]:
</p>
<h3><ins>20.8.9.1.?  Class template <tt>is_placeholder</tt>  [func.bind.isplace]</ins></h3> 
<blockquote><pre>
<ins>namespace std {
  template&lt;class T&gt; struct is_placeholder; <i>// see below</i>
}</ins>
</pre><blockquote><p>
<ins>-?- <tt>is_placeholder</tt> can be used to detect the standard placeholders <tt>_1</tt>, <tt>_2</tt>, and so on. 
<tt>bind</tt> uses <tt>is_placeholder</tt> to detect placeholders.</ins>
<p/>
<ins>-?- Instantiations of the <tt>is_placeholder</tt> template shall meet the UnaryTypeTrait requirements ([meta.rqmts]). 
The implementation shall provide a definition that has a BaseCharacteristic of <tt>integral_constant&lt;int, J&gt;</tt> 
if <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, otherwise it shall have a BaseCharacteristic of 
<tt>integral_constant&lt;int, 0&gt;</tt>. A program may specialize this template for a user-defined type <tt>T</tt> 
to have a BaseCharacteristic of <tt>integral_constant&lt;int, <i>N</i>&gt;</tt> with <tt><i>N</i> &gt; 0</tt> 
to indicate that <tt>T</tt> should be treated as a placeholder type.</ins>
</p></blockquote></blockquote>
</li>
</ol>





</body>
</html>
