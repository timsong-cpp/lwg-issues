<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2104: unique_lock move-assignment should not be noexcept</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="2104" href="lwg-defects.html#2104">2104.</a> <tt>unique_lock</tt> move-assignment should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 31.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique">[thread.lock.unique]</a> <b>Status:</b> <a href="lwg-active.html#C++14">C++14</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2011-11-27 <b>Last modified:</b> 2017-07-05 22:14:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++14">C++14</a> status.</p>
<p><b>Discussion:</b></p>

<p>
I just noticed that the <tt>unique_lock</tt> move-assignment operator is declared <tt>noexcept</tt>. This 
function may call <tt>unlock()</tt> on the wrapped mutex, which may throw.
<p/>
Suggested change: remove the <tt>noexcept</tt> specification from <tt>unique_lock::operator=(unique_lock&amp;&amp;)</tt> 
in 31.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique">[thread.lock.unique]</a> and 31.4.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique.cons">[thread.lock.unique.cons]</a>. 
<p/>
Daniel:
<p/>
I think the situation is actually a bit more complex as it initially looks.
<p/>
First, the effects of the move-assignment operator are (emphasize mine):
</p>
<blockquote><p>
<i>Effects</i>: <strong>If</strong> <tt>owns</tt> calls <tt>pm->unlock()</tt>.
</p></blockquote>
<p>
Now according to the <tt>BasicLockable</tt> requirements:
</p>
<blockquote><p>
<tt>m.unlock()</tt>
<p/>
3 <i>Requires</i>: The current execution agent shall hold a lock on <tt>m</tt>.
<p/>
4 <i>Effects</i>: Releases a lock on <tt>m</tt> held by the current execution agent.
<p/>
<i>Throws</i>: Nothing.
</p></blockquote>
<p>
This shows that unlock itself is a function with narrow contract and for 
this reasons no unlock function of a mutex or lock itself does have a noexcept 
specifier according to our mental model.
<p/>
Now the move-assignment operator <strong>attempts</strong> to satisfy these
requirement of the function and calls it only when it assumes that the conditions 
are ok, so from the view-point of the caller of the move-assignment operator it 
looks as if the move-assignment operator would in total a function with a
wide contract.
<p/>
The problem with this analysis so far is, that it depends on the assumed 
correctness of the state "owns".
<p/>
Looking at the construction or state-changing functions, there do exist several 
ones that depend on caller-code satisfying the requirements and there is one 
guy, who looks most suspicious:
</p>
<blockquote><p>
<tt>unique_lock(mutex_type&amp; m, adopt_lock_t);</tt>
<p/>
11 <i>Requires</i>: The calling thread own the mutex.<br/>
[&hellip;]<br/>
13 <i>Postconditions</i>: <tt>pm == &amp;m</tt> and <tt>owns == true</tt>.<br/>
</p></blockquote>
<p>
because this function does not even call <tt>lock()</tt> (which may, but is not 
required to throw an exception if the calling thread does already own the mutex). 
So we have in fact still a move-assignment operator that might throw an exception, 
if the mutex was either constructed or used (call of lock) incorrectly.
<p/>
The correct fix seems to me to also add a "<i>Throws</i>: Nothing" element to
the move-assignment operator, because using it correctly shall not throw an
exception.
</p>

<p><i>[Issaquah 2014-02-11: Move to Immediate after SG1 review]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Change 31.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique">[thread.lock.unique]</a>, class template <tt>unique_lock</tt> synopsis as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Mutex&gt;
  class unique_lock {
  public:
    typedef Mutex mutex_type;
    [&hellip;]
    unique_lock(unique_lock&amp;&amp; u) noexcept;
    unique_lock&amp; operator=(unique_lock&amp;&amp; u) <del>noexcept</del>;
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li>
<p>Change 31.4.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique.cons">[thread.lock.unique.cons]</a> around p22 as indicated:</p>

<blockquote><pre>
unique_lock&amp; operator=(unique_lock&amp;&amp; u) <del>noexcept</del>;
</pre><blockquote>
<p>
-22- <i>Effects</i>: If <tt>owns</tt> calls <tt>pm->unlock()</tt>.
<p/>
-23- <i>Postconditions</i>: <tt>pm == u_p.pm</tt> and <tt>owns == u_p.owns</tt> (where <tt>u_p</tt> 
is the state of <tt>u</tt> just prior to this construction), <tt>u.pm == 0</tt> and <tt>u.owns == false</tt>.
<p/>
-24- [<i>Note</i>: With a recursive mutex it is possible for both <tt>*this</tt> and <tt>u</tt> to own 
the same mutex before the assignment. In this case, <tt>*this</tt> will own the mutex after the assignment 
and <tt>u</tt> will not. &mdash; <i>end note</i>]
</p>
<ins>-??- <i>Throws</i>: Nothing.</ins>
<p/>
</blockquote></blockquote>
</li>

</ol>






</body>
</html>
