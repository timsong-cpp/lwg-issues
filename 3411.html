<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 3411: [fund.ts.v3] Contradictory namespace rules in the Library Fundamentals TS</title>
<meta property="og:title" content="Issue 3411: [fund.ts.v3] Contradictory namespace rules in the Library Fundamentals TS">
<meta property="og:description" content="C++ library issue. Status: C++23">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/3411.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="3411"><a href="lwg-defects.html#3411">3411</a>. [fund.ts.v3] Contradictory namespace rules in the Library Fundamentals TS</h3>
<p><b>Section:</b> 5.4 [fund.ts.v3::memory.resource.syn] <b>Status:</b> <a href="lwg-active.html#C++23">C++23</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2020-02-28 <b>Last modified:</b> 2023-11-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++23">C++23</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
The Library Fundamentals TS, <a href="https://wg21.link/n4840">N4840</a>, 
contains <a href="https://wg21.link/n4840#general.namespaces">a rule about 
the use of namespaces (paragraph 1)</a>, with the consequence:
</p>
<blockquote><p>
"This TS does not define <code>std::experimental::fundamentals_v3::pmr</code>"
</p></blockquote>
<p>
However, the TS then <a href="https://wg21.link/n4840#memory.resource.syn">goes on to 
define exactly that namespace</a>.
<p/>
At the time when the subclause memory.resource.syn was added, the IS didn't use to contain 
a namespace <code>pmr</code>. When the IS adopted that namespace and the TS was rebased, the 
namespace rule started conflicting with the material in the TS.
<p/>
I do not have a workable proposed resolution at this point.
</p>

<p><i>[2020-04-07 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>

<p><i>[2021-11-17; Jiang An comments and provides wording]</i></p>

<p>
Given namespaces <code>std::chrono::experimental::fundamentals_v2</code> and <code>std::experimental::fundamentals_v2::pmr</code> 
are used in LFTS v2, I think that the intent is that
</p>
<ul>
<li><p>the prefix <code>experimental::fundamentals_v<i>N</i></code> is only added to a namespace specified by the 
standard, and</p></li>
<li><p>every name specified by the standard in the outer namespace of that of the related component in the TS.</p></li>
</ul>
<p>
If we follow the convention, perhaps we should relocate <code>resource_adaptor</code> from 
<code>std::experimental::fundamentals_v3::pmr</code> to <code>std::pmr::experimental::fundamentals_v3</code> in LFTS v3.
If it's decided that <code>resource_adaptor</code> shouldn't be relocated, I suppose that LWG 3411 can be by striking 
the wrong wording in 1.3 [fund.ts.v3::general.namespaces] and using qualified <code>std::pmr::memory_resource</code> 
when needed.
</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4853">N4853</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b>
</p>

<ol>

<li><p>Modify 1.3 [fund.ts.v3::general.namespaces] as indicated:</p>

<blockquote>
<p>
-2- Each header described in this technical specification shall import the contents of 
<code><ins><i>outer-namespace</i></ins><del>std</del>::experimental::fundamentals_v3</code> 
into <code><ins><i>outer-namespace</i></ins><del>std</del>::experimental</code> as if by
</p>
<blockquote><pre>
namespace <ins><i>outer-namespace</i></ins><del>std</del>::experimental::inline fundamentals_v3 {}
</pre></blockquote>
<p>
<ins>where <code><i>outer-namespace</i></code> is a namespace defined in the C++ Standard Library.</ins>
</p>
</blockquote>
</li>

<li><p>Modify 5.3 [fund.ts.v3::memory.type.erased.allocator], Table 5, as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 5 &mdash; Computed <code>memory_resource</code> for type-erased allocator</caption>
<tr style="text-align:center">
<th>If the type of <code>alloc</code> is</th>
<th>then the value of <code>rptr</code> is</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>any other type meeting the <i></i> requirements (C++20 &para;16.5.3.5)</td>
<td>a pointer to a value of type <code>pmr::<ins>experimental::</ins>resource_adaptor&lt;A&gt;</code> where <code>A</code> 
is the type of <code>alloc</code>. <code>rptr</code> remains valid only for the lifetime of <code>X</code>.</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify 5.4 [fund.ts.v3::memory.resource.syn], header <code>&lt;experimental/memory_resource&gt;</code> 
synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::<ins>pmr::</ins>experimental::inline fundamentals_v3<del>::pmr</del> {
[&hellip;]
} // namespace std::<ins>pmr::</ins>experimental::inline fundamentals_v3<del>::pmr</del>
</pre>
</blockquote>
</li>

</ol>

<p>
<b>Option B:</b>
</p>

<ol>

<li><p>Modify 1.3 [fund.ts.v3::general.namespaces] as indicated:</p>

<blockquote>
<p>
-1- Since the extensions described in this technical specification are experimental and not part 
of the C++ standard library, they should not be declared directly within namespace <code>std</code>. 
Unless otherwise specified, all components described in this technical specification either: 
</p>
<ol style="list-style-type: none">
<li><p>&mdash; modify an existing interface in the C++ Standard Library in-place,</p></li>
<li><p>&mdash; are declared in a namespace whose name appends <code>::experimental::fundamentals_v3</code> to a 
namespace defined in the C++ Standard Library, such as <code>std</code> or <code>std::chrono</code>, or</p></li>
<li><p>&mdash; are declared in a subnamespace of a namespace described in the previous bullet<del>, whose name is 
not the same as an existing subnamespace of namespace <code>std</code></del>.</p></li>
</ol>
<p>
<del>[<i>Example:</i> This TS does not define <code>std::experimental::fundamentals_v3::pmr</code> because 
the C++ Standard Library defines <code>std::pmr</code>. &mdash; <i>end example</i>] </del>
</p>
</blockquote>
</li>

<li><p>Modify 4.2 [fund.ts.v3::func.wrap.func], class template <code>function</code> 
synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  namespace experimental::inline fundamentals_v3 {

    template&lt;class&gt; class function; <i>// undefined</i>

    template&lt;class R, class... ArgTypes&gt;
    class function&lt;R(ArgTypes...)&gt; {
    public:
      [&hellip;]
      <ins>std::</ins>pmr::memory_resource* get_memory_resource() const noexcept;
    };
[&hellip;]
} // namespace experimental::inline fundamentals_v3
[&hellip;]
} // namespace std
</pre>
</blockquote>
</li>

<li><p>Modify 5.3 [fund.ts.v3::memory.type.erased.allocator], Table 5, as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 5 &mdash; Computed <code>memory_resource</code> for type-erased allocator</caption>
<tr style="text-align:center">
<th>If the type of <code>alloc</code> is</th>
<th>then the value of <code>rptr</code> is</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>any other type meeting the <i></i> requirements (C++20 &para;16.5.3.5)</td>
<td>a pointer to a value of type <code><ins>experimental::</ins>pmr::resource_adaptor&lt;A&gt;</code> where <code>A</code> 
is the type of <code>alloc</code>. <code>rptr</code> remains valid only for the lifetime of <code>X</code>.</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify 5.5.1 [fund.ts.v3::memory.resource.adaptor.overview] as indicated:</p>

<blockquote>
<p>
-1- An instance of <code>resource_adaptor&lt;Allocator&gt;</code> is an adaptor that wraps a 
<code><ins>std::pmr::</ins>memory_resource</code> interface around <code>Allocator</code>. [&hellip;]
</p>
<blockquote>
<pre>
<i>// The name <code>resource_adaptor_imp</code> is for exposition only.</i>
template&lt;class Allocator&gt;
class <i>resource_adaptor_imp</i> : public <ins>std::pmr::</ins>memory_resource {
public:
  [&hellip;]
  
  virtual bool do_is_equal(const <ins>std::pmr::</ins>memory_resource&amp; other) const noexcept;
};
</pre>
</blockquote>
</blockquote>
</li>

<li><p>Modify 5.5.3 [fund.ts.v3::memory.resource.adaptor.mem] as indicated:</p>

<blockquote>
<pre>
-6- bool do_is_equal(const <ins>std::pmr::</ins>memory_resource&amp; other) const noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 7.2 [fund.ts.v3::futures.promise], class template <code>promise</code> 
synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  namespace experimental::inline fundamentals_v3 {

    template&lt;class R&gt;
    class promise {
    public:
      [&hellip;]
      <ins>std::</ins>pmr::memory_resource* get_memory_resource() const noexcept;
    };
[&hellip;]
} // namespace experimental::inline fundamentals_v3
[&hellip;]
} // namespace std
</pre>
</blockquote>
</li>

<li><p>Modify 7.3 [fund.ts.v3::futures.task], class template <code>packaged_task</code> 
synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  namespace experimental::inline fundamentals_v3 {

    template&lt;class R, class... ArgTypes&gt;
    class packaged_task&lt;R(ArgTypes...)&gt; {
    public:
      [&hellip;]
      <ins>std::</ins>pmr::memory_resource* get_memory_resource() const noexcept;
    };
[&hellip;]
} // namespace experimental::inline fundamentals_v3
[&hellip;]
} // namespace std
</pre>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2022-10-12; Jonathan provides updated wording]</i></p>

<p>
The LWG telecon decided on a simpler form of <b>Option A</b>.
The changes to 1.3 [fund.ts.v3::general.namespaces] generated some questions
and disagreement, but it was decided that they are not needed anyway.
The normative synopses already depict the use of inline namespaces with the
stated effects. That paragraph seems more informative than normative, and there
were suggestions to strike it entirely. It was decided to keep it but without
making the edits.  As such, it remains correct for the contents of
<code>std::experimental::fundamentals_v3</code>. It doesn't apply to
<code>pmr::resource_adaptor</code>, but is not <i>incorrect</i> for that either.
The rest of the proposed resolution fully specifies the <code>pmr</code> parts.
</p>

<p><i>[2022-10-19; Reflector poll]</i></p>

<p>
Set status to "Tentatively Ready" after eight votes in favour in reflector poll.
</p>

<p><i>[2022-11-12 Approved at November 2022 meeting in Kona. Status changed: Voting &rarr; WP.]</i></p>



<p id="res-3411"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4920">N4920</a>.
</p>

<ol>

<li><p>Modify 5.3 [fund.ts.v3::memory.type.erased.allocator], Table 5, as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 5 &mdash; Computed <code>memory_resource</code> for type-erased allocator</caption>
<tr style="text-align:center">
<th>If the type of <code>alloc</code> is</th>
<th>then the value of <code>rptr</code> is</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>any other type meeting the <i></i> requirements (C++20 &para;16.5.3.5)</td>
<td>a pointer to a value of type <code>pmr::<ins>experimental::</ins>resource_adaptor&lt;A&gt;</code> where <code>A</code> 
is the type of <code>alloc</code>. <code>rptr</code> remains valid only for the lifetime of <code>X</code>.</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify 5.4 [fund.ts.v3::memory.resource.syn], header <code>&lt;experimental/memory_resource&gt;</code> 
synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::<ins>pmr::</ins>experimental::inline fundamentals_v3<del>::pmr</del> {
[&hellip;]
} // namespace std::<ins>pmr::</ins>experimental::inline fundamentals_v3<del>::pmr</del>
</pre>
</blockquote>
</li>

</ol>





</body>
</html>
