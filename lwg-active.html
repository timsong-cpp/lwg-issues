<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Active Issues List</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<table>
<tr>
  <td align="left">Doc. no.</td>
  <td align="left">D????</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">2017-03-19</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">Programming Language C++</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h1>C++ Standard Library Active Issues List (Revision D103)</h1>
<p><p>Revised 2017-03-19 at 19:03:20 UTC</p>
</p>
  <p>Reference ISO/IEC IS 14882:2014(E)</p>
  <p>Also see:</p>
  <ul>
      <li><a href="lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="lwg-defects.html">Library Defect Reports List</a></li>
      <li><a href="lwg-closed.html">Library Closed Issues List</a></li>
  </ul>
  <p>The purpose of this document is to record the status of issues
  which have come before the Library Working Group (LWG) of the INCITS PL22.16
  and ISO WG21 C++ Standards Committee. Issues represent
  potential defects in the ISO/IEC IS 14882:2014(E) document.  
  </p>

  <p>This document contains only library issues which are actively being
  considered by the Library Working Group, i.e., issues which have a
  status of <a href="lwg-active.html#New">New</a>, <a href="lwg-active.html#Open">Open</a>, 
  <a href="lwg-active.html#Ready">Ready</a>, or <a href="lwg-active.html#Review">Review</a>.
  See <a href="lwg-defects.html">Library Defect Reports List</a> for issues considered defects
  and <a href="lwg-closed.html">Library Closed Issues List</a> for issues considered closed.</p>

  <p>The issues in these lists are not necessarily formal ISO Defect
  Reports (DR's). While some issues will eventually be elevated to
  official Defect Report status, other issues will be disposed of in
  other ways. See <a href="#Status">Issue Status</a>.</p>

  <p>Prior to Revision 14, library issues lists existed in two slightly
  different versions; a Committee Version and a Public
  Version. Beginning with Revision 14 the two versions were combined
  into a single version.</p>

  <p>This document includes <i>[bracketed italicized notes]</i> as a
  reminder to the LWG of current progress on issues. Such notes are
  strictly unofficial and should be read with caution as they may be
  incomplete or incorrect. Be aware that LWG support for a particular
  resolution can quickly change if new viewpoints or killer examples are
  presented in subsequent discussions.</p>

  <p>For the most current official version of this document see 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/">http://www.open-std.org/jtc1/sc22/wg21/</a>.
  Requests for further information about this document should include
  the document number above, reference ISO/IEC 14882:2014(E), and be
  submitted to Information Technology Industry Council (ITI), 1250 Eye
  Street NW, Washington, DC 20005.</p>

  <p>Public information as to how to obtain a copy of the C++ Standard,
  join the standards committee, submit an issue, or comment on an issue
  can be found in the comp.std.c++ FAQ.
  </p>

<p><a name="submit_issue"></a><b>How to submit an issue</b></p>

<ol style="list-style-type:upper-alpha">
<li><a name="submit_issue_A"></a>
Mail your issue to the author of this list.
</li>
<li><a name="submit_issue_B"></a>
Specify a short descriptive title.  If you fail to do so, the subject line of your
mail will be used as the issue title.
</li>
<li><a name="submit_issue_C"></a>
If the "From" on your email is not the name you wish to appear as issue submitter,
then specify issue submitter.
</li>
<li><a name="submit_issue_D"></a>
Provide a brief discussion of the problem you wish to correct.  Refer to the latest
working draft or standard using [section.tag] and paragraph numbers where appropriate.
</li>
<li><a name="submit_issue_E"></a>
Provide proposed wording.  This should indicate exactly how you want the standard
to be changed.  General solution statements belong in the discussion area.  This
area contains very clear and specific directions on how to modify the current
draft.  If you are not sure how to word a solution, you may omit this part.
But your chances of a successful issue greatly increase if you attempt wording.
</li>
<li><a name="submit_issue_F"></a>
It is not necessary for you to use html markup.  However, if you want to, you can
&lt;ins&gt;<ins>insert text like this</ins>&lt;/ins&gt; and &lt;del&gt;<del>delete text like
this</del>&lt;/del&gt;.  The only strict requirement is to communicate clearly to
the list maintainer exactly how you want your issue to look.
</li>
<li><a name="submit_issue_G"></a>
It is not necessary for you to specify other html font/formatting
mark-up, but if you do the list maintainer will attempt to respect your
formatting wishes (as described by html markup, or other common idioms).
</li>
<li><a name="submit_issue_H"></a>
It is not necessary for you to specify open date or last modified date (the date
of your mail will be used).
</li>
<li><a name="submit_issue_I"></a>
It is not necessary for you to cross reference other issues, but you can if you
like.  You do not need to form the hyperlinks when you do, the list maintainer will
take care of that.
</li>
<li><a name="submit_issue_J"></a>
One issue per email is best.
</li>
<li><a name="submit_issue_K"></a>
Between the time you submit the issue, and the next mailing deadline
(date at the top of the Revision History), you <em>own</em> this issue. 
You control the content, the stuff that is right, the stuff that is
wrong, the format, the misspellings, etc.  You can even make the issue
disappear if you want.  Just let the list maintainer know how you want
it to look, and he will try his best to accommodate you.  After the
issue appears in an official mailing, you no longer enjoy exclusive
ownership of it.
</li>
</ol>


<h2>Revision History</h2>
<ul>
<li>D103: 2017-03-20 2017 post-Kona mailing<ul>
<li><b>Summary:</b><ul>
<li>219 open issues, down by 86.</li>
<li>2176 closed issues, up by 104.</li>
<li>73 reassigned issues, up by 0.</li>
<li>2468 issues total, up by 18.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Ready issue: <a href="2932">2932</a>.</li>
<li>Added the following Tentatively Ready issue: <a href="2937">2937</a>.</li>
<li>Added the following 13 New issues: <a href="2929">2929</a>, <a href="2933">2933</a>, <a href="2935">2935</a>, <a href="2936">2936</a>, <a href="2938">2938</a>, <a href="2939">2939</a>, <a href="2940">2940</a>, <a href="2941">2941</a>, <a href="2942">2942</a>, <a href="2943">2943</a>, <a href="2944">2944</a>, <a href="2945">2945</a>, <a href="2946">2946</a>.</li>
<li>Added the following Open issue: <a href="2931">2931</a>.</li>
<li>Added the following Pending WP issue: <a href="2934">2934</a>.</li>
<li>Added the following NAD issue: <a href="2930">2930</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="2783">2783</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="2444">2444</a>, <a href="2597">2597</a>.</li>
<li>Changed the following issue to Review (from SG1): <a href="2412">2412</a>.</li>
<li>Changed the following issue to Open (from New): <a href="2894">2894</a>.</li>
<li>Changed the following 2 issues to Core (from New): <a href="2859">2859</a>, <a href="2860">2860</a>.</li>
<li>Changed the following 6 issues to Pending WP (from Ready): <a href="2781">2781</a>, <a href="2782">2782</a>, <a href="2784">2784</a>, <a href="2785">2785</a>, <a href="2786">2786</a>, <a href="2787">2787</a>.</li>
<li>Changed the following 18 issues to Pending WP (from Tentatively Ready): <a href="2260">2260</a>, <a href="2768">2768</a>, <a href="2769">2769</a>, <a href="2789">2789</a>, <a href="2794">2794</a>, <a href="2795">2795</a>, <a href="2804">2804</a>, <a href="2812">2812</a>, <a href="2824">2824</a>, <a href="2826">2826</a>, <a href="2834">2834</a>, <a href="2835">2835</a>, <a href="2837">2837</a>, <a href="2838">2838</a>, <a href="2842">2842</a>, <a href="2850">2850</a>, <a href="2853">2853</a>, <a href="2855">2855</a>.</li>
<li>Changed the following 3 issues to Pending WP (from Review): <a href="2676">2676</a>, <a href="2790">2790</a>, <a href="2796">2796</a>.</li>
<li>Changed the following 22 issues to Pending WP (from New): <a href="2788">2788</a>, <a href="2801">2801</a>, <a href="2802">2802</a>, <a href="2806">2806</a>, <a href="2807">2807</a>, <a href="2861">2861</a>, <a href="2866">2866</a>, <a href="2868">2868</a>, <a href="2872">2872</a>, <a href="2873">2873</a>, <a href="2874">2874</a>, <a href="2875">2875</a>, <a href="2876">2876</a>, <a href="2878">2878</a>, <a href="2890">2890</a>, <a href="2900">2900</a>, <a href="2903">2903</a>, <a href="2904">2904</a>, <a href="2905">2905</a>, <a href="2908">2908</a>, <a href="2911">2911</a>, <a href="2921">2921</a>.</li>
<li>Changed the following issue to Pending WP (from LEWG): <a href="2857">2857</a>.</li>
<li>Changed the following issue to Pending Resolved (from Review): <a href="2245">2245</a>.</li>
<li>Changed the following 22 issues to Pending Resolved (from New): <a href="2715">2715</a>, <a href="2803">2803</a>, <a href="2863">2863</a>, <a href="2869">2869</a>, <a href="2879">2879</a>, <a href="2887">2887</a>, <a href="2888">2888</a>, <a href="2889">2889</a>, <a href="2895">2895</a>, <a href="2912">2912</a>, <a href="2913">2913</a>, <a href="2914">2914</a>, <a href="2915">2915</a>, <a href="2917">2917</a>, <a href="2918">2918</a>, <a href="2919">2919</a>, <a href="2920">2920</a>, <a href="2924">2924</a>, <a href="2925">2925</a>, <a href="2926">2926</a>, <a href="2927">2927</a>, <a href="2928">2928</a>.</li>
<li>Changed the following 5 issues to Resolved (from New): <a href="2862">2862</a>, <a href="2864">2864</a>, <a href="2867">2867</a>, <a href="2877">2877</a>, <a href="2882">2882</a>.</li>
<li>Changed the following 19 issues to Resolved (from Tentatively Resolved): <a href="839">839</a>, <a href="1041">1041</a>, <a href="2179">2179</a>, <a href="2208">2208</a>, <a href="2241">2241</a>, <a href="2294">2294</a>, <a href="2343">2343</a>, <a href="2370">2370</a>, <a href="2391">2391</a>, <a href="2424">2424</a>, <a href="2443">2443</a>, <a href="2501">2501</a>, <a href="2502">2502</a>, <a href="2505">2505</a>, <a href="2529">2529</a>, <a href="2548">2548</a>, <a href="2663">2663</a>, <a href="2677">2677</a>, <a href="2757">2757</a>.</li>
<li>Changed the following 3 issues to NAD (from New): <a href="2256">2256</a>, <a href="2449">2449</a>, <a href="2865">2865</a>.</li>
<li>Changed the following 2 issues to Dup (from New): <a href="2764">2764</a>, <a href="2896">2896</a>.</li>
</ul></li>
</ul>
</li>
<li>R102: 
2017-02-06 2017 pre-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>305 open issues, up by 89.</li>
<li>2072 closed issues, up by 9.</li>
<li>73 reassigned issues, up by 5.</li>
<li>2450 issues total, up by 103.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 9 Tentatively Ready issues: <a href="2826">2826</a>, <a href="2834">2834</a>, <a href="2835">2835</a>, <a href="2837">2837</a>, <a href="2838">2838</a>, <a href="2842">2842</a>, <a href="2850">2850</a>, <a href="2853">2853</a>, <a href="2855">2855</a>.</li>
<li>Added the following 89 New issues: <a href="2827">2827</a>, <a href="2829">2829</a>, <a href="2832">2832</a>, <a href="2833">2833</a>, <a href="2836">2836</a>, <a href="2839">2839</a>, <a href="2840">2840</a>, <a href="2841">2841</a>, <a href="2843">2843</a>, <a href="2844">2844</a>, <a href="2845">2845</a>, <a href="2846">2846</a>, <a href="2847">2847</a>, <a href="2848">2848</a>, <a href="2849">2849</a>, <a href="2851">2851</a>, <a href="2852">2852</a>, <a href="2856">2856</a>, <a href="2858">2858</a>, <a href="2859">2859</a>, <a href="2860">2860</a>, <a href="2861">2861</a>, <a href="2862">2862</a>, <a href="2863">2863</a>, <a href="2864">2864</a>, <a href="2865">2865</a>, <a href="2866">2866</a>, <a href="2867">2867</a>, <a href="2868">2868</a>, <a href="2869">2869</a>, <a href="2870">2870</a>, <a href="2871">2871</a>, <a href="2872">2872</a>, <a href="2873">2873</a>, <a href="2874">2874</a>, <a href="2875">2875</a>, <a href="2876">2876</a>, <a href="2877">2877</a>, <a href="2878">2878</a>, <a href="2879">2879</a>, <a href="2880">2880</a>, <a href="2881">2881</a>, <a href="2882">2882</a>, <a href="2883">2883</a>, <a href="2884">2884</a>, <a href="2885">2885</a>, <a href="2886">2886</a>, <a href="2887">2887</a>, <a href="2888">2888</a>, <a href="2889">2889</a>, <a href="2890">2890</a>, <a href="2891">2891</a>, <a href="2892">2892</a>, <a href="2893">2893</a>, <a href="2894">2894</a>, <a href="2895">2895</a>, <a href="2896">2896</a>, <a href="2897">2897</a>, <a href="2898">2898</a>, <a href="2899">2899</a>, <a href="2900">2900</a>, <a href="2901">2901</a>, <a href="2902">2902</a>, <a href="2903">2903</a>, <a href="2904">2904</a>, <a href="2905">2905</a>, <a href="2906">2906</a>, <a href="2907">2907</a>, <a href="2908">2908</a>, <a href="2909">2909</a>, <a href="2910">2910</a>, <a href="2911">2911</a>, <a href="2912">2912</a>, <a href="2913">2913</a>, <a href="2914">2914</a>, <a href="2915">2915</a>, <a href="2916">2916</a>, <a href="2917">2917</a>, <a href="2918">2918</a>, <a href="2919">2919</a>, <a href="2920">2920</a>, <a href="2921">2921</a>, <a href="2922">2922</a>, <a href="2923">2923</a>, <a href="2924">2924</a>, <a href="2925">2925</a>, <a href="2926">2926</a>, <a href="2927">2927</a>, <a href="2928">2928</a>.</li>
<li>Added the following 3 LEWG issues: <a href="2831">2831</a>, <a href="2854">2854</a>, <a href="2857">2857</a>.</li>
<li>Added the following Resolved issue: <a href="2830">2830</a>.</li>
<li>Added the following NAD Editorial issue: <a href="2828">2828</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from New): <a href="2789">2789</a>, <a href="2795">2795</a>, <a href="2804">2804</a>, <a href="2812">2812</a>, <a href="2824">2824</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="2768">2768</a>, <a href="2769">2769</a>.</li>
<li>Changed the following 2 issues to Review (from New): <a href="2790">2790</a>, <a href="2796">2796</a>.</li>
<li>Changed the following 2 issues to LEWG (from New): <a href="2814">2814</a>, <a href="2825">2825</a>.</li>
<li>Changed the following 2 issues to WP (from New): <a href="2792">2792</a>, <a href="2793">2793</a>.</li>
<li>Changed the following 3 issues to Resolved (from New): <a href="2805">2805</a>, <a href="2809">2809</a>, <a href="2810">2810</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2754">2754</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2822">2822</a>.</li>
</ul></li>
</ul>
</li>
<li>R101: 
2016-11-28 2016 post-Issaquah mailing
<ul>
<li><b>Summary:</b><ul>
<li>216 open issues, down by 44.</li>
<li>2063 closed issues, up by 85.</li>
<li>68 reassigned issues, up by 0.</li>
<li>2347 issues total, up by 41.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 Ready issues: <a href="2785">2785</a>, <a href="2786">2786</a>, <a href="2787">2787</a>.</li>
<li>Added the following Tentatively Ready issue: <a href="2794">2794</a>.</li>
<li>Added the following 34 New issues: <a href="2788">2788</a>, <a href="2789">2789</a>, <a href="2790">2790</a>, <a href="2792">2792</a>, <a href="2793">2793</a>, <a href="2795">2795</a>, <a href="2796">2796</a>, <a href="2797">2797</a>, <a href="2799">2799</a>, <a href="2800">2800</a>, <a href="2801">2801</a>, <a href="2802">2802</a>, <a href="2803">2803</a>, <a href="2804">2804</a>, <a href="2805">2805</a>, <a href="2806">2806</a>, <a href="2807">2807</a>, <a href="2808">2808</a>, <a href="2809">2809</a>, <a href="2810">2810</a>, <a href="2811">2811</a>, <a href="2812">2812</a>, <a href="2813">2813</a>, <a href="2814">2814</a>, <a href="2815">2815</a>, <a href="2816">2816</a>, <a href="2818">2818</a>, <a href="2819">2819</a>, <a href="2820">2820</a>, <a href="2821">2821</a>, <a href="2822">2822</a>, <a href="2823">2823</a>, <a href="2824">2824</a>, <a href="2825">2825</a>.</li>
<li>Added the following Open issue: <a href="2798">2798</a>.</li>
<li>Added the following 2 Resolved issues: <a href="2791">2791</a>, <a href="2817">2817</a>.</li>
<li>Changed the following 3 issues to Ready (from New): <a href="2781">2781</a>, <a href="2782">2782</a>, <a href="2784">2784</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2260">2260</a>.</li>
<li>Changed the following issue to Review (from New): <a href="2697">2697</a>.</li>
<li>Changed the following 3 issues to Open (from Tentatively Ready): <a href="2569">2569</a>, <a href="2754">2754</a>, <a href="2768">2768</a>.</li>
<li>Changed the following 2 issues to Open (from New): <a href="2597">2597</a>, <a href="2730">2730</a>.</li>
<li>Changed the following issue to LEWG (from New): <a href="2780">2780</a>.</li>
<li>Changed the following issue to Pending NAD Editorial (from Open): <a href="2178">2178</a>.</li>
<li>Changed the following 66 issues to WP (from Tentatively Ready): <a href="2062">2062</a>, <a href="2166">2166</a>, <a href="2221">2221</a>, <a href="2223">2223</a>, <a href="2261">2261</a>, <a href="2394">2394</a>, <a href="2460">2460</a>, <a href="2468">2468</a>, <a href="2475">2475</a>, <a href="2503">2503</a>, <a href="2510">2510</a>, <a href="2514">2514</a>, <a href="2519">2519</a>, <a href="2531">2531</a>, <a href="2534">2534</a>, <a href="2536">2536</a>, <a href="2540">2540</a>, <a href="2544">2544</a>, <a href="2556">2556</a>, <a href="2562">2562</a>, <a href="2567">2567</a>, <a href="2570">2570</a>, <a href="2578">2578</a>, <a href="2584">2584</a>, <a href="2589">2589</a>, <a href="2591">2591</a>, <a href="2598">2598</a>, <a href="2664">2664</a>, <a href="2672">2672</a>, <a href="2678">2678</a>, <a href="2679">2679</a>, <a href="2680">2680</a>, <a href="2681">2681</a>, <a href="2686">2686</a>, <a href="2694">2694</a>, <a href="2696">2696</a>, <a href="2699">2699</a>, <a href="2712">2712</a>, <a href="2722">2722</a>, <a href="2729">2729</a>, <a href="2732">2732</a>, <a href="2733">2733</a>, <a href="2735">2735</a>, <a href="2736">2736</a>, <a href="2738">2738</a>, <a href="2739">2739</a>, <a href="2740">2740</a>, <a href="2742">2742</a>, <a href="2744">2744</a>, <a href="2745">2745</a>, <a href="2747">2747</a>, <a href="2748">2748</a>, <a href="2749">2749</a>, <a href="2750">2750</a>, <a href="2752">2752</a>, <a href="2755">2755</a>, <a href="2756">2756</a>, <a href="2758">2758</a>, <a href="2759">2759</a>, <a href="2760">2760</a>, <a href="2765">2765</a>, <a href="2767">2767</a>, <a href="2771">2771</a>, <a href="2773">2773</a>, <a href="2777">2777</a>, <a href="2778">2778</a>.</li>
<li>Changed the following 4 issues to WP (from New): <a href="2518">2518</a>, <a href="2521">2521</a>, <a href="2525">2525</a>, <a href="2527">2527</a>.</li>
<li>Changed the following 3 issues to WP (from Open): <a href="2568">2568</a>, <a href="2588">2588</a>, <a href="2770">2770</a>.</li>
<li>Changed the following 2 issues to Resolved (from Tentatively Ready): <a href="2543">2543</a>, <a href="2753">2753</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="2763">2763</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2465">2465</a>.</li>
<li>Changed the following issue to Resolved (from SG1): <a href="2445">2445</a>.</li>
<li>Changed the following issue to NAD Editorial (from New): <a href="2201">2201</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2668">2668</a>.</li>
<li>Changed the following 2 issues to NAD (from Open): <a href="1173">1173</a>, <a href="2199">2199</a>.</li>
</ul></li>
</ul>
</li>
<li>R100: 
2016-10-17 2016 pre-Issaquah mailing
<ul>
<li><b>Summary:</b><ul>
<li>260 open issues, up by 31.</li>
<li>1978 closed issues, up by 5.</li>
<li>68 reassigned issues, up by 5.</li>
<li>2306 issues total, up by 41.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 21 Tentatively Ready issues: <a href="2744">2744</a>, <a href="2745">2745</a>, <a href="2747">2747</a>, <a href="2748">2748</a>, <a href="2749">2749</a>, <a href="2750">2750</a>, <a href="2752">2752</a>, <a href="2753">2753</a>, <a href="2754">2754</a>, <a href="2755">2755</a>, <a href="2756">2756</a>, <a href="2758">2758</a>, <a href="2759">2759</a>, <a href="2760">2760</a>, <a href="2765">2765</a>, <a href="2767">2767</a>, <a href="2768">2768</a>, <a href="2771">2771</a>, <a href="2773">2773</a>, <a href="2777">2777</a>, <a href="2778">2778</a>.</li>
<li>Added the following 13 New issues: <a href="2746">2746</a>, <a href="2751">2751</a>, <a href="2763">2763</a>, <a href="2764">2764</a>, <a href="2766">2766</a>, <a href="2772">2772</a>, <a href="2774">2774</a>, <a href="2776">2776</a>, <a href="2780">2780</a>, <a href="2781">2781</a>, <a href="2782">2782</a>, <a href="2783">2783</a>, <a href="2784">2784</a>.</li>
<li>Added the following 2 Open issues: <a href="2769">2769</a>, <a href="2770">2770</a>.</li>
<li>Added the following 2 LEWG issues: <a href="2762">2762</a>, <a href="2779">2779</a>.</li>
<li>Added the following Tentatively Resolved issue: <a href="2757">2757</a>.</li>
<li>Added the following NAD issue: <a href="2761">2761</a>.</li>
<li>Added the following Dup issue: <a href="2775">2775</a>.</li>
<li>Changed the following 45 issues to Tentatively Ready (from New): <a href="2166">2166</a>, <a href="2221">2221</a>, <a href="2261">2261</a>, <a href="2394">2394</a>, <a href="2460">2460</a>, <a href="2475">2475</a>, <a href="2503">2503</a>, <a href="2514">2514</a>, <a href="2519">2519</a>, <a href="2531">2531</a>, <a href="2534">2534</a>, <a href="2536">2536</a>, <a href="2540">2540</a>, <a href="2544">2544</a>, <a href="2556">2556</a>, <a href="2562">2562</a>, <a href="2567">2567</a>, <a href="2569">2569</a>, <a href="2570">2570</a>, <a href="2578">2578</a>, <a href="2584">2584</a>, <a href="2589">2589</a>, <a href="2591">2591</a>, <a href="2598">2598</a>, <a href="2664">2664</a>, <a href="2672">2672</a>, <a href="2678">2678</a>, <a href="2679">2679</a>, <a href="2680">2680</a>, <a href="2681">2681</a>, <a href="2686">2686</a>, <a href="2694">2694</a>, <a href="2696">2696</a>, <a href="2699">2699</a>, <a href="2712">2712</a>, <a href="2722">2722</a>, <a href="2729">2729</a>, <a href="2732">2732</a>, <a href="2733">2733</a>, <a href="2735">2735</a>, <a href="2736">2736</a>, <a href="2738">2738</a>, <a href="2739">2739</a>, <a href="2740">2740</a>, <a href="2742">2742</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from Open): <a href="2062">2062</a>, <a href="2223">2223</a>, <a href="2468">2468</a>, <a href="2510">2510</a>, <a href="2543">2543</a>.</li>
<li>Changed the following issue to Review (from New): <a href="2676">2676</a>.</li>
<li>Changed the following issue to Review (from Open): <a href="2245">2245</a>.</li>
<li>Changed the following 13 issues to Open (from New): <a href="2158">2158</a>, <a href="2358">2358</a>, <a href="2381">2381</a>, <a href="2465">2465</a>, <a href="2512">2512</a>, <a href="2530">2530</a>, <a href="2532">2532</a>, <a href="2568">2568</a>, <a href="2587">2587</a>, <a href="2588">2588</a>, <a href="2665">2665</a>, <a href="2682">2682</a>, <a href="2708">2708</a>.</li>
<li>Changed the following 3 issues to LEWG (from New): <a href="2242">2242</a>, <a href="2471">2471</a>, <a href="2593">2593</a>.</li>
<li>Changed the following 3 issues to LEWG (from Open): <a href="2095">2095</a>, <a href="2152">2152</a>, <a href="2153">2153</a>.</li>
<li>Changed the following 6 issues to Tentatively Resolved (from New): <a href="2343">2343</a>, <a href="2501">2501</a>, <a href="2502">2502</a>, <a href="2548">2548</a>, <a href="2663">2663</a>, <a href="2677">2677</a>.</li>
<li>Changed the following 4 issues to Tentatively Resolved (from Open): <a href="2294">2294</a>, <a href="2370">2370</a>, <a href="2424">2424</a>, <a href="2505">2505</a>.</li>
<li>Changed the following 3 issues to Tentatively Resolved (from LEWG): <a href="839">839</a>, <a href="1041">1041</a>, <a href="2443">2443</a>.</li>
<li>Changed the following issue to NAD Editorial (from New): <a href="2701">2701</a>.</li>
<li>Changed the following 2 issues to NAD (from New): <a href="2161">2161</a>, <a href="2535">2535</a>.</li>
</ul></li>
</ul>
</li>
<li>R99: 
2016-07-11 2016 post-Oulu mailing
<ul>
<li><b>Summary:</b><ul>
<li>292 open issues, down by 26.</li>
<li>1973 closed issues, up by 51.</li>
<li>2265 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 16 New issues: <a href="2722">2722</a>, <a href="2729">2729</a>, <a href="2730">2730</a>, <a href="2731">2731</a>, <a href="2732">2732</a>, <a href="2733">2733</a>, <a href="2734">2734</a>, <a href="2735">2735</a>, <a href="2736">2736</a>, <a href="2737">2737</a>, <a href="2738">2738</a>, <a href="2739">2739</a>, <a href="2740">2740</a>, <a href="2741">2741</a>, <a href="2742">2742</a>, <a href="2743">2743</a>.</li>
<li>Added the following 9 WP issues: <a href="2719">2719</a>, <a href="2720">2720</a>, <a href="2721">2721</a>, <a href="2723">2723</a>, <a href="2724">2724</a>, <a href="2725">2725</a>, <a href="2726">2726</a>, <a href="2727">2727</a>, <a href="2728">2728</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="2717">2717</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Open): <a href="2241">2241</a>.</li>
<li>Changed the following 21 issues to WP (from Ready): <a href="2181">2181</a>, <a href="2309">2309</a>, <a href="2310">2310</a>, <a href="2328">2328</a>, <a href="2393">2393</a>, <a href="2426">2426</a>, <a href="2436">2436</a>, <a href="2441">2441</a>, <a href="2451">2451</a>, <a href="2516">2516</a>, <a href="2542">2542</a>, <a href="2549">2549</a>, <a href="2550">2550</a>, <a href="2551">2551</a>, <a href="2555">2555</a>, <a href="2573">2573</a>, <a href="2667">2667</a>, <a href="2669">2669</a>, <a href="2670">2670</a>, <a href="2671">2671</a>, <a href="2673">2673</a>.</li>
<li>Changed the following 12 issues to WP (from Tentatively Ready): <a href="2509">2509</a>, <a href="2596">2596</a>, <a href="2674">2674</a>, <a href="2683">2683</a>, <a href="2684">2684</a>, <a href="2685">2685</a>, <a href="2688">2688</a>, <a href="2689">2689</a>, <a href="2698">2698</a>, <a href="2706">2706</a>, <a href="2707">2707</a>, <a href="2710">2710</a>.</li>
<li>Changed the following 6 issues to WP (from New): <a href="2687">2687</a>, <a href="2704">2704</a>, <a href="2709">2709</a>, <a href="2711">2711</a>, <a href="2716">2716</a>, <a href="2718">2718</a>.</li>
<li>Changed the following 2 issues to WP (from Open): <a href="2312">2312</a>, <a href="2422">2422</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2700">2700</a>.</li>
</ul></li>
</ul>
</li>
<li>R98: 
2016-05-29 2016 pre-Oulu mailing
<ul>
<li><b>Summary:</b><ul>
<li>318 open issues, up by 50.</li>
<li>1922 closed issues, up by 0.</li>
<li>2240 issues total, up by 50.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 10 Tentatively Ready issues: <a href="2596">2596</a>, <a href="2683">2683</a>, <a href="2684">2684</a>, <a href="2685">2685</a>, <a href="2688">2688</a>, <a href="2689">2689</a>, <a href="2698">2698</a>, <a href="2706">2706</a>, <a href="2707">2707</a>, <a href="2710">2710</a>.</li>
<li>Added the following Tentatively NAD issue: <a href="2692">2692</a>.</li>
<li>Added the following 37 New issues: <a href="2595">2595</a>, <a href="2597">2597</a>, <a href="2598">2598</a>, <a href="2599">2599</a>, <a href="2675">2675</a>, <a href="2676">2676</a>, <a href="2677">2677</a>, <a href="2678">2678</a>, <a href="2679">2679</a>, <a href="2680">2680</a>, <a href="2681">2681</a>, <a href="2682">2682</a>, <a href="2686">2686</a>, <a href="2687">2687</a>, <a href="2691">2691</a>, <a href="2693">2693</a>, <a href="2694">2694</a>, <a href="2695">2695</a>, <a href="2696">2696</a>, <a href="2697">2697</a>, <a href="2699">2699</a>, <a href="2700">2700</a>, <a href="2701">2701</a>, <a href="2702">2702</a>, <a href="2703">2703</a>, <a href="2704">2704</a>, <a href="2705">2705</a>, <a href="2708">2708</a>, <a href="2709">2709</a>, <a href="2711">2711</a>, <a href="2712">2712</a>, <a href="2713">2713</a>, <a href="2714">2714</a>, <a href="2715">2715</a>, <a href="2716">2716</a>, <a href="2717">2717</a>, <a href="2718">2718</a>.</li>
<li>Added the following 2 LEWG issues: <a href="2600">2600</a>, <a href="2690">2690</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="2674">2674</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2509">2509</a>.</li>
<li>Changed the following 2 issues to Tentatively Resolved (from New): <a href="2208">2208</a>, <a href="2529">2529</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Open): <a href="2179">2179</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from LEWG): <a href="2391">2391</a>.</li>
</ul></li>
</ul>
</li>
<li>R97: 
2016-03-22 2016 post-Jacksonville mailing
<ul>
<li><b>Summary:</b><ul>
<li>268 open issues, down by 37.</li>
<li>1922 closed issues, up by 40.</li>
<li>2190 issues total, up by 3.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 New issues: <a href="2592">2592</a>, <a href="2593">2593</a>, <a href="2594">2594</a>.</li>
<li>Changed the following 7 issues to Ready (from Review): <a href="2181">2181</a>, <a href="2309">2309</a>, <a href="2310">2310</a>, <a href="2328">2328</a>, <a href="2393">2393</a>, <a href="2441">2441</a>, <a href="2516">2516</a>.</li>
<li>Changed the following 11 issues to Ready (from New): <a href="2542">2542</a>, <a href="2549">2549</a>, <a href="2550">2550</a>, <a href="2551">2551</a>, <a href="2555">2555</a>, <a href="2573">2573</a>, <a href="2667">2667</a>, <a href="2669">2669</a>, <a href="2670">2670</a>, <a href="2671">2671</a>, <a href="2673">2673</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="2426">2426</a>.</li>
<li>Changed the following 2 issues to Ready (from LEWG): <a href="2436">2436</a>, <a href="2451">2451</a>.</li>
<li>Changed the following issue to Open (from Review): <a href="2424">2424</a>.</li>
<li>Changed the following issue to Open (from New): <a href="2368">2368</a>.</li>
<li>Changed the following 3 issues to WP (from Ready): <a href="2276">2276</a>, <a href="2523">2523</a>, <a href="2537">2537</a>.</li>
<li>Changed the following 25 issues to WP (from Tentatively Ready): <a href="2192">2192</a>, <a href="2450">2450</a>, <a href="2520">2520</a>, <a href="2522">2522</a>, <a href="2539">2539</a>, <a href="2545">2545</a>, <a href="2557">2557</a>, <a href="2558">2558</a>, <a href="2559">2559</a>, <a href="2560">2560</a>, <a href="2565">2565</a>, <a href="2566">2566</a>, <a href="2571">2571</a>, <a href="2572">2572</a>, <a href="2574">2574</a>, <a href="2575">2575</a>, <a href="2576">2576</a>, <a href="2577">2577</a>, <a href="2579">2579</a>, <a href="2581">2581</a>, <a href="2582">2582</a>, <a href="2583">2583</a>, <a href="2585">2585</a>, <a href="2586">2586</a>, <a href="2590">2590</a>.</li>
<li>Changed the following issue to WP (from Review): <a href="2296">2296</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="2554">2554</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2456">2456</a>.</li>
<li>Changed the following issue to NAD Editorial (from New): <a href="2666">2666</a>.</li>
<li>Changed the following issue to NAD (from Review): <a href="2402">2402</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2553">2553</a>.</li>
<li>Changed the following issue to NAD (from LEWG): <a href="2372">2372</a>.</li>
<li>Changed the following 2 issues to NAD Arrays (from Ready): <a href="2253">2253</a>, <a href="2255">2255</a>.</li>
<li>Changed the following 3 issues to NAD Arrays (from Open): <a href="2254">2254</a>, <a href="2264">2264</a>, <a href="2277">2277</a>.</li>
</ul></li>
</ul>
</li>
<li>R96: 
2016-02-12 2016 pre-Jacksonville mailing (includes the FS TS bugs for the first time)
<ul>
<li><b>Summary:</b><ul>
<li>305 open issues, up by 48.</li>
<li>1882 closed issues, up by 63.</li>
<li>2187 issues total, up by 111.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 19 Tentatively Ready issues: <a href="2557">2557</a>, <a href="2558">2558</a>, <a href="2559">2559</a>, <a href="2560">2560</a>, <a href="2565">2565</a>, <a href="2566">2566</a>, <a href="2571">2571</a>, <a href="2572">2572</a>, <a href="2574">2574</a>, <a href="2575">2575</a>, <a href="2576">2576</a>, <a href="2577">2577</a>, <a href="2579">2579</a>, <a href="2581">2581</a>, <a href="2582">2582</a>, <a href="2583">2583</a>, <a href="2585">2585</a>, <a href="2586">2586</a>, <a href="2590">2590</a>.</li>
<li>Added the following 30 New issues: <a href="2554">2554</a>, <a href="2555">2555</a>, <a href="2556">2556</a>, <a href="2561">2561</a>, <a href="2562">2562</a>, <a href="2563">2563</a>, <a href="2564">2564</a>, <a href="2567">2567</a>, <a href="2568">2568</a>, <a href="2569">2569</a>, <a href="2570">2570</a>, <a href="2573">2573</a>, <a href="2578">2578</a>, <a href="2584">2584</a>, <a href="2587">2587</a>, <a href="2588">2588</a>, <a href="2589">2589</a>, <a href="2591">2591</a>, <a href="2663">2663</a>, <a href="2664">2664</a>, <a href="2665">2665</a>, <a href="2666">2666</a>, <a href="2667">2667</a>, <a href="2668">2668</a>, <a href="2669">2669</a>, <a href="2670">2670</a>, <a href="2671">2671</a>, <a href="2672">2672</a>, <a href="2673">2673</a>, <a href="2674">2674</a>.</li>
<li>Added the following 3 NAD Future issues: <a href="2611">2611</a>, <a href="2612">2612</a>, <a href="2654">2654</a>.</li>
<li>Added the following 41 WP issues: <a href="2601">2601</a>, <a href="2602">2602</a>, <a href="2603">2603</a>, <a href="2605">2605</a>, <a href="2606">2606</a>, <a href="2607">2607</a>, <a href="2608">2608</a>, <a href="2609">2609</a>, <a href="2614">2614</a>, <a href="2615">2615</a>, <a href="2616">2616</a>, <a href="2618">2618</a>, <a href="2619">2619</a>, <a href="2621">2621</a>, <a href="2622">2622</a>, <a href="2624">2624</a>, <a href="2625">2625</a>, <a href="2627">2627</a>, <a href="2629">2629</a>, <a href="2632">2632</a>, <a href="2633">2633</a>, <a href="2634">2634</a>, <a href="2635">2635</a>, <a href="2636">2636</a>, <a href="2637">2637</a>, <a href="2640">2640</a>, <a href="2641">2641</a>, <a href="2644">2644</a>, <a href="2645">2645</a>, <a href="2647">2647</a>, <a href="2648">2648</a>, <a href="2649">2649</a>, <a href="2650">2650</a>, <a href="2652">2652</a>, <a href="2653">2653</a>, <a href="2655">2655</a>, <a href="2656">2656</a>, <a href="2657">2657</a>, <a href="2658">2658</a>, <a href="2660">2660</a>, <a href="2662">2662</a>.</li>
<li>Added the following 2 NAD Editorial issues: <a href="2639">2639</a>, <a href="2659">2659</a>.</li>
<li>Added the following 14 NAD issues: <a href="2580">2580</a>, <a href="2604">2604</a>, <a href="2610">2610</a>, <a href="2613">2613</a>, <a href="2617">2617</a>, <a href="2623">2623</a>, <a href="2626">2626</a>, <a href="2628">2628</a>, <a href="2630">2630</a>, <a href="2631">2631</a>, <a href="2638">2638</a>, <a href="2642">2642</a>, <a href="2646">2646</a>, <a href="2661">2661</a>.</li>
<li>Added the following 2 Dup issues: <a href="2643">2643</a>, <a href="2651">2651</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="2545">2545</a>.</li>
<li>Changed the following 2 issues to Review (from Open): <a href="2310">2310</a>, <a href="2516">2516</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2552">2552</a>.</li>
</ul></li>
</ul>
</li>
<li>R95: 
2015-11-15 2015 post-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>257 open issues, down by 37.</li>
<li>1819 closed issues, up by 47.</li>
<li>2076 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 10 New issues: <a href="2544">2544</a>, <a href="2545">2545</a>, <a href="2546">2546</a>, <a href="2547">2547</a>, <a href="2548">2548</a>, <a href="2549">2549</a>, <a href="2550">2550</a>, <a href="2551">2551</a>, <a href="2552">2552</a>, <a href="2553">2553</a>.</li>
<li>Changed the following 2 issues to Ready (from New): <a href="2523">2523</a>, <a href="2537">2537</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="2276">2276</a>.</li>
<li>Changed the following 3 issues to Tentatively Ready (from New): <a href="2520">2520</a>, <a href="2522">2522</a>, <a href="2539">2539</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="2192">2192</a>, <a href="2450">2450</a>.</li>
<li>Changed the following issue to Review (from Ready): <a href="2181">2181</a>.</li>
<li>Changed the following 4 issues to Review (from Open): <a href="2309">2309</a>, <a href="2393">2393</a>, <a href="2402">2402</a>, <a href="2441">2441</a>.</li>
<li>Changed the following issue to Open (from Tentatively Ready): <a href="2510">2510</a>.</li>
<li>Changed the following 10 issues to Open (from New): <a href="2117">2117</a>, <a href="2164">2164</a>, <a href="2290">2290</a>, <a href="2468">2468</a>, <a href="2499">2499</a>, <a href="2505">2505</a>, <a href="2509">2509</a>, <a href="2516">2516</a>, <a href="2524">2524</a>, <a href="2543">2543</a>.</li>
<li>Changed the following issue to SG1 (from New): <a href="2533">2533</a>.</li>
<li>Changed the following 35 issues to WP (from Ready): <a href="1169">1169</a>, <a href="2072">2072</a>, <a href="2101">2101</a>, <a href="2111">2111</a>, <a href="2119">2119</a>, <a href="2127">2127</a>, <a href="2133">2133</a>, <a href="2156">2156</a>, <a href="2218">2218</a>, <a href="2219">2219</a>, <a href="2244">2244</a>, <a href="2250">2250</a>, <a href="2259">2259</a>, <a href="2336">2336</a>, <a href="2353">2353</a>, <a href="2367">2367</a>, <a href="2380">2380</a>, <a href="2384">2384</a>, <a href="2385">2385</a>, <a href="2435">2435</a>, <a href="2447">2447</a>, <a href="2462">2462</a>, <a href="2466">2466</a>, <a href="2469">2469</a>, <a href="2473">2473</a>, <a href="2476">2476</a>, <a href="2477">2477</a>, <a href="2483">2483</a>, <a href="2484">2484</a>, <a href="2485">2485</a>, <a href="2486">2486</a>, <a href="2487">2487</a>, <a href="2489">2489</a>, <a href="2492">2492</a>, <a href="2494">2494</a>.</li>
<li>Changed the following 8 issues to WP (from Tentatively Ready): <a href="2224">2224</a>, <a href="2234">2234</a>, <a href="2273">2273</a>, <a href="2495">2495</a>, <a href="2500">2500</a>, <a href="2515">2515</a>, <a href="2517">2517</a>, <a href="2526">2526</a>.</li>
<li>Changed the following issue to Resolved (from Core): <a href="2165">2165</a>.</li>
<li>Changed the following 2 issues to NAD (from New): <a href="2474">2474</a>, <a href="2538">2538</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="2379">2379</a>.</li>
<li>Changed the following issue to NAD (from Resolved): <a href="2319">2319</a>.</li>
</ul></li>
</ul>
</li>
<li>R94: 
2015-09-25 2015 pre-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>294 open issues, up by 38.</li>
<li>1772 closed issues, up by 2.</li>
<li>2066 issues total, up by 40.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 4 Tentatively Ready issues: <a href="2510">2510</a>, <a href="2515">2515</a>, <a href="2517">2517</a>, <a href="2526">2526</a>.</li>
<li>Added the following 36 New issues: <a href="2504">2504</a>, <a href="2505">2505</a>, <a href="2506">2506</a>, <a href="2507">2507</a>, <a href="2508">2508</a>, <a href="2509">2509</a>, <a href="2511">2511</a>, <a href="2512">2512</a>, <a href="2513">2513</a>, <a href="2514">2514</a>, <a href="2516">2516</a>, <a href="2518">2518</a>, <a href="2519">2519</a>, <a href="2520">2520</a>, <a href="2521">2521</a>, <a href="2522">2522</a>, <a href="2523">2523</a>, <a href="2524">2524</a>, <a href="2525">2525</a>, <a href="2527">2527</a>, <a href="2528">2528</a>, <a href="2529">2529</a>, <a href="2530">2530</a>, <a href="2531">2531</a>, <a href="2532">2532</a>, <a href="2533">2533</a>, <a href="2534">2534</a>, <a href="2535">2535</a>, <a href="2536">2536</a>, <a href="2537">2537</a>, <a href="2538">2538</a>, <a href="2539">2539</a>, <a href="2540">2540</a>, <a href="2541">2541</a>, <a href="2542">2542</a>, <a href="2543">2543</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="2495">2495</a>, <a href="2500">2500</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="2234">2234</a>, <a href="2273">2273</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2051">2051</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2326">2326</a>.</li>
</ul></li>
</ul>
</li>
<li>R93: 
2014-05-22 2015 post-Lenexa mailing
<ul>
<li><b>Summary:</b><ul>
<li>256 open issues, down by 36.</li>
<li>1770 closed issues, up by 48.</li>
<li>2026 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 2 Ready issues: <a href="2492">2492</a>, <a href="2494">2494</a>.</li>
<li>Added the following 10 New issues: <a href="2493">2493</a>, <a href="2495">2495</a>, <a href="2496">2496</a>, <a href="2497">2497</a>, <a href="2498">2498</a>, <a href="2499">2499</a>, <a href="2500">2500</a>, <a href="2501">2501</a>, <a href="2502">2502</a>, <a href="2503">2503</a>.</li>
<li>Changed the following 2 issues to Ready (from Review): <a href="2111">2111</a>, <a href="2380">2380</a>.</li>
<li>Changed the following 20 issues to Ready (from New): <a href="2244">2244</a>, <a href="2250">2250</a>, <a href="2259">2259</a>, <a href="2336">2336</a>, <a href="2353">2353</a>, <a href="2367">2367</a>, <a href="2384">2384</a>, <a href="2385">2385</a>, <a href="2435">2435</a>, <a href="2462">2462</a>, <a href="2466">2466</a>, <a href="2473">2473</a>, <a href="2476">2476</a>, <a href="2477">2477</a>, <a href="2483">2483</a>, <a href="2484">2484</a>, <a href="2485">2485</a>, <a href="2486">2486</a>, <a href="2487">2487</a>, <a href="2489">2489</a>.</li>
<li>Changed the following 12 issues to Ready (from Open): <a href="1169">1169</a>, <a href="2072">2072</a>, <a href="2101">2101</a>, <a href="2119">2119</a>, <a href="2127">2127</a>, <a href="2133">2133</a>, <a href="2156">2156</a>, <a href="2181">2181</a>, <a href="2218">2218</a>, <a href="2219">2219</a>, <a href="2447">2447</a>, <a href="2469">2469</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2224">2224</a>.</li>
<li>Changed the following issue to Review (from New): <a href="2296">2296</a>.</li>
<li>Changed the following issue to Review (from Open): <a href="2328">2328</a>.</li>
<li>Changed the following 11 issues to Open (from New): <a href="2262">2262</a>, <a href="2289">2289</a>, <a href="2338">2338</a>, <a href="2348">2348</a>, <a href="2349">2349</a>, <a href="2370">2370</a>, <a href="2398">2398</a>, <a href="2402">2402</a>, <a href="2422">2422</a>, <a href="2450">2450</a>, <a href="2456">2456</a>.</li>
<li>Changed the following 8 issues to Open (from SG1): <a href="2245">2245</a>, <a href="2265">2265</a>, <a href="2276">2276</a>, <a href="2309">2309</a>, <a href="2363">2363</a>, <a href="2379">2379</a>, <a href="2426">2426</a>, <a href="2441">2441</a>.</li>
<li>Changed the following issue to LEWG (from New): <a href="2372">2372</a>.</li>
<li>Changed the following issue to EWG (from New): <a href="2432">2432</a>.</li>
<li>Changed the following issue to Deferred (from Open): <a href="2202">2202</a>.</li>
<li>Changed the following 14 issues to WP (from Ready): <a href="2160">2160</a>, <a href="2168">2168</a>, <a href="2364">2364</a>, <a href="2403">2403</a>, <a href="2406">2406</a>, <a href="2411">2411</a>, <a href="2425">2425</a>, <a href="2427">2427</a>, <a href="2428">2428</a>, <a href="2433">2433</a>, <a href="2434">2434</a>, <a href="2438">2438</a>, <a href="2439">2439</a>, <a href="2440">2440</a>.</li>
<li>Changed the following 18 issues to WP (from Tentatively Ready): <a href="2059">2059</a>, <a href="2076">2076</a>, <a href="2239">2239</a>, <a href="2369">2369</a>, <a href="2378">2378</a>, <a href="2410">2410</a>, <a href="2415">2415</a>, <a href="2418">2418</a>, <a href="2437">2437</a>, <a href="2448">2448</a>, <a href="2454">2454</a>, <a href="2455">2455</a>, <a href="2458">2458</a>, <a href="2459">2459</a>, <a href="2463">2463</a>, <a href="2467">2467</a>, <a href="2470">2470</a>, <a href="2482">2482</a>.</li>
<li>Changed the following 3 issues to WP (from New): <a href="2420">2420</a>, <a href="2464">2464</a>, <a href="2488">2488</a>.</li>
<li>Changed the following issue to WP (from Open): <a href="2063">2063</a>.</li>
<li>Changed the following 2 issues to WP (from SG1): <a href="2407">2407</a>, <a href="2442">2442</a>.</li>
<li>Changed the following issue to Resolved (from Review): <a href="2228">2228</a>.</li>
<li>Changed the following 3 issues to Resolved (from Open): <a href="1526">1526</a>, <a href="2274">2274</a>, <a href="2397">2397</a>.</li>
<li>Changed the following 5 issues to NAD (from New): <a href="2079">2079</a>, <a href="2251">2251</a>, <a href="2351">2351</a>, <a href="2373">2373</a>, <a href="2386">2386</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="2388">2388</a>.</li>
</ul></li>
</ul>
</li>
<li>R92: 
2015-04-09 pre-Lenexa mailing
<ul>
<li><b>Summary:</b><ul>
<li>292 open issues, up by 33.</li>
<li>1722 closed issues, up by 0.</li>
<li>2014 issues total, up by 33.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 5 Tentatively Ready issues: <a href="2459">2459</a>, <a href="2463">2463</a>, <a href="2467">2467</a>, <a href="2470">2470</a>, <a href="2482">2482</a>.</li>
<li>Added the following 27 New issues: <a href="2460">2460</a>, <a href="2461">2461</a>, <a href="2462">2462</a>, <a href="2464">2464</a>, <a href="2465">2465</a>, <a href="2466">2466</a>, <a href="2468">2468</a>, <a href="2471">2471</a>, <a href="2472">2472</a>, <a href="2473">2473</a>, <a href="2474">2474</a>, <a href="2475">2475</a>, <a href="2476">2476</a>, <a href="2477">2477</a>, <a href="2478">2478</a>, <a href="2479">2479</a>, <a href="2480">2480</a>, <a href="2481">2481</a>, <a href="2483">2483</a>, <a href="2484">2484</a>, <a href="2485">2485</a>, <a href="2486">2486</a>, <a href="2487">2487</a>, <a href="2488">2488</a>, <a href="2489">2489</a>, <a href="2490">2490</a>, <a href="2491">2491</a>.</li>
<li>Added the following Open issue: <a href="2469">2469</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Review): <a href="2378">2378</a>.</li>
<li>Changed the following 11 issues to Tentatively Ready (from New): <a href="2076">2076</a>, <a href="2239">2239</a>, <a href="2369">2369</a>, <a href="2410">2410</a>, <a href="2415">2415</a>, <a href="2418">2418</a>, <a href="2437">2437</a>, <a href="2448">2448</a>, <a href="2454">2454</a>, <a href="2455">2455</a>, <a href="2458">2458</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2059">2059</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="2337">2337</a>.</li>
<li>Changed the following issue to Tentatively NAD (from Open): <a href="760">760</a>.</li>
<li>Changed the following 5 issues to Open (from New): <a href="2312">2312</a>, <a href="2388">2388</a>, <a href="2393">2393</a>, <a href="2444">2444</a>, <a href="2447">2447</a>.</li>
<li>Changed the following 4 issues to LEWG (from New): <a href="2391">2391</a>, <a href="2417">2417</a>, <a href="2436">2436</a>, <a href="2451">2451</a>.</li>
<li>Changed the following issue to EWG (from Open): <a href="2089">2089</a>.</li>
<li>Changed the following issue to Core (from New): <a href="2452">2452</a>.</li>
<li>Changed the following 13 issues to SG1 (from New): <a href="2236">2236</a>, <a href="2245">2245</a>, <a href="2265">2265</a>, <a href="2276">2276</a>, <a href="2309">2309</a>, <a href="2334">2334</a>, <a href="2363">2363</a>, <a href="2379">2379</a>, <a href="2407">2407</a>, <a href="2412">2412</a>, <a href="2426">2426</a>, <a href="2442">2442</a>, <a href="2445">2445</a>.</li>
<li>Changed the following issue to SG1 (from Open): <a href="2441">2441</a>.</li>
</ul></li>
</ul>
</li>
<li>R91: 
2014-11-23 post-Urbana mailing
<ul>
<li><b>Summary:</b><ul>
<li>259 open issues, up by 32.</li>
<li>1722 closed issues, down by 20.</li>
<li>1981 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 12 New issues: <a href="2447">2447</a>, <a href="2448">2448</a>, <a href="2449">2449</a>, <a href="2450">2450</a>, <a href="2451">2451</a>, <a href="2452">2452</a>, <a href="2453">2453</a>, <a href="2454">2454</a>, <a href="2455">2455</a>, <a href="2456">2456</a>, <a href="2457">2457</a>, <a href="2458">2458</a>.</li>
<li>Changed the following 2 issues to Ready (from Review): <a href="2160">2160</a>, <a href="2364">2364</a>.</li>
<li>Changed the following 11 issues to Ready (from New): <a href="2403">2403</a>, <a href="2406">2406</a>, <a href="2411">2411</a>, <a href="2425">2425</a>, <a href="2427">2427</a>, <a href="2428">2428</a>, <a href="2433">2433</a>, <a href="2434">2434</a>, <a href="2438">2438</a>, <a href="2439">2439</a>, <a href="2440">2440</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="2168">2168</a>.</li>
<li>Changed the following issue to Review (from New): <a href="2424">2424</a>.</li>
<li>Changed the following 5 issues to Open (from New): <a href="2307">2307</a>, <a href="2310">2310</a>, <a href="2383">2383</a>, <a href="2414">2414</a>, <a href="2441">2441</a>.</li>
<li>Changed the following 2 issues to Open (from NAD Future): <a href="760">760</a>, <a href="1173">1173</a>.</li>
<li>Changed the following 4 issues to LEWG (from New): <a href="2419">2419</a>, <a href="2430">2430</a>, <a href="2443">2443</a>, <a href="2446">2446</a>.</li>
<li>Changed the following 48 issues to LEWG (from NAD Future): <a href="255">255</a>, <a href="423">423</a>, <a href="484">484</a>, <a href="523">523</a>, <a href="532">532</a>, <a href="708">708</a>, <a href="839">839</a>, <a href="851">851</a>, <a href="877">877</a>, <a href="933">933</a>, <a href="935">935</a>, <a href="936">936</a>, <a href="961">961</a>, <a href="1025">1025</a>, <a href="1031">1031</a>, <a href="1041">1041</a>, <a href="1052">1052</a>, <a href="1053">1053</a>, <a href="1112">1112</a>, <a href="1120">1120</a>, <a href="1121">1121</a>, <a href="1150">1150</a>, <a href="1154">1154</a>, <a href="1184">1184</a>, <a href="1188">1188</a>, <a href="1201">1201</a>, <a href="1203">1203</a>, <a href="1217">1217</a>, <a href="1235">1235</a>, <a href="1238">1238</a>, <a href="1242">1242</a>, <a href="1282">1282</a>, <a href="1289">1289</a>, <a href="1317">1317</a>, <a href="1320">1320</a>, <a href="1396">1396</a>, <a href="1406">1406</a>, <a href="1422">1422</a>, <a href="1459">1459</a>, <a href="1484">1484</a>, <a href="1488">1488</a>, <a href="1493">1493</a>, <a href="1499">1499</a>, <a href="1521">1521</a>, <a href="2040">2040</a>, <a href="2055">2055</a>, <a href="2226">2226</a>, <a href="2232">2232</a>.</li>
<li>Changed the following 2 issues to Pending NAD (from Tentatively NAD): <a href="2302">2302</a>, <a href="2382">2382</a>.</li>
<li>Changed the following 11 issues to WP (from Ready): <a href="2016">2016</a>, <a href="2170">2170</a>, <a href="2340">2340</a>, <a href="2354">2354</a>, <a href="2377">2377</a>, <a href="2396">2396</a>, <a href="2399">2399</a>, <a href="2400">2400</a>, <a href="2401">2401</a>, <a href="2404">2404</a>, <a href="2408">2408</a>.</li>
<li>Changed the following 12 issues to WP (from Tentatively Ready): <a href="2106">2106</a>, <a href="2129">2129</a>, <a href="2212">2212</a>, <a href="2217">2217</a>, <a href="2230">2230</a>, <a href="2233">2233</a>, <a href="2266">2266</a>, <a href="2325">2325</a>, <a href="2361">2361</a>, <a href="2365">2365</a>, <a href="2376">2376</a>, <a href="2387">2387</a>.</li>
<li>Changed the following issue to Resolved (from Ready): <a href="2319">2319</a>.</li>
<li>Changed the following issue to Resolved (from Review): <a href="2118">2118</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="2416">2416</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2108">2108</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2429">2429</a>.</li>
</ul></li>
</ul>
</li>
<li>R90: 
2014-10-13 pre-Urbana mailing
<ul>
<li><b>Summary:</b><ul>
<li>227 open issues, up by 31.</li>
<li>1742 closed issues, up by 0.</li>
<li>1969 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 31 New issues: <a href="2416">2416</a>, <a href="2417">2417</a>, <a href="2418">2418</a>, <a href="2419">2419</a>, <a href="2420">2420</a>, <a href="2421">2421</a>, <a href="2422">2422</a>, <a href="2423">2423</a>, <a href="2424">2424</a>, <a href="2425">2425</a>, <a href="2426">2426</a>, <a href="2427">2427</a>, <a href="2428">2428</a>, <a href="2429">2429</a>, <a href="2430">2430</a>, <a href="2431">2431</a>, <a href="2432">2432</a>, <a href="2433">2433</a>, <a href="2434">2434</a>, <a href="2435">2435</a>, <a href="2436">2436</a>, <a href="2437">2437</a>, <a href="2438">2438</a>, <a href="2439">2439</a>, <a href="2440">2440</a>, <a href="2441">2441</a>, <a href="2442">2442</a>, <a href="2443">2443</a>, <a href="2444">2444</a>, <a href="2445">2445</a>, <a href="2446">2446</a>.</li>
<li>No issues changed.</li>
</ul></li>
</ul>
</li>
<li>R89: 
2014-07-08 post-Rapperswil mailing
<ul>
<li><b>Summary:</b><ul>
<li>196 open issues, up by 14.</li>
<li>1742 closed issues, up by 12.</li>
<li>1938 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 6 Ready issues: <a href="2396">2396</a>, <a href="2399">2399</a>, <a href="2400">2400</a>, <a href="2401">2401</a>, <a href="2404">2404</a>, <a href="2408">2408</a>.</li>
<li>Added the following 15 New issues: <a href="2391">2391</a>, <a href="2392">2392</a>, <a href="2393">2393</a>, <a href="2394">2394</a>, <a href="2398">2398</a>, <a href="2402">2402</a>, <a href="2403">2403</a>, <a href="2406">2406</a>, <a href="2407">2407</a>, <a href="2410">2410</a>, <a href="2411">2411</a>, <a href="2412">2412</a>, <a href="2413">2413</a>, <a href="2414">2414</a>, <a href="2415">2415</a>.</li>
<li>Added the following Open issue: <a href="2397">2397</a>.</li>
<li>Added the following 3 WP issues: <a href="2390">2390</a>, <a href="2395">2395</a>, <a href="2409">2409</a>.</li>
<li>Added the following NAD issue: <a href="2405">2405</a>.</li>
<li>Changed the following issue to Ready (from New): <a href="2377">2377</a>.</li>
<li>Changed the following 2 issues to Ready (from Deferred): <a href="2253">2253</a>, <a href="2255">2255</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="2325">2325</a>, <a href="2387">2387</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="2382">2382</a>.</li>
<li>Changed the following 3 issues to Review (from New): <a href="2364">2364</a>, <a href="2378">2378</a>, <a href="2380">2380</a>.</li>
<li>Changed the following 2 issues to Review (from Open): <a href="2118">2118</a>, <a href="2160">2160</a>.</li>
<li>Changed the following 3 issues to Open (from New): <a href="2168">2168</a>, <a href="2238">2238</a>, <a href="2273">2273</a>.</li>
<li>Changed the following 3 issues to Open (from Deferred): <a href="2254">2254</a>, <a href="2264">2264</a>, <a href="2277">2277</a>.</li>
<li>Changed the following 3 issues to WP (from New): <a href="2371">2371</a>, <a href="2374">2374</a>, <a href="2389">2389</a>.</li>
<li>Changed the following 4 issues to Resolved (from Deferred): <a href="2282">2282</a>, <a href="2283">2283</a>, <a href="2287">2287</a>, <a href="2333">2333</a>.</li>
<li>Changed the following issue to NAD (from Deferred): <a href="2305">2305</a>.</li>
</ul></li>
</ul>
</li>
<li>R88: 
2014-05-24 pre-Rapperswil mailing
<ul>
<li><b>Summary:</b><ul>
<li>182 open issues, up by 29.</li>
<li>1730 closed issues, up by 0.</li>
<li>1912 issues total, up by 29.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 Tentatively Ready issues: <a href="2361">2361</a>, <a href="2365">2365</a>, <a href="2376">2376</a>.</li>
<li>Added the following 26 New issues: <a href="2362">2362</a>, <a href="2363">2363</a>, <a href="2364">2364</a>, <a href="2366">2366</a>, <a href="2367">2367</a>, <a href="2368">2368</a>, <a href="2369">2369</a>, <a href="2370">2370</a>, <a href="2371">2371</a>, <a href="2372">2372</a>, <a href="2373">2373</a>, <a href="2374">2374</a>, <a href="2375">2375</a>, <a href="2377">2377</a>, <a href="2378">2378</a>, <a href="2379">2379</a>, <a href="2380">2380</a>, <a href="2381">2381</a>, <a href="2382">2382</a>, <a href="2383">2383</a>, <a href="2384">2384</a>, <a href="2385">2385</a>, <a href="2386">2386</a>, <a href="2387">2387</a>, <a href="2388">2388</a>, <a href="2389">2389</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from Open): <a href="2106">2106</a>, <a href="2129">2129</a>, <a href="2212">2212</a>, <a href="2230">2230</a>, <a href="2233">2233</a>.</li>
</ul></li>
</ul>
</li>
</ul>

<h2><a name="Status"></a>Issue Status</h2>

  <p>Issues reported to the LWG transition through a variety of statuses,
  indicating their progress towards a resolution.  Typically, most issues
  will flow through the following stages.
  </p>

  <p><b><a name="New">New</a></b> - The issue has not yet been
  reviewed by the LWG. Any <b>Proposed Resolution</b> is purely a
  suggestion from the issue submitter, and should not be construed as
  the view of LWG.</p>

  <p><b><a name="Open">Open</a></b> - The LWG has discussed the issue
  but is not yet ready to move the issue forward. There are several
  possible reasons for open status:</p>
     <ul>
        <li>Consensus may have not yet have been reached as to how to deal
            with the issue.</li>
        <li>Informal consensus may have been reached, but the LWG awaits
            exact <b>Proposed Resolution</b> wording for review.</li>
        <li>The LWG wishes to consult additional technical experts before
            proceeding.</li>
        <li>The issue may require further study.</li>
     </ul>

  <p>A <b>Proposed Resolution</b> for an open issue is still not be
  construed as the view of LWG. Comments on the current state of
  discussions are often given at the end of open issues in an italic
  font. Such comments are for information only and should not be given
  undue importance.</p>

  <p><b><a name="Review">Review</a></b> - Exact wording of a
  <b>Proposed Resolution</b> is now available for review on an issue
  for which the LWG previously reached informal consensus.</p>

  <p><b><a name="Ready">Ready</a></b> - The LWG has reached consensus
  that the issue is a defect in the Standard, the <b>Proposed
  Resolution</b> is correct, and the issue is ready to forward to the
  full committee for further action as a Defect Report (DR).</p>

  <p>Typically, an issue must have a proposed resolution in the currently
  published issues list, whose wording does not change during LWG review, to
  move to the Ready status.</p>

  <p><b><a name="Voting">Voting</a></b> - This status should not be seen
  in a published issues list, but is a marker for use during meetings to
  indicate an issues was Ready in the pre-meeting mailing, the <b>Proposed
  Resolution</b> is correct, and the issue will be offered to the working
  group at the end of the current meeting to apply to the current working
  paper (WP) or to close in some other appropriate manner.  This easily
  distinguishes such issues from those moving to Ready status during the
  meeting itself, that should not be forwarded until the next meeting.  If
  the issue does not move forward, it should fall back to one of the other
  open states before the next list is published.</p>

  <p><b><a name="Immediate">Immediate</a></b> - This status should not be
  seen in a published issues list, but is a marker for use during meetings
  to indicate an issues was not Ready in the pre-meeting mailing, but the
  <b>Proposed Resolution</b> is correct, and the issue will be offered to
  the working group at the end of the current meeting to apply to the
  current working paper (WP) or to close in some other appropriate manner.
  This status is used only rarely, typically for fixes that are both small
  and obvious, and usually within a meeting of the expected publication of
  a revised standard.  If the issue does not move forward, it should fall
  back to one of the other open states before the next list is published.</p>

  <p>In addition, there are a few ways to categorise and issue that remains
  open to a resolution within the library, but is not actively being worked
  on.
  </p>

  <p><b><a name="Deferred">Deferred</a></b> - The LWG has discussed the issue,
  is not yet ready to move the issue forward, but neither does it deem the
  issue significant enough to delay publishing a standard or Technical Report.
  A typical deferred issue would be seeking to clarify wording that might be
  technically correct, but easily mis-read.</p>

  <p>A <b>Proposed Resolution</b> for a deferred issue is still not be
  construed as the view of LWG. Comments on the current state of
  discussions are often given at the end of open issues in an italic
  font. Such comments are for information only and should not be given
  undue importance.</p>

  <p><b><a name="Core">Core</a></b> - The LWG has discussed the issue, and feels
  that some key part of resolving the issue is better handled by a cleanup of
  the language in the Core part of the standard.  The issue is passed to the Core
  Working Group, which should ideally open a corresponding issue that can be
  linked from the library issue.  Such issues will be revisitted after Core have
  made (or declined to make) any changes.
  </p>

  <p><b><a name="EWG">EWG</a></b> - The LWG has discussed the issue, and wonder
  that some key part of resolving the issue is better handled by some (hopefully
  small) extension to the language.  The issue is passed to the Evolution Working
  Group, which should ideally open a corresponding issue that can be linked from
  the library issue.  Such issues will be revisitted after Evoltion have made (or
  declined to make) any recommendations.  Positive recommendations from EWG will
  often mean the issue transition to <i>Core</i> status while we wait for some
  proposed new feature to land in the working paper.
  </p>

  <p><b><a name="LEWG">LEWG</a></b> - The LWG has discussed the issue, and deemd
  the issue is either an extension, however small, or changes the library design
  in some fundamental way, and so has delegated the initial work to the Library
  Evolution Working Group.
  </p>

  <p>Ultimately, all issues should reach closure with one of the following statuses.
  </p>

  <p><b><a name="DR">DR</a></b> - (Defect Report) - The full WG21/PL22.16
  committee has voted to forward the issue to the Project Editor to be
  processed as a Potential Defect Report. The Project Editor reviews
  the issue, and then forwards it to the WG21 Convenor, who returns it
  to the full committee for final disposition. This issues list
  accords the status of DR to all these Defect Reports regardless of
  where they are in that process.</p>

  <p><b><a name="WP">WP</a></b> - (Working Paper) - The proposed resolution has not been
  accepted as a Technical Corrigendum, but the full WG21/PL22.16 committee has voted to
  apply the Defect Report's Proposed Resolution to the working paper.</p>

  <p><b><a name="C++14">C++14</a></b> - (C++ Standard, as revised for 2014) - The full
  WG21/PL22.16 committee has voted to accept the Defect Report's Proposed Resolution into
  the published 2014 revision to the C++ standard, ISO/IEC IS 14882:2014(E).</p>

   <p><b><a name="C++11">C++11</a></b> - (C++ Standard, as revised for 2011) - The full
  WG21/PL22.16 committee has voted to accept the Defect Report's Proposed Resolution into
  the published 2011 revision to the C++ standard, ISO/IEC IS 14882:2011(E).</p>

   <p><b><a name="CD1">CD1</a></b> - (Committee Draft 2008) - The full
  WG21/PL22.16 committee has voted to accept the Defect Report's Proposed
  Resolution into the Fall 2008 Committee Draft.</p>

  <p><b><a name="TC1">TC1</a></b> - (Technical Corrigenda 1) - The full
  WG21/PL22.16 committee has voted to accept the Defect Report's Proposed
  Resolution as a Technical Corrigenda.  Action on this issue is thus
  complete and no further action is possible under ISO rules.</p>

  <p><b><a name="TRDec">TRDec</a></b> - (Decimal TR defect) - The LWG has voted to
  accept the Defect Report's Proposed Resolution into the Decimal TR.  Action on this
  issue is thus complete and no further action is expected.</p>

  <p><b><a name="Resolved">Resolved</a></b> - The LWG has reached consensus
  that the issue is a defect in the Standard, but the resolution adopted to
  resolve the issue came via some other mechanism than this issue in the
  list - typically by applying a formal paper, occasionally as a side effect
  of consolidating several interacting issue resolutions into a single issue.</p>

  <p><b><a name="Dup">Dup</a></b> - The LWG has reached consensus that
  the issue is a duplicate of another issue, and will not be further
  dealt with. A <b>Rationale</b> identifies the duplicated issue's
  issue number.</p>

  <p><b><a name="NAD">NAD</a></b> - The LWG has reached consensus that
  the issue is not a defect in the Standard.</p>

  <p><b><a name="NAD Editorial">NAD Editorial</a></b> - The LWG has reached consensus that
  the issue can either be handled editorially, or is handled by a paper (usually
  linked to in the rationale).</p>

  <p><b>Tentatively</b> - This is a <i>status qualifier</i>.  The issue has
  been reviewed online, or at an unofficial meeting, but not in an official meeting, and
  some support has been formed for the qualified status.  Tentatively qualified issues may
  be moved to the unqualified status and forwarded to full committee (if Ready) within the
  same meeting.  Unlike Ready issues, Tentatively Ready issues will be reviewed in
  subcommittee prior to forwarding to full committee.  When a status is qualified with
  Tentatively, the issue is still considered active.</p>

  <p><b>Pending</b> - This is a <i>status qualifier</i>.  When prepended to a status this
  indicates the issue has been processed by the committee, and a decision has been made to
  move the issue to the associated unqualified status.  However for logistical reasons the
  indicated outcome of the issue has not yet appeared in the latest working paper.</p>

  <p>The following statuses have been retired, but may show up on older issues lists.</p>

  <p><b><a name="NAD Future">NAD Future</a></b> - In addition to the regular status, the
  LWG believes that this issue should be revisited at the next revision of the standard.
  That is now an ongoing task managed by the Library Evolution Working Group, and most
  issues in this status were reopended with the status <a href="#NAD Editorial">LEWG</a>.
  </p>

  <p><b><a name="NAD Concepts">NAD Concepts</a></b> - This status reflects an evolution
  of the language during the development of C++11, where a new feature entered the
  language, called <i>concepts</i>, that fundamentally changed the way templates would
  be specified and written.  While this language feature was removed towards the end of
  the C++11 project, there is a clear intent to revisit this part of the language design.
  During that development, a number of issues were opened against the updated library
  related to use of that feature, or requesting fixes that would require explicit use of
  the concepts feature.  All such issues have been closed with this status, and may be
  revisitted should this or a similar language feature return for a future standard.</p>

  <p><b><a name="NAD Arrays">NAD Arrays</a></b> - This status reflects an evolution
  of the language during the development of C++14/17, where work on a Technical 
  Specification, called the <i>Arrays TS</i> was begun. In early 2016, this work was
  abandoned, and the work item was officially withdrawn.  During development of the TS,
  a number of issues were opened the features in the TS. All such issues have been closed
  with this status, and may be revisitted should this or a similar language feature
  return for a future standard.</p>

  <p>Issues are always given the status of <a href="lwg-active.html#New">New</a> when
  they first appear on the issues list. They may progress to
  <a href="lwg-active.html#Open">Open</a> or <a href="lwg-active.html#Review">Review</a>
  while the LWG is actively working on them. When the LWG has reached consensus on
  the disposition of an issue, the status will then change to
  <a href="lwg-active.html#Dup">Dup</a>, <a href="lwg-active.html#NAD">NAD</a>, or
  <a href="lwg-active.html#Ready">Ready</a> as appropriate.  Once the full PL22.16 committee
  votes to forward Ready issues to the Project Editor, they are given the status of Defect
  Report (<a href="lwg-active.html#DR">DR</a>). These in turn may become the basis for
  Technical Corrigenda (<a href="lwg-active.html#TC1">TC1</a>), an updated standard
  (<a href="lwg-defects.html#C++11">C++11</a>, <a href="lwg-defects.html#C++14">C++14</a>),
  or are closed without action other than a Record of Response
  (<a href="lwg-active.html#Resolved">Resolved</a>) where the desired effect has already
  been achieved by some other process.  The intent of this LWG process is that only issues
  which are truly defects in the Standard move to the formal ISO DR status.
  </p>


<h2>Active Issues</h2>
<hr>
<h3><a name="255" href="255">255.</a> Why do <tt>basic_streambuf&lt;&gt;::pbump()</tt> and <tt>gbump()</tt> take an int?</h3>
<p><b>Section:</b> 30.6.3 <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-12 <b>Last modified:</b> 2016-08-09 17:08:10 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#streambuf">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#streambuf">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_streambuf members gbump() and pbump() are specified to take an
int argument. This requirement prevents the functions from effectively
manipulating buffers larger than std::numeric_limits&lt;int&gt;::max()
characters. It also makes the common use case for these functions
somewhat difficult as many compilers will issue a warning when an
argument of type larger than int (such as ptrdiff_t on LLP64
architectures) is passed to either of the function. Since it's often the
result of the subtraction of two pointers that is passed to the
functions, a cast is necessary to silence such warnings. Finally, the
usage of a native type in the functions signatures is inconsistent with
other member functions (such as sgetn() and sputn()) that manipulate the
underlying character buffer. Those functions take a streamsize argument.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is part of a bigger problem. If anyone cares enough, they should
write a paper solving the bigger problem of offset types in iostreams.
</p>
<p>
This is related to the paper about large file sizes. Beman has already
agreed to drop the section of that paper that deals with this.
</p>
<p>
int is big enough for reasonable buffers.
</p>
<p>
Move to NAD Future.
</p>
<p>
This is related to LWG <a href="423">423</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the signatures of these functions in the synopsis of template
class basic_streambuf (27.5.2) and in their descriptions (27.5.2.3.1, p4
and 27.5.2.3.2, p4) to take a streamsize argument.
</p>

<p>
Although this change has the potential of changing the ABI of the
library, the change will affect only platforms where int is different
than the definition of streamsize. However, since both functions are
typically inline (they are on all known implementations), even on such
platforms the change will not affect any user code unless it explicitly
relies on the existing type of the functions (e.g., by taking their
address). Such a possibility is IMO quite remote.
</p>

<p>
Alternate Suggestion from Howard Hinnant, c++std-lib-7780:
</p>

<p>
This is something of a nit, but I'm wondering if streamoff wouldn't be a 
better choice than streamsize.  The argument to pbump and gbump MUST be 
signed.  But the standard has this to say about streamsize 
(27.4.1/2/Footnote):
</p>

<blockquote><p>
     [Footnote: streamsize is used in most places where ISO C would use
     size_t.  Most of the uses of streamsize could use size_t, except for
     the strstreambuf constructors, which require negative values. It
     should probably be the signed type corresponding to size_t (which is
     what Posix.2 calls ssize_t). &mdash; end footnote]
</p></blockquote>

<p>
This seems a little weak for the argument to pbump and gbump.  Should we 
ever really get rid of strstream, this footnote might go with it, along 
with the reason to make streamsize signed.
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this change is too big for now.  We may wish to
reconsider this for a future revision of the standard.  One
possibility is overloading pbump, rather than changing the
signature.</p>
<p><i>[
[2006-05-04: Reopened at the request of Chris (Krzysztof &#379;elechowski)]
]</i></p>





<hr>
<h3><a name="423" href="423">423.</a> effects of negative streamsize in iostreams</h3>
<p><b>Section:</b> 30 <a href="https://timsong-cpp.github.io/cppwp/input.output">[input.output]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#input.output">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/input.output">[input.output]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
A third party test suite tries to exercise istream::ignore(N) with
a negative value of N and expects that the implementation will treat
N as if it were 0. Our implementation asserts that (N >= 0) holds and
aborts the test.
</p>

<p>
I can't find anything in section 27 that prohibits such values but I don't
see what the effects of such calls should be, either (this applies to
a number of unformatted input functions as well as some member functions
of the basic_streambuf template).
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is related to LWG <a href="255">255</a>.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
I propose that we add to each function in clause 27 that takes an argument,
say N, of type streamsize a Requires clause saying that "N >= 0." The intent
is to allow negative streamsize values in calls to precision() and width()
but disallow it in calls to streambuf::sgetn(), istream::ignore(), or
ostream::write().
</p>

<p><i>[Kona: The LWG agreed that this is probably what we want.  However, we
  need a review to find all places where functions in clause 27 take
  arguments of type streamsize that shouldn't be allowed to go
  negative.  Martin will do that review.]</i></p>






<hr>
<h3><a name="484" href="484">484.</a> Convertible to <tt>T</tt></h3>
<p><b>Section:</b> 27.2.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-09-16 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#input.iterators">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>From comp.std.c++:</p>

<p>
I note that given an input iterator a for type <tt>T</tt>, 
then <tt>*a</tt> only has to be "convertable to <tt>T</tt>", 
not actually of type <tt>T</tt>.
</p>

<p>Firstly, I can't seem to find an exact definition of "convertable to <tt>T</tt>". 
While I assume it is the obvious definition (an implicit conversion), I 
can't find an exact definition. Is there one?</p>

<p>Slightly more worryingly, there doesn't seem to be any restriction on 
the this type, other than it is "convertable to <tt>T</tt>". Consider two input 
iterators <tt>a</tt> and <tt>b</tt>. I would personally assume that most people would 
expect <tt>*a==*b</tt> would perform <tt>T(*a)==T(*b)</tt>, however it doesn't seem that 
the standard requires that, and that whatever type <tt>*a</tt> is (call it <tt>U</tt>) 
could have == defined on it with totally different symantics and still 
be a valid inputer iterator.</p>

<p>Is this a correct reading? When using input iterators should I write 
<tt>T(*a)</tt> all over the place to be sure that the object I'm using is the 
class I expect?</p>

<p>This is especially a nuisance for operations that are defined to be
  "convertible to <tt>bool</tt>".  (This is probably allowed so that
  implementations could return say an <tt>int</tt> and avoid an unnessary
  conversion. However all implementations I have seen simply return a
  <tt>bool</tt> anyway.  Typical implemtations of STL algorithms just write
  things like <tt>while(a!=b &amp;&amp; *a!=0)</tt>.  But strictly
  speaking, there are lots of types that are convertible to <tt>T</tt> but
  that also overload the appropriate operators so this doesn't behave
  as expected.</p>

<p>If we want to make code like this legal (which most people seem to
  expect), then we'll need to tighten up what we mean by "convertible
  to <tt>T</tt>".</p>

<p><i>[Lillehammer: The first part is NAD, since "convertible" is
 well-defined in core. The second part is basically about pathological
 overloads. It's a minor problem but a real one. So leave open for
 now, hope we solve it as part of iterator redesign.]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair. No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD Future. We agree there's an issue, but there is no
proposed solution at this time and this will be solved by concepts in
the future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</p></blockquote>





<hr>
<h3><a name="523" href="523">523.</a> regex case-insensitive character ranges are unimplementable as specified</h3>
<p><b>Section:</b> 31 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2005-07-01 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#re">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A problem with TR1 regex is currently being discussed on the Boost 
developers list. It involves the handling of case-insensitive matching 
of character ranges such as [Z-a]. The proper behavior (according to the 
ECMAScript standard) is unimplementable given the current specification 
of the TR1 regex_traits&lt;&gt; class template. John Maddock, the author of 
the TR1 regex proposal, agrees there is a problem. The full discussion 
can be found at http://lists.boost.org/boost/2005/06/28850.php (first 
message copied below). We don't have any recommendations as yet.
</p>
<p>
-- Begin original message --
</p>
<p>
The situation of interest is described in the ECMAScript specification
(ECMA-262), section 15.10.2.15:
</p>
<p>
"Even if the pattern ignores case, the case of the two ends of a range
is significant in determining which characters belong to the range.
Thus, for example, the pattern /[E-F]/i matches only the letters E, F,
e, and f, while the pattern /[E-f]/i matches all upper and lower-case
ASCII letters as well as the symbols [, \, ], ^, _, and `."
</p>
<p>
A more interesting case is what should happen when doing a
case-insentitive match on a range such as [Z-a]. It should match z, Z,
a, A and the symbols [, \, ], ^, _, and `. This is not what happens with
Boost.Regex (it throws an exception from the regex constructor).
</p>
<p>
The tough pill to swallow is that, given the specification in TR1, I
don't think there is any effective way to handle this situation.
According to the spec, case-insensitivity is handled with
regex_traits&lt;&gt;::translate_nocase(CharT) -- two characters are equivalent
if they compare equal after both are sent through the translate_nocase
function. But I don't see any way of using this translation function to
make character ranges case-insensitive. Consider the difficulty of
detecting whether "z" is in the range [Z-a]. Applying the transformation
to "z" has no effect (it is essentially std::tolower). And we're not
allowed to apply the transformation to the ends of the range, because as
ECMA-262 says, "the case of the two ends of a range is significant."
</p>
<p>
So AFAICT, TR1 regex is just broken, as is Boost.Regex. One possible fix
is to redefine translate_nocase to return a string_type containing all
the characters that should compare equal to the specified character. But
this function is hard to implement for Unicode, and it doesn't play nice
with the existing ctype facet. What a mess!
</p>
<p>
-- End original message --
</p>

<p><i>[
John Maddock adds:
]</i></p>


<p>
One small correction, I have since found that ICU's regex package does 
implement this correctly, using a similar mechanism to the current 
TR1.Regex.
</p>
<p>
Given an expression [c1-c2] that is compiled as case insensitive it:
</p>
<p>
Enumerates every character in the range c1 to c2 and converts it to it's 
case folded equivalent.  That case folded character is then used a key to a 
table of equivalence classes, and each member of the class is added to the 
list of possible matches supported by the character-class.  This second step 
isn't possible with our current traits class design, but isn't necessary if 
the input text is also converted to a case-folded equivalent on the fly.
</p>
<p>
ICU applies similar brute force mechanisms to character classes such as 
[[:lower:]] and [[:word:]], however these are at least cached, so the impact 
is less noticeable in this case.
</p>
<p>
Quick and dirty performance comparisons show that expressions such as 
"[X-\\x{fff0}]+" are indeed very slow to compile with ICU (about 200 times 
slower than a "normal" expression).  For an application that uses a lot of 
regexes this could have a noticeable performance impact.  ICU also has an 
advantage in that it knows the range of valid characters codes: code points 
outside that range are assumed not to require enumeration, as they can not 
be part of any equivalence class.  I presume that if we want the TR1.Regex 
to work with arbitrarily large character sets enumeration really does become 
impractical.
</p>
<p>
Finally note that Unicode has:
</p>
<p>
Three cases (upper, lower and title).
One to many, and many to one case transformations.
Character that have context sensitive case translations - for example an 
uppercase sigma has two different lowercase forms  - the form chosen depends 
on context(is it end of a word or not), a caseless match for an upper case 
sigma should match either of the lower case forms, which is why case folding 
is often approximated by tolower(toupper(c)).
</p>
<p>
Probably we need some way to enumerate character equivalence classes, 
including digraphs (either as a result or an input), and some way to tell 
whether the next character pair is a valid digraph in the current locale.
</p>
<p>
Hoping this doesn't make this even more complex that it was already,
</p>

<p><i>[
Portland:  Alisdair: Detect as invalid, throw an exception.
Pete: Possible general problem with case insensitive ranges.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We agree that this is a problem, but we do not know the answer.
</p>
<p>
We are going to declare this NAD until existing practice leads us in some direction.
</p>
<p>
No objection to NAD Future.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="532" href="532">532.</a> Tuple comparison</h3>
<p><b>Section:</b> 23.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, 99 [tr.tuple.rel] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2005-11-29 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="348">348</a></p>
<p><b>Discussion:</b></p>
<p>
Where possible, <tt>tuple</tt> comparison operators &lt;,&lt;=,=&gt;, and &gt; ought to be
defined in terms of <tt>std::less</tt> rather than <tt>operator&lt;</tt>, in order to
support comparison of tuples of pointers.  
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
If we solve this for <tt>tuple</tt> we would have to solve it for <tt>pair</tt>
algorithms, etc.  It is too late to do that at this time.  Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
change 6.1.3.5/5 from:
</p>

<blockquote><p>
  Returns: The result of a lexicographical comparison between t and
  u. The result is defined as: (bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) ||
  (!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for
  some tuple r is a tuple containing all but the first element of
  r. For any two zero-length tuples e and f, e &lt; f returns false.
</p></blockquote>

<p>
to:
</p>

<blockquote>
<p>
  Returns: The result of a lexicographical comparison between t and
  u. For any two zero-length tuples e and f, e &lt; f returns false.
  Otherwise, the result is defined as: cmp( get&lt;0&gt;(t), get&lt;0&gt;(u)) ||
  (!cmp(get&lt;0&gt;(u), get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for some
  tuple r is a tuple containing all but the first element of r, and
  cmp(x,y) is an unspecified function template defined as follows.
</p>
<p>
  Where T is the type of x and U is the type of y:
</p>

<p>
     if T and U are pointer types and T is convertible to U, returns
     less&lt;U&gt;()(x,y)
</p>

<p>
     otherwise, if T and U are pointer types, returns less&lt;T&gt;()(x,y)
</p>

<p>
     otherwise, returns (bool)(x &lt; y)
</p>
</blockquote>

<p><i>[
Berlin: This issue is much bigger than just tuple (pair, containers,
algorithms). Dietmar will survey and work up proposed wording.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Recommend NAD.  This will be fixed with the next revision of concepts.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</p></blockquote>





<hr>
<h3><a name="708" href="708">708.</a> Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 25 <a href="https://timsong-cpp.github.io/cppwp/localization">[localization]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-07-28 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#localization">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/localization">[localization]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>


<p><i>[
San Francisco: Bill and Nick still intend to provide wording, but this
is a part of the task to be addressed by the group that will look into
issue <a href="860">860</a>.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's our intention to stay in sync with WG14. If WG14 makes a decision
that requires a change in WG21 the issue will be reopened.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="760" href="760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="767">767</a> and to <a href="2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="2164">2164</a> addresses this issue and therefore considers <a href="760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="851" href="851">851.</a> simplified array construction</h3>
<p><b>Section:</b> 26.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is an issue that came up on the libstdc++ list, where a
discrepancy between "C" arrays and C++0x's <tt>std::array</tt> was pointed
out.
</p>

<p>
In "C," this array usage is possible:
</p>

<blockquote><pre>
int ar[] = {1, 4, 6};
</pre></blockquote>

<p>
But for C++, 
</p>

<blockquote><pre>
std::array&lt;int&gt; a = { 1, 4, 6 }; // error
</pre></blockquote>

<p>
Instead, the second parameter of the <tt>array</tt> template must be
explicit, like so:
</p>

<blockquote><pre>
std::array&lt;int, 3&gt; a = { 1, 4, 6 };
</pre></blockquote>

<p>
Doug Gregor proposes the following solution, that assumes
generalized initializer lists.
</p>

<blockquote><pre>
template&lt;typename T, typename... Args&gt;
inline array&lt;T, sizeof...(Args)&gt; 
make_array(Args&amp;&amp;... args) 
{ return { std::forward&lt;Args&gt;(args)... };  }
</pre></blockquote>

<p>
Then, the way to build an <tt>array</tt> from a list of unknown size is:
</p>

<blockquote><pre>
auto a = make_array&lt;T&gt;(1, 4, 6);
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Benjamin: Move to Ready?
</p>
<p>
Bjarne: I'm not convinced this is useful enough to add, so I'd like us
to have time to reflect on it.
</p>
<p>
Alisdair: the constraints are wrong, they should be
</p>
<blockquote><pre>
template&lt;ValueType T, ValueType... Args&gt;
requires Convertible&lt;Args, T&gt;...
array&lt;T, sizeof...(Args)&gt; make_array(Args&amp;&amp;... args);
</pre></blockquote>
<p>
Alidair: this would be useful if we had a constexpr version.
</p>
<p>
Bjarne: this is probably useful for arrays with a small number of
elements, but it's not clearly useful otherwise.
</p>
<p>
Consensus is to move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest a fix and a simplification of the current proposal: Recent
prototyping by
Howard showed, that a fix is required because narrowing conversion
11.6.4 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>/6 b.3
would severely limit the possible distribution of argument types, e.g.
the expression
<tt>make_array&lt;double&gt;(1, 2.0)</tt> is ill-formed, because the narrowing
happens <em>inside</em> the
function body where no constant expressions exist anymore. Furthermore
given e.g.
</p>
<blockquote><pre>
int f();
double g();
</pre></blockquote>
<p>
we probably want to support
</p>
<blockquote><pre>
make_array&lt;double&gt;(f(), g());
</pre></blockquote>

<p>
as well. To make this feasible, the currently suggested expansion
</p>

<blockquote><pre>
{ std::forward&lt;Args&gt;(args)... }
</pre></blockquote>

<p>
needs to be replaced by
</p>

<blockquote><pre>
{ static_cast&lt;T&gt;(std::forward&lt;Args&gt;(args))... }
</pre></blockquote>

<p>
which is safe, because we already ensure convertibility via the
element-wise <tt>Convertible&lt;Args, T&gt;</tt> requirement. Some other fixes are
necessary: The <tt>ValueType</tt> requirement for the function <em>parameters</em>
is invalid, because all lvalue arguments will deduce to an lvalue-reference,
thereby no longer satisfying this requirement.
</p>

<p>
The suggested simplification is to provide a default-computed effective
type for the result array based on common_type and decay, in
unconstrained form:
</p>

<blockquote><pre>
template&lt;typename... Args&gt;
array&lt;typename decay&lt;typename common_type&lt;Args...&gt;::type&gt;::type,
sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</pre></blockquote>

<p>
The approach used below is similar to that of <tt>make_pair</tt> and <tt>make_tuple</tt>
using a symbol <tt>C</tt> to represent the decayed common type [Note: Special
handling of <tt>reference_wrapper</tt> types is intentionally <em>not</em> provided, because
our target has so satisfy <tt>ValueType</tt>, thus under the revised proposal only
an all-<tt>reference_wrapper</tt>-arguments would be well-formed and an array of
<tt>reference_wrapper</tt> will be constructed]. I do currently not suggest to
add new concepts reflecting <tt>decay</tt> and <tt>common_type</tt>, but an implementor will
need something like this to succeed. Note that we use a similar fuzziness for
<tt>make_pair</tt> and <tt>make_tuple</tt> currently. This fuzziness is not related to
the currently
missing <tt>Constructible&lt;Vi, Ti&amp;&amp;&gt;</tt> requirement for those functions. The following
proposal fixes that miss for <tt>make_array</tt>. If the corresponding <tt>C</tt> type
deduction is
explicitly wanted for standardization, here the implementation
</p>

<blockquote><pre>
auto concept DC&lt;typename... T&gt; {
  typename type = typename decay&lt;typename common_type&lt;T...&gt;::type&gt;::type;
}
</pre></blockquote>

<p>
where <tt>C</tt> is identical to <tt>DC&lt;Args...&gt;::type</tt> in the proposed resolution below.
</p>
<p>
I intentionally added no further type relation between type and the concept
template parameters, but instead added this requirement below to make
the specification as transparent as possible. As written this concept is
satisfied, if the corresponding associated type exists.
</p>

<p><b>Suggested Resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 26.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>:
</p>
<blockquote><pre>
<ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 26.3.7.9 <a href="https://timsong-cpp.github.io/cppwp/array.tuple">[array.tuple]</a> Tuple interface to class template array
the following new section:
</p>
<blockquote>
<p>
23.4.1.7 Array creation functions [array.creation]
</p>

<pre>
<ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);</ins>
</pre>

<blockquote>
<p><ins>
Let <tt>C</tt> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.
</ins></p>
<p>
<ins><i>Returns:</i> an <tt>array&lt;C, sizeof...(Args)&gt;</tt> initialized with
<tt>{ static_cast&lt;C&gt;(std::forward&lt;Args&gt;(args))... }</tt>.
</ins></p>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
The proposed resolution uses concepts.
</p>
<p>
Daniel to rewrite the proposed resolution.
</p>
<p>
Leave Open.
</p>
</blockquote>

<p><i>[
2009-07-25 Daniel provides rewritten proposed resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Argument for NAD future: everything about this could be added on. This
does not require changes to the existing text.
</p></blockquote>

<p><i>[2015-11-29, Alisdair comments]</i></p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4391">N4391</a> was adopted for Fundamentals 2 at the Lenexa meeting.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 26.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>:
</p>

<blockquote><pre>
<ins>template&lt;class... Args&gt;
  array&lt;<i>CT</i>, sizeof...(Args)&gt;
  make_array(Args&amp;&amp;... args);</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 26.3.7.9 <a href="https://timsong-cpp.github.io/cppwp/array.tuple">[array.tuple]</a> "Tuple interface to class template array" the
following new section:
</p>

<blockquote>
<p>
<ins>XX.X.X.X Array creation functions [array.creation]</ins>
</p>

<pre><ins>
template&lt;class... Args&gt;
array&lt;<i>CT</i>, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args)
</ins></pre>

<blockquote>
<p>
<ins>Let <i>CT</i> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.</ins>
</p>
<p>
<ins><i>Returns:</i> An <tt>array&lt;<i>CT</i>, sizeof...(Args)&gt;</tt> initialized with <tt>{
static_cast&lt;<i>CT</i>&gt;(std::forward&lt;Args&gt;(args))... }</tt>.</ins>
</p>

<p><ins>
[<i>Example:</i>
</ins></p>
<blockquote><pre><ins>
int i = 0; int&amp; ri = i;
make_array(42u, i, 2.78, ri);
</ins></pre></blockquote>
<p><ins>
returns an array of type
</ins></p>
<blockquote><pre><ins>
array&lt;double, 4&gt;
</ins></pre></blockquote>

<p><ins>
&mdash;<i>end example</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>








<hr>
<h3><a name="877" href="877">877.</a> to <tt>throw()</tt> or to <i>Throw:</i> Nothing.</h3>
<p><b>Section:</b> 20 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-08-23 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Recent changes to
the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">working
draft</a> have introduced a gratuitous inconsistency with the C++ 2003
version of the specification with respect to exception guarantees
provided by standard functions. While the C++ 2003 standard
consistenly uses the empty exception specification, <tt>throw()</tt>,
to declare functions that are guaranteed not to throw exceptions, the
current working draft contains a number of "<i>Throws:</i> Nothing."
clause to specify essentially the same requirement. The difference
between the two approaches is that the former specifies the behavior
of programs that violate the requirement (<tt>std::unexpected()</tt>
is called) while the latter leaves the behavior undefined.

       </p>
       <p>

A survey of the working draft reveals that there are a total of 209
occurrences of <tt>throw()</tt> in the library portion of the spec,
the majority in clause 18, a couple (literally) in 19, a handful in
20, a bunch in 22, four in 24, one in 27, and about a dozen in D.9.

       </p>
       <p>

There are also 203 occurrences of "<i>Throws:</i> Nothing." scattered
throughout the spec.

       </p>
       <p>

While sometimes there are good reasons to use the "<i>Throws:</i>
Nothing."  approach rather than making use of <tt>throw()</tt>, these
reasons do not apply in most of the cases where this new clause has
been introduced and the empty exception specification would be a
better approach.

       </p>
       <p>

First, functions declared with the empty exception specification
permit compilers to generate better code for calls to such
functions. In some cases, the compiler might even be able to eliminate
whole chunks of user-written code when instantiating a generic
template on a type whose operations invoked from the template
specialization are known not to throw. The prototypical example are
the <tt>std::uninitialized_copy()</tt>
and <tt>std::uninitialized_fill()</tt> algorithms where the
entire <tt>catch(...)</tt> block can be optimized away.

       </p>
       <p>

For example, given the following definition of
the <tt>std::uninitialized_copy</tt> function template and a
user-defined type <tt>SomeType</tt>:

       </p>
       <blockquote>
           <pre>
template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
uninitialized_copy (InputIterator first, InputIterator last, ForwardIterator res)
{
   typedef iterator_traits&lt;ForwardIterator&gt;::value_type ValueType;

   ForwardIterator start = res;

   try {
       for (; first != last; ++first, ++res)
           ::new (&amp;*res) ValueType (*first);
   }
   catch (...) {
       for (; start != res; --start)
           (&amp;*start)->~ValueType ();
       throw;
   }
   return res;
}

struct SomeType {
   SomeType (const SomeType&amp;) <ins>throw ()</ins>;
}</pre>
       </blockquote>
       <p>

compilers are able to emit the following efficient specialization
of <tt>std::uninitialized_copy&lt;const SomeType*, SomeType*&gt;</tt>
(note that the <tt>catch</tt> block has been optimized away):

       </p>
       <blockquote>
           <pre>
template &lt;&gt; SomeType*
uninitialized_copy (const SomeType *first, const SomeType *last, SomeType *res)
{
   for (; first != last; ++first, ++res)
       ::new (res) SomeType (*first);

   return res;
}</pre>
       </blockquote>
       <p>

Another general example is default constructors which, when decorated
with <tt>throw()</tt>, allow the compiler to eliminate the
implicit <tt>try</tt> and <tt>catch</tt> blocks that it otherwise must
emit around each the invocation of the constructor
in <i>new-expressions</i>.

       </p>
       <p>

For example, given the following definitions of
class <tt>MayThrow</tt> and <tt>WontThrow</tt> and the two
statements below:

       </p>
       <blockquote>
           <pre>
struct MayThrow {
   MayThrow ();
};

struct WontThrow {
   WontThrow () <ins>throw ()</ins>;
};

MayThrow  *a = new MayThrow [N];
WontThrow *b = new WontThrow [N];</pre>

       </blockquote>
       <p>

the compiler generates the following code for the first statement:

       </p>
       <blockquote>
           <pre>
MayThrow *a;
{
   MayThrow *first = operator new[] (N * sizeof (*a));
   MayThrow *last  = first + N;
   MayThrow *next  = first;
   try {
       for ( ; next != last; ++next)
           new (next) MayThrow;
   }
   catch (...) {
       for ( ; first != first; --next)
           next->~MayThrow ();
       operator delete[] (first);
       throw;
   }
   a = first;
}</pre>
       </blockquote>
       <p>

but it is can generate much more compact code for the second statement:

       </p>
       <blockquote>
           <pre>
WontThrow *b    = operator new[] (N * sizeof (*b));
WontThrow *last = b + N;
for (WontThrow *next = b; next != last; ++next)
   new (next) WontThrow;
</pre>
       </blockquote>
       <p>

Second, in order for users to get the maximum benefit out of the new
<tt>std::has_nothrow_xxx</tt> traits when using standard library types
it will be important for implementations to decorate all non throwing
copy constructors and assignment operators with <tt>throw()</tt>. Note
that while an optimizer may be able to tell whether a function without
an explicit exception specification can throw or not based on its
definition, it can only do so when it can see the source code of the
definition. When it can't it must assume that the function may
throw. To prevent violating the One Definition Rule,
the <tt>std::has_nothrow_xxx</tt> trait must return the most
pessimistic guess across all translation units in the program, meaning
that <tt>std::has_nothrow_xxx&lt;T&gt;::value</tt> must evaluate to
<tt>false</tt> for any <tt>T</tt> whose <tt>xxx</tt>
(where <tt>xxx</tt> is default or copy ctor, or assignment operator)
is defined out-of-line.

       </p>
       <p>

<b>Counterarguments:</b>

       </p>
       <p>

During the discussion of this issue
on <a href="mailto:c++std-lib@accu.org">c++std-lib@accu.org</a>
(starting with post <tt>c++std-lib-21950</tt>) the following arguments
in favor of the "<i>Throws:</i> Nothing." style have been made.

       </p>
         <ol>
           <li>

Decorating functions that cannot throw with the empty exception
specification can cause the compiler to generate suboptimal code for
the implementation of the function when it calls other functions that
aren't known to the compiler not to throw (i.e., that aren't decorated
with <tt>throw()</tt> even if they don't actually throw). This is a
common situation when the called function is a C or POSIX function.

           </li>
           <li>

Alternate, proprietary mechanisms exist (such as
GCC <a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Function-Attributes.html#index-g_t_0040code_007bnothrow_007d-function-attribute-2160"><tt>__attribute__((nothrow))</tt></a>
or Visual
C++ <a href="http://msdn.microsoft.com/en-us/library/49147z04(VS.80).aspx"><tt>__declspec(nothrow)</tt></a>)
that let implementers mark up non-throwing functions, often without
the penalty mentioned in (1) above. The C++ standard shouldn't
preclude the use of these potentially more efficient mechanisms.

           </li>
           <li>

There are functions, especially function templates, that invoke
user-defined functions that may or may not be
declared <tt>throw()</tt>. Declaring such functions with the empty
exception specification will cause compilers to generate suboptimal
code when the user-defined function isn't also declared not to throw.

           </li>
        </ol>
       <p>

The answer to point (1) above is that implementers can (and some have)
declare functions with <tt>throw()</tt> to indicate to the compiler
that calls to the function can safely be assumed not to throw in order
to allow it to generate efficient code at the call site without also
having to define the functions the same way and causing the compiler
to generate suboptimal code for the function definition. That is, the
function is declared with <tt>throw()</tt> in a header but it's
defined without it in the source file. The <tt>throw()</tt>
declaration is suppressed when compiling the definition to avoid
compiler errors. This technique, while strictly speaking no permitted
by the language, is safe and has been employed in practice. For
example, the GNU C library takes this approach. Microsoft Visual C++
takes a similar approach by simply assuming that no function with C
language linkage can throw an exception unless it's explicitly
declared to do so using the language extension <tt>throw(...)</tt>.

       </p>
       <p>

Our answer to point (2) above is that there is no existing practice
where C++ Standard Library implementers have opted to make use of the
proprietary mechanisms to declare functions that don't throw. The
language provides a mechanism specifically designed for this
purpose. Avoiding its use in the specification itself in favor of
proprietary mechanisms defeats the purpose of the feature. In
addition, making use of the empty exception specification
inconsistently, in some areas of the standard, while conspicuously
avoiding it and making use of the "<i>Throws:</i> Nothing." form in
others is confusing to users.

       </p>
       <p>

The answer to point (3) is simply to exercise caution when declaring
functions and especially function templates with the empty exception
specification. Functions that required not to throw but that may call
back into user code are poor candidates for the empty exception
specification and should instead be specified using "<i>Throws:</i>
Nothing." clause.

      </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We need someone to do an extensive review.
</p>
<p>
NAD Future.
</p>
</blockquote>

   
   <p><b>Proposed resolution:</b></p>
       <p>

We propose two possible solutions. Our recommendation is to adopt
Option 1 below.

       </p>
       <p>

<b>Option 1:</b>

       </p>
       <p>

Except for functions or function templates that make calls back to
user-defined functions that may not be declared <tt>throw()</tt>
replace all occurrences of the "<i>Throws:</i> Nothing." clause with
the empty exception specification. Functions that are required not to
throw but that make calls back to user code should be specified to
"<i>Throw:</i> Nothing."

       </p>
       <p>

<b>Option 2:</b>

       </p>
       <p>

For consistency, replace all occurrences of the empty exception
specification with a "<i>Throws:</i> Nothing." clause.

       </p>
   



<hr>
<h3><a name="933" href="933">933.</a> Unique_ptr defect</h3>
<p><b>Section:</b> 23.11.1.2.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-11-27 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.modifiers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we are supporting stateful deleters, we need an overload for
<tt>reset</tt> that
takes a deleter as well.
</p>

<blockquote><pre>
void reset( pointer p, deleter_type d);
</pre></blockquote>

<p>
We probably need two overloads to support move-only deleters, and
this
sounds uncomfortably like the two constructors I have been ignoring
for
now...
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard comments that we have the functionality via move-assigment.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD Future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="935" href="935">935.</a> clock error handling needs to be specified</h3>
<p><b>Section:</b> 23.17.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock">[time.clock]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-11-24 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Each of the three clocks specified in Clocks 23.17.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock">[time.clock]</a>
provides the member function:
</p>

<blockquote><pre>
static time_point now();
</pre></blockquote>

<p>
The semantics specified by Clock requirements 23.17.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a>
make no mention of error handling. Thus the function may throw <tt>bad_alloc</tt>
or an implementation-defined exception (20.5.5.12 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>
paragraph 4).
</p>

<p>
Some implementations of these functions on POSIX, Windows, and
presumably on other operating systems, may fail in ways only detectable
at runtime. Some failures on Windows are due to supporting chipset
errata and can even occur after successful calls to a clock's <tt>now()</tt>
function.
</p>

<p>
These functions are used in cases where exceptions are not appropriate
or where the specifics of the exception or cause of error need to be
available to the user. See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error
handling (Rev 1)</i>, for more specific discussion of use cases. Thus some change in
the interface of now is required.
</p>

<p>
The proposed resolution has been implemented in the Boost version of the
chrono library. No problems were encountered.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be deferred until the next Committee Draft
has been issued and the prerequisite paper has been accepted.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD future. Too late to make this change without having already
accepted the hybrid error handling proposal.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Accept the proposed wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error handling (Rev 1)</i>.
</p>

<p>
Change <tt>Clock</tt> requirements 23.17.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a> as indicated:
</p>

<blockquote>
<p>
-2- In Table 55 <tt>C1</tt> and <tt>C2</tt> denote clock types. <tt>t1</tt> and
<tt>t2</tt> are values returned by <tt>C1::now()</tt> where the call 
returning <tt>t1</tt> happens before (1.10) the call returning <tt>t2</tt> and
both of these calls happen before <tt>C1::time_point::max()</tt>.
<ins><tt>ec</tt> denotes an object of type <tt>error_code</tt> 
(22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.overview">[syserr.errcode.overview]</a>).</ins>
</p>

<table border="1">
<caption>Table 55 &mdash; Clock requirements</caption>
<tr>
<th>Expression</th><th>Return type</th><th>Operational semantics</th>
</tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>

<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point</tt></td>
<td>Returns a <tt>time_point</tt> object representing the current point in time.
</td>
</tr>

<tr>
<td><tt><ins>C1::now(ec)</ins></tt></td>
<td><tt><ins>C1::time_point</ins></tt></td>
<td><ins>Returns a <tt>time_point</tt> object representing the current point in time.</ins>
</td>
</tr>
</table>
</blockquote>

<p>
Change class <tt>system_clock</tt> 23.17.7.1 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system">[time.clock.system]</a> as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>monotonic_clock</tt> 99 [time.clock.monotonic] as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>high_resolution_clock</tt> 23.17.7.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.hires">[time.clock.hires]</a> as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>






<hr>
<h3><a name="936" href="936">936.</a> Mutex type overspecified</h3>
<p><b>Section:</b> 33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-05 <b>Last modified:</b> 2017-03-01 18:03:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="961">961</a></p>
<p><b>Discussion:</b></p>



<p>
33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> describes the requirements for a type to be
a "Mutex type". A Mutex type can be used as the template argument for
the <tt>Lock</tt> type that's passed to <tt>condition_variable_any::wait</tt> (although
<tt>Lock</tt> seems like the wrong name here, since <tt>Lock</tt> is given a different
formal meaning in 33.4.4 <a href="https://timsong-cpp.github.io/cppwp/thread.lock">[thread.lock]</a>) and, although the WD doesn't quite say
so, as the template argument for <tt>lock_guard</tt> and <tt>unique_lock</tt>.
</p>

<p>
The requirements for a Mutex type include:
</p>

<ul>
<li>
<tt>m.lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
<li>
<tt>m.try_lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>bool</tt>.
</li>
<li>
<tt>m.unlock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
</ul>

<p>
Also, a Mutex type "shall not be copyable nor movable".
</p>

<p>
The latter requirement seems completely irrelevant, and the three
requirements on return types are tighter than they need to be. For
example, there's no reason that <tt>lock_guard</tt> can't be instantiated with a
type that's copyable. The rule is, in fact, that <tt>lock_guard</tt>, etc. won't
try to copy objects of that type. That's a constraint on locks, not on
mutexes. Similarly, the requirements for <tt>void</tt> return types are
unnecessary; the rule is, in fact, that <tt>lock_guard</tt>, etc. won't use any
returned value. And with the return type of <tt>bool</tt>, the requirement should
be that the return type is convertible to <tt>bool</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Move to open. Related to conceptualization and should probably be tackled as part of that.
</p>
<ul>
<li>
The intention is not only to place a constraint on what types such as
<tt>lock_guard</tt> may do with mutex types, but on what any code, including user
code, may do with mutex types. Thus the constraints as they are apply to
the mutex types themselves, not the current users of mutex types in the
standard.
</li>
<li>
This is a low priority issue; the wording as it is may be overly
restrictive but this may not be a real issue.
</li>
</ul>
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Section 33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> conflates the
requirements on a generic Mutex type (including user-supplied mutexes)
with the requirements placed on the standard-supplied mutex types in an
attempt to group everything together and save space.
</p>
<p>
When applying concepts to chapter 30, I suggest that the concepts
<tt>Lockable</tt> and <tt>TimedLockable</tt> embody the requirements for
*use* of a mutex type as required by
<tt>unique_lock/lock_guard/condition_variable_any</tt>. These should be
relaxed as Pete describes in the issue. The existing words in 33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> are requirements on all of
<tt>std::mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_mutex</tt> and <tt>std::recursive_timed_mutex</tt>,
and should be rephrased as such.
</p>
</blockquote>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1: Agreement that we need a paper.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="961" href="961">961.</a> Various threading bugs #11</h3>
<p><b>Section:</b> 33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2017-03-01 18:03:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="936">936</a></p>
<p><b>Discussion:</b></p>
<p>
33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> describes required member
functions of mutex types, and requires that they throw exceptions under
certain circumstances. This is overspecified. User-defined types can
abort on such errors without affecting the operation of templates
supplied by standard-library.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
Move to open. Related to conceptualization and should probably be
tackled as part of that.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Would be OK to leave it as is for time constraints, could loosen later.
</p>

<p>
Mark as NAD Future.
</p>
</blockquote>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1: Agreement that we need a paper.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1025" href="1025">1025.</a> The library should provide more specializations for <tt>std::hash</tt></h3>
<p><b>Section:</b> 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 208 [CD1]</b></p>

<p>
<tt>std::hash</tt> should be implemented for much more of the standard
library. In particular for <tt>pair</tt>, <tt>tuple</tt> and all the
standard containers.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1031" href="1031">1031.</a> Need <tt>shared_ptr</tt> conversion to a <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 78 [CD1]</b></p>

<p>
There is presently no way to convert directly from a <tt>shared_ptr</tt> to a
<tt>unique_ptr</tt>. Add an interface that performs the conversion. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We believe that the shared pointer must use the default
deleter for the conversion to succeed.
</p></blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote><p>
This is basically a request for <tt>shared_ptr&lt;&gt;::release</tt> in
disguise, with all the associated problems. Not a good idea.
</p></blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
<p>
The rationale for the omission of a release() member function from shared_ptr is given in:
<a href="http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm</a>
</p>
<p>
The implementation of such a member is non-trivial (and maybe
impossible), because it would need to account for the deleter.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard sets to Tentatively NAD Future.
]</i></p>


<blockquote>
<p>
I took an online poll and got 3 votes for NAD and 3 for NAD Future.  Personally
I prefer NAD Future as this does refer to an extension that could conceivably be
considered beyond C++0X.
</p>

<p>
However such an extension would need to solve a couple of problems:
</p>

<ol>
<li>What is the interface for such a conversion when the <tt>shared_ptr</tt> does
not have unique ownership?  Throw an exception?  Create a null <tt>unique_ptr</tt>?
Undefined behavior?
</li>

<li>
<p>
How does one handle custom deleters given to the <tt>shared_ptr</tt> constructor?
</p>
<p>
I do not believe it is possible to implement a general answer to this question.
The <tt>shared_ptr</tt> deleter is a run time (or construction time) characteristic.
The <tt>unique_ptr</tt> deleter is a compile time characteristic.  In general one
can not know to what type of <tt>unqiue_ptr</tt> you are converting to.
</p>
<p>
One answer is for the user of the conversion to specify the deleter type and perhaps
throw an exception if the specification turns out to be incorrect.
</p>
<p>
Another answer is for the conversion to only be valid when the underlying deleter
is <tt>default_delete</tt>.  We would probalby need to specify that this is indeed the
underlying deleter of a <tt>shared_ptr</tt> when a custom deleter is not given in
the constructor.
</p>
</li>
</ol>

<p>
At any rate, there are non-trivial design issues which would need to be implemented
and tested in the field for usability prior to standardization.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to NAD Future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1052" href="1052">1052.</a> <tt>reverse_iterator::operator-&gt;</tt> should also support smart pointers</h3>
<p><b>Section:</b> 27.5.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opref">[reverse.iter.opref]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-10-08 04:10:13 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.opref">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opref">[reverse.iter.opref]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="2775">2775</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 281 [CD1]</b></p>

<p>
The current specification for return value for <tt>reverse_iterator::operator-&gt;</tt>
will always be a true pointer type, but <tt>reverse_iterator</tt> supports proxy
iterators where the pointer type may be some kind of 'smart pointer'.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
<tt>move_iterator</tt> avoids this problem by returning a value of the wrapped
Iterator type.
study group formed to come up with a suggested resolution.
</p>
<p>
<tt>move_iterator</tt> solution shown in proposed wording.
</p>
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote><p>
Howard to deconceptize. Move to Review after that happens.
</p></blockquote>

<p><i>[
2009-08-01 Howard deconceptized:
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
We can't think of any reason we can't just define reverse
iterator's pointer types to be the same as the underlying iterator's
pointer type, and get it by calling the right arrow directly.
</p>
<p>
Here is the proposed wording that was replaced:
</p>
<blockquote><pre>
template &lt;class Iterator&gt; 
class reverse_iterator { 
  ...
  typedef <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del> pointer;
</pre></blockquote>

<p>
Change 27.5.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opref">[reverse.iter.opref]</a>:
</p>

<blockquote><pre>
pointer operator-&gt;() const;
</pre>
<blockquote><p>
<i>Returns:</i>
</p><blockquote><pre>
<del>&amp;(operator*());</del>
<ins>this-&gt;tmp = current;</ins>
<ins>--this-&gt;tmp;</ins>
<ins>return this-&gt;tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</blockquote>

<p><i>[
2010-03-03 Daniel opens:
]</i></p>


<blockquote>
<ol>

<li>
There is a minor problem with the exposition-only declaration of the private
member <tt>deref_tmp</tt> which is modified in a const member function (and the
same problem occurs in the specification of <tt>operator*</tt>). The fix is to
make it a mutable member.
</li>

<li>
<p>
The more severe problem is that the resolution for some reasons
does not explain in the rationale why it was decided to differ from
the suggested fix (using <tt>deref_tmp</tt> instead of <tt>tmp</tt>) in the
[ 2009-10 Santa Cruz] comment:
</p>

<blockquote><pre>
this-&gt;deref_tmp = current;
--this-&gt;deref_tmp;
return this-&gt;deref_tmp;
</pre></blockquote>

<p>
combined with the change of
</p>

<blockquote><pre>
typedef typename iterator_traits&lt;Iterator&gt;::pointer pointer;
</pre></blockquote>

<p>
to
</p>

<blockquote><pre>
typedef Iterator pointer;
</pre></blockquote>

<p>
The problem of the agreed on wording is that the following rather
typical example, that compiled with the wording before 1052 had
been applied, won't compile anymore:
</p>

<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;utility&gt;

int main() {
  typedef std::pair&lt;int, double&gt; P;
  P op;
  std::reverse_iterator&lt;P*&gt; ri(&amp;op + 1);
  ri-&gt;first; // Error
}
</pre></blockquote>

<p>
Comeau online returns (if a correspondingly changed
<tt>reverse_iterator</tt> is used):
</p>

<blockquote><pre>
"error: expression must have class type
     return deref_tmp.operator-&gt;();
            ^
         detected during instantiation of "Iterator
                   reverse_iterator&lt;Iterator&gt;::operator-&gt;() const [with
                   Iterator=std::pair&lt;int, double&gt; *]""
</pre></blockquote>

<p>
Thus the change will break valid, existing code based
on <tt>std::reverse_iterator</tt>.
</p>

</li>

</ol>

<p>
IMO the suggestion proposed in the comment is a necessary fix, which harmonizes
with the similar specification of <tt>std::move_iterator</tt> and properly
reflects the recursive nature of the evaluation of <tt>operator-&gt;</tt>
overloads.
</p>

<p>
Suggested resolution:
</p>

<ol>

<li>
<p>
In the class template <tt>reverse_iterator</tt> synopsis of 27.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a> 
change as indicated:
</p>

<blockquote><pre>
namespace std {
template &lt;class Iterator&gt;
class reverse_iterator : public
             iterator&lt;typename iterator_traits&lt;Iterator&gt;::iterator_category,
             typename iterator_traits&lt;Iterator&gt;::value_type,
             typename iterator_traits&lt;Iterator&gt;::difference_type,
             <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del>,
             typename iterator_traits&lt;Iterator&gt;::reference&gt; {
public:
  [..]
  typedef <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del> pointer;
  [..]
protected:
  Iterator current;
private:
  <ins>mutable</ins> Iterator deref_tmp; // exposition only
};
</pre></blockquote>
</li>

<li>
Change 27.5.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opref">[reverse.iter.opref]</a>/1 as indicated:

<blockquote><pre>
pointer operator-&gt;() const;
</pre>

<blockquote><p>
1 <i><del>Returns</del> <ins>Effects</ins>:</i> <del><tt>&amp;(operator*())</tt>.</del>
</p><blockquote><pre>
<ins>deref_tmp = current;</ins>
<ins>--deref_tmp;</ins>
<ins>return deref_tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
We prefer to make to use a local variable instead of <tt>deref_tmp</tt> within
<tt>operator-&gt;()</tt>.  And although this means that the <tt>mutable</tt>
change is no longer needed, we prefer to keep it because it is needed for
<tt>operator*()</tt> anyway.
</p>

<p>
Here is the proposed wording that was replaced:
</p>

<blockquote class="note">
<p>
Change 27.5.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opref">[reverse.iter.opref]</a>:
</p>

<blockquote><pre>
pointer operator-&gt;() const;
</pre>

<blockquote><p>
<i>Returns:</i>
</p><blockquote><pre>
<del>&amp;(operator*());</del>
<ins>deref_tmp = current;
--deref_tmp;
return deref_tmp::operator-&gt;();</ins>
</pre></blockquote>

</blockquote>
</blockquote>


</blockquote>
</blockquote>

<p><i>[
2010-03-10 Howard adds:
]</i></p>


<blockquote>
<p>
Here are three tests that the current proposed wording passes, and no
other solution I've seen passes all three:
</p>

<ol>
<li>
<p>
Proxy pointer support:
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;cassert&gt;

struct X { int m; };

X x;

struct IterX {
    typedef std::bidirectional_iterator_tag iterator_category;
    typedef X&amp; reference;
    struct pointer
    {
        pointer(X&amp; v) : value(v) {}
        X&amp; value;
        X* operator-&gt;() const {return &amp;value;}
    };
    typedef std::ptrdiff_t difference_type;
    typedef X value_type;
    // additional iterator requirements not important for this issue
    
    reference operator*() const { return x; }
    pointer operator-&gt;() const { return pointer(x); }
    IterX&amp; operator--() {return *this;}

};

int main()
{
    std::reverse_iterator&lt;IterX&gt; ix;
    assert(&amp;ix-&gt;m == &amp;(*ix).m);
}
</pre></blockquote>
</li>
<li>
<p>
Raw pointer support:
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;utility&gt;

int main() {
  typedef std::pair&lt;int, double&gt; P;
  P op;
  std::reverse_iterator&lt;P*&gt; ri(&amp;op + 1);
  ri-&gt;first; // Error
}
</pre></blockquote>
</li>
<li>
<p>
Caching iterator support:
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;cassert&gt;

struct X { int m; };

struct IterX {
    typedef std::bidirectional_iterator_tag iterator_category;
    typedef X&amp; reference;
    typedef X* pointer;
    typedef std::ptrdiff_t difference_type;
    typedef X value_type;
    // additional iterator requirements not important for this issue
    
    reference operator*() const { return value; }
    pointer operator-&gt;() const { return &amp;value; }
    IterX&amp; operator--() {return *this;}

private:
    mutable X value;
};

int main()
{
    std::reverse_iterator&lt;IterX&gt; ix;
    assert(&amp;ix-&gt;m == &amp;(*ix).m);
}
</pre></blockquote>
</li>
</ol>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Future, rationale added.
</p></blockquote>




<p><b>Rationale:</b></p>
<p>
The LWG did not reach a consensus for a change to the WP.
</p>


<p><b>Proposed resolution:</b></p>

<ol>

<li>
<p>
In the class template <tt>reverse_iterator</tt> synopsis of 27.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a> change as indicated:
</p>

<blockquote><pre>
namespace std {
template &lt;class Iterator&gt;
class reverse_iterator : public
             iterator&lt;typename iterator_traits&lt;Iterator&gt;::iterator_category,
             typename iterator_traits&lt;Iterator&gt;::value_type,
             typename iterator_traits&lt;Iterator&gt;::difference_type,
             <del>typename iterator_traits&lt;</del>Iterator<ins>&amp;</ins><del>&gt;::pointer</del>,
             typename iterator_traits&lt;Iterator&gt;::reference&gt; {
public:
  [..]
  typedef <del>typename iterator_traits&lt;</del>Iterator<ins>&amp;</ins><del>&gt;::pointer</del> pointer;
  [..]
protected:
  Iterator current;
private:
  <ins>mutable</ins> Iterator deref_tmp; // exposition only
};
</pre></blockquote>
</li>

<li>
Change 27.5.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opref">[reverse.iter.opref]</a>/1 as indicated:

<blockquote><pre>
pointer operator-&gt;() const;
</pre>

<blockquote><p>
1 <i><del>Returns</del> <ins>Effects</ins>:</i> <del><tt>&amp;(operator*())</tt>.</del>
</p><blockquote><pre>
<ins>deref_tmp = current;</ins>
<ins>--deref_tmp;</ins>
<ins>return deref_tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>


<p><i>[Alternate Proposed Resolution from <a href="2775">2775</a>, which was closed as a dup of this issue]</i></p>


<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 27.5.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opref">[reverse.iter.opref]</a> as indicated:</p>
<blockquote>
<pre>
constexpr pointer operator-&gt;() const;
</pre>
<blockquote>
<p>
-1- <del><i>Returns:</i> <tt>addressof(operator*())</tt>.</del><ins><i>Effects:</i> If <tt>Iterator</tt>
is a pointer type, as if by:</ins>
</p>
<blockquote><pre>
<ins>Iterator tmp = current;
return --tmp;</ins>
</pre></blockquote>
<p>
<ins>Otherwise, as if by:</ins>
</p>
<blockquote><pre>
<ins>Iterator tmp = current;
--tmp;
return tmp.operator-&gt;();</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>









<hr>
<h3><a name="1053" href="1053">1053.</a> Unify algorithms with operator and function object variants</h3>
<p><b>Section:</b> 28 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 295 [CD1]</b></p>

<p>
There is a level of redundancy in the library specification for many
algorithms that can be eliminated with the combination of concepts and
default parameters for function templates. Eliminating redundancy simplified
specification and reduces the risk of introducing accidental
inconsistencies.
</p>
<p>
Proposed resolution: Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2743.pdf">N2743</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
NAD, this change would break code that takes the address of an algorithm.
</p>
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Request 'Open'.  The issues in the paper go beyond just reducing
the number of signatures, but cover unifying the idea of the ordering
operation used by algorithms, containers and other library components.  At
least, it takes a first pass at the problem.
</p>

<p>
For me (personally) that was the more important part of the paper, and not
clearly addressed by the Summit resolution.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Too inventive, too late, would really need a paper. Moved to NAD Future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1112" href="1112">1112.</a> bitsets and new style for loop</h3>
<p><b>Section:</b> 23.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-06 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#template.bitset">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::bitset</tt> is a homogeneous container-like sequence of bits, yet it does
not model the Range concept so cannot be used with the new for-loop syntax.
It is the only such type in the library that does NOT support the new for
loop.
</p>
<p>
The obvious reason is that bitset does not support iterators.
</p>
<p>
At least two reasonable solutions are available:
</p>
<ol style="list-style-type:lower-roman">
<li>
Add an iterator interface to <tt>bitset</tt>, bringing its interface close to that
of <tt>std::array</tt>
</li>
<li>
Provide an unspecified concept_map for <tt>Range&lt;bitset&gt;</tt>.
</li>
</ol>
<p>
The latter will still need some kind of iterator-like adapter for <tt>bitset</tt>,
but gives implementers greater freedom on the details. E.g. begin/end return
some type that simply invokes <tt>operator[]</tt> on the object it wraps, and
increments its index on <tt>operator++</tt>.  A vendor can settle for <tt>InputIterator</tt>
support, rather than wrapping up a full <tt>RandomAccessIterator</tt>.
</p>
<p>
I have a mild preference for option (ii) as I think it is less work to
specify at this stage of the process, although (i) is probably more useful
in the long run.
</p>
<p>
Hmm, my wording looks a little woolly, as it does not say what the element
type of the range is.  Do I get a range of <tt>bool</tt>, <tt>bitset&lt;N&gt;::reference</tt>, or
something else entirely?
</p>
<p>
I guess most users will assume the behaviour of reference, but expect to
work with <tt>bool</tt>.  <tt>Bool</tt> is OK for read-only traversal, but you really need to
take a reference to a <tt>bitset::reference</tt> if you want to write back.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open.
We further recommend this be deferred until after the next Committee Draft.
</p></blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
<p>
I just stumbled over the <tt>Range concept_map</tt> for <tt>valarray</tt> and this should
probably set the precedent on how to write the wording.
</p>

<p><i>[
Howard: I've replaced the proposed wording with Alisdair's suggestion.
]</i></p>


</blockquote>

<p><i>[
2009-07-24 Daniel modifies the proposed wording for non-concepts.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Mark as Tentatively NAD Future due to the loss of concepts.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
All concepts-related text has been removed from the draft.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Modify the section 23.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> <tt>&lt;bitset&gt;</tt> synopsis by adding
the following at the end of the synopsis:
</p>
<blockquote><pre>
<ins>
// XX.X.X bitset range access [bitset.range]
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins>
</pre></blockquote>
</li>
<li>
<p>
Add a new section <ins>"bitset range access" [bitset.range]</ins>
after the current section 23.9.4 <a href="https://timsong-cpp.github.io/cppwp/bitset.operators">[bitset.operators]</a> with the following series of
paragraphs:
</p>
<blockquote>
<p>
<ins>
1.  In the <tt>begin</tt> and <tt>end</tt> function templates that follow, <i>unspecified-1</i>
is a type that meets the requirements of a mutable random access
iterator (27.2.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>) whose <tt>value_type</tt> is <tt>bool</tt> and
whose reference type is <tt>bitset&lt;N&gt;::reference</tt>.
<i>unspecified-2</i> is a type that meets the requirements of a constant
random access iterator (27.2.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>) whose <tt>value_type</tt>
is <tt>bool</tt> and whose reference type is <tt>bool</tt>.
</ins>
</p>
<pre>
<ins>
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
</ins>
</pre>
<blockquote><p>
<ins>2.  Returns: an iterator referencing the first bit in the bitset.</ins>
</p></blockquote>

<pre><ins>
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins></pre>

<blockquote><p>
<ins>3.  Returns: an iterator referencing one past the last bit in the
bitset.</ins>
</p></blockquote>
</blockquote>
</li>
</ol>












<hr>
<h3><a name="1120" href="1120">1120.</a> New type trait - remove_all</h3>
<p><b>Section:</b> 23.15 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sometimes it is necessary to remove all qualifiers from a type before
passing on to a further API.  A good example would be calling the
<tt>tuple</tt> query APIs <tt>tuple_size</tt> or <tt>tuple_element</tt>
with a deduced type inside a function template.  If the deduced type is
cv-qualified or a reference then the call will fail.  The solution is to
chain calls to
<tt>remove_cv&lt;remove_reference&lt;T&gt;::type&gt;::type</tt>, and
note that the order matters.
</p>
<p>
Suggest it would be helpful to add a new type trait,
<tt>remove_all</tt>, that removes all top-level qualifiers from a type
i.e. cv-qualification and any references.  Define the term in such a way
that if additional qualifiers are added to the language, then
<tt>remove_all</tt> is defined as stripping those as well.
</p>

<p><i>[
2009-10-14 Daniel adds:
]</i></p>


<blockquote><p>
<tt>remove_all</tt> seems too generic, a possible alternative matching
the current naming style could be <tt>remove_cv_reference</tt> or
<tt>remove_reference_cv</tt>. It should also be considered whether this
trait should also remove 'extents', or pointer 'decorations'. Especially
if the latter situations are considered as well, it might be easier to
chose the name not in terms of what it <em>removes</em> (which might be
a lot), but in terms of it <em>creates</em>. In this case I could think
of e.g. <tt>extract_value_type</tt>.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1121" href="1121">1121.</a> Support for multiple arguments</h3>
<p><b>Section:</b> 23.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ratio.arithmetic">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both add and multiply could sensibly be called with more than two arguments.
The variadic template facility makes such declarations simple, and is likely
to be frequently wrapped by end users if we do not supply the variant
ourselves.
</p>
<p>
We deliberately ignore divide at this point as it is not transitive.
Likewise, subtract places special meaning on the first argument so I do not
suggest extending that immediately.  Both could be supported with analogous
wording to that for add/multiply below.
</p>
<p>
Note that the proposed resolution is potentially incompatible with that
proposed for <a href="921">921</a>, although the addition of the typedef to ratio would be
equally useful.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The consensus of the group when we reviewed this in Santa Cruz was that
<a href="921">921</a> would proceed to Ready as planned, and the
multi-paramater add/multiply templates should be renamed as
<tt>ratio_sum</tt> and <tt>ratio_product</tt> to avoid the problem
mixing template aliases with partial specializations.
</p>

<p>
It was also suggested to close this issue as NAD Future as it does not
correspond directly to any NB comment.  NBs are free to submit a
specific comment (and re-open) in CD2 though.
</p>

<p>
Walter Brown also had concerns on better directing the order of
evaluation to avoid overflows if we do proceed for 0x rather than TR1,
so wording may not be complete yet.
</p>

<p><i>[
Alisdair updates wording.
]</i></p>


</blockquote>

<p><i>[
2009-10-30 Howard:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the following type traits to p3 23.16 <a href="https://timsong-cpp.github.io/cppwp/ratio">[ratio]</a>
</p>

<blockquote><pre>
// ratio arithmetic
template &lt;class R1, class R2&gt; struct ratio_add;
template &lt;class R1, class R2&gt; struct ratio_subtract;
template &lt;class R1, class R2&gt; struct ratio_multiply;
template &lt;class R1, class R2&gt; struct ratio_divide;
<ins>template &lt;class R1, class ... RList&gt; struct ratio_sum;</ins>
<ins>template &lt;class R1, class ... RList&gt; struct ratio_product;</ins>
</pre></blockquote>

<p>
after 23.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p1: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_sum; // declared, never defined

template &lt;class R1&gt; struct ratio_sum&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_sum&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>

<p>
after 23.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p3: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_product; // declared, never defined

template &lt;class R1&gt; struct ratio_product&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_product&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>








<hr>
<h3><a name="1150" href="1150">1150.</a> wchar_t, char16_t and char32_t filenames</h3>
<p><b>Section:</b> 30.9.5 <a href="https://timsong-cpp.github.io/cppwp/fstream">[fstream]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 73</b></p>

   <p><b>Description</b></p>
        <p>It is a problem
        from C++98, <tt>fstream</tt> cannot appoint a filename of wide
        character string(<tt>const wchar_t</tt> and <tt>const wstring&amp;</tt>).</p>
<p><b>Suggestion</b></p>
        <p>Add
        interface corresponding to <tt>wchar_t</tt>, <tt>char16_t</tt> and <tt>char32_t</tt>.</p>

<p><i>[
2009-07-01 Alisdair notes that this is a duplicate of <a href="454">454</a> which has more
in-depth rationale.
]</i></p>


<p><i>[
2009-09-21 Daniel adds:
]</i></p>


<blockquote><p>
I suggest to mark this issue as NAD Future with the intend to
solve the issue with a single file path c'tor template assuming
a provision of a TR2 filesystem library.
</p></blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  This is a duplicate of <a href="454">454</a>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1154" href="1154">1154.</a> <tt>complex</tt> should accept integral types</h3>
<p><b>Section:</b> 29.5 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2017-03-03 18:03:12 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 35</b></p>

<p><b>Description</b></p>
        <p>Instantiations of the class
        template <tt>complex&lt;&gt;</tt> have to be allowed for integral
        types, to reflect existing practice and ISO standards
        (LIA-III).</p>
        
<p><b>Suggestion</b></p>

<p><i>[
2009-10-26 Proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3002.pdf">N3002</a>.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Future.  Rationale added.
</p></blockquote>

<p><i>[2017-03-03, Kona]</i></p>

<p>
SG6 suggests this issue is a new feature, not a problem with the existing
standard, and should therefore be closed NAD. However, SG6 invites papers that bring
the proposal up to date with the current standard.
</p>


<p><b>Rationale:</b></p>
<p>
There is no consensus for making this change at this time.
</p>


<p><b>Proposed resolution:</b></p><p>
Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3002.pdf">N3002</a>.
</p>




<hr>
<h3><a name="1175" href="1175">1175.</a> <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote><p>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</p></blockquote>

<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at 
both the clause 23 requirements tables and the constructor description of each unordered container to be sure.
</p>
<p>
Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.
</p>
<p>
Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[2011-02-26: Daniel provides wording]</i></p>


<p>I strongly suggest to clean-up the differences between requirement tables and individual
specifications. In the usual way, the most specific specifications wins, which is in this
case the wrong one. In regard to the concern expressed about missing <tt>DefaultConstructible</tt>
requirements of the value type I disagree: The function argument <tt>n</tt> is no size-control
parameter, but only some effective capacity parameter: No elements will be value-initialized
by these constructors. The necessary requirement for the value type, <tt>EmplaceConstructible</tt>
into <tt>*this</tt>, is already listed in Table 103 &mdash; Unordered associative container requirements.
Another part of the proposed resolution is the fact that there is an inconsistency of the
complexity counting when both a range <strong>and</strong> a bucket count is involved compared
to constructions where only bucket counts are provided: E.g. the construction <tt>X a(n);</tt>
has a complexity of <tt>n</tt> bucket allocations, but this part of the work is omitted for
<tt>X a(i, j, n);</tt>, even though it is considerable larger (in the average case) for 
<tt>n &#8811; distance(i, j)</tt>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The proposed wording looks good.  Move to Review.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Fix up some presentation issues with the wording, combining the big-O expressions into single
expressions rather than the sum of two separate big-Os.
</p>
<p>
Strike "constant or linear", prefer "linear in the number of buckets".
This allows for number of buckets being larger than requested <tt>n</tt> as well.
</p>
<p>
Default <tt>n</tt> to "unspecified" rather than "implementation-defined".  It seems an un-necessary
burden asking vendors to document a quantity that is easily determined through the public API of
these classes.
</p>
<p>
Replace <tt>distance(f,l)</tt> with "number of elements in the range <tt>[f,l)</tt>"
</p>
<p>
Retain in Review with the updated wording
</p>

<p><i>[2012, Portland: Move to Open]</i></p>

<p>
The wording still does not call out Pablo's original concern, that the element constructor is called
no more than <tt>N</tt> times, and that the <tt>N</tt> squared term applies to moves during rehash.
</p>

<p>
Inconsistent use of O(n)+O(N) vs. O(n+N), with a preference for the former.
</p>

<p>
AJM to update wording with a reference to "no more than <tt>N</tt> element constructor calls".
</p>

<p>
Matt concerned that calling out the O(n) requirements is noise, and dangerous noise in suggesting a precision
we do not mean.  The cost of constructing a bucket is very different to constructing an element of user-supplied
type.
</p>

<p>
AJM notes that if there are multiple rehashes, the 'n' complexity is probably not linear.
</p>

<p>
Matt suggests back to Open, Pablo suggests potentially NAD if we keep revisitting without achieving a resolution.
</p>

<p>
Matt suggests complexity we are concerned with is the number of operations, such as constructing elements, moving
nodes, and comparing/hashing keys.  We are less concerned with constructing buckets, which are generally noise in
this bigger picture.
</p>

<p><i>[2015-01-29 Telecon]</i></p>

<p>
AM: essentially correct, but do we want to complicate the spec?
<p/>
HH: Pablo has given us permission to NAD it
<p/>
JM: when I look at the first change in the P/R I find it mildly disturbing that the existing wording says you have a 
constant time constructor with a single element even if your <tt>n</tt> is 10^6, so I think adding this change makes people 
aware there might be a large cost in initializing the hash table, even though it doesn't show up in user-visible constructions.
<p/>
HH: one way to avoid that problem is make the default ctor <tt>noexcept</tt>. Then the container isn't allowed to create 
an arbitrarily large hash table
<p/>
AM: but this is the constructor where the user provides <tt>n</tt>
<p/>
MC: happy with the changes, except I agree with the editorial recommendation to keep the two &#x1d4aa;s separate.
<p/>
JW: yes, the constant '<tt>k</tt>' is different in &#x1d4aa;(n) and &#x1d4aa;(N)
<p/>
GR: do we want to talk about buckets at all
<p/>
JM: yes, good to highlight that bucket construction might be a significant cost
<p/>
HH: suggest we take the suggestion to split &#x1d4aa;(n+N) to &#x1d4aa;(n)+&#x1d4aa;(N) and move to Tentatively Ready
<p/>
GR: 23.2.1p2 says all complexity requirements are stated solely in terms of the number of operations on the contained 
object, so we shouldn't be stating complexity in terms of the hash table initialization
<p/>
HH: channeling Pete, there's an implicit "unless otherwise specified" everywhere.
<p/>
VV: seem to be requesting modifications that render this not Tentatively Ready
<p/>
GR: I think it can't be T/R
<p/>
AM: make the editorial recommendation, consider fixing 23.2.1/3 to give us permission to state complexity in terms 
of bucket initialization
<p/>
HH: only set it to Review after we get new wording to review 
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Update wording, revisit later.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Modify the following rows in Table 103 &mdash; Unordered associative container requirements to
add the explicit bucket allocation overhead of some constructions. As editorial recommendation it is 
suggested <em>not</em> to shorten the sum <tt>&#x1d4aa;(n) + &#x1d4aa;(<em>N</em>)</tt> to
<tt>&#x1d4aa;(n + <em>N</em>)</tt>, because two different work units are involved.</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf, eq)</tt><br/>
<tt>X a(i, j, n, hf, eq)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>eq</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf)</tt><br/>
<tt>X a(i, j, n, hf)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case &#x1d4aa;(<tt><i><ins>n + </ins>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n)</tt><br/>
<tt>X a(i, j, n)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hasher()</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case &#x1d4aa;(<tt><i><ins>n + </ins>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 26.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a> p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_map(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_map(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 26.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a> p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multimap(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 26.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a> p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_set(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_set(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a> p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multiset(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multiset(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1184" href="1184">1184.</a> Feature request: dynamic bitset</h3>
<p><b>Section:</b> 26.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-29 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Opened at Alisdair's request, steming from <a href="96">96</a>.
Alisdair recommends NAD Future.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  We want a heap allocated bitset, but we don't have one today and
don't have time to add one.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1188" href="1188">1188.</a> Unordered containers should have a minimum load factor as well as a maximum</h3>
<p><b>Section:</b> 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 26.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unordered associative containers have a notion of a maximum load factor:
when the number of elements grows large enough, the containers
automatically perform a rehash so that the number of elements per bucket
stays below a user-specified bound. This ensures that the hash table's
performance characteristics don't change dramatically as the size
increases.
</p>

<p>
For similar reasons, Google has found it useful to specify a minimum
load factor: when the number of elements shrinks by a large enough, the
containers automatically perform a rehash so that the number of elements
per bucket stays above a user-specified bound. This is useful for two
reasons. First, it prevents wasting a lot of memory when an unordered
associative container grows temporarily. Second, it prevents amortized
iteration time from being arbitrarily large; consider the case of a hash
table with a billion buckets and only one element. (This was discussed
even before TR1 was published; it was TR issue 6.13, which the LWG
closed as NAD on the grounds that it was a known design feature.
However, the LWG did not consider the approach of a minimum load
factor.)
</p>

<p>
The only interesting question is when shrinking is allowed. In principle
the cleanest solution would be shrinking on erase, just as we grow on
insert. However, that would be a usability problem; it would break a
number of common idioms involving erase. Instead, Google's hash tables
only shrink on insert and rehash.
</p>

<p>
The proposed resolution allows, but does not require, shrinking in
rehash, mostly because a postcondition for rehash that involves the
minimum load factor would be fairly complicated. (It would probably have
to involve a number of special cases and it would probably have to
mention yet another parameter, a minimum bucket count.)
</p>

<p>
The current behavior is equivalent to a minimum load factor of 0. If we
specify that 0 is the default, this change will have no impact on
backward compatibility.
</p>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This seems to a useful extension, but is too late for 0x.

Move to Tentatively NAD Future.
</p></blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add two new rows, and change rehash's postcondition in the unordered
associative container requirements table in 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &mdash; Unordered associative container requirements
(in addition to container)</caption>

<tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><ins>
<tt>a.min_load_factor()</tt>
</ins></td>
<td><ins>
<tt>float</tt>
</ins></td>
<td><ins>
Returns a non-negative number that the container attempts to keep the
load factor greater than or equal to. The container automatically
decreases the number of buckets as necessary to keep the load factor
above this number.
</ins></td>
<td><ins>
constant
</ins></td>
</tr>

<tr>
<td><ins><tt>a.min_load_factor(z)</tt></ins></td>
<td><ins><tt>void</tt></ins></td>
<td><ins>Pre: <tt>z</tt> shall be non-negative. Changes the container's minimum
load factor, using <tt>z</tt> as a hint. [<i>Footnote:</i> the minimum
load factor should be significantly smaller than the maximum. 
If <tt>z</tt> is too large, the implementation may reduce it to a more sensible value.]
</ins></td>
<td><ins>
constant
</ins></td>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <ins><tt>a.bucket_count() &gt;= n</tt>, and <tt>a.size() &lt;= a.bucket_count()
* a.max_load_factor()</tt>. [<i>Footnote:</i> It is intentional that the
postcondition does not mention the minimum load factor.
This member function is primarily intended for cases where the user knows
that the container's size will increase soon, in which case the container's
load factor will temporarily fall below <tt>a.min_load_factor()</tt>.]</ins>
<del>
<tt>a.bucket_cout &gt; a.size() / a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</del>
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</table>
</blockquote>

<p>
Add a footnote to 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p12:
</p>

<blockquote>
<p>
The insert members shall not affect the validity of references to
container elements, but may invalidate all iterators to the container.
The erase members shall invalidate only iterators and references to the
erased elements.
</p>

<blockquote><p>
[A consequence of these requirements is that while insert may change the
number of buckets, erase may not. The number of buckets may be reduced
on calls to insert or rehash.]
</p></blockquote>
</blockquote>

<p>
Change paragraph 13:
</p>

<blockquote><p>
The insert members shall not affect the validity of iterators if
<del><tt>(N+n) &lt; z * B</tt></del> <ins><tt>zmin * B &lt;= (N+n) &lt;= zmax * B</tt></ins>,
where <tt>N</tt> is the number of elements in
the container prior to the insert operation, <tt>n</tt> is the number of
elements inserted, <tt>B</tt> is the container's bucket count,
<ins><tt>zmin</tt> is the container's minimum load factor,</ins>
and <tt>z<ins>max</ins></tt> is the container's maximum load factor.
</p></blockquote>

<p>
Add to the <tt>unordered_map</tt> class synopsis in section 26.5.4 <a href="https://timsong-cpp.github.io/cppwp/unord.map">[unord.map]</a>,
the <tt>unordered_multimap</tt> class synopsis
in 26.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap">[unord.multimap]</a>, the <tt>unordered_set</tt> class synopsis in
26.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a>, and the <tt>unordered_multiset</tt> class synopsis
in 26.5.7 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset">[unord.multiset]</a>:
</p>

<blockquote><pre><ins>
float min_load_factor() const;
void min_load_factor(float z);
</ins></pre></blockquote>

<p>
In 26.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a>, 26.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a>, 26.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a>, and
26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a>, change:
</p>

<blockquote><p>
... <tt>max_load_factor()</tt> returns 1.0 <ins>and
<tt>min_load_factor()</tt> returns 0</ins>.
</p></blockquote>





<hr>
<h3><a name="1201" href="1201">1201.</a> Do we always want to unwrap <tt>ref</tt>-wrappers in <tt>make_tuple</tt></h3>
<p><b>Section:</b> 23.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a>, 23.4 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.creation">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.creation">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Spotting a recent thread on the boost lists regarding collapsing
optional representations in <tt>optional&lt;optional&lt;T&gt;&gt;</tt> instances, I wonder if
we have some of the same issues with <tt>make_tuple</tt>, and now <tt>make_pair</tt>?
</p>

<p>
Essentially, if my generic code in my own library is handed a
<tt>reference_wrapper</tt> by a user, and my library in turn delegates some logic
to <tt>make_pair</tt> or <tt>make_tuple</tt>, then I am going to end up with a <tt>pair</tt>/<tt>tuple</tt>
holding a real reference rather than the intended reference wrapper.
</p>

<p>
There are two things as a library author I can do at this point:
</p>

<ol style="list-style-type:lower-roman">
<li>
document my library also has the same reference-wrapper behaviour as
<tt>std::make_tuple</tt>
</li>
<li>
roll my own <tt>make_tuple</tt> that does not unwrap rereferences, a lost
opportunity to re-use the standard library.
</li>
</ol>

<p>
(There may be some metaprogramming approaches my library can use to wrap
the <tt>make_tuple</tt> call, but all will be significantly more complex than
simply implementing a simplified <tt>make_tuple</tt>.)
</p>

<p>
Now I don't propose we lose this library facility, I think unwrapping
references will be the common behaviour.  However, we might want to
consider adding another overload that does nothing special with
<tt>ref</tt>-wrappers.  Note that we already have a second overload of 
<tt>make_tuple</tt> in the library, called <tt>tie</tt>.
</p>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest to change the currently proposed paragraph for
<tt>make_simple_pair</tt>
</p>

<blockquote><pre>
template&lt;typename... Types&gt;
  pair&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_pair(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<del><i>Type requirements:</i> <tt>sizeof...(Types) == 2</tt>.</del>
<ins><i>Remarks:</i> The program shall be ill-formed, if
<tt>sizeof...(Types) != 2</tt>.</ins>
</p>
<p>
...
</p>
</blockquote>
</blockquote>

<p>
or alternatively (but with a slightly different semantic):
</p>

<blockquote>
<blockquote><p>
<i>Remarks:</i> If <tt>sizeof...(Types) != 2</tt>, this function shall not
participate in overload resolution.
</p></blockquote>
</blockquote>

<p>
to follow a currently introduced style and because the library does
not have yet a specific "<i>Type requirements</i>" element. If such thing
would be considered as useful this should be done as a separate
issue. Given the increasing complexity of either of these wordings
it might be preferable to use the normal two-argument-declaration
style again in either of the following ways:
</p>

<ol style="list-style-type:upper-alpha">
<li>
<pre>template&lt;class T1, class T2&gt;
pair&lt;typename decay&lt;T1&gt;::type, typename decay&lt;T2&gt;::type&gt;
make_simple_pair(T1&amp;&amp; t1, T2&amp;&amp; t2);
</pre>
</li>
<li>
<pre>template&lt;class T1, class T2&gt;
pair&lt;V1, V2&gt; make_simple_pair(T1&amp;&amp; t1, T2&amp;&amp; t2);
</pre>
<blockquote><p>
Let <tt>V1</tt> be <tt>typename decay&lt;T1&gt;::type</tt> and <tt>V2</tt> be
<tt>typename decay&lt;T2&gt;::type</tt>.
</p></blockquote>
</li>
</ol>

</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Mark as Tentatively NAD Future.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following function to 23.4 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> and signature in
appropriate synopses:
</p>

<blockquote><pre>
template&lt;typename... Types&gt;
  pair&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_pair(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<i>Type requirements:</i> <tt>sizeof...(Types) == 2</tt>.
</p>
<p>
<i>Returns:</i> <tt>pair&lt;typename decay&lt;Types&gt;::type...&gt;(std::forward&lt;Types&gt;(t)...)</tt>.
</p>
</blockquote>
</blockquote>

<p><i>[
Draughting note: I chose a variadic representation similar to <tt>make_tuple</tt>
rather than naming both types as it is easier to read through the
clutter of metaprogramming this way.  Given there are exactly two
elements, the committee may prefer to draught with two explicit template
type parameters instead
]</i></p>


<p>
Add the following function to 23.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a> and
signature in appropriate synopses:
</p>

<blockquote><pre>
template&lt;typename... Types&gt;
  tuple&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_tuple(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>tuple&lt;typename decay&lt;Types&gt;::type...&gt;(std::forward&lt;Types&gt;(t)...)</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1203" href="1203">1203.</a> More useful rvalue stream insertion</h3>
<p><b>Section:</b> 30.7.5.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.rvalue">[ostream.rvalue]</a>, 30.7.4.5 <a href="https://timsong-cpp.github.io/cppwp/istream.rvalue">[istream.rvalue]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-06 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.rvalue">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ostream.rvalue">[ostream.rvalue]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.7.5.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.rvalue">[ostream.rvalue]</a> was created to preserve the ability to insert
into (and extract from 30.7.4.5 <a href="https://timsong-cpp.github.io/cppwp/istream.rvalue">[istream.rvalue]</a>) rvalue streams:
</p>

<blockquote><pre>
template &lt;class charT, class traits, class T&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>os &lt;&lt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt>os</tt>
</p>
</blockquote>
</blockquote>

<p>
This is good as it allows code that wants to (for example) open, write to, and
close an <tt>ofstream</tt> all in one statement:
</p>

<blockquote><pre>
std::ofstream("log file") &lt;&lt; "Some message\n";
</pre></blockquote>

<p>
However, I think we can easily make this "rvalue stream helper" even easier to
use.  Consider trying to quickly create a formatted string.  With the current
spec you have to write:
</p>

<blockquote><pre>
std::string s = static_cast&lt;std::ostringstream&amp;&gt;(std::ostringstream() &lt;&lt; "i = " &lt;&lt; i).str();
</pre></blockquote>

<p>
This will store "<tt>i = 10</tt>" (for example) in the string <tt>s</tt>.  Note
the need to cast the stream back to <tt>ostringstream&amp;</tt> prior to using
the member <tt>.str()</tt>.  This is necessary because the inserter has cast
the <tt>ostringstream</tt> down to a more generic <tt>ostream</tt> during the
insertion process.
</p>

<p>
I believe we can re-specify the rvalue-inserter so that this cast is unnecessary.
Thus our customer now has to only type:
</p>

<blockquote><pre>
std::string s = (std::ostringstream() &lt;&lt; "i = " &lt;&lt; i).str();
</pre></blockquote>

<p>
This is accomplished by having the rvalue stream inserter return an rvalue of
the same type, instead of casting it down to the base class.  This is done by
making the stream generic, and constraining it to be an rvalue of a type derived
from <tt>ios_base</tt>.
</p>

<p>
The same argument and solution also applies to the inserter.  This code has been
implemented and tested.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  No concensus for change.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.7.4.5 <a href="https://timsong-cpp.github.io/cppwp/istream.rvalue">[istream.rvalue]</a>:
</p>

<blockquote><pre>
template &lt;class <del>charT, class traits</del> <ins>Istream</ins>, class T&gt;
  <del>basic_istream&lt;charT, traits&gt;&amp;</del> <ins>Istream&amp;&amp;</ins>
  operator&gt;&gt;(<del>basic_istream&lt;charT, traits&gt;</del> <ins>Istream</ins>&amp;&amp; is, T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>is &gt;&gt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt><ins>std::move(</ins>is<ins>)</ins></tt>
</p>
<p><ins>
3 <i>Remarks:</i> This signature shall participate in overload resolution if
and only if <tt>Istream</tt> is not an lvalue reference type and is derived from
<tt>ios_base</tt>.
</ins></p>
</blockquote>
</blockquote>

<p>
Change 30.7.5.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.rvalue">[ostream.rvalue]</a>:
</p>

<blockquote><pre>
template &lt;class <del>charT, class traits</del> <ins>Ostream</ins>, class T&gt;
  <del>basic_ostream&lt;charT, traits&gt;&amp;</del> <ins>Ostream&amp;&amp;</ins>
  operator&lt;&lt;(<del>basic_ostream&lt;charT, traits&gt;</del> <ins>Ostream</ins>&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>os &lt;&lt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt><ins>std::move(</ins>os<ins>)</ins></tt>
</p>
<p><ins>
3 <i>Remarks:</i> This signature shall participate in overload resolution if
and only if <tt>Ostream</tt> is not an lvalue reference type and is derived from
<tt>ios_base</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1213" href="1213">1213.</a> Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 27.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="208">208</a> (including further updates by <a href="278">278</a>). In
27.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote><p>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</p></blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote><p>
An iterator is valid if it is dereferenceable or past-the-end.
</p></blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was incomplete, because by restricting feasible expressions of singular
iterators to destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 23.10.10 <a href="https://timsong-cpp.github.io/cppwp/specialized.algorithms">[specialized.algorithms]</a>/1 says:
</p>

<blockquote><p>
In all of the following algorithms, the formal template parameter <tt>ForwardIterator</tt> 
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</p></blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In 99 [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote><p>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &mdash;<i>end note</i>]
</p></blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote><p>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</p></blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
Doesn't need to be resolved for Ox
</p>


<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p>
Consider to await the paper.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1217" href="1217">1217.</a> Quaternion support</h3>
<p><b>Section:</b> 29.5 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Ted Shaneyfelt <b>Opened:</b> 2009-09-26 <b>Last modified:</b> 2017-03-03 18:03:12 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Concerning mathematically proper operation of the type:
</p>

<blockquote><pre>
complex&lt;complex&lt;T&gt; &gt;
</pre></blockquote>

<p>
Generally accepted mathematical semantics of such a construct correspond
to quaternions through Cayly-Dickson construct
</p>

<blockquote><pre>
(w+xi) + (y+zi) j
</pre></blockquote>

<p>
The proper implementation seems straightforward by adding a few
declarations like those below. I have included operator definition for
combining real scalars and complex types, as well, which seems
appropriate, as algebra of complex numbers allows mixing complex and
real numbers with operators. It also allows for constructs such as
<tt>complex&lt;double&gt; i=(0,1),  x = 12.34 + 5*i;</tt>
</p>

<p>
Quaternions are often used in areas such as computer graphics, where,
for example, they avoid the problem of Gimbal lock when rotating objects
in 3D space, and can be more efficient than matrix multiplications,
although I am applying them to a different field.
</p>

<pre>
/////////////////////////ALLOW OPERATORS TO COMBINE REAL SCALARS AND COMPLEX VALUES /////////////////////////
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()+a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a+x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()-a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a-x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()*a, x.imag()*a);
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a*x.real(), a*x.imag());
    return result;
}

/////////////////////////PROPERLY IMPLEMENT QUATERNION SEMANTICS/////////////////////////
template&lt;typename T&gt; double normSq(const complex&lt;complex&lt;T&gt; &gt;q) {
    return q.real().real()*q.real().real()
         + q.real().imag()*q.real().imag()
         + q.imag().real()*q.imag().real()
         + q.imag().imag()*q.imag().imag();
}
template&lt;typename T&gt; double norm(const complex&lt;complex&lt;T&gt; &gt;q) {
    return sqrt(normSq(q));
}
/////// Cayley-Dickson Construction
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; conj(const complex&lt;complex&lt;T&gt; &gt; x) {
    complex&lt;complex&lt;T&gt; &gt; result(conj(x.real()),-x.imag());
    return result;
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator*(const complex&lt;complex&lt;T&gt; &gt; ab,const complex&lt;complex&lt;T&gt; &gt; cd) {
    complex&lt;T&gt; re(ab.real()*cd.real()-conj(cd.imag())*ab.imag());
    complex&lt;T&gt; im(cd.imag()*ab.real()+ab.imag()*conj(cd.real()));
    complex&lt;complex&lt;double&gt; &gt; q(re,im);
    return q;
}
//// Quaternion division
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; q,const S a) {
    return q * (1/a);
}
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const S a,const complex&lt;complex&lt;T&gt; &gt; q) {
    return a*conj(q)/normSq(q);
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; n, const complex&lt;complex&lt;T&gt; &gt; d) {
    return n * (conj(d)/normSq(d));
}
</pre>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future. There is no consensus or time to move this into C++0X.
</p></blockquote>

<p><i>[2017-03-03, Kona]</i></p>

<p>
SG6 suggests this issue is a new feature, not a problem with the existing
standard, and should therefore be closed NAD. However, SG6 invites papers that bring
the proposal up to date with the current standard.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1235" href="1235">1235.</a> Issue with C++0x random number proposal</h3>
<p><b>Section:</b> 99 [rand.concept.dist] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Matthias Troyer <b>Opened:</b> 2009-10-12 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There exist optimized, vectorized vendor libraries for the creation of
random number generators, such as Intel's MKL [1] and AMD's ACML [2]. In
timing tests we have seen a performance gain of a factor of up to 80
(eighty) compared to a pure C++ implementation (in Boost.Random) when
using these generator to generate a sequence of normally distributed
random numbers. In codes dominated by the generation of random numbers
(we have application codes where random number generation is more than
50% of the CPU time) this factor 80 is very significant.
</p>

<p>
To make use of these vectorized generators, we use a C++ class modeling
the <tt>RandomNumberEngine</tt> concept and forwarding the generation of random
numbers to those optimized generators. For example:
</p>

<blockquote><pre>
namespace mkl {
 class mt19937 {.... };
}
</pre></blockquote>

<p>
For the generation of random variates we also want to dispatch to
optimized vectorized functions in the MKL or ACML libraries. See this
example:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::normal_distribution&lt;double&gt; dist;

double n = dist(eng);
</pre></blockquote>

<p>
Since the variate generation is done through the <tt>operator()</tt> of the
distribution there is no customization point to dispatch to Intel's or
AMD's optimized functions to generate normally distributed numbers based
on the <tt>mt19937</tt> generator. Hence, the performance gain of 80 cannot be
achieved.
</p>

<p>
Contrast this with TR1:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::tr1::normal_distribution&lt;double&gt; dist;
std::tr1::variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; rng(eng,dist);
double n = rng();
</pre></blockquote>

<p>
This - admittedly much uglier from an aestethic point of view - design
allowed optimization by specializing the <tt>variate_generator</tt> template for
<tt>mkl::mt19937</tt>:
</p>

<blockquote><pre>
namespace std { namespace tr1 {

template&lt;&gt;
class variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; { .... };

} }
</pre></blockquote>

<p>
A similar customization point is missing in the C++0x design and
prevents the optimized vectorized version to be used.
</p>

<p>
Suggested resolution:
</p>

<p>
Add a customization point to the distribution concept. Instead of the
<tt>variate_generator</tt> template this can be done through a call to a
free function <tt>generate_variate</tt> found by ADL instead of
<tt>operator()</tt> of the distribution:
</p>

<blockquote><pre>
template &lt;RandomNumberDistribution, class RandomNumberEngine&gt;
typename RandomNumberDistribution ::result_type
generate_variate(RandomNumberDistribution const&amp; dist, RandomNumberEngine&amp; eng);
</pre></blockquote>

<p>
This function can be overloaded for optimized enginges like
<tt>mkl::mt19937</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  No time to add this feature for C++0X.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1238" href="1238">1238.</a> defining algorithms taking iterator for range</h3>
<p><b>Section:</b> 28 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-15 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library has many algorithms that take a source range represented by
a pair of iterators, and the start of some second sequence given by a
single iterator.  Internally, these algorithms will produce undefined
behaviour if the second 'range' is not as large as the input range, but
none of the algorithms spell this out in Requires clauses, and there is
no catch-all wording to cover this in clause 17 or the front matter of
25.
</p>

<p>
There was an attempt to provide such wording in paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a>
but this
seems incidental to the focus of the paper, and getting the wording of
this issue right seems substantially more difficult than the simple
approach taken in that paper.  Such wording will be removed from an
updated paper, and hopefully tracked via the LWG issues list instead.
</p>

<p>
It seems there are several classes of problems here and finding wording
to solve all in one paragraph could be too much.  I suspect we need
several overlapping requirements that should cover the desired range of
behaviours.
</p>

<p>
Motivating examples:
</p>

<p>
A good initial example is the <tt>swap_ranges</tt> algorithm.  Here there is a
clear requirement that <tt>first2</tt> refers to the start of a valid range at
least as long as the range <tt>[first1, last1)</tt>.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a> tries to solve this
by positing a hypothetical <tt>last2</tt> iterator that is implied by the
signature, and requires <tt>distance(first2,last2) &lt; distance(first1,last1)</tt>.
 This mostly works, although I am uncomfortable assuming that <tt>last2</tt> is
clearly defined and well known without any description of how to obtain
it (and I have no idea how to write that).
</p>

<p>
A second motivating example might be the <tt>copy</tt> algorithm.  Specifically,
let us image a call like:
</p>

<blockquote><pre>
copy(istream_iterator&lt;int&gt;(is),istream_iterator(),ostream_iterator&lt;int&gt;(os));
</pre></blockquote>

<p>
In this case, our input iterators are literally simple <tt>InputIterators</tt>,
and the destination is a simple <tt>OutputIterator</tt>.  In neither case am I
happy referring to <tt>std::distance</tt>, in fact it is not possible for the
<tt>ostream_iterator</tt> at all as it does not meet the requirements.  However,
any wording we provide must cover both cases.  Perhaps we might deduce
<tt>last2 == ostream_iterator&lt;int&gt;{}</tt>, but that might not always be valid for
user-defined iterator types.  I can well imagine an 'infinite range'
that writes to <tt>/dev/null</tt> and has no meaningful <tt>last2</tt>.
</p>

<p>
The motivating example in <a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf"
>n2944</a> is <tt>std::equal</tt>, and that seems to fall somewhere between the
two.
</p>

<p>
Outlying examples might be <tt>partition_copy</tt> that takes two output
iterators, and the <tt>_n</tt> algorithms where a range is specified by a
specific number of iterations, rather than traditional iterator pair. 
We should also <em>not</em> accidentally apply inappropriate constraints to
<tt>std::rotate</tt> which takes a third iterator that is not intended to be a
separate range at all.
</p>

<p>
I suspect we want some wording similar to:
</p>

<blockquote><p>
For algorithms that operate on ranges where the end iterator of the
second range is not specified, the second range shall contain at least
as many elements as the first.
</p></blockquote>

<p>
I don't think this quite captures the intent yet though.  I am not sure
if 'range' is the right term here rather than sequence.  More awkwardly,
I am not convinced we can describe an Output sequence such as produce by
an <tt>ostream_iterator</tt> as "containing elements", at least not as a
precondition to the call before they have been written.
</p>

<p>
Another idea was to describe require that the trailing iterator support
at least distance(input range) applications of <tt>operator++</tt> and may be
written through the same number of times if a mutable/output iterator.
</p>

<p>
We might also consider handling the case of an output range vs. an input
range in separate paragraphs, if that simplifies how we describe some of
these constraints.
</p>

<p><i>[
2009-11-03 Howard adds:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1242" href="1242">1242.</a> Enable SCARY iterators</h3>
<p><b>Section:</b> 26 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2009-10-21 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2980.pdf">N2980</a>.
</p>

<p><i>[
2009-10 Santa Cruz
]</i></p>


<blockquote><p>
The paper was lengthy discussed but considerable concern remained to add this feature to C++0x. 
Strong consensus was found to consider it for C++1x, though.
</p></blockquote>


<p><b>Proposed resolution:</b></p><p>
The LWG does not wish to make a change at this time. 
</p>




<hr>
<h3><a name="1282" href="1282">1282.</a> A proposal to add <tt>std::split</tt> algorithm</h3>
<p><b>Section:</b> 28 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Igor Semenov <b>Opened:</b> 2009-12-07 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<ol style="list-style-type:upper-roman">

<li>
<p>
Motivation and Scope
</p>
<p>
Splitting strings into parts by some set of delimiters is an often task, but
there is no simple and generalized solution in C++ Standard. Usually C++
developers use <tt>std::basic_stringstream&lt;&gt;</tt> to split string into
parts, but there are several inconvenient restrictions:
</p>

<ul>
<li>
we cannot explicitly assign the set of delimiters;
</li>
<li>
this approach is suitable only for strings, but not for other types of
containers;
</li>
<li>
we have (possible) performance leak due to string instantiation.
</li>
</ul>
</li>

<li>
<p>
Impact on the Standard
</p>
<p>
This algorithm doesn't interfere with any of current standard algorithms.
</p>
</li>

<li>
<p>
Design Decisions
</p>
<p>
This algorithm is implemented in terms of input/output iterators. Also, there is
one additional wrapper for <tt>const CharType *</tt> specified delimiters.
</p>
</li>

<li>
<p>
Example implementation
</p>
<pre>
template&lt; class It, class DelimIt, class OutIt &gt;
void split( It begin, It end, DelimIt d_begin, DelimIt d_end, OutIt out )
{
   while ( begin != end )
   {
       It it = std::find_first_of( begin, end, d_begin, d_end );
       *out++ = std::make_pair( begin, it );
       begin = std::find_first_of( it, end, d_begin, d_end,
           std::not2( std::equal_to&lt; typename It::value_type &gt;() ) );
   }
}

template&lt; class It, class CharType, class OutIt &gt;
void split( It begin, It end, const CharType * delim, OutIt out )
{
   split( begin, end, delim, delim + std::strlen( delim ), out );
}
</pre>
</li>

<li>
<p>
Usage
</p>
<pre>
std::string ss( "word1 word2 word3" );
std::vector&lt; std::pair&lt; std::string::const_iterator, std::string::const_iterator &gt; &gt; v;
split( ss.begin(), ss.end(), " ", std::back_inserter( v ) );

for ( int i = 0; i &lt; v.size(); ++i )
{
   std::cout &lt;&lt; std::string( v[ i ].first, v[ i ].second ) &lt;&lt; std::endl;
}
// word1
// word2
// word3
</pre>
</li>

</ol>

<p><i>[
2010-01-22 Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
The LWG is not considering completely new features for standardization at this
time.  We would like to revisit this good suggestion for a future TR and/or
standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 28.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a>:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );

template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre></blockquote>

<p>
Add a new section [alg.split]:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> splits the range <tt>[first, last)</tt> into parts, using any
element of <tt>[delimiter_first, delimiter_last)</tt> as a delimiter. Results
are pushed to output iterator in the form of <tt>std::pair&lt;ForwardIterator1,
ForwardIterator1&gt;</tt>. Each of these pairs specifies a maximal subrange of
<tt>[first, last)</tt> which does not contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

<pre>
template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> split the range <tt>[first, last)</tt> into parts, using any
element of <tt>delimiters</tt> (interpreted as zero-terminated string) as a
delimiter. Results are pushed to output iterator in the form of
<tt>std::pair&lt;ForwardIterator1, ForwardIterator1&gt;</tt>. Each of these
pairs specifies a maximal subrange of <tt>[first, last)</tt> which does not
contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="1289" href="1289">1289.</a> Generic casting requirements for smart pointers</h3>
<p><b>Section:</b> 23.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Ion Gazta&ntilde;aga <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 40 &mdash; Allocator requirements,
the following expression is required for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>
<tr>
<td><tt>static_cast&lt;X::pointer&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static_cast&lt;X::pointer&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>
</table>
</blockquote>

<p>
To achieve this expression, a smart pointer writer must introduce an explicit
conversion operator from <tt>smart_ptr&lt;void&gt;</tt> to
<tt>smart_ptr&lt;T&gt;</tt> so that
<tt>static_cast&lt;pointer&gt;(void_ptr)</tt> is a valid expression.
Unfortunately this explicit conversion weakens the safety of a smart pointer
since the following expression (invalid for raw pointers) would become valid:
</p>

<blockquote><pre>
smart_ptr&lt;void&gt; smart_v = ...;
smart_ptr&lt;T&gt; smart_t(smart_v);
</pre></blockquote>

<p>
On the other hand, <tt>shared_ptr</tt> also defines its own casting functions in
23.11.2.2.9 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cast">[util.smartptr.shared.cast]</a>, and although it's unlikely that a
programmer will use <tt>shared_ptr</tt> as <tt>allocator::pointer</tt>, having
two different ways to do the same cast operation does not seem reasonable. A
possible solution would be to replace <tt>static_cast&lt;X::pointer&gt;(w)</tt>
expression with a user customizable (via ADL)
<tt>static_pointer_cast&lt;value_type&gt;(w)</tt>, and establish the
<tt>xxx_pointer_cast</tt> functions introduced by <tt>shared_ptr</tt> as the
recommended generic casting utilities of the standard.
</p>

<p>
Unfortunately, we've experienced problems in Boost when trying to establish
<tt>xxx_pointer_cast</tt> as customization points for generic libraries (<a
href="http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html"
>http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html</a>)
because these casting functions are called with explicit template parameters and
the standard says in 17.8.1 <a href="https://timsong-cpp.github.io/cppwp/temp.arg.explicit">[temp.arg.explicit]</a> p.8 "Explicit template
argument specification":
</p>

<blockquote><p>
8 ...But when a function template with explicit template arguments is used, the
call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call. If no such name is
visible, the call is not syntactically well-formed and argument-dependent lookup
does not apply.
</p></blockquote>

<p>
So we can do this:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_swap(BasePtr p)
{
  //ADL customization point
  swap(p, p);
  //...
}
</pre></blockquote>

<p>
but not the following:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;
  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);
}
</pre></blockquote>

<p>
The solution to make <tt>static_pointer_cast</tt> a customization point is to
add a generic declaration (no definition) of <tt>static_pointer_cast</tt> in a
namespace (like <tt>std</tt>) and apply "<tt>using
std::static_pointer_cast</tt>" declaration to activate ADL:
</p>

<blockquote><pre>
namespace std{

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

}

template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;

  //ADL applies because static_pointer_cast is made
  //  visible according to [temp.arg.explicit]/8
  using std::static_pointer_cast;

  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);

  //...
}
</pre></blockquote>

<p>
A complete solution will need also the definition of
<tt>static_pointer_cast</tt> for raw pointers, and this definition has been
present in Boost (<a
href="http://www.boost.org/boost/pointer_cast.hpp">http://www.boost.org/boost/
pointer_cast.hpp</a>) for years.
</p>

<p><i>[
2010-03-26 Daniel made editorial adjustments to the proposed wording.
]</i></p>


<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>

<blockquote><p>
This is a new feature rather than a defect. 
It can be added later: "this is such a hairy area that people will put up with changes"
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to section 23.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> Utility components, Header
<tt>&lt;utility&gt;</tt> synopsis:
</p>

<blockquote><pre>
// 20.3.X, generic pointer cast functions

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;

//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre></blockquote>

<p>
Add to section 23.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> Utility components, a new subclause
20.3.X Pointer cast utilities [pointer.cast]:
</p>

<blockquote>
<p>
20.3.X Pointer cast utilities [pointer.cast]
</p>

<p>
1 The library defines generic pointer casting function templates so that template code
can explicitly make these names visible and activate argument-dependent lookup
for pointer cast calls.
</p>

<pre>
//Generic declarations
template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;
</pre>

<p>
2 The library also defines overloads of these functions for raw pointers.
</p>

<pre>
//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>static_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>dynamic_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>const_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
#include &lt;utility&gt; //static_pointer_cast
#include &lt;memory&gt;  //pointer_traits

class Base{};
class Derived : public Base{};

template&lt;class BasePtr&gt;
void generic_pointer_code(BasePtr b)
{
   typedef std::pointer_traits&lt;BasePtr&gt;::template
      rebind&lt;Derived&gt; DerivedPtr;

   using std::static_pointer_cast;
   //ADL applies now that static_pointer_cast is visible
   DerivedPtr d = static_pointer_cast&lt;Derived&gt;(b);
}
</pre></blockquote>

<p>
&mdash; <i>end example</i>]
</p>

</blockquote>

<p>
Replace in section 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> Table 40 &mdash; Allocator
requirements, the following table entries for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(w)</tt></td>
<td><tt>X::const_pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(z) == q</tt></td>
<td>&nbsp;</td>
</tr>

</table>
</blockquote>






<hr>
<h3><a name="1317" href="1317">1317.</a> make_hash</h3>
<p><b>Section:</b> 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Nicolai M. Josuttis <b>Opened:</b> 2010-02-10 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the library lacks a convenient way to provide a hash function that
can be used with the provided unordered containers to allow the usage of non
trivial element types.
</p>

<p>
While we can easily declare an
</p>

<blockquote><pre>
std::unordered_set&lt;int&gt;
</pre></blockquote>

<p>
or
</p>

<blockquote><pre>
std::unordered_set&lt;std::string&gt;
</pre></blockquote>

<p>
we have no easy way to declare an <tt>unordered_set</tt> for a user defined
type. IMO, this is a big obstacle to use unordered containers in practice. Note
that in Java, the wide usage of <tt>HashMap</tt> is based on the fact that there
is always a default hash function provided.
</p>

<p>
Of course, a default hash function implies the risk to provide poor hash
functions. But often even poor hash functions are good enough.
</p>

<p>
While I really would like to see a default hash function, I don't propose it
here because this would probably introduce a discussion that's too big for this
state of C++0x.
</p>

<p>
However, I strongly suggest at least to provide a convenience variadic template
function <tt>make_hash&lt;&gt;()</tt> to allow an easy definition of a (possibly
poor) hash function.
</p>

<p>
As a consequence for a user-defined type such as
</p>

<blockquote><pre>
class Customer {
   friend class CustomerHash;
   private:
     string firstname;
     string lastname;
     long   no;
   ...
 };
</pre></blockquote>

<p>
would allow to specify:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return make_hash(c.firstname,c.lastname,c.no);
    }
};
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return std::hash&lt;std::string&gt;()(c.firstname) +
              std::hash&lt;std::string&gt;()(c.lastname) +
              std::hash&lt;long&gt;()(c.no);
    }
};
</pre></blockquote>

<p>
Note that, in principle, we can either specify that
</p>

<blockquote><p>
<tt>make_hash</tt> returns the sum of a call of
<tt>std::hash&lt;T&gt;()(x)</tt> for each argument <tt>x</tt> of type
<tt>T</tt>
</p></blockquote>

<p>
or we can specify that
</p>

<blockquote><p>
<tt>make_hash</tt> provides a hash value for each argument, for which a
<tt>std::hash()</tt> function is provided
</p></blockquote>

<p>
with the possible note that the hash value may be poor or only a good hash value
if the ranges of all passed arguments is equally distributed.
</p>

<p>
For my convenience, I propose wording that describes
the concrete implementation.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
There is no consensus to make this change at this time.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Function objects 23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>
in paragraph 2 at the end of the Header <tt>&lt;functional&gt;</tt> synopsis
insert:
</p>

<blockquote><pre>
// convenience functions
template &lt;class T&gt;
  size_t make_hash (const T&amp;);
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp;, const Types&amp;...);
</pre></blockquote>

<p>
In Class template hash 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>
add:
</p>

<blockquote>
<p>
<b>20.7.16.1 Hash creation functions [hash.creation]</b>
</p>

<pre>
template &lt;class T&gt;
  size_t make_hash (const T&amp; val);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val);</tt>
</p></blockquote>

<pre>
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp; val, const Types&amp;... args);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val) + std::make_hash(args...)</tt>
</p></blockquote>

</blockquote>






<hr>
<h3><a name="1320" href="1320">1320.</a> Header for <tt>iter_swap</tt></h3>
<p><b>Section:</b> 27.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>iter_swap</tt> function template appears in the
<tt>&lt;algorithm&gt;</tt> header, yet its main use is in building further
algorithms, not calling existing ones. The main clients are implementers of data
structures and their iterators, so it seems most appropriate to place the
template in the <tt>&lt;iterator&gt;</tt> header instead.
</p>

<p>
Note that this is not an issue for implementers of the standard library, as they
rarely use the standard headers directly, designing a more fine-grained set of
headers for their own internal use.  This option is not available to customers
of the standard library.
</p>

<p>
Note that we cannot remove <tt>iter_swap</tt> from <tt>&lt;algorithm&gt;</tt>
without breaking code, but there is no reason we cannot offer the same
declaration via two standard headers.  Alternatively, require
<tt>&lt;algorithm&gt;</tt> to <tt>#include &lt;iterator&gt;</tt>, but
introducing the dependency on the iterator adaptors seems un-necessary.
</p>

<p><i>[
]</i></p>


<p>
Discussed possibly moving to <tt>&lt;utility&gt;</tt> but don't like that. Some not seeing this 
as a defect, and want to keep it in <tt>&lt;algorithm&gt;</tt>. No one seems to feel strongly 
about moving to <tt>&lt;iterator&gt;</tt>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the declaration of <tt>iter_swap</tt> to the <tt>&lt;iterator&gt;</tt>
header synopsis (27.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>), with a note that it is
documented in clause 28 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.
</p>

<blockquote><pre>
...
template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);

<ins><i>// documented in 28 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a></i>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</ins>
</pre></blockquote>






<hr>
<h3><a name="1396" href="1396">1396.</a> <tt>regex</tt> should support allocators</h3>
<p><b>Section:</b> 31.8 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="1451">1451</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>
<p>
<tt>std::basic_regex</tt> should have an allocator for all the
reasons that a <tt>std::string</tt> does. For example, I can use
<tt>boost::interprocess</tt> to put a <tt>string</tt> or <tt>vector</tt>
in shared memory, but not a <tt>regex</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Add allocators to regexes
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote><p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">n3171</a> 
would solve this issue.
</p></blockquote>

<p><i>[2011-03-22 Madrid]</i></p>


<p>Close 1396 as NAD Future.</p>


<p><b>Rationale:</b></p><p>No consensus for a change at this time</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1406" href="1406">1406.</a> Support hashing smart-pointers based on <i>owner</i></h3>
<p><b>Section:</b> 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-5</b></p>
<p>
Hash support based on ownership sharing should be
supplied for <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
For two <tt>shared_ptr</tt> objects <tt>p</tt> and <tt>q</tt>, two distinct
equivalence relations can be defined. One is based on
equivalence of pointer values, which is derived from the
expression <tt>p.get() == q.get()</tt> (hereafter called <i>address based
equivalence relation</i>), the other is based on
equivalence of ownership sharing, which is derived from
the expression <tt>!p.owner_before(q) &amp;&amp; !q.owner_before(p)</tt>
(hereafter called <i>ownership-based equivalence relation</i>).
These two equivalence relations are independent in
general. For example, a <tt>shared_ptr</tt> object created by the
constructor of the signature <tt>shared_ptr(shared_ptr&lt;U>
const &amp;, T *)</tt> could reveal a difference between these two
relations. Therefore, hash support based on each
equivalence relation should be supplied for <tt>shared_ptr</tt>.
However, while the standard library provides the hash
support for address-based one (20.9.11.6 paragraph 2), it
lacks the hash support for ownership-based one. In
addition, associative containers work well in combination
with the <tt>shared_ptr</tt>'s ownership-based comparison but
unordered associative containers don't. This is
inconsistent.
</p>
<p>
For the case of <tt>weak_ptr</tt>, hash support for the ownership based
equivalence relation can be safely defined on
<tt>weak_ptr</tt>s, and even on expired ones. The absence of
hash support for the ownership-based equivalence
relation is fatal, especially for expired <tt>weak_ptr</tt>s. And the
absence of such hash support precludes some quite
effective use-cases, e.g. erasing the <tt>unordered_map</tt> entry
of an expired <tt>weak_ptr</tt> key from a customized deleter
supplied to <tt>shared_ptr</tt>s.
</p>
<p>
Hash support for the ownership-based equivalence
relation cannot be provided by any user-defined manner
because information about ownership sharing is not
available to users at all. Therefore, the only way to provide
ownership-based hash support is to offer it intrusively by
the standard library.
</p>
<p>
As far as we know, such hash support is implementable.
Typical implementation of such hash function could return
the hash value of the pointer of the counter object that is
internally managed by <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
</p>

<p><i>[2010 Rapperswil:]</i></p>

<blockquote>
<p>No consensus to make this change at this time.</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add the following non-static member functions to
<tt>shared_ptr</tt> and <tt>weak_ptr</tt> class template;
</p>
<p>
Update [util.smartptr.shared], 20.9.11.2 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class shared_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
Update [util.smartptr.weak], 20.9.11.3 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class weak_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
These functions satisfy the following
requirements. Let <tt>p</tt> and <tt>q</tt> be objects of either
<tt>shared_ptr</tt> or <tt>weak_ptr</tt>, <tt>H</tt> be a hypothetical
function object type that satisfies the hash
requirements ([hash.requirements], 20.2.4) and <tt>h</tt> be an object of the
type <tt>H</tt>. The expression <tt>p.owner_hash()</tt> behaves
as if it were equivalent to the expression <tt>h(p)</tt>. In
addition, <tt>h(p) == h(q)</tt> must become <tt>true</tt> if <tt>p</tt> and
<tt>q</tt> share ownership.
</p>





<hr>
<h3><a name="1422" href="1422">1422.</a> <tt>vector&lt;bool&gt;</tt> iterators are not random access</h3>
<p><b>Section:</b> 26.3.12 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.bool">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-118</b></p>
<p>
<tt>vector&lt;bool&gt;</tt> iterators are not random access iterators
because their reference type is a special class, and not
<tt>bool &amp;</tt>. All standard libary operations taking iterators
should treat this iterator as if it was a random access iterator, rather
than a simple input iterator.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Either revise the iterator requirements to support proxy iterators
(restoring functionality that was lost when the Concept facility was
removed) or add an extra paragraph to the <tt>vector&lt;bool&gt;</tt>
specification requiring the library to treat <tt>vector&lt;bool&gt;</tt>
iterators as-if they were random access iterators, despite having the wrong
reference type.
</p>

<p><i>[
Rapperswil Review
]</i></p>

<p>
The consensus at Rapperswil is that it is too late for full support for
proxy iterators, but requiring the library to respect <tt>vector&lt;bool&gt;</tt>
iterators as-if they were random access would be preferable to flagging
this container as deliberately incompatible with standard library algorithms.
</p>
<p>
Alisdair to write the note, which may become normative <i>Remark</i> depending
on the preferences of the project editor.
</p>

<p><i>[
Post-Rapperswil Alisdair provides wording
]</i></p>

<p>
Initial wording is supplied, deliberately using <i>Note</i> in preference to
<i>Remark</i> although the author notes his preference for <i>Remark</i>.  The
issue of whether <tt>iterator_traits&lt;vector&lt;bool&gt;&gt;::iterator_category</tt>
is permitted to report <tt>random_access_iterator_tag</tt> or must report 
<tt>input_iterator_tag</tt> is not addressed.
</p>

<p><i>[
Old Proposed Resolution:
]</i></p>

<blockquote>
<p>
Insert a new paragraph into 26.3.12 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> between p4 and p5:
</p>
<blockquote><p>
[<i>Note</i> All functions in the library that take a pair of iterators to
denote a range shall treat <tt>vector&lt;bool&gt;</tt> iterators as-if they were
random access iterators, even though the <tt>reference</tt> type is not a
true reference.<i>-- end note</i>]
</p></blockquote>
</blockquote>

<p><i>[
2010-11 Batavia:
]</i></p>

<blockquote><p>
Closed as NAD Future, because the current iterator categories cannot correctly describe
<tt>vector&lt;bool&gt;::iterator</tt>. But saying that they are Random Access Iterators
is also incorrect, because it is not too hard to create a corresponding test that fails.
We should deal with the more general proxy iterator problem in the future, and see no
benefit to take a partial workaround specific to <tt>vector&lt;bool&gt;</tt> now.
</p></blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
No consensus to make this change at this time.
</p>





<hr>
<h3><a name="1459" href="1459">1459.</a> Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="1458">1458</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-21, GB-131</b></p>
<p>
32.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8 states:
</p>
<blockquote><p>
An atomic store shall only store a value that has
been computed from constants and program input values
by a finite sequence of program evaluations, such
that each evaluation observes the values of variables
as computed by the last prior assignment in the
sequence.
</p></blockquote>
<p>
... but 4.6 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> p.13 states:
</p>
<blockquote><p>
If A is not sequenced before B and B is not
sequenced before A, then A and B are unsequenced.
[ <em>Note</em>: The execution of unsequenced
evaluations can overlap. &mdash; <em>end note</em> ]
</p></blockquote>
<p>
Overlapping executions can make it impossible to
construct the sequence described in 32.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8. We are not
sure of the intention here and do not offer a suggestion for
change, but note that 32.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8 is the condition that prevents
out-of-thin-air reads.
</p>
<p>
For an example, suppose we have a function invocation
f(e1,e2). The evaluations of e1 and e2 can overlap.
Suppose that the evaluation of e1 writes y and reads x
whereas the evaluation of e2 reads y and writes x, with
reads-from edges as below (all this is within a single
thread).
</p>
<pre>
 e1           e2
Wrlx y--   --Wrlx x
      rf\ /rf
         X
        / \
Rrlx x&lt;-   -&gt;Rrlx y
</pre>
<p>
This seems like it should be allowed, but there seems to
be no way to produce a sequence of evaluations with the
property above.
</p>
<p>
In more detail, here the two evaluations, e1 and e2, are
being executed as the arguments of a function and are
consequently not sequenced-before each other. In
practice we'd expect that they could overlap (as allowed
by 4.6 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> p.13), with the two writes taking effect before the two
reads. However, if we have to construct a linear order of
evaluations, as in 32.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8, then the execution above is not
permited. Is that really intended?
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Please clarify.
</p>

<p><i>[2011-03-09 Hans comments:]</i></p>


<p>I'm not proud of 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 (formerly p8), and I agree with the comments that this
isn't entirely satisfactory. 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 was designed to preclude
out-of-thin-air results for races among <tt>memory_order_relaxed</tt> atomics, in spite of 
the fact that Java experience has shown we don't really know how to do that adequately. In 
the long run, we probably want to revisit this.
<p/>
However, in the short term, I'm still inclined to declare this NAD, for two separate reasons:
</p>

<ol>
<li><p>4.6 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> p15 states: "If a side effect on a scalar
object is unsequenced relative to either another side
effect on the same scalar object or a value computation
using the value of the same scalar object, the behavior is undefined."
I think the examples presented here have undefined behavior as a result.
It's not completely clear to me whether examples can be constructed
that exhibit this problem, and don't have undefined behavior.</p></li>

<li><p>This comment seems to be using a different meaning of "evaluation"
from what is used elsewhere in the standard. The sequence of evaluations
here doesn't have to consist of full expression evaluations.  They
can be evaluations of operations like lvalue to rvalue conversion,
or individual assignments. In particular, the reads and writes
executed by <tt>e1</tt> and <tt>e2</tt> in the example could be treated as separate
evaluations for purposes of producing the sequence.
The definition of "sequenced before" in 4.6 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> makes
little sense if the term "evaluation" is restricted to any notion
of complete expression. Perhaps we should add yet another note
to clarify this?  32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p10 probably leads to 
the wrong impression here.
<p/>
An alternative resolution would be to simply delete our flakey
attempt at preventing out-of-thin-air reads, by removing 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9-11,
possibly adding a note that explains that we technically allow,
but strongly discourage them. If we were starting this from scratch
now, that would probably be my preference.  But it seems like too drastic
a resolution at this stage.
</p></li>
</ol>

<p><i>[2011-03-24 Madrid]</i></p>

<p>
Moved to NAD Future
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1484" href="1484">1484.</a> Need a way to join a thread with a timeout</h3>
<p><b>Section:</b> 33.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.class">[thread.thread.class]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2017-03-01 18:03:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-183</b></p>

<p>
There is no way to join a thread with a timeout.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Add <tt>join_for</tt> and <tt>join_until</tt>. Or decide one should
never join a thread with a timeout since <tt>pthread_join</tt> doesn't have a 
timeout version.
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The concurrency working group deemed this an extension beyond the scope of C++0x.
</p>
<p><b>Rationale:</b></p><p>The LWG does not wish to make a change at this time.</p>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
There has not been much demand for it, and it would usually be difficult to deal with <tt>thread_local</tt> destructor races. 
It can be approximated with a condition variable wait followed by an unconditional <tt>join</tt>. Adding it would create 
implementation issues on Posix. As always, this may be revisited if we have a paper exploring the issues in detail.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1488" href="1488">1488.</a> Improve interoperability between the C++0x and C1x threads APIs</h3>
<p><b>Section:</b> 33.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex">[thread.mutex]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2017-03-01 18:03:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.mutex">[thread.mutex]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-185</b></p>

<p>
Cooperate with WG14 to improve interoperability between
the <tt>C++0x</tt> and <tt>C1x</tt> threads APIs. In particular, <tt>C1x</tt>
mutexes should be conveniently usable with a <tt>C++0x</tt>
<tt>lock_guard</tt>. Performance overheads for this combination
should be considered.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Remove <tt>C++0x</tt> <tt>timed_mutex</tt> and
<tt>timed_recursive_mutex</tt> if that facilitates
development of more compatible APIs.
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The concurrency sub-group reviewed the options, and decided that closer harmony should wait until both standards are published.
</p>

<p><b>Rationale:</b></p>
<p>
The LWG does not wish to make any change at this time.
</p>


<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
Papers about C compatibility are welcome, but there may be more pressing issues. C threads are not consistently available 
at this point, so there seems to be little demand to fix this particular problem.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1493" href="1493">1493.</a> Add <tt>mutex</tt>, <tt>recursive_mutex</tt>, <tt>is_locked</tt> function</h3>
<p><b>Section:</b> 33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2017-03-01 18:03:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-189</b></p>

<p>
<tt>mutex</tt> and <tt>recursive_mutex</tt> should have an <tt>is_locked()</tt>
member function. <tt>is_locked</tt> allows a user to test a lock
without acquiring it and can be used to implement a lightweight
<tt>try_try_lock</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Add a member function:
</p>
<pre>
bool is_locked() const;
</pre>
<p>
to <tt>std::mutex</tt> and <tt>std::recursive_mutex</tt>. These
functions return true if the current thread would
not be able to obtain a mutex. These functions do
not synchronize with anything (and, thus, can
avoid a memory fence).
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed this issue and deemed it to be an extension to be handled after publishing C++0x.
</p>

<p><b>Rationale:</b></p><p>The LWG does not wish to make a change at this time.</p>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
Several participants voiced strong objections, based on either memory model issues or lock elision. No support. It is 
already possible to write a wrapper that explicitly tracks ownership for testing in the owning thread, which may have 
been part of the intent here.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1499" href="1499">1499.</a> Condition variables preclude wakeup optimization</h3>
<p><b>Section:</b> 33.5 <a href="https://timsong-cpp.github.io/cppwp/thread.condition">[thread.condition]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2017-03-01 18:03:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.condition">[thread.condition]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-193</b></p>

<p>
Condition variables preclude a wakeup optimization.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote><p>
Change condition_variable to allow such
optimization. See Appendix 1 - Additional Details
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed the issue, and deemed it an extension to be handled after C++0x.
</p>

<p><b>Rationale:</b></p><p>The LWG does not wish to make the change at this time.</p>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
The approach suggested there raises all sorts of issues about <tt>thread_locals</tt>, etc. It's probably way too late 
to change this anyway, but this would have required a careful paper.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1521" href="1521">1521.</a> Requirements on internal pointer representations in containers</h3>
<p><b>Section:</b> 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2010-10-16 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>

<p>
The standard doesn't say that containers should use abstract pointer 
types internally. Both Howard and Pablo agree that this is the intent. 
Further, it is necessary for containers to be stored, for example, in 
shared memory with an interprocess allocator (the type of scenario that 
allocators are intended to support).
</p>
<p>
In spite of the (possible) agreement on intent, it is necessary to make 
this explicit:
</p>
<p>
An implementations may like to store the result of dereferencing the 
pointer (which is a raw reference) as an optimization, but that prevents 
the data structure from being put in shared memory, etc. In fact, a 
container could store raw references to the allocator, which would be a 
little weird but conforming as long as it has one by-value copy. 
Furthermore, pointers to locales, ctypes, etc. may be there, which also 
prevents the data structure from being put in shared memory, so we 
should make explicit that a container does not store raw pointers or 
references at all.
</p>

<p><i>[
Pre-batavia
]</i></p>

<p>
This issue is being opened as part of the response to NB comments US-104/141. 
See paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing. 
</p>

<p><i>[2011-03-23 Madrid meeting]</i></p>


<p>Deferred</p>

<p><i>[
2011 Batavia
]</i></p>


<p>
This may be an issue, but it is not clear.  We want to gain a few years experience
with the C++11 allocator model to see if this is already implied by the existing
specification.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to the end of 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p. 8:
</p>
<blockquote><p>
[..] In all container types defined in this Clause, the member <tt>get_allocator()</tt> returns 
a copy of the allocator used to construct the container or, if that allocator has been replaced, 
a copy of the most recent replacement. <ins>The container may not store internal objects whose 
types are of the form  <tt>T *</tt> or <tt>T &amp;</tt> except insofar as they are part of the 
item type or members.</ins>
</p></blockquote>





<hr>
<h3><a name="2035" href="2035">2035.</a> Output iterator requirements are broken</h3>
<p><b>Section:</b> 27.2.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>During the Pittsburgh meeting the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
became accepted because it fixed several severe issues related to the iterator specification. But the current working draft (N3225)
does not reflect all these changes. Since I'm unaware whether every correction can be done editorial, this issue is submitted to take
care of that. To give one example: All expressions of Table 108 &mdash; &quot;Output iterator requirements&quot; have a post-condition
that the iterator is incrementable. This is impossible, because it would exclude any finite sequence that is accessed by an output 
iterator, such as a pointer to a C array. The N3066 wording changes did not have these effects.
</p>

<p><i>[2011-03-01: Daniel comments:]</i></p>


<p>This issue has some overlap with the issue <a href="2038">2038</a> and I would prefer if we
could solve both at one location. I suggest the following approach:
</p>
<ol>
<li><p>The terms <tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> could be defined in a more
general way not restricted to iterators (similar to the concepts <tt>HasDereference</tt> and 
<tt>HasPreincrement</tt> from working draft N2914). But on the other hand, all current usages of 
<tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> are involved with types that satisfy 
iterator requirements. Thus, I believe that it is sufficient for C++0x to add corresponding definitions to 
27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> and to let all previous usages of these terms refer to this 
sub-clause. Since the same problem occurs with the past-the-end iterator, this proposal suggest providing 
similar references to usages that precede its definition as well.
</p></li>
<li><p>We also need to ensure that all iterator expressions get either an operational semantics in
terms of others or we need to add missing pre- and post-conditions. E.g. we have the following
ones without semantics:
</p><blockquote><pre>
*r++ = o // output iterator
*r--     // bidirectional iterator
</pre></blockquote><p>
According to the <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a>
these correspond to
</p><blockquote><pre>
{ *r = o; ++r; }                         // output iterator
{ reference tmp = *r; --r; return tmp; } // bidirectional iterator
</pre></blockquote><p>
respectively. Please note especially the latter expression for bidirectional iterator. It fixes a problem
that we have for forward iterator as well: Both these iterator categories provide stronger guarantees
than input iterator, because the result of the dereference operation is <tt>reference</tt>, and <strong>not</strong>
only convertible to the value type (The exact form from the SGI documentation does not correctly refer to
<tt>reference</tt>).
</p></li>
</ol>

<p><i>[2011-03-14: Daniel comments and updates the suggested wording]</i></p>


<p>In addition to the before mentioned necessary changes there is another one need, which
became obvious due to issue <a href="2042">2042</a>: <tt>forward_list&lt;&gt;::before_begin()</tt> returns
an iterator value which is not dereferencable, but obviously the intention is that it should
be incrementable. This leads to the conclusion that imposing dereferencable as a requirement
for the expressions <tt>++r</tt> is wrong: We only need the iterator to be incrementable. A
similar conclusion applies to the expression <tt>--r</tt> of bidirectional iterators.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Consensus this is the correct direction, but there are (potentially) missing <i>incrementable</i>
preconditions on some table rows, and the Remarks on when an output iterator becomes dereferencable
are probably better handled outside the table, in a manner similar to the way we word for input
iterators.
</p>

<p>
There was some concern about redundant pre-conditions when the operational semantic is defined in
terms of operations that have preconditions, and a similar level of concern over dropping such
redundancies vs. applying a consistent level of redundant specification in all the iterator tables.
Wording clean-up in either direction would be welcome.
</p>

<p><i>[2011-08-18: Daniel adapts the proposed resolution to honor the Bloomington request]</i></p>


<p>
There is only a small number of further changes suggested to get rid of superfluous 
requirements and essentially non-normative assertions. Operations should not have extra 
pre-conditions, if defined by "in-terms-of" semantics, see e.g. <tt>a != b</tt> or <tt>a-&gt;m</tt> 
for Table 107. Further, some remarks, that do not impose anything or say nothing new have been removed, 
because I could not find anything helpful they provide.
E.g. consider the remarks for Table 108 for the operations dereference-assignment and
preincrement: They don't provide additional information say nothing surprising. With the
new pre-conditions <em>and</em> post-conditions it is implied what the remarks intend to say.
</p>

<p><i>[
2011-11-03: Some observations from Alexander Stepanov via c++std-lib-31405
]</i></p>


<p>
The following sentence is dropped from the standard section on OutputIterators:
<p/>
"In particular, the following two conditions should hold: first, any
iterator value should be assigned through before it is incremented
(this is, for an output iterator <tt>i, i++; i++;</tt> is not a valid code
sequence); second, any value of an output iterator may have at most
one active copy at any given time (for example, <tt>i = j; *++i = a; *j = b;</tt> 
is not a valid code sequence)."
</p>

<p><i>[
2011-11-04: Daniel comments and improves the wording
]</i></p>


<p>
In regard to the first part of the comment, the intention of the newly proposed wording 
was to make clear that for the expression
</p>
<blockquote><pre>
*r = o
</pre></blockquote>
<p>
we have the precondition dereferenceable and the post-condition
incrementable. And for the expression
</p>
<blockquote><pre>
++r
</pre></blockquote>
<p>
we have the precondition incrementable and the post-condition dereferenceable 
or past-the-end. This <em>should not</em>  allow for a sequence like <tt>i++; i++;</tt> 
but I agree that it doesn't exactly say that.
<p/>
In regard to the second point: To make this point clearer, I suggest to
add a similar additional wording as we already have for input iterator to the 
"Assertion&#47;note" column of the expression <tt>++r</tt>:
<p/>
"Post: any copies of the previous value of <tt>r</tt> are no longer 
required to be dereferenceable or incrementable."
<p/>
The proposed has been updated to honor the observations of Alexander Stepanov.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
The matter is complicated, Daniel volunteers to write a paper.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Add a reference to 27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> to the following parts of the
library preceding Clause 24 Iterators library: (I stopped from 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> on, because
the remaining references are the concrete containers)</p>
<ol>
<li><p>20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> p5:</p>

<blockquote><p>
-5- A type <tt>X</tt> satisfying any of the iterator requirements (24.2) is <tt><i>ValueSwappable</i></tt> if, 
for any dereferenceable <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> object <tt>x</tt> of type 
<tt>X</tt>, <tt>*x</tt> is swappable.
</p></blockquote>
</li>

<li><p>20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 27 &mdash; &quot;Descriptive variable definitions&quot;, 
row with the expression <tt>c</tt>:</p>

<blockquote><p>
a dereferenceable <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> pointer of type <tt>C*</tt>
</p></blockquote>

</li>

<li><p>23.10.3.2 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.functions">[pointer.traits.functions]</a>:</p>
<blockquote><p>
<i>Returns</i>: The first template function returns a dereferenceable <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
pointer to <tt>r</tt> obtained by calling <tt>Ptr::pointer_to(r)</tt>;  [&hellip;]
</p></blockquote>
</li>

<li><p>24.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/string.iterators">[string.iterators]</a> p. 2:</p>
<blockquote><p>
<i>Returns</i>: An iterator which is the past-the-end value <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins>.
</p></blockquote>
</li>

<li><p>25.4.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> p. 11:</p>
<blockquote><pre>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
  ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
</pre><blockquote><p>
<i>Requires</i>: <tt>t</tt> shall be dereferenceable <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins>.
</p></blockquote></blockquote>
</li>

<li><p>26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p. 6:</p>

<blockquote><p>
[&hellip;]  <tt>end()</tt> returns an iterator which is the past-the-end <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
value for the container.  [&hellip;]
</p></blockquote>
</li>

<li><p>26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> p. 3:</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> p. 8 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p. 10 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> and <tt>q1</tt> are valid dereferenceable <ins>(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
const iterators to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>
</ol>

</li>
<li><p>Edit 27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> p. 5 as indicated (The intent is to properly define
<i>incrementable</i> and to ensure some further library guarantee related to past-the-end iterator values):</p>

<blockquote><p>
-5- Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence. These values are called <i>past-the-end values</i>. Values of an iterator <tt>i</tt> for which the
expression <tt>*i</tt> is defined are called <i>dereferenceable</i>. <ins>Values of an iterator <tt>i</tt> for which the
expression <tt>++i</tt> is defined are called <i>incrementable</i>. </ins> The library never assumes that 
past-the-end values are dereferenceable <ins>or incrementable</ins>. Iterators can also have singular values 
that are not associated with any sequence. [&hellip;]
</p></blockquote>
</li>

<li><p>Modify the column contents of Table 106 &mdash; &quot;Iterator requirements&quot;, 
27.2.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.iterators">[iterator.iterators]</a>, as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 106 &mdash; Iterator requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r</tt></td>
<td><tt>reference</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is dereferenceable.</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins></td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 107 &mdash; &quot;Input iterator requirements&quot;, 
27.2.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>, as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <tt>*a</tt> and <tt>++r</tt>, and 
to specify the semantics of the remaining ones. This approach seems to be in agreement with the 
original <a href="http://www.sgi.com/tech/stl/InputIterator.html">SGI specification</a> 
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>a != b</tt></td>
<td>contextually<br/>
convertible to <tt>bool</tt></td>
<td><tt>!(a == b)</tt></td>
<td><del>pre: <tt>(a, b)</tt> is in the domain<br/>
of <tt>==</tt>.</del>
</td>
</tr>

<tr>
<td><tt>*a</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>a</tt> is dereferenceable.<br/>
The expression<br/>
<tt>(void)*a, *a</tt> is equivalent<br/>
to <tt>*a</tt>.<br/>
If <tt>a == b</tt> and <tt>(a,b)</tt> is in<br/>
the domain of <tt>==</tt> then <tt>*a</tt> is<br/>
equivalent to <tt>*b</tt>.
</td>
</tr>

<tr>
<td><tt>a-&gt;m</tt></td>
<td><tt>&nbsp;</tt></td>
<td><tt>(*a).m</tt></td>
<td><del>pre: <tt>a</tt> is dereferenceable.</del></td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
post: <tt>r</tt> is dereferenceable or<br/>
<tt>r</tt> is past-the-end.<br/>
post: any copies of the<br/>
previous value of <tt>r</tt> are no<br/>
longer required either to be<br/>
dereferenceable<ins>, incrementable,</ins><br/>
or to be in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td><tt>(void)r++</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins><tt>(void)++r</tt></ins></td>
<td><del>equivalent to <tt>(void)++r</tt></del></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</tt></td>
<td><tt>&nbsp;</tt></td>
</tr>

</table>
</blockquote>
</li>

<li>
<p>Modify the column contents of Table 108 &mdash; &quot;Output iterator requirements&quot;, 
27.2.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>, as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <tt>*r = o</tt> and <tt>++r</tt>,
and to specify the semantics of the remaining ones. This approach seems to be in agreement with
the original <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a> 
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 108 &mdash; Output iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r = o</tt></td>
<td>result is not used</td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is dereferenceable.</ins><br/>
<i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>and any copies of<br/>
the previous value of <tt>r</tt> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <tt>r</tt> is incrementable.
</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins><br/>
<tt>&amp;r == &amp;++r</tt>.<br/>
<del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/></del>
<ins><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
incrementable and any copies of<br/>
the previous value of <tt>r</tt> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <tt>r</tt> is <ins>dereferenceable<br/>
or <tt>r</tt> is past-the-end</ins><del>incrementable</del>.<br/>
</td>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.</del>
</td>
</tr>

<tr>
<td><tt>*r++ = o</tt></td>
<td>result is not used</td>
<td><ins><tt>{ *r = o; ++r; }</tt></ins></td>
<td><del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.</del>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 109 &mdash; &quot;Forward iterator requirements&quot;, 
27.2.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a>, as indicated [<i>Rationale</i>: Since the return type of the
expression <tt>*r++</tt> is now guaranteed to be type <tt>reference</tt>, the implied operational
semantics from input iterator based on value copies is wrong &mdash; <i>end rationale</i>]</p>

<blockquote>
<table border="1">
<caption>Table 109 &mdash; Forward iterator requirements (in addition to input iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 ++r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify the column contents of Table 110 &mdash; &quot;Bidirectional iterator requirements&quot;, 
27.2.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a>, as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 110 &mdash; Bidirectional iterator requirements (in addition to forward iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>--r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: there exists <tt>s</tt> such that<br/>
<tt>r == ++s</tt>.<br/>
post: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
<tt>--(++r) == r</tt>.<br/>
<tt>--r == --s</tt> implies <tt>r == s</tt>.<br/>
<tt>&amp;r == &amp;--r</tt>.
</td>
</tr>

<tr>
<td><tt>r--</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  --r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r--</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 --r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2038" href="2038">2038.</a> Missing definition for <tt>incrementable</tt> iterator</h3>
<p><b>Section:</b> 27.2.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>In comp.lang.c++, Vicente Botet raises the following questions:</p>

<blockquote><p>
&quot;In "24.2.4 Output iterators" there are 3 uses of incrementable. I've
not found the definition. Could some one point me where it is defined?
<p/>
Something similar occurs with dereferenceable. While the definition is
given in "24.2.1 In general" it is used several times before.
<p/>
Shouldn't these definitions be moved to some previous section?&quot;
</p></blockquote>

<p>He's right: both terms are used without being properly defined.
<p/>
There is no definition of "incrementable".
<p/>
While there is a definition of "dereferenceable", it is, in fact, a definition of 
"dereferenceable iterator". "dereferenceable" is used throughout Clause 23 (Containers) 
before its definition in Clause 24. In almost all cases it's referring to iterators, 
but in 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> there is a mention of "dereferenceable object"; in 
20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> the table of Descriptive variable definitions refers to a 
"dereferenceable pointer"; 23.10.3.2 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.functions">[pointer.traits.functions]</a> refers to a 
"dereferenceable pointer"; in 25.4.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a>&#47;11 (<tt>do_get</tt>) 
there is a requirement that a pointer "shall be dereferenceable". In those specific cases 
it is not defined.
</p>

<p><i>[2011-03-02: Daniel comments:]</i></p>


<p>I believe that the currently proposed resolution of issue <a href="2035">2035</a> solves this
issue as well.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Agree with Daniel, this will be handled by the resolution of <a href="2035">2035</a>.
</p>



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2040" href="2040">2040.</a> Missing type traits related to <tt>is_convertible</tt></h3>
<p><b>Section:</b> 23.15 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-03-03 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>
was suggested, it concentrated on constructions, assignments, and destructions, but overlooked 
to complement the single remaining compiler-support trait</p>

<blockquote><pre>
template &lt;class From, class To&gt; struct is_convertible;
</pre></blockquote>

<p>with the no-throw and triviality related aspects as it had been done with the other
expression-based traits. Specifically, the current specification misses to add the
following traits:
</p>

<blockquote><pre>
template &lt;class From, class To&gt; struct is_nothrow_convertible;
template &lt;class From, class To&gt; struct is_trivially_convertible;
</pre></blockquote>

<p>In particular the lack of <tt>is_nothrow_convertible</tt> is severly restricting. This
was recently recognized when the proposal for <tt>decay_copy</tt> was prepared by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3255.html">n3255</a>.
There does not exist a portable means to define the correct conditional <tt>noexcept</tt>
specification for the <tt>decay_copy</tt> function template, which is declared as:</p>

<blockquote><pre>
template &lt;class T&gt; 
typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v) noexcept(<i>???</i>);
</pre></blockquote>

<p>The semantics of <tt>decay_copy</tt> bases on an implicit conversion which again
influences the overload set of functions that are viable here. In most circumstances
this will have the same effect as comparing against the trait 
<tt>std::is_nothrow_move_constructible</tt>, but there is no guarantee for that being
the right answer. It is possible to construct examples, where this would lead
to the false result, e.g.</p>

<blockquote><pre>
struct S {
  S(const S&amp;) noexcept(false);
 
  template&lt;class T&gt;
  explicit S(T&amp;&amp;) noexcept(true);
};
</pre></blockquote>

<p><tt>std::is_nothrow_move_constructible</tt> will properly honor the explicit template
constructor because of the direct-initialization context which is part of the
<tt>std::is_constructible</tt> definition and will in this case select it, such that
<tt>std::is_nothrow_move_constructible&lt;S&gt;::value == true</tt>, but if we had
the traits <tt>is_nothrow_convertible</tt>, <tt>is_nothrow_convertible&lt;S, S&gt;::value</tt>
would evaluate to <tt>false</tt>, because it would use the copy-initialization context
that is part of the <tt>is_convertible</tt> definition, excluding any explicit
constructors and giving the opposite result.</p>

<p>The <tt>decay_copy</tt> example is surely not one of the most convincing examples, but
<tt>is_nothrow_convertible</tt> has several use-cases, and can e.g. be used to express
whether calling the following implicit conversion function could throw an exception or not:</p>

<blockquote><pre>
template&lt;class T, class U&gt;
T implicit_cast(U&amp;&amp; u) noexcept(is_nothrow_convertible&lt;U, T&gt;::value) 
{
  return std::forward&lt;U&gt;(u);
}
</pre></blockquote>

<p>Therefore I suggest to add the missing trait <tt>is_nothrow_convertible</tt> and for
completeness also the missing trait <tt>is_trivially_convertible</tt> to 23.15 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Daniel K: This is a new feature so out of scope.
<p/>
Pablo: Any objections to moving 2040 to Open?
<p/>
No objections. 
</p>

<p><i>[Bloomington, 2011]</i></p>

<p>
Move to NAD Future, this would be an extension to existing functionality.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Ammend the following declarations to the header <tt>&lt;type_traits&gt;</tt> synopsis
in 23.15.2 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>:</p>

<blockquote><pre>
namespace std {
  &hellip;
  // 20.9.6, type relations:
  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;
  <ins>template &lt;class From, class To&gt; struct is_trivially_convertible;</ins>
  <ins>template &lt;class From, class To&gt; struct is_nothrow_convertible;</ins>

  &hellip;
}
</pre></blockquote>
</li>

<li><p>Modify Table 51 &mdash; &quot;Type relationship predicates&quot; as indicated. The removal of the
remaining traces of the trait <tt>is_explicitly_convertible</tt> is an editorial
step, it was removed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3047.html">n3047</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 51 &mdash; Type relationship predicates</caption>

<tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>

<tr>
<td colspan="3" style="text-align:center;">&hellip;</td> 
</tr>

<tr>
<td><tt>template &lt;class From, class To&gt;<br/>
struct is_convertible;</tt></td>
<td><i>see below</i></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound, or<br/>
(possibly cv-qualified) <tt>void</tt><br/>
types.</td>
</tr>

<tr>
<td><del><tt>template &lt;class From, class To&gt;<br/>
struct is_explicitly_convertible;</tt></del></td>
<td><del><tt>is_constructible&lt;To, From&gt;::value</tt></del></td>
<td><del>a synonym for a two-argument<br/>
version of <tt>is_constructible</tt>.<br/>
An implementation may define it<br/>
as an alias template.</del></td>
</tr>

<tr>
<td><ins><tt>template &lt;class From, class To&gt;<br/>
struct is_trivially_convertible;</tt></ins></td>
<td><ins><tt>is_convertible&lt;From,<br/>
 To&gt;::value</tt> is <tt>true</tt> and the<br/>
conversion, as defined by<br/>
<tt>is_convertible</tt>, is known<br/>
to call no operation that is<br/>
not trivial ([basic.types], [special]).</ins></td>
<td><ins><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly cv-qualified) <tt>void</tt><br/>
types.</ins></td>
</tr>

<tr>
<td><ins><tt>template &lt;class From, class To&gt;<br/>
struct is_nothrow_convertible;</tt></ins></td>
<td><ins><tt>is_convertible&lt;From,<br/>
 To&gt;::value</tt> is <tt>true</tt> and the<br/>
conversion, as defined by<br/>
<tt>is_convertible</tt>, is known<br/>
not to throw any<br/>
exceptions ([expr.unary.noexcept]).</ins></td>
<td><ins><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly cv-qualified) <tt>void</tt><br/>
types.</ins></td>
</tr>

<tr>
<td colspan="3" style="text-align:center;">&hellip;</td> 
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2055" href="2055">2055.</a> <tt>std::move</tt> in <tt>std::accumulate</tt> and other algorithms</h3>
<p><b>Section:</b> 29.8 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2011-01-01 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.ops">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++0x draft says <tt>std::accumulate</tt> uses: <tt>acc = binary_op(acc, *i)</tt>.
<p/>
Eelis van der Weegen has pointed out, on the libstdc++ mailing list, that using 
<tt>acc = binary_op(std::move(acc), *i)</tt> can lead to massive improvements (particularly, 
it means accumulating strings is linear rather than quadratic).
<p/>
Consider the simple case, accumulating a bunch of strings of length 1 (the same argument holds for other length buffers).
For strings <tt>s</tt> and <tt>t</tt>, <tt>s+t</tt> takes time <tt>length(s)+length(t)</tt>, as you have to copy 
both <tt>s</tt> and <tt>t</tt> into a new buffer.
<p/>
So in accumulating <tt>n</tt> strings, step <tt>i</tt> adds a string of length <tt>i-1</tt> to a string of length 
1, so takes time <tt>i</tt>.
<p/>
Therefore the total time taken is: <tt>1+2+3+...+n</tt> = O(<tt>n<sup>2</sup></tt>)
<p/>
<tt>std::move(s)+t</tt>, for a "good" implementation, is amortized time <tt>length(t)</tt>, like <tt>vector</tt>, 
just copy <tt>t</tt> onto the end of the buffer. So the total time taken is:
<p/>
<tt>1+1+1+...+1</tt> (<tt>n</tt> times) = O(<tt>n</tt>). This is the same as <tt>push_back</tt> on a <tt>vector</tt>.
<p/>
I'm trying to decide if this implementation might already be allowed. I suspect it might not 
be (although I can't imagine any sensible code it would break). There are other algorithms 
which could benefit similarly (<tt>inner_product</tt>, <tt>partial_sum</tt> and 
<tt>adjacent_difference</tt> are the most obvious).
<p/>
Is there any general wording for "you can use rvalues of temporaries"?
<p/>
The reflector discussion starting with message c++std-lib-29763 came to the conclusion
that above example is not covered by the "as-if" rules and that enabling this behaviour
would seem quite useful.
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Moved to NAD Future.  This would be a larger change than we would consider for a simple TC.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2070" href="2070">2070.</a> <tt>allocate_shared</tt> should use <tt>allocator_traits&lt;A&gt;::construct</tt></h3>
<p><b>Section:</b> 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-07-11 <b>Last modified:</b> 2016-08-02 17:08:11 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> says:
</p>
<blockquote><p>
-2- <i>Effects</i>: Allocates memory suitable for an object of type <tt>T</tt> and constructs an object in that memory
via the placement new expression <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template
<tt>allocate_shared</tt> uses a copy of a to allocate memory. If an exception is thrown, the functions have
no effect.
</p></blockquote>
<p>
This explicitly requires placement new rather than using
<tt>allocator_traits&lt;A&gt;::construct(a, (T*)pv, std::forward&lt;Args&gt;(args)...)</tt>
In most cases that would result in the same placement new expression,
but would allow more control over how the object is constructed e.g.
using <tt>scoped_allocator_adaptor</tt> to do uses-allocator construction, or
using an allocator declared as a friend to construct objects with no
public constructors.
</p>

<p><i>[2011-08-16 Bloomington:]</i></p>

<p>
Agreed to fix in principle, but believe that <tt>make_shared</tt> and
<tt>allocate_shared</tt> have now diverged enough that their descriptions
should be separated.  Pablo and Stefanus to provide revised wording.
</p>

<p><strong>Daniel's (old) proposed resolution:</strong></p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the following paragraphs of 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated (The suggested
removal of the last sentence of p1 is not strictly required to resolve this issue, but is still recommended,
because it does not say anything new but may give the impression that it says something new):
</p><blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre><blockquote>
<p>
-1- <i>Requires</i>: <ins>For the template <tt>make_shared</tt>, t</ins><del>T</del>he expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>T</tt>, shall be well 
formed. <ins>For the template <tt>allocate_shared</tt>, the expression 
<tt>allocator_traits&lt;A&gt;::construct(a, pt, std::forward&lt;Args&gt;(args)...)</tt>,
where <tt>pt</tt> has type <tt>T*</tt> and points to storage suitable to hold an object
of type <tt>T</tt>, shall be well formed.</ins> <tt>A</tt> shall be an allocator ([allocator.requirements]). 
<del>The copy constructor and destructor of  <tt>A</tt> shall not throw exceptions.</del>
<p/>
-2- <i>Effects</i>: Allocates memory suitable for an object of type <tt>T</tt> and constructs an object in 
that memory<ins>. The template <tt>make_shared</tt> constructs the object</ins> via the placement new expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template <tt>allocate_shared</tt> uses a copy 
of <tt>a</tt> to allocate memory<ins> and constructs the object by calling <tt>allocator_traits&lt;A&gt;::construct(a, pt,
std::forward&lt;Args&gt;(args)...)</tt></ins>. If an exception is thrown, the functions have no effect.
<p/>
-3- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>.
<p/>
-4- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt>
<p/>
-5- <i>Throws</i>: <tt>bad_alloc</tt>, or<ins>, for the template <tt>make_shared</tt>, an exception thrown from
the constructor of <tt>T</tt>, or, for the template <tt>allocate_shared</tt>,</ins> an exception thrown from 
<tt>A::allocate</tt> or <ins>from <tt>allocator_traits&lt;A&gt;::construct</tt></ins><del>from the constructor of 
<tt>T</tt></del>.
<p/>
-6- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [ <i>Note</i>: This provides efficiency equivalent to an intrusive smart pointer. &mdash; <i>end note</i> ]
<p/>
-7- [ <i>Note</i>: These functions will typically allocate more memory than <tt>sizeof(T)</tt> to allow for internal
bookkeeping structures such as the reference counts. &mdash; <i>end note</i> ]
</p>
</blockquote></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2011-12-04: Jonathan and Daniel improve wording]</i></p>


<p>See also c++std-lib-31796</p>




<p><i>[2013-10-13, Ville]</i></p>

<p>
This issue is related to <a href="2089">2089</a>.
</p>


<p><i>[2014-02-15 post-Issaquah session : move to Tentatively NAD]</i></p>

<p>STL: This takes an allocator, but then ignores its construct. That's squirrely.</p>
<p>Alisdair: The convention is when you take an allocator, you use its construct.</p>
<p>STL: 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/3, argh! This fills me with despair, but I understand it now.</p>
<p>STL: Ok, this is some cleanup.</p>
<p>STL: You're requiring <tt>b</tt> to be of type <tt>A</tt> and not being rebound, is that an overspecification?</p>
<p>Pablo: Good point. Hmm, that's only a requirement on what must be well-formed.</p>
<p>STL: If it's just a well-formed requirement, then why not just use a directly?</p>
<p>Pablo: Yeah, the well-formed requirement is overly complex. It's not a real call, we could just use a directly. It makes it harder to read.</p>
<p>Alisdair: <tt>b</tt> should be an allocator in the same family as <tt>a</tt>.</p>
<p>Pablo: This is a well-formed requirement, I wonder if it's the capital A that's the problem here. It doesn't matter here, this is way too much wording.</p>
<p>Alisdair: It's trying to tie the constructor arguments into the allocator requirements.</p>
<p>Pablo: <tt>b</tt> could be struck, that's a runtime quality. The construct will work with anything that's in the family of <tt>A</tt>.</p>
<p>Alisdair: The important part is the <tt>forward</tt> of <tt>Args</tt>.</p>
<p>Pablo: <tt>A</tt> must be an allocator, and <tt>forward</tt> <tt>Args</tt> must work with that.</p>
<p>Alisdair: First let's nail down <tt>A</tt>.</p>
<p>Pablo: Then replace <tt>b</tt> with <tt>a</tt>, and strike the rest.</p>
<p>STL: You need <tt>pt</tt>'s type, at least.</p>
<p>Pablo: There's nothing to be said about runtime constraints here, this function doesn't even take a <tt>pt</tt>.</p>
<p>STL: Looking at the Effects, I believe <tt>b</tt> is similarly messed up, we can use <tt>a2</tt> to construct an object.</p>
<p>Alisdair: Or any allocator in the family of <tt>a</tt>.</p>
<p>STL: We say this stuff for the deallocate too, it should be lifted up.</p>
<p>STL: "owns the address" is weird.</p>
<p>Alisdair: shared_ptr owns pointers, although it does sound funky.</p>
<p>Walter: "to destruct" is ungrammatical.</p>
<p>STL: "When ownership is given up" is not what we usually say.</p>
<p>Alisdair: I think the Returns clause is the right place to say this.</p>
<p>STL: The right place to say this is <tt>shared_ptr</tt>'s dtor, we don't want to use Core's "come from" convention.</p>
<p>Alisdair: I'm on the hook to draft cleaner wording.</p>


<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>
AM: I was going to clean up the wording, but haven't done it yet.<br/>
Defer until we have new wording.<br/>
</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>
Alisdair: we need to figure out whether we should call construct or not; major implementation divergence<br/>
STL: this does not grant friendship, does it?<br/>
Jonathan: some people want it.<br/>
Thomas: scoped allocator adapter should be supported, so placement new doesn't work<br/>
Alisdair: this makes the make_ functions impossible<br/>
Thomas: you don't want to use those though.<br/>
Alisdair: but people use that today, at Bloomberg<br/>
Alisdair: and what do we do about fancy pointers?<br/>
Jonathan: we constrain it to only non-fancy pointers.<br/>
STL: shared_ptr has never attempted to support fancy pointers; seems like a paper is needed.<br/>
Poll: call construct:6 operator new: 0 don't care: 4<br/>
Poll: should we support fancy pointers? Yes: 1 No: 4 don't care: 4<br/>
STL: 20.8.2.2.6p2: 'and pv->~T()' is bogus for void<br/>
STL: 20.8.2.2.6p4: is this true even if we're going to allocate a bit more?<br/>
Alisdair: yes<br/>
Alisdair: coming up with new wording<br/>
</p>

<p><i>[2016-08, Chicago Monday PM]</i></p>

<p>Alisdair to provide new wording this week</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the following paragraphs of 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:
</p>
<blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
<del>template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);</del>
</pre></blockquote>
<p>
<del>-1- <i>Requires</i>: The expression <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>T</tt>, shall be well 
formed. <tt>A</tt> shall be an allocator (20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>). The copy constructor 
and destructor of <tt>A</tt> shall not throw exceptions.</del>
<p/>
-2- <i>Effects</i>: <ins>Equivalent to</ins>
</p>
<blockquote><pre> 
<ins>return allocate_shared&lt;T&gt;(allocator&lt;T&gt;(), std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<del>Allocates memory suitable for an object of type <tt>T</tt> 
and constructs an object in that memory via the placement new expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template <tt>allocate_shared</tt> uses a copy 
of <tt>a</tt> to allocate memory. If an exception is thrown, the functions have no effect.</del>
<p/>
<ins>-?- <i>Remarks</i>: An implementation may meet the effects (and the implied guarantees) without 
creating the allocator object [<i>Note</i>: That is, user-provided specializations of <tt>std::allocator</tt>
may not be instantiated, the expressions <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt> and 
<tt>pv-&gt;~T()</tt> may be evaluated directly &mdash; <i>end note</i>].</ins>
<p/>
<del>-3- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>.</del>
<p/>
<del>-4- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt></del>
<p/>
<del>-5- <i>Throws</i>: <tt>bad_alloc</tt>, or an exception thrown from <tt>A::allocate</tt> or from the 
constructor of <tt>T</tt>.</del>
<p/>
<del>-6- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [<i>Note</i>: This provides efficiency equivalent to an intrusive smart pointer. &mdash; <i>end note</i>]</del>
<p/>
<del>-7- [<i>Note</i>: These functions will typically allocate more memory than <tt>sizeof(T)</tt> to allow 
for internal bookkeeping structures such as the reference counts. &mdash; <i>end note</i>]</del>
</p>
</li>
<li><p>
Add the following set of <ins>new paragraphs</ins> immediately following the previous paragraph 7 of
23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a>:
</p>
<blockquote><pre>
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre></blockquote>
<p>
-?- <i>Requires</i>: The expressions 
<tt>allocator_traits&lt;A&gt;::construct(b, pt, std::forward&lt;Args&gt;(args)...)</tt> and
<tt>allocator_traits&lt;A&gt;::destroy(b, pt)</tt> shall be well-formed and well-defined, 
where <tt>b</tt> has type <tt>A</tt> and is a copy of <tt>a</tt> and where <tt>pt</tt> 
has type <tt>T*</tt> and points to storage suitable to hold an object of type <tt>T</tt>. 
<tt>A</tt> shall meet the allocator requirements (20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>). 
<p/>
-?- <i>Effects</i>: Uses an object <tt>a2</tt> 
of type <tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;<i>unspecified</i>&gt;</tt> that compares equal to 
<tt>a</tt> to allocate memory suitable for an object of type <tt>T</tt>. 
Uses a copy <tt>b</tt> of type <tt>A</tt> from <tt>a</tt> to construct an object of type <tt>T</tt> in 
that memory by calling <tt>allocator_traits&lt;A&gt;::construct(b, pt, std::forward&lt;Args&gt;(args)...)</tt>. 
If an exception is thrown, the function has no effect.
<p/>
-?- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>. When ownership is given up, the effects are as follows: Uses a copy <tt>b2</tt> 
of type <tt>A</tt> from <tt>a</tt> to destruct an object of type <tt>T</tt> by calling 
<tt>allocator_traits&lt;A&gt;::destroy(b2, pt2)</tt> where <tt>pt2</tt> has type <tt>T*</tt> 
and refers to the newly constructed object. Then uses an object of type
<tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;<i>unspecified</i>&gt;</tt> that compares equal to 
<tt>a</tt> to deallocate the allocated memory.
<p/>
-?- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt>
<p/>
-?- <i>Throws</i>: Nothing unless memory allocation or <tt>allocator_traits&lt;A&gt;::construct</tt> 
throws an exception.
<p/>
-?- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory 
allocation. [<i>Note</i>: Such an implementation provides efficiency equivalent to an intrusive smart 
pointer. &mdash; <i>end note</i>]
<p/>
-?- [<i>Note</i>: This function will typically allocate more memory than <tt>sizeof(T)</tt> to allow for internal
bookkeeping structures such as the reference counts. &mdash; <i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3><a name="2077" href="2077">2077.</a> Further incomplete constraints for type traits</h3>
<p><b>Section:</b> 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-08-20 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The currently agreed on proposed wording for <a href="2015">2015</a> using 
<tt>remove_all_extents&lt;T&gt;::type</tt> instead of the "an array of 
unknown bound" terminology in the precondition should be extended to 
some further entries especially in Table 49, notably the 
<tt>is_*constructible</tt>, <tt>is_*assignable</tt>, and 
<tt>is_*destructible</tt> entries. To prevent ODR violations, incomplete
element types of arrays must be excluded for value-initialization and
destruction for example. Construction and assignment has to be honored, 
when we have array-to-pointer conversions or pointer conversions of
incomplete pointees in effect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
The issue is that in three type traits, we are accidentally saying that in certain
circumstances the type must give a specified answer when given an incomplete type.
(Specifically: an array of unknown bound of incomplete type.)  The issue asserts
that there's an ODR violation, since the trait returns false in that case but might
return a different version when the trait is completed.
</p>
<p>
Howard argues: no, there is no risk of an ODR violation.
<tt>is_constructible&lt;A[]></tt> must return <tt>false</tt> regardless of whether
<tt>A</tt> is complete, so there's no reason to forbid an array of unknown bound of
incomplete types. Same argument applies to <tt>is_assignable</tt>. General agreement
with Howard's reasoning.
</p>
<p>
There may be a real issue for <tt>is_destructible</tt>. None of us are sure what
<tt>is_destructible</tt> is supposed to mean for an array of unknown bound
(regardless of whether its type is complete), and the standard doesn't make it clear.
The middle column doesn't say what it's supposed to do for incomplete types.
</p>
<p>
In at least one implementation, <tt>is_destructible&lt;A[]></tt> does return <tt>true</tt>
if <tt>A</tt> is complete, which would result in ODR violation unless we forbid it for
incomplete types.
</p>
<p>
Move to open. We believe there is no issue for <tt>is_constructible</tt> or
<tt>is_assignable</tt>, but that there is a real issue for <tt>is_destructible</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2088" href="2088">2088.</a> <tt>std::terminate</tt> problem</h3>
<p><b>Section:</b> 21.8.4 <a href="https://timsong-cpp.github.io/cppwp/exception.terminate">[exception.terminate]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-09-25 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Andrzej Krzemienski reported the following on comp.std.c++:
</p>
<blockquote>
<p>
In N3290, which is to become the official standard, in 21.8.4.4 <a href="https://timsong-cpp.github.io/cppwp/terminate">[terminate]</a>,
paragraph 1 reads
</p>
<blockquote><p>
<i>Remarks</i>: Called by the implementation when exception handling must
be abandoned for any of several reasons (15.5.1), in effect immediately after 
evaluating the <em>throw-expression</em> (18.8.3.1). May also be called directly by the 
program.
</p></blockquote>
<p>It is not clear what is "in effect". It was clear in previous drafts where paragraphs 
1 and 2 read:
</p>
<blockquote><p>
Called by the implementation when exception handling must be
abandoned for any of several reasons (15.5.1). May also be called directly
by the program.
<p/>
<i>Effects</i>: Calls the <tt>terminate_handler</tt> function in effect
immediately after evaluating the <em>throw-expression</em> (18.8.3.1), if called by the
implementation, or calls the current <tt>terminate_handler</tt> function,
if called by the program.
</p>
</blockquote>
<p>
It was changed by N3189. The same applies to function unexpected (D. 11.4, paragraph 1).
<p/>
Assuming the previous wording is still intended, the wording can be read
"unless <tt>std::terminate</tt> is called by the program, we will use the handler
that was in effect immediately after evaluating the throw-expression".
<p/>
  This assumes that there is some throw-expression connected to every
  situation that triggers the call to <tt>std::terminate</tt>. But this is not
  the case:
</p>
<ul>
<li>
  In case <tt>std::thread</tt> is assigned to or destroyed while being joinable
  there is no throw-expression involved.
</li>
<li>
  In case <tt>std::unexpected</tt> is called by the program, <tt>std::terminate</tt> is
  triggered by the implementation - no throw-expression involved.
</li>
<li>
  In case a destructor throws during stack unwinding we have two throw-expressions 
  involved.
 </li>
 </ul>
<p>
Which one is referred to?
<p/>
In case <tt>std::nested_exception::rethrow_nested</tt> is called for an object that has 
captured no exception, there is no throw-expression involved directly (and may no throw 
be involved even indirectly).
<p/>
Next, 21.8.4.1 <a href="https://timsong-cpp.github.io/cppwp/terminate.handler">[terminate.handler]</a>, paragraph 2 says 
</p>
<blockquote><p>
<i>Required behavior</i>: A <tt>terminate_handler</tt> shall terminate execution
of the program without returning to the caller.
</p></blockquote>
<p>
This seems to allow that the function may exit by throwing an
exception (because word "return" implies a normal return).
<p/>
One could argue that words "terminate execution of the program" are sufficient,
but then why "without returning to the caller" would be mentioned. In
case such handler throws, noexcept specification in function <tt>std::terminate</tt> 
is violated, and <tt>std::terminate</tt> would be called recursively - should 
<tt>std::abort</tt> not be called in case of recursive <tt>std::terminate</tt> 
call? On the other hand some controlled recursion could be useful, like in the 
<a href="http://cplusplus.co.il/2010/03/21/catching-uncaught-exceptions-within-terminate/">following technique</a>.
</p>
</blockquote>

<p>
The here mentioned wording changes by N3189 in regard to 21.8.4.4 <a href="https://timsong-cpp.github.io/cppwp/terminate">[terminate]</a> p1 
were done for a better separation of effects (Effects element) and additional normative 
wording explanations (Remarks element), there was no meaning change intended. Further,
there was already a defect existing in the previous wording, which was not updated when 
further situations where defined, when <tt>std::terminate</tt> where supposed to be 
called by the implementation. 
<p/>
The part
<p/>
"in effect immediately after evaluating the throw-expression"
<p/>
should be removed and the quoted reference to 21.8.4.1 <a href="https://timsong-cpp.github.io/cppwp/terminate.handler">[terminate.handler]</a> 
need to be part of the effects element where it refers to the current <tt>terminate_handler</tt> 
function, so should be moved just after
<p/>
"Effects: Calls the current <tt>terminate_handler</tt> function."
<p/>
It seems ok to allow a termination handler to exit via an exception, but the 
suggested idiom should better be replaced by a more simpler one based on
evaluating the current exception pointer in the terminate handler, e.g.
</p>
<blockquote><pre>
void our_terminate (void) {
  std::exception_ptr p = std::current_exception();
  if (p) {
    ... // OK to rethrow and to determine it's nature
  } else {
    ... // Do something else
  }
}
</pre></blockquote>

<p><i>[2011-12-09: Daniel comments]</i></p>


<p>
A related issue is <a href="2111">2111</a>.
</p>


<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
There is an interaction with Core issues in this area that Jens is already supplying wording
for.  Review this issue again once Jens wording is available.
</p>
<p>
Alisdair to review clause 15.5 (per Jens suggestion) and recommend any changes, then integrate
Jens wording into this issue.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2089" href="2089">2089.</a> <tt>std::allocator::construct</tt> should use uniform initialization</h3>
<p><b>Section:</b> 23.10.9.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a> <b>Status:</b> <a href="lwg-active.html#EWG">EWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2011-10-07 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.members">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
When the <tt>EmplaceConstructible</tt> (26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>&#47;13) requirement is used 
to initialize an object, direct-initialization occurs. Initializing an aggregate or using a <tt>std::initializer_list</tt> 
constructor with emplace requires naming the initialized type and moving a temporary. This is a result of 
<tt>std::allocator::construct</tt> using direct-initialization, not list-initialization (sometimes called "uniform 
initialization") syntax.
<p/>
Altering <tt>std::allocator&lt;T&gt;::construct</tt> to use list-initialization would, among other things, give 
preference to <tt>std::initializer_list</tt> constructor overloads, breaking valid code in an unintuitive and 
unfixable way &mdash; there would be no way for <tt>emplace_back</tt> to access a constructor preempted by 
<tt>std::initializer_list</tt> without essentially reimplementing <tt>push_back</tt>.
</p>
<blockquote><pre>
std::vector&lt;std::vector&lt;int&gt;&gt; v;
v.emplace_back(3, 4); // v[0] == {4, 4, 4}, not {3, 4} as in list-initialization
</pre></blockquote>
<p>
The proposed compromise is to use SFINAE with <tt>std::is_constructible</tt>, which tests whether direct-initialization 
is well formed. If <tt>is_constructible</tt> is false, then an alternative <tt>std::allocator::construct</tt> overload 
is chosen which uses list-initialization. Since list-initialization always falls back on direct-initialization, the 
user will see diagnostic messages as if list-initialization (uniform-initialization) were always being used, because 
the direct-initialization overload cannot fail.
<p/>
I can see two corner cases that expose gaps in this scheme. One occurs when arguments intended for 
<tt>std::initializer_list</tt> satisfy a constructor, such as trying to emplace-insert a value of <tt>{3, 4}</tt> in 
the above example. The workaround is to explicitly specify the <tt>std::initializer_list</tt> type, as in 
<tt>v.emplace_back(std::initializer_list&lt;int&gt;(3, 4))</tt>. Since this matches the semantics as if 
<tt>std::initializer_list</tt> were deduced, there seems to be no real problem here.
<p/>
The other case is when arguments intended for aggregate initialization satisfy a constructor. Since aggregates cannot 
have user-defined constructors, this requires that the first nonstatic data member of the aggregate be implicitly 
convertible from the aggregate type, and that the initializer list have one element. The workaround is to supply an 
initializer for the second member. It remains impossible to in-place construct an aggregate with only one nonstatic 
data member by conversion from a type convertible to the aggregate's own type. This seems like an acceptably small 
hole.
<p/>
The change is quite small because <tt>EmplaceConstructible</tt> is defined in terms of whatever allocator is specified, 
and there is no need to explicitly mention SFINAE in the normative text.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
There appears to be a real concern with initializing aggregates, that can be performed only
using brace-initialization.  There is little interest in the rest of the issue, given the existence
of 'emplace' methods in C++11.
</p>
<p>
Move to Open, to find an acceptable solution for intializing aggregates.  There is the potential
that EWG may have an interest in this area of language consistency as well.
</p>

<p><i>[2013-10-13, Ville]</i></p>

<p>
This issue is related to <a href="2070">2070</a>.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Move to EWG, Ville to write a paper. 
</p>

<p><i>[2015-09, Telecon]</i></p>

<p>
Ville: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html">N4462</a> reviewed in Lenexa. EWG discussion to continue in Kona.<br/>
</p>
<p><i>[2016-08 Chicago]</i></p>

<p>See <a href="http://wg21.link/N4462">N4462</a></p>
<p>The notes in Lenexa say that Marshall &amp; Jonathan volunteered to write a paper on this</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 23.10.9.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a> p12 as indicated:</p>

<blockquote><pre>
template &lt;class U, class... Args&gt;
  void construct(U* p, Args&amp;&amp;... args);
</pre><blockquote>
<p>
12 <i>Effects</i>: <tt>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</tt> <ins>if <tt>is_constructible&lt;U, Args...&gt;::value</tt> 
is <tt>true</tt>, else <tt>::new((void *)p) U{std::forward&lt;Args&gt;(args)...}</tt></ins>
</p>
</blockquote></blockquote>






<hr>
<h3><a name="2095" href="2095">2095.</a> <tt>promise</tt> and <tt>packaged_task</tt> missing constructors needed for uses-allocator construction</h3>
<p><b>Section:</b> 33.6.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>, 33.6.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-11-01 <b>Last modified:</b> 2016-08-06 21:08:50 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This example is ill-formed according to C++11 because <tt>uses_allocator&lt;promise&lt;R&gt;, A&gt;::value</tt> is true, but
<tt>is_constructible&lt;promise&lt;R&gt;, A, promise&lt;R&gt;&amp;&amp;&gt;::value</tt> is false. Similarly for <tt>packaged_task</tt>.
</p>
<blockquote><pre>
#include &lt;future&gt;
#include &lt;memory&gt;
#include &lt;tuple&gt;

using namespace std;

typedef packaged_task&lt;void()&gt; task;
typedef promise&lt;void&gt; prom;
allocator&lt;task&gt; a;

tuple&lt;task, prom&gt; t1{ allocator_arg, a };
tuple&lt;task, prom&gt; t2{ allocator_arg, a, task{}, prom{} };
</pre></blockquote>

<p><i>[2012, Portland]</i></p>

<p>
This is an allocator issue, and should be dealt with directly by LWG.
</p>

<p><i>[2013-03-06]</i></p>


<p>
Jonathan suggests to make the new constructors non-explicit and makes some representational improvements.
</p>


<p><i>[2013-09 Chicago]</i></p>

<p>
Move to deferred.
</p>
<p>
This issue has much in common with similar problems with <tt>std::function</tt> that are being addressed
by the polymorphic allocators proposal currently under evaluation in LEWG.  Defer further discussion on
this topic until the final outcome of that paper and its proposed resolution is known.
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2016-08 Chicago]</i></p>

<p>Fri PM: Send to LEWG  - and this also applies to <tt>function</tt> in LFTS.</p>


<p><b>Proposed resolution:</b></p>
<p><i>[This wording is relative to the FDIS.]</i></p>


<ol>
<li><p>Add to 33.6.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>, class template <tt>promise</tt> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class promise {
  public:
    promise();
    template &lt;class Allocator&gt;
    promise(allocator_arg_t, const Allocator&amp; a);
    <ins>template &lt;class Allocator&gt;
    promise(allocator_arg_t, const Allocator&amp; a, promise&amp;&amp; rhs) noexcept;</ins>
    promise(promise&amp;&amp; rhs) noexcept;
    promise(const promise&amp; rhs) = delete;
    ~promise();	
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 33.6.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> as indicated:</p>

<blockquote><pre>
promise(promise&amp;&amp; rhs) noexcept;
<ins>template &lt;class Allocator&gt;
promise(allocator_arg_t, const Allocator&amp; a, promise&amp;&amp; rhs) noexcept;</ins>
</pre><blockquote>
<p>
-5- <i>Effects</i>: constructs a new <tt>promise</tt> object and transfers ownership of 
the shared state of <tt>rhs</tt> (if any) to the newly-constructed object.
<p/>
-6- <i>Postcondition</i>: <tt>rhs</tt> has no shared state.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>

<li><p>Add to 33.6.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a>, class template <tt>packaged_task</tt> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class&gt; class packaged_task; // <i>undefined</i>

  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
  public:
    // construction and destruction
    packaged_task() noexcept;
    <ins>template &lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a) noexcept;</ins>
    template &lt;class F&gt;
      explicit packaged_task(F&amp;&amp; f);
    template &lt;class F, class Allocator&gt;
      explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
    ~packaged_task();
	
    // no copy
    packaged_task(const packaged_task&amp;) = delete;
    <ins>template&lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a, const packaged_task&amp;) = delete;</ins>
    packaged_task&amp; operator=(const packaged_task&amp;) = delete;
    
    // move support
    packaged_task(packaged_task&amp;&amp; rhs) noexcept;
    <ins>template &lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a, packaged_task&amp;&amp; rhs) noexcept;</ins>
    packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
    void swap(packaged_task&amp; other) noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 33.6.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> as indicated:</p>

<blockquote><pre>
packaged_task() noexcept;
<ins>template &lt;class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a) noexcept;</ins>
</pre><blockquote>
<p>
-1- <i>Effects</i>: constructs a <tt>packaged_task</tt> object with no shared state and no stored task.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>
<p>[&hellip;]</p>
<blockquote><pre>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
<ins>template &lt;class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a, packaged_task&amp;&amp; rhs) noexcept;</ins>
</pre><blockquote>
<p>
-5- <i>Effects</i>: constructs a new <tt>packaged_task</tt> object and transfers ownership of <tt>rhs</tt>'s 
shared state to <tt>*this</tt>, leaving <tt>rhs</tt> with no shared state. Moves the stored task from <tt>rhs</tt> 
to <tt>*this</tt>.
<p/>
-6- <i>Postcondition</i>: <tt>rhs</tt> has no shared state.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>
</ol>

<blockquote><pre>
</pre><blockquote>
<p>
</p></blockquote></blockquote>






<hr>
<h3><a name="2114" href="2114">2114.</a> Incorrect "<em>contextually</em> convertible to <tt>bool</tt>" requirements</h3>
<p><b>Section:</b> 20.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/nullablepointer.requirements">[nullablepointer.requirements]</a>, 27.2.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>, 27.2.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>, 28.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a>, 28.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a>, 33.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.req.paramname">[thread.req.paramname]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
As of 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> Table 17&#47;18, the return types of the expressions
</p>
<blockquote><pre>
a == b
</pre></blockquote>
<p>
or
</p>
<blockquote><pre>
a &lt; b
</pre></blockquote>
<p>
for types satisfying the <tt>EqualityComparable</tt> or <tt>LessThanComparable</tt>
types, respectively, are required to be "convertible to <tt>bool</tt>" which corresponds to
a copy-initialization context. But several newer parts of the library that refer to 
such contexts have lowered the requirements taking  advantage of the new terminology of 
"<em>contextually</em> convertible to <tt>bool</tt>" instead, which corresponds to a 
direct-initialization context (In addition to "normal" direct-initialization constructions, 
operands of logical operations as well as <tt>if</tt> or <tt>switch</tt> conditions also 
belong to this special context).
<p/>
One example for these new requirements are input iterators which satisfy <tt>EqualityComparable</tt> 
but also specify that the expression
</p>
<blockquote><pre>
a != b
</pre></blockquote>
<p>
shall be just "<strong>contextually</strong> convertible to <tt>bool</tt>". The same discrepancy 
exists for requirement set <tt>NullablePointer</tt> in regard to several equality-related expressions.
<p/>
For random access iterators we have
</p>
<blockquote><p>
<tt>a &lt; b</tt>      contextually convertible to <tt>bool</tt>
</p></blockquote>
<p>
as well as for all derived comparison functions, so strictly speaking we could have a random access 
iterator that does not satisfy the <tt>LessThanComparable</tt> requirements, which looks like an
artifact to me.
<p/>
Even if we keep with the existing requirements based on <tt>LessThanComparable</tt> or
<tt>EqualityComparable</tt> we still would have the problem that some current specifications 
are actually  based on the assumption of implicit convertibility instead of "explicit convertibility", e.g. 
23.11.1.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a> p3:
</p>
<blockquote><pre>
template &lt;class T1, class D1, class T2, class D2&gt;
bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: <tt>x.get() != y.get()</tt>.
</p>
</blockquote></blockquote>
<p>
Similar examples exist in 23.11.1.2.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.dtor">[unique.ptr.single.dtor]</a> p2, 23.11.1.2.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.asgn">[unique.ptr.single.asgn]</a> p9,
23.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> p1+3+8, etc.
<p/>
In all these places the expressions involving comparison functions (but <em>not</em> those of the conversion 
of a <tt>NullablePointer</tt> to <tt>bool</tt>!) assume to be "convertible to <tt>bool</tt>". I think this
is a very natural assumption and all delegations of the comparison functions of some type <tt>X</tt> to some
other API type <tt>Y</tt> in third-party code does so assuming that copy-initialization semantics will
just work.
<p/>
The actual reason for using the newer terminology can be rooted back to LWG <a href="556">556</a>. My hypotheses 
is that the resolution of that issue also needs a slight correction. Why so?
<p/>
The reason for opening that issue were worries based on the previous "convertible to <tt>bool</tt>"
wording. An expressions like "<tt>!pred(a, b)</tt>" might not be well-formed in those situations, because
<tt>operator!</tt> might not be accessible or might have an unusual semantics (and similarly for other logical
operations). This can indeed happen with unusual proxy return types, so the idea was that the evaluation of 
<tt>Predicate</tt>, <tt>BinaryPredicate</tt> (28.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a> p8+9), and <tt>Compare</tt> 
(28.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> p2) should be defined based on contextual conversion to <tt>bool</tt>. 
Unfortunately this <em>alone</em> is not sufficient: In addition, I think, we <em>also</em> want the predicates 
to be (implicitly) convertible to <tt>bool</tt>! Without this wording, several conditions are plain wrong, 
e.g. 28.5.5 <a href="https://timsong-cpp.github.io/cppwp/alg.find">[alg.find]</a> p2, which talks about "<tt>pred(*i) != false</tt>" (<tt>find_if</tt>) and 
"<tt>pred(*i) == false</tt>" (<tt>find_if_not</tt>). These expressions are not within a boolean context! 
<p/>
While we could simply fix all these places by proper wording to be considered in a "contextual conversion to
<tt>bool</tt>", I think that this is not the correct solution: Many third-party libraries already refer to
the previous C++03 <tt>Predicate</tt> definition &mdash; it actually predates C++98 and is as old as the 
<a href="http://www.sgi.com/tech/stl/Predicate.html">SGI specification</a>. It seems to be a high price to
pay to switch to direct initialization here instead of fixing a completely different specification problem.
<p/>
A final observation is that we have another definition for a <tt>Predicate</tt> in 33.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.req.paramname">[thread.req.paramname]</a> p2:
</p>
<blockquote><p>
If a parameter is <tt>Predicate</tt>, <tt>operator()</tt> applied to the actual template argument shall return a value that
is convertible to <tt>bool</tt>.
</p></blockquote>
<p>
The problem here is not that we have two different definitions of <tt>Predicate</tt> in the standard &mdash; this 
is confusing, but this fact alone is not a defect. The first (minor) problem is that this definition does not properly 
apply to function objects that are function pointers, because <tt>operator()</tt> is not defined in a strict sense. 
But the actually worse second problem is that this wording has the very <tt>same</tt> problem that has originally lead to
LWG <a href="556">556</a>! We only need to look at 33.5.3 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> p15 to recognice this:
</p>
<blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
<p>
The negation expression here looks very familiar to the example provided in LWG <a href="556">556</a> and is sensitive
to the same "unusual proxy" problem. Changing the 33.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.req.paramname">[thread.req.paramname]</a> wording to a corresponding
"contextual conversion to <tt>bool</tt>" wouldn't work either, because existing specifications rely on "convertible
to <tt>bool</tt>", e.g. 33.5.3 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> p32+33+42 or 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a> 
p25+26+32+33.
<p/>
To summarize: I believe that LWG <a href="556">556</a> was not completely resolved. A pessimistic interpretation is,
that even with the current wording based on "contextually convertible to <tt>bool</tt>" the actual problem of that 
issue has <em>not</em> been fixed. What actually needs to be required here is some normative wording that basically
expresses something along the lines of:
</p>
<blockquote><p>
The semantics of <em>any</em> contextual conversion to <tt>bool</tt> shall be equivalent to the semantics of 
any implicit conversion to <tt>bool</tt>.
</p></blockquote>
<p>
This is still not complete without having concepts, but it seems to be a better approximation. Another way of solving
this issue would be to define a minimum requirements table with equivalent semantics. The proposed wording is a bit
simpler but attempts to express the same thing.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Agree with Daniel that we potentially broke some C++03 user code, accept the changes striking
"contextually" from tables.  Stefan to provide revised wording for section 25, and figure out
changes to section 30.
</p>
<p>
Move to open, and then to Review when updated wording from Stefan is available.
</p>

<p><i>[2012-10-12, STL comments]</i></p>


<ol>
<li>
<p>
The current proposed resolution still isn't completely satisfying. It would certainly be possible for the Standard to 
require these various expressions to be implicitly and contextually convertible to <tt>bool</tt>, but that would have 
a subtle consequence (which, I will argue, is undesirable - regardless of the fact that it dates all the way back to 
C++98/03). It would allow users to provide really wacky types to the Standard Library, with one of two effects:
</p>
<ol style="list-style-type:upper-alpha">
<li>
<p>Standard Library implementations would have to go to great lengths to respect such wacky types, essentially using 
<tt>static_cast&lt;bool&gt;</tt> when invoking any predicates or comparators.
</p>
</li>

<li>
<p>
Otherwise, such wacky types would be de facto nonportable, because they would make Standard Library implementations 
explode.
</p>
</li>
</ol>

<p>
Effect B is the status quo we're living with today. What Standard Library implementations want to do with <tt>pred(args)</tt> 
goes beyond "<tt>if (pred(args))</tt>" (C++03), contextually converting <tt>pred(args)</tt> to <tt>bool</tt> (C++11), or 
implicitly and contextually converting <tt>pred(args)</tt> to <tt>bool</tt> (the current proposed resolution). 
Implementations want to say things like:
</p>

<blockquote><pre>
if (pred(args))
if (!pred(args))
if (cond &amp;&amp; pred(args))
if (cond &amp;&amp; !pred(args))
</pre></blockquote>

<p>
These are real examples taken from Dinkumware's implementation. There are others that would be realistic 
("<tt>pred(args) &amp;&amp; cond</tt>", "<tt>cond || pred(args)</tt>", etc.)
<p/>
Although negation was mentioned in this issue's Discussion section, and in LWG <a href="556">556</a>'s, the current proposed 
resolution doesn't fix this problem. Requiring <tt>pred(args)</tt> to be implicitly and contextually convertible to <tt>bool</tt> 
doesn't prevent <tt>operator!()</tt> from being overloaded and returning <tt>std::string</tt> (as a wacky example). More 
ominously, it doesn't prevent <tt>operator&amp;&amp;()</tt> and <tt>operator||()</tt> from being overloaded and destroying 
short-circuiting.
</p>

</li>

<li>
<p>
I would like LWG input before working on Standardese for a new proposed resolution. Here's an outline of what I'd like to 
do:
</p>
<ol style="list-style-type:upper-alpha">
<li>
<p>
Introduce a new "concept" in 20.5.3 <a href="https://timsong-cpp.github.io/cppwp/utility.requirements">[utility.requirements]</a>, which I would call <tt>BooleanTestable</tt> in the 
absence of better ideas.
</p>
</li>

<li>
<p>
Centralize things and reduce verbosity by having everything simply refer to <tt>BooleanTestable</tt> when necessary. 
I believe that the tables could say "Return type: <tt>BooleanTestable</tt>", while Predicate/BinaryPredicate/Compare 
would need the incantation "shall satisfy the requirements of BooleanTestable".
</p>
</li>

<li>
<p>
Resolve the tug-of-war between users (who occasionally want to do weird things) and implementers (who don't want to have 
to contort their code) by requiring that:
</p>
<ol style="list-style-type:upper-roman">
<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>x</tt> is both implicitly and contextually convertible to <tt>bool</tt>.
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>!x</tt> is <tt>BooleanTestable</tt>. (This is intentionally "recursive".)
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>bool t = x, t2(x), f = !x;</tt> has the postcondition <tt>t == t2 &amp;&amp; t != f</tt>.
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt> and a <tt>BooleanTestable y</tt> of possibly different types, "<tt>x &amp;&amp; y</tt>" 
and "<tt>x || y</tt>" invoke the built-in <tt>operator&amp;&amp;()</tt> and <tt>operator||()</tt>, triggering short-circuiting.
</p>
</li>

<li>
<p>
<tt>bool</tt> is <tt>BooleanTestable</tt>.
</p>
</li>
</ol>

</li>

</ol>

<p>
 I believe that this simultaneously gives users great latitude to use types other than <tt>bool</tt>, while allowing 
 implementers to write reasonable code in order to get their jobs done. (If I'm forgetting anything that implementers 
 would want to say, please let me know.)
</p>

</li>

<li>
<p>
About requirement (I): As Daniel patiently explained to me, we need to talk about both implicit conversions and 
contextual conversions, because it's possible for a devious type to have both "<tt>explicit operator bool()</tt>" 
and "<tt>operator int()</tt>", which might behave differently (or be deleted, etc.).
</p>
</li>

<li>
<p>
About requirement (IV): This is kind of tricky. What we'd like to say is, "<tt>BooleanTestable</tt> can't ever trigger 
an overloaded logical operator". However, given a perfectly reasonable type <tt>Nice</tt> - perhaps even <tt>bool</tt> itself! - 
other code (perhaps a third-party library) could overload <tt>operator&amp;&amp;(Nice, Evil)</tt>. Therefore, I believe 
that the requirement should be "no first use" - the Standard Library will ask for various <tt>BooleanTestable</tt> types 
from users (for example, the result of "<tt>first != last</tt>" and the result of "<tt>pred(args)</tt>"), and as long 
as they don't trigger overloaded logical operators with each other, everything is awesome.
</p>
</li>


<li>
<p>
About requirement (V): This is possibly redundant, but it's trivial to specify, makes it easier for users to understand 
what they need to do ("oh, I can always achieve this with <tt>bool</tt>"), and provides a "base case" for requirement 
(IV) that may or may not be necessary.  Since <tt>bool</tt> is <tt>BooleanTestable</tt>, overloading 
<tt>operator&amp;&amp;(bool, Other)</tt> (etc.) clearly makes the <tt>Other</tt> type non-<tt>BooleanTestable</tt>.
</p>
</li>
</ol>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<p/>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change Table 25 &mdash; "<tt>NullablePointer</tt> requirements" in 20.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/nullablepointer.requirements">[nullablepointer.requirements]</a>
as indicated:</p>

<table border="1">
<caption>Table 25 &mdash; <tt>NullablePointer</tt> requirements</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
</tr> 

<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == b)</tt>
</td>
</tr>

<tr>
<td>
<tt>a == np<br/>
np == a</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>a == P()</tt>
</td>
</tr>

<tr>
<td>
<tt>a != np<br/>
np != a</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == np)</tt>
</td>
</tr>

</table>
 
</li>

<li><p>Change Table 107 &mdash; "Input iterator requirements" in 27.2.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>
as indicated:</p>

<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == b)</tt>
</td>
<td>
pre: <tt>(a, b)</tt> is in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

</table>
 
</li>

<li><p>Change Table 111 &mdash; "Random access iterator requirements" in 27.2.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>
as indicated:</p>

<table border="1">
<caption>Table 111 &mdash; Random access iterator requirements (in addition to bidirectional iterator)</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>b - a &gt; 0</tt>
</td>
<td>
<tt>&lt;</tt> is a total ordering relation
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>b &lt; a</tt>
</td>
<td>
<tt>&gt;</tt> is a total ordering relation opposite to <tt>&lt;</tt>.
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a &lt; b)</tt>
</td>
<td>
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a &gt; b)</tt>
</td>
<td>
</td>
</tr>

</table>
 
</li>

<li><p>Change 28.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a> p8+9 as indicated:</p>

<blockquote>
<p>
-8- The <tt>Predicate</tt> parameter is used whenever an algorithm expects a function object 
(23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>) that, when applied to the result of dereferencing the corresponding iterator, 
returns a value testable as <tt>true</tt>. In other words, if an algorithm takes <tt>Predicate pred</tt> 
as its argument and first as its iterator argument, it should work correctly in the construct 
<tt>pred(*first)</tt> <ins>implicitly or</ins> contextually converted to <tt>bool</tt> (Clause 7 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>). 
The function object <tt>pred</tt> shall not apply any non-constant function through the dereferenced iterator.
<p/>
-9- The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a function object that when applied
to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type
<tt>T</tt> when <tt>T</tt> is part of the signature returns a value testable as <tt>true</tt>. In other words, if an algorithm takes
<tt>BinaryPredicate binary_pred</tt> as its argument and <tt>first1</tt> and <tt>first2</tt> as its iterator arguments, it should
work correctly in the construct <tt>binary_pred(*first1, *first2)</tt> <ins>implicitly or</ins> contextually converted to 
<tt>bool</tt> (Clause 7 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>).
<tt>BinaryPredicate</tt> always takes the first iterator's <tt>value_type</tt> as its first argument, that is, in those cases
when <tt>T</tt> value is part of the signature, it should work correctly in the construct <tt>binary_pred(*first1, value)</tt> 
<ins>implicitly or</ins> contextually converted to <tt>bool</tt> (Clause 7 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>). <tt>binary_pred</tt> shall 
not apply any non-constant function through the dereferenced iterators.
</p>
</blockquote>
</li>

<li><p>Change 28.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- <tt>Compare</tt> is a function object type (23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>). The return value of the function 
call operation applied to an object of type <tt>Compare</tt>, when <ins>implicitly or</ins> contextually converted 
to <tt>bool</tt> (7 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>), yields <tt>true</tt> if the first argument of the call is less than the second, and 
<tt>false</tt> otherwise. <tt>Compare comp</tt> is used throughout for algorithms assuming an ordering relation. It is assumed 
that <tt>comp</tt> will not apply any non-constant function through the dereferenced iterator.
</p>
</blockquote>
</li>

<li><p>Change 33.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.req.paramname">[thread.req.paramname]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- <del>If a parameter is <tt>Predicate</tt>, operator() applied to the actual template argument shall return a value that
is convertible to <tt>bool</tt></del><ins><tt>Predicate</tt> is a function object type (23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>).
The return value of the function call operation applied to an object of type <tt>Predicate</tt>, when implicitly or 
contextually converted to <tt>bool</tt> (7 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>), yields <tt>true</tt> if the corresponding test condition is
satisfied, and <tt>false</tt> otherwise</ins>.
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2014-05-20, Daniel suggests concrete wording based on STL's proposal]</i></p>

<p>
The presented wording follows relatively closely STL's outline with the following notable exceptions:
</p>
<ol style="list-style-type:upper-alpha">
<li><p>
A reference to <tt>BooleanTestable</tt> in table "Return Type" specifications seemed very unusual to me and
I found no "prior art" for this in the Standard. Instead I decided to follow the usual style to add a symbol
with a specific meaning to a specific paragraph that specifies symbols and their meanings.
</p></li>
<li><p>
STL's requirement IV suggested to directly refer to built-in operators <tt>&amp;&amp;</tt> and <tt>||</tt>. In my
opinion this concrete requirement isn't needed if we simply require that two <tt>BooleanTestable</tt> operands behave 
equivalently to two those operands after conversion to <tt>bool</tt> (each of them).
</p></li>
<li><p>
I couldn't find a good reason to require normatively that type <tt>bool</tt> meets the requirements of <tt>BooleanTestable</tt>: My
assertion is that after having defined them, the result simply falls out of this. But to make this a bit clearer, I added
also a non-normative note to these effects.
</p></li>
</ol>

<p><i>[2014-06-10, STL comments]</i></p>

<p>
In the current wording I would like to see changed the suggested changes described by bullet #6:
</p>
<ol style="list-style-type:upper-alpha">
<li><p>In 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p4 undo the suggested change</p></li>
<li><p>Then change the 7 occurrences of "convertible to <tt>bool</tt>" in the denoted tables to "<tt>bool</tt>".</p></li>
</ol>

<p><i>[2015-05-05 Lenexa]</i></p>

<p>STL: Alisdair wanted to do something here, but Daniel gave us updated wording.</p>

<p><i>[2015-07 Telecon]</i></p>
<p>
Alisdair: Should specify we don't break short circuiting.<br/>
Ville: Looks already specified because that's the way it works for bool. <br/>
Geoffrey: Maybe add a note about the short circuiting.<br/>
B2/P2 is somewhat ambiguous. It implies that B has to be both implicitly convertible to bool and contextually convertible to bool.<br/>
We like this, just have nits.<br/>
Status stays Open.<br/>
Marshall to ping Daniel with feedback.<br/>
</p>

<p><i>[2016-02-27, Daniel updates wording]</i></p>

<ol>
<li>
<p>
The revised wording has been updated from N3936 to N4567. 
</p>
</li>
<li>
<p>
To satisfy the Kona 2015 committee comments, the wording in 
[booleantestable.requirements] has been improved to better separate the two different requirements of "can be 
contextually converted to <tt>bool</tt>" and "can be implicitly converted to <tt>bool</tt>. Both are necessary because 
it is possible to define a type that has the latter property but not the former, such as the following one:
</p>
<blockquote class="note">
<p>
2016-08-07, Daniel: The below example has been corrected to reduce confusion about the performed conversions as indicated
by the delta markers:
</p>
</blockquote>
<blockquote><pre>
using Bool = int;

struct OddBoolean 
{
  explicit <ins>operator bool() const = delete;
  operator Bool() const;</ins>
  <del>OddBoolean(bool) = delete;
  OddBoolean(Bool){}</del>
} <ins>ob</ins>;

<ins>bool b2 = ob; // OK
bool b1(ob);  // Error</ins>
<del>OddBoolean b2 = true; // OK
OddBoolean b1(true);  // Error</del>
<ins></ins>
</pre></blockquote>
</li>
<li>
<p>
In [booleantestable.requirements] a note has been added to ensure that an implementation is not allowed to 
break any short-circuiting semantics.
</p>
</li>
<li>
<p>
I decided to separate LWG <a href="2587">2587</a>/<a href="2588">2588</a> from this issue. Both these issues aren't exactly the
same but depending on the committee's position, their resolution might benefit from the new vocabulary introduced
here.
</p>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> p1, Table 17 &mdash; "EqualityComparable requirements", and
Table 18 &mdash; "LessThanComparable requirements" as indicated:</p>

<blockquote>
<p>
-1- [&hellip;] In these tables, <tt>T</tt> is an object or reference type to be supplied by a C++ program
instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are values of type (possibly <tt>const</tt>) <tt>T</tt>; 
<tt>s</tt> and <tt>t</tt> are modifiable lvalues of type <tt>T</tt>; <tt>u</tt> denotes an identifier; <tt>rv</tt> 
is an rvalue of type <tt>T</tt>; <del>and</del> <tt>v</tt> is an lvalue of type (possibly <tt>const</tt>) <tt>T</tt> or an
rvalue of type <tt>const T</tt><ins>; and <tt>BT</tt> denotes a type that meets the <tt>BooleanTestable</tt> 
requirements ([booleantestable.requirements])</ins>.
<p/>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 17 &mdash; <tt>EqualityComparable</tt> requirements [equalitycomparable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<tt>a == b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
<tt>==</tt> is an equivalence relation, that is, it has the
following properties: [&hellip;]
</td>
</tr>

</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 18 &mdash; <tt>LessThanComparable</tt> requirements [lessthancomparable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
<tt>&lt;</tt> is a strict weak ordering relation (28.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a>)
</td>
</tr>

</table>
</blockquote>

</blockquote>

</li>

<li><p>Between 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> and 20.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/nullablepointer.requirements">[nullablepointer.requirements]</a> insert a new sub-clause 
as indicated:</p>

<blockquote>
?.?.?.? <b><tt>BooleanTestable</tt> requirements [booleantestable.requirements]</b>  
<blockquote>
<p>
-?- A <tt>BooleanTestable</tt> type is a boolean-like type that also supports conversions to <tt>bool</tt>.
A type <tt>B</tt> meets the <tt>BooleanTestable</tt> requirements if the expressions described in Table ?? are valid 
and have the indicated semantics, and if <tt>B</tt> also satisfies all the other requirements of this sub-clause 
[booleantestable.requirements].
<p/>
An object <tt>b</tt> of type <tt>B</tt> can be implicitly converted to <tt>bool</tt> and in addition can be 
contextually converted to <tt>bool</tt> (Clause 4). The result values of both kinds of conversions shall be equivalent. 
<p/>
[<i>Example</i>: The types <tt>bool</tt>, <tt>std::true_type</tt>, and <tt>std::bitset&lt;&gt;::reference</tt> are 
<tt>BooleanTestable</tt> types. &mdash; <i>end example</i>]
<p/>
For the purpose of Table ??, let <tt>B2</tt> and <tt>Bn</tt> denote types (possibly both equal to <tt>B</tt> or to each other) 
that meet the <tt>BooleanTestable</tt> requirements, let <tt>b1</tt> denote a (possibly <tt>const</tt>) value of <tt>B</tt>, 
let <tt>b2</tt> denote a (possibly <tt>const</tt>) value of <tt>B2</tt>, and let <tt>t1</tt> denote a value of type 
<tt>bool</tt>.
<p/>
[<i>Note</i>: These rules ensure what an implementation can rely on but doesn't grant it
license to break short-circuiting behavior of a <tt>BooleanTestable</tt> type. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Somewhere within the new sub-clause [booleantestable.requirements] insert the following new Table (?? denotes
the assigned table number):</p>

<blockquote>
<table border="1">
<caption>Table ?? &mdash; <tt>BooleanTestable</tt> requirements [booleantestable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational semantics</th>
</tr>

<tr>
<td>
<tt>bool(b1)</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<i>Remarks</i>: <tt>bool(b1) == t1</tt> for every value<br/>
<tt>b1</tt> implicitly converted to <tt>t1</tt>.
</td>
</tr>

<tr>
<td>
<tt>!b1</tt>
</td>
<td>
<tt>Bn</tt>
</td>
<td>
<i>Remarks</i>: <tt>bool(b1) == !bool(!b1)</tt> for<br/>
every value <tt>b1</tt>.
</td>
</tr>

<tr>
<td>
<tt>b1 &amp;&amp; b2</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<tt>bool(b1) &amp;&amp; bool(b2)</tt>
</td>
</tr>

<tr>
<td>
<tt>b1 || b2</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<tt>bool(b1) || bool(b2)</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 20.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/nullablepointer.requirements">[nullablepointer.requirements]</a> p5 and Table 25 &mdash; "NullablePointer requirements" as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-5- In Table 25, <tt>u</tt> denotes an identifier, <tt>t</tt> denotes a non-<tt>const</tt> lvalue of type <tt>P</tt>, <tt>a</tt> 
and <tt>b</tt> denote values of type (possibly <tt>const</tt>) <tt>P</tt>, <del>and</del> <tt>np</tt> denotes a value of type 
(possibly <tt>const</tt>) <tt>std::nullptr_t</tt><ins>, and <tt>BT</tt> denotes a type that meets the <tt>BooleanTestable</tt> 
requirements ([booleantestable.requirements])</ins>.
<p/>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 25 &mdash; <tt>NullablePointer</tt> requirements [nullablepointer]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational semantics</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a == np</tt><br/>
<tt>np == a</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a != np</tt><br/>
<tt>np != a</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> as indicated;</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: For all <tt>i</tt>, where <tt>0 &lt;= i</tt> and <tt>i &lt; sizeof...(TTypes)</tt>, 
<tt>get&lt;i&gt;(t) == get&lt;i&gt;(u)</tt> is a valid expression returning a type that <del>is convertible to 
<tt>bool</tt></del><ins>meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>. 
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-4- <i>Requires</i>: For all <tt>i</tt>, where <tt>0 &lt;= i</tt> and <tt>i &lt; sizeof...(TTypes)</tt>, 
<tt>get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</tt> and <tt>get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</tt> are valid 
expressions returning types that <del>are convertible to 
<tt>bool</tt></del><ins>meet the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>. 
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, Table 95 &mdash; "Container requirements", and
Table 97 &mdash; "Optional container operations" as indicated:</p>

<blockquote>
<p>
-4- In Tables 95, 96, and 97 <tt>X</tt> denotes a container class containing objects of type <tt>T</tt>, <tt>a</tt> and 
<tt>b</tt> denote values of type <tt>X</tt>, <tt>u</tt> denotes an identifier, <tt>r</tt> denotes a non-<tt>const</tt> value 
of type <tt>X</tt>, <del>and</del> <tt>rv</tt> denotes a non-<tt>const</tt> rvalue of type <tt>X</tt><ins>, and <tt>BT</tt> 
denotes a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>.
</p>
<blockquote>
<table border="1">
<caption>Table 95 &mdash; Container requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a == b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.empty()</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 97 &mdash; Optional container requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>, Table 106 &mdash; "Input iterator requirements", and
Table 110 &mdash; "Random access iterator requirements" as indicated:</p>

<blockquote>
<p>
-12- In the following sections, <tt>a</tt> and <tt>b</tt> denote values of type <tt>X</tt> or <tt>const X</tt>, 
<tt>difference_type</tt> and <tt>reference</tt> refer to the types <tt>iterator_traits&lt;X&gt;::difference_type</tt> and 
<tt>iterator_traits&lt;X&gt;::reference</tt>, respectively, <tt>n</tt> denotes a value of <tt>difference_type</tt>, <tt>u</tt>, 
<tt>tmp</tt>, and <tt>m</tt> denote identifiers, <tt>r</tt> denotes a value of <tt>X&amp;</tt>, <tt>t</tt> denotes
a value of value type <tt>T</tt>, <tt>o</tt> denotes a value of some type that is writable to the output iterator<ins>, and <tt>BT</tt> 
denotes a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>.
</p>
<blockquote>
<table border="1">
<caption>Table 106 &mdash; Input iterator requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>
</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 110 &mdash; Random access iterator requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 28.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a> p8+p9 as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording changes below also fix
(a) unusual wording forms used ("should work") which are unclear in which sense they are imposing normative requirements and
(b) the problem, that the current wording seems to allow that the predicate may mutate a call argument, if that is not a 
dereferenced iterator.
Upon applying the new wording it became obvious that the both the previous and the new wording has the effect that currently 
algorithms such as <tt>adjacent_find</tt>, <tt>search_n</tt>, <tt>unique</tt>, and <tt>unique_copy</tt> are not correctly 
described (because they have no iterator argument named <tt>first1</tt>), which could give raise to a new library issue. 
&mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<p>
-8- The <tt>Predicate</tt> parameter is used whenever an algorithm expects a function object (20.9) that, when applied
to the result of dereferencing the corresponding iterator, returns a value testable as <tt>true</tt>. <del>In other words,
i</del><ins>I</ins>f an algorithm takes <tt>Predicate pred</tt> as its argument and <tt>first</tt> as its iterator argument, 
<del>it should work correctly in the construct <tt>pred(*first)</tt> contextually converted to 
<tt>bool</tt> (Clause 4)</del><ins>the expression <tt>pred(*first)</tt> shall have a type that meets the <tt>BooleanTestable</tt> 
requirements ( [booleantestable.requirements])</ins>. 
The function object <tt>pred</tt> shall not apply any non-constant function through <del>the dereferenced 
iterator</del><ins>its argument</ins>.
<p/>
-9- The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a function object that when applied
to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type
<tt>T</tt> when <tt>T</tt> is part of the signature returns a value testable as <tt>true</tt>. <del>In other words, 
i</del><ins>I</ins>f an algorithm takes <tt>BinaryPredicate binary_pred</tt> as its argument and <tt>first1</tt> and 
<tt>first2</tt> as its iterator arguments, <del>it should work correctly in the construct <tt>binary_pred(*first1, *first2)</tt> 
contextually converted to <tt>bool</tt> (Clause 4)</del><ins>the expression <tt>binary_pred(*first1, *first2)</tt> shall 
have a type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements])</ins>. 
<tt>BinaryPredicate</tt> always takes the first iterator's <tt>value_type</tt> as its first argument, that is, in those cases 
when <tt>T</tt> value is part of the signature, <del>it should work correctly in the construct <tt>binary_pred(*first1, value)</tt> 
contextually converted to <tt>bool</tt> (Clause 4)</del><ins>the expression <tt>binary_pred(*first1, value)</tt> shall have a 
type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements])</ins>. <tt>binary_pred</tt> 
shall not apply any non-constant function through <del>the dereferenced iterators</del><ins>any of its arguments</ins>.
</p>
</blockquote>
</li>

<li><p>Change 28.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> p2 as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-2- <tt>Compare</tt> is a function object type (20.9). <del>The return value of the function call 
operation applied to an object of type <tt>Compare</tt>, when contextually converted 
to <tt>bool</tt>(Clause 4), yields <tt>true</tt> if the first argument of the call is less than the second, 
and <tt>false</tt> otherwise.</del> <tt>Compare comp</tt> is used throughout for algorithms assuming an ordering relation. 
<ins>Let <tt>a</tt> and <tt>b</tt> denote two argument values whose types depend on the corresponding algorithm. Then the expression 
<tt>comp(a, b)</tt> shall have a type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements]).
The return value of <tt>comp(a, b)</tt>, converted to <tt>bool</tt>, yields <tt>true</tt> if the 
first argument <tt>a</tt> is less than the second argument <tt>b</tt>, and <tt>false</tt> otherwise.</ins> It is assumed that 
<tt>comp</tt> will not apply any non-constant function through <del>the dereferenced iterator</del><ins>any of its arguments</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
</li>

<li><p>Change 30.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a> and Table 126 &mdash; "Position type requirements" as indicated:</p>

<blockquote>
<p>
-1- Operations specified in Table 126 are permitted. In that table,
</p>
<ul>
<li><p><tt>P</tt> refers to an instance of <tt>fpos</tt>,</p></li>
<li><p>[&hellip;]</p></li>
<li><p><tt>o</tt> refers to a value of type <tt>streamoff</tt>,</p></li>
<li><p><ins><tt>BT</tt> refers to a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements]),</ins></p></li>
<li><p>[&hellip;]</p></li>
</ul>
<blockquote>
<table border="1">
<caption>Table 126 &mdash; Position type requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>p == q</tt>
</td>
<td>
<del>convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>p != q</tt>
</td>
<td>
<del>convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
<blockquote>
</blockquote>
</li>

<li><p>Change 33.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.req.paramname">[thread.req.paramname]</a> p1 as indicated:</p>

<blockquote>
<p>
-1- Throughout this Clause, the names of template parameters are used to express type requirements. <del>If a template
parameter is named <tt>Predicate</tt>, <tt>operator()</tt> applied to the template argument shall return a value that
is convertible to <tt>bool</tt></del><ins><tt>Predicate</tt> is a function object type (23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>).
Let <tt>pred</tt> denote an lvalue of type <tt>Predicate</tt>. Then the expression <tt>pred()</tt> shall have a type that meets the 
<tt>BooleanTestable</tt> requirements ( [booleantestable.requirements]). The return value of <tt>pred()</tt>, 
converted to <tt>bool</tt>, yields <tt>true</tt> if the corresponding test condition is satisfied, and <tt>false</tt> otherwise</ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2115" href="2115">2115.</a> Undefined behaviour for <tt>valarray</tt> assignments with <tt>mask_array</tt> index?</h3>
<p><b>Section:</b> 29.7.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2011-12-10 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Recently I received a Service Request (SR) alleging that one of our testcases causes an 
undefined behavior. The complaint is that 29.7.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a> in C++11 
(and the corresponding subclause in C++03) are interpreted by some people to require that 
in an assignment "<tt>a[mask] = b</tt>", the subscript <tt>mask</tt> and the rhs <tt>b</tt> 
must have the same number of elements.
<p/>
IMHO, if that is the intended requirement, it should be stated explicitly.
<p/>
In any event, there is a tiny editorial cleanup that could be made:
<p/>
In C++11, 29.7.8.1 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array.overview">[template.mask.array.overview]</a> para 2 mentions
</p>
<blockquote><p>
"the expression <tt>a[mask] = b;</tt>"
</p></blockquote>
<p>
but the semicolon cannot be part of an expression. The correction could omit the 
semicolon, or change the word "expression" to "assignment" or "statement".
<p/>
Here is the text of the SR, slightly modified for publication:
</p>
<blockquote>
<p>
Subject:  SR01174 LVS _26322Y31 has undefined behavior [open]
<p/>
[Client:]<br/>
The test case t263.dir&#47;_26322Y31.cpp seems to be illegal as it has an undefined 
behaviour. I searched into the SRs but found SRs were not related to the topic 
explained in this mail (SR00324, SR00595, SR00838).
</p>
<blockquote><pre>
const char vl[] = {"abcdefghijklmnopqrstuvwxyz"};
const char vu[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
const std::valarray&lt;char&gt; v0(vl, 27), vm5(vu, 5), vm6(vu, 6);
std::valarray&lt;char&gt; x = v0;
[&hellip;]
const bool vb[] = {false, false, true, true, false, true};
const std::valarray&lt;bool&gt; vmask(vb, 6);
x = v0;
x[vmask] = vm5;      // ***** HERE....
steq(&amp;x[0], "abABeCghijklmnopqrstuvwxyz");
x2 = x[vmask];       // ***** ....AND HERE
[&hellip;]
</pre></blockquote>
<p>
This problem has already been discussed between [experts]:
See thread <a href="http://gcc.gnu.org/ml/libstdc++/2009-11/threads.html#00051">http:&#47;&#47;gcc.gnu.org&#47;ml&#47;libstdc++&#47;2009-11&#47;threads.html#00051</a> 
Conclusion <a href="http://gcc.gnu.org/ml/libstdc++/2009-11/msg00099.html">http:&#47;&#47;gcc.gnu.org&#47;ml&#47;libstdc++&#47;2009-11&#47;msg00099.html</a>
<p/>
[Plum Hall:]<br/>
Before I log this as an SR, I need to check one detail with you.
<p/>
I did read the email thread you mentioned, and I did find a citation (see INCITS ISO&#47;IEC 14882-2003 
Section 26.3.2.6 on valarray computed assignments):
<p/>
Quote: "If the array and the argument array do not have the same length, the behavior is undefined",
<p/>
But this applies to computed assignment (<tt>*=</tt>, <tt>+=</tt>, etc), not to simple assignment. Here is the C++03 citation 
re simple assignment:
<p/>
26.3.2.2 valarray assignment [lib.valarray.assign]
</p>
<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp;);
</pre><blockquote>
<p>
1 Each element of the <tt>*this</tt> array is assigned the value of the corresponding element of the argument array.
The resulting behavior is undefined if the length of the argument array is not equal to the length of the
<tt>*this</tt> array.
</p>
</blockquote></blockquote>
<p>
In the new C++11 (N3291), we find ...
<p/>
26.6.2.3 valarray assignment [valarray.assign]
</p>
<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp; v);
</pre><blockquote>
<p>
1 Each element of the <tt>*this</tt> array is assigned the value of the corresponding element of the argument
array. If the length of <tt>v</tt> is not equal to the length of <tt>*this</tt>, resizes <tt>*this</tt> to make 
the two arrays the same length, as if by calling <tt>resize(v.size())</tt>, before performing the assignment.
</p>
</blockquote></blockquote>
<p>
So it looks like the testcase might be valid for C++11 but not for C++03; what do you think?
<p/>
[Client:]<br/>
I quite agree with you but the two problems I mentioned:
</p>
<blockquote><pre>
x[vmask] = vm5;      // ***** HERE....
[&hellip;]
x2 = x[vmask];       // ***** ....AND HERE
</pre></blockquote>
<p>
refer to <tt>mask_array</tt> assignment hence target the C++03 26.3.8 paragraph. Correct?
<p/>
[Plum Hall:]<br/>
I mentioned the contrast between C++03 26.3.2.2 para 1 versus C++11 26.6.2.3 para 1.
<p/>
But in C++03 26.3.8, I don't find any corresponding restriction. Could you quote the specific 
requirement you're writing about?
<p/>
[Client:]<br/>
I do notice the difference between c++03 26.3.2.2 and c++11 26.6.2.3 about assignments between 
different sized <tt>valarray</tt> and I perfectly agree with you.
<p/>
But, as already stated, this is not a simple <tt>valarray</tt> assignment but a
<tt>mask_array</tt> assignment (c++03 26.3.8 &#47; c++11 26.6.8). See c++11 quote below:
<p/>
26.6.8 Class template mask_array<br/>
26.6.8.1 Class template mask_array overview<br/>
[....]
</p>
<ol>
<li><p>This template is a helper template used by the mask subscript operator:
<tt>mask_array&lt;T&gt; valarray&lt;T&gt;::operator[](const valarray&lt;bool&gt;&amp;)</tt>.
</p></li>
<li><p>It has reference semantics to a subset of an array specified by a boolean mask. Thus, 
the expression <tt>a[mask] = b;</tt> has the effect of assigning <em>the elements of <tt>b</tt></em> 
to the masked elements in <tt>a</tt> (those for which the corresponding element in <tt>mask</tt> is true.)
</p></li>
</ol>
<p>
26.6.8.2 mask_array assignment
</p>
<blockquote><pre>
void operator=(const valarray&lt;T&gt;&amp;) const;
const mask_array&amp; operator=(const mask_array&amp;) const;
</pre><blockquote>
<p>
1 These assignment operators have reference semantics, assigning the values of the argument array 
elements to selected elements of the <tt>valarray&lt;T&gt;</tt> object to which it refers.
</p>
</blockquote></blockquote>
<p>
In particular, [one of the WG21 experts] insisted on the piece "the elements of <tt>b</tt>".
<p/>
That is why I reported the test t263.dir&#47;_26322Y31.cpp having an undefined behaviour.
<p/>
[Plum Hall:]<br/>
OK, I can see that I will have to ask WG21; I will file an appropriate issue 
with the Library subgroup. In the meantime, I will mark this testcase as "DISPUTED" 
so that it is not required for conformance testing, until we get a definitive opinion.
</p>
</blockquote>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Open.
</p>
<p>
There appears to be a real need for clarification in the standard, and
implementations differ in their current interpretation.  This will need
some research by implementers and a proposed resolution before further
discussion is likely to be fruitful.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2116" href="2116">2116.</a> <tt>is_nothrow_constructible</tt> and destructors</h3>
<p><b>Section:</b> 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2017-01-30 17:01:50 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
IMO if we specified <tt>is_[nothrow_]constructible</tt> in terms of a variable
declaration whose validity requires destructibility, it is clearly a bug
in our specification and a failure to realize the actual original
intent. The specification should have been in terms of placement-new.
<p/>
Daniel:<br/>
At the time of the specification this was intended and the solution is
<em>not</em> done by removing the destruction semantics of <tt>is_constructible</tt>.
<p/>
The design of <tt>is_constructible</tt> was also impacted by the previous
<tt>Constructible</tt> concept that <em>explicitly</em> contained destruction semantics,
because during conceptification of the library it turned out to simplify
the constraints  in the library because you did not need to add
<tt>Destructible</tt> all the time. It often was implied but never spoken out
in C++03.
<p/>
Pure construction semantics was considered as useful as well, so <tt>HasConstructor</tt> 
did also exist and would surely be useful as trait as well.
<p/>
Another example that is often overlooked: This also affects wrapper types like <tt>pair</tt>, 
<tt>tuple</tt>, <tt>array</tt> that contain potentially more than one type:
This is easy to understand if you think of <tt>T1</tt> having a deleted destructor
and <tt>T2</tt> having a constructor that may throw: Obviously the compiler has
potentially need to use the <tt>destructor</tt> of <tt>T1</tt> in the <em>constructor</em>
of <tt>std::pair&lt;T1, T2&gt;</tt> to ensure that the core language requirements
are satisfied (All previous fully constructed sub-objects must be destructed).
<p/>
The core language also honors this fact in 15.8 <a href="https://timsong-cpp.github.io/cppwp/class.copy">[class.copy]</a> p11:
</p>
<blockquote><p>
A defaulted copy&#47;move constructor for a class <tt>X</tt> is defined as deleted (11.4.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.fct.def.delete">[dcl.fct.def.delete]</a>) 
if <tt>X</tt> has:<br/>
[&hellip;]<br/>
&mdash; any direct or virtual base class or non-static data member of a type with a destructor that is deleted
or inaccessible from the defaulted constructor,<br/>
[&hellip;]
</p></blockquote>
<p>
Dave:<br/>
This is about <tt>is_nothrow_constructible</tt> in particular. The fact that it is 
foiled by not having a <tt>noexcept</tt> dtor is a defect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
<tt>is_nothrow_constructible</tt> is defined in terms of <tt>is_constructible</tt>, which is defined
by looking at a hypothetical variable and asking whether the variable definition is known not to
throw exceptions. The issue claims that this also examines the type's destructor, given the context,
and thus will return <tt>false</tt> if the destructor can potentially throw. At least one
implementation (Howard's) does return <tt>false</tt> if the constructor is <tt>noexcept(true)</tt>
and the destructor is <tt>noexcept(false)</tt>. So that's not a strained interpretation.
The issue is asking for this to be defined in terms of placement <tt>new</tt>, instead of in terms
of a temporary object, to make it clearer that <tt>is_nothrow_constructible</tt> looks at the
<tt>noexcept</tt> status of only the constructor, and not the destructor.
</p>
<p>
Sketch of what the wording would look like:
</p>
<p>
require <tt>is_constructible</tt>, and then also require that a placement <tt>new</tt> operation
does not throw. (Remembering the title of this issue... What does this imply for <tt>swap</tt>?
</p>
<p>
If we accept this resolution, do we need any changes to <tt>swap</tt>?
</p>
<p> STL argues: no, because you are already forbidden from passing anything with a throwing
desturctor to <tt>swap</tt>.
</p>
<p>
Dietmar argues: no, not true. Maybe statically the destructor can conceivably throw for some
values, but maybe there are some values known not to throw. In that case, it's correct to
pass those values to <tt>swap</tt>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Gave the issue a better title</p>
<p>This issue interacts with <a href="2827">2827</a></p>
<p>Ville would like "an evolution group" to take a look at this issue.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2117" href="2117">2117.</a> <tt>ios_base</tt> manipulators should have <tt>showgrouping&#47;noshowgrouping</tt></h3>
<p><b>Section:</b> 25.4.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>, 30.5.3.1.2 <a href="https://timsong-cpp.github.io/cppwp/ios::fmtflags">[ios::fmtflags]</a>, 30.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/fmtflags.manip">[fmtflags.manip]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2011-12-15 <b>Last modified:</b> 2016-04-16 04:04:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Iostreams should include a manipulator to toggle grouping on&#47;off for
locales that support grouped digits. This has come up repeatedly and
been deferred. See LWG <a href="826">826</a> for the previous attempt.
<p/>
If one is using a locale that supports grouped digits, then output
will always include the generated grouping characters. However, very
plausible scenarios exist where one might want to output the number,
un-grouped. This is similar to existing manipulators that toggle
on&#47;off the decimal point, numeric base, or positive sign.
<p/>
See some user commentary <a href="http://www.tablix.org/~avian/blog/archives/2008/01/c_streams_suck/">here</a>.
</p>


<p><i>[21012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
This is a feature request.
</p>
<p>
Walter is slightly uncomfortable with processing feature requests through the issues lists.
</p>
<p>
Alisdair says this is far from the first feature request that has come in from the issues list.
</p>
<p>
STL: The fact that you can turn off grouping on hex output is compelling.
</p>
<p>
Marshall: if we add this flag, we'll need to update tables 87-91 as well.
</p>
<p>
STL: If it has been implemented somewhere, and it works, we'd be glad to add it.
</p>
<p>
Howard: We need to say what the default is.
</p>
<p>
Alisdair sumarizes:
</p>
<p>
(1) We want clear wording that says what the effect is of turning the flag off;
</p>
<p>
(2) what the default values are, and
</p>
<p>
(3) how this fits into tables 87-90. (and 128)
</p>

<p><i>[Issaquah 2014-02-10-12: Move to LEWG]</i></p>

<p>
Since this issue was filed, we have grown a new working group that is better placed to handle feature requests.
</p>
<p>
We will track such issues with an LEWG status until we get feedback from the Library Evolution Working Group.
</p>

<p><i>[Issaquah 2014-02-12: LEWG discussion]</i></p>


<table>
  <caption>Do we think this feature should exist?</caption>
  <tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
  <tr><td>2</td> <td>4</td><td>1</td><td>0</td><td>0</td></tr>
</table>

<p>Think about the ABI break for adding a flag. But this could be
mitigated by putting the data into an iword instead of a flag.</p>

<p>This needs to change Stage 2 in [facet.num.put.virtuals].</p>

<p>Previous resolution, which needs the above corrections:</p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Insert in 25.4.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> paragraph 5:</p>

<blockquote><p>
<strong>Stage 1</strong>: The first action of stage 1 is to determine a conversion specifier. The tables that describe
this determination use the following local variables
</p>
<pre>
fmtflags flags = str.flags() ;
fmtflags basefield = (flags &amp; (ios_base::basefield));
fmtflags uppercase = (flags &amp; (ios_base::uppercase));
fmtflags floatfield = (flags &amp; (ios_base::floatfield));
fmtflags showpos = (flags &amp; (ios_base::showpos));
fmtflags showbase = (flags &amp; (ios_base::showbase));
<ins>fmtflags showgrouping = (flags &amp; (ios_base::showgrouping));</ins>
</pre>
</blockquote>
</li>

<li><p>Change header <tt>&lt;ios&gt;</tt> synopsis,  [iostreams.base.overview] as indicated:</p>

<blockquote><pre>
#include &lt;iosfwd&gt;

namespace std {
  [&hellip;]
  <i>// 27.5.6, manipulators:</i>
  [&hellip;]
  ios_base&amp; showpoint     (ios_base&amp; str);
  ios_base&amp; noshowpoint   (ios_base&amp; str);
  <ins>ios_base&amp; showgrouping  (ios_base&amp; str);</ins>
  <ins>ios_base&amp; noshowgrouping(ios_base&amp; str);</ins>
  ios_base&amp; showpos       (ios_base&amp; str);
  ios_base&amp; noshowpos     (ios_base&amp; str);
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change class <tt>ios_base</tt> synopsis, 30.5.3 <a href="https://timsong-cpp.github.io/cppwp/ios.base">[ios.base]</a> as indicated:</p>

<blockquote><pre>
namespace std {
  class ios_base {
  public:
  class failure;
    <i>// 27.5.3.1.2 fmtflags</i>
    typedef <i>T1</i> fmtflags;
    [&hellip;]
    static constexpr fmtflags showpoint = <i>unspecified</i> ;
    <ins>static constexpr fmtflags showgrouping = <i>unspecified</i> ;</ins>
    static constexpr fmtflags showpos = <i>unspecified</i> ;
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Add a new entry to Table 122 &mdash; "<tt>fmtflags</tt> effects" as indicated:</p>

<table border="1">
<caption>Table 122 &mdash; <tt>fmtflags</tt> effects</caption>
<tr align="center">
<th>Element</th>
<th>Effect(s) if set</th>
</tr> 

<tr>
<td colspan="2" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>showpoint</tt>
</td>
<td>
generates a decimal-point character unconditionally in generated floatingpoint output
</td>
</tr>

<tr>
<td>
<ins><tt>showgrouping</tt></ins>
</td>
<td>
<ins>generates grouping characters unconditionally in generated output</ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

</table>
 
</li>

<li><p>After 30.5.3.1.2 <a href="https://timsong-cpp.github.io/cppwp/ios::fmtflags">[ios::fmtflags]</a> p12 insert the following:</p>
<blockquote><pre>
<ins>ios_base&amp; showgrouping(ios_base&amp; str);</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Effects</i>: Calls <tt>str.setf(ios_base::showgrouping)</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>str</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>ios_base&amp; noshowgrouping(ios_base&amp; str);</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Effects</i>: Calls <tt>str.unsetf(ios_base::showgrouping)</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>str</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>

</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2121" href="2121">2121.</a> <tt>app</tt> for string streams</h3>
<p><b>Section:</b> 30.8.5.1 <a href="https://timsong-cpp.github.io/cppwp/stringstream.cons">[stringstream.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2012-01-15 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This issue was raised while discussing issue <a href="1448">1448</a>.
<p/>
Note the following program:
</p>
<blockquote><pre>
string s("s1: 123456789");
ostringstream s1(s, ios_base::out|ios_base::app);
s1 &lt;&lt; "hello";
cout &lt;&lt; s1.str() &lt;&lt; endl;
</pre></blockquote>
<p>
With g++4.x it prints:
</p>
<blockquote><pre>
s1: 123456789hello
</pre></blockquote>
<p>
With VisualC++10 it prints:
</p>
<blockquote><pre>
hello23456789
</pre></blockquote>
<p>
From my intuitive understanding the flag "app" should result in the output of g++4.x.
I also would read that from 30.5.3.1.4 <a href="https://timsong-cpp.github.io/cppwp/ios::openmode">[ios::openmode]</a> claiming:
</p>
<blockquote><p>
<tt>app</tt>&nbsp;&nbsp;&nbsp;seek to end before each write
</p></blockquote>
<p>
However in issue <a href="1448">1448</a> P.J.Plauger comments:
</p>
<blockquote><p>
I think we should say nothing special about <tt>app</tt> at construction time (thus leaving the write pointer at the beginning of the buffer).
Leave implementers wiggle room to ensure subsequent append writes as they see fit, but don't change existing rules for initial seek
position.
</p></blockquote>
<p>
Note that the flag <tt>ate</tt> on both platforms appends "hello" to <tt>s</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2136" href="2136">2136.</a> Postconditions vs. exceptions</h3>
<p><b>Section:</b> 20.4.1 <a href="https://timsong-cpp.github.io/cppwp/structure">[structure]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The front matter in clause 17 should clarify that postconditions will not hold if a 
standard library function exits via an exception. Postconditions or guarantees that 
apply when an exception is thrown (beyond the basic guarantee) are described in an 
"Exception safety" section.
</p>

<p><i>[
2012-10 Portland: Move to Open
]</i></p>


<p>
Consensus that we do not clearly say this, and that we probably should.  A likely
location to describe the guarantees of <i>postconditions</i> could well be a new
sub-clause following 20.5.4.11 <a href="https://timsong-cpp.github.io/cppwp/res.on.required">[res.on.required]</a> which serves the same purpose
for <i>requires</i> clauses.  However, we need such wording before we can make
progress.
</p>

<p>
Also, see <a href="2137">2137</a> for a suggestion that we want to see a paper resolving
both issues together.
</p>

<p><i>[2015-05-06 Lenexa: EirkWF to write paper addressing 2136 and 2137]</i></p>

<p>MC: Idea is to replace all such "If no exception" postconditions with "Exception safety" sections.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2137" href="2137">2137.</a> Misleadingly constrained post-condition in the presence of exceptions</h3>
<p><b>Section:</b> 31.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex.assign">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The post-conditions of <tt>basic_regex&lt;&gt;::assign</tt> 31.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a> p16 say:
</p>
<blockquote><p>
<span style="color:#C80000;font-weight:bold">If no exception is thrown,</span> <tt>flags()</tt> returns 
<tt>f</tt> and <tt>mark_count()</tt> returns the number of marked sub-expressions within the expression.
</p></blockquote>
<p>
The default expectation in the library is that post-conditions only hold, if there is no failure 
(see also <a href="2136">2136</a>), therefore the initial condition should be removed to prevent any
misunderstanding.
</p>

<p><i>[
2012-10 Portland: Move to Open
]</i></p>


<p>
A favorable resolution clearly depends on a favorable resolution to <a href="2136">2136</a>.
There is also a concern that this is just one example of where we would want to apply
such a wording clean-up, and which is really needed to resolve both this issue and
<a href="2136">2136</a> is a paper providing the clause 17 wording that gives the guarantee
for <i>postcondition</i> paragaraphs, and then reviews clauses 18-30 to apply that
guarantee consistently.  We do not want to pick up these issues piecemeal, as we risk
openning many issues in an ongoing process.
</p>

<p><i>[2015-05-06 Lenexa: EirkWF to write paper addressing 2136 and 2137]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<blockquote><pre>
template &lt;class string_traits, class A&gt;
  basic_regex&amp; assign(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
    flag_type f = regex_constants::ECMAScript);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Effects</i>: Assigns the regular expression contained in the string <tt>s</tt>, interpreted according 
the flags specified in <tt>f</tt>. If an exception is thrown, <tt>*this</tt> is unchanged.
<p/>
-16- <i>Postconditions</i>: <del>If no exception is thrown,</del> <tt>flags()</tt> returns <tt>f</tt> and 
<tt>mark_count()</tt> returns the number of marked sub-expressions within the expression.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="2139" href="2139">2139.</a> What is a <em>user-defined</em> type?</h3>
<p><b>Section:</b> 20.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>, 22.5 <a href="https://timsong-cpp.github.io/cppwp/syserr">[syserr]</a>, 23.10.7.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.trait">[allocator.uses.trait]</a>, 23.14.11.1 <a href="https://timsong-cpp.github.io/cppwp/func.bind.isbind">[func.bind.isbind]</a>, 23.14.11.2 <a href="https://timsong-cpp.github.io/cppwp/func.bind.isplace">[func.bind.isplace]</a>, 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>, 23.15.7.6 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a>, 25.3.1 <a href="https://timsong-cpp.github.io/cppwp/locale">[locale]</a>, 25.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a>, 31.12.1.4 <a href="https://timsong-cpp.github.io/cppwp/re.regiter.incr">[re.regiter.incr]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lo&iuml;c Joly <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#namespace.std">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The expression "user-defined type" is used in several places in the standard, but I'm not sure what 
it means. More specifically, is a type defined in the standard library a user-defined type?
<p/>
From my understanding of English, it is not. From most of the uses of this term in the standard, it 
seem to be considered as user defined. In some places, I'm hesitant, e.g. 20.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> p1:
</p>
<blockquote><p>
A program may add a template specialization for any standard library template to namespace <tt>std</tt> 
only if the declaration depends on a user-defined type and the specialization meets the standard library 
requirements for the original template and is not explicitly prohibited.
</p></blockquote>
<p>
Does it mean we are allowed to add in the namespace <tt>std</tt> a specialization for 
<tt>std::vector&lt;std::pair&lt;T, U&gt;&gt;</tt>, for instance?
<p/>
Additional remarks from the reflector discussion: The traditional meaning of user-defined types refers
to class types and enum types, but the library actually means here user-defined types that are not
(purely) library-provided. Presumably a new term - like <em>user-provided type</em> - should be introduced
and properly defined.
</p>

<p><i>[
2012-10 Portland: Move to Deferred 
]</i></p>


<p>
The issue is real, in that we never define this term and rely on a "know it when I see it"
intuition.  However, there is a fear that any attempt to pin down a definition is more
likely to introduce bugs than solve them - getting the wording for this precisely correct
is likely far more work than we are able to give it.
</p>

<p>
There is unease at simple closing as NAD, but not real enthusiasm to provide wording either.
Move to Deferred as we are not opposed to some motivated individual coming back with full
wording to review, but do not want to go out of our way to encourage someone to work on this
in preference to other issues.
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2015-03-05 Jonathan suggests wording]</i></p>

<p>
I dislike the suggestion to change to "user-provided" type because I already find the 
difference between user-declared / user-provided confusing for special member functions, 
so I think it would be better to use a completely different term. The core language
uses "user-defined conversion sequence" and "user-defined literal" and
similar terms for things which the library provides, so I think we
should not refer to "user" at all to distinguish entities defined
outside the implementation from things provided by the implementation.
<p/>
I propose "program-defined type" (and "program-defined specialization"), defined below. 
The P/R below demonstrates the scope of the changes required, even if this name isn't adopted. 
I haven't proposed a change for "User-defined facets" in [locale].
</p>

<p><i>[Lenexa 2015-05-06]</i></p>

<p>RS, HT: The core language uses "user-defined" in a specific way, including library things but excluding core language things, let's use a different term.</p>
<p>MC: Agree.</p>
<p>RS: "which" should be "that", x2</p>
<p>RS: Is std::vector&lt;MyType&gt; a "program-defined type"?</p>
<p>MC: I think it should be.</p>
<p>TK: std::vector&lt;int&gt; seems to take the same path.</p>
<p>JW: std::vector&lt;MyType&gt; isn't program-defined, we don't need it to be, anything that depends on that also depends on =MyType.</p>
<p>TK: The type defined by an "explicit template specialization" should be a program-defined type.</p>
<p>RS: An implicit instantiation of a "program-defined partial specialization" should also be a program-defined type.</p>
<p>JY: This definition formatting is horrible and ugly, can we do better?</p>
<p>RS: Checking ISO directives.</p>
<p>RS: Define "program-defined type" and "program-defined specialization" instead, to get rid of the angle brackets.</p>
<p>JW redrafting.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Add a new sub-clause to 20.3 <a href="https://timsong-cpp.github.io/cppwp/definitions">[definitions]</a>:</p>

<p><ins><b>17.3.? [defns.program.defined]</b></ins></p>
<p>
<ins><b>program-defined</b></ins>
<p/>
<ins>&lt;type&gt; a class type or enumeration type which is not part of the C++
standard library and not defined by the implementation. [<i>Note</i>: Types
defined by the implementation include extensions (4.1 <a href="https://timsong-cpp.github.io/cppwp/intro.compliance">[intro.compliance]</a>)
and internal types used by the library. &mdash; <i>end note</i>]</ins>
</p>
<p>
<ins><b>program-defined</b></ins>
<p/>
<ins>&lt;specialization&gt; an explicit template specialization or partial
specialization which is not part of the C++ standard library and not
defined by the implementation.</ins>
</p>
</li>

<li><p>Change 20.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> paragraph 1+2:</p>

<p>
-1- The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <tt>std</tt> or to a
namespace within namespace <tt>std</tt> unless otherwise specified. A program may add a template specialization
for any standard library template to namespace <tt>std</tt> only if the declaration depends on a 
<del>user</del><ins>program</ins>-defined type and the specialization meets the standard library requirements for the 
original template and is not explicitly prohibited.
<p/>
-2- The behavior of a C++ program is undefined if it declares
<p/>
[&hellip;]
<p/>
A program may explicitly instantiate a template defined in the standard library only if the declaration
depends on the name of a <del>user</del><ins>program</ins>-defined type and the instantiation meets the standard 
library requirements for the original template.
</p>
</li>

<li><p>Change 22.5 <a href="https://timsong-cpp.github.io/cppwp/syserr">[syserr]</a> paragraph 4:</p>

<p>
-4- The <tt>is_error_code_enum</tt> and <tt>is_error_condition_enum</tt> may be specialized for 
<del>user</del><ins>program</ins>-defined types to indicate that such types are eligible for class <tt>error_code</tt> 
and class <tt>error_condition</tt> automatic conversions, respectively.
</p>
</li>

<li><p>Change 23.10.7.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.trait">[allocator.uses.trait]</a> paragraph 1:</p>

<p>
-1- <i>Remarks</i>: automatically detects [&hellip;]. A program may specialize this template to derive from 
<tt>true_type</tt> for a <del>user</del><ins>program</ins>-defined type <tt>T</tt> that does not have a nested 
<tt>allocator_type</tt> but nonetheless can be constructed with an allocator where either: [&hellip;]
</p>
</li>

<li><p>Change 23.14.11.1 <a href="https://timsong-cpp.github.io/cppwp/func.bind.isbind">[func.bind.isbind]</a> paragraph 2:</p>

<p>
-2- Instantiations of the <tt>is_bind_expression</tt> template [&hellip;]. A program may specialize
this template for a <del>user</del><ins>program</ins>-defined type <tt>T</tt> to have a <tt>BaseCharacteristic</tt> 
of <tt>true_type</tt> to indicate that <tt>T</tt> should be treated as a subexpression in a <tt>bind</tt> call.
</p>
</li>

<li><p>Change 23.14.11.2 <a href="https://timsong-cpp.github.io/cppwp/func.bind.isplace">[func.bind.isplace]</a> paragraph 2:</p>

<p>
-2- Instantiations of the <tt>is_placeholder</tt> template [&hellip;]. A program may specialize this template for a 
<del>user</del><ins>program</ins>-defined type <tt>T</tt> to have a <tt>BaseCharacteristic</tt> of 
<tt>integral_constant&lt;int, <i>N</i>&gt;</tt> with <tt><i>N</i> &gt; 0</tt> to indicate that <tt>T</tt> should be 
treated as a placeholder type.
</p>
</li>

<li><p>Change 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> paragraph 1:</p>

<p>
The unordered associative containers defined in 23.5 use specializations of the class template <tt>hash</tt> [&hellip;], 
the instantiation <tt>hash&lt;Key&gt;</tt> shall:
</p>
<ul>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>satisfy the requirement that the expression <tt>h(k)</tt>, where <tt>h</tt> is an object of type 
<tt>hash&lt;Key&gt;</tt> and <tt>k</tt> is an object of type <tt>Key</tt>, shall not throw an exception unless 
<tt>hash&lt;Key&gt;</tt> is a <del>user</del><ins>program</ins>-defined specialization that depends on at least one 
<del>user</del><ins>program</ins>-defined type.</p></li>
</ul>
</li>

<li><p>Change 23.15.7.5 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.ptr">[meta.trans.ptr]</a> Table 57 (<tt>common_type</tt> row):</p>

<blockquote>
<table border="1">
<caption>Table 57 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class... T&gt;<br/>
struct common_type;</tt>
</td>

<td align="center">
&nbsp;
</td>

<td>
The member typedef <tt>type</tt> shall be<br/>
defined or omitted as specified below.<br/>
[&hellip;]. A program may<br/>
specialize this trait if at least one<br/>
template parameter in the<br/>
specialization is a <del>user</del><ins>program</ins>-defined type.<br/>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 25.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a> paragraph 3:</p>

<p>
-3- The specializations required in Table 81 (22.3.1.1.1) [&hellip;]. Other encodings can be converted 
by specializing on a <del>user</del><ins>program</ins>-defined <tt>stateT</tt> type.[&hellip;]
</p>
</li>

<li><p>Change 31.12.1.4 <a href="https://timsong-cpp.github.io/cppwp/re.regiter.incr">[re.regiter.incr]</a> paragraph 8:</p>

<p>
-8- [<i>Note</i>: This means that a compiler may call an implementation-specific search function, in which case
a <del>user</del><ins>program</ins>-defined specialization of <tt>regex_search</tt> will not be called. &mdash; 
<i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3><a name="2146" href="2146">2146.</a> Are reference types <tt>Copy</tt>&#47;<tt>Move-Constructible</tt>&#47;<tt>Assignable</tt> or <tt>Destructible</tt>?</h3>
<p><b>Section:</b> 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-03-23 <b>Last modified:</b> 2016-06-21 05:06:22 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> p1
</p>
<blockquote><p>
The template definitions in the C++ standard library refer to various named requirements whose details are set out in 
tables 17-24. In these tables, <tt>T</tt> is an object or reference type to be supplied by a C++ program instantiating 
a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are values of type (possibly <tt>const</tt>) <tt>T</tt>; <tt>s</tt> 
and <tt>t</tt> are modifiable lvalues of type <tt>T</tt>; <tt>u</tt> denotes an identifier; <tt>rv</tt> is an rvalue of 
type <tt>T</tt>; and <tt>v</tt> is an lvalue of type (possibly <tt>const</tt>) <tt>T</tt> or an rvalue of type <tt>const T</tt>.
</p></blockquote>
<p>
Is it really intended that <tt>T</tt> may be a reference type? If so, what should <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, 
<tt>s</tt>, <tt>t</tt>, <tt>u</tt>, <tt>rv</tt>, and <tt>v</tt> mean? For example, are "<tt>int &amp;</tt>" and 
"<tt>int &amp;&amp;</tt>" <tt>MoveConstructible</tt>?
<p/>
As far as I understand, we can explicitly specify template arguments for <tt>std::swap</tt> and <tt>std::for_each</tt>. 
Can we use reference types there?
</p>
<ol>
<li>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main()
{
  int x = 1;
  int y = 2;
  std::swap&lt;<span style="color:#C80000;font-weight:bold">int &amp;&amp;</span>&gt;(x, y); // <em>undefined?</em>
  std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;
}
</pre></blockquote>
</li>
<li>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;

struct F
{
  void operator()(int n)
  {
    std::cout &lt;&lt; n &lt;&lt; std::endl;
    ++count;
  }
  int count;
} f;

int main()
{
  int arr[] = { 1, 2, 3 };
  auto&amp;&amp; result = std::for_each&lt;int *, <span style="color:#C80000;font-weight:bold">F &amp;&amp;</span>&gt;( // <em>undefined?</em>
    std::begin(arr),
    std::end(arr),
    std::move(f));
  std::cout &lt;&lt; "count: " &lt;&lt; result.count &lt;&lt; std::endl;
}
</pre></blockquote>
</li>
</ol>
<p>
Are these forms of usage well-defined?
<p/>
Let's also consider the following constructor of <tt>std::thread</tt>:
</p>
<blockquote><pre>
template &lt;class F, class ...Args&gt;
explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre><blockquote>
<p>
<i>Requires</i>: <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall satisfy the <tt>MoveConstructible</tt> requirements.
</p>
</blockquote></blockquote>
<p>
When the first argument of this constructor is an lvalue (e.g. a name of a global function), template argument for <tt>F</tt> 
is deduced to be lvalue reference type. What should "<tt>MoveConstructible</tt>" mean with regard to an lvalue reference 
type? Maybe the wording should say that <tt>std::decay&lt;F&gt;::type</tt> and each <tt>std::decay&lt;Ti&gt;::type</tt> (where 
<tt>Ti</tt> is an arbitrary item in <tt>Args</tt>) shall satisfy the <tt>MoveConstructible</tt> requirements?
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>Moved to Open.</p>
<p>The questions raised by the issue are real, and should have a clear answer.</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: std::thread needs to be fixed, and anything behaving like it needs to be fixed, rather than reference types. std::bind gets this right. We need to survey this. GR: That doesn't sound small to me. STL: Seach for CopyConstructible etc. It may be a long change, but not a hard one.</p>
<p>MC: It seems that we don't have a PR. Does anyone have one? Is anyone interested in doing a survey?</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>Casey volunteers to make a survey</p>

<p><i>[2016-06, Oulu]</i></p>

<p>
During an independent survey performed by Daniel as part of the analysis of LWG <a href="2716">2716</a>,
some overlap was found between these two issues. Daniel suggested to take responsibility for surveying
LWG <a href="2146">2146</a> and opined that the P/R of LWG <a href="2716">2716</a> should restrict to forwarding 
references, where the deduction to lvalue references can happen without providing an explicit template
argument just by providing an lvalue function argument.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2151" href="2151">2151.</a> <tt>basic_string&lt;&gt;::swap</tt> semantics ignore allocators</h3>
<p><b>Section:</b> 24.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/string.require">[string.require]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2016-11-12 20:11:11 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.require">[string.require]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++11, <tt>basic_string</tt> is not described as a "container", and is not governed by the allocator-aware 
container semantics described in sub-clause 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>; as a result, and 
requirements or contracts for the <tt>basic_string</tt> interface must be documented in Clause 
24 <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a>.
<p/>
Sub-clause 24.3.2.6.8 <a href="https://timsong-cpp.github.io/cppwp/string.swap">[string.swap]</a> defines the <tt>swap</tt> member function with no requirements, and
with guarantees to execute in constant time without throwing. Fulfilling such a contract is not reasonable 
in the presence of unequal non-propagating allocators.
<p/>
In contrast, 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p7 declares the behavior of member <tt>swap</tt> 
for containers with unequal non-propagating allocators to be undefined.
<p/>
Resolution proposal:
<p/>
Additional language from Clause 26 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> should probably be copied to Clause 
24 <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a>. I will refrain from an exactly recommendation, however, as I am raising further
issues related to the language in Clause 26 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair has offered to provide wording.
</p>
<p>
Telecon notes that 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>p13 says that <tt>string</tt> is an
allocator-aware container.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2152" href="2152">2152.</a> Instances of standard container types are not swappable</h3>
<p><b>Section:</b> 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>, 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2016-08-02 18:08:23 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#swappable.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sub-clause 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> defines two notions of swappability: a binary version defining
when two objects are <em>swappable with</em> one another, and a unary notion defining whether an object is 
<em>swappable</em> (without qualification), with the latter definition requiring that the object satisfy the 
former with respect to all values of the same type.
<p/>
Let <tt>T</tt> be a container type based on a non-propagating allocator whose instances do not necessarily 
compare equal. Then sub-clause 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p7 implies that no object <tt>t</tt> 
of type <tt>T</tt> is swappable (by the unary definition).
<p/>
Throughout the standard it is the unary definition of "swappable" that is listed as a requirement (with the 
exceptions of 23.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a> p4, 23.4.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> p31, 23.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a> p2, 
28.6.3 <a href="https://timsong-cpp.github.io/cppwp/alg.swap">[alg.swap]</a> p2, and 28.6.3 <a href="https://timsong-cpp.github.io/cppwp/alg.swap">[alg.swap]</a> p6, which use the binary definition). This renders 
many of the mutating sequence algorithms of sub-clause 28.6 <a href="https://timsong-cpp.github.io/cppwp/alg.modifying.operations">[alg.modifying.operations]</a>, for example, 
inapplicable to sequences of standard container types, even where every element of the sequence is swappable 
with every other.
<p/>
Note that this concern extends beyond standard containers to all future allocator-based types.
<p/>
Resolution proposal:
<p/>
I see two distinct straightforward solutions:
</p>
<ol style="list-style-type:lower-roman">
<li>Modify the requirements of algorithms from sub-clause 28.6 <a href="https://timsong-cpp.github.io/cppwp/alg.modifying.operations">[alg.modifying.operations]</a>, and all other
places that reference the unary "swappable" definition, to instead use the binary "swappable with" definition 
(over a domain appropriate to the context). The unary definition of "swappable" could then be removed from the 
standard.
</li>
<li>Modify sub-clause 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> such that objects of standard container types 
are "swappable" by the unary definition.
</li>
</ol>
<p>
I favor the latter solution, for reasons detailed in the following issue.
</p>

<p><i>[
2012-10 Portland: Move to Open 
]</i></p>


<p>
The issue is broader than containers with stateful allocotors, although they are the most obvious
example contained within the standard itself.  The basic problem is that once you have a stateful
allocator, that does not <tt>propagate_on_swap</tt>, then whether two objects of this type can be
swapped with well defined behavior is a run-time property (the allocators compare equal) rather
than a simple compile-time property that can be deduced from the type.  Strictly speaking, any
type where the nature of swap is a runtime property does not meet the <tt>swappable</tt>
requirements of C++11, although typical sequences of such types are going to have elements that
are all <tt>swappable with</tt> any other element in the sequence (using our other term of art
for specifying requirements) as the common case is a container of elements who all share the
same allocator.
</p>

<p>
The heart of the problem is that the <tt>swappable</tt> requirments demand that any two objects
of the same type be <tt>swappable with</tt> each other, so if any two such objects would not
be <tt>swappable with</tt> each other, then the whole type is never <tt>swappable</tt>.  Many
algorithms in clause 25 are specified in terms of <tt>swappable</tt> which is essentially an
overspecification as all they actually need is that any element in the sequence is <tt>swappable
with</tt> any other element in the sequence.
</p>

<p>
At this point Howard joins the discussion and points out that the intent of introducing the
two swap-related terms was to support <tt>vector&lt;bool&gt;::reference</tt> types, and we are
reading something into the wording that was never intended.  Consuses is that regardless of
the intent, that is what the words today say.
</p>

<p>
There is some support to see a paper reviewing the whole of clause 25 for this issue, and
other select clauses as may be necessary.
</p>

<p>
There was some consideration to introducing a note into the front of clause 25 to indicate
<tt>swappable</tt> requirements in the clause should be interpreted to allow such awkward
types, but ultimately no real enthusiasm for introducing a <tt>swappable for clause 25</tt>
requirement term, especially if it confusingly had the same name as a term used with a
subtly different meaning through the rest of the standard.
</p>

<p>
There was no enthusiasm for the alternate resolution of requiring containers with unequal
allocators that do not propagate provide a well-defined swap behavior, as it is not
believed to be possible without giving <tt>swap</tt> linear complexity for such values,
and even then would require adding the constraint that the container element types are
CopyConstructible.
</p>

<p>
Final conclusion: move to open pending a paper from a party with a strong interest in
stateful allocators.
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Alisdair says that his paper <a href="http://wg21.link/P0178">P0178</a> addresses this.
</p>

<p><i>[2016-06 Oulu]</i></p>

<p>
<a href="http://wg21.link/P0178">P0178</a> reviewed, and sent back to LEWG for confirmation.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Apply <a href="http://wg21.link/P0178">P0178</a>.
</p>





<hr>
<h3><a name="2153" href="2153">2153.</a> Narrowing of the non-member <tt>swap</tt> contract</h3>
<p><b>Section:</b> 23.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a>, 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>, 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.swap">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.swap">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sub-clause 23.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a> defines a non-member 'swap' function with defined behavior for
all <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> types. It does not guarantee
constant-time complexity or <tt>noexcept</tt> in general, however this definition does
render all objects of <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> type swappable
(by the unary definition of sub-clause 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>) in the absence of 
specializations or overloads.
<p/>
The overload of the non-member <tt>swap</tt> function defined in Table 96, however,
defines semantics incompatible with the generic non-member <tt>swap</tt> function,
since it is defined to call a member <tt>swap</tt> function whose semantics are
undefined for some values of <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> types.
<p/>
The obvious (perhaps naive) interpretation of sub-clause 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> is as a guide to
the "right" semantics to provide for a non-member <tt>swap</tt> function (called in
the context defined by 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> p3) in order to provide interoperable
user-defined types for generic programming. The standard container types don't follow these guidelines.
<p/>
More generally, the design in the standard represents a classic example of "contract narrowing". It 
is entirely reasonable for the contract of a particular <tt>swap</tt> overload to provide <em>more</em> 
guarantees, such as constant-time execution and <tt>noexcept</tt>, than are provided by the <tt>swap</tt> 
that is provided for any <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> types, but it is <em>not</em> 
reasonable for such an overload to fail to live up to the guarantees it provides for general types when 
it is applied to more specific types. Such an overload or specialization in generic programming is akin 
to an override of an inherited virtual function in OO programming: violating a superclass contract in a
subclass may be legal from the point of view of the language, but it is poor design and can easily lead 
to errors. While we cannot prevent user code from providing overloads that violate the more general 
<tt>swap</tt> contract, we can avoid doing so within the library itself.
<p/>
My proposed resolution is to draw a sharp distinction between member <tt>swap</tt> functions, which provide 
optimal performance but idiosyncratic contracts, and non-member <tt>swap</tt> functions, which should always 
fulfill at least the contract of 23.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a> and thus render objects swappable. The member 
<tt>swap</tt> for containers with non-propagating allocators, for example, would offer constant-time
guarantees and <tt>noexcept</tt> but would only offer defined behavior for values with allocators that compare 
equal; non-member <tt>swap</tt> would test allocator equality and then dispatch to either member <tt>swap</tt> or 
<tt>std::swap</tt> depending on the result, providing defined behavior for all values (and rendering the type
"swappable"), but offering neither the constant-time nor the <tt>noexcept</tt> guarantees.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This topic deserves more attention than can be given in the telocon, and there is no proposed resolution.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This topic deserves more attention than can be given in the telocon, and there is no proposed resolution.
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Alisdair says that his paper <a href="http://wg21.link/P0178">P0178</a> addresses this.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Send to LEWG</p>

<p><i>[2016-06 Oulu]</i></p>

<p>
<a href="http://wg21.link/P0178">P0178</a> reviewed, and sent back to LEWG for confirmation.
</p>


<p><b>Proposed resolution:</b></p>
Apply <a href="http://wg21.link/P0178">P0178</a>.





<hr>
<h3><a name="2154" href="2154">2154.</a> What exactly does compile-time complexity imply?</h3>
<p><b>Section:</b> 29.6.1.3 <a href="https://timsong-cpp.github.io/cppwp/rand.req.urng">[rand.req.urng]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> John Salmon <b>Opened:</b> 2012-04-26 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.urng">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/rand.req.urng">[rand.req.urng]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The expressions <tt>G::min()</tt> and <tt>G::max()</tt> in Table 116 in 29.6.1.3 <a href="https://timsong-cpp.github.io/cppwp/rand.req.urng">[rand.req.urng]</a> are specified 
as having "compile-time" complexity.
<p/>
It is not clear what, exactly, this requirement implies.  If a URNG has a method:
</p>
<blockquote><pre>
static int min();
</pre></blockquote>
<p>
then is the method required to have a <tt>constexpr</tt> qualifier?  I believe the standard would benefit from 
clarification of this point.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2155" href="2155">2155.</a> Macro <tt>__bool_true_false_are_defined</tt> should be removed</h3>
<p><b>Section:</b> 21.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2012-04-30 <b>Last modified:</b> 2017-03-14 03:03:42 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Since C99, the C standard describes a macro named  <tt>__bool_true_false_are_defined</tt>.
<p/>
In the process of harmonizing C++11 with C99, this name became part of the C++ standard.
<p/>
I propose that all mention of this name should be removed from the C and C++ standards.
<p/>
Here's the problem: The name was originally proposed as a transition tool, so that the headers for a 
project could contain lines like the following.
</p>
<blockquote><pre>
#if !defined(__bool_true_false_are_defined)
#define bool int /* or whatever */
#define true 1
#define false 0
#endif
</pre></blockquote>
<p>
Then when the project was compiled by a "new" compiler that implemented <tt>bool</tt> as defined by the 
evolving C++98 or C99 standards, those lines would be skipped; but when compiled by an "old" compiler that 
didn't yet provide <tt>bool</tt>, <tt>true</tt>, and <tt>false</tt>, then the <tt>#define</tt>'s would provide a
simulation that worked for most purposes.
<p/>
It turns out that there is an unfortunate ambiguity in the name.  One interpretation is as shown above, but 
a different reading says "bool, true, and false are #define'd", i.e. that the meaning of the macro is to
assert that these names are macros (not built-in) ... which is true in C, but not in C++.
<p/>
In C++11, the name appears in parentheses followed by a stray period, so
some editorial change is needed in any event:
<p/>
21.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> para 1:
</p>
<blockquote><p>
Headers <tt>&lt;csetjmp&gt;</tt> (nonlocal jumps), <tt>&lt;csignal&gt;</tt> (signal handling), <tt>&lt;cstdalign&gt;</tt> 
(alignment), <tt>&lt;cstdarg&gt;</tt> (variable arguments), <tt>&lt;cstdbool&gt;</tt> (<tt>__bool_true_false_are_defined</tt>). 
<tt>&lt;cstdlib&gt;</tt> (runtime environment <tt>getenv()</tt>, <tt>system()</tt>), and <tt>&lt;ctime&gt;</tt> 
(system clock <tt>clock()</tt>, <tt>time()</tt>) provide further compatibility with C code.
</p></blockquote>
<p>
However, para 2 says
</p>
<blockquote><p>
"The contents of these headers are the same as the Standard C library headers <tt>&lt;setjmp.h&gt;</tt>, 
<tt>&lt;signal.h&gt;</tt>, <tt>&lt;stdalign.h&gt;</tt>, <tt>&lt;stdarg.h&gt;</tt>, <tt>&lt;stdbool.h&gt;</tt>, 
<tt>&lt;stdlib.h&gt;</tt>, and <tt>&lt;time.h&gt;</tt>, respectively, with the following 
changes:",
</p></blockquote>
<p>
and para 8 says 
</p>
<blockquote><p>
"The header <tt>&lt;cstdbool&gt;</tt> and the header <tt>&lt;stdbool.h&gt;</tt> shall 
not define macros named <tt>bool</tt>, <tt>true</tt>, or <tt>false</tt>."
</p></blockquote>
<p>
Thus para 8 doesn't exempt the C++ implementation from the arguably clear requirement of the C standard, to 
provide a macro named <tt>__bool_true_false_are_defined</tt> defined to be 1.
<p/>
Real implementations of the C++ library differ, so the user cannot count upon any consistency; furthermore, the 
usefulness of the transition tool has faded long ago.
<p/>
That's why my suggestion is that both C and C++ standards should eliminate any mention of 
<tt>__bool_true_false_are_defined</tt>.  In that case, the name belongs to implementers to provide, or not, as 
they choose.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
While not strictly necessary, the clean-up look good.
</p>
<p>
We would like to hear from our C liaison before moving on this issue though.
</p>

<p><i>[2015-05 Lenexa]</i></p>

<p>
LWG agrees. Jonathan provides wording.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>The reference to &lt;cstdbool&gt; in p2 needs to be struck as well. Continue the discussion on the reflector once the DIS is available.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li>
<p>Edit the footnote on 20.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a> p7:</p>
<blockquote>
<p>
176) In particular, including <ins>any of</ins> the standard header<ins>s <tt>&lt;stdbool.h&gt;</tt>, <tt>&lt;cstdbool&gt;</tt>,</ins> <tt>&lt;iso646.h&gt;</tt> or <tt>&lt;ciso646&gt;</tt> has no effect.
</p>
</blockquote>
</li>

<li>
<p>Edit 21.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> p1 as indicated (and remove the index entry for <tt>__bool_true_false_are_defined</tt>):</p>

<blockquote>
<p>
-1- Headers <tt>&lt;csetjmp&gt;</tt> (nonlocal jumps), <tt>&lt;csignal&gt;</tt> (signal handling), <tt>&lt;cstdalign&gt;</tt> (alignment), <tt>&lt;cstdarg&gt;</tt> (variable arguments), <tt>&lt;cstdbool&gt;</tt><ins>,</ins><del> (<tt>__bool_true_false_are_defined</tt>).</del> <tt>&lt;cstdlib&gt;</tt> (runtime environment <tt>getenv()</tt>, <tt>system()</tt>), and <tt>&lt;ctime&gt;</tt> (system clock <tt>clock()</tt>, <tt>time()</tt>) provide further compatibility with C code.
</p>
</blockquote>
</li>

<li>
<p>Remove Table 38 &mdash; Header <tt>&lt;cstdbool&gt;</tt> synopsis [tab:support.hdr.cstdbool] from 21.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> </p>
<blockquote>
<table border="1">
<caption> Table 38 &mdash; Header <tt>&lt;cstdbool&gt;</tt> synopsis </caption>
<tr><td><b>Type</b></td><td><b>Name(s)</b></td></tr>
<tr><td><b>Macro:</b></td><td><tt>__bool_true_false_are_defined</tt></td></tr>
</table>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2157" href="2157">2157.</a> How does <tt>std::array&lt;T,0&gt;</tt> initialization work when <tt>T</tt> is not default-constructible?</h3>
<p><b>Section:</b> 26.3.7.8 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daryle Walker <b>Opened:</b> 2012-05-08 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#array.zero">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Objects of <tt>std::array&lt;T,N&gt;</tt> are supposed to be initialized with aggregate initialization (when 
not the destination of a copy or move). This clearly works when <tt>N</tt> is positive. What happens when <tt>N</tt> 
is zero?  To continue using an (inner) set of braces for initialization, a <tt>std::array&lt;T,0&gt;</tt> implementation 
must have an array member of at least one element, and let default initialization take care of those secret elements.  
This cannot work when <tt>T</tt> has a set of constructors and the default constructor is deleted from that set.
Solution: Add a new paragraph in 26.3.7.8 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a>:
</p>
<blockquote><p>
The unspecified internal structure of array for this case shall allow initializations like:
</p>
<blockquote><pre>
array&lt;T, 0&gt; a = { };
</pre></blockquote>
<p>
and said initializations must be valid even when <tt>T</tt> is not default-constructible.
</p></blockquote>

<p><i>[2012, Portland: Move to Open]</i></p>

<p>
Some discussion to understand the issue, which is that implementations currently have freedom to implement
an empty <tt>array</tt> by holding a dummy element, and so might not support value initialization, which is
surprising when trying to construct an empty container.  However, this is not mandated, it is an unspecified
implementation detail.
</p>

<p>
Jeffrey points out that the implication of 26.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> is that this initialization syntax
must be supported by empty <tt>array</tt> objects already.  This is a surprising inference that was not
obvious to the room, but consensus is that the reading is accurate, so the proposed resolution is not necessary,
although the increased clarity may be useful.
</p>

<p>
Further observation is that the same clause effectively implies that <tt>T</tt> must always be DefaultConstructible,
regardless of <tt>N</tt> for the same reasons - as an <i>initializer-list</i> may not supply enough values, and the
remaining elements must all be value initialized.
</p>

<p>
Concern that we are dancing angels on the head of pin, and that relying on such subtle implications in wording is
not helpful. We need a clarification of the text in this area, and await wording.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
DK: What was the outcome of Portland? AM: Initially we thought we already had the intended behaviour. 
We concluded that <tt>T</tt> must always be <tt>DefaultConstructible</tt>, but I'm not sure why. GR: It's p2 in 
<tt>std::array</tt>, "up to <tt>N</tt>". AM: That wording already implies that "<tt>{}</tt>" has to work when <tt>N</tt> 
is zero. But the wording of p2 needs to be fixed to make clear that it does <em>not</em> imply that <tt>T</tt> must be 
<tt>DefaultConstructible</tt>.
<p/>
Conclusion: Update wording, revisit later. 
</p>


<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>MC: How important is this? Can you not just use default construction for empty arrays? </p>
<p>TK: It needs to degenerate properly from a pack. STL agrees.</p> 
<p>JW: Yes, this is important, and we have to make it work.</p>
<p>MC: I hate the words "initialization like". </p>
<p>JW: I'll reword this.</p>
<p>WEB: Can I ask that once JW has reworded this we move it to Review rather than Open? </p>
<p>MC: We'll try to review it in a telecon and hopefully get it to tentatively ready.</p>
<p>STL: Double braces must also work: <tt>array&lt;T, 0&gt; a = {{}};</tt>.</p>
<p>Jonathan to reword.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<p>Add the following new paragraph between the current 26.3.7.8 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> p1 and p2:</p>

<blockquote><p>
-1- <tt>array</tt> shall provide support for the special case <tt>N == 0</tt>.
<p/>
<ins>-?- The unspecified internal structure of <tt>array</tt> for this case shall allow initializations like:</ins>
</p>
<blockquote><pre>
<ins>array&lt;T, 0&gt; a = { };</ins>
</pre></blockquote>
<p>
<ins>and said initializations must be valid even when <tt>T</tt> is not default-constructible.</ins>
<p/>
-2- In the case that <tt>N == 0</tt>, <tt>begin() == end() ==</tt> unique value. The return value of 
<tt>data()</tt> is unspecified.
<p/>
-3- The effect of calling <tt>front()</tt> or <tt>back()</tt> for a zero-sized array is undefined.
<p/>
-4- Member function <tt>swap()</tt> shall have a <em>noexcept-specification</em> which is equivalent to 
<tt>noexcept(true)</tt>.
</p></blockquote>





<hr>
<h3><a name="2158" href="2158">2158.</a> Conditional copy&#47;move in <tt>std::vector</tt></h3>
<p><b>Section:</b> 26.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-05-08 <b>Last modified:</b> 2016-08-06 21:08:20 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
There are various operations on <tt>std::vector</tt> that can cause elements of the vector to be 
moved from one location to another. A move operation can use either rvalue or const lvalue as 
argument; the choice depends on the value of <tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;
is_copy_constructible&lt;T&gt;::value</tt>, where <tt>T</tt> is the element type. Thus, some operations 
on <tt>std::vector</tt> (e.g. 'resize' with single parameter, 'reserve', 'emplace_back') should have 
conditional requirements. For example, let's consider the requirement for 'reserve' in N3376 &ndash; 
26.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>&#47;2:
</p>
<blockquote><p>
<i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
</p></blockquote>
<p>
This requirement is not sufficient if an implementation is free to select copy constructor when 
<tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value</tt> 
evaluates to true. Unfortunately, <tt>is_copy_constructible</tt> cannot reliably determine whether 
<tt>T</tt> is really copy-constructible. A class may contain public non-deleted copy constructor whose 
definition does not exist or cannot be instantiated successfully (e.g., 
<tt>std::vector&lt;std::unique_ptr&lt;int&gt;&gt;</tt> has copy constructor, but this type is not 
copy-constructible). Thus, the actual requirements should be:
</p>
<ul>
<li><p>
if <tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value</tt> 
then <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>*this</tt>;
</p></li>
<li><p>
otherwise <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
</p></li>
</ul>
<p>
Maybe it would be useful to introduce a new name for such conditional requirement (in addition to 
"<tt>CopyInsertable</tt>" and "<tt>MoveInsertable</tt>").
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>
The problem does not appear to be as severe as described. The <tt>MoveInsertable</tt>
requirements are consistently correct, but an issue may arise on the
exception-safety guarantees when we check for
<tt>is_copy_constructible_v&lt;T&gt;</tt>.  The problem, as described, is
typically for templates that appear to have a copy constructor, but one that
fails to compile once instantiated, and so gives a misleading result for the
trait.
</p>
<p>
In general, users should not provide such types, and the standard would not
serve users well by trying to address support for such types.  However, the
standard should not be providing such types either, such as
<tt>vector&lt;unique_ptr&lt;T&gt;&gt;</tt>.  A possible resolution would be
to tighten the constraints in Table 80 &mdash; Container Requirements, so that if
the Requirements for the copy constructor/assingment operator of a container
are not satisfied, that operation shall be deleted.
</p>
<p>
A futher problem highlighted by this approach is that there are no constraints on
the copy-assignment operator, so that <tt>vector&lt;unique_ptr&lt;T&gt;&gt;</tt>
should be <tt>CopyAssignable</tt>! However, we can lift the equivalent constraints from
the Allocator-aware container requirements.
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Fri PM: Move to OPen</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<p>
<table border="1">
<caption> 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> Table 80 &mdash; Container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><tt>X(a)</tt></td>
  <td></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into
    <tt>X</tt> (see below)<del>.</del><ins>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>a == X(a)</tt>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td><tt>X u(a)</tt><br/><tt>X u = a;</tt></td>
  <td></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into
    <tt>X</tt> (see below)<del>.</del><ins>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>u == a</tt>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
</tr>
<tr>
  <td><tt>r = a</tt></td>
  <td><tt>X&amp;</tt></td>
  <td></td>
  <td>
    <ins><i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>
    and <tt>CopyAssignable</tt>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>r == a</tt>.</td>
  <td>linear</td>
</tr>
</table>
</p>

<p>
<table border="1">
<caption> 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> Table 83 &mdash; Allocator-aware container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><tt>a = t</tt></td>
  <td><tt>X&amp;</tt></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt> and
    <tt>CopyAssignable</tt><del>.</del><ins>, otherwise this  expression shall
    be ill-formed</ins><br/>
    post: <tt>r == a</tt>.</td>
  <td>linear</td>
</tr>
</table>
</p>






<hr>
<h3><a name="2164" href="2164">2164.</a> What are the semantics of <tt>vector.emplace(vector.begin(), vector.back())</tt>?</h3>
<p><b>Section:</b> 26.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>, 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2012-07-07 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Nikolay Ivchenkov recently brought the following example on the
<a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/dhy23mDFXj4/discussion">std-discussion</a> 
newsgroup, asking whether the following program well-defined:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
  std::vector&lt;int&gt; v;
  v.reserve(4);
  v = { 1, 2, 3 };
  v.emplace(v.begin(), v.back());
  for (int x : v)
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
Nikolay Ivchenkov:
<p/>
I think that an implementation of <tt>vector</tt>'s 'emplace' should initialize an intermediate object with 
<tt>v.back()</tt> before any shifts take place, then perform all necessary shifts and finally replace the 
value pointed to by <tt>v.begin()</tt> with the value of the intermediate object. So, I would expect the 
following output:
</p>
<blockquote><pre>
3
1
2
3
</pre></blockquote>
<p>
GNU C++ 4.7.1 and GNU C++ 4.8.0 produce other results:
</p>
<blockquote><pre>
2
1
2
3
</pre></blockquote>
<p>
Howard Hinnant:
<p/>
I believe Nikolay is correct that vector should initialize an intermediate object with <tt>v.back()</tt> 
before any shifts take place. As Nikolay pointed out in another email, this appears to be the only way to 
satisfy the strong exception guarantee when an exception is not thrown by <tt>T</tt>'s copy constructor, 
move constructor, copy assignment operator, or move assignment operator as specified by 
26.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>/p1. I.e. if the emplace construction throws, the vector must remain unaltered.
<p/>
That leads to an implementation that tolerates objects bound to the function parameter pack of the <tt>emplace</tt> 
member function may be elements or sub-objects of elements of the container.
<p/>
My position is that the standard is correct as written, but needs a clarification in this area. Self-referencing 
<tt>emplace</tt> should be legal and give the result Nikolay expects. The proposed resolution of LWG <a href="760">760</a> 
is not correct.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG agrees with the analysis including the assessment of LWG <a href="760">760</a> and would appreciate a concrete wording proposal.
</p>

<p><i>[2015-04-07 dyp comments]</i></p>

<p>
The Standard currently does not require that creation of such
intermediate objects is legal. 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> Table 100
&mdash; "Sequence container requirements" currently specifies:
</p>

<blockquote>
<table border="1">
<caption>Table 100 &mdash; Sequence container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.emplace(p, args);</tt>
</td>
<td>
<tt>iterator</tt>
</td>
<td>
<i>Requires</i>: <tt>T</tt> is <tt>EmplaceConstructible</tt> into
<tt>X</tt> from <tt>args</tt>. For <tt>vector</tt> and <tt>deque</tt>,
<tt>T</tt> is also <tt>MoveInsertable</tt> into <tt>X</tt> and
<tt>MoveAssignable</tt>. [&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

<p>
The <tt>EmplaceConstructible</tt> concept is defined via
<tt>allocator_traits&lt;A&gt;::construct</tt> in 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p15.5 That's surprising to me
since the related concepts use the suffix <tt>Insertable</tt> if they
refer to the allocator. An additional requirement such as
<tt>std::is_constructible&lt;T, Args...&gt;</tt> is necessary to allow
creation of intermediate objects.
</p>

<p>
The creation of intermediate objects also affects other functions, such
as <tt>vector.insert</tt>. Since aliasing the vector is only allowed for
the single-element forms of <tt>insert</tt> and <tt>emplace</tt> (see
<a href="526">526</a>), the range-forms are not affected. Similarly,
aliasing is not allowed for the rvalue-reference overload. See also LWG
<a href="2266">2266</a>.
</p>

<p>
There might be a problem with a requirement of
<tt>std::is_constructible&lt;T, Args...&gt;</tt> related to the issues
described in LWG <a href="2461">2461</a>. For example, a scoped allocator
adapter passes additional arguments to the constructor of the value
type. This is currently not done in recent implementations of libstdc++
and libc++ when creating the intermediate objects, they simply create
the intermediate object by perfectly forwarding the arguments. If such
an intermediate object is then moved to its final destination in the
vector, a change of the allocator instance might be required &mdash;
potentially leading to an expensive copy. One can also imagine worse
problems, such as run-time errors (allocators not comparing equal at
run-time) or compile-time errors (if the value type cannot be created
without the additional arguments). I have not looked in detail into this
issue, but I'd be reluctant adding a requirement such as
<tt>std::is_constructible&lt;T, Args...&gt;</tt> without further
investigation.
</p>

<p>
It should be noted that the creation of intermediate objects currently
is inconsistent in libstdc++ vs libc++. For example, libstdc++ creates
an intermediate object for <tt>vector.insert</tt>, but not
<tt>vector.emplace</tt>, whereas libc++ does the exact opposite in this
respect.
</p>

<p>
A live demo of the inconsistent creation of intermediate objects can be
found <a href="http://coliru.stacked-crooked.com/a/449253d3d329ef4c">here</a>.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>HH: If it were easy, it'd have wording. Over the decades I have flipped 180 degrees on this. My current position is that it should work even if the element is in the same container.</p>
<p>TK: What's the implentation status? JW: Broken in GCC. STL: Broken in MSVS. Users complain about this every year.</p>
<p>MC: 526 says push_back has to work.</p>
<p>HH: I think you have to make a copy of the element anyway for reasons of exception safety. [Discussion of exception guarantees] </p>
<p>STL: vector has strong exception guarantees. Could we not just provide the Basic guarantee here. </p>
<p>HH: It would terrify me to relax that guarantee. It'd be an ugly, imperceptible runtime error. </p>
<p>HH: I agree if we had a clean slate that strong exception safety is costing us here, and we shouldn't provide it if it costs us.</p>
<p>STL: I have a mail here, "how can vector provide the strong guarantee when inserting in the middle". </p>
<p>HH: The crucial point is that you only get the strong guarantee if the exception is thrown by something other than the copy and move operations that are used to make the hole. </p>
<p>STL: I think we need to clean up the wording. But it does mandate currently that the self-emplacement must work, because nothings says that you can't do it. TK clarifies that a) self-emplacement must work, and b) you get the strong guarantee only if the operations for making the hole don't throw, otherwise basic. HH agrees. STL wants this to be clear in the Standard.</p>
<p>STL: Should it work for deque, too? HH: Yes.</p>
<p>HH: I will attempt wording for this. </p>
<p>TK: Maybe mail this to the reflector, and maybe someone has a good idea? </p>
<p>JW: I will definitely not come up with anything better, but I can critique wording.</p>
<p>Moved to Open; Howard to provide wording, with feedback from Jonathan.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2173" href="2173">2173.</a> The meaning of <code>operator +</code> in the description of the algorithms</h3>
<p><b>Section:</b> 28 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-08-01 <b>Last modified:</b> 2016-08-09 17:08:42 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 28.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a>/12,
</p>
<blockquote><p>
In the description of the algorithms operators <tt>+</tt> and <tt>-</tt> are used for some of the iterator categories 
for which they do not have to be defined. In these cases the semantics of <tt>a+n</tt> is the same as that of
</p>
<blockquote><pre>
X tmp = a;
advance(tmp, n);
return tmp;
</pre></blockquote>
</blockquote>
<p>
There are several places where such operator <tt>+</tt> is applied to an output iterator &mdash; for example, see the 
description of <tt>std::copy</tt>:
</p>
<blockquote><pre>
template&lt;class InputIterator, class OutputIterator&gt;
OutputIterator copy(InputIterator first, InputIterator last,
                    OutputIterator result);
</pre>
<blockquote><p>
-1- <i>Effects</i>: Copies elements in the range <tt>[first,last)</tt> into the range <tt>[result,result + (last -
first))</tt> starting from <tt>first</tt> and proceeding to <tt>last</tt>. For each non-negative integer 
<tt>n &lt; (last - first)</tt>, performs <tt>*(result + n) = *(first + n)</tt>.
</p></blockquote></blockquote>
<p>
<tt>std::advance</tt> is not supposed to be applicable to output iterators, so we need a different method of description.
<p/>
See also message <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32908">c++std-lib-32908</a>.
</p>

<p><i>[2014-06-07 Daniel comments and provides wording]</i></p>

<p>
The specification for output iterators is somewhat tricky, because here a sequence of increments is required to
be combined with intervening <em>assignments</em> to the dereferenced iterator. I tried to respect this
fact by using a conceptual assignment operation as part of the specification.
<p/>
Another problem in the provided as-if-code is the question which requirements are imposed on <tt>n</tt>. Unfortunately,
the corresponding function <tt>advance</tt> is completely underspecified in this regard, so I couldn't borrow wording
from it. We cannot even assume here that <tt>n</tt> is the difference type of the iterator, because for output iterators there is
no requirements for this associated type to be defined. The presented wording attempts to minimize assumptions, but still
can be considered as controversial. 
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 28.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a> around p12 as indicated:</p>

<blockquote>
<p>
-12- In the description of the algorithms operators <tt>+</tt> and <tt>-</tt> are used for some of the iterator categories for which
they do not have to be defined. In these cases the semantics of <tt>a+n</tt> is the same as that of
</p>
<blockquote>
<pre>
X tmp = a;
advance(tmp, n);
return tmp;
</pre>
</blockquote>
<p>
<ins>when <tt>X</tt> meets the input iterator requirements (27.2.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>), otherwise it is the same as that of</ins>
</p>
<blockquote>
<pre>
<ins>X tmp = a;
for (auto i = n; i; ++tmp, (void) --i) 
  *tmp = <i>Expr</i>(i); 
return tmp;</ins>
</pre>
</blockquote>
<p>
<ins>where <tt><i>Expr</i>(i)</tt> denotes the <tt>(n-i)</tt><sup>th</sup> expression that is assigned to for the corresponding algorithm;</ins> and that of <tt>b-a</tt> is the same as of
</p>
<blockquote>
<pre>
return distance(a, b);
</pre>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2183" href="2183">2183.</a> Muddled allocator requirements for <tt>match_results</tt> constructors</h3>
<p><b>Section:</b> 31.10.1 <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>, 31.10.6 <a href="https://timsong-cpp.github.io/cppwp/re.results.all">[re.results.all]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-08-29 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
31.10.1 <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a> p1 says:
</p>
<blockquote><p>
In all <tt>match_results</tt> constructors, a copy of the <tt>Allocator</tt> argument shall be used for any memory 
allocation performed by the constructor or member functions during the lifetime of the object.
</p></blockquote>
<p>
There are three constructors:
</p>
<blockquote><pre>
match_results(const Allocator&amp; = Allocator());
match_results(const match_results&amp; m);
match_results(match_results&amp;&amp; m) noexcept;
</pre></blockquote>
<p>
The second and third constructors do no have an <tt>Allocator</tt> argument, so despite the "all <tt>match_results</tt> 
constructors", it is not possible to use "the <tt>Allocator</tt> argument" for the second and third constructors.
<p/>
The requirements for those two constructors also does not give any guidance. The second constructor has no language 
about allocators, and the third states that the stored <tt>Allocator</tt> value is move constructed from 
<tt>m.get_allocator()</tt>, but doesn't require using that allocator to allocate memory.
<p/>
The same basic problem recurs in 31.10.6 <a href="https://timsong-cpp.github.io/cppwp/re.results.all">[re.results.all]</a>, which gives the required return value for 
<tt>get_allocator()</tt>:
</p>
<blockquote><p>
<i>Returns</i>: A copy of the <tt>Allocator</tt> that was passed to the object's constructor or, if that allocator 
has been replaced, a copy of the most recent replacement.
</p></blockquote>
<p>
Again, the second and third constructors do not take an <tt>Allocator</tt>, so there is nothing that meets this 
requirement when those constructors are used.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2184" href="2184">2184.</a> Muddled allocator requirements for <tt>match_results</tt> assignments</h3>
<p><b>Section:</b> 31.10.1 <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>, 31.10.6 <a href="https://timsong-cpp.github.io/cppwp/re.results.all">[re.results.all]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-08-29 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The effects of the two assignment operators are specified in Table 141. Table 141 makes no mention of allocators, 
so, presumably, they don't touch the target object's allocator. That's okay, but it leaves the question: 
<tt>match_results::get_allocator()</tt> is supposed to return "A copy of the Allocator that was passed to the 
object's constructor or, if that allocator has been replaced, a copy of the most recent replacement"; if assignment 
doesn't replace the allocator, how can the allocator be replaced?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2189" href="2189">2189.</a> Throwing <tt>swap</tt> breaks unordered containers' state</h3>
<p><b>Section:</b> 26.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.except">[unord.req.except]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-09-23 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The hash functor and key-comparison functor of unordered containers are allowed to throw on <tt>swap</tt>.
</p>
<p>
26.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.except">[unord.req.except]</a>p3 "For unordered associative containers, no <tt>swap</tt> function throws
an exception unless that exception is thrown by the swap of the container's Hash or Pred object (if any)."
</p>
<p>
In such a case we must offer the basic exception safety guarantee, where both objects are left in valid
but unspecified states, and no resources are leaked.  This yields a corrupt, un-usable container if the
first <tt>swap</tt> succeeds, but the second fails by throwing, as the functors form a matched pair.
</p>
<p>
So our basic scenario is first, swap the allocators if the allocators propagate on swap, according to
<tt>allocator_traits</tt>.  Next we swap the pointers to our internal hash table data structures, so that
they match the allocators that allocated them.  (Typically, this operation cannot throw).  Now our containers
are back in a safely destructible state if an exception follows.
</p>
<p>
Next, let's say we swap the hash functor, and that throws.  We have a corrupt data structure, in that the
buckets are not correctly indexed by the correct functors, lookups will give unpredicatable results etc.
We can safely restore a usable state by forcibly clearing each container - which does not leak resources
and leaves us with two (empty but) usable containers.
</p>
<p>
Now let us assume that the hasher swap succeeds.  Next we swap the equality comparator functor, and this
too could throw. The important point to bear in mind is that these two functors form an important pairing
- two objects that compare equal by the equality functor must also hash to the same value.  If we swap
one without the other, we most likely leave the container in an unusable state, even if we clear out all
elements.
</p>
<p>
1. A colleague pointed out that the solution for this is to dynamically allocate the two functors, and then
we need only swap pointers, which is not a throwing operation.  And if we don't want to allocate on default
construction (a common QoI request), we might consider moving to a dynamically allocated functors whenever
<tt>swap</tt> is called, or on first insertion.  Of course, allocating memory in <tt>swap</tt> is a whole
new can of worms, but this does not really sound like the design we had intended.
</p>

<p>
2. The simplest option is to say that we do not support hasher or equality functors that throw on ADL
<tt>swap</tt>.  Note that the requirement is simply to not throw, rather than to be explicitly
marked as <tt>noexcept</tt>.  Throwing functors are allowed, so long as we never use values that
would actually manifest a throw when used in an unordered container.
</p>

<p>
Pablo went on to give me several more options, to be sure we have a full set to consider:
</p>
<p>
3. Disallow one or the other functor from throwing.  In that case, the 
possibly-throwing functor must be swapped first, then the other functor, 
the allocator, and the data pointer(s) afterwards (in any order -- there 
was a TC that allocator assignment and swap may not throw if the 
corresponding propagation trait is true.). Of course, the question 
becomes: which functor is allowed to throw and which one is not?
</p>
<p>
4. Require that any successful functor <tt>swap</tt> be reliably reversible.  
This is very inventive.  I know of no other place in the standard where 
such a requirement is stated, though I have occasionally wanted such a 
guarantee.
</p>
<p>
5. Allow a failed swap to leave the containers in a state where future 
insertions may fail for reasons other than is currently allowed.  
Specifically, if the hash and equality functors are out of sync, all 
insertions will fail.  Presumably some "incompletely swapped" exception 
would be thrown.  This is "slightly" inventive, although people have been 
discussing "radioactive" states for a while.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2191" href="2191">2191.</a> Incorrect specification of <tt>match_results(match_results&amp;&amp;)</tt></h3>
<p><b>Section:</b> 31.10.1 <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-10-02 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
31.10.1 <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>/3: "Move-constructs an object of class <tt>match_results</tt> satisfying the same 
postconditions as Table 141."
</p>
<p>
Table 141 lists various member functions and says that their results should be the results of the corresponding member 
function calls on <tt>m</tt>. But <tt>m</tt> has been moved from, so the actual requirement ought to be based on the 
value that <tt>m</tt> had <em>before</em> the move construction, not on <tt>m</tt> itself.
</p>
<p>
In addition to that, the requirements for the copy constructor should refer to Table 141.
<p/>
<u>Ganesh</u>:
<p/>
Also, the requirements for move-assignment should refer to Table 141. Further it seems as if in Table 141 all phrases of
"for all integers <tt>n &lt; m.size()</tt>" should be replaced by "for all <em>unsigned</em> integers 
<tt>n &lt; m.size()</tt>".
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2195" href="2195">2195.</a> Missing constructors for <tt>match_results</tt></h3>
<p><b>Section:</b> 31.10 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-10-06 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The requirement expressed in 31.10 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a> p2
</p>
<blockquote><p>
The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specified in 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, except that only operations defined for 
const-qualified sequence containers are supported.
</p></blockquote>
<p>
can be read to require the existence of the described constructors from as well, but they do not exist in the
synopsis. 
<p/>
The missing sequence constructors are: 
</p>
<blockquote><pre>
match_results(initializer_list&lt;value_type&gt;);
match_results(size_type, const value_type&amp;);
template&lt;class InputIterator&gt; match_results(InputIterator, InputIterator);
</pre></blockquote>
<p>
The missing allocator-aware container constructors are:
</p>
<blockquote><pre>
match_results(const match_results&amp;, const Allocator&amp;);
match_results(match_results&amp;&amp;, const Allocator&amp;);
</pre></blockquote>
<p>
It should be clarified, whether (a) constructors are an exception of above mentioned operations or (b) whether
at least some of them (like those accepting a <tt>match_results</tt> value and an allocator) should be added.
<p/>
As visible in several places of the standard (including the core language), constructors seem usually to be considered 
as "operations" and they certainly can be invoked for const-qualified objects.
<p/>
The below given proposed resolution applies only the minimum necessary fix, i.e. it excludes constructors from
above requirement. 
</p>

<p><i>[2013-04-20, Bristol]</i></p>

<p>Check current implementations to see what they do and, possibly, write a paper.</p>

<p><i>[2013-09 Chicago]</i></p>

<p>Ask Daniel to update the proposed wording to include the allocator copy and move constructors.</p>

<p><i>[2014-01-18 Daniel changes proposed resolution]</i></p>

<p><strong>Previous resolution from Daniel [SUPERSEDED]:</strong></p>

<blockquote class="note">
<ol>
<li><p>Change 31.10 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a> p2 as indicated:</p>
<blockquote><p>
The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specified in 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, except that only operations defined for 
const-qualified sequence containers <ins>that are not constructors</ins> are supported.
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-05-06 Lenexa]</i></p>

<p>MC passes important knowledge to EF.</p>
<p>VV, RP: Looks good.</p>
<p>TK: Second form should be conditionally noexcept</p>
<p>JY: Sequence constructors are not here, but mentioned in the issue writeup. Why?</p>
<p>TK: That would have been fixed by the superseded wording.</p>
<p>JW: How does this interact with Mike Spertus' allocator-aware regexes? [...] Perhaps it doesn't.</p>
<p>JW: Can't create match_results, want both old and new resolution.</p>
<p>JY: It's problematic that users can't create these, but not this issue.</p>
<p>VV: Why conditional noexcept?</p>
<p>MC: Allocator move might throw.</p>
<p>JW: Update superseded wording to "only non-constructor operations that are"?</p>
<p>MC: Only keep superseded, but append "and the means of constructing match_results are limited to [...]"?</p>
<p>JY: Bullet 4 paragraph 2 needs to address the allocator constructor.</p>
<p>Assigned to JW for drafting.</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: I want Mike Spertus to be aware of this issue.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 31.10 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a> p4, class template <tt>match_results</tt> synopsis, as indicated:</p>
<blockquote><pre>
[&hellip;]
// 28.10.1, construct/copy/destroy:
explicit match_results(const Allocator&amp; a = Allocator());
match_results(const match_results&amp; m);
<ins>match_results(const match_results&amp; m, const Allocator&amp; a);</ins>
match_results(match_results&amp;&amp; m) noexcept;
<ins>match_results(match_results&amp;&amp; m, const Allocator&amp; a) noexcept;</ins>
[&hellip;]
</pre></blockquote>
</li>

<li><p>Change 31.10.1 <a href="https://timsong-cpp.github.io/cppwp/re.results.const">[re.results.const]</a>  as indicated: [<i>Drafting note:</i> Paragraph 6 as currently written,
makes not much sense, because the <tt>noexcept</tt> does not allow any exception to propagate. Further-on, the allocator requirements
do not allow for throwing move constructors. Deleting it seems to be near to editorial &mdash; <i>end drafting note</i>]</p>
<blockquote>

<pre>
match_results(const match_results&amp; m);
<ins>match_results(const match_results&amp; m, const Allocator&amp; a);</ins>
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Constructs an object of class <tt>match_results</tt>, as a copy of <tt>m</tt>.
</p>
</blockquote>

<pre>
match_results(match_results&amp;&amp; m) noexcept;
<ins>match_results(match_results&amp;&amp; m, const Allocator&amp; a) noexcept;</ins>
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Move-constructs an object of class <tt>match_results</tt> from <tt>m</tt> satisfying the same postconditions
as Table 142. <del>Additionally</del><ins>For the first form</ins>, the stored <tt>Allocator</tt> value is move constructed 
from <tt>m.get_allocator()</tt>.
<p/>
<del>-6- <i>Throws:</i> Nothing if the allocator's move constructor throws nothing.</del>
</p>
</blockquote>

</blockquote>
</li>
</ol>






<hr>
<h3><a name="2198" href="2198">2198.</a> <tt>max_load_factor(z)</tt> makes no strong guarantees, but bans useful behavior</h3>
<p><b>Section:</b> 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-10-09 <b>Last modified:</b> 2016-12-10 13:12:32 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The user cannot specify a <tt>max_load_factor</tt> for their unordered container
at construction, it must be supplied after the event, when the container is
potentially not empty.  The contract for this method is deliberately vague, not
guaranteeing to use the value supplied by the user, and any value actually used
will be used as a ceiling that the container will <i>attempt</i> to respect.
</p>
<p>
The only guarantee we have is that, if user requests a <tt>max_load_factor</tt>
that is less than the current <tt>load_factor</tt>, then the operation will take
constant time, thus outlawing an implementation that chooses to rehash and so
preserve as a class invariant that <tt>load_factor &lt; max_load_factor</tt>.
</p>
<p>
Reasonable options conforming to the standard include ignoring the user's request
if the requested value is too low, or deferring the rehash to the next <tt>insert</tt>
operation and allowing the container to have a strange state (wrt <tt>max_load_factor</tt>)
until then - and there is still the question of rehashing if the next <tt>insert</tt>
is for a duplicate key in a unique container.
</p>
<p>
Given the deliberate vagueness of the current wording, to support a range of reasonable
(but not <i>perfect</i>) behaviors, it is not clear why the equally reasonable rehash
to restore the constraint should be outlawed.  It is not thought that this is a performance
critical operation, where users will be repeatedly setting low load factors on populated
containers, in a tight or (less unlikely) an instant response scenario.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to provide wording.
</p>
<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: Howard to provide wording</p>

<p><i>[2016-11-17 Howard provided wording.]</i></p>


<blockquote>
<p>
The provided wording is consistent with LWG discussion in Issaquah.  An implementation
of the proposed wording would be setting <tt>max_load_factor()</tt> to
<tt>max(z, load_factor())</tt>.  This preserves the container invariant:
</p>
<blockquote><pre>
load_factor() &lt;= max_load_factor()
</pre></blockquote>
<p>
And it preserves the existing behavior that no rehash is done by this operation.
</p>
<p>
If it is desired to change the <tt>max_load_factor()</tt> to something smaller than
the current <tt>load_factor()</tt> that can be done by <i>first reducing</i> the
current <tt>load_factor()</tt> by either increasing <tt>bucket_count()</tt> (via
<tt>rehash</tt> or <tt>reserve</tt>), or decreasing <tt>size()</tt> (e.g.
<tt>erase</tt>), <i>and then</i> changing <tt>max_load_factor()</tt>.
</p>

<p>
This resolution reaffirms that <tt>load_factor() &lt;= max_load_factor()</tt> is a
container invariant which can <i>never</i> be violated.
</p>
</blockquote>

<p><i>[2016-11-27, Nico comments]</i></p>

<p>
Current implementations behave differently. 
<p/>
In regard to the sentence
<blockquote>
"The only guarantee we have is that, if user requests a <tt>max_load_factor</tt>
that is less than the current <tt>load_factor</tt>, then the operation will take
constant time, thus outlawing an implementation that chooses to rehash
and so preserve as a class invariant that <tt>load_factor &lt; max_load_factor</tt>."
</blockquote>
Note that the current spec says that there is constant complexity
<em>without</em> any precondition. So, rehashing to keep the invariant would
violate the spec (which is probably not be the intention).
<p/>
This issue is related to LWG <a href="2199">2199</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Modify Table 87 as follows:
</p>

<table border="1">
<caption>Table 87 &mdash; Unordered associative container requirements</caption>

<tr>
<th>
Expression
</th>
<th>
Return type
</th>
<th>
Assertion/note pre-/post-condition
</th>
<th>
Complexity
</th>
</tr>

<tr>
<td>
<tt>a.max_load_factor(z)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<p>
Pre: <tt>z</tt> shall be positive.  May change the container's maximum
load factor, uing <tt>z</tt> as a hint.
</p>
<p>
<ins>Post: <tt>a.load_factor() &lt;= a.max_load_factor()</tt></ins>
</p>
<p>
<ins><i>Note:</i> <tt>a.load_factor()</tt> is not modified by this operation.</ins>
</p>
</td>
<td>
Constant
</td>
</tr>

</table>






<hr>
<h3><a name="2202" href="2202">2202.</a> Missing allocator support by <tt>async</tt></h3>
<p><b>Section:</b> 33.6.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2012-10-19 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a>.</p>
<p><b>Discussion:</b></p>

<p>
<tt>promise</tt>, <tt>packaged_task</tt>, and <tt>async</tt> are the only
places where a shared state is actually supposed to be allocated. Accordingly,
<tt>promise</tt> and <tt>packaged_task</tt> are "allocator-aware". But
function template <tt>async</tt> provides no way to provide an allocator.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Matt: deprecate async 
<p/>
Nico: read my paper 
<p/>
Alisdair: defer issues to wait for polymorphic allocators 
<p/>
Alisdair: defer, active topic of research Deferred 
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
We want whatever status approximates: "will not fix; we're working on a replacement facility and don't want to add features to a broken one"
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2206" href="2206">2206.</a> Inaccuracy in <tt>initializer_list</tt> constructor requirements</h3>
<p><b>Section:</b> 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 29.6.1.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-21 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> p3, we have "<tt>il</tt> designates an object of type
<tt>initializer_list&lt;value_type&gt;</tt>", and then several functions that take
'<tt>il</tt>' as an argument. However, an expression like <tt>{1, 2, 'a'}</tt> is <em>not</em>
an object of type <tt>initializer_list&lt;int&gt;</tt> unless it's used to initialize
an explicitly-typed variable of that type. I believe we want:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v;
v = {1, 2, 'a'};
</pre></blockquote>
<p>
to compile portably, so we should say something different when defining '<tt>il</tt>'. The 
same phrasing happens in 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, and 
29.6.1.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a>.
<p/>
This may just be an editorial issue because the actual class synopses declare the functions 
to take <tt>initializer_list&lt;exact_type&gt;</tt>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This is definitely not NAD
</p>
<p>
Should copy the suggested wording as the proposed resolution.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2214" href="2214">2214.</a> Clarify <tt>basic_ios::init</tt> call restrictions</h3>
<p><b>Section:</b> 30.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andrey Semashev <b>Opened:</b> 2012-11-09 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.ios.cons">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is an ambiguity in how <tt>std::basic_ios::init</tt> method (30.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a>) 
can be used in the derived class. The Standard only specify the state of the <tt>basic_ios</tt> 
object after the call completes. However, in <tt>basic_ios</tt> default constructor description 
(30.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a>) there is this sentence:
</p>
<blockquote><p>
<i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (30.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a>) 
leaving its member objects uninitialized. The object shall be initialized by calling <tt>basic_ios::init</tt> 
before its first use or before it is destroyed, whichever comes first; otherwise the behavior is undefined.
</p></blockquote>
<p>
This restriction hints that <tt>basic_ios::init</tt> should be called exactly
once before the object can be used or destroyed, because <tt>basic_ios::init</tt> 
may not know whether it was called before or not (i.e. whether its members are actually 
uninitialized or are initialized by the previous call to <tt>basic_ios::init</tt>). There 
is no such restriction in the <tt>basic_ios::init</tt> preconditions so it is not clear whether it is
allowed to call <tt>basic_ios::init</tt> multiple times or not.
<p/>
This problem has already affected publicly available implementations.
For example, Microsoft Visual C++ STL introduces a memory leak if
<tt>basic_ios::init</tt> is called multiple times, while GCC 4.7 and STLPort
reinitialize the <tt>basic_ios</tt> object correctly without memory leak or any
other undesired effects. There was a discussion of this issue on Boost
<a href="http://article.gmane.org/gmane.comp.lib.boost.devel/235659">developers mailing list</a>, 
and there is a <a href="https://sourceforge.net/apps/trac/boost-log/ticket/2#comment:4">test case 
that reproduces the problem</a>. The test case is actually a bug report for my Boost.Log library, 
which attempts to cache <tt>basic_ostream</tt>-derived objects internally to avoid expensive construction 
and destruction. My stream objects allowed resetting the stream buffer pointers the stream
is attached to, without requiring to destroy and construct the stream.
<p/>
My personal view of the problem and proposed resolution follows.
<p/>
While apparently the intent of <tt>basic_ios::init</tt> is to provide a way to
initialize <tt>basic_ios</tt> after default construction, I see no reason to
forbid it from being called multiple times to reinitialize the stream.
Furthermore, it is possible to implement a conforming <tt>basic_ios</tt> that
does not have this restriction.
<p/>
The quoted above section of the Standard that describes the effects of
the default constructor is misleading. The Standard does not mandate
any data members of <tt>basic_ios</tt> or <tt>ios_base</tt> (30.5.3 <a href="https://timsong-cpp.github.io/cppwp/ios.base">[ios.base]</a>), which
it derives from. This means that the implementation is allowed to use
non-POD data members with default constructors that initialize the
members with particular default values. For example, in the case of
Microsoft Visual C++ STL the leaked memory is an <tt>std::locale</tt> instance
that is dynamically allocated during <tt>basic_ios::init</tt>, a raw pointer to
which is stored within ios_base. It is possible to store e.g. an
<tt>unique_ptr</tt> instead of a raw pointer as a member of <tt>ios_base</tt>, the smart
pointer will default initialize the underlying raw pointer on default
construction and automatically destroy the allocated object upon being
reset or destroyed, which would eliminate the leak and allow
<tt>basic_ios::init</tt> to be called multiple times. This leads to conclusion
that the default constructor of <tt>basic_ios</tt> cannot leave "its member
objects uninitialized" but instead performs default initialization of
the member objects, which would mean the same thing in case of POD types.
<p/>
However, I feel that restricting <tt>ios_base</tt> and <tt>basic_ios</tt> members to
non-POD types is not acceptable. Since multiple calls to <tt>basic_ios::init</tt> are 
not forbidden by the Standard, I propose to correct the <tt>basic_ios</tt> default 
constructor description so that it is allowed to destroy <tt>basic_ios</tt> object 
without calling <tt>basic_ios::init</tt>. This would imply that any raw members of 
<tt>basic_ios</tt> and <tt>ios_base</tt> should be initialized to values suitable for 
destruction (essentially, this means only initializing raw pointers to NULL). The new 
wording could look like this:
</p>
<blockquote><p>
<i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (30.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a>)
initializing its member objects to unspecified state, only suitable for <tt>basic_ios</tt> destruction.
The object shall be initialized by calling <tt>basic_ios::init</tt> before its first use; otherwise 
the behavior is undefined.
</p></blockquote>
<p>
This would remove the hint that <tt>basic_ios::init</tt> must be called exactly
once. Also, this would remove the requirement for <tt>basic_ios::init</tt> to
be called at all before the destruction. This is also an important issue because 
the derived stream constructor may throw an exception before it manages to call 
<tt>basic_ios::init</tt> (for example, if the streambuf constructor throws), and 
in this case the <tt>basic_ios</tt> destructor has undefined behavior.
<p/>
To my mind, the described modification is sufficient to resolve the issue. But to 
emphasize the possibility to call <tt>basic_ios::init</tt> multiple times, a remark 
or a footnote for <tt>basic_ios::init</tt> postconditions could be added to explicitly 
state the semantics of calling it multiple times. The note could read as follows:
</p>
<blockquote><p>
The function can be called multiple times during the object lifetime. Each subsequent 
call reinitializes the object to the described in postconditions initial state.
</p></blockquote>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Alisdair: The current wording is unclear but the proposed resolution is wrong
<p/>
Solution: Clarify that <tt>init</tt> must be called once and only once. Move then to review. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 30.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a> as indicated:</p>
<blockquote><pre>
basic_ios();
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (30.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a>) 
<del>leaving its member objects uninitialized</del><ins>initializing its member objects to unspecified state, 
only suitable for <tt>basic_ios</tt> destruction</ins>. The object shall be initialized by calling 
<tt>basic_ios::init</tt> before its first use <del>or before it is destroyed, whichever comes first</del>; 
otherwise the behavior is undefined.
</p>
</blockquote>
<pre>
void init(basic_streambuf&lt;charT,traits&gt;* sb);
</pre><blockquote>
<p>
<i>Postconditions</i>: The postconditions of this function are indicated in Table 128.
<p/>
<ins>-?- <i>Remarks</i>: The function can be called multiple times during the object lifetime. Each subsequent 
call reinitializes the object to the described in postconditions initial state.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2215" href="2215">2215.</a> (unordered) associative container functors should be <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-11-14 <b>Last modified:</b> 2015-10-22 17:10:35 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on the functors used to arrange elements in the various associative and
unordered containers are given by a set of expressions in tables 102 &mdash; Associative container
requirements, and 103 &mdash; Unordered associative container requirements.  In keeping with Library
convention these expressions make the minimal requirements necessary on their types.  For
example, we have the following 3 row extracts for the unordered containers:
</p>
<table>
<tr>
  <td>
    <b>Expression</b>
  </td>
  <td>
    <b>Assertion/note pre-/post-condition</b>
  </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n, hf, eq)</tt>
<tt>X a(n, hf, eq)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.
 </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n, hf)</tt>
<tt>X a(n, hf)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> is <tt>CopyConstructible</tt> and 
                  <tt>key_equal</tt> is <tt>DefaultConstructible</tt>.
 </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n)</tt>
<tt>X a(n)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>DefaultConstructible</tt>.
 </td>
</tr>
</table>

<p>
However, the signature for each class template requires that the functors must effectively be
<tt>CopyConstructible</tt> for each of these expressions:
</p>

<blockquote><pre>
template &lt;class Key,
          class T,
          class Hash  = hash&lt;Key>,
          class Pred  = std::equal_to&lt;Key>,
          class Allocator = std::allocator&lt;std::pair&lt;const Key, T> > >
class unordered_map
{
  <i>...</i>

  <i>// construct/destroy/copy</i>
  explicit unordered_map(size_type n = <i>see below</i>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());

  <i>...</i>
}
</pre></blockquote>

<p>
The letter of the standard can be honored as long as implementors recognize
their freedom to split this one signature into multiple overloads, so that
the documented default arguments (requiring a <tt>CopyConstructible</tt> functor)
are not actually passed as default arguments.
</p>
<p>
As we look into the requirements for the copy constructor and copy-assignment
operator, the requirements are even more vague, as the explicit requirements on
the functors are not called out, other than saying that the functors are copied.
</p>
<p>
Must the functors be <tt>CopyAssignable</tt>? Or is <tt>CopyConstructible</tt>
sufficient in this case?  Do we require that the functors be <tt>Swappable</tt>
so that the copy-swap idiom can be deployed here?  Note that a type that is both
<tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> is still not guaranteed to
be <tt>Swappable</tt> as the user may delete the <tt>swap</tt> function for their
type in their own namespace, which would be found via ADL.
</p>
<p>
Some clean-up of the requirements table looks necessary, to at least document the
assignment behavior.  In addition, we should have clear guidance on whether these
functors should always be <tt>CopyConstructible</tt>, as suggested by the class
template definitions, or if the requirement tables are correct and we should
explicitly split up the constructors in the (unordered) associative containers
to no longer use default (function) arguments to obtain their defaulted functors.
</p>
<p>
I recommend the simplest solution would be to always require that the functors
for (unordered) associative containers be <tt>CopyConstructible</tt>, above the
requirements tables themselves, so that the issue need not be addressed within
the tables.  I suggest that the assignment operators for these containers add
the requirement that the functors be <tt>Swappable</tt>, rather than forwarding
the corresponding <tt>Assignable</tt> requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to propose wording.
</p>

<p><i>[2014-06-08, Daniel comments]</i></p>

<p>
The area of this issue partially overlaps what LWG <a href="2227">2227</a> addresses.
</p>

<p><i>[2015-10-20, Daniel comments]</i></p>

<p>
The revised resolution of LWG <a href="2227">2227</a> should resolve this issue as well. It follows the recommendations
of the submitter to require <tt>CopyConstructible</tt> requirements for the function objects owned by containers,
but it does not impose any further fundamental requirements.
</p>


<p><b>Proposed resolution:</b></p>
<p>
See the resolution of LWG <a href="2227">2227</a>.
</p>





<hr>
<h3><a name="2216" href="2216">2216.</a> <tt>regex_replace(basic_string)</tt> allocator handling</h3>
<p><b>Section:</b> 31.11.4 <a href="https://timsong-cpp.github.io/cppwp/re.alg.replace">[re.alg.replace]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-11-26 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.alg.replace">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.alg.replace">[re.alg.replace]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<blockquote><pre>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
      const basic_regex&lt;charT, traits&gt;&amp; e,
      const charT* fmt,
      regex_constants::match_flag_type flags = 
	    regex_constants::match_default);
</pre></blockquote>
<p>
and friends are documented as
</p>
<blockquote><p>
Constructs an empty string result of type <tt>basic_string&lt;charT, ST, SA&gt;</tt>
and calls <tt>regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags)</tt>.
</p></blockquote>
<p>
This appears to require the result to have a default-constructed
allocator, which isn't even possible for all allocator types. I
suspect the allocator should be copied from 's' instead. Possibly
there should be an additional defaulted argument to override the
allocator of the result.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2220" href="2220">2220.</a> Under-specification of <tt>operator==</tt> for <tt>regex_token_iterator</tt></h3>
<p><b>Section:</b> 31.12.2.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.comp">[re.tokiter.comp]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-11-21 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Consider the following example:
</p>
<blockquote><pre>
std::string str0("x");
std::regex rg0("a");
std::regex_token_iterator it0(str0.begin(), str0.end(), rg0, -1); // points at "x" in str0
std::string str1("x");
std::regex rg1("b");
std::regex_token_iterator it1(str1.begin(), str1.end(), rg1, -1); // points at "x" in str1
</pre></blockquote>
<p>
31.12.2.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.comp">[re.tokiter.comp]</a> p1 says that <tt>it0.operator==(it1)</tt> returns true "if 
<tt>*this</tt> and <tt>right</tt> are both suffix iterators and <tt>suffix == right.suffix</tt>"; both 
conditions are satisfied in this example. It does not say that they must both be iterators 
into the same sequence, nor does it say (as general iterator requirements do) that they must 
both be in the domain of <tt>==</tt> in order for the comparison to be meaningful. It's a 
simple statement: they're equal if the strings they point at compare equal. Given this being
a valid comparison, the obtained result of "true" looks odd.
<p/>
The problem is that for iterator values prior to the suffix iterator, equality means the same 
regular expression and the same matched sequence (both uses of "same" refer to identity, not equality); 
for the suffix iterator, equality means that the matched sequences compare equal.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2226" href="2226">2226.</a> <tt>wstring_convert</tt> methods do not take allocator instance</h3>
<p><b>Section:</b> 99 [conversions.string] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Glen Fernandes <b>Opened:</b> 2012-12-14 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>wstring_convert</tt> class template, described in 99 [conversions.string], does not 
support custom stateful allocators. It only supports custom stateless allocators.
<p/>
The <tt>to_bytes</tt> member function returns <tt>basic_string&lt;char, char_traits&lt;char&gt;, Byte_alloc&gt;</tt>  
but it does not take an instance of <tt>Byte_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
Similarly the <tt>from_bytes</tt> member function returns <tt>basic_string&lt;Elem, char_traits&lt;Elem&gt;, Wide_alloc&gt;</tt>  
but it does not take an instance of <tt>Wide_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
This makes these two member functions and the <tt>wstring_convert</tt> class template not usable when <tt>Wide_alloc</tt> 
or <tt>Byte_alloc</tt> are stateful allocators.
</p>

<p><i>[2013-01-22, Glen provides wording]</i></p>


<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to NAD Future.
</p>
<p>
This is clearly an extension that the LEWG may want to take a look at, once we have more experience
with appropriate use of allocators with the C++11 model.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>In 99 [conversions.string]/2 and /6 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>from_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Wide_alloc</tt>:</p>

<blockquote><pre>
wide_string from_bytes(char byte<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *ptr<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const byte_string&amp; str<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *first, const char *last<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In 99 [conversions.string] /8 specify that this <tt>Wide_alloc</tt> allocator parameter is used to
construct the <tt>wide_string</tt> object returned from the function:</p>

<p>
-7- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>byte</tt> to a wide string.
The second member function shall convert the null-terminated sequence beginning at <tt>ptr</tt> to a wide
string. The third member function shall convert the sequence stored in <tt>str</tt> to a wide string. The fourth
member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a wide string.
<p/>
-8- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Wide_alloc</tt> allocator parameter is used to construct the <tt>wide_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

<li><p>In 99 [conversions.string]/2 and /12 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>to_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Byte_alloc</tt>:</p>

<blockquote><pre>
byte_string to_bytes(Elem wchar<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *wptr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const wide_string&amp; wstr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *first, const Elem *last<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In 99 [conversions.string] /13 specify that this <tt>Byte_alloc</tt> allocator parameter is used to
construct the <tt>byte_string</tt> object returned from the function:</p>

<p>
-12- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>wchar</tt> to a byte string.
The second member function shall convert the null-terminated sequence beginning at <tt>wptr</tt> to a byte
string. The third member function shall convert the sequence stored in <tt>wstr</tt> to a byte string. The
fourth member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a byte string.
<p/>
-13- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Byte_alloc</tt> allocator parameter is used to construct the <tt>byte_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

</ol>





<hr>
<h3><a name="2227" href="2227">2227.</a> Stateful comparison objects in associative containers</h3>
<p><b>Section:</b> 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2012-12-19 <b>Last modified:</b> 2016-08-07 09:08:51 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 102 in 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>/8 states on expression <tt>a.key_comp()</tt> that it 
"returns the comparison object out of which a was constructed". At the same time, 
26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/8 states (starting in the third line) that 
"...Any <tt>Compare</tt>, <tt>Pred</tt>, or <tt>Hash</tt> objects belonging to <tt>a</tt> and <tt>b</tt> 
shall be swappable and <em>shall be exchanged</em> by unqualified calls to non-member swap...". This is 
problematic for any compliant implementation, since once swapped the container cannot return the comparison 
object out of which it was constructed unless incurring in storing an otherwise needless object.
<p/>
The simple solution is to correct that statement in Table 102, but I believe this is part of a larger problem 
of underspecified behavior: The new standard has made an effort in regards to allocators and now fully 
specifies what happens to stateful allocator objects. It has even specified what happens to stateful <tt>hasher</tt> 
and <tt>key_equal</tt> members of unordered containers (they propagate), but it says nothing about stateful 
comparison objects of (ordered) associative containers, except for the statement in 
26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/8 referred above and only related to <tt>swap</tt>.
<p/>
For example, it is unclear to me what is specified to happen on an assignment: should the comparison object 
be copied/moved along with the elements, or should the left-hand side object keep its own?
Maybe this has been intentionally left unspecified with the purpose of compatibility with C++98, which I 
understand it specified that comparison objects were kept for the entire life of the container (like allocators) 
&mdash; an unfortunate choice. But anyway, the segment of 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> quoted 
above seems to break any possible backwards compatibility with C++98 in this regard.
<p/>
Therefore, taking into consideration consistency with how this is dealed with for unordered associative 
containers, I propose that Table 102 is modified as follows:
</p>
<ul>
<li>
<p>
The row for expression <tt>a.key_comp()</tt> is changed so that its "assertion/note pre-/post-condition" reads 
"Returns <tt>a</tt>'s comparison object."
</p>
</li>

<li>
<p>
A new row is added at the appropriate location (which I believe would be after "X(il)" row), with:
</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td>
<tt>X(b)<br/>
X a(b)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
Copy constructor. In addition to<br/>
the requirements of Table 96, copies<br/>
the comparison object.
</td>
<td>
Linear in <tt>b.size()</tt>
</td>
</tr>

<tr>
<td>
<tt>a = b</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
Copy assignment operator. In addition to<br/>
the requirements of Table 96, copies the<br/>
comparison object.
</td>
<td>
Linear in <tt>a.size()</tt> and <tt>b.size()</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ul>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Review.
</p>

<p><i>[2013-04-18, Bristol]</i></p>
 
<p>
STL: can't believe we don't specify this already. this is totally necessary
<p/>
Alisdair: how does it do this? copy construction? assignment?
<p/>
Also need it for move.
<p/>
STL: we already specify this for constructing from a comparator, not during copy construction though.
<p/>
Jonathan: don't like wording, should say "<tt>key_compare</tt> is <tt>CopyConstructible</tt>. Uses <tt>b.key_comp()</tt> 
as a comparison object."
<p/>
STL: we get it right for unordered!
<p/>
Jonathan: can't wordsmith this now, but I think implementations do the right thing.
<p/>
Alisdair: not sure what right thing is for moves. Also we say nothing about propagating allocators to functors.
</p>
<p>
Moved to Open.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
TK: There's no need for fine-grained propagate/not-propagate control. If you don't want to propagate the predicate, you can 
simply construct or insert from an iterator range.
<p/>
VV: libstdc++ already implements the resolution of this issue.
<p/>
GR: There are a couple of other problems. We don't specify move constructor and move assignment for maps. Those are just general.
<p/>
TK: General container requirements already describe the semantics for {copy,move}-{construction,assignment}, so it doesn't 
seem that there's room for choice in <tt>std::map</tt> assignments. <tt>unordered_map</tt> is different, though.
<p/>
[Note: Check what general container requirements say about container equality.]
<p/>
DK will draft wording. The decision is to unambiguously make all {copy,move}-{construction,assignment} operations endow the 
LHS with the exact state of the RHS, including all predicates and hash function states.
<p/>
Conclusion: Update wording, revisit later. 
</p>

<p><i>[2015-05-06 Lenexa: Waiting for updated wording]</i></p>


<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Change Table 102 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(il)</tt>
</td>
<td>
<tt></tt>
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
<td>
same as <tt>X(il.begin(), il.end())</tt>.
</td>
</tr>

<tr>
<td>
<ins><tt>X(b)<br/>
X a(b)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>Copy constructor. In addition to<br/>
the requirements of Table 96, copies<br/>
the comparison object.</ins>
</td>
<td>
<ins>Linear in <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = b</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>Copy assignment operator. In addition to<br/>
the requirements of Table 96, copies the<br/>
comparison object.</ins>
</td>
<td>
<ins>Linear in <tt>a.size()</tt> and <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.key_comp()</tt>
</td>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<del>r</del><ins>R</ins>eturns <del>the</del><ins><tt>a</tt>'s</ins> comparison object<br/>
<del>out of which a was constructed.</del>
</td>
<td>
constant
</td>
</tr>


</table>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2015-10-19 Daniel comments and provides alternative wording]</i></p>

<p>
The current standard is especially unclear in regard to what effects move operations of unordered/associative
containers should have. We have one example that is standardized exactly in this way by looking at 
26.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/priqueue.cons.alloc">[priqueue.cons.alloc]</a> p7:
</p>
<blockquote>
<pre>
template &lt;class Alloc&gt; priority_queue(priority_queue&amp;&amp; q, const Alloc&amp; a);
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> as the first argument and <tt>a</tt> as 
the second argument, and initializes <tt>comp</tt> with <tt>std::move(q.comp)</tt>
</p>
</blockquote>
</blockquote>
<p>
A similarly comparable example are the move-operations of <tt>std::unique_ptr</tt> in regard to the deleter 
(when this is no a reference), which also respect move-capabilities of that function object.
<p/>
We have wording from C++98 for associative containers (but <em>not</em> for unordered containers!) that was never
adjusted to C++11 move-semantics in 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> p12:
</p>
<blockquote><p>
When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.
</p></blockquote>
<p>
The second sentence of this wording is problematic for several reasons:
</p>
<ol>
<li><p>It only talks about copy operations, not about move operations, except that the term "assignment" without
leading "copy" is a bit ambigious (albeit it seems clear in the complete context).</p></li>
<li><p>It is not really clear how to interpret "as if that comparison object had been
passed to the target container in its constructor" for an assignment operation. A possible but not conclusive
interpretation could be that this is wording supporting a "copy-via-swap" idiom.</p></li>
<li><p>There does not exist similar wording for unordered containers, except that Table 102 provides entries for
copy construction and copy assignment of the containers whose wording just talks of "copies" in either case.</p></li>
</ol>
<p>
Existing implementations differ already:
</p>
<ol>
<li><p>Visual Studio 2015 uses copy construction and copy assignment for the two copy operations but uses swap operations
for the move operations.</p></li>
<li><p>GCC's libstdc++ performs copy construction and copy assignment for the two copy operations and for the two
move operations, respectively</p></li>
<li><p>clang++'s libc++ performs copy/move construction and copy/move assignment for the corresponding
four copy/move operations</p></li>
</ol>
<p>
The alternative wording provided below attempts to clarify that container copy/move operations perform the corresponding
copy/move operations on the owned function objects.
<p/>
In addition the wording also resolves LWG <a href="2215">2215</a>: I believe that the current
wording should require that container function objects should meet the <tt>CopyConstructible</tt> requirements. Adding
this general requirement also fixes the underspecified requirements of the accessor functions <tt>key_comp()</tt> and
<tt>value_comp()</tt>.
<p/>
I don't think that a general requirement for <tt>Swappable</tt> is needed, only the member <tt>swap</tt> function currently requires this.
Nonetheless the wording below does <em>support</em> stateful functors that are <em>also</em> moveable or move-assignable,
therefore the specified semantics in terms of move operations.
<p/>
I should add the following warning, though: If this proposed wording would be accepted, there is a little chance of
code breakage, because the current wording <em>can</em> be read that in general there is no requirement that the
container functors are <tt>CopyConstructible</tt>. The following code example is accepted by gcc + libstd++:
</p>
<blockquote><pre>
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

struct Cmp {
  Cmp() = default;
  Cmp(const Cmp&amp;) = delete;
  Cmp(Cmp&amp;&amp;) = delete;
  Cmp&amp; operator=(const Cmp&amp;) = delete;
  Cmp&amp; operator=(Cmp&amp;&amp;) = delete;
  template&lt;class T&gt;
  bool operator()(const T&amp; x, const T&amp; y) const
  {
    return x &lt; y;
  }
};

typedef std::map&lt;int, int, Cmp&gt; MyMap;

int main() {
  MyMap m;
  std::cout &lt;&lt; (m.find(12) == m.end()) &lt;&lt; std::endl;
}
</pre></blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4527.</p>

<ol>
<li><p>Change 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> p8 as indicated:</p>

<blockquote><p>
-8- In Table 101, <tt>X</tt> denotes an associative container class, <tt>a</tt> denotes a value of type <tt>X</tt>, 
<ins><tt>b</tt> denotes a possibly <tt>const</tt> value of type <tt>X</tt>, <tt>rv</tt> denotes a non-<tt>const</tt> rvalue of 
type <tt>X</tt>,</ins> <tt>u</tt> denotes the name of a variable being declared, [&hellip;]
</p></blockquote>
</li>

<li><p>Change Table 101 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 101 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<tt>Compare</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Compare</tt> is <tt>CopyConstructible</tt>.</ins><br/>
defaults to <tt>less&lt;key_type&gt;</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X(c)<br/>
X u(c);</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<del><i>Requires:</i> <tt>key_compare</tt> is <tt>CopyConstructible</tt>.<br/></del> 
<i>Effects</i>: Constructs an empty container.<br/> 
Uses a copy of <tt>c</tt> as a comparison object.
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(i,j,c)<br/>
X u(i,j,c);</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<i>Requires:</i> <del><tt>key_compare</tt> is <tt>CopyConstructible</tt>.<br/></del> 
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: Constructs an empty container and inserts elements<br/>
from the range <tt>[i, j)</tt> into it; uses <tt>c</tt> as a comparison object.
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(il)</tt>
</td>
<td>
<tt></tt>
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
<td>
same as <tt>X(il.begin(), il.end())</tt>.
</td>
</tr>

<tr>
<td>
<ins><tt>X(b)<br/>
X a(b)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>(In addition to the requirements of Table 95)<br/>
<i>Effects:</i> Copy constructs the comparison object of <tt>a</tt> from<br/> 
the comparison object of <tt>b</tt>.</ins>
</td>
<td>
<ins>Linear in <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>X(rv)<br/>
X a(rv)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Effects:</i> Move constructs the comparison object of <tt>a</tt> from<br/> 
the comparison object of <tt>rv</tt>.</ins>
</td>
<td>
<ins>constant</ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = b</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>key_compare</tt> is <tt>CopyAssignable</tt>.<br/> 
<i>Effects:</i> Copy assigns the comparison object of <tt>b</tt><br/>
to the comparison object of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear in <tt>a.size()</tt> and <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = rv</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>key_compare</tt> is <tt>MoveAssignable</tt>.<br/> 
<i>Effects:</i> Move assigns from the comparison object of <tt>rv</tt><br/>
to the comparison object of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.key_comp()</tt>
</td>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<del>r</del><ins>R</ins>eturns <del>the</del><ins><tt>a</tt>'s</ins> comparison object<br/>
<del>out of which a was constructed.</del>
</td>
<td>
constant
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> p12 as indicated:</p>

<blockquote><p>
-12- When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. <del>When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.</del>
</p></blockquote>
</li>


<li><p>Change 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p11 as indicated:</p>

<blockquote><p>
-11- In Table 102: <tt>X</tt> denotes an unordered associative container class, <tt>a</tt> denotes a value of type <tt>X</tt>, 
<tt>b</tt> denotes a possibly <tt>const</tt> value of type <tt>X</tt>, <ins><tt>rv</tt> denotes a non-<tt>const</tt> rvalue 
of type <tt>X</tt>,</ins> [&hellip;]
</p></blockquote>
</li>

<li><p>Change Table 102 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::hasher</tt>
</td>
<td>
<tt>Hash</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Hash</tt> is <tt>CopyConstructible</tt>.<br/></ins>
<tt>Hash</tt> shall be a unary function object type<br/> 
such that the expression <tt>hf(k)</tt> has type <tt>std::size_t</tt>.
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::key_equal</tt>
</td>
<td>
<tt>Pred</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Pred</tt> is <tt>CopyConstructible</tt>.<br/></ins>
<tt>Pred</tt> shall be a binary predicate that takes<br/> 
two arguments of type <tt>Key</tt>.<br/> 
<tt>Pred</tt> is an equivalence relation.
</td>
<td>
compile time
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(n, hf, eq)<br/>
X a(n, hf, eq)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<del><i>Requires</i>: <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.<br/></del>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>X(n, hf)<br/>
X a(n, hf)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> is <tt>CopyConstructible</tt> and<br/></del>
<tt>key_equal</tt> is <tt>DefaultConstructible</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(i, j, n, hf, eq)<br/>
X a(i, j, n, hf, eq)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.<br/></del>
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>X(i, j, n, hf)<br/>
X a(i, j, n, hf)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> is <tt>CopyConstructible</tt> and<br/></del>
<tt>key_equal</tt> is <tt>DefaultConstructible</tt>.<br/> 
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(b)<br/>
X a(b)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<del>Copy constructor. In addition<br/>
to the requirements of Table 95,<br/>
copies the hash function,<br/>
predicate, and maximum load<br/>
factor.</del>
<ins>(In addition to the requirements of Table 95)<br/>
<i>Effects:</i> Copy constructs the hash function, predicate, and maximum load factor<br/> 
of <tt>a</tt> from the corresponding objects of <tt>b</tt>.</ins>
</td>
<td>
Average case linear in<br/> 
<tt>b.size()</tt>,<br/>
worst case quadratic.
</td>
</tr>

<tr>
<td>
<ins><tt>X(rv)<br/>
X a(rv)</tt></ins>
</td>
<td>
<ins><tt>X</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Effects:</i> Move constructs the hash function, predicate, and maximum load factor<br/> 
of <tt>a</tt> from the corresponding objects of <tt>rv</tt>.</ins>
</td>
<td>
<ins>constant</ins>
</td>
</tr>

<tr>
<td>
<tt>a = b</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<del>Copy assignment operator. In<br/>
addition to the requirements of<br/>
Table 95, copies the hash<br/>
function, predicate, and<br/>
maximum load factor.</del>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyAssignable</tt>.<br/> 
<i>Effects:</i> Copy assigns the hash function, predicate, and maximum load factor<br/> 
of <tt>b</tt> to the corresponding objects of <tt>a</tt>.</ins>
</td>
<td>
Average case linear in<br/> 
<tt>b.size()</tt>,<br/>
worst case quadratic.
</td>
</tr>

<tr>
<td>
<ins><tt>a = rv</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>MoveAssignable</tt>.<br/> 
<i>Effects:</i> Move assigns the hash function, predicate, and maximum load factor<br/> 
from <tt>rv</tt> to the corresponding objects of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2016-08-07]</i></p>

<p>
Daniel removes the previously proposed wording to work on revised wording.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2232" href="2232">2232.</a> [CD] The <tt>char_traits</tt> specializations should declare their <tt>length()</tt>, <tt>compare()</tt>, and 
<tt>find()</tt> members constexpr</h3>
<p><b>Section:</b> 24.2.3 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations">[char.traits.specializations]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-12-24 <b>Last modified:</b> 2016-10-31 21:10:13 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.specializations">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations">[char.traits.specializations]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses ES 14, US 19</b></p>

<p>
These functions have easy recursive constexpr implementations that, unfortunately, aren't efficient at runtime. 
EWG is still figuring out how to solve this problem in general (e.g., 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3444.html">N3444</a> isn't sufficient to avoid 
stack overflows in debug builds or to get the optimal assembly-based implementations at runtime), so users can't 
portably solve this problem for themselves, but implementations can use compiler-specific techniques to choose 
the right implementation inside their standard libraries.
</p>

<p>
The LWG is still undecided about whether individual implementations can add constexpr to these functions, so we 
need to add <tt>constexpr</tt> to the standard here for implementations to be able to improve this.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
There are a number of people who have a strong interest in this issue not available for the telecon.
</p>
<p>
It also plays at the heart of a discussion about library freedoms for <tt>constexpr</tt> and specifying
a library that may depend on unspecified compiler intrinsics to be implementable.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Moved to NAD Future.
</p>
<p>
While it is clear that this feature can be implemented using only C++14 <tt>constexpr</tt> features,
there is real concern that we cannot call the efficient, highly optimized, C implementations of these
functions under a C++14 <tt>constexpr</tt> implementation, nor implement similar ourselves as this
typically involves use of inline <tt>asm</tt> instructions.
</p>
<p>
Clang and libc++ have some experience of using intrinsics to try to address the performance issue, but
the current intrinsics are not general enough to support <tt>char_traits</tt>.  The intrinsics support
only operations on character string literals, and the string literal is no longer visible <i>as</i> a
literal after passing as a <tt>const char *</tt> to the <tt>char_traits</tt> functions.
</p>
<p>
Additional concern was raised that these operations are unlikely to be useful anyway, as the only client
is <tt>basic_string</tt> which relies on dynamic memory allocation, and so cannot effectively be made a
literal type.  Jeffrey then pointed out the pending <tt>string_view</tt> library that will also use
<tt>char_traits</tt> and would most certainly benefit from being a literal type.
</p>

<p>
Given the choice of giving up performance on a critical library component, or requiring a compiler
intrinsic with only unsuccessful implementation experience, the consensus is to not reject this, unless
compelling implementation experience is demonstrated.  NAD Future seems the appropriate resolution.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 24.2.3.1 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char">[char.traits.specializations.char]</a>, 24.2.3.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char16_t">[char.traits.specializations.char16_t]</a>, 
24.2.3.3 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char32_t">[char.traits.specializations.char32_t]</a>, and 24.2.3.4 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.wchar.t">[char.traits.specializations.wchar.t]</a>:</p>
<blockquote><pre>
static <ins>constexpr</ins> int compare(const char_type* s1, const char_type* s2, size_t n);
static <ins>constexpr</ins> size_t length(const char_type* s);
static <ins>constexpr</ins> const char_type* find(const char_type* s, size_t n, const char_type&amp; a);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="2236" href="2236">2236.</a> <tt>kill_dependency</tt> unconditionally noexcept</h3>
<p><b>Section:</b> 32.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>, 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-01-19 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.syn">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The "magic" <tt>kill_dependency</tt> function is a function without any constraints on the template parameter <tt>T</tt> 
and is specified as
</p>

<blockquote><pre>
template &lt;class T&gt;
T kill_dependency(T y) noexcept;
</pre><blockquote>
<p>
-14- <i>Effects</i>: The argument does not carry a dependency to the return value (1.10).
<p/>
-15- <i>Returns</i>: <tt>y</tt>.
</p>
</blockquote></blockquote>

<p>
I wonder whether the unconditional <tt>noexcept</tt> is really intended here:
Assume we have some type <tt>U</tt> that has a potentially throwing move
constructor (or it has a potentially throwing copy constructor and no
move constructor), for any "normal" function template with the same
signature and the same effects (modulo the dependency magic) this
would mean that it cannot safely be declared <tt>noexcept</tt> because of the
return statement being part of the complete function call affected by
<tt>noexcept</tt> (The by-value function argument is irrelevant in this
context). In other words it seems that a function call such as
</p>

<blockquote><pre>
struct S {
  ...
  S(const S&amp; r) { if(<em>some condition</em>) throw Something(); }
  ...
};

int main() {
  S s1 = ...;
  S s2 = std::kill_dependency(s1);
}
</pre></blockquote>

<p>
would be required to call <tt>std::terminate</tt> if the copy constructor of <tt>S</tt> throws during the return 
of <tt>std::kill_dependency</tt>.
<p/>
To require copy elision for this already magic function would look like a low-hanging fruit to solve this problem, 
but this case is not covered by current copy elision rules see 12.8 p31 b1:
<p/>
"&mdash; in a return statement in a function with a class return type, when the expression is the name of a non-volatile 
automatic object (other than a function or catch-clause parameter) with the same <em>cv</em>-unqualified type as the 
function return type, the copy/move operation can be omitted by constructing the automatic object directly into the
function's return value".
<p/>
Some options come into my mind:
</p>
<ol>
<li><p>
Make the exception-specification a constrained one in regard via <tt>std::is_nothrow_move_constructible</tt>:
</p>

<blockquote><pre>
template &lt;class T&gt;
T kill_dependency(T y) noexcept(<em>see below</em>);
</pre></blockquote>

<p>
This is similar to the approach taken for function templates such as <tt>std::swap</tt>.
</p>
</li>

<li><p>
Use perfect forwarding (This needs further wording to correct the effects):
</p>

<blockquote><pre>
template &lt;class T&gt;
T&amp;&amp; kill_dependency(T&amp;&amp; y) noexcept;
</pre></blockquote>
</li>

<li><p>
Impose constraints on the template arguments in regard to throwing exceptions while copying/moving.
</p></li>

<li><p>
Keep the state as it is but possibly add a note about a call of <tt>std::terminate</tt> in above scenario.
</p></li>
</ol>

<p>
A second problem is that the current wording is not clear whether it is well-defined to call the function with
types that are reference types, such as in the following example:
</p>

<blockquote><pre>
#include &lt;atomic&gt;

int main()
{
  int a = 12;
  int&amp; b = std::kill_dependency&lt;int&amp;&gt;(a);
}
</pre></blockquote>

<p>
It is unclear what kind of dependency is killed here. This is presumably a core language problem, but could
affect the possible resolutions of the problem.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>
Recommend using a revised example:
</p>
<blockquote><pre>
int lookup(class D* p) 
{
  class E* q = p-&gt;a.load(memory_order_consume);
  int y = std::kill_dependency(q-&gt;y);
}
</pre></blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2237" href="2237">2237.</a> <tt>&lt;cuchar&gt;</tt> macros</h3>
<p><b>Section:</b> 24.5 <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2013-01-29 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Apparently C1X changes <tt>__STDC_UTF_16__</tt> and <tt>__STDC_UTF_32__</tt> from macros
defined in <tt>uchar.h</tt> (and reflected in C++ by Table 79) to be predefined by the compiler. 
Do we want to do the same?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2238" href="2238">2238.</a> Problematic iterator-pair constructor of containers</h3>
<p><b>Section:</b> 24.5 <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Johannes Schaub <b>Opened:</b> 2013-02-02 <b>Last modified:</b> 2016-08-09 17:08:48 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The non-explicit nature of the iterator-pair constructor of containers, such a
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</pre></blockquote>

<p>
can be selected in unexpected situations, leading to a hard runtime error, as demonstrated by the following example:
</p>

<blockquote><pre>
#include &lt;vector&gt;

void f(std::vector&lt;char&gt; v){ /* ... */}

int main() {
  f({"A", "B"});
}
</pre></blockquote>

<p>
The actually intended initializer-list constructor isn't feasible here, so the best match is the constructor template
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</pre></blockquote>

<p>
This compiles, but will result in code running amok. The potential trap (that cannot be easily detected by the
library implementation) could be reduced by making this constructor explicit. It would still have the effect to 
be selected here, but the code would be ill-formed, so the programmer gets a clear message here.
</p>

<p><i>[2014-06 Rapperswil]</i></p>

<p>
JW: can't fix this, don't want to touch this, Do The Right Thing clause has been a source of tricky issues. 
only really happens with string literals, that's the only way to create an array that isn't obviously an array
<p/>
GR: want to see paper
<p/>
AM: is it only string literals, or also UDLs?
<p/>
STL: maybe, but we don't need to deal with that. This is only a problem in a very specific case 
<p/>
Leave as Open. 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2242" href="2242">2242.</a> <tt>[uninitialized_]copy_n()</tt> defect</h3>
<p><b>Section:</b> 28.6.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>, 23.10.10.4 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Sean Parent <b>Opened:</b> 2013-02-14 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>copy_n()</tt> and <tt>uninitialized_copy_n()</tt> only return the output iterator, and not the input iterator. 
Likely the interface was simply copied from the original STL. Unfortunately the interface in the original STL contains a bug.
<p/>
<tt>copy_n()</tt> and <tt>uninitialized_copy_n()</tt> must return the resulting input iterator as well as the output 
iterator (I would suggest returning a pair). Without this, there is no way to continue reading from an actual input 
iterator &mdash; and if it is really a forward iterator, it will cost <tt>n</tt> increments to get back to where you were.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: refer to LEWG</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2243" href="2243">2243.</a> <tt>istream::putback</tt> problem</h3>
<p><b>Section:</b> 30.7.4.3 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2013-03-01 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.7.4.3 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> / 34, when describing <tt>putback</tt>, it says that "<tt>rdbuf-&gt;sputbackc()</tt>" 
is called. The problem are not the obvious typos in the expression, but the fact that it may lead to different 
interpretations, since nowhere is specified what the required argument to <tt>sputbackc</tt> is.
<p/>
It can be guessed to be "<tt>rdbuf()-&gt;sputbackc(c)</tt>", but "<tt>rdbuf()-&gt;sputbackc(char_type())</tt>" or 
just anything would be as conforming (or non-confoming) as the first guess.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2248" href="2248">2248.</a> <tt>numeric_limits::is_iec559</tt> misnamed</h3>
<p><b>Section:</b> 21.3.4 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2013-03-08 <b>Last modified:</b> 2017-02-25 12:02:15 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.limits">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This member should probably be named "is_ieee754". Or at least the standard should explain that IEC-559 no longer exists, 
and that it's been superseded by IEEE-754.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2262" href="2262">2262.</a> Requirement for <tt>unique_ptr&lt;T&gt;::get_deleter()(p)</tt> to be able to destroy the <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rob Desbois <b>Opened:</b> 2013-05-15 <b>Last modified:</b> 2017-03-14 03:03:42 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N3337 23.11.1.2.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a> contains 2 non-normative notes stating:
</p>

<blockquote>
<p>
[para 4]: &quot;The order of these operations is significant because the call to <tt>get_deleter()</tt> 
may destroy <tt>*this</tt>.&quot;
</p>
<p>
[para 5]: &quot;The postcondition does not hold if the call to <tt>get_deleter()</tt> destroys <tt>*this</tt> since 
<tt>this->get()</tt> is no longer a valid expression.&quot;
</p>
</blockquote>

<p>
It seems this wording was created to resolve <a href="998">998</a> due to the possibility that a <tt>unique_ptr</tt> may be 
destroyed through deletion of its stored pointer where that directly or indirectly refers to the same <tt>unique_ptr</tt>. 
If <tt>unique_ptr</tt> is required to support circular references then it seems this must be normative text: an implementation 
is currently allowed to operate on <tt>*this</tt> after the assignment and deletion specified in para 4, since this is only 
'disallowed' by the non-normative note.
</p>

<p>I propose the following draft rewording:</p>

<p>
[para 4]: <i>Effects</i>: assigns <tt>p</tt> to the stored pointer, and then if the old value of the stored pointer, <tt>old_p</tt>, was not
equal to <tt>nullptr</tt>, calls <tt>get_deleter()(old_p)</tt>. <ins>No operation shall be performed after the call to 
<tt>get_deleter()(old_p)</tt> that requires <tt>*this</tt> to be valid, because the deletion may destroy <tt>*this</tt> if it is 
referred to directly or indirectly by the stored pointer.</ins> <del>[<i>Note:</i> The order of these operations is significant
because the call to <tt>get_deleter()</tt> may destroy <tt>*this</tt>. &mdash; <i>end note</i>]</del>
<p/>
[para 5]: <i>Postconditions</i>: <ins>If the call <tt>get_deleter()(old_p)</tt> destroyed <tt>*this</tt>, none. Otherwise,</ins> 
<tt>get() == p</tt>. <del>[<i>Note:</i> The postcondition does not hold if the call to <tt>get_deleter()</tt>
destroys <tt>*this</tt> since <tt>this->get()</tt> is no longer a valid expression. &mdash; <i>end note</i>]</del>
</p>

<p>
I expect it will also be necessary to amend the requirements for a deleter, so in addition:
</p>

<p>
23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> [para 1]: The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>Where <tt>D</tt> is not an lvalue reference type, <tt>d(ptr)</tt> shall be valid if <tt>ptr</tt> 
refers directly or indirectly to the invoking <tt>unique_ptr</tt> object.</ins>
</p>

<p><i>[2013-10-05, Stephan T. Lavavej comments and provides alternative wording]</i></p>

<p>
In Chicago, we determined that the original proposed change to 23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a>/1 was insufficient, because 
<tt>d</tt> might be a reference to a deleter functor that's destroyed during self-destruction.
<p/>
We believed that 23.11.1.2.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a>/4 was already sufficiently clear. The Standard occasionally prevents 
implementations of <tt>X</tt> from doing various things, through the principle of "nothing allows <tt>X</tt> to fail in that situation".  
For example, <tt>v.push_back(v[0])</tt> is required to work for non-empty vectors because nothing allows that to fail. In this case, 
the intent to allow self-destruction is already clear.
<p/>
Additionally, we did not believe that 23.11.1.2.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a>/5 had to be changed. The current note is slightly 
squirrely but it does not lead to confusion for implementers or users.
</p>

<p>
Previous resolution from Rob Desbois:
</p>
<blockquote class="note">
<ol>
<li>
<p>
Edit 23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>Where <tt>D</tt> is not an lvalue reference type, <tt>d(ptr)</tt> shall be valid if <tt>ptr</tt> 
refers directly or indirectly to the invoking <tt>unique_ptr</tt> object.</ins>
</p></blockquote>
</li>

<li>
<p>
Edit 23.11.1.2.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a> p4+5 as indicated:
</p>
<blockquote><pre>
void reset(pointer p = pointer()) noexcept;
</pre><blockquote>
<p>
-3- <i>Requires:</i> The expression <tt>get_deleter()(get())</tt> shall be well formed, shall have well-defined behavior,
and shall not throw exceptions.
<p/>
-4- <i>Effects:</i> assigns <tt>p</tt> to the stored pointer, and then if the old value of the stored pointer, <tt>old_p</tt>, was not
equal to <tt>nullptr</tt>, calls <tt>get_deleter()(old_p)</tt>. <ins>No operation shall be performed after the call to 
<tt>get_deleter()(old_p)</tt> that requires <tt>*this</tt> to be valid, because the deletion may destroy <tt>*this</tt> if it is 
referred to directly or indirectly by the stored pointer.</ins> <del>[<i>Note:</i> The order of these operations is significant
because the call to <tt>get_deleter()</tt> may destroy <tt>*this</tt>. &mdash; <i>end note</i>]</del>
<p/>
-5- <i>Postconditions:</i> <ins>If the call <tt>get_deleter()(old_p)</tt> destroyed <tt>*this</tt>, none. Otherwise,</ins> 
<tt>get() == p</tt>. <del>[<i>Note:</i> The postcondition does not hold if the call to <tt>get_deleter()</tt>
destroys <tt>*this</tt> since <tt>this->get()</tt> is no longer a valid expression. &mdash; <i>end note</i>]</del>
</p>
</blockquote></blockquote>
</li>
</ol>

</blockquote>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li>
<p>
Edit 23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins><tt>d(ptr)</tt> shall be valid even if it triggers the destruction of <tt>d</tt> or (if 
<tt>D</tt> is an lvalue reference to function object type) the function object that <tt>d</tt> refers to.</ins>
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-05, Lenexa]</i></p>

<p>
After some discussion in Lenexa there was some wavering on if the added sentence is necessary. Here is example code that 
demonstrates why the extra sentence is necessary. In this example the call to <tt>d(ptr)</tt> is valid, however the deleter 
references <tt>*this</tt> after destructing its element:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;

class Deleter
{
    int state_ = 0;

    enum
    {
        destructed            = -4,
        self_move_assigned    = -3,
        move_assigned_from    = -2,
        move_constructed_from = -1
    };
public:
    ~Deleter() {state_ = destructed;}

    Deleter() = default;
    Deleter(Deleter const&amp;) = default;
    Deleter&amp; operator=(Deleter const&amp;) = default;

    Deleter(Deleter&amp;&amp; a) noexcept
        : state_(a.state_)
    {a.state_ = move_constructed_from;}

    Deleter&amp; operator=(Deleter&amp;&amp; a) noexcept
    {
        if (this == &amp;a)
            state_ = self_move_assigned;
        else
        {
            state_ = a.state_;
            a.state_ = move_assigned_from;
        }
        return *this;
    }

    Deleter(int state)
        : state_(state)
    {
        assert(state &gt;= 0);
    }

    template &lt;class T&gt;
    void
    operator()(T* t) const
    {
        std::cout &lt;&lt; "Deleter beginning operator()(T*)\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; *this &lt;&lt; '\n';
        std::cout &lt;&lt; "Deleter about to destruct the X.\n";
        delete t;
        std::cout &lt;&lt; "Deleter has destructed the X.\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; *this &lt;&lt; '\n';
        std::cout &lt;&lt; "Deleter ending operator()(T*)\n";
    }

    friend
    std::ostream&amp;
    operator&lt;&lt;(std::ostream&amp; os, const Deleter&amp; a)
    {
        switch (a.state_)
        {
        case destructed:
            os &lt;&lt; "**destructed**";
            break;
        case self_move_assigned:
            os &lt;&lt; "self_move_assigned";
            break;
        case move_assigned_from:
            os &lt;&lt; "move_assigned_from";
            break;
        case move_constructed_from:
            os &lt;&lt; "move_constructed_from";
            break;
        default:
            os &lt;&lt; a.state_;
            break;
        }
        return os;
    }
};

struct X
{
    Deleter deleter_{1};
};

int main()
{
    auto xp = new X;
    {
        std::unique_ptr&lt;X, Deleter&amp;&gt; p(xp, xp-&gt;deleter_);
        std::cout &lt;&lt; "unique_ptr is constructed.\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; p.get_deleter() &lt;&lt; '\n';
        std::cout &lt;&lt; "Destructing unique_ptr...\n";
    }
    std::cout &lt;&lt; "unique_ptr is destructed.\n";
}
</pre></blockquote>
<p>
Which outputs:
</p>
<blockquote>
<pre>
unique_ptr is constructed.
The deleter = 1
Destructing unique_ptr...
Deleter beginning operator()(T*)
The deleter = 1
Deleter about to destruct the X.
Deleter has destructed the X.
The deleter = **destructed**
Deleter ending operator()(T*)
unique_ptr is destructed.
</pre>
</blockquote>
<p>
The line "<tt>The deleter = **destructed**</tt>" represents the deleter referencing itself after it has been destructed by the 
<tt>d(ptr)</tt> expression, but prior to that call returning.
<p/>
Suggested alternative to the current proposed wording:
</p>
<blockquote>
<p>
The expression <tt>d(ptr)</tt> shall not refer to the object <tt>d</tt> after it executes <tt>ptr-&gt;~T()</tt>.
</p>
</blockquote>

<p><i>[2015-07, Telecon]</i></p>

<p>
Geoffrey: Deleter may or may not execute ~T().<br/>
Alisdair: After the destructor after the element has run. Say it in words instead of code. <br/>
Howard will provide updated wording. Perhaps need both normative and non-normative wording.<br/>
</p>

<p><i>[2015-08-03, Howard updates P/R per telecon discussion.]</i></p>


<p><i>[2017-03-04, Kona]</i></p>

<p>This is related to <ref iref="2751"/>, which has been suggested NAD.</p>
<p>STL wants "Effects equivalent to" here - say it in code.  Marshall to research.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4431.</p>

<ol>
<li>
<p>
Edit 23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.9), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>The expression <tt>d(ptr)</tt>, if it destructs the object referred to by <tt>ptr</tt>,
shall not refer to the object <tt>d</tt> after it destructs <tt>*ptr</tt>.
[<i>Note:</i> The object being destructed may control the lifetime of <tt>d</tt>. &mdash; <i>end note</i>]</ins>
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2265" href="2265">2265.</a> 29.3p9 appears to rule out some acceptable executions</h3>
<p><b>Section:</b> 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Brian Demsky <b>Opened:</b> 2013-06-17 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe that the following variation on IRIW should admit executions in
which <tt>c1 = d1 = 5</tt> and <tt>c2 = d2 = 0</tt>.  If this is allowed, then what is sequence of
program evaluations for 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 that justifies the store to <tt>z</tt>?  It seems that
32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 should not allow this execution because one of the stores to <tt>x</tt> or <tt>y</tt> has
to appear earlier in the sequence, each of the <tt>fetch_adds</tt> reads the previous load in the thread (and thus must 
appear later in the sequence), and 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 states that each load must read from the last prior 
assignment in the sequence.
</p>

<blockquote><pre>
atomic_int x;
atomic_int y;
atomic_int z;
int c1, c2, d1, d2;

static void a(void* obj)
{
  atomic_store_explicit(&amp;x, 5, memory_order_relaxed); 
}

static void b(void* obj)
{
  atomic_store_explicit(&amp;y, 5, memory_order_relaxed); 
}

static void c(void* obj)
{
  c1 = atomic_load_explicit(&amp;x, memory_order_relaxed);
  // this could also be an atomic load if the address depends on c1:
  c2 = atomic_fetch_add_explicit(&amp;y, c1, memory_order_relaxed);  
}

static void d(void* obj)
{
  d1 = atomic_load_explicit(&amp;y, memory_order_relaxed);
  d2 = atomic_fetch_add_explicit(&amp;x, d1, memory_order_relaxed); 
}

int user_main(int argc, char** argv)
{
  thrd_t t1, t2, t3, t4;

  atomic_init(&amp;x, 0);
  atomic_init(&amp;y, 0);

  printf("Main thread: creating 4 threads\n");
  thrd_create(&amp;t1, (thrd_start_t)&amp;a, NULL);
  thrd_create(&amp;t2, (thrd_start_t)&amp;b, NULL);
  thrd_create(&amp;t3, (thrd_start_t)&amp;c, NULL);
  thrd_create(&amp;t4, (thrd_start_t)&amp;d, NULL);

  thrd_join(t1);
  thrd_join(t2);
  thrd_join(t3);
  thrd_join(t4);
  printf("c1=%d c2=%d\n",c1,c2);
  printf("d1=%d d2=%d\n",d1,d2);

  // Can this store write 1000 (i.e., c1=d1=5, c2=d2=0)?
  atomic_store(&amp;z, (c1+d1)*100+c2+d2);

  printf("Main thread is finished\n");

  return 0;
}
</pre></blockquote>

<p>
It seems that the easiest fix is to allow a load in 32.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 to read from any prior
store in the evaluation order.
<p/>
That said, I would personally advocate the following:
It seems to me that C/C++ atomics are in a bit of different situation than Java
because:
</p>
<ol>
<li><p>People are expected to use relaxed C++ atomics in potentially racy
situations, so it isn't clear that semantics as complicated as the JMM's
causality would be sane.
</p></li>
<li><p>People who use C/C++ atomics are likely to be experts and use them in a
very controlled fashion. I would be really surprised if compilers would find
any real wins by optimizing the use of atomics.
</p></li>
</ol>
<p>
Why not do something like:
<p/>
There is satisfaction DAG of all program evaluations. Each evaluation
observes the values of variables as computed by some prior assignment in
the DAG.
<p/>
There is an edge <tt>x-&gt;y</tt> between two evaluations <tt>x</tt> and <tt>y</tt> if:
</p>
<ol>
<li><p>the evaluation <tt>y</tt> observes a value computed by the evaluation <tt>x</tt> or
</p></li>
<li><p>the evaluation <tt>y</tt> is an atomic store, the evaluation <tt>x</tt> is an atomic load, and
there is a condition branch c that may depend (intrathread dependence) on <tt>x</tt>
and <tt>x-sb-&gt;c</tt> and <tt>c-sb-&gt;y</tt>.
</p></li>
</ol>
<p>
This seems to allow reordering of relaxed atomics that processors do without
extra fence instructions, allows most reorderings by the compiler, and gets
rid of satisfaction cycles.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>


<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
This was partially addressed (weasel-worded) in C++14 (See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3786.htm">N3786</a>).
The remainder is an open research problem.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3710.html">N3710</a> outlines a "solution" that doesn't have a consensus behind it because it costs performance.  We have no better solution at the moment.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2267" href="2267">2267.</a> <tt>partial_sort_copy</tt> underspecified for ranges of two different types</h3>
<p><b>Section:</b> 28.7.1.4 <a href="https://timsong-cpp.github.io/cppwp/partial.sort.copy">[partial.sort.copy]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern  <b>Opened:</b> 2013-06-26 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signature of this function is:
</p>

<blockquote><pre>
template&lt;class InputIterator, class RandomAccessIterator&gt;
RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
                  RandomAccessIterator result_first,
                  RandomAccessIterator result_last);

</pre></blockquote>

<p>
(and the usual overload for an explicitly provided comparison function). The standard says nothing about requirements 
in the case where the input type (<tt>iterator_traits&lt;InputIterator&gt;::value_type</tt>) and the output type 
(<tt>iterator_traits&lt;RandomAccessIterator&gt;::value_type</tt>) are different.
<p/>
Presumably the input type must be convertible to the output type. What's less clear is what the requirements are on 
the comparison operator. Does the algorithm only perform comparisons on two values of the output type, or does it also 
perform comparisons on values of the input type, or might it even perform heterogeneous comparisons?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2269" href="2269">2269.</a> Container iterators and argument-dependent lookup</h3>
<p><b>Section:</b> 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2013-06-26 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following code snippet:
</p>

<blockquote><pre>
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
  std::vector&lt;int&gt; v1(100, 3);
  std::vector&lt;int&gt; v2(100);
  copy(v1.begin(), v1.end(), v2.begin());
}
</pre></blockquote>

<p>
It compiles without error on my desktop. Is it required to? I can't find evidence from the standard that it is. 
In my test <tt>std::copy</tt> was found by argument-dependent lookup because the implementation I used made 
<tt>std::vector&lt;int&gt;::iterator</tt> a user-defined type defined in namespace <tt>std</tt>. But the standard 
only requires <tt>std::vector&lt;int&gt;::iterator</tt> to be an implementation specified random access iterator 
type. I can't find anything requiring it to be a user-defined type at all (and in fact there are reasonable implementation 
where it isn't), let alone a user defined type defined in a specific namespace.
</p>

<p>
Since the defining namespace of container iterators is visible to users, should the standard say anything about what 
that namespace is?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2286" href="2286">2286.</a> <tt>stringbuf::underflow()</tt> underspecified</h3>
<p><b>Section:</b> 30.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.virtuals">[stringbuf.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Sergey Zubkov <b>Opened:</b> 2013-08-29 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#stringbuf.virtuals">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/stringbuf.virtuals">[stringbuf.virtuals]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.virtuals">[stringbuf.virtuals]</a>/1, <tt>basic_stringbuf::underflow()</tt> is specified to unconditionally 
return <tt>traits::eof()</tt> when a read position is not available.
<p/>
The semantics of <tt>basic_stringbuf</tt> require, and existing libraries implement it so that this function makes 
a read position available if possible to do so, e.g. if some characters were inserted into the stream since the 
last call to <tt>overflow()</tt>, resulting in <tt>pptr() &gt; egptr()</tt>. Compare to the conceptually similar 
D.6.1.3 <a href="https://timsong-cpp.github.io/cppwp/depr.strstreambuf.virtuals">[depr.strstreambuf.virtuals]</a>/15.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>

<li><p>Change 30.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.virtuals">[stringbuf.virtuals]</a> as indicated:</p>

<blockquote>
<pre>
int_type underflow();
</pre><blockquote>
<p>
-1- <i>Returns:</i> If the input sequence has a read position available <ins>or the function makes a read position available 
(as described below)</ins>, returns <tt>traits::to_int_type(*gptr())</tt>. Otherwise, returns <tt>traits::eof()</tt>. Any 
character in the underlying buffer which has been initialized is considered to be part of the input sequence.
<p/>
<ins>-?- The function can make a read position available only if <tt>(mode &amp; ios_base::in) != 0</tt> and if the write 
next pointer <tt>pptr()</tt> is not null and is greater than the current read end pointer <tt>egptr()</tt>. To make a read 
position available, the function alters the read end pointer <tt>egptr()</tt> to equal <tt>pptr()</tt>.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2289" href="2289">2289.</a> <tt>constexpr</tt> guarantees of defaulted functions still insufficient</h3>
<p><b>Section:</b> 23.4.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a>, 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>, 23.17.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-09 <b>Last modified:</b> 2016-12-14 19:12:58 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">N3471</a> and
some similar <tt>constexpr</tt> papers, specific wording was added to <tt>pair</tt>, <tt>tuple</tt>, and other templates
that were intended to impose implementation constraints that ensure that the observable <tt>constexpr</tt> "character"
of a defaulted function template is solely determined by the required expressions of the user-provided types when instantiated,
for example:
</p>

<blockquote><p>
The defaulted move and copy constructor, respectively, of pair shall be a <tt>constexpr</tt> function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function.
</p></blockquote>

<p>
This wording doesn't require enough, especially since the core language via CWG 1358 does now support <tt>constexpr</tt>
function template instantiations, even if such function cannot appear in a constant expression (as specified in 8.20 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) 
or as a constant initializer of that object (as specified in  [basic.start.init]). The wording should be 
improved and should require valid uses in constant expressions and as constant initializers instead.
</p>

<p><i>[Lenexa 2015-05-05]</i></p>

<p>STL : notice order of move/copy and copy/move with "respectively".</p>
<p>General word-smithing; ask for updated wording</p>
<p>Are we happy with this with changes we are suggesting?</p>
<p>unanimous</p>

<p><i>[2016-12-14, Daniel comments]</i></p>

<p>
LWG <a href="2833">2833</a> overlaps considerably and both should be resolved together.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 23.4.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- <del>The defaulted move and copy constructor, respectively, of pair shall be a <tt>constexpr</tt> function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function</del><ins>An invocation of the move or copy constructor of <tt>pair</tt> shall be a constant expression 
(8.20 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) if all required element-wise initializations would be constant expressions. An invocation of the 
move or copy constructor of <tt>pair</tt> shall be a constant initializer for that <tt>pair</tt> object ( [basic.start.init])
if all required element-wise initializations would be constant initializers for the respective subobjects</ins>.
</p>
</blockquote>
</li>

<li><p>Change 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- <del>The defaulted move and copy constructor, respectively, of <tt>tuple</tt> shall be a <tt>constexpr</tt> function if 
and only if all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function. The defaulted move and copy constructor of <tt>tuple&lt;&gt;</tt> shall be <tt>constexpr</tt> 
functions</del><ins>An invocation of the move or copy constructor of <tt>tuple</tt> shall be a constant expression (8.20 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>)
if all required element-wise initializations would be constant expressions. An invocation of the move or copy constructor of 
<tt>tuple</tt> shall be a constant initializer for that <tt>tuple</tt> object ( [basic.start.init]) if all 
required element-wise initializations would be constant initializers for the respective subobjects. An invocation of the 
move or copy constructor of <tt>tuple&lt;&gt;</tt> shall be a constant expression, or a constant initializer for that 
<tt>tuple&lt;&gt;</tt> object, respectively, if the function argument would be constant expression</ins>.
</p>
</blockquote>
</li>

<li><p>Change 23.17.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a> p7 as indicated:</p>

<blockquote>
<p>
-7- <i>Remarks:</i> <del>The defaulted copy constructor of duration shall be a <tt>constexpr</tt> function if and only if
the required initialization of the member <tt>rep_</tt> for copy and move, respectively, would satisfy the
requirements for a <tt>constexpr</tt> function.</del><ins>An invocation of the copy constructor of <tt>duration</tt> shall 
be a constant expression (8.20 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) if the required initialization of the member <tt>rep_</tt> would be a constant expression.
An invocation of the copy constructor of <tt>duration</tt> shall be a constant initializer for that <tt>duration</tt> object 
( [basic.start.init]) if the required initialization of the member <tt>rep_</tt> would be constant initializers 
for this subobject</ins>.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2290" href="2290">2290.</a> Top-level "SFINAE"-based constraints should get a separate definition in Clause 17</h3>
<p><b>Section:</b> 23.15 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-02 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current library specification uses at several places wording that is intended to refer to
core language template deduction failure at the top-level of expressions (aka "SFINAE"), for example:
</p>

<blockquote><p>
The expression <tt>declval&lt;T&gt;() = declval&lt;U&gt;()</tt> is well-formed when treated as an unevaluated operand (Clause 5). 
Access checking is performed as if in a context unrelated to <tt>T</tt> and <tt>U</tt>. Only the validity of the immediate context 
of the assignment expression is considered. [<i>Note:</i> The compilation of the expression can result in side effects 
such as the instantiation of class template specializations and function template specializations, the generation of
implicitly-defined functions, and so on. Such side effects are not in the "immediate context" and can result in the program
being ill-formed. &mdash; <i>end note</i>]
</p></blockquote>

<p>
Similar wording can be found in the specification of <tt>result_of</tt>, <tt>is_constructible</tt>, and <tt>is_convertible</tt>,
being added to resolve an NB comment by LWG <a href="1390">1390</a> and <a href="1391">1391</a> through 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">N3142</a>.
<p/>
This wording is necessary to limit speculative compilations needed to implement these traits, but it is also lengthy and repetitive.
</p>

<p><i>[2014-05-19, Daniel suggests a descriptive term]</i></p>

<p>
<b>constrictedly well-formed expression</b>:
<p/>
An expression <em>e</em> depending on a set of types <tt>A1</tt>, ..., <tt>An</tt> which is well-formed when treated as 
an unevaluated operand (Clause 5). Access checking is performed as if in a context unrelated to <tt>A1</tt>, ..., 
<tt>An</tt>. Only the validity of the immediate context of <em>e</em> is considered. [<i>Note:</i> The compilation of 
the expression can result in side effects such as the instantiation of class template specializations and function 
template specializations, the generation of implicitly-defined functions, and so on. Such side effects are not in the 
"immediate context" and can result in the program being ill-formed. &mdash; <i>end note</i>]
</p>

<p><i>[2014-05-20, Richard and Jonathan suggest better terms]</i></p>

<p>
Richard suggested "locally well-formed"
<p/>
Jonathan suggested "contextually well-formed" and then "The expression ... is valid in a contrived argument
deduction context"
</p>

<p><i>[2014-06-07, Daniel comments and improves wording]</i></p>

<p>
The 2014-05-19 suggestion did only apply to expressions, but there are two important examples that are not expressions, but instead
are involving an <em>object definition</em> (<tt>std::is_constructible</tt>) and a <em>function definition</em> 
(<tt>std::is_convertible</tt>), respectively, instead. Therefore I suggest to rephrase the usage of "expression" into "program 
construct" in the definition of Jonathan's suggestion of "valid in a contrived argument deduction context".
<p/>
I would like to point out that given the new definition of "valid in a contrived argument deduction context", there are several other 
places of the Library specification that could take advantage of this wording to improve the existing specification, such as 
23.14.13.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> p2, most functions in 23.10.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.members">[allocator.traits.members]</a>, and the <tt>**Insertable</tt>, 
<tt>EmplaceConstructible</tt>, and <tt>Erasable</tt> definitions in 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, but given that
these are not fully described in terms of the aforementioned wording <em>yet</em>, I would recommend to fix them by a separate issue 
once the committee has agreed on following the suggestion presented by this issue.
</p>

<p><i>[2015-05-05 Lenexa: Move to Open]</i></p>

<p>...</p>
<p>MC: I think we like the direction but it isn't quite right: it needs some work</p>
<p>JW: I'm prepared to volunteer to move that further, hopefully with the help of Daniel</p>
<p>Roger Orr: should this be Core wording because it doesn't really have anything to do with libraries - the term could then just be used here</p>
<p>AM: Core has nothing to deal with that, though</p>
<p>HT: it seems there is nothing to imply that allows dropping out with an error - maybe that's a separate issue</p>
<p>MC: I'm not getting what you are getting at: could you write an issue? - any objection to move to Open?</p>
<p>...</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Add the following new definition to 20.3 <a href="https://timsong-cpp.github.io/cppwp/definitions">[definitions]</a> as indicated:</p>

<p>
<ins><b>valid in a contrived argument deduction context</b> [defns.valid.contr.context]</ins>
<p/>
<ins>A program construct <em>c</em> depending on a set of types <tt>A1</tt>, ..., <tt>An</tt>, and treated as 
an unevaluated operand (Clause 5) when <em>c</em> is an expression, which is well-formed. 
Access checking is performed as if in a context unrelated to <tt>A1</tt>, ..., <tt>An</tt>. 
Only the validity of the immediate context (17.8.2 <a href="https://timsong-cpp.github.io/cppwp/temp.deduct">[temp.deduct]</a>) of <em>c</em> is considered. 
[<i>Note:</i> The compilation of <em>c</em> can result in side effects such as the instantiation of class template 
specializations and function template specializations, the generation of implicitly-defined functions, and so on. 
Such side effects are not in the "immediate context" and can result in the program being ill-formed. &mdash; 
<i>end note</i>].</ins>
</p>
</li>

<li><p>Change Table 49 ("Type property predicates") as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 49 &mdash; Type property predicates</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T, class U&gt;<br/>
struct is_assignable;</tt>
</td>

<td>
The expression
<tt>declval&lt;T&gt;() =<br/>
declval&lt;U&gt;()</tt> is <ins>valid in a<br/>
contrived argument deduction context<br/>
([defns.valid.contr.context]) for types<br/>
<tt>T</tt> and <tt>U</tt>.</ins>
<del>well-formed when treated<br/>
as an unevaluated operand<br/>
(Clause 5). Access<br/>
checking is performed as if<br/>
in a context unrelated to <tt>T</tt><br/>
and <tt>U</tt>. Only the validity of<br/>
the immediate context of<br/>
the assignment expression<br/>
is considered. [<i>Note</i>: The<br/>
compilation of the<br/>
expression can result in<br/>
side effects such as the<br/>
instantiation of class<br/>
template specializations<br/>
and function template<br/>
specializations, the<br/>
generation of<br/>
implicitly-defined<br/>
functions, and so on. Such<br/>
side effects are not in the<br/>
"immediate context" and<br/>
can result in the program<br/>
being ill-formed. &mdash; end<br/>
note]</del>
</td>

<td align="center">
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> p7 as indicated:</p>

<blockquote><p>
-7- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre></blockquote>
<p>
the predicate condition for a template specialization <tt>is_constructible&lt;T, Args...&gt;</tt> shall be satisfied
if and only if the following variable definition <del>would be well-formed</del> for some invented 
variable <tt>t</tt> <ins>would be valid in a contrived argument deduction context ([defns.valid.contr.context]) for 
types <tt>T</tt> and <tt>Args...</tt></ins>:
</p>
<blockquote><pre>
T t(create&lt;Args&gt;()...);
</pre></blockquote>
<p>
[<i>Note</i>: These tokens are never interpreted as a function declaration. &mdash; <i>end note</i>] <del>Access checking is
performed as if in a context unrelated to <tt>T</tt> and any of the <tt>Args</tt>. Only the validity of the immediate context
of the variable initialization is considered. [<i>Note</i>: The evaluation of the initialization can result in side
effects such as the instantiation of class template specializations and function template specializations, the
generation of implicitly-defined functions, and so on. Such side effects are not in the "immediate context"
and can result in the program being ill-formed. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

<li><p>Change Table 57 ("Other transformations") as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 57 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class... ArgTypes&gt;<br/>
struct result_of&lt;Fn(ArgTypes...)&gt;;</tt>
</td>

<td align="center">
[&hellip;]
</td>

<td>
If the expression<br/>
<tt><i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...)</tt> is<br/>
<ins>valid in a contrived argument deduction<br/>
context ([defns.valid.contr.context]) for types<br/>
<tt>Fn</tt> and <tt>ArgTypes...</tt></ins>
<del>well<br/>
formed when treated as an<br/>
unevaluated operand (Clause 5)</del>, the<br/>
member typedef type shall name the<br/>
type<br/>
<tt>decltype(<i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...))</tt>;<br/>
otherwise, there shall be no member<br/>
type. <del>Access checking is performed as<br/>
if in a context unrelated to <tt>Fn</tt> and<br/>
<tt>ArgTypes</tt>. Only the validity of the<br/>
immediate context of the expression is<br/>
considered. [<i>Note</i>: The compilation of<br/>
the expression can result in side<br/>
effects such as the instantiation of<br/>
class template specializations and<br/>
function template specializations, the<br/>
generation of implicitly-defined<br/>
functions, and so on. Such side effects<br/>
are not in the "immediate context"<br/>
and can result in the program being<br/>
ill-formed. &mdash; <i>end note</i>]</del>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 23.15.6 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> p4 as indicated:</p>

<blockquote><p>
-4- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre></blockquote>
<p>
the predicate condition for a template specialization <tt>is_convertible&lt;From, To&gt;</tt> shall be satisfied if and
only if the return expression in the following code would be <del>well-formed</del><ins>valid in a contrived argument 
deduction context ([defns.valid.contr.context]) for types <tt>To</tt> and <tt>From</tt></ins>, including any implicit conversions
to the return type of the function:
</p>
<blockquote><pre>
To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>
<p>
[<i>Note</i>: This requirement gives well defined results for reference types, <tt>void</tt> types, array types, and
function types. &mdash; <i>end note</i>] <del>Access checking is performed as if in a context unrelated to <tt>To</tt> 
and <tt>From</tt>. Only the validity of the immediate context of the expression of the return-statement (including conversions to
the return type) is considered. [<i>Note</i>: The evaluation of the conversion can result in side effects such as
the instantiation of class template specializations and function template specializations, the generation of
implicitly-defined functions, and so on. Such side effects are not in the "immediate context" and can result
in the program being ill-formed. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2292" href="2292">2292.</a> Find a better phrasing for "shall not participate in overload resolution"</h3>
<p><b>Section:</b> 20.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2013-09-03 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++14 CD has 25 sections including the phrase "X shall not
participate in overload resolution ...". Most of these uses are double
negatives, which are hard to interpret. "shall not ... unless" tends
to be the easiest to read, since the condition is true when the
function is available, but we also have a lot of "if X is not Y, then
Z shall not participate", which actually means "You can call Z if X is
Y." The current wording is also clumsy and long-winded. We should find
a better and more concise phrasing.
<p/>
As an initial proposal, I'd suggest using "X is enabled if and only if Y" in prose
and adding an "<i>Enabled If:</i> ..." element to 20.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>.
<p/>
Daniel:
<p/>
I suggest to name this new specification element for 20.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>
as "<i>Template Constraints:</i>" instead, because the mentioned wording form was intentionally provided 
starting with LWG <a href="1237">1237</a> to give implementations more freedom to realize the 
concrete constraints. Instead of the original <tt>std::enable_if</tt>-based specifications
we can use better forms of "SFINAE" constraints today and it eases the path to possible language-based
constraints in the future.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2295" href="2295">2295.</a> Locale name when the provided <tt>Facet</tt> is a <tt>nullptr</tt></h3>
<p><b>Section:</b> 25.3.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.cons">[locale.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2013-09-04 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.3.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.cons">[locale.cons]</a> p14 ends with:
</p>
<blockquote><p>
"[&hellip;] If <tt>f</tt> is null, the resulting object is a copy of <tt>other</tt>."
</p></blockquote>
<p>
but the next line p15 says: 
</p>
<blockquote><p>
"<i>Remarks:</i> The resulting locale has no name."
</p></blockquote>
<p>
But both can't be true when <tt>other</tt> has a name and <tt>f</tt> is null.
<p/>
I've tried it on two implementations (MSVC,GCC) and they are inconsistent with each other on this.
</p>
<p>
Daniel Kr&uuml;gler:
<p/>
As currently written, the <i>Remarks</i> element applies unconditionally for all cases and thus should
"win". The question arises whether the introduction of this element by LWG <a href="424">424</a> had actually intended
to change the previous <i>Note</i> to a <i>Remarks</i> element. In either case the wording should be improved
to clarify this special case.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2303" href="2303">2303.</a> Explicit instantiation of <tt>std::vector&lt;UserType&gt;</tt> broken?</h3>
<p><b>Section:</b> 21.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/new.delete.placement">[new.delete.placement]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-18 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.placement">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/new.delete.placement">[new.delete.placement]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library gives explicit permission in 20.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> p2 that user code may explicitly instantiate
a library template provided that the instantiations depend on at least one user-defined type:
</p>

<blockquote><p>
A program may explicitly instantiate a template defined in the standard library only if the declaration
depends on the name of a user-defined type and the instantiation meets the standard library requirements
for the original template.
</p></blockquote>

<p>
But it seems that the C++11 library is not specified in a way that guarantees such an instantiation to be well-formed
if the minimum requirements of the library is not satisfied. 
<p/>
For example, in general, the first template parameter of <tt>std::vector</tt> is not required to be 
<tt>DefaultConstructible</tt> in general, but due to the split of the single C++03 member function
with default argument
</p>
<blockquote><pre>
void resize(size_type sz, T c = T());
</pre></blockquote>
<p>
into
</p>
<blockquote><pre>
void resize(size_type sz);
void resize(size_type sz, const T&amp; c);
</pre></blockquote>
<p>
the effect is now that for a type <tt>ND</tt> that is not <tt>DefaultConstructible</tt>, such as
</p>
<blockquote><pre>
struct NP { 
  NP(int); 
};
</pre></blockquote>
<p>
the explicit instantiation of <tt>std::vector&lt;ND&gt;</tt> is no longer well-formed, because the attempt to
instantiate the single-argument overload of <tt>resize</tt> cannot not succeed, because this function imposes
the <tt>DefaultInsertable</tt> requirements and given the default allocator this effectively requires
<tt>DefaultConstructible</tt>.
</p>
<p>
But <tt>DefaultConstructible</tt> is not the only point, what about <tt>CopyConstructible</tt> versus
<tt>MoveConstructible</tt> alone? It turns out that currently the second <tt>resize</tt> overload
would fail during an explicit instantiation for a type like
</p>
<blockquote><pre>
struct MO { 
  MO() = default; 
  MO(MO&amp;&amp;) = default; 
};
</pre></blockquote>
<p>
because it imposes <tt>CopyInsertable</tt> requirements that end up being equivalent to the <tt>CopyConstructible</tt>
requirements for the default allocator.
<p/>
Technically a library can solve these issues: For special member functions by defining them in some base class, for others
by transforming them effectively into a function template due to the great feature of default template arguments for
function templates (At the very moment the validity of the latter approach depends on a resolution of core language issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1635">CWG 1635</a>, though). E.g. the here mentioned 
<tt>resize</tt> functions of <tt>std::vector</tt> could be prevented from instantiation by defining them like this 
with an implementation:
</p>
<blockquote><pre>
template&lt;class = void&gt;
void resize(size_type sz) { [&hellip;] }
template&lt;class = void&gt;
void resize(size_type sz, const T&amp; c) { [&hellip;] }
</pre></blockquote>
<p>
In this case, these functions could also be defined in a base class, but the latter approach won't work in all cases.
<p/>
Basically such an implementation is required to constrain all member functions that are not covered by the general
requirements imposed on the actual library template parameters. I tested three different C++11 library implementations
and but none could instantiate for example <tt>std::list</tt>, <tt>std::vector</tt>, or <tt>std::deque</tt> with
value types that are not <tt>DefaultConstructible</tt> or only <tt>MoveConstructible</tt>. 
<p/>

<p/>
This issue is raised to clarify the current situation in regard to the actual requirements imposed on user-provided
types that are used to explicitly instantiate Library-provided templates. For example, the current Container requirements
impose very little requirements on the actual value type and it is unclear to which extend library implementations have
to respect that. 
<p/>
The minimum solution of this issue should be to at least realize that there is no fundamental requirement on 
<tt>DefaultConstructible</tt> for value types of library containers, because we have since C++03 the general
statement of 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> ("In general, a default constructor is not required.").
It is unclear whether <tt>CopyConstructible</tt> should be required for an explicit instantiation request, but
given the careful introduction of move operations in the library it would seem astonishing that a
<tt>MoveConstructible</tt> type wouldn't suffice for value types of the container types.
<p/>
In any case I can envision at least two approaches to solve this issue:
</p>
<ol>
<li>
<p>
As indicated in LWG <a href="2292">2292</a>, those function could get an explicit "<i>Template Constraints:</i>"
element, albeit this promises more than needed to solve this issue.
</p>
</li>
<li>
<p>
The library could introduce a completely new element form, such as "<i>Instantiation Constraints:</i>" that
would handle this situation for explicit instantiation situations. This would allow for simpler techniques
to solve the issue when explicit instantiation is required compared to the first bullet, because it would not 
(necessarily) guarantee SFINAE-friendly expression-wellformedness, such as inspecting the expression 
<tt>std::declval&lt;std::vector&lt;ND&gt;&amp;&gt;.resize(0)</tt> in an unevaluated context.
</p>
</li>
</ol>

<p>
It should be noted that the 2013-08-27 comment to LWG <a href="2193">2193</a> could be resolved by a similar solution
as indicated in this issue here.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2307" href="2307">2307.</a> Should the Standard Library use <tt>explicit</tt> only when necessary?</h3>
<p><b>Section:</b> 26 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-09-26 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2193">2193</a> yields <tt>explicit</tt> for default ctors to allow <tt>{}</tt>, but not for
all cases of uniform initialization. For example:
</p>
<blockquote><pre>
explicit vector(size_type count, const Allocator&amp; alloc = Allocator());
</pre></blockquote>
<p>
This prevents <tt>{n, alloc()}</tt>. Although this use is relatively rare,
but the behavior is inconsistent with that of
</p>
<blockquote><pre>
vector(size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator());
</pre></blockquote>

<p><i>[Urbana 2014-11-07: Move to Open]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2318" href="2318">2318.</a> <tt>basic_string</tt>'s wording has confusing relics from the copy-on-write era</h3>
<p><b>Section:</b> 24.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-11-12 20:11:11 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a>/8 specifies <tt>basic_string::resize(n, c)</tt> with:
</p>
<blockquote><p>
<i>Effects:</i> Alters the length of the string designated by <tt>*this</tt> as follows:
</p>
<ul>
<li><p>
If <tt>n &lt;= size()</tt>, the function replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose 
elements are a copy of the initial elements of the original string designated by <tt>*this</tt>.
</p>
</li>
<li><p>
If <tt>n &gt; size()</tt>, the function replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose 
first <tt>size()</tt> elements are a copy of the original string designated by <tt>*this</tt>, and whose remaining elements are all 
initialized to <tt>c</tt>.
</p>
</li>
</ul>
</blockquote>
<p>
This wording is a relic of the copy-on-write era. In addition to being extremely confusing, it has undesirable implications.  
Saying "replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose elements are a copy" suggests 
that the trimming case can reallocate. Reallocation during trimming should be forbidden, like <tt>vector</tt>.
<p/>
At least 7 paragraphs are affected: 24.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a>/8, 24.3.2.6.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a>/9, 
24.3.2.6.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a>/3 and /10, 24.3.2.6.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a>/11, 24.3.2.6.5 <a href="https://timsong-cpp.github.io/cppwp/string.erase">[string.erase]</a>/4, and 
24.3.2.6.6 <a href="https://timsong-cpp.github.io/cppwp/string.replace">[string.replace]</a>/11 say "replaces the string [designated/controlled] by <tt>*this</tt>". (24.3.2.6.7 <a href="https://timsong-cpp.github.io/cppwp/string.copy">[string.copy]</a>/3 
is different &mdash; it "replaces the string designated by <tt>s</tt>".)
<p/>
Of the affected paragraphs, <tt>resize()</tt> and <tt>erase()</tt> are the most important to fix because they should forbid 
reallocation during trimming.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2321" href="2321">2321.</a> Moving containers should (usually) be required to preserve iterators</h3>
<p><b>Section:</b> 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/10 says that unless otherwise specified, "no <tt>swap()</tt> function invalidates 
any references, pointers, or iterators referring to the elements of the containers being swapped. [<i>Note:</i> The <tt>end()</tt> 
iterator does not refer to any element, so it may be invalidated. &mdash; <i>end note</i>]". However, move constructors and move 
assignment operators aren't given similar invalidation guarantees. The guarantees need several exceptions, so I do not believe 
that blanket language like /11 "Unless otherwise specified (either explicitly or by defining a function in terms of other functions), 
invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, 
or change the values of, objects within that container." is applicable.
</p>

<p><i>[2014-02-13 Issaquah]</i></p>

<p>
General agreeement on intent, several wording nits and additional paragraphs to hit.
</p>
<p>
STL to provide updated wording.  Move to Open.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: in the proposed wording, I'd like to mention that the iterators now refer to elements of a different container. 
I think we're saying something like this somewhere. JY: There's some wording like that for swap I think. TK: It's also in 
<tt>list::splice()</tt>. DK to JY: 23.2.1p9.
<p/>
VV: The issue says that STL was going to propose new wording. Has he done that? AM: I believe we're looking at that. 
GR: The request touches on multiple paragraphs, and this PR has only one new paragraph, so this looks like it's not up-to-date. 
MC: This was last updated a year ago in Issaquah.
<p/>
<b>Conclusion</b>: Skip, not up to date. 
</p>

<p><i>[2015-06, Telecon]</i></p>

<p>Still waiting for updated wording</p>

<p><i>[2015-08 Chicago]</i></p>

<p>Still waiting for updated wording</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/10 change as indicated:</p>

<blockquote><p>
-10- Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.3.4, and 23.3.7.5) all container types defined in this
Clause meet the following additional requirements:
</p>
<ul>
<li><p>
[&hellip;]
</p></li>
<li><p>
no copy constructor or assignment operator of a returned iterator throws an exception.
</p></li>
<li><p>
<ins>no move constructor (or move assignment operator when 
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt> is true) of a container 
(except for <tt>array</tt>) invalidates any references, pointers, or iterators referring to the elements of the source container. 
[<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element, so it may be invalidated. &mdash; <i>end note</i>]</ins>
</p></li>
<li><p>
no <tt>swap()</tt> function throws an exception.
</p></li>
<li><p>
no <tt>swap()</tt> function invalidates any references, pointers, or iterators referring to the elements of the
containers being swapped. [<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element, so it may be
invalidated. &mdash; <i>end note</i>]
</p></li>
</ul>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2331" href="2331">2331.</a> <tt>regex_constants::collate</tt>'s effects are inaccurately summarized</h3>
<p><b>Section:</b> 31.5.1 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.synopt">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The table in 31.5.1 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a>/1 says that <tt>regex_constants::collate</tt> "Specifies that character ranges of the form 
"<tt>[a-b]</tt>" shall be locale sensitive.", but 31.13 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a>/14 says that it affects individual character comparisons 
too.
</p>

<p><i>[2012-02-12 Issaquah : recategorize as P3]</i></p>


<p>
Marshall Clow: 28.13/14 only applies to ECMAScript
</p>

<p>
All: we're unsure
</p>

<p>
Jonathan Wakely: we should ask John Maddock
</p>

<p>
Move to P3
</p>

<p><i>[2014-5-14, John Maddock response]</i></p>

<p>
The original intention was the original wording: namely that <tt>collate</tt> only made character ranges locale sensitive.  
To be frank it's a feature that's probably hardly ever used (though I have no real hard data on that), and is a leftover 
from early POSIX standards which <em>required</em> locale sensitive collation for character ranges, and then later changed 
to implementation defined if I remember correctly (basically nobody implemented locale-dependent collation).
<p/>
So I guess the question is do we gain anything by requiring all character-comparisons to go through the locale when this bit 
is set? Certainly it adds a great deal to the implementation effort (it's not what Boost.Regex has ever done). I guess the 
question is are differing code-points that collate identically an important use case? I guess there might be a few Unicode 
code points that do that, but I don't know how to go about verifying that.
<p/>
STL:
<p/>
If this was unintentional, then 31.5.1 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a>/1's table should be left alone, while 31.13 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a>/14 
should be changed instead.
<p/>
Jeffrey Yasskin:
<p/>
<a href="http://www.unicode.org/reports/tr18/tr18-13.html#Tailored_Loose_Matches">This page</a>
mentions that [V] in Swedish should match "W" in a perfect world.
<p/>
However, the most recent version of <a href="http://www.unicode.org/reports/tr18/#Tailored_Loose_Matches">TR18</a> retracts
both language-specific loose matches <em>and</em> language-specific ranges
because "for most full-featured regular expression engines, it is
quite difficult to match under code point equivalences that are not
1:1" and "tailored ranges can be quite difficult to implement
properly, and can have very unexpected results in practice. For
example, languages may also vary whether they consider lowercase below
uppercase or the reverse. This can have some surprising results: [a-Z]
may not match anything if <tt>Z &lt; a</tt> in that locale."
<p/>
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.15">ECMAScript</a> doesn't include collation at all.
<p/>
IMO, +1 to changing 28.13 instead of 28.5.1. It seems like we'd be on
fairly solid ground if we wanted to remove <tt>regex_constants::collate</tt>
entirely, in favor of named character classes, but of course that's
not for this issue.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 31.5.1 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a>/1, Table 138 &mdash; "<tt>syntax_option_type</tt> effects", change as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 138 &mdash; <tt>syntax_option_type</tt> effects</caption>
<tr>
<th align="center">Element</th>
<th align="center">Effect(s) if set</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>collate</tt>
</td>
<td>
Specifies that character <del>ranges of the form "<tt>[a-b]</tt>"</del><ins>comparisons and character range comparisons</ins> 
shall be locale sensitive.
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2334" href="2334">2334.</a> <tt>atomic</tt>'s default constructor requires "uninitialized" state even for types with non-trivial default-constructor</h3>
<p><b>Section:</b> 99 [atomics.types.operations.req] <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-10-03 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations.req">issues</a> in [atomics.types.operations.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 99 [atomics.types.operations.req] p4,
</p>
<blockquote><pre>
A ::A () noexcept = default;
</pre><blockquote>
<p>
<i>Effects:</i> leaves the atomic object in an uninitialized state. [<i>Note:</i> These semantics ensure compatibility
with <tt>C</tt>. &mdash; <i>end note</i>]
</p>
</blockquote></blockquote>
<p>
This implementation requirement is OK for POD types, like <tt>int</tt>, but 32.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a> p1
intentionally allows template arguments of <tt>atomic</tt> with a non-trivial default constructor ("The type of the template argument 
<tt>T</tt> shall be trivially copyable (3.9)"), so this wording can be read in a way that makes the behaviour of the following code
undefined:
</p>
<blockquote><pre>
#include &lt;atomic&gt;
#include &lt;iostream&gt;

struct S {
  S() noexcept : v(42) {}
  int v;
};

int main() {
  std::atomic&lt;S&gt; as; // Default-initialization
  std::cout &lt;&lt; as.load().v &lt;&lt; std::endl; // ?
}
</pre></blockquote>
<p>
For a user-defined emulation of <tt>atomic</tt> the expected outcome would be defined and the program would output "42",
but existing implementations differ and the result value is a "random number" for at least one implementation. This seems
very surprising to me.
<p/>
To realize that seemingly existing requirement, an implementation is either required to violate normal language rules internally
or to perform specific bit-randomization-techniques after the normal default-initialization that called the default constructor
of <tt>S</tt>.
<p/>
According to my understanding, the non-normative note in 99 [atomics.types.operations.req] p4 is intended to
refer to types that are valid <tt>C</tt>-types, but the example type <tt>S</tt> is not such a type.
<p/>
To make the mental model of <tt>atomic</tt>'s default constructor more intuitive for user-code, I suggest to clarify the wording
to have the effects of default-initialization instead. The current state seems more like an unintended effect of imprecise
language used here and has some similarities to wording that was incorrectly used to specify <tt>atomic_flag</tt> initialization 
as described by LWG <a href="2159">2159</a>.
</p>

<p><i>[2014-05-17, Daniel comments and provides alternative wording]</i></p>


<p>
The current wording was considered controversial as expressed by reflector discussions. To me, the actual problem is not newly
introduced by that wording, but instead is already present in basically all paragraphs specifying semantics of atomic types,
since the wording never clearly distinguishes the value of the actual atomic type <i>A</i> and the value of the "underlying",
corresponding non-atomic type <i>C</i>. The revised proposed wording attempts to improve the current ambiguity of these two
kinds of values.
</p>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<p/>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 99 [atomics.types.operations.req] p4 as indicated: <em>[Editorial note: There is no exposition-only
member in <tt>atomic</tt>, which makes it a bit hard to specify what actually is initialized, but the usage of the term "value" 
seems consistent with similar wording used to specify the effects of the atomic <tt>load</tt> functions]</em></p>

<blockquote><pre>
A ::A () noexcept = default;
</pre><blockquote>
<p>
-4- <i>Effects:</i> <del>leaves the atomic object in an uninitialized state</del><ins>The value of the atomic object
is default-initialized (11.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>)</ins>. [<i>Note:</i> These semantics ensure compatibility
with <tt>C</tt>. &mdash; <i>end note</i>]
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Modify 99 [atomics.types.operations.req] p2 as indicated: <em>[Editorial note: This is a near-to editorial
change not directly affecting this issue, but <tt>atomic_address</tt> does no longer exist and the pointed to definition is
relevant in the context of this issue resolution.]</em>
</p>
<blockquote>
<p>
-2- In the following operation definitions:
</p>
<ul>
<li><p>an <i>A</i> refers to one of the atomic types.</p></li>
<li><p>a <i>C</i> refers to its corresponding non-atomic type. <del>The <tt>atomic_address</tt> atomic type corresponds to the
<tt>void*</tt> non-atomic type.</del></p></li>
<li><p>[&hellip;]</p></li>
</ul>
</blockquote>
</li>

<li><p>Modify 99 [atomics.types.operations.req] p4 and the following as indicated: <em>[Editorial note: There 
is no exposition-only member in <tt>atomic</tt>, which makes it a bit hard to specify what actually is initialized, but 
the introductory wording of 99 [atomics.types.operations.req] p2 b2 defines: "a <i>C</i> refers to its 
corresponding non-atomic type." which helps to specify the semantics in terms of "the <i>C</i> value referred to by the 
atomic object"]</em></p>

<blockquote>
<pre>
<i>A</i>::<i>A</i>() noexcept = default;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> <del>leaves the atomic object in an uninitialized state</del><ins>Default-initializes (11.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>) 
the <i>C</i> value referred to by the atomic object</ins>. [<i>Note:</i> These semantics ensure compatibility with <tt>C</tt>. 
&mdash; <i>end note</i>]
</p>
</blockquote>

<pre>
constexpr <i>A</i>::<i>A</i>(<i>C</i> desired) noexcept;
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> <ins>Direct-i</ins><del>I</del>nitializes the <ins><i>C</i> value referred to by the atomic</ins> object 
with the value <tt>desired</tt>. Initialization is not an atomic operation (1.10). [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
void atomic_init(volatile <i>A</i>* object, <i>C</i> desired) noexcept;
void atomic_init(<i>A</i>* object, <i>C</i> desired) noexcept;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Non-atomically initializes <ins>the <i>C</i> value referred to by</ins> <tt>*object</tt> with value 
<tt>desired</tt>. [&hellip;]
</p>
</blockquote>

<pre>
void atomic_store(volatile <i>A</i>* object, <i>C</i> desired) noexcept;
[&hellip;]
void <i>A</i>::store(<i>C</i> desired, memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-9- [&hellip;]
<p/>
-10- <i>Effects:</i> Atomically replaces the <ins><i>C</i></ins> value pointed to by 
<tt>object</tt> or by <tt>this</tt> with the value of <tt>desired</tt>. [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
<i>C</i> atomic_load(const volatile <i>A</i>* object) noexcept;
[&hellip;]
<i>C</i> <i>A</i>::load(memory_order order = memory_order_seq_cst) const noexcept;
</pre>
<blockquote>
<p>
-13- [&hellip;]
<p/>
-14- [&hellip;]
<p/>
-15- <i>Returns:</i> Atomically returns the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
<i>C</i> atomic_exchange(volatile <i>A</i>* object, C desired) noexcept;
[&hellip;]
<i>C</i> <i>A</i>::exchange(C desired, memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-18- <i>Effects</i>: Atomically replaces the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt> with <tt>desired</tt>. [&hellip;]
<p/>
-19- <i>Returns:</i> Atomically returns the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt> 
immediately before the effects.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
<i>C</i> atomic_fetch_key(volatile <i>A</i>* object, <i>M</i> operand) noexcept;
[&hellip;]
<i>C</i> <i>A</i>::fetch_key(<i>M</i> operand, memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-28- <i>Effects</i>: Atomically replaces the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt> with 
the result of the computation applied to the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt> and 
the given <tt>operand</tt>. [&hellip;]
<p/>
-29- <i>Returns:</i> Atomically<del>,</del> <ins>returns</ins> the <ins><i>C</i></ins> value pointed to by <tt>object</tt>
or by <tt>this</tt> immediately before the effects.
<p/>
[&hellip;]
</p>
</blockquote>

</blockquote>
</li>

<li><p>Modify 32.8 <a href="https://timsong-cpp.github.io/cppwp/atomics.flag">[atomics.flag]</a> p5 and the following as indicated:</p>

<blockquote>
<pre>
bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
[&hellip;]
bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-5- <i>Effects</i>: Atomically sets the <ins>bool</ins> value pointed to by <tt>object</tt> or by <tt>this</tt> to <tt>true</tt>. 
[&hellip;]
<p/>
-6- <i>Returns</i>: Atomically<del>,</del> <ins>returns</ins> the <ins>bool</ins> value <del>of the</del><ins>pointed 
to by</ins> <tt>object</tt> <ins>or by <tt>this</tt></ins> immediately before the effects.
</p>
</blockquote>

<pre>
void atomic_flag_clear(volatile atomic_flag* object) noexcept;
[&hellip;]
void atomic_flag::clear(memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-7- [&hellip;]
<p/>
-8- <i>Effects</i>: Atomically sets the <ins>bool</ins> value pointed to by <tt>object</tt> or by <tt>this</tt> to <tt>false</tt>. 
[&hellip;]
</p>
</blockquote>

</blockquote>

</li>
</ol>





<hr>
<h3><a name="2335" href="2335">2335.</a> <tt>array&lt;array&lt;int, 3&gt;, 4&gt;</tt> should be layout-compatible with <tt>int[4][3]</tt></h3>
<p><b>Section:</b> 26.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2013-10-04 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to replace some uses of C arrays with <tt>std::array</tt>, we need it
to be possible to cast from a <tt>std::array&lt;&gt;</tt> to an equivalent C array.
Core wording doesn't appear to be in quite the right state to allow
casting, but if we specify that appropriate types are
layout-compatible, we can at least write:
</p>
<blockquote><pre>
union {
  array&lt;array&lt;array&lt;int, 2&gt;, 3&gt;, 4&gt; arr;
  int carr[4][3][2];
};
</pre></blockquote>
<p>
to view memory as the other type: C++14 CD [class.mem]p18.
</p>
I believe it's sufficient to add "<tt>array&lt;T, N&gt;</tt> shall be
layout-compatible (6.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>) with <tt>T[N]</tt>." to 
26.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>, but we might also need some extension to 
12.2 <a href="https://timsong-cpp.github.io/cppwp/class.mem">[class.mem]</a> to address the possibility of layout-compatibility 
between struct and array types.
<p>
I checked that libc++ on MacOS already implements this, although it
would be good for someone else to double-check; I haven't checked any
other standard libraries.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2337" href="2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a>/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a>/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 23.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2338" href="2338">2338.</a> &sect;[re.traits]/7 expects of locale facets something not guaranteed by [locale.facet]/4</h3>
<p><b>Section:</b> 31.7 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>, 25.3.1.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.facet">[locale.facet]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sergey Zubkov <b>Opened:</b> 2013-10-15 <b>Last modified:</b> 2016-02-01 11:02:56 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.traits">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
31.7 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>/7, begins with "if <tt>typeid(use_facet&lt;collate&lt;charT&gt; &gt;) == typeid(collate_byname&lt;charT&gt;)</tt>", 
which appears to be pseudocode with the intention to convey that the collate facet has not been replaced by the user. Cf. the wording in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">N1429</a> "there is no portable way to implement 
<tt>transform_primary</tt> in terms of <tt>std::locale</tt>, since even if the sort key format returned by 
<tt>std::collate_byname&lt;&gt;::transform</tt> is known and can be converted into a primary sort key, the user can still 
install their own custom <tt>std::collate</tt> implementation into the locale object used, and that can use any sort key 
format they see fit.".
<p/>
Taken literally, 31.7 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>/7 appears to imply that named locales are required to hold their collate facets with 
dynamic type <tt>std::collate_byname&lt;charT&gt;</tt>, which is in fact true in some implementations (e.g libc++), but not others 
(e.g. libstdc++). This does not follow from the description of <tt>_byname</tt> in 25.3.1.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.facet">[locale.facet]</a>/4, which is only 
required to provide equivalent semantics, to the named locale's facet, not to actually be one.
</p>


<p><i>[2015-05-06 Lenexa: Move to Open]</i></p>


<p>MC, RP: Consequence of failing to follow the rule is UB.</p>
<p>MC: Tightening of requirements.</p>
<p>RP: It should be this way, we just didn't impose it before.</p>
<p>MC: Second change is a bug fix, original code didn't work.</p>
<p>TK: Doesn't seem to make things worse.</p>
<p>Bring up in larger group tomorrow.</p>
<p>JW arrives.</p>
<p>JW: libstdc++ violates this due to two std::string ABIs.</p>
<p>JW: This prevents installing a type derived from Facet_byname, constrains the implementor from using a smarter derived class version.</p>
<p>JW: Can't look at facet id to detect replacement, because replacements have the same id.</p>
<p>RP: Can you give it multiple ids through multiple inheritance?</p>
<p>JW: No, the facet mechanism wouldn't like that.</p>
<p>JW: We should also ask Martin Sebor, he's implemented this stuff recently.</p>
<p>MC: Sounds like this resolution doesn't work, need a better solution.</p>
<p>JW: Write in words "if the facet has not been replaced by the user", the implementation knows how to detect that, but not like this.</p>
<p>RP: User RE traits need to detect this too.</p>
<p>JW: =(</p>
<p>Move to Open, JW will invite Martin Sebor to join LWG for discussion.</p>
<p>Later ... </p>
<p>JW: This is not needed for user specializations after all.</p>
<p>MC: Agree, [re.traits]/7 only applies to the stdlib traits.</p>
<p>NM: Effects: doesn't make sense.</p>
<p>JW, NM, Martin Sebor to come up with new wording.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 25.3.1.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.facet">[locale.facet]</a>/4 as indicated:</p>

<blockquote><p>
For some standard facets a standard "...<tt>_byname</tt>" class, derived from it, implements the virtual function
semantics <del>equivalent to</del><ins>provided by</ins> that facet of the locale constructed by <tt>locale(const char*)</tt> 
with the same name.
Each such facet provides a constructor that takes a <tt>const char*</tt> argument, which names the locale, and a
<tt>refs</tt> argument, which is passed to the base class constructor. Each such facet also provides a constructor
that takes a string argument <tt>str</tt> and a <tt>refs</tt> argument, which has the same effect as calling the first
constructor with the two arguments <tt>str.c_str()</tt> and <tt>refs</tt>. If there is no "...<tt>_byname</tt>" 
version of a facet, the base class implements named locale semantics itself by reference to other facets. <ins>For any 
locale <tt>loc</tt> constructed by <tt>locale(const char*)</tt> and facet <tt>Facet</tt> that has a corresponding standard 
<tt>Facet_byname</tt> class, <tt>typeid(use_facet&lt;Facet&gt;(loc)) == typeid(Facet_byname)</tt>.</ins>
</p></blockquote>
</li>

<li><p>Modify 31.7 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>/7 as indicated:</p>

<blockquote><pre>
template &lt;class ForwardIterator&gt;
  string_type transform_primary(ForwardIterator first, ForwardIterator last) const;
</pre><blockquote>
<p>
-7- <i>Effects:</i> if <tt>typeid(use_facet&lt;collate&lt;charT&gt; &gt;<ins>(getloc())</ins>) == typeid(collate_byname&lt;charT&gt;)</tt> 
and the form of the sort key returned by <tt>collate_byname&lt;charT&gt;::transform(first, last)</tt> is known and
can be converted into a primary sort key then returns that key, otherwise returns an empty string.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2342" href="2342">2342.</a> User conversion to <tt>wchar_t const*</tt> or to <tt>wchar_t</tt> not invoked for <tt>operator&lt;&lt;</tt></h3>
<p><b>Section:</b> 30.7.5.1 <a href="https://timsong-cpp.github.io/cppwp/ostream">[ostream]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alf P. Steinbach <b>Opened:</b> 2013-10-29 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ostream">[ostream]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For wide streams argument types <tt>wchar_t const*</tt> and <tt>wchar_t</tt> are supported only as template parameters. 
User defined conversions are not considered for template parameter matching. Hence inappropriate overloads of 
<tt>operator&lt;&lt;</tt> are selected when an implicit conversion is required for the argument, which is inconsistent 
with the behavior for <tt>char const*</tt> and <tt>char</tt>, is unexpected, and is a useless result.
<p/>
Demonstration:
</p>
<blockquote><pre>
#include &lt;iostream&gt;

struct Byte_string
{ 
  operator char const*() const { return "Hurray, it works!"; } 
};

struct Wide_string
{ 
  operator wchar_t const*() const { return L"Hurray, it works!"; } 
};

struct Byte_ch
{ 
  operator char() const { return 'X'; } 
};

struct Wide_ch
{ 
  operator wchar_t() const { return L'X'; } 
};

auto main() -> int
{
  using namespace std;
  wcout &lt;&lt; "'X' as char value   : " &lt;&lt; Byte_ch() &lt;&lt; endl;
  wcout &lt;&lt; "'X' as wchar_t value: " &lt;&lt; Wide_ch() &lt;&lt; endl;
  wcout &lt;&lt; "Byte string pointer : " &lt;&lt; Byte_string() &lt;&lt; endl;
  wcout &lt;&lt; "Wide string pointer : " &lt;&lt; Wide_string() &lt;&lt; endl;
}
</pre></blockquote>
<p>
Example output:
</p>
<blockquote><pre>
'X' as char value   : X
'X' as wchar_t value: 88
Byte string pointer : Hurray, it works!
Wide string pointer : 000803C8
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Modify 30.7.5.1 <a href="https://timsong-cpp.github.io/cppwp/ostream">[ostream]</a>, class template <tt>basic_ostream</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
[&hellip;]

<i>// 27.7.3.6.4 character inserters</i>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          charT);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          char);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;,
                                         char);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp;,
                                            wchar_t);</ins>
[&hellip;]

template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          const charT*);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          const char*);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;,
                                         const char*);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp;,
                                            const wchar_t*);</ins>
[&hellip;]
}

</pre></blockquote>
</li>

<li><p>Modify 30.7.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.character">[ostream.inserters.character]</a> as indicated: <em>[Drafting note: 
The replacement of <tt>os</tt> by <tt>out</tt> in p1 and the insertion of "<tt>out.</tt>" in p4 
just fix two obvious typos &mdash; end drafting note]</em></p>

<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          charT c);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          char c);
<i>// specialization</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         char c);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp; out,
                                            wchar_t c);</ins>

<i>// signed and unsigned</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                          signed char c);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                          unsigned char c);
</pre><blockquote>
<p>
-1- <i>Effects:</i> Behaves as a formatted output function (30.7.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>) of <tt>out</tt>. 
Constructs a character sequence <tt>seq</tt>. If <tt>c</tt> has type <tt>char</tt> and the character type of the stream 
is not <tt>char</tt>, then <tt>seq</tt> consists of <tt>out.widen(c)</tt>; otherwise <tt>seq</tt> consists of <tt>c</tt>. 
Determines padding for <tt>seq</tt> as described in 30.7.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>. Inserts <tt>seq</tt> into 
<tt>out</tt>. Calls <tt><del>os</del><ins>out</ins>.width(0)</tt>.
<p/>
-2- <i>Returns:</i> <tt>out</tt>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const charT* s);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const char* s);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp; out,
                                            const wchar_t* s);</ins>
											
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const signed char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const unsigned char* s);
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>s</tt> shall not be a null pointer.
<p/>
-4- <i>Effects:</i> Behaves like a formatted inserter (as described in 30.7.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>) of <tt>out</tt>. 
Creates a character sequence <tt>seq</tt> of <tt>n</tt> characters starting at <tt>s</tt>, each widened using <tt>out.widen()</tt> 
(27.5.5.3), where <tt>n</tt> is the number that would be computed as if by:
</p>
<ul>
<li><p>
<tt>traits::length(s)</tt> for the <ins>following</ins> overload<ins>s:</ins>
<ul>
<li><p>
where the first argument is of type <tt>basic_ostream&lt;charT, traits&gt;&amp;</tt> 
and the second is of type <tt>const charT*</tt>,
</p></li>
<li><p>
<del>and also for the overload</del> where the first argument is of type 
<tt>basic_ostream&lt;char, traits&gt;&amp;</tt> and the second is of type <tt>const char*</tt>,
</p></li>
<li><p>
<ins>where the first argument is of type 
<tt>basic_ostream&lt;wchar_t, traits&gt;&amp;</tt> and the second is of type <tt>const wchar_t*</tt>,</ins>
</p></li>
</ul> 
</p></li>
<li><p>
<tt>std::char_traits&lt;char&gt;::length(s)</tt> for the overload where the first argument is of type
<tt>basic_ostream&lt;charT, traits&gt;&amp;</tt> and the second is of type <tt>const char*</tt>,
</p></li>
<li><p>
<tt>traits::length(reinterpret_cast&lt;const char*&gt;(s))</tt> for the other two overloads.
</p></li>
</ul>
<p>
Determines padding for <tt>seq</tt> as described in 30.7.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>. Inserts <tt>seq</tt> into 
<tt>out</tt>. Calls <tt><ins>out.</ins>width(0)</tt>.
<p/>
-5- <i>Returns:</i> <tt>out</tt>.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2348" href="2348">2348.</a> <tt>charT('1')</tt> is not the wide equivalent of <tt>'1'</tt></h3>
<p><b>Section:</b> 23.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a>, 30.7.8 <a href="https://timsong-cpp.github.io/cppwp/quoted.manip">[quoted.manip]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#template.bitset">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Example: <tt>char16_t('1') != u'1'</tt> is possible.
<p/>
The numeric value of <tt>char16_t</tt> is defined to be Unicode
code point, which is same to the ASCII value and UTF-8 for
7-bit chars.  However, <tt>char</tt> is not guaranteed to have an
encoding which is compatible with ASCII. For example, <tt>'1'</tt> in EBCDIC is 241.
<p/>
I found three places in the standard casting narrow char
literals: <tt>bitset::bitset</tt>, <tt>bitset::to_string</tt> and <tt>quoted</tt>.
<p/>
PJ confirmed this issue and says he has a solution used
in their <tt>&lt;filesystem&gt;</tt> implementation, and he may want to
propose it to the standard.
<p/>
The solution in my mind, for now, is to make those default
arguments magical, where the "magic" can be implemented
with a C11 <tt>_Generic</tt> selection (works in clang):
</p>
<blockquote><pre>
#define _G(T, literal) _Generic(T{}, \
      char: literal, \
      wchar_t: L ## literal, \
      char16_t: u ## literal, \
      char32_t: U ## literal)

  _G(char16_t, '1') == u'1'
</pre></blockquote>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Ask for complete PR (need quoted, to string, et al.)</p>
<p>Will then take it up again</p>
<p>Expectation is that this is correct way to fix this</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

[<i>Drafting note:</i> This is a sample wording fixing only one case;
 I'm just too lazy to copy-paste it before we discussed whether
 the solution is worth and sufficient (for example, should the
 other `charT`s like `unsigned char` just don't compile without
 supplying those arguments?  I hope so). &mdash; <i>end drafting note</i>]

<ol>
<li><p>Modify 23.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> p1, class template <tt>bitset</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;size_t N&gt; class bitset {
  public:
    [&hellip;]
    template&lt;class charT, class traits, class Allocator&gt;
      explicit bitset(
        const basic_string&lt;charT,traits,Allocator&gt;&amp; str,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type pos = 0,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type n =
          basic_string&lt;charT,traits,Allocator&gt;::npos,
          charT zero = <del>charT('0')</del><ins><em>see below</em></ins>, charT one = <del>charT('1')</del><ins><em>see below</em></ins>);
     [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 23.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/bitset.cons">[bitset.cons]</a> as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
explicit 
bitset(const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type pos = 0,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type n =
         basic_string&lt;charT, traits, Allocator&gt;::npos,
         charT zero = <del>charT('0')</del><ins><em>see below</em></ins>, charT one = <del>charT('1')</del><ins><em>see below</em></ins>);
</pre><blockquote>
<p>
<ins>-?- The default values of <tt>zero</tt> and <tt>one</tt> compare equal to the
character literals <tt>0</tt> and <tt>1</tt> of type <tt>charT</tt>, respectively.</ins>
<p/>
-3- <i>Requires::</i> <tt>pos &lt;= str.size()</tt>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2349" href="2349">2349.</a> Clarify input/output function rethrow behavior</h3>
<p><b>Section:</b> 30.7.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted.reqmts">[istream.formatted.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-12-06 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.formatted.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/istream.formatted.reqmts">[istream.formatted.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The formatted input function requirement says in 30.7.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted.reqmts">[istream.formatted.reqmts]</a>:
</p>
<blockquote><p>
"If an exception is thrown during input then <tt>ios::badbit</tt> is turned on
in <tt>*this</tt>'s error state.  If <tt>(exceptions()&amp;badbit) != 0</tt> then the exception
is rethrown."
</p></blockquote>
<p>
while some formatted function may throw an exception from <tt>basic_ios::clear</tt>, for example
in 23.9.4 <a href="https://timsong-cpp.github.io/cppwp/bitset.operators">[bitset.operators]</a> p6:
</p>
<blockquote><p>
"If no characters are stored in <tt>str</tt>, calls <tt>is.setstate(ios_base::failbit)</tt> (which may 
throw <tt>ios_base::failure</tt>)"
</p></blockquote>
<p>
So should this exception be considered as "an exception [...] thrown
during input"?  And here is an implementation divergence (or you
can read the following as "a bug libc++ only has" :)
</p>
<blockquote><pre>
cin.exceptions(ios_base::failbit);
bitset&lt;N&gt; b;
try {
  cin &gt;&gt; b;  // type 'a' and return
} catch (...)
{}
</pre></blockquote>
<p>
Now <tt>cin.rdstate()</tt> is just <tt>failbit</tt> in libstdc++ (and Dinkumware, by
PJ), but <tt>failbit &amp; badbit</tt> libc++. Similar difference found in other
places, like <tt>eofbit &amp; badbid</tt> after <tt>std::getline</tt>.
<p/>
PJ and Matt both agree that the intention (of <tt>badbit</tt> + rethrow) is
"to signify an exception arising in user code, not the iostreams package".
<p/>
In addition, I found the following words in unformatted input
function's requirements (30.7.4.3 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a>):
</p>
<blockquote><p>
If an exception is thrown during input then <tt>ios::badbit</tt> is turned on
in <tt>*this</tt>'s error state. (Exceptions thrown from <tt>basic_ios&lt;&gt;::clear()</tt>
are not caught or rethrown.)  If <tt>(exceptions()&amp;badbit) != 0</tt> then the
exception is rethrown.
</p></blockquote>
<p>
The content within the parenthesis is added by LWG defect <a href="61">61</a>,
and does fix the ambiguity. However, it only fixed the 1 of 4
requirements, and it lost some context (the word "rethrown" is not
seen before this sentence within this section).
</p>

<p><i>[Lenexa 2015-05-07: Marshall to research and report]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

[<i>Drafting note:</i> The editor is kindly asked to introduce additional spaces at the following marked occurrences of
<tt>operator&amp;</tt> &mdash; <i>end drafting note</i>]

<ol>
<li><p>Modify 30.7.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted.reqmts">[istream.formatted.reqmts]</a> p1 as indicated:</p>

<blockquote><p>
-1- Each formatted input function begins execution by constructing an object of class <tt>sentry</tt> with the <tt>noskipws</tt>
(second) argument false. If the <tt>sentry</tt> object returns true, when converted to a value of type <tt>bool</tt>, the
function endeavors to obtain the requested input. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> 
is thrown during input then <tt>ios::badbit</tt>
is turned on[Footnote 314] in <tt>*this</tt>'s error state. If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> 
then the exception is rethrown.
In any case, the formatted input function destroys the <tt>sentry</tt> object. If no exception has been thrown, it returns <tt>*this</tt>.
</p></blockquote>
</li>

<li><p>Modify 30.7.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a> p1 as indicated:</p>

<blockquote><p>
-1- Each formatted output function begins execution by constructing an object of class <tt>sentry</tt>. If this object
returns true when converted to a value of type <tt>bool</tt>, the function endeavors to generate the requested
output. If the generation fails, then the formatted output function does <tt>setstate(ios_base::failbit)</tt>,
which might throw an exception. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> is thrown 
during output, then <tt>ios::badbit</tt> is turned on[Footnote 327]
in <tt>*this</tt>'s error state. If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> then the exception is rethrown. 
Whether or not
an exception is thrown, the <tt>sentry</tt> object is destroyed before leaving the formatted output function. If no
exception is thrown, the result of the formatted output function is <tt>*this</tt>.
</p></blockquote>
</li>

<li><p>Modify 30.7.5.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.unformatted">[ostream.unformatted]</a> p1 as indicated:</p>

<blockquote><p>
-1- Each unformatted output function begins execution by constructing an object of class <tt>sentry</tt>. If this object
returns true, while converting to a value of type <tt>bool</tt>, the function endeavors to generate the requested
output. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> is thrown during output, 
then ios::badbit is turned on[Footnote 330] in <tt>*this</tt>'s error state.
If <tt>(exceptions() &amp; badbit) != 0</tt> then the exception is rethrown. In any case, the unformatted output
function ends by destroying the <tt>sentry</tt> object, then, if no exception was thrown, returning the value specified
for the unformatted output function.
</p></blockquote>
</li>

<li><p>Modify 30.7.4.3 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> p1 as indicated:</p>

<blockquote><p>
-1- Each unformatted input function begins execution by constructing an object of class <tt>sentry</tt> with the default
argument <tt>noskipws</tt> (second) argument true. If the <tt>sentry</tt> object returns true, when converted to a value
of type <tt>bool</tt>, the function endeavors to obtain the requested input. Otherwise, if the <tt>sentry</tt> constructor exits
by throwing an exception or if the sentry object returns false, when converted to a value of type <tt>bool</tt>, the
function returns without attempting to obtain any input. In either case the number of extracted characters
is set to <tt>0</tt>; unformatted input functions taking a character array of non-zero size as an argument shall also
store a null character (using <tt>charT()</tt>) in the first location of the array. If an exception<ins>, other than the 
ones thrown from <tt>clear()</tt>, if any,</ins> is thrown during input
then <tt>ios::badbit</tt> is turned on[Footnote 317] in <tt>*this</tt>'s error state. <del>(Exceptions thrown from 
<tt>basic_ios&lt;&gt;::clear()</tt> are not caught or rethrown.)</del> If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> 
then the exception is rethrown. It also counts the number of characters extracted. If no exception has been thrown it ends 
by storing the count in a member object and returning the value specified. In any event the <tt>sentry</tt> object is destroyed 
before leaving the unformatted input function.
</p></blockquote>
</li>

</ol>






<hr>
<h3><a name="2352" href="2352">2352.</a> Is a default-constructed <tt>std::seed_seq</tt> intended to produce a predictable <tt>.generate()</tt>?</h3>
<p><b>Section:</b> 29.6.7.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.seedseq">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With respect to class <tt>seed_seq</tt> 29.6.7.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a>, is a default-constructed 
<tt>std::seed_seq</tt> intended to produce a predictable <tt>.generate()</tt> sequence?
<p/>
Implementations differ.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2358" href="2358">2358.</a> Apparently-bogus definition of <tt>is_empty</tt> type trait</h3>
<p><b>Section:</b> 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-02-01 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 'Condition' for <tt>std::is_empty</tt> is listed as:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no non-static data members other than bit-fields of length 0, 
no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which <tt>is_empty&lt;B&gt;::value</tt> 
is false."
</p></blockquote>
<p>
This is incorrect: there is no such thing as a non-static data member that is a bit-field of length 0, since bit-fields of 
length 0 must be unnamed, and unnamed bit-fields are not members (see 12.2.4 <a href="https://timsong-cpp.github.io/cppwp/class.bit">[class.bit]</a> p2).
<p/>
It also means that classes such as:
</p>
<blockquote><pre>
struct S {
 int : 3;
};
</pre></blockquote>
<p>
are empty (because they have no non-static data members). There's implementation divergence on the value of 
<tt>is_empty&lt;S&gt;::value</tt>.
<p/>
I'm not sure what the purpose of <tt>is_empty</tt> is (or how it could be useful), but if it's desirable for the above type to 
not be treated as empty, something like this could work:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no non-static data members <del>other than</del><ins>, no unnamed</ins> 
bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class 
<tt>B</tt> for which <tt>is_empty&lt;B&gt;::value</tt> is false."
</p></blockquote>
<p>
and if the above type <em>should</em> be treated as empty, then this might be appropriate:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no <ins>(named)</ins> non-static data members <del>other than bit-fields of 
length 0</del>, no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which 
<tt>is_empty&lt;B&gt;::value</tt> is false."
</p></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Walter says: We want <tt>is_empty_v&lt;S&gt;</tt> to produce false as a result.  Therefore, we recommend adoption of the first of the issue's suggestions.</p>
<p>Tuesday AM: Moved to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<p><i>[2016-10 by Marshall - this PR incorrectly highlighted changed portions]</i></p>


<blockquote class="note">
<p>Modify Table 38  Type property predicates for <tt>is_empty</tt> as follows:</p>
<blockquote><p>
<tt>T</tt> is a non-union class type with no non-static data members <del>other than</del><ins>, no unnamed</ins> bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which <tt>is_empty_v&lt;B&gt;</tt> is false.</p>
</blockquote>
</blockquote>

<p><i>[2016-10 Telecon]</i></p>

<p>Should probably point at section 1.8 for some of this. Status back to 'Open'</p>


<p><b>Proposed resolution:</b></p>
<p>Modify Table 38  Type property predicates for <tt>is_empty</tt> as follows:</p>
<blockquote><p>
<tt>T</tt> <del>is a class type, but not a union type,</del><ins>is a non-union class type</ins> with no non-static data members<del> other than</del><ins>, no unnamed</ins> bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which <tt>is_empty_v&lt;B&gt;</tt> is false.</p>
</blockquote>





<hr>
<h3><a name="2362" href="2362">2362.</a> unique, associative <tt>emplace()</tt> should not move/copy the <tt>mapped_type</tt> constructor 
arguments when no insertion happens</h3>
<p><b>Section:</b> 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-02-15 <b>Last modified:</b> 2015-09-23 18:09:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>a_uniq.emplace(args)</tt> is specified as:
</p>

<blockquote><p>
<i>Effects</i>: Inserts a value_type object <tt>t</tt> constructed with<br/>
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element in the<br/>
container with key equivalent to the key of <tt>t</tt>. The <tt>bool</tt> component of<br/>
the returned pair is true if and only if the insertion takes place,<br/>
and the iterator component of the pair points to the element with key<br/>
equivalent to the key of <tt>t</tt>. 
</p></blockquote>

<p>
However, we occasionally find code of the form:
</p>

<blockquote><pre>
std::unique_ptr&lt;Foo&gt; p(new Foo);
auto res = m.emplace("foo", std::move(p));
</pre></blockquote>

<p>
where we'd like to avoid destroying the <tt>Foo</tt> if the insertion doesn't
take place (if the container already had an element with the specified key).
<p/>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3873">N3873</a> includes
a partial solution to this in the form of a new <tt>emplace_stable</tt> member function, but LEWG's 
discussion strongly agreed that we'd rather have <tt>emplace()</tt> Just Work:
<p/>
Should <tt>map::emplace()</tt> be guaranteed not to move/copy its arguments if the insertion doesn't happen?
<p/>
SF: 8 F: 3 N: 0 A: 0 SA: 0
<p/>
This poll was marred by the fact that we didn't notice or call out
that <tt>emplace()</tt> must construct the key before doing the lookup, and it
must not then move the key after it determines whether an insert is
going to happen, and the <tt>mapped_type</tt> instance must live next to the key.
<p/>
The very similar issue <a href="2006">2006</a> was previously marked NAD, with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3178.htm">N3178</a> as
discussion. However, given LEWG's interest in the alternate behavior,
we should reopen the question in this issue.
<p/>
We will need a paper that describes how to implement this before we can make more progress.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2363" href="2363">2363.</a> Defect in 30.4.1.4.1 [thread.sharedtimedmutex.class]</h3>
<p><b>Section:</b> 33.4.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.class">[thread.sharedtimedmutex.class]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-02-16 <b>Last modified:</b> 2016-03-07 04:03:57 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
33.4.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.class">[thread.sharedtimedmutex.class]</a> paragraph 2: 
</p>
<blockquote><p> The class <tt>shared_timed_mutex</tt> shall satisfy all of the 
<tt>SharedTimedMutex</tt> requirements (30.4.1.4). It shall be a standard layout class (Clause 9).
</p></blockquote> 
<p>
There's no <tt>SharedTimedMutex</tt> requirements; this name doesn't appear anywhere else in the standard. (Prior to N3891, 
this was <tt>SharedMutex</tt>, which was equally undefined.)
<p/>
I assume this concept should be defined somewhere?
<p/>
Also, n3891 changes 33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a> from defining "shared mutex type" to defining 
"shared timed mutex type", but its paragraph 2 still talks about "shared mutex type". Is that OK? I think you could argue 
that it's clear enough what it means, but presumably it should use the term that paragraph 1 defined.
<p/>
33.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.shared">[thread.lock.shared]</a> paragraph 1 talks about the "shared mutex requirements", which again is a term that isn't 
defined, and presumably means "the requirements on a shared timed mutex type" or similar (maybe if <tt>SharedMutex</tt> or 
<tt>SharedTimedMutex</tt> were defined it could be reused here).
</p>

<p><i>[2014-05-22, Daniel comments]</i></p>

<p>
As for <tt>SharedTimedMutex</tt>, there exists a similar problem in regard to <tt>TimedMutex</tt> referred to in
33.4.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.class">[thread.timedmutex.class]</a> p2 and in 33.4.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.recursive">[thread.timedmutex.recursive]</a> p2, but nowhere defined.
<p/>
Another problem is, that according to 33.4.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a> p3, "The class <tt>mutex</tt> shall satisfy all the 
<tt>Mutex</tt> requirements (33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>).", but there are no concrete <tt>Mutex</tt> requirements,
33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> &mdash; titled as "Mutex requirements" &mdash; describes <em>mutex types</em>,
<em>timed mutex types</em>, and <em>shared timed mutex types</em>.
</p>

<p><i>[2014-06-08, Daniel comments and provides wording]</i></p>

<p>
The presented wording adds to the existing <em>mutex types</em>, <em>timed mutex types</em>, and <em>shared timed mutex types</em> 
terms a new set of corresponding <tt>MutexType</tt>, <tt>TimedMutexType</tt>, and <tt>SharedTimedMutexType</tt> requirements. 
<p/>
The reason for the change of requirement names is two-fold: First, the new name better matches the intention to have a concrete 
name for the requirements imposed on the corresponding <em>mutex types</em> (This kind of requirement deviate from the more general
<tt>Lockable</tt> requirements, which are not restricted to a explicitly enumerated set of library types). Second, using 
<tt>**MutexType</tt> over <tt>**Mutex</tt> provides the additional advantage that it reduces the chances of confusing named 
requirements from template parameters named <tt>Mutex</tt> (such as for <tt>unique_lock</tt> or <tt>shared_lock</tt>).
<p/>
Nonetheless the here presented wording has one unfortunate side-effect: Once applied it would have the effect that types
used to instantiate <tt>std::shared_lock</tt> cannot be user-defined shared mutex types due to 33.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.shared">[thread.lock.shared]</a>. 
The reason is based on the currently lack of an existing <tt>SharedLockable</tt> requirement set, which would complete the 
existing <tt>BasicLockable</tt> and <tt>Lockable</tt> requirements (which are "real" requirements). This restriction is not
actually a problem introduced by the provided resolution but instead one that existed before but becomes more obvious now.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>

<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
Thanks to Daniel, and please put it in SG1-OK status. Perhaps open another issue for the remaining problem Daniel points out?
</p>

<p><i>[2015-10 pre-Kona]</i></p>

<p>
SG1 hands this over to LWG for wording review
</p>

<p><i>[2015-10-21 Kona, Daniel comments and adjusts wording to to untimed shared mutex types]</i></p>

<p>
The new wording reflects the addition of the new shared mutex types. The approach used for <tt>shared_lock</tt>
is similar to the one used for <tt>unique_lock</tt>: The template argument <tt>Mutex</tt> has a reduced requirement set that is not
sufficient for <em>all</em> operations. Only those members that require stronger requirements of <tt>SharedTimedMutexType</tt>
specify that additionally in the <i>Requires</i> element of the corresponding prototype specifications.
<p/>
The proposed wording could be more general if we would introduce more fundamental requirements set for <tt>SharedLockable</tt>
and <tt>SharedTimedLockable</tt> types which could be satisfied by user-provided types as well, because the 
<tt>SharedMutexType</tt> and <tt>SharedTimedMutexType</tt> requirements are essentially restricted to an enumerated set of
types provided by the Standard Library. But this extension seemed too large for this issue and can be easily fixed later
without any harm. 
</p>

<p><b>Previous resolution [SUPERSEDED]:</b></p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a> as indicated:</p>

<blockquote><p>
-1- The <em>mutex types</em> are the standard library types <tt>std::mutex</tt>, <tt>std::recursive_mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_timed_mutex</tt>, and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>MutexType</em></tt></ins> 
requirements set out in this section. In this description, <tt>m</tt> denotes an object of a mutex type.
</p></blockquote>
</li>

<li><p>Change 33.4.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a> as indicated:</p>

<blockquote><p>
-3- The class <tt>mutex</tt> shall satisfy all the <tt>Mutex<ins>Type</ins></tt> requirements 
(<ins>33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a></ins><del>33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a></del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.recursive">[thread.mutex.recursive]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_mutex</tt> shall satisfy all the <del>Mutex</del><ins><tt>MutexType</tt></ins> requirements 
(<ins>33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a></ins><del>33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a></del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a> as indicated:</p>

<blockquote><p>
-1- The <em>timed mutex types</em> are the standard library types <tt>std::timed_mutex</tt>, <tt>std::recursive_timed_mutex</tt>,
and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>TimedMutexType</em></tt></ins> requirements set out below. 
In this description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_time</tt> denotes an object of an instantiation of 
<tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
</p></blockquote>
</li>

<li><p>Change 33.4.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.class">[thread.timedmutex.class]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.recursive">[thread.timedmutex.recursive]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a> as indicated: [<i>Drafting note</i>: The reference to the
timed mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedTimedMutexType</tt> <em>refine</em> <tt>TimedMutexType</tt>.]</p>

<blockquote>
<p>
-1- The standard library type <tt>std::shared_timed_mutex</tt> is a <em>shared timed mutex type</em>. Shared timed mutex
types shall meet the <ins><tt><em>SharedTimedMutexType</em></tt></ins> requirements <del>of timed mutex types 
(33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>), and additionally shall meet the requirements</del> set out below. In this 
description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_type</tt> denotes
an object of an instantiation of <tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of
<tt>time_point</tt> (20.12.6).
<p/>
<ins>-?- The shared timed mutex types shall meet the <tt>TimedMutexType</tt> requirements (33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>).</ins>
</p>
</blockquote>
</li>

<li><p>Change 33.4.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.class">[thread.sharedtimedmutex.class]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_timed_mutex</tt> shall satisfy all of the <tt>SharedTimedMutex<ins>Type</ins></tt> requirements 
(33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a>). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.shared">[thread.lock.shared]</a> as indicated: [<i>Drafting note</i>: Once 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3995.htm">N3995</a> has been applied, the following 
reference should be changed to the new <tt>SharedMutexType</tt> requirements ([thread.sharedmutex.requirements]) or 
even better to some new <tt>SharedLockable</tt> requirements (to be defined) &mdash; <i>end drafting note</i>]</p>

<blockquote><p>
-1- [&hellip;] The supplied <tt>Mutex</tt> type shall meet the <del>shared mutex</del><ins><tt>SharedTimedMutexType</tt></ins> requirements 
(33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a>).
<p/>
-2- [<i>Note</i>: <tt>shared_lock&lt;Mutex&gt;</tt> meets the <tt>TimedLockable</tt> requirements 
(30.2.5.4). &mdash; <i>end note</i>]
</p></blockquote>
</li>
</ol>

</blockquote>

<p><i>[2016-02 Jacksonville]</i></p>

<p>
Marshall to review wording.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<ol>
<li><p>Change 33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a> as indicated:</p>

<blockquote><p>
-1- The <em>mutex types</em> are the standard library types <tt>std::mutex</tt>, <tt>std::recursive_mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_timed_mutex</tt>, <tt>std::shared_mutex</tt>, and <tt>std::shared_timed_mutex</tt>. They shall meet the 
<ins><tt><em>MutexType</em></tt></ins> requirements set out in this section. In this description, <tt>m</tt> denotes an object 
of a mutex type.
<p/>
-2- The mutex types shall meet the <tt>Lockable</tt> requirements (33.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.req">[thread.req.lockable.req]</a>).
</p></blockquote>
</li>

<li><p>Change 33.4.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a> as indicated:</p>

<blockquote><p>
-3- The class <tt>mutex</tt> shall satisfy all the <tt>Mutex<ins>Type</ins></tt> requirements 
(<ins>33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a></ins><del>33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a></del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.recursive">[thread.mutex.recursive]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_mutex</tt> shall satisfy all the <del>Mutex</del><ins><tt>MutexType</tt></ins> requirements 
(<ins>33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a></ins><del>33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a></del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a> as indicated:</p>

<blockquote><p>
-1- The <em>timed mutex types</em> are the standard library types <tt>std::timed_mutex</tt>, <tt>std::recursive_timed_mutex</tt>,
and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>TimedMutexType</em></tt></ins> requirements set out below. 
In this description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_time</tt> denotes an object of an instantiation of 
<tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
<p/>
-2- The timed mutex types shall meet the <tt>TimedLockable</tt> requirements (33.2.5.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.timed">[thread.req.lockable.timed]</a>).
</p></blockquote>
</li>

<li><p>Change 33.4.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.class">[thread.timedmutex.class]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.recursive">[thread.timedmutex.recursive]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedmutex.requirements">[thread.sharedmutex.requirements]</a> as indicated:  [<i>Drafting note</i>: The reference to the
mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedMutexType</tt> <em>refines</em> <tt>MutexType</tt>.]</p>

<blockquote><p>
-1- The standard library types <tt>std::shared_mutex</tt> and <tt>std::shared_timed_mutex</tt> are <em>shared mutex types</em>.
Shared mutex types shall meet the <ins><tt><em>SharedMutexType</em></tt></ins> requirements <del>of mutex types 
(33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>), and additionally shall meet the 
requirements</del> set out below. In this description, <tt>m</tt> denotes an object of a shared mutex type.
<p/>
<ins>-?- The shared mutex types shall meet the <tt>MutexType</tt> requirements (33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>).</ins>
</p>
</blockquote>
</li>

<li><p>Change 33.4.3.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedmutex.class">[thread.sharedmutex.class]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_mutex</tt> shall satisfy all of the <ins><tt>SharedMutexType</tt></ins> requirements 
<del>for shared mutexes</del> (33.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedmutex.requirements">[thread.sharedmutex.requirements]</a>). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a> as indicated: [<i>Drafting note</i>: The reference to the
timed mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedTimedMutexType</tt> <em>refines</em> <tt>TimedMutexType</tt> and <tt>SharedMutexType</tt>.]</p>

<blockquote>
<p>
-1- The standard library type <tt>std::shared_timed_mutex</tt> is a <em>shared timed mutex type</em>. Shared timed mutex
types shall meet the <ins><tt><em>SharedTimedMutexType</em></tt></ins> requirements <del>of timed mutex types 
(33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>), shared mutex types (33.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedmutex.requirements">[thread.sharedmutex.requirements]</a>), 
and additionally shall meet the requirements</del> set out below. In this description, <tt>m</tt> denotes an object of 
a shared timed mutex type, <tt>rel_type</tt> denotes an object of an instantiation of <tt>duration</tt> (20.12.5), and 
<tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
<p/>
<ins>-?- The shared timed mutex types shall meet the <tt>TimedMutexType</tt> requirements (33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>)
and the <tt>SharedMutexType</tt> requirements (33.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedmutex.requirements">[thread.sharedmutex.requirements]</a>).</ins>
</p>
</blockquote>
</li>

<li><p>Change 33.4.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.class">[thread.sharedtimedmutex.class]</a> as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_timed_mutex</tt> shall satisfy all of the <ins><tt>SharedTimedMutexType</tt></ins> requirements 
<del>for shared timed mutexes</del> (33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a>). It shall be a standard-layout 
class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 33.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.shared">[thread.lock.shared]</a> as indicated:</p>

<blockquote><p>
-1- [&hellip;] The supplied <tt>Mutex</tt> type shall meet the <del>shared mutex</del><ins><tt>SharedMutexType</tt></ins> requirements 
(<del>33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a></del><ins>33.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedmutex.requirements">[thread.sharedmutex.requirements]</a></ins>).
<p/>
-2- [<i>Note</i>: <tt>shared_lock&lt;Mutex&gt;</tt> meets the <tt>TimedLockable</tt> requirements 
(30.2.5.4). &mdash; <i>end note</i>]
</p></blockquote>
</li>

<li><p>Change 33.4.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.shared.cons">[thread.lock.shared.cons]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration&gt;
  shared_lock(mutex_type&amp; m,
              const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote>
<p>
-14- <i>Requires</i>: <ins>The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a>).</ins> 
The calling thread does not own the mutex for any ownership mode.
<p/>
-15- <i>Effects</i>: Constructs an object of type <tt>shared_lock</tt> and calls <tt>m.try_lock_shared_until(abs_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class Rep, class Period&gt;
  shared_lock(mutex_type&amp; m,
              const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p>
-17- <i>Requires</i>: <ins>The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a>).</ins> 
The calling thread does not own the mutex for any ownership mode.
<p/>
-18- <i>Effects</i>: Constructs an object of type <tt>shared_lock</tt> and calls <tt>m.try_lock_shared_for(rel_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Change 33.4.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.shared.locking">[thread.lock.shared.locking]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration&gt;
  bool
  try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a>).</ins>
<p/>
-8- <i>Effects</i>: <tt>pm-&gt;try_lock_shared_until(abs_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class Rep, class Period&gt;
  bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(33.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a>).</ins>
<p/>
-12- <i>Effects</i>: <tt>pm-&gt;try_lock_shared_for(rel_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2366" href="2366">2366.</a> <tt>istreambuf_iterator</tt> end-of-stream equality</h3>
<p><b>Section:</b> 27.6.3 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hyman Rosen <b>Opened:</b> 2014-02-19 <b>Last modified:</b> 2014-06-17 08:06:43 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istreambuf.iterator">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given the following code,
</p>
<blockquote><pre>
#include &lt;sstream&gt;

std::stringbuf buf;
std::istreambuf_iterator&lt;char&gt; begin(&amp;buf);
std::istreambuf_iterator&lt;char&gt; end;
</pre></blockquote>
<p>
it is not clear from the wording of the Standard whether <tt>begin.equal(end)</tt>
must be true. In at least one implementation it is not (CC: Sun C++ 5.10 SunOS_sparc Patch 128228-25 2013/02/20) and in at least
one implementation it is (gcc version 4.3.2 x86_64-unknown-linux-gnu).
<p/>
27.6.3 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a> says that <tt>end</tt> is an end-of-stream iterator since it was default
constructed. It also says that an iterator becomes equal to an end-of-stream
iterator when end of stream is reached by <tt>sgetc()</tt> having returned <tt>eof()</tt>.
27.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator::equal">[istreambuf.iterator::equal]</a> says that <tt>equal()</tt> returns true iff both iterators are end of stream
or not end of stream. But there seems to be no requirement that <tt>equal</tt> check for end-of-stream by calling <tt>sgetc()</tt>. 
<p/>
Jiahan Zi at BloombergLP discovered this issue through his code failing to
work correctly. Dietmar K&uuml;hl has opined in a private communication that
the iterators should compare equal.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2368" href="2368">2368.</a> Replacing global <tt>operator new</tt></h3>
<p><b>Section:</b> 21.6.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete">[new.delete]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephen Clamage <b>Opened:</b> 2014-02-20 <b>Last modified:</b> 2016-03-08 22:03:25 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/new.delete">[new.delete]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 21.6.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete">[new.delete]</a> and subsections shows:
</p>
<blockquote><pre>
void* operator new(std::size_t size);
void* operator new[](std::size_t size);
</pre></blockquote>
<p>
That is, without exception-specifications. (Recall that C++03 specified these functions with <tt>throw(std::bad_alloc)</tt>.)
<p/>
Section 20.5.5.12 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a> the end of paragraph 4 says:
</p>
<blockquote><p>
Any other functions defined in the C++ standard library that do not have an exception-specification may throw implementation-defined 
exceptions unless otherwise specified. An implementation may strengthen this implicit exception-specification by adding an explicit one.
</p></blockquote>
<p>
For example, an implementation could provide C++03-compatible declarations of <tt>operator new</tt>.
<p/>
Programmers are allowed to replace these <tt>operator new</tt> functions. But how can you write the definition of these functions when 
the exception specification can vary among implementations? For example, the declarations
</p>
<blockquote><pre>
void* operator new(std::size_t size) throw(std::bad_alloc);
void* operator new(std::size_t size);
</pre></blockquote>
<p>
are not compatible.
<p/>
From what I have been able to determine, gcc has a hack for the special case of <tt>operator new</tt> to ignore the differences in 
(at least) the two cases I show above. But can users expect all compilers to quietly ignore the incompatibility?
<p/>
The blanket permission to add any explicit exception specification could cause a problem for any user-overridable function. 
Different implementations could provide incompatible specifications, making portable code impossible to write.
</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>
STL: Core changes to remove dynamic exception specs would make this moot<br/>
Room: This is on track to be resolved by <a href="http://wg21.link/P0003">P0003</a>, or may be moot.<br/>
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2375" href="2375">2375.</a> Is [iterator.requirements.general]/9 too broadly applied?</h3>
<p><b>Section:</b> 27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2014-03-25 <b>Last modified:</b> 2014-06-17 08:06:43 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> p9 says:
</p>
<blockquote><p>
Destruction of an iterator may invalidate pointers and references previously obtained from that iterator.
</p></blockquote>
<p>
But the resolution of LWG issue <a href="2360">2360</a> specifically advocates returning <tt>*--temp;</tt> where <tt>temp</tt> is a 
local variable.
<p/>
And 27.2.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> p6 says:
</p>
<blockquote><p>
If <tt>a</tt> and <tt>b</tt> are both dereferenceable, then <tt>a == b</tt> if and only if <tt>*a</tt> and <tt>*b</tt> are bound 
to the same object.
</p></blockquote>
<p>
which disallows "stashing" iterators (i.e, iterators that refer to data inside themselves).
<p/>
So, I suspect that the restriction in p9 should only apply to input iterators, and can probably be moved into 
27.2.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> instead of 27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>.
</p>

<p><i>[2014-05-22, Daniel comments]</i></p>


<p>
Given that forward iterators (and beyond) are refinements of input iterator, moving this constraint to input iterators won't help
much because it would still hold for all refined forms. 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2381" href="2381">2381.</a> Inconsistency in parsing floating point numbers</h3>
<p><b>Section:</b> 25.4.2.1.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2014-04-30 <b>Last modified:</b> 2016-09-08 20:09:59 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25.4.2.1.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> we have:
</p>
<blockquote><p>
Stage 3: The sequence of chars accumulated in stage 2 (the field) is converted to a numeric value by the
rules of one of the functions declared in the header <tt>&lt;cstdlib&gt;</tt>:
</p>
<ul>
<li><p>For a signed integer value, the function <tt>strtoll</tt>.</p></li>
<li><p>For an unsigned integer value, the function <tt>strtoull</tt>.</p></li>
<li><p>For a floating-point value, the function <tt>strtold</tt>.</p></li>
</ul>
</blockquote>
<p>
This implies that for many cases, this routine should return true:
</p>
<blockquote><pre>
bool is_same(const char* p) 
{
  std::string str{p};
  double val1 = std::strtod(str.c_str(), nullptr);
  std::stringstream ss(str);
  double val2;
  ss &gt;&gt; val2;
  return std::isinf(val1) == std::isinf(val2) &amp;&amp;                 // either they're both infinity
         std::isnan(val1) == std::isnan(val2) &amp;&amp;                 // or they're both NaN
         (std::isinf(val1) || std::isnan(val1) || val1 == val2); // or they're equal
}
</pre></blockquote>
<p>
and this is indeed true, for many strings:
</p>
<blockquote><pre>
assert(is_same("0"));
assert(is_same("1.0"));
assert(is_same("-1.0"));
assert(is_same("100.123"));
assert(is_same("1234.456e89"));
</pre></blockquote>
<p>
but not for others
</p>
<blockquote><pre>
assert(is_same("0xABp-4")); // hex float
assert(is_same("inf"));
assert(is_same("+inf"));
assert(is_same("-inf"));
assert(is_same("nan"));
assert(is_same("+nan"));
assert(is_same("-nan"));

assert(is_same("infinity"));
assert(is_same("+infinity"));
assert(is_same("-infinity"));
</pre></blockquote>
<p>
These are all strings that are correctly parsed by <tt>std::strtod</tt>, but not by the stream extraction operators.
They contain characters that are deemed invalid in stage 2 of parsing.
<p/>
If we're going to say that we're converting by the rules of <tt>strtold</tt>, then we should accept all the things that 
<tt>strtold</tt> accepts.
</p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
People are much more interested in round-tripping hex floats than handling <tt>inf</tt> and <tt>nan</tt>. Priority changed to P2.
</p>
<p>
Marshall says he'll try to write some wording, noting that this is a very closely specified part of the standard, and has remained unchanged for a long time. Also, there will need to be a sample implementation.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Zhihao provides wording</p>
<p>The <tt>src</tt> array in Stage 2 does narrowing only.  The actual
input validation is delegated to <tt>strtold</tt> (independent from
the parsing in Stage 3 which is again being delegated
to <tt>strtold</tt>) by saying:</p>

<p>  [...] If it is not discarded, then a check is made to determine
  if c is allowed as the next character of an input field of the
  conversion specifier returned by Stage 1.</p>

<p>So a conforming C++11 <tt>num_get</tt> is supposed to magically
accept an hexfloat without an exponent</p>

<p>  0x3.AB</p>

<p>because we refers to C99, and the fix to this issue should be
just expanding the <tt>src</tt> array.</p>

<p>Support for Infs and NaNs are not proposed because of the
complexity of nan(n-chars).</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Tues PM: Move to Open</p>

<p><i>[2016-09-08, Zhihao Yuan comments and updates proposed wording]</i></p>

<p>
Examples added.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol> 
<li><p>Change 25.4.2.1.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a>/3 Stage 2 as indicated:</p>

<blockquote>
<p><tt>static const char src[] = "0123456789abcdef<ins>p</ins>xABCDEF<ins>P</ins>X+-";</tt></p>
</blockquote>
</li>

<li><p>Append the following examples to 25.4.2.1.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a>/3 Stage 2 as indicated:</p>
<blockquote>
<p>
<ins>[<i>Example:</i></ins>
</p>
<blockquote>
<p>
<ins>Given an input sequence of <tt>"0x1a.bp+07p"</tt>,</ins>
</p>
<ul>
<li><p><ins>if Stage 1 returns <tt>%d</tt>, <tt>"0"</tt> is accumulated;</ins></p></li>
<li><p><ins>if Stage 1 returns <tt>%i</tt>, <tt>"0x1a"</tt> are accumulated;</ins></p></li>
<li><p><ins>if Stage 1 returns <tt>%g</tt>, <tt>"0x1a.bp+07"</tt> are accumulated.</ins></p></li>
</ul>
<p>
<ins>In all cases, leaving the rest in the input.</ins>
</p>
</blockquote>
<p><ins>&mdash; end example]</ins></p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2383" href="2383">2383.</a> Overflow cannot be ill-formed for chrono::duration integer literals</h3>
<p><b>Section:</b> 23.17.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.literals">[time.duration.literals]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-05-16 <b>Last modified:</b> 2014-11-08 16:11:57 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.17.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.literals">[time.duration.literals]</a> p3 says:
</p>
<blockquote><p>
If any of these suffixes are applied to an integer literal and the
resulting <tt>chrono::duration</tt> value cannot be represented in the result
type because of overflow, the program is ill-formed.
</p></blockquote>
<p>
Ill-formed requires a diagnostic at compile-time, but there is no way
to  detect the overflow from <tt>unsigned long long</tt> to the <tt>signed
duration&lt;&gt;::rep</tt> type.
<p/>
Overflow could be detected if the duration integer literals were
literal operator templates, otherwise overflow can either be undefined
or a run-time error, not ill-formed.
</p>

<p><i>[Urbana 2014-11-07: Move to Open]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2392" href="2392">2392.</a> "character type" is used but not defined</h3>
<p><b>Section:</b> 20.3.16 <a href="https://timsong-cpp.github.io/cppwp/defns.ntcts">[defns.ntcts]</a>, 25.3.1.1.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a>, 30.2.2 <a href="https://timsong-cpp.github.io/cppwp/iostreams.limits.pos">[iostreams.limits.pos]</a>, 30.7.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>, 30.7.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.character">[ostream.inserters.character]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-06-01 <b>Last modified:</b> 2015-09-23 18:09:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The term "character type" is used in 20.3.16 <a href="https://timsong-cpp.github.io/cppwp/defns.ntcts">[defns.ntcts]</a>, 25.3.1.1.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a>,
30.2.2 <a href="https://timsong-cpp.github.io/cppwp/iostreams.limits.pos">[iostreams.limits.pos]</a>, 30.7.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>, and
30.7.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.character">[ostream.inserters.character]</a>, but the core language only defines
"narrow character types" (6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>).
<p/>
"wide-character type" is used in 99 [locale.stdcvt], but the core
language only defines a "wide-character set" and "wide-character literal".
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2398" href="2398">2398.</a> <tt>type_info</tt>'s destructor shouldn't be required to be virtual</h3>
<p><b>Section:</b> 21.7.2 <a href="https://timsong-cpp.github.io/cppwp/type.info">[type.info]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-06-14 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#type.info">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/type.info">[type.info]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>type_info</tt>'s destructor is depicted as being <tt>virtual</tt>, which is nearly unobservable to users (since they can't construct 
or copy this class, they can't usefully derive from it). However, it's technically observable (via <tt>is_polymorphic</tt> and 
<tt>has_virtual_destructor</tt>). It also imposes real costs on implementations, requiring them to store one vptr per 
<tt>type_info</tt> object, when RTTI space consumption is a significant concern.
<p/>
Making this implementation-defined wouldn't affect users (who can observe this only if they're specifically looking for it) and 
wouldn't affect implementations who need <tt>virtual</tt> here, but it would allow other implementations to drop <tt>virtual</tt> 
and improve their RTTI space consumption.
<p/>
Richard Smith:
<p/>
It's observable in a few other ways.
</p>
<blockquote><pre>
std::map&lt;void*, something&gt; m;
m[dynamic_cast&lt;void*&gt;(&amp;typeid(blah))] = stuff;
</pre></blockquote>
<p>
... is broken by this change, because you can't <tt>dynamic_cast</tt> a non-polymorphic class type to <tt>void*</tt>.
</p>
<blockquote><pre>
type_info&amp; f();
typeid(f());
</pre></blockquote>
<p>
... evaluates <tt>f()</tt> at runtime without this change, and might not do so with this change.
<p/>
These are probably rare things, but I can imagine at least some forms of the latter being used in SFINAE tricks.
</p>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Marshall to poll LEWG for their opinion</p>

<p><i>[2016-06]</i></p>
 
<p>
On the <a href="http://lists.isocpp.org/lib-ext/2016/06/2451.php">reflector</a>, STL wrote:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>We'll prototype this change and report back with data in the future.</p></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>No update from STL. Set priority to P3</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 21.7.2 <a href="https://timsong-cpp.github.io/cppwp/type.info">[type.info]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  class type_info {
  public:
    <del>virtual</del><ins><i>see below</i></ins> ~type_info();
    [&hellip;]
  };
}
</pre>
<p>
-1- The class <tt>type_info</tt> describes type information generated by the implementation. Objects of this class
effectively store a pointer to a name for the type, and an encoded value suitable for comparing two types for
equality or collating order. The names, encoding rule, and collating sequence for types are all unspecified
and may differ between programs. <ins>Whether <tt>~type_info()</tt> is <tt>virtual</tt> is implementation-defined.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2412" href="2412">2412.</a> <tt>promise::set_value()</tt> and <tt>promise::get_future()</tt> should not race</h3>
<p><b>Section:</b> 33.6.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>, 33.6.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-06-23 <b>Last modified:</b> 2017-03-01 18:03:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code has a data race according to the standard:
</p>
<blockquote>
<pre>
std::promise&lt;void&gt; p;
std::thread t{ []{
  p.get_future().wait();
}};
p.set_value();
t.join();
</pre>
</blockquote>
<p>
The problem is that both <tt>promise::set_value()</tt> and
<tt>promise::get_future()</tt> are non-const member functions which modify the
same object, and we only have wording saying that the <tt>set_value()</tt> and
<tt>wait()</tt> calls (i.e. calls setting and reading the shared state) are
synchronized.
<p/>
The calls don't actually access the same memory locations, so the
standard should allow it. My suggestion is to state that calling
<tt>get_future()</tt> does not conflict with calling the various functions that
make the shared state ready, but clarify with a note that this does
not imply any synchronization or "happens before", only being free
from data races.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>

<p><i>[2016-10-21, Nico comments]</i></p>

<p>
After creating a promise or packaged task one thread can call <tt>get_future()</tt>
while another thread can set values/exceptions (either directly or via function call).
This happens very easily.
<p/>
Consider:
</p>
<blockquote><pre>
promise&lt;string&gt; p;
thread t(doSomething, ref(p));
cout &lt;&lt; "result: " &lt;&lt; p.get_future().get() &lt;&lt; endl;
</pre></blockquote>
<p>
AFAIK, this is currently UB due to a data race (calling <tt>get_future()</tt> for the 
promise might happen while setting the value in the promise).
<p/>
Yes, a fix is pretty easy:
</p>
<blockquote><pre>
promise&lt;string&gt; p;
future&lt;string&gt; f(p.get_future());
thread t(doSomething, ref(p));
cout &lt;&lt; "result: " &lt;&lt; f.get() &lt;&lt; endl;
</pre></blockquote>
<p>
but I would like to have <tt>get_future()</tt> and setters be synchronized to avoid this UB.
<p/>
This would especially make the use of packaged tasks a lot easier. Consider:
</p>
<blockquote><pre>
vector&lt;packaged_task&lt;int(char)&gt;&gt; tasks;
packaged_task&lt;int(char)&gt; t1(func);

// start separate thread to run all tasks:
auto futCallTasks = async(launch::async, callTasks, ref(tasks));

for (auto&amp; fut : tasksResults) {
  cout &lt;&lt; "result: " &lt;&lt; fut.get_future().get() &lt;&lt; endl; // OOPS: UB
}
</pre></blockquote>
<p>
Again, AFAIK, this program currently is UB due to a data race.
Instead, currently I'd have to program, which is a lot less convenient:
</p>
<blockquote><pre>
vector&lt;packaged_task&lt;int(char)&gt;&gt; tasks;
vector&lt;future&lt;int&gt;&gt; tasksResults;
packaged_task&lt;int(char)&gt; t1(func);
tasksResults.push_back(t1.getFuture()));
tasks.push_back(move(t1));

// start separate thread to run all tasks:
auto futCallTasks = async(launch::async, callTasks, ref(tasks));

for (auto&amp; fut : tasksResults) {
  cout &lt;&lt; "result: " &lt;&lt; fut.get() &lt;&lt; endl;
}
</pre></blockquote>
<p>
With my naive thinking I see not reason not to guarantee
that these calls synchronize (as <tt>get_future</tt> returns an "address/reference"
while all setters set the values there).
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 33.6.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> around p12 as indicated:</p>

<blockquote>
<pre>
future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-12- <i>Returns</i>: A <tt>future&lt;R&gt;</tt> object with the same shared state as <tt>*this</tt>.
<p/>
<ins>-?- <i>Synchronization</i>: Calls to this function do not conflict (4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>) 
with calls to <tt>set_value</tt>, <tt>set_exception</tt>, <tt>set_value_at_thread_exit</tt>, or
<tt>set_exception_at_thread_exit</tt>. [<i>Note</i>: Such calls need not be synchronized, but implementations 
must ensure they do not introduce data races. &mdash; <i>end note</i>]</ins>
<p/>
-13- <i>Throws</i>: <tt>future_error</tt> if <tt>*this</tt> has no shared state or if <tt>get_future</tt> has already been called on a
<tt>promise</tt> with the same shared state as <tt>*this</tt>.
<p/>
-14- <i>Error conditions</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 33.6.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> around p13 as indicated:</p>

<blockquote>
<pre>
future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-13- <i>Returns</i>: A <tt>future&lt;R&gt;</tt> object that shares the same shared state as <tt>*this</tt>.
<p/>
<ins>-?- <i>Synchronization</i>: Calls to this function do not conflict (4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>) 
with calls to <tt>operator()</tt> or <tt>make_ready_at_thread_exit</tt>. [<i>Note</i>: Such calls need not be 
synchronized, but implementations must ensure they do not introduce data races. &mdash; <i>end note</i>]</ins>
<p/>
-14- <i>Throws</i>: a <tt>future_error</tt> object if an error occurs.
<p/>
-15- <i>Error conditions</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2017-02-28, Kona]</i></p>

<p>
SG1 has updated wording for LWG 2412. SG1 voted to move this to Ready status by unanimous consent.
</p>

<p><i>[2017-03-01, Kona, SG1]</i></p>

<p>
GeoffR to forward revised wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Change 33.6.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> around p12 as indicated:</p>

<blockquote>
<pre>
future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-12- <i>Returns</i>: A <tt>future&lt;R&gt;</tt> object with the same shared state as <tt>*this</tt>.
<p/>
<ins>-?- <i>Synchronization</i>: Calls to this function do not introduce data races (4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>) with 
calls to <tt>set_value</tt>, <tt>set_exception</tt>, <tt>set_value_at_thread_exit</tt>, or <tt>set_exception_at_thread_exit</tt>. 
[<i>Note</i>: Such calls need not synchronize with each other. &mdash; <i>end note</i>]</ins>
<p/>
-13- <i>Throws</i>: <tt>future_error</tt> if <tt>*this</tt> has no shared state or if <tt>get_future</tt> has already been called on a
<tt>promise</tt> with the same shared state as <tt>*this</tt>.
<p/>
-14- <i>Error conditions</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 33.6.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> around p13 as indicated:</p>

<blockquote>
<pre>
future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-13- <i>Returns</i>: A <tt>future</tt> object that shares the same shared state as <tt>*this</tt>.
<p/>
<ins>-?- <i>Synchronization</i>: Calls to this function do not introduce data races (4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>) with calls 
to <tt>operator()</tt> or <tt>make_ready_at_thread_exit</tt>. [<i>Note</i>: Such calls need not synchronize with each other. 
&mdash; <i>end note</i>]</ins>
<p/>
-14- <i>Throws</i>: a <tt>future_error</tt> object if an error occurs.
<p/>
-15- <i>Error conditions</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2413" href="2413">2413.</a> <tt>assert</tt> macro is overconstrained</h3>
<p><b>Section:</b> 22.3 <a href="https://timsong-cpp.github.io/cppwp/assertions">[assertions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2014-06-25 <b>Last modified:</b> 2014-11-03 20:11:17 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#assertions">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/assertions">[assertions]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <tt>NDEBUG</tt> is defined, <tt>assert</tt> must expand exactly to the token sequence <tt>((void)0)</tt>, with no 
whitespace (C99 &sect;7.2/1 and also C11 &sect;7.2/1). This is a lost opportunity to pass the condition along to the optimizer.
<p/>
The user may observe the token sequence using the stringize operator or discriminate it by making a matching <tt>#define</tt> 
directive. There is little chance of practical code doing such things. It's reasonable to allow any expansion that is a <tt>void</tt> 
expression with no side effects or semantic requirements, for example, an extension keyword or an attribute-specifier finagled 
into the context.
<p/>
Conforming optimizations would still be limited to treating the condition as hint, not a requirement. Nonconformance on this 
point is quite reasonable though, given user preferences. Anyway, it shouldn't depend on preprocessor quirks.
<p/>
As for current practice, Darwin OS <tt>&lt;assert.h&gt;</tt> provides a GCC-style compiler hint <tt>__builtin_expect</tt> but only in 
debug mode. Shouldn't release mode preserve hints?
<p/>
Daniel:
<p/>
The corresponding resolution should take care not to conflict with the intention behind LWG <a href="2234">2234</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2414" href="2414">2414.</a> Member function reentrancy should be implementation-defined</h3>
<p><b>Section:</b> 20.5.5.8 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-07-01 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reentrancy">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N3936 20.5.5.8 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a>/1 talks about "functions", but that doesn't address the scenario of calling different member 
functions of a single object. Member functions often have to violate and then re-establish invariants. For example, vectors 
often have "holes" during insertion, and element constructors/destructors/etc. shouldn't be allowed to observe the vector 
while it's in this invariant-violating state. The [reentrancy] Standardese should be extended to cover member functions, 
so that implementers can either say that member function reentrancy is universally prohibited, or selectively allowed for 
very specific scenarios.
<p/>
(For clarity, this issue has been split off from LWG <a href="2382">2382</a>.)
</p>

<p><i>[2014-11-03 Urbana]</i></p>

<p>
AJM confirmed with SG1 that they had no special concerns with this issue, and LWG should retain ownership.
<p/>
AM: this is too overly broad as it also covers calling the exact same member function on a different object<br/>
STL: so you insert into a map, and copying the value triggers another insertion into a different map of the same type<br/>
GR: reentrancy seems to imply the single-threaded case, but needs to consider the multi-threaded case
<p/>
Needs more wording.
</p>
<p>
Move to Open
</p>

<p><i>[2015-07 Telecon Urbana]</i></p>

<p>
Marshall to ping STL for updated wording.<br/>
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 20.5.5.8 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a> p1 as indicated:</p>
<blockquote>
<p>
-1- Except where explicitly specified in this standard, it is implementation-defined which functions <ins>(including different 
member functions called on a single object)</ins> in the Standard C++ library may be recursively reentered.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2417" href="2417">2417.</a> [fund.ts.v2] <tt>std::experimental::optional::operator&lt;</tt> and <tt>LessThanComparable</tt> requirement</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.relops], 99 [fund.ts.v2::optional.comp_with_t] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-06-20 <b>Last modified:</b> 2016-11-20 18:11:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
Currently, <tt>std::experimental::optional::operator==</tt> imposes the <tt>EqualityComparable</tt> requirement which provides
two guarantees: It ensures that <tt>operator!=</tt> can rely on the equivalence-relation property and more importantly, that
the <tt>BooleanTestable</tt> requirements suggested by issue <a href="2114">2114</a> are automatically implied.
<p/>
<tt>std::experimental::optional::operator&lt;</tt> doesn't provide a <tt>LessThanComparable</tt> requirement, but there was quite
an historic set of changes involved with that family of types: As of 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3527.html">N3527</a>
this operator was defined in terms of <tt>operator&lt;</tt> of the contained type <tt>T</tt> and imposed the <tt>LessThanComparable</tt> 
requirement. In the final acceptance step of <tt>optional</tt> by the committee, the definition was expressed in terms of <tt>std::less</tt>
and the <tt>LessThanComparable</tt> requirement had been removed.
<p/>
The inconsistency between <tt>operator==</tt> and <tt>operator&lt;</tt> should be removed. One possible course of action would be 
to add the <tt>LessThanComparable</tt> to <tt>std::experimental::optional::operator&lt;</tt>. The <tt>EqualityComparable</tt> requirement
of <tt>operator==</tt> could also be removed, but in that case both operators would at least need to require the <tt>BooleanTestable</tt> 
requirements (see <a href="2114">2114</a>) for the result type of <tt>T</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>. 
<p/>
Arguably, corresponding operators for <tt>pair</tt> and <tt>tuple</tt> do not impose <tt>LessThanComparable</tt> (nor
<tt>EqualityComparable</tt>), albeit the definition of the "derived" relation functions depend on properties ensured by
<tt>LessThanComparable</tt>. According to the <a href="https://www.sgi.com/tech/stl/pair.html">SGI definition</a>, the intention was
to imposed both <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt>. If this is not intended, the standard should clarify
this position.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
VV, DK, JY discuss why and when <tt>LessThanComparable</tt> was removed. AM: Move to LEWG. Please tell LWG when you look at it. 
</p>

<p><i>[2016-11-08, Issaquah]</i></p>

<p>Not adopted during NB comment resolution</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2419" href="2419">2419.</a> Clang's libc++ extension to <tt>std::tuple</tt></h3>
<p><b>Section:</b> 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Akim Demaille <b>Opened:</b> 2014-07-11 <b>Last modified:</b> 2016-08-09 17:08:41 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The issue has been submitted after exchanges with the clang++ team
as a consequence of two PR I sent:
<p/>
<a href="http://llvm.org/bugs/show_bug.cgi?id=20174">Issue 20174</a>
<p/>
<a href="http://llvm.org/bugs/show_bug.cgi?id=20175">Issue 20175</a>
<p/>
The short version is shown in the program below:
</p>
<blockquote>
<pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct base
{
  void out(const std::tuple&lt;char, char&gt;&amp; w) const
  {
    std::cerr &lt;&lt; "Tuple: " &lt;&lt; std::get&lt;0&gt;(w) &lt;&lt; std::get&lt;1&gt;(w) &lt;&lt; '\n';
  }
};

struct decorator
{
  base b_;

  template &lt;typename... Args&gt;
  auto
  out(Args&amp;&amp;... args)
    -> decltype(b_.out(args...))
  {
    return b_.out(args...);
  }

  void out(const char&amp; w)
  {
    std::cerr &lt;&lt; "char: " &lt;&lt; w &lt;&lt; '\n';
  }
};

int main()
{
  decorator d{base{}};
  char l = 'a';
  d.out(l);
}
</pre>
</blockquote>
<p>
This is a stripped down version of a real world case where I
wrap objects in decorators.  These decorators contributes some
functions, and forward all the rest of the API to the wrapped
object using perfect forwarding.  There can be overloaded names.
<p/>
Here the inner object provides an
</p>
<blockquote><pre>
out(const std::tuple&lt;char, char&gt;&amp;) -&gt; void
</pre></blockquote>
<p>
function, and the wrappers, in addition to perfect forwarding,
provides
</p>
<blockquote><pre>
out(const char&amp;) -&gt; void
</pre></blockquote>
<p>
The main function then call <tt>out(l)</tt> where <tt>l</tt> is a <tt>char</tt> lvalue.
<p/>
With (GCC's) libstdc++ I get the expected result: the <tt>char</tt>
overload is run.  With (clang++'s) libc++ it is the tuple
version which is run.
</p>
<blockquote><pre>
$ g++-mp-4.9 -std=c++11 bar.cc &amp;&amp; ./a.out
char: a
$ clang++-mp-3.5 -std=c++11 bar.cc -Wall &amp;&amp; ./a.out
Tuple: a
</pre></blockquote>
<p>
It turns out that this is the result of an extension of <tt>std::tuple</tt>
in libc++ where they accept constructors with fewer values that
tuple elements.
<p/>
The purpose of this issue is to ask the standard to forbid
that this extension be allowed to participate in overload resolution.
</p>

<p><i>[2014-10-05, Daniel comments]</i></p>

<p>
This issue is closely related to LWG <a href="2312">2312</a>.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>
Moved to LEWG.
</p>
<p>
Extensions to <tt>tuple</tt>'s design are initially a question for LEWG.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2421" href="2421">2421.</a> Non-specification of handling zero size in <tt>std::align</tt> [ptr.align]</h3>
<p><b>Section:</b> 23.10.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.align">[ptr.align]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Melissa Mears <b>Opened:</b> 2014-08-06 <b>Last modified:</b> 2014-11-03 20:11:17 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.align">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ptr.align">[ptr.align]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>std::align</tt> does not appear to specify what happens when the value of the <tt>size</tt> 
parameter is 0. (The question of what happens when <tt>alignment</tt> is 0 is mentioned in another Defect Report, <a href="2377">2377</a>; 
it would change the behavior to be undefined rather than potentially implementation-defined.)
<p/>
The case of <tt>size</tt> being 0 is interesting because the result is ambiguous. Consider the following code's output:
</p>
<blockquote>
<pre>
#include &lt;cstdio&gt;
#include &lt;memory&gt;

int main()
{
  alignas(8) char buffer[8];
  void *ptr = &amp;buffer[1];
  std::size_t space = sizeof(buffer) - sizeof(char[1]);

  void *result = std::align(8, 0, ptr, space);

  std::printf("%d %td\n", !!result, result ? (static_cast&lt;char*&gt;(result) - buffer) : std::ptrdiff_t(-1));
}
</pre>
</blockquote>
<p>
There are four straightforward answers as to what the behavior of <tt>std::align</tt> with size 0 should be:
</p>
<ol>
<li><p>The behavior is undefined because the size is invalid.</p></li>
<li><p>The behavior is implementation-defined. This seems to be the status quo, with current implementations using #3.</p></li>
<li><p>Act the same as <tt>size == 1</tt>, except that if <tt>size == 1</tt> would fail but would be defined and succeed 
if space were exactly 1 larger, the result is a pointer to the byte past the end of the <tt>ptr</tt> buffer. That is, the 
"aligned" version of a 0-byte object can be one past the end of an allocation. Such pointers are, of course, valid when not 
dereferenced (and a "0-byte object" shouldn't be), but whether that is desired is not specified in the Standard's definition 
of <tt>std::align</tt>, it appears. The output of the code sample is "<tt>1 8</tt>" in this case.</p></li>
<li><p>Act the same as <tt>size == 1</tt>; this means that returning "one past the end" is not a possible result. In this case, 
the code sample's output is "<tt>0 -1</tt>".</p></li>
</ol>
<p>
The two compilers I could get working with <tt>std::align</tt>, Visual Studio 2013 and Clang 3.4, implement #3. (Change <tt>%td</tt> to 
<tt>%Id</tt> on Visual Studio 2013 and earlier. 2014 and later will have <tt>%td</tt>.)
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2423" href="2423">2423.</a> Missing specification <tt>slice_array</tt>, <tt>gslice_array</tt>, <tt>mask_array</tt>, <tt>indirect_array</tt> copy constructor</h3>
<p><b>Section:</b> 29.7.5 <a href="https://timsong-cpp.github.io/cppwp/template.slice.array">[template.slice.array]</a>, 29.7.7 <a href="https://timsong-cpp.github.io/cppwp/template.gslice.array">[template.gslice.array]</a>, 29.7.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a>, 29.7.9 <a href="https://timsong-cpp.github.io/cppwp/template.indirect.array">[template.indirect.array]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Akira Takahashi <b>Opened:</b> 2014-08-12 <b>Last modified:</b> 2014-11-03 20:11:17 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#template.slice.array">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/template.slice.array">[template.slice.array]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I found a missing specification of the copy constructor of the following class templates:
</p>
<ul>
<li><p><tt>slice_array</tt> (29.7.5 <a href="https://timsong-cpp.github.io/cppwp/template.slice.array">[template.slice.array]</a>)</p></li>
<li><p><tt>gslice_array</tt> (29.7.7 <a href="https://timsong-cpp.github.io/cppwp/template.gslice.array">[template.gslice.array]</a>)</p></li>
<li><p><tt>mask_array</tt> (29.7.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a>)</p></li>
<li><p><tt>indirect_array</tt> (29.7.9 <a href="https://timsong-cpp.github.io/cppwp/template.indirect.array">[template.indirect.array]</a>)</p></li>
</ul>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Before 29.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/slice.arr.assign">[slice.arr.assign]</a> insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>slice_array</tt> constructors [slice.arr.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>slice_array(const slice_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 29.7.7.2 <a href="https://timsong-cpp.github.io/cppwp/gslice.array.assign">[gslice.array.assign]</a> insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>gslice_array</tt> constructors [gslice.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>gslice_array(const gslice_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 29.7.8.2 <a href="https://timsong-cpp.github.io/cppwp/mask.array.assign">[mask.array.assign]</a> insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>mask_array</tt> constructors [mask.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>mask_array(const mask_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 29.7.9.2 <a href="https://timsong-cpp.github.io/cppwp/indirect.array.assign">[indirect.array.assign]</a> insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>indirect_array</tt> constructors [indirect.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>indirect_array(const indirect_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2430" href="2430">2430.</a> Heterogeneous container lookup should be enabled using meta-function instead of nested type</h3>
<p><b>Section:</b> 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2014-07-14 <b>Last modified:</b> 2014-11-04 10:11:55 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the heterogeneous lookup in associative container are
enabled by presence of <tt>is_transparent</tt> nested type in the comparator
type (26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>). This complicates the definition
of call wrapper types that want to define <tt>is_transparent</tt> if they wrap
a callable type that defines <tt>is_transparent</tt>, and requires the target
to be a complete type in cases where an incomplete type would otherwise be ok.
<p/>
Another problem is that users cannot add the <tt>is_transparent</tt> member to
a third-party comparison type that they do not control, even if they
know it supports heterogeneous comparisons.
<p/>
If the associative containers used a trait instead of checking for an
<tt>is_transparent</tt> member type then it would avoid the requirement for
complete types, and would allow customization of the trait without
modifying the comparator type. This would also be consistent with the
traits <tt>is_placeholder</tt> and <tt>is_bind_expression</tt>.
<p/>
For backward compatibility with the existing design, the default
implementation of the <tt>is_transparent</tt> trait could depend on the
presence of the <tt>is_transparent</tt> nested type.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Move to LEWG</p>
<p>
Request for a new metafunction should first be responded to by LEWG.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2431" href="2431">2431.</a> Missing regular expression traits requirements</h3>
<p><b>Section:</b> 31.3 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-09-30 <b>Last modified:</b> 2014-11-04 10:11:55 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on the traits class in 31.3 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> do not say whether a
regular expression traits class is required to be <tt>DefaultConstructible</tt>, 
<tt>CopyConstructible</tt>, <tt>CopyAssignable</tt> etc.
<p/>
The <tt>std::regex_traits</tt> class appears to be all of the above, but can
<tt>basic_regex</tt> assume that for user-defined traits classes?
<p/>
Should the following statements all leave <tt>u</tt> in equivalent states?
</p>
<blockquote><pre>
X u{v};
X u; u = v;
X u; u.imbue(v.getloc();
</pre></blockquote>
<p>
Whether they are equivalent has implications for <tt>basic_regex</tt> copy construction and 
assignment.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2432" href="2432">2432.</a> <tt>initializer_list</tt> assignability</h3>
<p><b>Section:</b> 21.9 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> <b>Status:</b> <a href="lwg-active.html#EWG">EWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2014-09-30 <b>Last modified:</b> 2015-05-22 19:05:39 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::initializer_list::operator=</tt> 21.9 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> is horribly broken and it needs deprecation:
</p>
<blockquote><pre>
std::initializer_list&lt;foo&gt; a = {{1}, {2}, {3}};
a = {{4}, {5}, {6}};
// New sequence is already destroyed.
</pre></blockquote>
<p>
Assignability of <tt>initializer_list</tt> isn't explicitly specified, but most implementations supply a default assignment 
operator. I'm not sure what 20.4 <a href="https://timsong-cpp.github.io/cppwp/description">[description]</a> says, but it probably doesn't matter.
</p>

<p><i>[Lenexa 2015-05-05: Send to EWG as discussed in Telecon]</i></p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Edit 21.9 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> p1, class template <tt>initializer_list</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class E&gt; class initializer_list {
  public:
    [&hellip;]
    constexpr initializer_list() noexcept;
  
    <ins>initializer_list(const initializer_list&amp;) = default;</ins>
    <ins>initializer_list(initializer_list&amp;&amp;) = default;</ins>
    <ins>initializer_list&amp; operator=(const initializer_list&amp;) = delete;</ins>
    <ins>initializer_list&amp; operator=(initializer_list&amp;&amp;) = delete;</ins>
    
    constexpr size_t size() const noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2444" href="2444">2444.</a> Inconsistent complexity for <tt>std::sort_heap</tt></h3>
<p><b>Section:</b> 28.7.7.4 <a href="https://timsong-cpp.github.io/cppwp/sort.heap">[sort.heap]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Fran&ccedil;ois Dumont <b>Opened:</b> 2014-10-07 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While creating complexity tests for the GNU libstdc++ implementation <a href="https://gcc.gnu.org/ml/libstdc++/2014-10/msg00048.html">I 
stumbled</a> across a surprising requirement for the <tt>std::sort_heap</tt> algorithm.
<p/>
In 28.7.7.4 <a href="https://timsong-cpp.github.io/cppwp/sort.heap">[sort.heap]</a> p3 the Standard states:
</p>
<blockquote><p>
<i>Complexity</i>: At most <tt><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>
<p>
As stated on the libstdc++ mailing list by Marc Glisse <tt>sort_heap</tt> can be implemented by <tt><i>N</i></tt> calls to 
<tt>pop_heap</tt>. As max number of comparisons of <tt>pop_heap</tt> is <tt>2 * log(<i>N</i>)</tt> then <tt>sort_heap</tt> 
max limit should be <tt>2 * log(1) + 2 * log(2) + .... + 2 * log(<i>N</i>)</tt> that is to say <tt>2 * log(<i>N</i>!)</tt>. 
In terms of <tt>log(<i>N</i>)</tt> we can also consider that this limit is also cap by <tt>2 * <i>N</i> * log(<i>N</i>)</tt> 
which is surely what the Standard wanted to set as a limit.
<p/>
This is why I would like to propose to replace paragraph 3 by:
</p>
<blockquote><p>
<i>Complexity</i>: At most <tt><ins>2</ins><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
Marshall will research the maths and report back in Lenexa.
</p>

<p><i>[2015-05-06 Lenexa]</i></p>

<p>STL: I dislike exact complexity requirements, they prevent one or two extra checks in debug mode. Would it be better to say O(N log(N)) not at most?</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Move to Tentatively Ready. STL may write a paper (with Thomas & Robert) offering guidance about Big-O notation vs. exact requirements.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol><li>
<p>
In 28.7.7.4 <a href="https://timsong-cpp.github.io/cppwp/sort.heap">[sort.heap]</a> p3 the Standard states:
</p>
<blockquote>
<pre>
template&lt;class RandomAccessIterator&gt;
  void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
template&lt;class RandomAccessIterator, class Compare&gt;
  void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
</pre>
<blockquote><p>
[&hellip;]
<p/>
-3- <i>Complexity</i>: At most <tt><ins>2</ins><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2446" href="2446">2446.</a> Unspecialized <tt>std::tuple_size</tt> should be defined</h3>
<p><b>Section:</b> 23.5.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2014-10-10 <b>Last modified:</b> 2014-11-04 10:11:55 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.general">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 23.5.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a> paragraph 2, the unspecialized <tt>std::tuple_size</tt> is undefined. It would 
be a lot more useful with SFINAE if it were defined as an empty struct; that way, it can be used with <tt>enable_if</tt> 
for determining whether or not it is valid to use <tt>tuple_size</tt>, <tt>tuple_element</tt> and get on the 
corresponding data structure.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Moved to LEWG 42.</p>
<p>
This request goes beyond simply making an API respond well to SFINAE, but coupling that with an
implication for other tuple APIs.  The proper place for such design discussions is LEWG.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol>
<li><p>Change 23.5.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a> p2, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated</p>
<blockquote>
<pre>
[&hellip;]
// <i>20.4.2.5, tuple helper classes</i>:
template &lt;class T&gt; class tuple_size; <del>// undefined</del>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 23.5.3.6 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a> as indicated</p>
<blockquote>
<pre>
[&hellip;]
template &lt;class T&gt; struct tuple_size <ins>{ }</ins>;
[&hellip;]
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2452" href="2452">2452.</a> <tt>is_constructible</tt>, etc. and default arguments</h3>
<p><b>Section:</b> 23.15 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#Core">Core</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2014-11-04 <b>Last modified:</b> 2015-10-21 05:10:23 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Core">Core</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>BaseCharacteristic</tt> for <tt>is_constructible</tt> is defined in terms of the well-formedness 
of a declaration for an invented variable. The well-formedness of the described declaration itself may 
change for the same set of arguments because of the introduction of default arguments.
<p/>
In the following program, there appears to be conflicting definitions of a specialization of 
<tt>std::is_constructible</tt>; however, it seems that this situation is caused without a user violation 
of the library requirements or the ODR. There is a similar issue with <tt>is_convertible</tt>, <tt>result_of</tt>
and others.
<p/>
a.cc:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
struct A { A(int, int); };
const std::false_type&amp; x1 = std::is_constructible&lt;A, int&gt;();

int main() { }
</pre></blockquote>
<p>
b.cc:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
struct A { A(int, int); };

inline A::A(int, int = 0) { }

const std::true_type&amp; x2 = std::is_constructible&lt;A, int&gt;();
</pre></blockquote>
<p>
Presumably this program should invoke undefined behaviour, but the Library specification doesn't
say that.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Core wording should say "this kind of thing is ill-formed, no diagnostic required"
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2453" href="2453">2453.</a> &sect;[iterator.range] and now [iterator.container] aren't available via <tt>&lt;initializer_list&gt;</tt></h3>
<p><b>Section:</b> 21.9 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>, 27.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>, 27.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.container">[iterator.container]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2016-02-01 11:02:56 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
These sections define helper functions, some of which apply to <tt>initializer_list&lt;T&gt;</tt>. And they're 
available if you include one of a long list of header files, many of which include <tt>&lt;initializer_list&gt;</tt>. 
But they are not available if you include <tt>&lt;initializer_list&gt;</tt>. This seems very odd.
</p>
<blockquote><pre>
#include &lt;initializer_list&gt;
auto x = {1, 2, 3};
const int *p = data(x); // error, undeclared
#include &lt;vector&gt;
const int *q = data(x); // ok
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2457" href="2457">2457.</a> <tt>std::begin()</tt> and <tt>std::end()</tt> do not support multi-dimensional arrays correctly</h3>
<p><b>Section:</b> 27.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Janez &#x17d;emva <b>Opened:</b> 2014-11-16 <b>Last modified:</b> 2015-02-23 23:02:50 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

int main() 
{
  int a[2][3][4] = { { { 1,  2,  3,  4}, { 5,  6,  7,  8}, { 9, 10, 11, 12} },
                     { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } };
  int b[2][3][4];

  assert(std::distance(std::begin(a), std::end(a)) == 2 * 3 * 4);
  std::copy(std::begin(a), std::end(a), std::begin(b));
  std::copy(std::begin(b), std::end(b), std::ostream_iterator&lt;int&gt;(std::cout, ","));
}
</pre></blockquote>
<p>
does not compile. 
<p/>
A possible way to remedy this would be to add the following overloads of
<tt>begin</tt>, <tt>end</tt>, <tt>rbegin</tt>, and <tt>rend</tt> to 27.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>, 
relying on recursive evaluation:
</p>
<blockquote><pre>
namespace std {

  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  begin(T (&amp;array)[M][N])
  {
    return begin(*array);
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  end(T (&amp;array)[M][N])
  {
    return end(array[M - 1]);
  }

  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rbegin(T (&amp;array)[M][N])
  {
    return decltype(rbegin(array))(end(array[M - 1]));
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rend(T (&amp;array)[M][N])
  {
    return decltype(rend(array))(begin(*array));
  }

}
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2461" href="2461">2461.</a> Interaction between allocators and container exception safety guarantees</h3>
<p><b>Section:</b> 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, 26.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>, 26.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> dyp <b>Opened:</b> 2014-12-06 <b>Last modified:</b> 2015-06-10 17:06:20 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When resizing a <tt>vector</tt>, the accessibility and exception specification of the value type's 
constructors determines whether the elements are copied or moved to the new buffer.
However, the copy/move is performed via the allocator's <tt>construct</tt> member function, which is 
assumed, but not required, to call the copy/move constructor and propagate only exceptions 
from the value type's copy/move constructor. The issue might also affect other classes. 
<p/>
The current wording in N4296 relevant here is from Table 28 &mdash; "Allocator requirements" in 
20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>: 
</p>
<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.construct(c, args)</tt>
</td>
<td>
(not used)
</td>
<td>
<i>Effect</i>: Constructs an object of type <tt>C</tt> at <tt>c</tt>
</td>
<td>
<tt>::new ((void*)c) C(forward&lt;Args&gt;(args)...)</tt>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
<p>
and from 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> p9:
</p>
<blockquote><p>
An allocator may constrain the types on which it can be instantiated and the arguments for which its
<tt>construct</tt> member may be called. If a type cannot be used with a particular allocator, the allocator class
or the call to <tt>construct</tt> may fail to instantiate.
</p></blockquote>
<p>
I conclude the following from the wording:
</p>
<ol>
<li><p>The allocator is not required to call the copy constructor if the
arguments (args) is a single (potentially const) lvalue of the value
type. Similarly for a non-const rvalue + move constructor. See also
26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p15 which seems to try to require
this, but is not sufficient:
That paragraph specifies the semantics of the allocator's operations,
but not which constructors of the value type are used, if any.
</p></li>
<li>
<p>The allocator may throw exceptions in addition to the exceptions propagated by
the constructors of the value type; it can also propagate exceptions from constructors
other than a copy/move constructor.
</p>
</li>
</ol>
<p>
This leads to an issue with the wording of the exception safety guarantees for vector modifiers in
26.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> p1:
</p>
<blockquote>
<p>
[&hellip;]
</p>
<pre>
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</pre>
<blockquote>
<p>
<i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. If no 
reallocation happens, all the iterators and references before the insertion point remain valid. 
If an exception is thrown other than by the copy constructor, move constructor, assignment 
operator, or move assignment operator of <tt>T</tt> or by any InputIterator operation there are 
no effects.
<span  style="color:#C80000;font-weight:bold">
If an exception is thrown while inserting a single element at the end and <tt>T</tt> 
is <tt>CopyInsertable</tt> or <tt>is_nothrow_move_constructible&lt;T&gt;::value</tt>
is true, there are no effects. Otherwise, if an exception is thrown by the move constructor of a
non-<tt>CopyInsertable</tt> <tt>T</tt>, the effects are unspecified.
</span>
</p>
</blockquote>
</blockquote>
<p>
The wording leads to the following problem:
Copy and move assignment are invoked directly from <tt>vector</tt>.
For intermediary objects (see <a href="2164">2164</a>),
<tt>vector</tt> also directly invokes the copy and move constructor of the value type.
However, construction of the actual element within the buffer is invoked via the allocator abstraction.
As discussed above, the allocator currently is not required to call a copy/move constructor.
If <tt>is_nothrow_move_constructible&lt;T&gt;::value</tt> is <tt>true</tt> for some value type <tt>T</tt>,
but the allocator uses modifying operations for <tt>MoveInsertion</tt> that do throw,
the implementation is required to ensure that "there are no effects",
even if the source buffer has been modified.
<p/>
Similarly, the <tt>vector</tt> capacity functions specify exception safety guarantees
referring to the move constructor of the value type. For example, <tt>vector::resize</tt> in 26.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> p14:
</p>
<blockquote>
<i>Remarks</i>: If an exception is thrown other than by the move constructor of a
non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.
</blockquote>
<p>
The wording leads to the same issue as described above.
<p/>
Code example:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
class allocator;

class pot_reg_type // a type which creates
                   // potentially registered instances
{
private:
  friend class allocator&lt;pot_reg_type&gt;;
  struct register_t {};

  static std::set&lt;pot_reg_type*&gt;&amp; get_registry()
  {
    static std::set&lt;pot_reg_type*&gt; registry;
    return registry;
  }
  void enregister() noexcept(false)
  {
    get_registry().insert(this);
  }
  void deregister()
  {
    get_registry().erase(this);
  }

public:
  pot_reg_type(void               ) noexcept(true) {}
  pot_reg_type(pot_reg_type const&amp;) noexcept(true) {}
  pot_reg_type(pot_reg_type&amp;&amp;     ) noexcept(true) {}

private:
  pot_reg_type(register_t                     ) noexcept(false)
  { enregister(); }
  pot_reg_type(register_t, pot_reg_type const&amp;) noexcept(false)
  { enregister(); }
  pot_reg_type(register_t, pot_reg_type&amp;&amp;     ) noexcept(false)
  { enregister(); }
};

template&lt;class T&gt;
class allocator
{
public:
  using value_type = T;

  value_type* allocate(std::size_t p)
  { return (value_type*) ::operator new(p); }

  void deallocate(value_type* p, std::size_t)
  { ::operator delete(p); }

  void construct(pot_reg_type* pos)
  {
    new((void*)pos) pot_reg_type((pot_reg_type::register_t()));
  }
  void construct(pot_reg_type* pos, pot_reg_type const&amp; source)
  {
    new((void*)pos) pot_reg_type(pot_reg_type::register_t(), source);
  }

  template&lt;class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args)
  {
    new((void*)p) T(std::forward&lt;Args&gt;(args)...);
  }
}; 
</pre>
</blockquote>
<p>
The <tt>construct</tt> member function template is only required for rebinding,
which can be required e.g. to store additional debug information in
the allocated memory (e.g. VS2013).
<p/>
Even though the value type has an accessible and <tt>noexcept(true)</tt> move
constructor, this allocator won't call that constructor for rvalue arguments.
In any case, it does not call a constructor for which vector has formulated its 
requirements. An exception thrown by a constructor called by this allocator is not
covered by the specification in 26.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> and therefore is
guaranteed not to have any effect on the vector object when resizing.
<p/>
For an example how this might invalidate the exception safety
guarantees, see <a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/BcM7ya8JeqY/discussion">this post on the std-discussion mailing list</a>.
<p/>
Another problem arises for value types whose constructors are private,
but may be called by the allocator e.g. via friendship.
Those value types are not <tt>MoveConstructible</tt> 
(<tt>is_move_constructible</tt> is false), yet they can be <tt>MoveInsertable</tt>.
It is not possible for <tt>vector</tt> to create intermediary objects (see <a href="2164">2164</a>) of such a type
by directly using the move constructor.
Current implementations of the single-element forms of <tt>vector::insert</tt> and <tt>vector::emplace</tt>
do create intermediary objects by directly calling one of the value type's constructors,
probably to allow inserting objects from references that alias other elements of the container.
As far as I can see, Table 100 &mdash; "Sequence container requirements" in 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>
does not require that the creation of such intermediare objects can be performed
by containers using the value type's constructor directly.
It is unclear to me if the allocator's construct function could be used to create those
intermediary objects, given that they have not been allocated by the allocator.
<p/>
Two possible solutions:
</p>
<ol>
<li><p>
Add the following requirement to the <tt>allocator_traits::construct</tt> function:
If the parameter pack <tt>args</tt> consists of a single parameter of the type
<tt>value_type&amp;&amp;</tt>,
the function may only propagate exceptions if <tt>is_nothrow_move_constructible&lt;value_type&gt;::value</tt>
is <tt>false</tt>.
<p/>
Requiring <tt>alloctor_traits::construct</tt> to call a true copy/move constructor
of the value type breaks <tt>std::scoped_allocator_adapter</tt>,
as pointed out by <a href="https://groups.google.com/a/isocpp.org/d/msg/std-discussion/0yxikZInp-E/Lxj-msFT22cJ">Casey Carter in a post on the std-discussion mailing list</a>.
</p></li>
<li>
<p>
Change vector's criterion whether to move or copy when resizing:
<p/>
Instead of testing the value type's constructors via
<tt>is_move_constructible</tt>, check the value of
<tt>noexcept( allocator_traits&lt;Allocator&gt;::construct(alloc, ptr, rval) )</tt>
where
<tt>alloc</tt> is an lvalue of type <tt>Allocator</tt>,
<tt>ptr</tt> is an expression of type <tt>allocator_traits&lt;Allocator&gt;::pointer</tt>
and
<tt>rval</tt> is a non-const rvalue of type <tt>value_type</tt>.
</p>
</li>
</ol>
<p>
A short discussion of the two solutions:
<p/>
Solution 1 allows keeping <tt>is_nothrow_move_constructible&lt;value_type&gt;</tt>
as the criterion for <tt>vector</tt> to decide between copying and moving when resizing.
It restricts what can be done inside the <tt>construct</tt> member function of allocators,
and requires implementers of allocators to pay attention to the value types used.
One could conceive allocators checking the following with a <tt>static_assert</tt>:
If the value type <tt>is_nothrow_move_constructible</tt>,
then the constructor actually called for <tt>MoveInsertion</tt> within the <tt>construct</tt>
member function is also declared as noexcept.
<p/>
Solution 2 requires changing both the implementation of the default
allocator (add a conditional <tt>noexcept</tt>) and <tt>vector</tt> (replace
<tt>is_move_constructible</tt> with an allocator-targeted check).
It does not impose additional restrictions on the allocator (other than
26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p15),
and works nicely even if the move constructor of a <tt>MoveInsertable</tt> type is private or deleted
(the allocator might be a friend of the value type).
<p/>
In both cases, an addition might be required to provide the basic exception safety guarantee.
A short discussion on this topic can be found
<a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/yZLnYy_y2z0/discussion">
in the std-discussion mailing list</a>.
Essentially, if <tt>allocator_traits&lt;Allocator&gt;::construct</tt> throws an exception,
the object may or may not have been constructed.
Two solutions are mentioned in that discussion:
</p>
<ol>
<li><p>
<tt>allocator_traits&lt;Allocator&gt;::construct</tt> needs to tell its caller
whether or not the construction was successful, in case of an exception.
</p></li>
<li><p>
If <tt>allocator_traits&lt;Allocator&gt;::construct</tt> propagates an exception,
it shall either not have constructed an object at the specified location,
or that object shall have been destroyed
(or it shall ensure otherwise that no resources are leaked).
</p></li>
</ol>

<p><i>[2015-05-23, Tomasz Kami&nacute;ski comments]</i></p>

<p>
Solution 1 discussed in this issue also breaks support for the <tt>polymorphic_allocator</tt> proposed in the part 
of the Library Fundamentals TS v1, in addition to already mentioned <tt>std::scoped_allocator_adapter</tt>. Furthermore 
there is unknown impact on the other user-defined state-full allocators code written in the C++11.
<p/>
In addition the library resolution proposed in the LWG issues <a href="2089">2089</a> and 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html">N4462</a>, 
will break the relation between the <tt>std::allocator_trait::construct</tt> method and 
copy/move constructor even for the standard <tt>std::allocator</tt>. As example please consider following class:
</p>
<blockquote><pre>
struct NonCopyable
{
  NonCopyable() = default;
  NonCopyable(NonCopyable const&amp;) = delete;
  NonCopyable(NonCopyable&amp;&amp;) = delete;
};

struct InitListConstructor : NonCopyable
{
  InitListConstructor() = default;
  InitListConstructor(std::initializer_list&lt;int&gt;);
  operator int() const;
};
</pre></blockquote>
<p>
For the above declarations following expression are ill-formed:
</p>
<blockquote><pre>
InitListConstructor copy(std::declval&lt;InitListConstructor const&amp;&gt;());
InitListConstructor move(std::declval&lt;InitListConstructor&amp;&amp;&gt;());
</pre></blockquote>
<p>
So the class is not <tt>CopyConstructible</tt> nor <tt>MoveConstructible</tt>. However the following are well formed:
</p>
<blockquote><pre>
InitListConstructor copy{std::declval&lt;InitListConstructor const&amp;&gt;()};
InitListConstructor move{std::declval&lt;InitListConstructor&amp;&amp;&gt;()};
</pre></blockquote>
<p>
And will be used by <tt>std::allocator&lt;InitListConstructor&gt;::construct</tt> in case of move-insertion 
and copy-insertion, after appliance of the resolution proposed in mentioned papers:
</p>
<blockquote>
<p>
The gist of the proposed library fix is simple:
</p>
<ul>
<li><p>if <tt>is_constructible_v&lt;TargetType, Args...&gt;</tt>, use direct-nonlist-initialization</p></li>
<li><p>otherwise, use brace-initialization.</p></li>
</ul>
</blockquote>
<p>
As consequence the requirement proposed in the Solution 1:
</p>
<blockquote><p>
If the parameter pack <tt>args</tt> consists of a single parameter of the type <tt>value_type&amp;&amp;</tt>, 
the function may only propagate exceptions if <tt>is_nothrow_move_constructible&lt;value_type&gt;::value</tt> is false. 
</p></blockquote>
<p>
Will no longer hold for the <tt>std::allocator</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2471" href="2471">2471.</a> <tt>copy_n</tt>'s number of <tt>InputIterator</tt> increments unspecified</h3>
<p><b>Section:</b> 28.6.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-01-28 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It's unspecified how many times <tt>copy_n</tt> increments the <tt>InputIterator</tt>.
<tt>uninitialized_copy_n</tt> is specified to increment it exactly <tt>n</tt> times,
which means if an <tt>istream_iterator</tt> is used then the next character
after those copied is read from the stream and then discarded, losing data.
<p/>
I believe all three of Dinkumware, libc++ and libstdc++ implement
<tt>copy_n</tt> with <tt>n - 1</tt> increments of the <tt>InputIterator</tt>, which avoids reading
and discarding a character when used with <tt>istream_iterator</tt>, but is
inconsistent with <tt>uninitialized_copy_n</tt> and causes surprising behaviour
with <tt>istreambuf_iterator</tt> instead, because <tt>copy_n(in, 2, copy_n(in, 2,
out))</tt> is not equivalent to <tt>copy_n(in, 4, out)</tt>
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: refer to LEWG</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2472" href="2472">2472.</a> Heterogeneous comparisons in the standard library can result in ambiguities</h3>
<p><b>Section:</b> 23.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, 23.10.9.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.globals">[allocator.globals]</a>, 23.11.1.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a>, 23.11.2.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cmp">[util.smartptr.shared.cmp]</a>, 23.17.5.6 <a href="https://timsong-cpp.github.io/cppwp/time.duration.comparisons">[time.duration.comparisons]</a>, 23.17.6.6 <a href="https://timsong-cpp.github.io/cppwp/time.point.comparisons">[time.point.comparisons]</a>, 23.13.5 <a href="https://timsong-cpp.github.io/cppwp/scoped.adaptor.operators">[scoped.adaptor.operators]</a>, 27.5.1.3.13 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.op==">[reverse.iter.op==]</a>, 27.5.3.3.13 <a href="https://timsong-cpp.github.io/cppwp/move.iter.op.comp">[move.iter.op.comp]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-02-07 <b>Last modified:</b> 2015-05-05 12:05:28 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library specifies a lot of heterogeneous comparison operators. For instance:
</p>
<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
</pre>
</blockquote>
<p>
This has an unfortunate consequence:
</p>
<blockquote>
<pre>
#include &lt;tuple&gt;
#include &lt;utility&gt;

using namespace std::rel_ops;
std::tuple&lt;int&gt; a(0);
bool b = a != a;
</pre>
</blockquote>
<p>
The last line here is ill-formed due to ambiguity: it might be <tt>rel_ops::operator!=</tt>, and it might be the 
heterogeneous tuple <tt>operator!=</tt>. These are not partially ordered, because they have different constraints: 
<tt>rel_ops</tt> requires the types to match, whereas the tuple comparison requires both types to be tuples (but not 
to match). The same thing happens for user code that defines its own unconstrained 
'<tt>template&lt;typename T&gt; operator!=(const T&amp;, const T&amp;)</tt>' rather than using <tt>rel_ops</tt>.
<p/>
One straightforward fix would be to add a homogeneous overload for each heterogeneous comparison:
</p>
<blockquote>
<pre>
template&lt;class... TTypes&gt;
constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;TTypes...&gt;&amp;);
</pre>
<p>
This is then unambiguously chosen over the other options in the preceding case. FWIW, libstdc++ already does this 
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.4/libstdc++/api/a01065_source.html#l00788">in some cases</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2478" href="2478">2478.</a> Unclear how <tt>wstring_convert</tt> uses <tt>cvtstate</tt></h3>
<p><b>Section:</b> 99 [conversions.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2015-05-05 12:05:28 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
How do <tt>wstring_convert::from_bytes</tt> and <tt>wstring_convert::to_bytes</tt> use
the <tt>cvtstate</tt> member?
<p/>
Is it passed to the <tt>codecvt</tt> member functions? Is a copy of it passed
to the member functions? "Otherwise it shall be left unchanged"
implies a copy is used, but if that's really what's intended there are
simpler ways to say so.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2479" href="2479">2479.</a> Unclear how <tt>wbuffer_convert</tt> uses <tt>cvtstate</tt></h3>
<p><b>Section:</b> 99 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2015-05-05 12:05:28 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.buffer">active issues</a> in [conversions.buffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.buffer">issues</a> in [conversions.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
How does <tt>wbuffer_convert</tt> use the <tt>cvtstate</tt> member?
<p/>
Is the same conversion state object used for converting both the get
and put areas? That means a read which runs out of bytes halfway 
through a multibyte character will leave some shift state in cvtstate, 
which would then be used by a following write, even though the shift 
state of the get area is unrelated to the put area.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2480" href="2480">2480.</a> Error handling of <tt>wbuffer_convert</tt> unclear</h3>
<p><b>Section:</b> 99 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2015-05-05 12:05:28 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.buffer">active issues</a> in [conversions.buffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.buffer">issues</a> in [conversions.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If a <tt>codecvt</tt> conversion returns <tt>codecvt_base::error</tt> should that be
treated as <tt>EOF</tt>? An exception? Should all the successfully converted
characters before a conversion error be available to the users of the
<tt>wbuffer_convert</tt> and/or the internal <tt>streambuf</tt>, or does a conversion
error lose information?
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2481" href="2481">2481.</a> <tt>wstring_convert</tt> should be more precise regarding "byte-error string" etc.</h3>
<p><b>Section:</b> 99 [conversions.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2015-05-05 12:05:28 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 4 of 99 [conversions.string] introduces <tt>byte_err_string</tt> 
as "a byte string to display on errors". What does display mean? The string is returned 
on error, it's not displayed anywhere.
<p/>
Paragraph 14 says "Otherwise, if the object was constructed with a
byte-error string, the member function shall return the byte-error
string." The term byte-error string is not used anywhere else.
<p/>
Paragraph 17 talks about storing "default values in <tt>byte_err_string</tt>".
What default value? Is "Hello, world!" allowed? If it means
default-construction it should say so. If paragraph 14 says it won't
be used what does it matter how it's initialized? The end of the
paragraph refers to storing "<tt>byte_err</tt> in <tt>byte_err_string</tt>". This should
be more clearly related to the wording in paragraph 14.
<p/>
It might help if the constructor (and destructor) was specified before
the other member functions, so it can more formally define the
difference between being "constructed with a byte-error string" and
not.
<p/>
All the same issues apply to the <tt>wide_err_string</tt> member.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2490" href="2490">2490.</a> <tt>&lt;regex&gt;</tt> needs lots of <tt>noexcept</tt></h3>
<p><b>Section:</b> 31 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2015-03-27 <b>Last modified:</b> 2015-05-05 12:05:28 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#re">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Only 4 functions are marked <tt>noexcept</tt> in all of Clause 28. Many more need to be marked &mdash; for example, 
<tt>regex_error::code()</tt>, <tt>basic_regex::swap()</tt>, and <tt>sub_match::length()</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2491" href="2491">2491.</a> <tt>std::less&lt;T*&gt;</tt> in constant expression</h3>
<p><b>Section:</b> 23.14.7 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-04-01 <b>Last modified:</b> 2017-01-23 18:01:23 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not entirely clear if and when the specializations of <tt>std::less</tt> (and friends) for pointer types 
can be used in a constant expression. Consider the following code:
</p>
<blockquote><pre>
#include &lt;functional&gt;

struct foo {};
foo x, y;
constexpr bool b = std::less&lt;foo*&gt;{}(&amp;x, &amp;y); // [1]

foo z[] = {{}, {}};
constexpr bool ba = std::less&lt;foo*&gt;{}(&amp;z[0], &amp;z[1]); // [2]
</pre></blockquote>
<p>
Comparing the address of unrelated objects is not a constant expression since the result is unspecified, so 
it could be expected for [1] to fail and [2] to succeed. However, <tt>std::less</tt> specialization for pointer 
types is well-defined and yields a total order, so it could just as well be expected for [1] to succeed. Finally, 
since the implementation of such specializations is not mandated, [2] could fail as well (This could happen, if
an implementation would provide such a specialization and if that would use built-in functions that would not be
allowed in constant expressions, for example). In any case, the standard should be clear so as to avoid 
implementation-defined <tt>constexpr</tt>-ness.
</p>

<p><i>[2017-01-22, Jens provides rationale and proposed wording]</i></p>

<p>
<tt>std::less&lt;T*&gt;</tt> is required to deliver a total order on pointers.
However, the layout of global objects is typically determined
by the linker, not the compiler, so requiring <tt>std::less&lt;T*&gt;</tt> to
provide an ordering at compile-time that is consistent with
run-time would need results from linking to feed back to
the compiler, something that C++ has traditionally not required.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Add at the end of 23.14.7 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>:</p>
<blockquote>
<p>
-2- For templates <tt>less</tt>, <tt>greater</tt>, <tt>less_equal</tt>, and <tt>greater_equal</tt>, [&hellip;], 
if the call operator calls a built-in operator comparing pointers, the call operator yields a strict total order 
that is consistent among those specializations and is also consistent with the partial order imposed by those 
built-in operators. <ins>Relational comparisons of pointer values are not required to be usable as constant expressions.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2493" href="2493">2493.</a> <tt>initializer_list</tt> supports incomplete classes</h3>
<p><b>Section:</b> 21.9 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-04-27 <b>Last modified:</b> 2015-05-05 12:05:28 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The typical use-case of <tt>std::initializer_list&lt;T&gt;</tt> is for a pass-by-value parameter of <tt>T</tt>'s constructor. 
However, this contravenes 20.5.4.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a>/2.5 because <tt>initializer_list</tt> doesn't specifically allow 
incomplete types (as do for example <tt>std::unique_ptr</tt> (23.11.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr">[unique.ptr]</a>/5) and 
<tt>std::enable_shared_from_this</tt> (23.11.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a>/2)).
<p/>
A resolution would be to copy-paste the relevant text from such a paragraph.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2496" href="2496">2496.</a> Certain hard-to-avoid errors not in the immediate context are not allowed to be triggered by 
the evaluation of type traits</h3>
<p><b>Section:</b> 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-07 <b>Last modified:</b> 2015-08-03 14:08:06 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I do not believe that the wording in 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> paragraph 3 allows for the following program to be ill-formed:
</p>
<blockquote>
<pre>
#include &lt;type_traits&gt;

template &lt;typename T&gt; struct B : T { };
template &lt;typename T&gt; struct A { A&amp; operator=(const B&lt;T&gt;&amp;); };

std::is_assignable&lt;A&lt;int&gt;, int&gt; q;
</pre>
</blockquote>
<p>
In particular, I do not see where the wording allows for the "compilation of the expression" 
<tt>declval&lt;T&gt;() = declval&lt;U&gt;()</tt> to occur as a consequence of instantiating <tt>std::is_assignable&lt;T, U&gt;</tt> 
(where <tt>T</tt> and <tt>U</tt> are, respectively, <tt>A&lt;int&gt;</tt> and <tt>int</tt> in the example code).
<p/>
Instantiating <tt>A&lt;int&gt;</tt> as a result of requiring it to be a complete type does not trigger the instantiation of 
<tt>B&lt;int&gt;</tt>; however, the "compilation of the expression" in question does.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2497" href="2497">2497.</a> Use of <tt>uncaught_exception()</tt></h3>
<p><b>Section:</b> 30.7.5.1.3 <a href="https://timsong-cpp.github.io/cppwp/ostream::sentry">[ostream::sentry]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Roger Orr <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream::sentry">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ostream::sentry">[ostream::sentry]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current 30.7.5.1.3 <a href="https://timsong-cpp.github.io/cppwp/ostream::sentry">[ostream::sentry]</a>, p4 refers to the now deprecated <tt>std::uncaught_exception()</tt>: 
D.9 [depr.uncaught].
</p>
<blockquote>
<p>
If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception() &amp;&amp; os.good())</tt> is true, calls
<tt>os.rdbuf()->pubsync()</tt>.
</p>
</blockquote>
<p>
This needs to be changed, for example to use <tt>std::uncaught_exceptions()</tt> and to capture the value on entry and 
compare with the saved value on exit.
</p>

<p><i>[2015-06, Telecon]</i></p>

<p>
JW: I already added an 's' here to make it use the new function, but that doesn't resolve Roger's suggestion to capture the value on entry and check it.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2498" href="2498">2498.</a> <tt>operator&gt;&gt;(basic_istream&amp;&amp;, T&amp;&amp;)</tt> returns <tt>basic_istream&amp;</tt>, but should probably return 
<tt>basic_istream&amp;&amp;</tt></h3>
<p><b>Section:</b> 30.7.4.5 <a href="https://timsong-cpp.github.io/cppwp/istream.rvalue">[istream.rvalue]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.rvalue">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/istream.rvalue">[istream.rvalue]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote>
<pre>
auto&amp; is = make_istream() &gt;&gt; x; // oops, istream object is already gone
</pre>
</blockquote>
<p>
With a <tt>basic_istream&amp;&amp;</tt> return type, the above would be ill-formed, and generally we'd 
preserve the value category properly.
</p>

<p><i>[2015-06, Telecon]</i></p>

<p>
JW: think this needs proper consideration, it would make <pre>stream() &gt;&gt; x &gt;&gt; y &gt;&gt; z</pre> go from 3 operator&gt;&gt; calls to 6 operator&gt;&gt; calls, and wouldn't prevent dangling references (change the example to auto&amp;&amp;) <br/>
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2499" href="2499">2499.</a> <tt>operator&gt;&gt;(basic_istream&amp;, CharT*)</tt> makes it hard to avoid buffer overflows</h3>
<p><b>Section:</b> 30.7.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/istream.extractors">[istream.extractors]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We removed <tt>gets()</tt> (due to an NB comment and C11 &mdash; bastion of backwards compatibility &mdash; doing the same). 
Should we remove this too?
<p/>
Unlike <tt>gets()</tt>, there are legitimate uses:
</p>
<blockquote>
<pre>
char buffer[32];
char text[32] = // ...
ostream_for_buffer(text) &gt;&gt; buffer; // ok, can't overrun buffer
</pre>
</blockquote>
<p>
&hellip; but the risk from constructs like "<tt>std::cin &gt;&gt; buffer</tt>" seems to outweigh the benefit.
<p/>
The issue had been discussed on the library reflector starting around 
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=35541">c++std-lib-35541</a>.
</p>

<p><i>[2015-06, Telecon]</i></p>

<p>VV: Request a paper to deprecate / remove anything<br/></p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: This overload is evil and should probably die. </p>
<p>VV: I agree with that, even though I don't care.</p>
<p>STL: Say that we either remove it outright following the gets() rationale, or at least deprecate it.</p>
<p>Move to Open; needs a paper.</p>

<p><i>[2016-08, Chicago: Zhihao Yuan comments and provides wording]</i></p>

<p>
Rationale:
</p>
<ol>
<li><p>I would like to keep some reasonable code working;</p></li>
<li><p>Reasonable code includes two cases:</p>
<ol style="list-style-type:lower-alpha">
<li><p><tt>width() &gt; 0</tt>, any pointer argument</p></li>
<li><p><tt>width() &gt;= 0</tt>, array argument</p></li>
</ol>
</li>
<li><p>For a), banning bad code will become a silent behavior change at runtime; 
for b), it breaks at compile time.</p></li>
</ol>
<p>
I propose to replace these signatures with references to arrays.
An implementation may want to ship the old instantiatations in the
binary without exposing the old signatures.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Tues PM: General agreement on deprecating the unsafe call, but no consensus for the P/R.</p>
<p>General feeling that implementation experience would be useful.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 30.7.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/istream.extractors">[istream.extractors]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;charT, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; in,
                                           <del>charT* s</del><ins>charT (&amp;s)[N]</ins>);
template&lt;class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;char, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char, traits&gt;&amp; in,
                                          <del>unsigned char* s</del><ins>unsigned char (&amp;s)[N]</ins>);
template&lt;class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;char, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char, traits&gt;&amp; in,
                                          <del>signed char* s</del><ins>signed char (&amp;s)[N]</ins>);
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Behaves like a formatted input member (as described in 30.7.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted.reqmts">[istream.formatted.reqmts]</a>) 
of <tt>in</tt>. After a <tt>sentry</tt> object is constructed, <tt>operator&gt;&gt;</tt> extracts characters and 
stores them into <del>successive locations of an array whose first element is designated by</del> <tt>s</tt>. If <tt>width()</tt> 
is greater than zero, <tt>n</tt> is <tt><del>width()</del><ins>min(size_t(width()), N)</ins></tt>. Otherwise 
<tt>n</tt> is <del>the number of elements of the largest 
array of <tt>char_type</tt> that can store a terminating <tt>charT()</tt></del><ins><tt>N</tt></ins>. <tt>n</tt> is the 
maximum number of characters stored.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2504" href="2504">2504.</a> <tt>basic_streambuf</tt> is not an abstract class</h3>
<p><b>Section:</b> 30.6.3 <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-05-28 <b>Last modified:</b> 2015-08-03 14:08:06 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#streambuf">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#streambuf">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.6.3 <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a> p1 says:
</p>
<blockquote><p>
The class template <tt>basic_streambuf&lt;charT, traits&gt;</tt> serves as an abstract base class for deriving various
stream buffers whose objects each control two character sequences: [&hellip;]
</p></blockquote>
<p>
The term "abstract base class" is not defined in the standard, but "abstract class" is (13.4 <a href="https://timsong-cpp.github.io/cppwp/class.abstract">[class.abstract]</a>).
<p/>
According to the synopsis <tt>basic_streambuf</tt> has no pure virtual
functions so is not an abstract class and none of libstdc++, libc++, or
dinkumware implement it as an abstract class. I don't believe the wording was
ever intended to require it to be an abstract class, but it could be
read that way.
<p/>
I suggest the wording be changed to "polymorphic base class" or
something else that can't be seen to imply a normative requirement to
make it an abstract class.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2506" href="2506">2506.</a> Underspecification of atomics</h3>
<p><b>Section:</b> 4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>, 32.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a>, 21.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2015-05-29 <b>Last modified:</b> 2015-09-23 18:09:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#intro.multithread">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The concurrency libraries specified in clauses 29 and 30 do not adequately specify how they relate to the concurrency model 
specified in 4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>. In particular:
<p/>
4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a> specifies "atomic objects" as having certain properties. I can only assume that instances 
of the classes defined in Clause 29 are intended to be "atomic objects" in this sense, but I can't find any wording to 
specify that, and it's genuinely unclear whether Clause 30 objects are atomic objects. In fact, on a literal reading the 
C++ Standard doesn't appear to provide <em>any</em> portable way to create an atomic object, or even determine whether an 
object is an atomic object.
<p/>
(It's not clear if the term "atomic object" is actually needed, given that atomic objects can have non-atomic operations, 
and non-atomic objects can have atomic operations. But even if the term itself goes away, there still needs to be some 
indication that Clause 29 objects have the properties currently attributed to atomic objects).
<p/>
Similarly, 4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a> uses "atomic operation" as a term of art, but the standard never unambiguously 
identifies any operation as an "atomic operation" (although in one case it unambiguously identifies an operation that is 
<em>not</em> atomic). It does come close in a few cases, but not close enough:
</p>
<ul>
<li><p>4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>/p7 could be read to imply that "synchronization operations" in Clauses 29 and 30 
are also atomic operations. However, that's vague and indirect, and somewhat belied by 33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>/p5, 
which specifies that mutex lock and unlock operations "behave as atomic operations", but only "for purposes of determining 
the existence of a data race". Furthermore, not a single operation in Clause 29 explicitly identifies itself as a 
"synchronization operation".</p></li>
<li><p>32.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a>/p4 states in part that "There shall be a specialization <tt>atomic&lt;bool&gt;</tt> 
which provides the general atomic operations as specified in 29.6.1", but read in context, "general atomic operations" 
appears to be a loose synonym for "general operations on atomic types" as defined in  [atomics.types.operations.general], 
rather than a use of "atomic object" as Words of Power. Incidentally, "atomic type" is never satisfactorily defined either 
(although the <tt>&lt;atomic&gt;</tt> synopsis comes close).</p></li>
<li><p>21.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>/p10 specifies exactly which operations are "plain lock-free atomic operations", but 
in a standard where an "integral constant expression" isn't necessarily a "constant expression", I do not feel safe assuming 
that a "plain lock-free atomic operation" is an "atomic operation".</p></li>
<li><p>Hans Boehm tells me the operations with "atomically" in the Effects element are intended to be atomic operations, 
but since "atomic operation" is a term of art (e.g. in 4.7 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>/p27.4), I think this needs to be 
spelled out rather than assumed. Furthermore, this does not help with 32.9 <a href="https://timsong-cpp.github.io/cppwp/atomics.fences">[atomics.fences]</a>, or anything in Clause 30.</p></li>
</ul>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2507" href="2507">2507.</a> <tt>codecvt_mode</tt> should be a bitmask type</h3>
<p><b>Section:</b> 99 [locale.stdcvt] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-06-08 <b>Last modified:</b> 2015-08-03 14:08:06 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.stdcvt">issues</a> in [locale.stdcvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The enumeration type <tt>codecvt_mode</tt> is effectively a bitmask type
(20.4.2.1.4 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a>) with three elements, but isn't defined as
such.
<p/>
This harms usability because bitmask types are required to work well
with bitwise operators, but <tt>codecvt_mode</tt> doesn't have overloaded
operators, making it very inconvenient to combine values:
</p>
<blockquote><pre>
std::codecvt_utf16&lt;char32_t, 0x10FFFF,
  static_cast&lt;std::codecvt_mode&gt;(std::little_endian|std::generate_header)&gt;
cvt;
</pre></blockquote>
<p>
The <tt>static_cast</tt> harms readability and should not be necessary.
<p/>
I suggest that either <tt>codecvt_mode</tt> is specified to be a bitmask type,
or as a minimal fix we provide an overloaded <tt>operator|</tt> that returns
the right type.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2508" href="2508">2508.</a> &sect;[new.delete.dataraces] wording needs to be updated</h3>
<p><b>Section:</b> 21.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/new.delete.dataraces">[new.delete.dataraces]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2015-06-09 <b>Last modified:</b> 2016-02-01 11:02:56 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.dataraces">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/new.delete.dataraces">[new.delete.dataraces]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/new.delete.dataraces">[new.delete.dataraces]</a> uses obsolete wording.
<p/>
It should introduce a "synchronizes with" relationship. "Happens before" is too weak, since that may not composes 
with sequenced before.
<p/>
The "shall not introduce a data race" wording is probably not technically correct either. These may race with other 
(non-allocation/deallocation) concurrent accesses to the object being allocated or deallocated.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2511" href="2511">2511.</a> <tt>scoped_allocator_adaptor</tt> piecewise construction does not require <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-06-16 <b>Last modified:</b> 2016-11-09 18:11:32 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>/10 requires that the argument types in the piecewise-construction tuples 
all be <tt>CopyConstructible</tt>. These tuples are typically created by <tt>std::forward_as_tuple</tt>, such as in 
&para;13. So they will be a mix of lvalue and rvalue references, the latter of which are not <tt>CopyConstructible</tt>.
<p/>
My guess is that <tt>CopyConstructible</tt> was specified to feed the <tt>tuple_cat</tt>, before that function could 
handle rvalues. Since the argument tuple is already moved in &para;11, the requirement is obsolete. It should either 
be changed to <tt>MoveConstructible</tt>, or perhaps better, convert the whole tuple to references (i.e. form 
<tt>tuple&lt;Args1&amp;&amp;...&gt;</tt>) so nothing needs to be moved. After all, this is a facility for handling non-movable 
types.
<p/>
It appears that the resolution of DR <a href="2203">2203</a>, which added <tt>std::move</tt> to &para;11, simply omitted the 
change to &para;10.
</p>

<p><i>[2016-11-08, Jonathan comments]</i></p>

<p>
My paper <a href="http://wg21.link/p0475r0">P0475R0</a> provides a proposed resolution.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2512" href="2512">2512.</a> Y2K bites; what is an "unambiguous year identifier"?</h3>
<p><b>Section:</b> 25.4.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-19 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.time.get.virtuals">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I recently encountered a failure related to questionable use of <tt>do_get_year</tt>. The platform where the code happened 
to work had an implementation which handled certain three-digit "year identifiers" as the number of years since 
1900 (<a href="http://www.drdobbs.com/cpp/remembering-y2k/228701726">this article</a> describes such an implementation).
<p/>
25.4.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> makes it implementation defined whether two-digit years are accepted, etc., but does not 
say anything specifically about three-digit years.
<p/>
The implementation freedom to not report errors in 25.4.5.1 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get">[locale.time.get]</a> paragraph 1 also seems to be too broad.
<p/>
See also the discussion following <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=38042">c++std-lib-38042</a>.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed PM: This has been this way since C++98. Don't think it's a P2.</p>
<p>Change to P4, and move to Open.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2513" href="2513">2513.</a> Missing requirements for <tt>basic_string::value_type</tt></h3>
<p><b>Section:</b> 24.1 <a href="https://timsong-cpp.github.io/cppwp/strings.general">[strings.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-06-26 <b>Last modified:</b> 2016-06-28 20:06:06 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#strings.general">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/strings.general">[strings.general]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The allocator-aware container requirements in Table 98 impose no
<tt>MoveAssignable</tt> requirements on the <tt>value_type</tt> when
<tt>propagate_on_container_move_assignment</tt> is true, because typically the
container's storage would be moved by just exchanging some pointers.
<p/>
However for a <tt>basic_string</tt> using the small string optimization move
assignment may need to assign individual characters into the small
string buffer, even when the allocator propagates.
<p/>
The only requirement on the char-like objects stored in a <tt>basic_string</tt>
are that they are non-array POD types and <tt>Destructible</tt>, which means
that a POD type with a deleted move assignment operator should be
usable in a <tt>basic_string</tt>, despite it being impossible to move assign:
</p>
<blockquote><pre>
#include &lt;string&gt;

struct odd_pod 
{
  odd_pod() = default;
  odd_pod&amp; operator=(odd_pod&amp;&amp;) = delete;
};

static_assert(std::is_pod&lt;odd_pod&gt;::value, "POD");

int main()
{
  using S = std::basic_string&lt;odd_pod&gt;;
  S s;
  s = S{};       // fails
}
</pre></blockquote>
<p>
Using libstdc++ <tt>basic_string&lt;odd_pod&gt;</tt> cannot even be
default-constructed because the constructor attempts to assign the
null terminator to the first element of the small string buffer.
<p/>
Similar problems exist with POD types with a deleted default constructor.
<p/>
I believe that <tt>basic_string</tt> should require its <tt>value_type</tt> to be at
least <tt>DefaultConstructible</tt> and <tt>MoveAssignable</tt>.
</p>

<p><i>[2016-06, Oulu]</i></p>

<p>This should be resolved by <a href="http://wg21.link/P0178">P0178</a></p>
<p>Note: P0178 was sent back to LEWG in Oulu.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2524" href="2524">2524.</a> <tt>generate_canonical</tt> can occasionally return 1.0</h3>
<p><b>Section:</b> 29.6.8.4.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.pois.exp">[rand.dist.pois.exp]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Michael Pr&auml;hofer <b>Opened:</b> 2015-08-20 <b>Last modified:</b> 2015-11-04 16:11:21 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Original title was: <tt>exponential_distribution&lt;float&gt;</tt> sometimes returns inf.</p>

<p>
The random number distribution class template <tt>exponential_distribution&lt;float&gt;</tt> may return "inf" as can be 
seen from the following example program:
</p>
<blockquote>
<pre>
// compiled with
// g++ -std=c++11 Error_exp_distr.cpp

#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;

int main(){
  unsigned long long h;
  std::mt19937_64 mt1(1);
  std::mt19937_64 mt2(1);
  mt1.discard(517517);
  mt2.discard(517517);
  std::exponential_distribution&lt;float&gt; dis(1.0);
  h = mt2();
  std::cout &lt;&lt; std::bitset&lt;64&gt;(h) &lt;&lt; " " &lt;&lt; (float) -log(1 - h/pow(2, 64)) &lt;&lt; " " 
            &lt;&lt; -log(1 - (float) h/pow(2, 64)) &lt;&lt; " " &lt;&lt; dis(mt1) &lt;&lt; std::endl;
  h = mt2();
  std::cout &lt;&lt; std::bitset&lt;64&gt;(h) &lt;&lt; " " &lt;&lt; (float) -log(1 - h/pow(2, 64)) &lt;&lt; " " 
            &lt;&lt; -log(1 - (float) h/pow(2, 64)) &lt;&lt; " " &lt;&lt; dis(mt1) &lt;&lt; std::endl;
}
</pre>
</blockquote>
<p>
output:
</p>
<blockquote>
<pre>
0110010110001001010011000111000101001100111110100001110011100001 0.505218 0.505218 0.505218
1111111111111111111111111101010011000110011110011000110101100110 18.4143 inf inf
</pre>
</blockquote>
<p>
The reason seems to be that converting a <tt>double x</tt> in the range <tt>[0, 1)</tt> to <tt>float</tt> may result in <tt>1.0f</tt> 
if <tt>x</tt> is close enough to <tt>1</tt>. I see two possibilities to fix that:
</p>
<ol>
<li><p>use internally <tt>double</tt> (or <tt>long double</tt>?) and then convert the result at the very end to <tt>float</tt>.</p></li>
<li><p>take only 24 random bits and convert them to a <tt>float x</tt> in the range <tt>[0, 1)</tt> and then return <tt>-log(1 - x)</tt>.</p></li>
</ol>

<p>
I have not checked if <tt>std::exponential_distribution&lt;double&gt;</tt> has the same problem:
For <tt>float</tt> on the average 1 out of 2<sup>24</sup> (~10<sup>7</sup>) draws returns "inf", which is easily confirmed.
For <tt>double</tt> on the average 1 out of 2<sup>53</sup> (~10<sup>16</sup>) draws might return "inf", which I have not tested.
</p>

<p><b>Marshall:</b><br/>
I don't think the problem is in <tt>std::exponential_distribution</tt>; but rather in <tt>generate_canonical</tt>.
</p>

<p>Consider:
<blockquote><pre>
std::mt19937_64 mt2(1);
mt2.discard(517517);
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
</pre></blockquote>
<p/>
which outputs:
<p/>
<blockquote><pre>
0x1.962532p-2
0x1p+0
0x1.20d0cap-3
</pre></blockquote>

but <tt>generate_canonical</tt> is defined to return a result in the range [0, 1).
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>Options: </p>
<ul>
<li>1) NAD, make it work. E.g. nudge slightly, making the hightest result return the highest allowable value (next_after). This might change the distribution slightly.</li>
<li>2) Re-run the algorithm when you get a 1. This changes the specification in that it makes extra calls to the random engine.</li>
<li>3) Something else</li>
</ul>

<p>WEB: The one thing we cannot tolerate is any output range other than [0, 1).</p>
<p>WEB: I believe there may be a documented algorithm for the generator, and perhaps it's possible to discover en-route that the algorithm produces the wrong result and fix it.</p>
<p>MC: No. I analyzed this once, and here it is: the algorithm is in [rand.util.canonical], and it's all fine until p5. The expression <tt>S/R^k</tt> is mathematically less than one, but it may round to one.</p>
<p>GR: Could we change the rounding mode for the computation? </p>
<p>HH: No, because the rounding mode is global, not thread-local.</p>
<p>AM: SG1 wants to get rid of the floating point environment. </p>
<p>STL: The problem is that the standard specifies the implementation, and the implementation doesn't work.</p>
<p>MC: I'm not sure if nudging it down will introduce a subtle bias.</p>
<p>EF: I worry about how the user's choice of floating point environment affects the behaviour.</p>
<p>MS offers to run the topic past colleagues.</p>
<p>MC: Will set the status to open. STL wants to rename the issue. WEB wants to be able to find the issue by its original name still.</p>

<p>Mike Spertus to run the options past his mathematical colleagues, and report back.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2528" href="2528">2528.</a> Order of <tt>std::tuple</tt> construction unspecified</h3>
<p><b>Section:</b> 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Rodriguez <b>Opened:</b> 2015-08-25 <b>Last modified:</b> 2017-02-19 15:02:54 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>std::tuple</tt> order of element construction is unspecified. It is either in the same order of the type list or in reverse. 
<p/>
Consider the following program:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct X 
{
  X(int) { std::cout &lt;&lt; "X constructor\n"; }
};

struct Y 
{
  Y(int) { std::cout &lt;&lt; "Y constructor\n"; }
};

int main()
{
  std::tuple&lt;X, Y&gt; t(1, 2);
}
</pre></blockquote>
<p>
Here is a <a href="http://coliru.stacked-crooked.com/a/764d0477523ba249">link</a> to two sample compilations. The first uses 
libstdc++ and constructs in reverse order, and the second uses libc++ and constructs in in-order. 
<p/>
A <tt>std::tuple</tt> mimics both a struct and type-generic container and should thus follow their standards. Construction is 
fundamentally different from a function call, and it has been historically important for a specific order to be guaranteed; 
namely: whichever the developer may decide. Mandating construction order will allow developers to reference younger elements 
later on in the chain as well, much like a struct allows you to do with its members.
<p/>
There are implementation issues as well. Reversed lists will require unnecessary overhead for braced-initializer-list initialization.  
Since lists are evaluated from left to right, the initializers must be placed onto the stack to respect the construction order. 
This issue could be significant for large tuples, deeply nested tuples, or tuples with elements that require 
many constructor arguments.
<p/>
I propose that the <tt>std::tuple&lt;A, B, ..., Y, Z&gt;</tt>'s constructor implementation be standardized, and made to construct 
in the same order as its type list e.g. <tt>A{}, B{}, ..., Y{}, Z{}</tt>.
</p>

<p>
<b>Daniel:</b>
<p/>
When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">N3140</a> became accepted, wording had been
added that gives at least an indication of requiring element initialization in the order of the declaration of the template
parameters. This argumentation can be based on 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> p3 (emphasize mine):
</p>
<blockquote><p>
-3- In the constructor descriptions that follow, let <tt><i>i</i></tt> be in the range <tt>[0,sizeof...(Types))</tt> 
<span style="color:#C80000;font-weight:bold">in order</span>, 
<tt><i>Ti</i></tt> be the <tt><i>i<sup>th</sup></i></tt> type in <tt>Types</tt>, and <tt><i>Ui</i></tt> be the 
<tt><i>i<sup>th</sup></i></tt> type in a template parameter pack named <tt>UTypes</tt>, where indexing is
zero-based.
</p></blockquote>
<p>
But the current wording needs to be improved to make that intention clearer and an issue like this one is necessary to be sure that
the committee is agreeing (or disagreeing) with that intention, especially because N3140 didn't really point out the relevance of the element
construction order in the discussion, and because not all constructors explicitly refer to the ordered sequence of numbers generated
by the variable <tt><i>i</i></tt> (The move constructor does it right, but most other don't do that). 
</p>

<p><i>[2017-02-12, Alisdair comments]</i></p>

<p>
Note that this issue should not be extended to cover the assignment operators,
as implementations may want the freedom to re-order member-wise assignment
so that, for example, all potentially-throwing assignments are performed before
non-throwing assignments (as indicated by the <tt>noexcept</tt> operator).
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2530" href="2530">2530.</a> Clarify observable side effects of releasing a shared state</h3>
<p><b>Section:</b> 33.6.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-08-06 20:08:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When a shared-state is released, it may be necessary to execute user defined code for the destructor of a 
stored value or exception. It is unclear whether the execution of said destructor constitutes an observable side effect.
</p>
<p>
While discussing N4445 in Lenexa, Nat Goodspeed pointed out that 33.6.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a>/5.1 does not explicitly 
mention the destruction of the result, so implementations should be allowed to release (or reuse) a shared state ahead 
of time under the "as-if" rule.
<p/>
The standard should clarify whether the execution of destructors is a visible side effect of releasing a shared state.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>This is related to <a href="2532">2532</a></p>
<p>Fri AM: Moved to Open</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2532" href="2532">2532.</a> Satisfying a <tt>promise</tt> at thread exit</h3>
<p><b>Section:</b> 33.6.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-08-06 20:08:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>promise::set_value_at_thread_exit</tt> and <tt>promise::set_exception_at_thread_exit</tt> operate on a shared state 
at thread exit, without making the thread participate in the ownership of such shared state.
<p/>
Consider the following snippet:
</p>
<blockquote><pre>
std::promise&lt;int&gt;{}.set_value_at_thread_exit(42);
</pre></blockquote>
<p>
Arguably, since the <tt>promise</tt> abandons its shared state without actually making it ready, a <tt>broken_promise</tt> 
error condition should be stored in the shared state. Implementations diverge, they either crash at thread exit by 
dereferencing an invalid pointer, or keep the shared state around until thread exit.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>This is related to <a href="2530">2530</a></p>
<p><i>[2016-08-03, Billy O'Neal suggests concrete wording]</i></p>

<p>Fri AM: Moved to Open</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 33.6.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a> p7 as indicated:</p>

<blockquote>
<p>
-7- When an asynchronous provider is said to abandon its shared state, it means:
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; first, if that state is not ready <ins>or scheduled to be made ready at thread exit</ins>, the provider</p>
<ol style="list-style-type: none">
<li><p>(7.1.1) &mdash; stores an exception object of type <tt>future_error</tt> with an error condition of 
<tt>broken_promise</tt> within its shared state; and then</p></li>
<li><p>(7.1.2) &mdash; makes its shared state ready;</p></li>
</ol>
</li>
</ol>
</blockquote>
</li>

<li><p>Change 33.6.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a> p10 as indicated:</p>

<blockquote>
<p>
-10- Some functions (e.g., <tt>promise::set_value_at_thread_exit</tt>) <del>delay making the shared state ready 
until</del><ins>schedule the shared state to be made ready when</ins> the
calling thread exits. <ins>This associates a reference to the shared state with the calling thread.</ins> The 
destruction of each of that thread's objects with thread storage duration 
(6.7.2 <a href="https://timsong-cpp.github.io/cppwp/basic.stc.thread">[basic.stc.thread]</a>) is sequenced before making that shared state ready. <ins>When the calling 
thread makes the shared state ready, if the thread holds the last reference to the shared state, the shared state 
is destroyed. [<i>Note:</i> This means that the shared state may not become ready until after the <em>asynchronous 
provider</em> has been destroyed. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2533" href="2533">2533.</a> [concurr.ts] Constrain threads where <tt>future::then</tt> can run a continuation</h3>
<p><b>Section:</b> 99 [concurr.ts::futures.unique_future] <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2017-03-01 18:03:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concurr.ts::futures.unique_future">active issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#concurr.ts::futures.unique_future">issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: concurr.ts</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4538.pdf">N4538</a>, the continuation given to 
<tt>future::then</tt> can be run "on an unspecified thread of execution". This is too broad, as it allows the 
continuation to be run on the main thread, a UI thread, or any other thread. In comparison, functions given to 
<tt>async</tt> run "as if in a new thread of execution", while the Parallelism TS gives less guarantees by running 
"in either the invoking thread or in a thread implicitly created by the library to support parallel algorithm execution". 
The threads on which the continuation given to <tt>future::then</tt> can run should be similarly constrained.
</p>

<p><i>[2017-03-01, Kona, SG1]</i></p>

<p>
Agreement that this is a problem. Suggested addition to the issue is below. We have no immediate delivery vehicle 
for a fix at the moment, but we would like to make the intended direction clear.
<p/>
There is SG1 consensus that <tt>.then</tt> continuations should, by default, and in the absence of executors, be run 
only in the following ways:
</p>
<ol>
<li><p>If the future is not ready when <tt>.then()</tt> is called, the <tt>.then</tt> argument may be run on the execution 
agent that fulfills the promise.</p></li>
<li><p>In all cases, the <tt>.then</tt> argument may be run on an implementation-provided thread, i.e. a thread that is 
neither the main thread nor explicitly created by the user.</p></li>
</ol>
<p>
In the absence of an executor argument (which currently cannot be supplied), running of the <tt>.then()</tt> continuation 
will not block the thread calling <tt>.then()</tt>, even if the future is ready at the time.
<p/>
Straw polls:
<p/>
SF | F | N | A | SA
<p/>
For the default behaviour:
<p/>
"1. Run on completed task or new execution agent"
<p/>
0 | 7 | 5 | 1 | 0
<p/>
"2. Run on completed task or <tt>.then</tt> caller"
<p/>
0 | 0 | 5 | 5 | 3
<p/>
"3. Leave as implementation defined"
<p/>
1 | 2 | 4 | 3 | 3
<p/>
"4. Always new execution agent"
<p/>
2 | 3 | 6 | 2 | 0
<p/>
The actual conclusion was to allow either (1) or (4) for now, since they are quite close, but present a very different 
programming mode from (2).
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2541" href="2541">2541.</a> [parallel.ts] Headers for <tt>ExecutionPolicy</tt> algorithm overloads</h3>
<p><b>Section:</b> 99 [parallel.ts::parallel.alg.overloads] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-09-26 <b>Last modified:</b> 2015-10-21 05:10:23 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: parallel.ts</b></p>
<p>
99 [parallel.ts::parallel.alg.overloads] provides parallel algorithm overloads for many algorithms in the standard library, 
but I can't find any normative wording specifying which headers these new overloads live in. Presumably, if the original 
algorithm is in <tt>&lt;meow&gt;</tt>, the new overloads should be in <tt>&lt;experimental/meow&gt;</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2546" href="2546">2546.</a> Implementability of locale-sensitive <em>UnicodeEscapeSequence</em> matching</h3>
<p><b>Section:</b> 31.13 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-10-08 <b>Last modified:</b> 2015-10-21 05:10:23 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 31.13 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> paragraph 2:
</p>
<blockquote><p>
<tt>basic_regex</tt> member functions shall not call any locale dependent C or C++ API, including the formatted 
string input functions. Instead they shall call the appropriate traits member function to achieve the required effect.
</p></blockquote>
<p>
Yet, the required interface for a regular expression traits class (31.3 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a>) does not appear to have 
any reliable method for determining whether a character as encoded for the locale associated with the traits 
instance is the same as a character represented by a <em>UnicodeEscapeSequence</em>, e.g., assuming a sane 
<tt>ru_RU.koi8r</tt> locale:
</p>
<blockquote><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;regex&gt;

const char data[] = "\xB3";
const char matchCyrillicCaptialLetterYo[] = R"(\u0401)";

int main(void) 
{
  try {
    std::regex myRegex;
    myRegex.imbue(std::locale("ru_RU.koi8r"));

    myRegex.assign(matchCyrillicCaptialLetterYo, std::regex_constants::ECMAScript);
    printf("(%s)\n", std::regex_replace(std::string(data), myRegex, std::string("E")).c_str());

    myRegex.assign("[[:alpha:]]", std::regex_constants::ECMAScript);
    printf("(%s)\n", std::regex_replace(std::string(data), myRegex, std::string("E")).c_str());
  } catch (std::regex_error&amp; e) {
    abort();
  }
  return 0;
}
</pre></blockquote>
<p>
The implementation I tried prints:
</p>
<blockquote><pre>
(&#x401;)
(E)
</pre></blockquote>
<p>
Which means that the character class matching worked, but not the matching to the <em>UnicodeEscapeSequence</em>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2547" href="2547">2547.</a> Container requirements (and other library text) should say "strict total order", not just "total order"</h3>
<p><b>Section:</b> 23.14.7 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>, 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, 33.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2015-10-08 <b>Last modified:</b> 2015-10-21 05:10:23 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of places in the library, including 23.14.7 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>/14, the Optional container requirements in 
26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, and 33.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a>/8, use the phrase "total order". 
Unfortunately, that phrase is ambiguous. In mathematics, the most common definition is that a relation <tt>&le;</tt> is 
a total order if it's total, transitive, and antisymmetric in the sense that <tt>x&le;y &#x2227; y&le;x &rArr; x=y</tt>. 
What we really want is a strict total order: a relation <tt>&lt;</tt> is a strict total order if it's total, transitive, and 
antisymmetric in the sense that exactly one of <tt>x&lt;y</tt>, <tt>y&lt;x</tt>, and <tt>x=y</tt> holds.
</p>
<p>
The non-normative note in 28.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a>/4 correctly uses the phrase "strict total ordering" rather than 
simply "total ordering".
</p>
<p>
We could address this issue by replacing "total order" with "strict total order" everywhere it appears, since I 
think there are no cases where we actually want a non-strict total order, or we could add something in Clause 17 saying 
that we always mean strict total order whenever we say total order.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2561" href="2561">2561.</a> [fund.ts.v2] Incorrect exception specifications for 'swap' in C++ Extensions for Library Fundamentals</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object.swap], 99 [fund.ts.v2::propagate_const.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2015-11-14 <b>Last modified:</b> 2016-11-20 18:11:35 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
As pointed out in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4511.html#Related_Issues">N4511</a>,
the Library fundamentals are affected by a similar problem as described in LWG <a href="2456">2456</a>. First, it is caused
by <tt>optional</tt>'s member <tt>swap</tt> (99 [fund.ts.v2::optional.object.swap]):
</p>
<blockquote><pre>
void swap(optional&lt;T&gt;&amp; rhs) noexcept(<i>see below</i>);
</pre></blockquote>
<p>
with 
</p>
<blockquote>
<p>
The expression inside <tt>noexcept</tt> is equivalent to: 
</p>
<blockquote><pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))
</pre></blockquote>
</blockquote>
<p>
Again, the unqualified lookup for <tt>swap</tt> finds the member <tt>swap</tt> instead of the result of a normal argument-depending 
lookup, making this ill-formed.
<p/>
A second example of such a problem recently entered the arena with the addition of the <tt>propagate_const</tt> template
with another member <tt>swap</tt> (99 [fund.ts.v2::propagate_const.modifiers]):
</p>
<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- The constant-expression in the exception-specification is <tt>noexcept(swap(t_, pt.t_))</tt>.
</p>
</blockquote>
</blockquote>
<p>
A working approach is presented in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4511.html#Proposed_resolution">N4511</a>. By adding a new
trait to the standard library and referencing this by the library fundamentals (A similar approach had been applied in the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3940.html#path-inserter-extractor">file system specification</a>
where the <tt>quoted</tt> manipulator from C++14 had been referred to, albeit the file system specification is generally based on the
C++11 standard), <tt>optional</tt>'s member <tt>swap</tt> exception specification could be rephrased as follows:
</p>
<blockquote>
<p>
The expression inside <tt>noexcept</tt> is equivalent to: 
</p>
<blockquote><pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; <ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</del>
</pre></blockquote>
</blockquote>
<p>
and <tt>propagate_const</tt>'s member <tt>swap</tt> exception specification could be rephrased as follows:
</p>
<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- The constant-expression in the exception-specification is <tt><ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(t_, pt.t_))</del></tt>.
</p>
</blockquote>
</blockquote>

<p><i>[2016-02-20, Ville comments]</i></p>

<p>
Feedback from an implementation:
<p/>
libstdc++ already applies the proposed resolution for <tt>propagate_const</tt>,
but not for <tt>optional</tt>.
</p>

<p><i>[2016-02-20, Daniel comments]</i></p>

<p>
A recent paper update has been provided: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0185r0.html#Proposed_resolution">P0185R0</a>.
</p>

<p><i>[2016-03, Jacksonville]</i></p>

Add a link to <a href="2456">2456</a>

<p><i>[2016-11-08, Issaquah]</i></p>

<p>Not adopted during NB comment resolution</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2563" href="2563">2563.</a> LWG 2259 relaxes requirements, perhaps unintentionally</h3>
<p><b>Section:</b> 20.5.5.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-11-29 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#member.functions">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The combination of 20.5.5.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>, paragraphs 2 and 3 that LWG 
<a href="2259">2259</a> does seems to drop a requirement that any call behaves as if 
no overloads were added. Paragraph 3 used to say
"A call to a member function signature described in the C ++ standard
library behaves as if the implementation
declares no additional member function signatures."
whereas the new wording says
"provided that any call to the member function that would select an
overload from the set of declarations described in this standard
behaves as if that overload were selected."
<p/>
This can be read as meaning that if there's no default constructor
specified, like for instance for <tt>std::ostream</tt>, an implementation is free to
add it. It can also be read as meaning that an implementation is free to
add any overloads that wouldn't change the overload resolution result
of any call expression that would select a specified overload. That's
vastly different from allowing extensions that add new functions rather
than new overloads.
<p/>
Was this relaxation intentional?
</p>
<p><i>[2016-04, Issues Telecon]</i></p>

<p>
Ville provides a motivating example.
</p>

<p>
<blockquote>
<pre>
#include &lt;iostream&gt;

class my_stream : std::ostream
{
};

int main()
{
    my_stream ms;
}
</pre>
</blockquote>
</p>

<p>This example is accepted by libstdc++, msvc rejects it, and clang+libc++
segfault on melpon.org/wandbox o_O. An earlier clang+libc++ just accepts
it. I don't think the implementation divergence is caused by the acceptance
of the referred-to <a href="2259">2259</a>, but it certainly seems to increasingly bless
the implementation divergence.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
This is related to issue <a href="2695">2695</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2564" href="2564">2564.</a> [fund.ts.v2] <tt>std::experimental::function</tt> constructors taking allocator arguments may throw exceptions</h3>
<p><b>Section:</b> 99 [fund.ts.v2::func.wrap.func] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song  <b>Opened:</b> 2015-12-05 <b>Last modified:</b> 2016-11-20 18:11:35 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::func.wrap.func">issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
[This is essentially LWG <a href="2370">2370</a>, but deals with the fundamentals TS version rather than the one in the standard]
<p/>
In 99 [fund.ts.v2::func.wrap.func] of library fundamentals TS, the constructors
</p>
<blockquote><pre>
template&lt;class A&gt; function(allocator_arg_t, const A&amp;) noexcept;
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) noexcept;
</pre></blockquote>
<p>
must type-erase and store the provided allocator, since the <tt>operator=</tt> specification requires using the "allocator 
specified in the construction of" the <tt>std::experimental::function</tt> object. This may require a dynamic allocation 
and so cannot be noexcept. Similarly, the following constructors
</p>
<blockquote><pre>
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, const function&amp;); 
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, function&amp;&amp;);
template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp;, F);
</pre></blockquote>
<p>
cannot satisfy the C++14 requirement that they "shall not throw exceptions if [the <tt>function</tt> object to be stored] 
is a callable object passed via <tt>reference_wrapper</tt> or a function pointer" if they need to type-erase and store the 
allocator.
</p>
<p><i>[2016-11-08, Issaquah]</i></p>

<p>Not adopted during NB comment resolution</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>.
</p>

<ol>
<li><p> Edit 99 [fund.ts.v2::func.wrap.func], class template <tt>function</tt> synopsis, as follows:</p>

<blockquote>
<pre>
namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    [&hellip;]

    template&lt;class R, class... ArgTypes&gt;
    class function&lt;R(ArgTypes...)> {
    public:    
      [&hellip;]
      template&lt;class A> function(allocator_arg_t, const A&amp;) <del>noexcept</del>;
      template&lt;class A> function(allocator_arg_t, const A&amp;,
        nullptr_t) <del>noexcept</del>;
      [&hellip;]
    };

    [&hellip;]

  } // namespace fundamentals_v2
  } // namespace experimental

  [&hellip;]

} // namespace std
</pre>
</blockquote>
</li>

<li><p>Insert the following paragraphs after 99 [fund.ts.v2::func.wrap.func.con]/1:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: This just reproduces the wording from C++14 with the "shall not throw exceptions for 
<tt>reference_wrapper</tt>/function pointer" provision deleted. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<p>
-1- When a <tt>function</tt> constructor that takes a first argument of type <tt>allocator_arg_t</tt> is invoked, 
the second argument is treated as a <em>type-erased allocator</em> (8.3). If the constructor moves or makes a copy 
of a function object (C++14 &sect;20.9), including an instance of the <tt>experimental::function</tt> class template, 
then that move or copy is performed by <em>using-allocator construction</em> with allocator <tt>get_memory_resource()</tt>. 
</p>
<blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, nullptr_t);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Postconditions</i>: <tt>!*this</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Postconditions</i>: <tt>!*this if !f</tt>; otherwise, <tt>*this</tt> targets a copy of <tt>f.target()</tt>.</ins>
<p/>
<ins>-?- <i>Throws</i>: May throw <tt>bad_alloc</tt> or any exception thrown by the copy constructor of the stored callable object. 
[<i>Note</i>: Implementations are encouraged to avoid the use of dynamically allocated memory for small callable objects, 
for example, where <tt>f</tt>'s target is an object holding only a pointer or reference to an object and a member function pointer. 
&mdash; <i>end note</i>]</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, function&amp;&amp; f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- Effects: If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, move-constructs the target of <tt>f</tt> into the 
target of <tt>*this</tt>, leaving <tt>f</tt> in a valid state with an unspecified value.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>F</tt> shall be <tt>CopyConstructible</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution unless <tt>f</tt> is Callable 
(C++14 &sect;20.9.11.2) for argument types <tt>ArgTypes...</tt> and return type <tt>R</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>!*this</tt> if any of the following hold:</ins>
<ul>
<li><p><ins><tt>f</tt> is a null function pointer value.</ins></p></li>
<li><p><ins><tt>f</tt> is a null member pointer value.</ins></p></li>
<li><p><ins><tt>F</tt> is an instance of the <tt>function</tt> class template, and <tt>!f</tt>.</ins></p></li>
</ul>
<p/>
<ins>-?- Otherwise, <tt>*this</tt> targets a copy of <tt>f</tt> initialized with <tt>std::move(f)</tt>. [<i>Note</i>: 
Implementations are encouraged to avoid the use of dynamically allocated memory for small callable objects, for example, 
where <tt>f</tt>'s target is an object holding only a pointer or reference to an object and a member function pointer. &mdash; 
<i>end note</i>]</ins>
<p/>
<ins>-?- <i>Throws</i>: May throw <tt>bad_alloc</tt> or any exception thrown by <tt>F</tt>'s copy or move constructor.</ins>
</p>
</blockquote>
</blockquote>
<p>
-2- In the following descriptions, let <tt><i>ALLOCATOR_OF</i>(f)</tt> be the allocator specified in the construction 
of <tt>function f</tt>, or <tt>allocator&lt;char&gt;()</tt> if no allocator was specified.
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2569" href="2569">2569.</a> <tt>conjunction</tt> and <tt>disjunction</tt> requirements are too strict</h3>
<p><b>Section:</b> 23.15.8 <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-11 <b>Last modified:</b> 2016-11-15 22:11:57 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.logical">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.logical">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.15.8 <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a>/2 and /5 impose the following requirement on the arguments of <tt>conjunction</tt> and <tt>disjunction</tt>:
</p>
<blockquote><p>
Every template type argument shall be usable as a base class and shall have a static data member value which is convertible to 
<tt>bool</tt>, is not hidden, and is unambiguously available in the type.
</p></blockquote>
<p>
Since the requirement is unconditional, it applies even to type arguments whose instantiation is not required due to short circuiting. 
This seems contrary to the design intent, expressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a>, 
that it is valid to write <tt>conjunction_v&lt;is_class&lt;T&gt;, is_foo&lt;T&gt;&gt;</tt> even if instantiating 
<tt>is_foo&lt;T&gt;::value</tt> is ill-formed for non-class types.
</p>
<p><i>[2016-08 Chicago]</i></p>

<p>Ville provided wording for both <a href="2569">2569</a> and <a href="2570">2570</a>.</p>
<p>Tuesday AM: Move to Tentatively Ready</p>

<p><i>[2016-11-15, Reopen upon request of Dawn Perchik ]</i></p>

<p>
The proposed wording requires an update, because the referenced issue LWG <a href="2568">2568</a> is still open.
</p>


<p><b>Proposed resolution:</b></p>
<p><i>[We recommend applying the proposed resolution for LWG issues 2567 and 2568 before this
proposed resolution, lest the poor editor gets confused.]</i></p>


<p>In [meta.logical],</p>

<p>- insert a new paragraph before paragraph 2:</p>

<p><ins>The class template <tt>conjunction</tt> forms the logical conjunction of its
template type arguments.</ins></p>

<p>- move paragraph 4 before paragraph 2, and edit
paragraph 2 as follows:</p>

<p><del>The class template <tt>conjunction</tt> forms the logical conjunction of its
template type arguments.</del>
Every template type argument <ins>for which <tt>Bi::value</tt> is instantiated</ins>
shall be usable as a base class and shall have a member value which is
convertible to <tt>bool</tt>, is not hidden, and is unambiguously available in the type.</p>

<p>- insert a new paragraph before paragraph 5:</p>

<p><ins>The class template <tt>disjunction</tt> forms the logical disjunction
of its template type arguments.</ins></p>

<p>- move paragraph 7 before paragraph 5, and edit
paragraph 5 as follows:</p>

<p><del>The class template <tt>disjunction</tt> forms the logical disjunction
of its template type arguments.</del>
Every template type argument <ins>for which <tt>Bi::value</tt> is instantiated</ins>
shall be usable as a base class and shall have a member value which is
convertible to <tt>bool</tt>, is not hidden, and is unambiguously available in the type.</p>





<hr>
<h3><a name="2587" href="2587">2587.</a> "Convertible to <tt>bool</tt>" requirement in <tt>conjunction</tt> and <tt>disjunction</tt></h3>
<p><b>Section:</b> 23.15.8 <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-01-18 <b>Last modified:</b> 2016-08-07 11:08:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.logical">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.logical">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> in 23.15.8 <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a> p2 and p5 requires 
<tt>Bi::value</tt> to be convertible to <tt>bool</tt>, but nothing in the specification of the actual behavior of the 
templates, which instead uses the expressions <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt> instead, 
actually requires this conversion.
<p/>
If the intention of this requirement is to allow implementations to pass <tt>Bi::value</tt> directly to <tt>std::conditional</tt>, 
like the sample implementation in P0013R1:
</p>
<blockquote><pre>
template&lt;class B1, class B2&gt;
struct and_&lt;B1, B2&gt; : conditional_t&lt;B1::value, B2, B1&gt; { };
</pre></blockquote>
<p>
then it's insufficient in at least two ways:
</p>
<ol>
<li><p>Nothing in the specification requires the result of comparing <tt>Bi::value</tt> with <tt>false</tt> to be consistent 
with the result of the implicit conversion. This is similar to LWG <a href="2114">2114</a>, though I don't think the 
<tt>BooleanTestable</tt> requirements in that issue's P/R covers <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt>.</p></li>
<li><p>More importantly, the above implementation is ill-formed for, e.g., 
<tt>std::conjunction&lt;std::integral_constant&lt;int, 2&gt;, std::integral_constant&lt;int, 4&gt;&gt;</tt>, because converting 2 
to <tt>bool</tt> is a narrowing conversion that is not allowed for non-type template arguments (see 8.20 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>/4). 
(Note that GCC currently doesn't diagnose this error at all, and Clang doesn't diagnose it inside system headers.) It's not clear 
whether such constructs are intended to be supported, but if they are not, the current wording doesn't prohibit it.</p></li> 
</ol>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Walter, Nevin, and Jason provide initial Proposed Resolution.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>

<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 23.15.8 <a href="https://timsong-cpp.github.io/cppwp/meta.logical">[meta.logical]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... B&gt; struct conjunction : <i>see below</i> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- The BaseCharacteristic of a specialization <tt>conjunction&lt;B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub>&gt;</tt>
is the first type <tt>B<sub><i>i</i></sub></tt> in the list <tt>true_type, B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub></tt>
for which <tt><del>B<sub><i>i</i></sub>::value == false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>,
or if every <tt><del>B<sub><i>i</i></sub>::value != false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, the
BaseCharacteristic is the last type in the list. [&hellip;]
<p/>
-4- For a specialization <tt>conjunction&lt;B<sub>1</sub>, ..., B<sub><i>N</i></sub>&gt;</tt>, if there is a template
type argument <tt>B<sub><i>i</i></sub></tt> with <tt><del>B<sub><i>i</i></sub>::value ==
false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>, then instantiating [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... B&gt; struct disjunction : <i>see below</i> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- The BaseCharacteristic of a specialization <tt>disjunction&lt;B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub>&gt;</tt>
is the first type <tt>B<sub><i>i</i></sub></tt> in the list <tt>false_type, B<sub><i>1</i></sub>, ...,
B<sub><i>N</i></sub></tt> for which <tt><del>B<sub><i>i</i></sub>::value !=
false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, or if every
<tt><del>B<sub><i>i</i></sub>::value == false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>, the
BaseCharacteristic is the last type in the list. [&hellip;]
<p/>
-7- For a specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>, if there is a template type argument <tt>Bi</tt> with
<tt><del>B<sub><i>i</i></sub>::value != false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, then instantiating
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class B&gt; struct negation : bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt; { };
</pre>
<blockquote>
<p>
-8- The class template negation forms the logical negation of its template type argument. The type
<tt>negation&lt;B&gt;</tt> is a UnaryTypeTrait with a BaseCharacteristic of
<tt>bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt;</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
The resolution for this issue was combined with the resolution for LWG <a href="2567">2567</a>, so <a href="2567">2567</a> 
resolves this issue here as well.
</p>





<hr>
<h3><a name="2592" href="2592">2592.</a> Require that <tt>chrono::duration_cast</tt>s from smaller durations to larger durations do not overflow</h3>
<p><b>Section:</b> 23.17.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Andy Giese <b>Opened:</b> 2016-02-05 <b>Last modified:</b> 2016-05-08 21:05:54 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.syn">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently 23.17.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a> states
</p>
<blockquote><pre>
<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least 45 bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least 35 bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least 29 bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least 23 bits</i>, ratio&lt;3600&gt;&gt; hours;
</pre></blockquote>
<p>
However, a <tt>duration_cast&lt;minutes&gt;(seconds::max())</tt> would cause overflow if the underlying signed integers 
only met the minimums specified.
<p/>
The standard should specify that implementations guarantee that a <tt>duration_cast</tt> from any smaller duration in 
these "convenience typedefs" will not overflow any larger duration. That is, <tt>hours</tt> should be able to hold 
the maximum of <tt>minutes</tt>, which should be able to hold the maximum of <tt>seconds</tt> and so on.
<p/>
More formally, if the ratio <tt>typedef A</tt> and <tt>typedef B</tt> is <tt>1:Y</tt> where <tt>Y &gt; 1</tt> (e.g., 
1 : 60 in case of <tt>minutes</tt> : <tt>seconds</tt>), then <tt>#bits<sub>A</sub>-1</tt> must be at least 
<tt>ceil(log<sub>2</sub>(2<sup>#bits<sub>B</sub>-1)/Y)</sup>)</tt>.
<p/>
In the case of <tt>minutes</tt> : <tt>seconds</tt>, <tt>X = 1</tt>, <tt>Y = 60</tt>. Let 
<tt>#bits<sub>seconds</sub> = 32</tt>. Therefore:
</p>
<ul>
<li><p><tt>2<sup>(#bits<sub>seconds</sub> - 1)</sup> = 2<sup>31</sup> = 2147483648</tt></p></li>
<li><p><tt>ceil(log<sub>2</sub>(2<sup>31</sup> / 60) = 26</tt></p></li>
<li><p><tt>#bits<sub>minutes</sub> - 1 = 26</tt></p></li>
<li><p><tt>#bits<sub>minutes</sub> = 27</tt></p></li>
</ul>
<p>
Therefore, a minimum of 27 bits would be needed to store <tt>minutes</tt> if 32 were used to store <tt>seconds</tt>.
<p/>
I propose to change the definitions of the convenience typedefs as follows:
</p>
<blockquote><pre>
<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least 46 bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least 37 bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least 32 bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least 27 bits</i>, ratio&lt;3600&gt;&gt; hours;
</pre></blockquote>
<p>
These bits were chosen to satisfy the above formula. Note that
minimums only increased, so larger ranges could be held. A nice
outcome of this choice is that <tt>minutes</tt> does not go above 32 bits.
</p>

<p><i>[2016-04-23, Tim Song comments]</i></p>

<p>
The P/R of LWG 2592 doesn't fix the issue it wants to solve, because the actual underlying type will likely 
have more bits than the specified minimum.
<p/>
Consider <tt>seconds</tt>, which the P/R requires to have at least 37 bits. On a typical system this implies 
using a 64-bit integer. To ensure that casting from <tt>seconds::max()</tt> to <tt>minutes</tt> doesn't overflow 
in such a system, it is necessary for the latter to have at least 59 bits (which means, in practice, 64 bits too), 
not just 32 bits. Thus, just changing the minimum number of bits will not be able to provide the desired guarantee 
that casting from a smaller unit to a larger one never overflow.
<p/>
If such a guarantee is to be provided, it needs to be spelled out directly. Note that the difference here is 9 bits 
(for the 1000-fold case) and 5 bits (for the 60-fold case), which is less than the size difference between integer 
types on common systems, so such a requirement would effectively require those convenience typedefs to use the 
same underlying integer type.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 23.17.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>, header <tt>&lt;chrono&gt;</tt> synopsis, as indicated</p>

<blockquote><pre>
[&hellip;]

<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least <ins>46</ins><del>45</del> bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least <ins>37</ins><del>35</del> bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least <ins>32</ins><del>29</del> bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least <ins>27</ins><del>23</del> bits</i>, ratio&lt;3600&gt;&gt; hours;

[&hellip;]
</pre></blockquote>

</li>
</ol>





<hr>
<h3><a name="2593" href="2593">2593.</a> Moved-from state of Allocators</h3>
<p><b>Section:</b> 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-02-19 <b>Last modified:</b> 2016-08-05 03:08:05 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> suggests that the moved-from state of an allocator may be unequal to its 
previous state. Such a move constructor would break most container implementations, which move-construct the 
embedded allocator along with a compressed pair. Even if a moved-from container is empty, it should still 
subsequently allocate from the same resource pool as it did before.
</p>
<blockquote><pre>
std::vector&lt;int, pool&gt; a(500, my_pool);
auto b = std::move(a); // b uses my_pool too.
a.resize(500); // should still use my_pool.
</pre></blockquote>

<p><i>[2016-02, Jacksonville]</i></p>

<p>Marshall will see if this can be resolved editorially.</p>

<p>
After discussion, the editors and I decided that this could not be handled editorially. 
The bit about a moved-from state of an allocator being the same as the original state is a
normative change. I submitted a <a href="https://github.com/cplusplus/draft/pull/727">pull request</a>
to handle the mismatched variables in the table.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 28 &mdash; "Allocator requirements" as indicated:
<blockquote class="note">
<p>
Note there's an editorial error in Table 28 in that line and the surrounding ones. The left column was apparently 
updated to use <tt>u</tt> and the right column is still using <tt>a</tt>/<tt>a1</tt>/<tt>b</tt>.
</p>
</blockquote>
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X u(move(a));<br/>
X u = move(a);</tt>
</td>
<td></td>
<td>
Shall not exit via an exception.
post: <ins><tt>u</tt> is equal to <tt>a</tt> and equal to the prior value of <tt>a</tt></ins><del><tt>a1</tt> 
equals the prior value of <tt>a</tt></del>.
</td>
<td>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>

</blockquote>

<p><i>[2016-06-20, Oulu, Daniel comments]</i></p>

<p>
According to the current working draft, the situation has changed due to changes performed by the project editor, the revised 
resolution has been adjusted to N4594.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to LEWG, as this decision (should allocators only be copyable, not movable) is design.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4594.
</p>

<ol>
<li><p>Change 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 28 &mdash; "Allocator requirements" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X u(std::move(a));<br/>
X u = std::move(a);</tt>
</td>
<td></td>
<td>
Shall not exit via an exception.
post: <ins><tt>u</tt> is equal to <tt>a</tt> and equal to the prior value of <tt>a</tt></ins><del><tt>u</tt> is equal to the prior
value of <tt>a</tt>.</del>.
</td>
<td>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2594" href="2594">2594.</a> Contradicting definition of empty <tt>shared_ptr</tt> on <tt>shared_ptr(nullptr, d)</tt></h3>
<p><b>Section:</b> 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-02-20 <b>Last modified:</b> 2016-06-20 06:06:43 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Latest draft (N4567) 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> p1 says:
</p>
<blockquote>
<p>
A <tt>shared_ptr</tt> object is <em>empty</em> if it does not own a pointer.
</p>
</blockquote>
<p>
Please note that it says "own a pointer". This definition was added as
the resolution for LWG defect <a href="813">813</a>.
<p/>
23.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> p8 says about the effect of
<tt>shared_ptr(nullptr_t p, D d)</tt>:
</p>
<blockquote>
<p>
<i>Effects</i>: Constructs a <tt>shared_ptr</tt> object that <em>owns</em> the object <tt>p</tt> and the deleter <tt>d</tt>.
</p>
</blockquote>
<p>
Please note that it says "<em>owns</em> the object". This was intentionally
changed from "the pointer" as a part of resolution for LWG defect <a href="758">758</a>,
to cover <tt>nullptr_t</tt> case.
<p/>
Since <tt>shared_ptr(nullptr, d)</tt> owns an object of type <tt>nullptr_t</tt>, but does
not own a pointer, it is said as "empty" by a strict reading of the
above mentioned definition in 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> p1.
<p/>
These cause a contradiction:
<p/>
23.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> p9 sets a postcondition
<tt>use_count() == 1</tt> on <tt>shared_ptr(nullptr, d)</tt>. But 
23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> p7 says that the return value of <tt>use_count()</tt>
is "<tt>0</tt> when <tt>*this</tt> is <em>empty</em>".
</p>
<p>
Proposed wording changes:
<p/>
Replace the last 2 words in 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> p1 from
</p>
<blockquote><p>
[&hellip;] <em>empty</em> if it does not own a pointer.
</p></blockquote>
<p>
to
</p>
<blockquote><p>
[&hellip;] <em>empty</em> if it does not own an object.
</p></blockquote>
<p>
Note that <tt>shared_ptr(nullptr_t)</tt> is defined to be empty in synopsis in
23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>.
</p>
<blockquote><pre>
constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
</pre></blockquote>
<p>
It could be less confusing if <tt>shared_ptr(nullptr, d)</tt> could be defined to
be empty. But it seems too late to change that (which means changing
whether the deleter is called or not, see 
<a href="https://stackoverflow.com/questions/11164354/">this Stackoverflow article</a>). 
Then I'm proposing just fix the contradiction.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4594.
</p>

<ol>
<li><p>Change 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> p1 as indicated:</p>

<blockquote>
<p>-1- The <tt>shared_ptr</tt> class template stores a pointer, usually obtained via <tt>new</tt>. <tt>shared_ptr</tt> 
implements semantics of shared ownership; the last remaining owner of the pointer is responsible for destroying the 
object, or otherwise releasing the resources associated with the stored pointer. A <tt>shared_ptr</tt> object is 
<em>empty</em> if it does not own <ins>an object</ins><del>a pointer</del>.
</p>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2595" href="2595">2595.</a> <tt>reverse_iterator::operator[]</tt>'s return type revisited</h3>
<p><b>Section:</b> 27.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a>, 27.5.1.3.12 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opindex">[reverse.iter.opindex]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2016-02-28 <b>Last modified:</b> 2016-04-16 04:04:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterator">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="386">386</a> changed the return type of <tt>reverse_iterator::operator[]</tt> to unspecified. However, 
as of N3066, the return type of a random access iterator's <tt>operator[]</tt> shall be convertible to <tt>reference</tt>; 
thus the return type of <tt>reverse_iterator::operator[]</tt> should be <tt>reference</tt> (and it is in all common
implementations).
<p/>
Suggested resolution: Adjust 27.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a>'s synopsis and 27.5.1.3.12 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opindex">[reverse.iter.opindex]</a> to 
use <tt>reference</tt> instead of <tt><i>unspecified</i></tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Edit 27.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a>, class template <tt></tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Iterator&gt;
  class reverse_iterator {
  public:
    [&hellip;]
    typedef typename iterator_traits&lt;Iterator&gt;::reference reference;
    [&hellip;]
    constexpr <ins>reference</ins><del><i>unspecified</i></del> operator[](difference_type n) const;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Change 27.5.1.3.12 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.opindex">[reverse.iter.opindex]</a> before p1 as indicated:</p>

<blockquote>
<pre>
constexpr <ins>reference</ins><del><i>unspecified</i></del> operator[](
  typename reverse_iterator&lt;Iterator&gt;::difference_type n) const;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2597" href="2597">2597.</a> <tt>std::log</tt> misspecified for complex numbers</h3>
<p><b>Section:</b> 29.5.8 <a href="https://timsong-cpp.github.io/cppwp/complex.transcendentals">[complex.transcendentals]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-03-01 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.transcendentals">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.transcendentals">[complex.transcendentals]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <tt>std::log</tt> is inconsistent for complex numbers, specifically, the Returns clause 
(29.5.8 <a href="https://timsong-cpp.github.io/cppwp/complex.transcendentals">[complex.transcendentals]</a>). On the one hand, it states that the imaginary part of the return value lies 
in the <em>closed</em> interval <tt>[-<i>i</i> &pi;, +<i>i</i> &pi;]</tt>. On the other hand, it says that "the branch 
cuts are along the negative real axis" and "the imaginary part of <tt>log(x)</tt> is <tt>+&pi;</tt> when <tt>x</tt> 
is a negative real number".
</p>
<p>
The inconsistency lies in the difference between the mathematical concept of a branch cut and the nature of floating 
point numbers in C++. The corresponding specification in the C standard makes it clearer that if <tt>x</tt> is a real 
number, then <tt>log(x + 0<i>i</i>) = +&pi;</tt>, but <tt>log(x - 0<i>i</i>) = -&pi;</tt>, i.e. they consider positive 
and negative zero to represent the two different limits of approaching the branch cut from opposite directions. In 
other words, the term "negative real number" is misleading, and in fact there are <em>two distinct</em> real numbers, 
<tt>x + 0<i>i</i></tt> and <tt>x - 0<i>i</i></tt>, that compare equal but whose logarithms differ by <tt>2 &pi; <i>i</i></tt>.
</p>
<p>
The resolution should consist of two parts:
</p>
<ol>
<li><p>Double-check that our usage and definition of "branch cut" is sufficiently unambiguous. The C standard contains 
a lot more wording around this that we don't have in C++.</p></li>
<li><p>Change the Returns clause of <tt>log</tt> appropriately. For example: "When <tt>x</tt> is a negative real number, 
<tt>imag(log(x + 0<i>i</i>))</tt> is <tt>&pi;</tt>, and <tt>imag(log(x - 0<i>i</i>))</tt> is <tt>-&pi;</tt>."</p></li>
</ol>
<p>
Current implementations seem to behave as described in (2). 
(<a href="http://melpon.org/wandbox/permlink/pwBDeGiY3HDtFAh8">Try-it-at-home link</a>)
</p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Move to Open - Thomas to provide wording</p>

<p><i>[2016-11-15, Thomas comments and provides wording]</i></p>

<p>
Following LWG discussion in Issaquah, I now propose to resolve this issue by removing the normative requirement on the 
function limits, and instead adding a note that the intention is to match the behaviour of C. This allows implementations 
to use the behaviour of C without having to specify what floating point numbers really are.
<p/>
The change applies to both <tt>std::log</tt> and <tt>std::sqrt</tt>.
<p/>
Updated try-at-home link, see <a href="http://melpon.org/wandbox/permlink/tVYVUNfeZ1yoFnp8">here</a>.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Minor wording update and status to Tentatively Ready.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Change the "returns" element for <tt>std::log</tt> (29.5.8 <a href="https://timsong-cpp.github.io/cppwp/complex.transcendentals">[complex.transcendentals]</a> p17):</p>

<blockquote>
<pre>
template&lt;class T&gt; complex&lt;T&gt; log(const complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-16- <i>Remarks:</i> The branch cuts are along the negative real axis.
<p/>
-17- <i>Returns:</i> The complex natural (base-&#8495;) logarithm of <tt>x</tt>. For all <tt>x</tt>, <tt>imag(log(x))</tt> 
lies in the interval <tt>[</tt>-&pi;, &pi;<tt>]</tt><del>, and when <tt>x</tt> is a negative real number, <tt>imag(log(x))</tt> 
is &pi;</del>. <ins>[<i>Note:</i> The semantics of <tt>std::log</tt> are intended to be the same in C++ as they are for 
<tt>clog</tt> in C. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change the "returns" element for <tt>std::sqrt</tt> (29.5.8 <a href="https://timsong-cpp.github.io/cppwp/complex.transcendentals">[complex.transcendentals]</a> p25):</p>

<blockquote>
<pre>
template&lt;class T&gt; complex&lt;T&gt; sqrt(const complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-24- <i>Remarks:</i> The branch cuts are along the negative real axis.
<p/>
-25- <i>Returns:</i> The complex square root of <tt>x</tt>, in the range of the right half-plane. <del>If the argument is a
negative real number, the value returned lies on the positive imaginary axis.</del><ins>[<i>Note:</i> The semantics of 
<tt>std::sqrt</tt> are intended to be the same in C++ as they are for <tt>csqrt</tt> in C. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Change the "returns" element for <tt>std::log</tt> (29.5.8 <a href="https://timsong-cpp.github.io/cppwp/complex.transcendentals">[complex.transcendentals]</a> p17):</p>

<blockquote>
<pre>
template&lt;class T&gt; complex&lt;T&gt; log(const complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-16- <i>Remarks:</i> The branch cuts are along the negative real axis.
<p/>
-17- <i>Returns:</i> The complex natural (base-&#8495;) logarithm of <tt>x</tt>. For all <tt>x</tt>, <tt>imag(log(x))</tt> 
lies in the interval <tt>[</tt>-&pi;, &pi;<tt>]</tt><del>, and when <tt>x</tt> is a negative real number, <tt>imag(log(x))</tt> 
is &pi;</del>. <ins>[<i>Note:</i> the semantics of this function are intended to be the same in C++ as they are for 
<tt>clog</tt> in C. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change the "returns" element for <tt>std::sqrt</tt> (29.5.8 <a href="https://timsong-cpp.github.io/cppwp/complex.transcendentals">[complex.transcendentals]</a> p25):</p>

<blockquote>
<pre>
template&lt;class T&gt; complex&lt;T&gt; sqrt(const complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-24- <i>Remarks:</i> The branch cuts are along the negative real axis.
<p/>
-25- <i>Returns:</i> The complex square root of <tt>x</tt>, in the range of the right half-plane. <del>If the argument is a
negative real number, the value returned lies on the positive imaginary axis.</del><ins>[<i>Note:</i> The semantics of 
this function are intended to be the same in C++ as they are for <tt>csqrt</tt> in C. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2599" href="2599">2599.</a> Library incomplete type permission phrase is unclear</h3>
<p><b>Section:</b> 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/declval">[declval]</a>, 23.11.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr">[unique.ptr]</a>, 23.11.1.1.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.dltr.general">[unique.ptr.dltr.general]</a>, 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>, 23.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.weak">[util.smartptr.weak]</a>, 23.11.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2016-03-08 <b>Last modified:</b> 2016-04-16 04:04:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the phrase to grant this permission is:
</p>
<blockquote><p>
The template parameter <tt>T</tt> of <tt><i>LibraryTemplate</i></tt> may be an incomplete type.
</p></blockquote>
<p>
Two problems:
</p>
<ol>
<li><p>The timing is unclear.  We always allow specializations like <tt><i>LibraryTemplate</i>&lt;Incomp&gt;* p;</tt></p></li>
<li><p>To the users of a template, the correct terminology should be "argument" rather than "parameter".</p></li>
</ol>
<p>
Suggested resolution:
</p>
<blockquote><p>
In an instantiation of <tt><i>LibraryTemplate</i></tt>, an incomplete type
may be used as the template argument for the template parameter <tt>T</tt>.
</p></blockquote>
<p>
as shown <a href="https://github.com/cplusplus/draft/pull/304/files">here</a>.
<p/>
Or, to copy <a href=" http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4510.html">N4510's wording</a>:
</p>
<blockquote><p>
An incomplete type <tt>T</tt> may be used when instantiating <tt><i>LibraryTemplate</i></tt>.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2600" href="2600">2600.</a> <tt>ios_base</tt> must store inaccessible iostate flags</h3>
<p><b>Section:</b> 30.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2016-04-16 04:04:53 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base.storage">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
DR <a href="41">41</a>, "Ios_base needs <tt>clear()</tt>, <tt>exceptions()</tt>" stopped short of providing the interface 
suggested in its title, but it did require the underlying state to be stored in <tt>ios_base</tt>. Because <tt>rdstate()</tt> 
is also missing, <tt>ios_base</tt> manipulators relying on <tt>iword</tt> and <tt>pword</tt> cannot detect failure. 
The only safe alternative is to manipulate a derived class, which must be a template.
<p/>
libc++ already provides the interface as a nonconforming extension. libstdc++ implements the internal state but leaves 
it frustratingly inaccessible, as specified. Any conforming implementation should be able to provide the interface 
without ABI problems.
</p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
This is really a request for an (feature) API. Passing to LEWG.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2665" href="2665">2665.</a> <code>remove_filename()</code> post condition is incorrect</h3>
<p><b>Section:</b> 30.10.8.4.5 <a href="https://timsong-cpp.github.io/cppwp/fs.path.modifiers">[fs.path.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2014-06-07 <b>Last modified:</b> 2017-03-19 19:03:20 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  <code>remove_filename()</code> specifies <code>!has_filename()</code> as the post condition.
This post condition is not correct. For example the path <code>"/foo"</code>
has a filename of <code>"foo"</code>. If we remove the filename we get <code>"/"</code>,
and <code>"/"</code> has a filename of <code>"/"</code>.</p>

<p><i>[2014-06-08 Beman supplies an <i>Effects:</i> element.]</i></p>


<p><i>[2014-06-17 Rapperswil LWG will investigate issue at a subsequent meeting.]</i></p>


<p><i>[<b>2016-04  Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
There was concern that the effects wording is not right.  Jonathan provided updated wording.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
  <pre>
    path&amp; <a name="path-remove_filename">remove_filename</a>();
  </pre>
  <blockquote>
    <p>
      <del><i>Postcondition:</i> <code>!has_filename()</code>.</del>
    </p>
    <p>
    <ins>
      <i>Effects:</i> <code>*this = parent_path()</code>, except that if <code>parent_path() == root_path()</code>, <code>clear()</code>.
    </ins>
    </p>
    <p>
      <i>Returns: </i> <code>*this</code>.
    </p>
    <p>
      [<i>Example:</i>
    </p>
    <blockquote>
      <pre>
        <code>std::cout &lt;&lt; path(&quot;/foo&quot;).remove_filename();</code>  // outputs &quot;<code>/</code>&quot;
        std::cout &lt;&lt; path(&quot;/&quot;).<code>remove_</code>filename();     // outputs &quot;&quot;
      </pre>
    </blockquote>
    <p>
      <i>&mdash;end example</i>]
    </p>
  </blockquote>
</blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<pre>
  path&amp; <a name="path-remove_filename">remove_filename</a>();
</pre>
<blockquote>
  <p>
    <del>Postcondition: !has_filename().</del>
  </p>
  <p>
    <ins>Effects: If <code>*this == root_path()</code>, then <code>clear()</code>. Otherwise, <code>*this = parent_path()</code>.</ins>
  </p>
  <p>
    <i>Returns: </i> <code>*this</code>.
  </p>
  <p>
    [<i>Example:</i><br/>
  <blockquote>
    <pre>
      <code>std::cout &lt;&lt; path(&quot;/foo&quot;).remove_filename();</code>  // outputs &quot;<code>/</code>&quot;
      std::cout &lt;&lt; path(&quot;/&quot;).<code>remove_</code>filename();     // outputs &quot;&quot;
    </pre>
  </blockquote><br/>
    <i>&mdash;end example</i>]
  </p>
  </blockquote>
</blockquote>

<p><i>[2016-10-16, Eric reopens and provides improved wording]</i></p>

<p>
The suggested PR is incorrect. <tt>root_path()</tt> removes redundant directory separators.
<p/>
Therefore the condition <tt>*this == root_path()</tt> will fail for <tt>"//foo///"</tt> because <tt>root_path()</tt> 
returns <tt>"//foo/"</tt>. However using <tt>path::compare</tt> instead would solve this problem.
</p>

<p><i>[2016-11-21, Beman comments]</i></p>

<p>
This issue is closely related to CD NB comments US 25, US 37, US 51, US 52, US 53, US 54, and US 60. The Filesystem 
SG in Issaquah recommended that these all be handled together, as they all revolve around the exact meaning of 
"filename" and path decomposition.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 30.10.8.4.5 <a href="https://timsong-cpp.github.io/cppwp/fs.path.modifiers">[fs.path.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
path&amp; remove_filename();
</pre>
<blockquote>
<p>
-5- <i><del>Postcondition</del><ins>Effects</ins>:</i> <del><tt>!has_filename()</tt></del><ins>If 
<tt>this-&gt;compare(root_path()) == 0</tt>, then <tt>clear()</tt>. Otherwise, <tt>*this = parent_path()</tt>.</ins>.
<p/>
-6- <i>Returns:</i> <tt>*this</tt>.
<p/>
-7- [<i>Example:</i>
</p>
<blockquote>
<pre>
std::cout &lt;&lt; path("/foo").remove_filename(); // outputs "/"
std::cout &lt;&lt; path("/").remove_filename(); // outputs ""
</pre>
</blockquote>
<p>
&mdash; <i>end example</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2675" href="2675">2675.</a> <tt>register_callback</tt> can fail</h3>
<p><b>Section:</b> 30.5.3.6 <a href="https://timsong-cpp.github.io/cppwp/ios.base.callback">[ios.base.callback]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2016-04-16 04:04:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>register_callback</tt> allocates memory and so it can fail, but the case is unspecified. libc++ sets
<tt>badbit</tt>, which is consistent with <tt>iword</tt> and <tt>pword</tt>. libstdc++ throws <tt>std::bad_alloc</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2682" href="2682">2682.</a> <code>filesystem::copy()</code> won't create a symlink to a directory</h3>
<p><b>Section:</b> 30.10.15.3 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-04-19 <b>Last modified:</b> 2016-10-16 12:10:00 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.copy">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>(First raised in c++std-lib-38544)</p>

<p><code>filesystem::copy</code> doesn't create a symlink to a directory in this case:</p>

<blockquote>
<code>copy("/", "root", copy_options::create_symlinks);</code>
</blockquote>

<p>
If the first path is a file then a symlink is created, but I think my
implementation is correct to do nothing for a directory. We get to
bullet 30.10.15.3 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a> (3.6) where <code>is_directory(f)</code> is true, but <code>options
== create_symlinks</code>, so we go to the next bullet (3.7) which says
"Otherwise, no effects."
<p/>
I think the case above should either create a symlink, or should
report an error. GNU cp -s gives an error in this case, printing
"omitting directory '/'". An error seems reasonable, you can use
<code>create_symlink</code> to create a symlink to a directory.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
This is related to <a href="2681">2681</a>; and should be considered together.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>Add a new bullet following (3.6) in 30.10.15.3 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a> as shown:</p>

<blockquote>
<ul>
<li><p>If <code>!exists(t)</code>, then <code>create_directory(to, from)</code>.</p></li>
<li><p>Then, iterate over the files in <code>from</code>, as if by <code>for (directory_entry&amp; x :
 directory_iterator(from))</code>, and for each iteration
  <code>copy(x.path(), to/x.path().filename(), options | copy_options::unspecified )</code></p></li>
<li><p><ins>Otherwise, if <code>is_directory(f) &amp;&amp; (options &amp;
copy_options::create_symlinks) != copy_options::none</code>, then report an
error with an <code>error_code</code> argument equal to
<code>make_error_code(errc::is_a_directory)</code>.</ins></p></li>
<li><p>Otherwise, no effects.</p></li>
</ul>
</blockquote>
</blockquote>

<p><i>[2016-10-16, Eric reopens and provides improved wording]</i></p>

<p>
The current PR makes using <tt>copy(...)</tt> to copy/create a directory symlink an error. For example, the following 
is now an error:
</p>
<blockquote><pre>
copy("/", "root", copy_options::create_symlinks);
</pre></blockquote>
<p>
However the current PR doesn't handle the case where both <tt>copy_options::create_symlinks</tt> and 
<tt>copy_options::recursive</tt> are specified. This case is still incorrectly handled by bullet (3.6) [fs.op.copy].
<p/>
I suggest we move the PR before this bullet so that it catches the recursive copy case, since currently the conditions 
are ordered:
</p>
<blockquote>
<p>
3.6 Otherwise if <tt>is_directory(f) &amp;&amp; (bool(options &amp; copy_options::recursive) || ...)</tt><br/>
3.X Otherwise if <tt>is_directory(f) &amp;&amp; bool(options &amp; copy_options::create_symlinks)</tt>
</p>
</blockquote>
<p>
So 3.6 catches <tt>create_symlinks | recursive</tt> but I believe we want 3.X to handle it instead.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Add a new bullet before (3.6) in 30.10.15.3 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a> as shown:</p>

<blockquote>
<ol style="list-style-type: none">
<li><p>(3.5) &mdash; Otherwise, if <tt>is_regular_file(f)</tt>, then:</p>
<blockquote>
[&hellip;]
</blockquote>
</li>
<li><p><ins>(3.?) &mdash; Otherwise, if</ins></p>
<blockquote>
<blockquote><pre>
<ins>is_directory(f) &amp;&amp; 
(options &amp; copy_options::create_symlinks) != copy_options::none</ins>
</pre></blockquote>
<p> 
<ins>then report an error with an <code>error_code</code> argument equal to
<code>make_error_code(errc::is_a_directory)</code>.</ins></p></blockquote></li>
<li><p>(3.6) &mdash; Otherwise, if</p>
<blockquote>
<blockquote><pre>
is_directory(f) &amp;&amp;
((options &amp; copy_options::recursive) != copy_options::none ||
options == copy_options::none)
</pre></blockquote>
<p>
then:
</p>
</blockquote>
<ol style="list-style-type: none">
<li><p>(3.6.1) &mdash; If <code>!exists(t)</code>, then <code>create_directory(to, from)</code>.</p></li>
<li><p>(3.6.2) &mdash; Then, iterate over the files in <code>from</code>, as if by <code>for (directory_entry&amp; x :
 directory_iterator(from))</code>, and for each iteration</p>
<blockquote><pre>
copy(x.path(), to/x.path().filename(), options | copy_options::<i>unspecified</i>)
</pre></blockquote>
</li>
</ol>
</li>
<li><p>(3.7) &mdash; Otherwise, for the signature with argument <tt>ec</tt>, <tt>ec.clear()</tt>.</p></li>
<li><p>(3.8) &mdash; Otherwise, no effects.</p></li>
</ol>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2690" href="2690">2690.</a> <tt>invoke&lt;R&gt;</tt></h3>
<p><b>Section:</b> 23.14.4 <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2016-03-25 <b>Last modified:</b> 2016-09-06 19:09:22 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.invoke">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#func.invoke">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4169.html">N4169</a>
the author dropped the <tt>invoke&lt;R&gt;</tt> support by claiming
that it's an unnecessary cruft in TR1, obsoleted by C++11
type inference.  But now we have some new business went
to *<tt><i>INVOKE</i></tt>*<tt>(f, t1, t2, ..., tN, R)</tt>, that is to discard the
return type when <tt>R</tt> is <tt>void</tt>. This form is very useful, or
possible even more useful than the basic form when
implementing a call wrapper. Also note that the optional
<tt>R</tt> support is already in <tt>std::is_callable</tt> and
<tt>std::is_nothrow_callable</tt>.
</p>

<p><i>[2016-07-31, Tomasz Kami&nacute;ski comments]</i></p>

<p>
The lack of <tt>invoke&lt;R&gt;</tt> was basically a result of the concurrent publication of the never revision 
of the paper and additional special semantics of <tt><i>INVOKE</i>(f, args..., void)</tt>.
<p/>
In contrast to existing <tt>std::invoke</tt> function, the proposed <tt>invoke&lt;R&gt;</tt> version is not 
SFINAE friendly, as elimination of the standard version of invoke is guaranteed by <tt>std::result_of_t</tt> 
in the result type that is missing for proposed <tt>invoke&lt;R&gt;</tt> version. To provide this guarantee, 
following remarks shall be added to the specification:
</p>
<blockquote>
<p>
<i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_callable_v&lt;F(Args...), R&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>

<p><i>[2016-08-01, Tomasz Kami&nacute;ski and Zhihao Yuan update the proposed wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>/2, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  <i>// 20.12.3, invoke:</i>
  template &lt;class F, class... Args&gt; result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);
  <ins>template &lt;class R, class F, class... Args&gt; R invoke(F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
</blockquote>
</li>

<li><p>Add the following sequence of paragraphs after 23.14.4 <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a>/1 as indicated:</p>

<blockquote>
<pre>
<ins>template &lt;class R, class F, class... Args&gt; R invoke(F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt><i>INVOKE</i>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)..., R)</tt> 
(23.14.3 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>).</ins>
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_callable_v&lt;F(Args...), R&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-09-04, Tomasz Kami&nacute;ski comments and improves wording]</i></p>

<p>
The usage of <tt>is_callable_v&lt;F(Args...), R&gt;</tt> causes problem in situation when either <tt>F</tt> or <tt>Args</tt> 
is an abstract type and the function type <tt>F(Args...)</tt> cannot be formed or when one of the args is <i>cv</i>-qualified, 
as top-level <i>cv</i>-qualification for function parameters is dropped by language rules. It should use 
<tt>is_callable_v&lt;F&amp;&amp;(Args&amp;&amp;...), R&gt;</tt> instead.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>/2, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  <i>// 20.12.3, invoke:</i>
  template &lt;class F, class... Args&gt; result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);
  <ins>template &lt;class R, class F, class... Args&gt; R invoke(F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
</blockquote>
</li>

<li><p>Add the following sequence of paragraphs after 23.14.4 <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a>/1 as indicated:</p>

<blockquote>
<pre>
<ins>template &lt;class R, class F, class... Args&gt; R invoke(F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt><i>INVOKE</i>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)..., R)</tt> 
(23.14.3 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>).</ins>
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_callable_v&lt;F&amp;&amp;(Args&amp;&amp;...), R&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2691" href="2691">2691.</a> <tt>money_base::space</tt> and <tt>do_put</tt>: U+0020 versus <tt>fill</tt></h3>
<p><b>Section:</b> 25.4.6.3 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct">[locale.moneypunct]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-12 <b>Last modified:</b> 2016-05-22 15:05:38 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.moneypunct">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct">[locale.moneypunct]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The description of <tt>money_base::space</tt> is that "at least one space is required at that position." 
(N4582 subclause 22.4.6.3 [locale.moneypunct] paragraph 2)
<p/>
When formatting for output (25.4.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.put.virtuals">[locale.money.put.virtuals]</a>), it is not clear that
</p>
<ol style="list-style-type:lower-alpha">
<li><p>
"the number of characters generated for the specified format" (excluding fill padding) includes exactly 
one character for <tt>money_base::space</tt> (if present), and
</p></li>
<li><p>
all characters corresponding to <tt>money_base::space</tt> (excluding fill padding) are copies of <tt>fill</tt>.
</p></li>
</ol>
<p>
In particular, there is implementation divergence over point (b) as to whether U+0020 or <tt>fill</tt> should be used.
Further, should a character other than <tt>fill</tt> be used, it is unclear when "the fill characters are 
placed where <tt>none</tt> or <tt>space</tt> appears in the formatting pattern", whether the fill characters are placed 
at the beginning or the end of the "space field".
<p/>
I believe that a strict interpretation of the current wording supports U+0020; however, <tt>fill</tt> is more likely 
to be the pragmatic choice.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Change 25.4.6.3 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct">[locale.moneypunct]</a> paragraph 2 as indicated:</p>

<blockquote>
<p>
-2- Where <tt>none</tt> or <tt>space</tt> appears, white space is permitted in the format, except where <tt>none</tt> 
appears at the end, in which case no white space is permitted. <ins>For input, the value <tt>space</tt> indicates that 
at least one space is required at that position. For output, the value <tt>space</tt> indicates one instance of the 
fill character (25.4.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.put.virtuals">[locale.money.put.virtuals]</a>).</ins><del>The value <tt>space</tt> indicates that at least one 
space is required at that position</del>. Where <tt>symbol</tt> appears, the sequence of characters returned by 
<tt>curr_symbol()</tt> is permitted, and can be required. Where <tt>sign</tt> appears, the first (if any) of the 
sequence of characters returned by <tt>positive_sign()</tt> or <tt>negative_sign()</tt> (respectively as the monetary 
value is non-negative or negative) is required. Any remaining characters of the sign sequence are required after all 
other format components. Where <tt>value</tt> appears, the absolute numeric monetary value is required.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2692" href="2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 20.4.2.1.4 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2693" href="2693">2693.</a> <tt>constexpr</tt> for various <tt>std::complex</tt> arithmetic and value operators</h3>
<p><b>Section:</b> 29.5 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Oliver Rosten <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This modification will allow complex-number arithmetic to be performed at compile time. From a mathematical 
standpoint, it is natural (and desirable) to treat complex numbers on the same footing as the reals. 
From a programming perspective, this change will broaden the scope in which <tt>std::complex</tt> can be used, 
allowing it to be smoothly incorporated into classes exploiting <tt>constexpr</tt>.
<p/>
Suggested resolution:
<p/>
The following functions in the <tt>std::complex</tt> namespace should be made <tt>constexpr</tt>:
</p>
<ol>
<li><p>
Section 29.5.5 <a href="https://timsong-cpp.github.io/cppwp/complex.member.ops">[complex.member.ops]</a>: The member (arithmetic) operators 
{<tt>+=</tt>, <tt>-=</tt>, <tt>/=</tt>, <tt>*=</tt>}
</p></li>
<li><p>
Section 29.5.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a>: The arithmetic operators unary operators {<tt>+</tt>, <tt>-</tt>} 
and binary operators {<tt>+</tt>, <tt>-</tt>, <tt>/</tt>, <tt>*</tt>};
</p></li>
<li><p>
Section 29.5.7 <a href="https://timsong-cpp.github.io/cppwp/complex.value.ops">[complex.value.ops]</a>: The 'value' operators <tt>abs</tt>, <tt>norm</tt>, and <tt>conj</tt>.
</p></li>
</ol>
<p>
In terms of modification of the standard, all that is required is the insertion of the <tt>constexpr</tt> specifier 
in the relevant parts of:
</p>
<ol>
<li><p>
Section 29.5.1 <a href="https://timsong-cpp.github.io/cppwp/complex.syn">[complex.syn]</a> (the Header synopsis), together with the corresponding entries in sections 
29.5.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a> and 29.5.7 <a href="https://timsong-cpp.github.io/cppwp/complex.value.ops">[complex.value.ops]</a>.
</p></li>
<li><p>
Sections 29.5.2 <a href="https://timsong-cpp.github.io/cppwp/complex">[complex]</a>, 29.5.3 <a href="https://timsong-cpp.github.io/cppwp/complex.special">[complex.special]</a> (class template and specializations), together 
with the corresponding entries in section 29.5.5 <a href="https://timsong-cpp.github.io/cppwp/complex.member.ops">[complex.member.ops]</a>.
</p></li>
</ol>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
This kind of work (new feature) has been being done via papers rather than via the issues list.
</p>
<p>
Walter believes that he knows someone who would be willing to write such a paper.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2695" href="2695">2695.</a> "As if" unclear in [member.functions]</h3>
<p><b>Section:</b> 20.5.5.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-15 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#member.functions">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4582 subclause 17.6.5.5 [member.functions], the requirement that:
</p>
<blockquote><p>
any call to the member function that would select an overload from the set of declarations described in this 
standard behaves as if that overload were selected
</p></blockquote>
<p>
is unclear in the extent of the "as if". For example, in providing:
</p>
<blockquote><pre>
basic_string(const charT* s);
</pre></blockquote>
<p>
for a one-argument call to:
</p>
<blockquote><pre>
basic_string(const charT* s, const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
it can be read that an implementation may be required to call the copy constructor for the allocator since 
the core language rules for copy elision would not allow the "a" argument to be constructed directly into 
the member used to store the allocator.
<p/>
Clarification (even if just a note) would be appreciated.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
This is related to issue <a href="2563">2563</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2697" href="2697">2697.</a> [concurr.ts] Behavior of <tt>future/shared_future</tt> unwrapping constructor when given an invalid <tt>future</tt></h3>
<p><b>Section:</b> 99 [concurr.ts::futures.unique_future], 99 [concurr.ts::futures.shared_future] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-04-22 <b>Last modified:</b> 2017-02-22 18:02:43 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concurr.ts::futures.unique_future">active issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#concurr.ts::futures.unique_future">issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: concurr.ts</b></p>

<p>
In the concurrency TS, the future/shared_future unwrapping constructors
</p>
<blockquote><pre>
future(future&lt;future&lt;R&gt;&gt;&amp;&amp;) noexcept;
shared_future(future&lt;shared_future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre></blockquote>
<p>
appear to implicitly require <tt>rhs</tt> be valid (e.g., by referring to its shared state, and by requiring a 
<tt>valid() == true</tt> postcondition). However, they are also marked <tt>noexcept</tt>, suggesting that they 
are wide-contract, and also makes the usual suggested handling for invalid futures, throwing a 
<tt>future_error</tt>, impossible.
<p/>
Either the <tt>noexcept</tt> should be removed, or the behavior with an invalid future should be specified.
</p>

<p>
<strong>Original resolution alternative #1 [NOT CHOSEN]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4577">N4577</a>.
</p>

<p>Strike the <tt>noexcept</tt> on these constructors in 99 [concurr.ts::futures.unique_future]/1-2 and 
99 [concurr.ts::futures.shared_future]/1-2, and optionally add a <i>Requires</i>: <tt>rhs.valid() == true</tt> 
paragraph.</p>
</blockquote>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: We prefer alternative #2 - Move to review</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4577">N4577</a>.
</p>

<blockquote class="note">
<p>
Alternative #2: Specify that an empty (<tt>shared_</tt>)<tt>future</tt> object is constructed if <tt>rhs</tt> is invalid, and adjust 
the postcondition accordingly.
</p>
</blockquote>
<ol>
<li><p>Edit 99 [concurr.ts::futures.unique_future] as indicated:</p>

<blockquote><pre>
future(future&lt;future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>If <tt>rhs.valid() == false</tt>, constructs an empty <tt>future</tt> object that does not 
refer to a shared state. Otherwise, c</ins><del>C</del>onstructs a <tt>future</tt> object from the shared state 
referred to by <tt>rhs</tt>. The <tt>future</tt> becomes ready when one of the following occurs:
</p>
<ul>
<li><p>Both the <tt>rhs</tt> and <tt>rhs.get()</tt> are ready. The value or the exception from
<tt>rhs.get()</tt> is stored in the <tt>future</tt>'s shared state.</p></li>
<li><p><tt>rhs</tt> is ready but <tt>rhs.get()</tt> is invalid. An exception of type
<tt>std::future_error</tt>, with an error condition of <tt>std::future_errc::broken_promise</tt>
is stored in the <tt>future</tt>'s shared state.</p></li>
</ul>
<p>
-4- <i>Postconditions</i>:
</p>
<ul>
<li><p><del><tt>valid() == true</tt></del><ins><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> prior to 
the constructor invocation.</ins>.</p></li>
<li><p><tt>rhs.valid() == false</tt>.</p></li>
</ul>
</blockquote>
</blockquote>
</li>

<li><p>Edit 99 [concurr.ts::futures.shared_future] as indicated:</p>

<blockquote><pre>
shared_future(future&lt;shared_future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>If <tt>rhs.valid() == false</tt>, constructs an empty <tt>shared_future</tt> object that does not 
refer to a shared state. Otherwise, c</ins><del>C</del>onstructs a <tt>shared_future</tt> object from the shared state 
referred to by <tt>rhs</tt>. The <tt>shared_future</tt> becomes ready when one of the following occurs:
</p>
<ul>
<li><p>Both the <tt>rhs</tt> and <tt>rhs.get()</tt> are ready. The value or the exception from
<tt>rhs.get()</tt> is stored in the <tt>shared_future</tt>'s shared state.</p></li>
<li><p><tt>rhs</tt> is ready but <tt>rhs.get()</tt> is invalid. The <tt>shared_future</tt>
stores an exception of type <tt>std::future_error</tt>, with an error condition of
<tt>std::future_errc::broken_promise</tt>.</p></li>
</ul>
<p>
-4- <i>Postconditions</i>:
</p>
<ul>
<li><p><del><tt>valid() == true</tt></del><ins><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> prior to 
the constructor invocation.</ins>.</p></li>
<li><p><tt>rhs.valid() == false</tt>.</p></li>
</ul>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2702" href="2702">2702.</a> <tt>num_put::do_put(..., bool)</tt> performs ill-formed <tt>do_put</tt> call</h3>
<p><b>Section:</b> 25.4.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-07 <b>Last modified:</b> 2016-05-22 15:05:38 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The call to <tt>do_put(out, str, fill, (int)val)</tt> in N4582 subclause 25.4.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> 
paragraph 6 cannot select a best viable function in overload resolution given the overloads listed for 
<tt>do_put</tt> in 25.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.nm.put">[locale.nm.put]</a>.
<p/>
There is implementation divergence:
</p>
<ul>
<li><p>Some implementations call the <tt>long</tt> overload (as overriden);</p></li>
<li><p>some implementations call the <tt>unsigned long</tt> overload (as overriden);</p></li>
<li><p>some implementations call something else.</p></li>
</ul>
<p>
It appears that the resolution to DR <a href="359">359</a> attempted a fix; however, the relevant portion of the 
change was not applied to the WP.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2703" href="2703">2703.</a> No provision for fill-padding when <tt>boolalpha</tt> is set</h3>
<p><b>Section:</b> 25.4.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-07 <b>Last modified:</b> 2016-05-22 15:05:38 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4582 subclause 25.4.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> paragraph 6 makes no provision for fill-padding in its 
specification of the behaviour when <tt>(str.flags() &amp; ios_base::boolalpha) != 0</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2705" href="2705">2705.</a> Questionable precondition on Sequence containers <tt>a.assign(n, t)</tt></h3>
<p><b>Section:</b> 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-05-08 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Please look through the following modifications on a value <tt>v</tt> of type <tt>vector&lt;T&gt;</tt>:
</p>
<blockquote><pre>
assert(v.size() &gt; 0);
v.push_back(v[0]);
v.insert(v.begin(), v[0]);
v.resize(v.size() * 2, v[0]);
v.assign(v.size() * 2, v[0]);
</pre></blockquote>
<p>
All of these use an element of itself which may be moved or destroyed by
the modification.
<p/>
From what I see so far, the first three are required to work. Please
see library issue <a href="526">526</a> for validity of them.
<p/>
But only the last one is undefined because it violates a precondition of
a sequence container operation. I think this is too subtle.
<p/>
Should it be like that, really?
<p/>
The precondition is in Table 107 "Sequence container requirements" at the next 
of 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> p3.
</p>
<blockquote>
<p>
In Tables 107 and 108, <tt>X</tt> denotes a sequence container class,
<tt>a</tt> denotes a value of <tt>X</tt> containing elements of type <tt>T</tt>,
[&hellip;] <tt>n</tt> denotes a value of <tt>X::size_type</tt>,
[&hellip;] <tt>t</tt> denotes an lvalue or a <tt>const</tt> rvalue of <tt>X::value_type</tt>,
[&hellip;]
</p>
<p>[&hellip;]</p>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>a.assign(n, t)</tt>
</td>
<td><tt>void</tt></td>
<td>
<i>Requires</i>: <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>X</tt> and <tt>CopyAssignable</tt>.<br/>
pre: <tt>t</tt> is not a reference into <tt>a</tt>.<br/>
Replaces elements in <tt>a</tt> with <tt>n</tt> copies of <tt>t</tt>.
</td>
</tr>
</table>
</blockquote>
<p>
I looked into the following implementations:
</p>
<ul>
<li><p>
libc++ relies on the precondition.
<p/>
It deallocates first on <tt>n &gt; capacity()</tt> case,
see <a href="https://github.com/llvm-mirror/libcxx/blob/release_38/include/vector#L1415">here</a>.
</p></li>
<li><p>
libstdc++ doesn't rely on the precondition.
<p/>
It creates temporary <tt>vector(n, t)</tt> and <tt>swap()</tt>
on <tt>n &gt; capacity()</tt> case, see
<a href="https://github.com/gcc-mirror/gcc/blob/gcc_5_3_0_release/libstdc%2B%2B-v3/include/bits/vector.tcc#L223">here</a>.
</p></li>
<li><p>
MSVC relies on the precondition.
<p/>
It unconditionally does <tt>clear()</tt> and then <tt>insert(begin(), n, t)</tt>.
I looked into my local "%PROGRAMFILES(X86)%/Microsoft Visual Studio 14.0/VC/include/vector".
</p></li>
</ul>
<p>
One drawback of libstdc++ implementation, I could find so far, is
possibly increased peek memory usage (both old and new buffer exist at
the same time). But, because the same can happen on the most other
modifications, it seems a reasonable trade-off to remove the
precondition to fill the subtle gap. Users who really needs less memory
usage can do <tt>clear()</tt> and <tt>insert()</tt> by themselves.
<p/>
I also found that <tt>basic_string::assign(n, c)</tt> is safe on this point.
At 24.3.2.6.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> p17:
</p>
<blockquote>
<pre>
basic_string&amp; assign(size_type n, charT c);
</pre>
<blockquote>
<p>
<i>Effects</i>: Equivalent to <tt>assign(basic_string(n, c))</tt>.
<p/>
<i>Returns</i>: <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
<p>
This can be seen as another gap.
<p/>
Looking back on the history, I found that the definition of <tt>assign(n, t)</tt>
was changed at C++14 for library issue <a href="2209">2209</a>. There were more restricting 
definitions like this:
</p>
<blockquote>
<pre>
void assign(size_type n, const T&amp; t);
</pre>
<blockquote>
<p>
<i>Effects</i>:
</p>
<blockquote><pre>
erase(begin(), end());
insert(begin(), n, t);
</pre></blockquote>
</blockquote>
</blockquote>
<p>
I think the precondition was probably set to accept this old definition
and is not required inherently. And if the less memory usage was really
intended, the standard is now underspecifying about that.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
Howard believes this should be NAD, but we tabled the discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>In 26.2.3 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, edit Table 107 (Sequence container requirements) as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>a.assign(n, t)</tt>
</td>
<td><tt>void</tt></td>
<td>
<i>Requires</i>: <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>X</tt> and <tt>CopyAssignable</tt>.<br/>
<del>pre: <tt>t</tt> is not a reference into <tt>a</tt>.</del><br/> 
Replaces elements in <tt>a</tt> with <tt>n</tt> copies of <tt>t</tt>.
</td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2708" href="2708">2708.</a> <tt>recursive_directory_iterator::recursion_pending()</tt> is incorrectly specified</h3>
<p><b>Section:</b> 30.10.14.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-05-09 <b>Last modified:</b> 2017-03-19 19:03:20 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.rec.dir.itr.members">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <tt>recursion_pending()</tt> says (30.10.14.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a>/24):
</p>
<blockquote><p>
<i>Returns</i>: <tt>true</tt> if <tt>disable_recursion_pending()</tt> has not been called subsequent to the prior construction 
or increment operation, otherwise <tt>false</tt>.
</p></blockquote>
<p>
This language does not take into account cases where the prior construction was a copy construction from a iterator, 
<tt>it</tt>, where <tt>it.recursion_pending() == false</tt>. 
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Open</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 30.10.14.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> as indicated:</p>

<blockquote>
<pre>
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Postcondition</i>: <del><tt>options() == options</tt> for the signatures with a <tt>directory_options</tt> argument, 
otherwise <tt>options() == directory_options::none</tt>.</del>
</p>
<ul>
<li><p><ins><tt>options() == options</tt> for the signatures with a <tt>directory_options</tt> argument, otherwise 
<tt>options() == directory_options::none</tt>.</ins></p></li>
<li><p><ins><tt>recursion_pending() == true</tt>.</ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The following changes the specification of <tt>recursion_pending()</tt> seemingly recursive. 
Perhaps it would be easier to specify <tt>recursion_pending()</tt> in terms of a exposition only member in 
<tt>recursive_directory_iterator</tt>.]
</p>
</blockquote>
<pre>
bool recursion_pending() const;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-24- <i>Returns</i>: <del><tt>true</tt> if <tt>disable_recursion_pending()</tt> has not been called subsequent to the 
prior construction or increment operation, otherwise <tt>false</tt></del><ins><tt>false</tt> if 
<tt>disable_recursion_pending()</tt> has been called subsequent to the prior construction or increment operation, 
otherwise the value of <tt>recursion_pending()</tt> set by that operation</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-27- <i>Effects</i>: As specified by Input iterators (24.2.3), except that: [&hellip;]
<p/>
<ins>-?- <i>Postcondition</i>: <tt>recursion_pending() == true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2713" href="2713">2713.</a> More missing allocator-extended constructors for unordered containers</h3>
<p><b>Section:</b> 26.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-20 <b>Last modified:</b> 2016-06-28 13:06:39 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of LWG <a href="2210">2210</a> missed constructors accepting a range or initializer list and allocator.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Add to the synopsis in 26.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_map(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_map(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 26.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_multimap(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_multimap(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 26.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_set(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_set(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 26.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_multiset(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_multiset(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2016-06, Oulu &mdash; Daniel comments and provides new wording]</i></p>

<p>
During the LWG discussion of this issue it has been observed, that the interpretation of the embedded <i>see below</i>
is not really clear and that we should split declaration and definition of the new overloads, so that we have a place
that allows us to specify what "<i>see below</i>" stands for. In addition, the new wording wraps the "<i>see below</i>"
as "<tt>size_type(<i>see below</i>)</tt>" to clarify the provided expression type, similar as we did for the default
constructor of <tt>unordered_map</tt>.
</p>

<p><i>[Oulu, 2016-06]</i></p>

<p>Alisdair to review wording.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Add to the synopsis in 26.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 26.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_map(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_map(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 26.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 26.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multimap(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multimap(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 26.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 26.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_set(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_set(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 26.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multiset(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multiset(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="2714" href="2714">2714.</a> <tt>complex</tt> stream extraction underspecified</h3>
<p><b>Section:</b> 29.5.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-05-23 <b>Last modified:</b> 2016-06-20 16:06:58 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.ops">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>operator&gt;&gt;(istream&amp;, complex&lt;T&gt;&amp;)</tt> is extremely short on details. 
It currently reads, in its entirety (29.5.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a>/12-15):
</p>
<blockquote class="note">
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp; operator>>(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<i>Effects:</i> Extracts a complex number <tt>x</tt> of the form: <tt>u</tt>, <tt>(u)</tt>, or <tt>(u,v)</tt>, 
where <tt>u</tt> is the real part and <tt>v</tt> is the imaginary part (30.7.4.2 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted">[istream.formatted]</a>).
<p/>
<i>Requires:</i> The input values shall be convertible to <tt>T</tt>.
<p/>
If bad input is encountered, calls <tt>is.setstate(ios_base::failbit)</tt> (which may throw <tt>ios::failure</tt> 
(30.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a>)).
<p/>
<i>Returns:</i> <tt>is</tt>.
<p/>
<i>Remarks:</i> This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace 
is specified to be the same for each of the simpler extractions.
</p>
</blockquote>
</blockquote>
<p>
It is completely unclear:
</p>
<ul>
<li>which "simpler extractions" are performed,</li>
<li>how the extracted characters are matched to the special characters <tt>'('</tt>, <tt>')'</tt> and <tt>','</tt> 
(by <tt>==</tt>, or by <tt>traits::eq</tt>),</li>
<li>what is left in the stream on failure. (For example, with <tt>"(0, 0]"</tt>, libstdc++ extracts the <tt>]</tt> 
while libc++ leaves it in the stream.)</li>
</ul>


<p><b>Proposed resolution:</b></p>
<blockquote class="note">
<i>Drafting note:</i> the following wording is based on:
<ul>
<li> Characters are extracted using <tt>operator&gt;&gt;</tt> and compared using <tt>traits::eq</tt>.</li>
<li> Mismatched characters are returned to the stream. </li>
</ul>
</blockquote>
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Replace 29.5.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a>/12-15 with the following paragraphs:</p>

<blockquote>
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator>>(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-?- <i>Effects:</i> First, extracts a character from <tt>is</tt>.
<ul>
<li>If the character extracted is equal to <tt>is.widen('(')</tt>, extracts an object <tt>u</tt> of type <tt>T</tt> from <tt>is</tt>, then extracts a character from <tt>is</tt>.
<ul>
    <li>
    If this character is equal to <tt>is.widen(')')</tt>, then assigns <tt>complex&lt;T&gt;(u)</tt> to <tt>x</tt>.
    </li>
    <li>
      Otherwise, if this character is equal to <tt>is.widen(',')</tt>, extracts an object <tt>v</tt> of type <tt>T</tt> from <tt>is</tt>,
      then extracts a character from <tt>is</tt>.
      If this character is equal to <tt>is.widen(')')</tt>, then assigns <tt>complex&lt;T&gt;(u, v)</tt> to <tt>x</tt>;
      otherwise returns the character to <tt>is</tt> and the extraction fails.
    </li>
    <li>
      Otherwise, returns the character to <tt>is</tt> and the extraction fails.
    </li>
  </ul>
</li>
<li> Otherwise, returns the character to <tt>is</tt>, extracts an object <tt>u</tt> of type <tt>T</tt> from <tt>is</tt>, and assigns <tt>complex&lt;T&gt;(u)</tt> to <tt>x</tt>.
</li>
</ul>
In the description above, characters are extracted from <tt>is</tt> as if by <tt>operator&gt;&gt;</tt> (99 [istream::extractors]), and returned
to the stream as if by <tt>basic_istream::putback</tt> (30.7.4.3 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a>). Character equality is determined using <tt>traits::eq</tt>.
An object <tt>t</tt> of type <tt>T</tt> is extracted from <tt>is</tt> as if by <tt> is &gt;&gt; t</tt>.
<p/>
If any extraction operation fails, no further operation is performed and the whole extraction fails.
<p/>
On failure, calls <tt>is.setstate(ios_base::failbit)</tt> (which may throw <tt>ios::failure</tt>
(30.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a>)).
<p/>
-?- <i>Returns:</i> <tt>is</tt>.
<p/>
-?- [<i>Note</i>: This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace
is specified to be the same for each of the simpler extractions. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2717" href="2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-06-05 16:06:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





<hr>
<h3><a name="2730" href="2730">2730.</a> <tt>numeric_limits</tt> primary template definition</h3>
<p><b>Section:</b> 21.3.4 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-06-09 <b>Last modified:</b> 2017-02-25 12:02:21 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.limits">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've received this report at the <a href="mailto:cxxeditor@gmail.com">project editor mail alias</a>, and it seems like it may be worthy of a LWG issue:
</p>
<blockquote class="note">
<p>
I recently had this problem: 
</p>
<ul>
<li>I was storing data in a vector of <tt>__uint128_t</tt>s</li>
<li>I used a sorting library which used <tt>numeric_limits&lt;T&gt;::max()</tt> as a sentinel value</li>
<li>GCC's libstdc++ provides a <tt>numeric_limits</tt> specialisation for that type, but</li>
<li>Clang's libc++ does not.</li>
</ul>
<p>
This broke the sorting for me on different platforms, and it was quite difficult to determine why. If the default 
<tt>numeric_limits</tt> didn't default to <tt>0</tt>s and <tt>false</tt> values (18.3.2.4 of N4582), and instead 
<tt>static_assert</tt>ed, causing my code to not compile, I would have found the solution immediately.
<p/>
I know that <tt>__uint128_t</tt> is non-standard, so neither GCC nor Clang is doing the wrong thing nor the right thing 
here. I could just submit a patch to libc++ providing the specialisations, but it doesn't fix the problem at its core.
<p/>
I am wondering, what is the rationale behind the defaults being <tt>0</tt> and <tt>false</tt>? It seems like it is 
inviting a problem for any future numeric types, whether part of a library, compiler extension, and possibly even 
future updates to C++'s numeric types. I think it would be much better to prevent code that tries to use 
unspecified <tt>numeric_limits</tt> from compiling.
</p>
</blockquote>
<p>
An alternative to this suggestion would be to still define the primary template, but not provide any of the members 
except <tt>is_specialized</tt>. Either way, this would make <tt>numeric_limits</tt> members SFINAEable.
<p/>
Along the same lines, one might wonder why the members that only make sense for floating-point types are required to 
be defined to nonsense values for integer types.
</p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: This looks like a good idea. Jonathan and Marshall will do post C++17 implementations and report back.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2731" href="2731">2731.</a> Existence of <tt>lock_guard&lt;MutexTypes...&gt;::mutex_type</tt> typedef unclear</h3>
<p><b>Section:</b> 33.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-06-13 <b>Last modified:</b> 2016-08-01 18:08:48 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.lock.guard">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis of 33.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a> the <tt>mutex_type</tt> typedef is specified as follows:
</p>
<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class lock_guard {
public:
  typedef Mutex mutex_type; <i>// If</i> MutexTypes... <i>consists of the single type</i> Mutex
  [&hellip;]
};
</pre>
</blockquote>
<p>
The comment seems ambiguous as it could mean either:
</p>
<ol>
<li><tt>sizeof...(MutexTypes) == 1</tt>.</li>
<li><tt>sizeof...(MutexTypes) &gt;= 1</tt> and every type in <tt>MutexTypes...</tt> is the same type.</li>
</ol>
<p>
I originally took the language to mean (2), but upon further review it seems that (1) is the intended interpretation, 
as suggested in the LEWG discussion in <a href="http://wiki.edg.com/bin/view/Wg21lenexa/N4470">Lenexa</a>.
<p/>
I think the language should be clarified to prevent implementation divergence.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Edit 33.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a>/1, class template <tt>lock_guard</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class lock_guard {
public:
  typedef Mutex mutex_type; <i>// <ins>Only i</ins><del>I</del>f</i> MutexTypes... <i><del>consists of the</del><ins>expands to a</ins> single type</i> <tt>Mutex</tt>
  [&hellip;]
};
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2734" href="2734">2734.</a> Questionable specification in [fs.path.concat]</h3>
<p><b>Section:</b> 30.10.8.4.4 <a href="https://timsong-cpp.github.io/cppwp/fs.path.concat">[fs.path.concat]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-06-16 <b>Last modified:</b> 2017-03-19 19:03:20 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.10.8.4.4 <a href="https://timsong-cpp.github.io/cppwp/fs.path.concat">[fs.path.concat]</a> specifies that the postcondition for
</p>
<blockquote>
<pre>
path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(const value_type* x);
path&amp; operator+=(value_type x);
template&lt;class Source&gt;
path&amp; operator+=(const Source&amp; x);
template&lt;class EcharT&gt;
path&amp; operator+=(EcharT x);
template&lt;class Source&gt; 
path&amp; concat(const Source&amp; x); 
template&lt;class InputIterator>
path&amp; concat(InputIterator first, InputIterator last);
</pre>
</blockquote>
<p>
is
</p>
<blockquote>
<p>
<tt>native() == prior_native</tt> + <i>effective-argument</i>
</p>
</blockquote>
<p>
where <i>effective-argument</i> is
</p>
<ol>
<li>if <tt>x</tt> is present and is <tt>const path&amp;</tt>, <tt>x.native()</tt>; otherwise</li>
<li>if <tt>source</tt> is present, the effective range of <tt>source</tt> (30.10.8.3 <a href="https://timsong-cpp.github.io/cppwp/fs.path.req">[fs.path.req]</a>); otherwise,</li>
<li>if <tt>first</tt> and <tt>last</tt> are present, the range <tt>[first, last)</tt>; otherwise,</li>
<li><tt>x</tt></li>
</ol>
<p>
It also says that
</p>
<blockquote>
<p>
If the value type of <i>effective-argument</i> would not be <tt>path::value_type</tt>, the actual argument or 
argument range is first converted (30.10.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.type.cvt">[fs.path.type.cvt]</a>) so that <i>effective-argument</i> has value 
type <tt>path::value_type</tt>.
</p>
</blockquote>
<p>
There are several problems with this specification:
<p/>
First, there is no overload taking "<tt>source</tt>" (note the lower case); all single-argument overloads take 
"<tt>x</tt>". Second, there's nothing that defines what it means to use <tt>operator+</tt> on a string and an 
iterator range; clearly concatentation is intended but there is no wording to that effect.
Third, the final portion uses "value type", but the "value type" of a single character is not a defined concept.
<p/>
Also, the reference only to 30.10.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.type.cvt">[fs.path.type.cvt]</a> seems to imply that any format conversion specified in 
30.10.8.2.1 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmt.cvt">[fs.path.fmt.cvt]</a> will not be performed, in seeming contradiction to the rule that <tt>native()</tt> 
is to return the native pathname format (30.10.8.4.6 <a href="https://timsong-cpp.github.io/cppwp/fs.path.native.obs">[fs.path.native.obs]</a>/1). Is that intended?
</p>

<p><i>[2016-11-10, Billy suggests wording]</i></p>

<p>
The wording for LWG <a href="2798">2798</a> resolves this issue as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>
The wording for LWG <a href="2798">2798</a> resolves this issue as well.
</p>





<hr>
<h3><a name="2737" href="2737">2737.</a> Consider relaxing object size restrictions for single-object allocation functions</h3>
<p><b>Section:</b> 21.6.2.1 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Clark Nelson <b>Opened:</b> 2016-06-21 <b>Last modified:</b> 2016-08-01 18:08:48 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.single">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It should be considered whether the description of the
single-object allocation functions should say "or smaller", like
the array allocation functions. For example, according to 21.6.2.1 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> p1 (emphasis mine):
</p>
<blockquote>
<p>
The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate <tt>size</tt> bytes of
storage suitably aligned to represent any object <em>of that size</em>.
</p>
</blockquote>
<p>
In contrast to this, 21.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.array">[new.delete.array]</a> p1 says (emphasis mine):
</p>
<blockquote>
<p>
The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate
<tt>size</tt> bytes of storage suitably aligned to represent any array object <em>of that size or smaller</em>. 
(footnote: It is not the direct responsibility of <tt>operator new[](std::size_t)</tt> or <tt>operator delete[](void*)</tt> 
to note the repetition count or element size of the array. Those operations are performed elsewhere in the array 
<tt>new</tt> and <tt>delete</tt> expressions. The array <tt>new</tt> expression, may, however, increase the size 
argument to operator <tt>new[](std::size_t)</tt> to obtain space to store supplemental information.)
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2741" href="2741">2741.</a> <tt>is_partitioned</tt> requirements need updating</h3>
<p><b>Section:</b> 28.7.4 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-07-06 <b>Last modified:</b> 2016-08-01 18:08:48 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.partitions">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote class="note">
<p>
<i>Requires:</i> <tt>InputIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument type.
</p>
</blockquote>
<p>
This seems to date from the days of adaptable function objects with an <tt>argument_type</tt> typedef, but in 
modern C++ the predicate might not have an argument type. It could have a function template that accepts various 
arguments, so it doesn't make sense to state requirements in terms of a type that isn't well defined.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Edit 28.7.4 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class InputIterator, class Predicate&gt;
bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <del><tt>InputIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument 
type</del><ins>The expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class InputIterator, class OutputIterator1,
          class OutputIterator2, class Predicate&gt;
  pair&lt;OutputIterator1, OutputIterator2&gt;
  partition_copy(InputIterator first, InputIterator last,
                 OutputIterator1 out_true, OutputIterator2 out_false,
                 Predicate pred);
</pre>
<blockquote>
<p>
-12- <i>Requires:</i> <tt>InputIterator</tt>'s value type shall be <tt>CopyAssignable</tt>, and shall be writable 
(27.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>) to the <tt>out_true</tt> and <tt>out_false</tt> 
<tt>OutputIterator</tt>s, and <del>shall be convertible to <tt>Predicate</tt>'s argument type</del><ins>the
expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>. 
The input range shall not overlap with either of the output ranges.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class ForwardIterator, class Predicate&gt;
  ForwardIterator partition_point(ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred);
</pre>
<blockquote>
<p>
-16- <i>Requires:</i> <del><tt>ForwardIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument 
type</del><ins>The expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>. 
<tt>[first, last)</tt> shall be partitioned by <tt>pred</tt>, i.e. all elements that satisfy <tt>pred</tt> shall appear 
before those that do not.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2743" href="2743">2743.</a> p0083r3 <tt>node_handle</tt> private members missing "exposition only" comment</h3>
<p><b>Section:</b> 26.2.4.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-08 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The private members of <tt>node_handle</tt> are missing the usual "exposition only" comment. As a consequence, 
<tt>ptr_</tt> and <tt>alloc_</tt> now appear to be names defined by the library (so programs defining these names 
as macros before including a library header have undefined behavior).
<p/>
Presumably this is unintentional and these members should be considered to be for exposition only.
<p/>
It's also not clear whether the name <tt>node_handle</tt> is reserved for library usage or not; 
26.2.4.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a>/3 says the implementation need not provide a type with this name, but 
doesn't seem to rule out the possibility that an implementation will choose to do so regardless.
</p>
<p>
<b>Daniel:</b>
<p/>
A similar problem seems to exist for the exposition-only type <tt><i>call_wrapper</i></tt> from 
<a href="http://wg21.link/p0358r1">p0358r1</a>, which exposes a private data member named <tt>fd</tt> and 
a typedef <tt>FD</tt>.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Jonathan says that we need to make clear that the name <tt>node_handle</tt> is not reserved</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2746" href="2746">2746.</a> Inconsistency between requirements for <tt>emplace</tt> between <tt>optional</tt> and <tt>variant</tt></h3>
<p><b>Section:</b> 23.6.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-13 <b>Last modified:</b> 2016-11-26 14:11:13 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.optional">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.optional">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Referring to N4604:
</p>
<p>
In 99 [optional.object.assign]: <tt>emplace</tt> (normal form) has a Requires that the construction works.
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> 
is <tt>true</tt>.
</p>
</blockquote>
<p>
In 23.8.3.3 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a>: <tt>emplace</tt> (normal form) has a Requires that the construction works:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
In 23.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a>: <tt>emplace</tt> (<tt>T</tt>, normal form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>, and <tt>T</tt> occurs exactly 
once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (Idx, normal form) has a <em>both</em> a Requires and a SFINAE condition:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>I &lt; sizeof...(Types)</tt>
<p/>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>, and <tt>T</tt> 
occurs exactly once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>T</tt>, <tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is 
<tt>true</tt>, and <tt>T</tt> occurs exactly once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (Idx, <tt>initializer_list</tt> form) has a both a Requires and a SFINAE condition:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>I &lt; sizeof...(Types)</tt>
<p/>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is true, and <tt>T</tt> occurs exactly 
once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
Why the inconsistency? Should all the cases have a SFINAE requirement?
<p/>
I see that variant has an additional requirement (<tt>T</tt> occurs exactly once in <tt>Types...</tt>), but that 
only agues that it must be a SFINAE condition &mdash; doesn't say that the other cases (any/variant) should not.
<p/>
<tt>map</tt>/<tt>multimap</tt>/<tt>unordered_map</tt>/<tt>unordered_multimap</tt> have SFINAE'd versions of 
<tt>emplace</tt> that don't take <tt>initializer_list</tt>s, but they don't have any <tt>emplace</tt> versions 
that take ILs.
<p/>
Suggested resolution:
<p/>
Add SFINAE requirements to <tt>optional::emplace(Args&amp;&amp;... args)</tt> and 
<tt>any::emplace(Args&amp;&amp;... args);</tt>
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>During issue prioritization, people suggested that this might apply to <tt>any</tt> as well.</p>
<p>Ville notes that <a href="2746">2746</a>, <a href="2754">2754</a> and <a href="2756">2756</a> all go together.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2751" href="2751">2751.</a> <tt>shared_ptr</tt> deleter not specified to observe expired <tt>weak_ptr</tt> instances</h3>
<p><b>Section:</b> 23.11.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Aaron Jacobs <b>Opened:</b> 2016-07-21 <b>Last modified:</b> 2017-03-14 03:03:42 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.dest">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.dest">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++14 standard contains no language that guarantees the deleter run by a
<tt>shared_ptr</tt> will see all associated <tt>weak_ptr</tt> instances as expired. For example,
the standard doesn't appear to guarantee that the assertion in the following
snippet won't fire:
</p>
<blockquote><pre>
std::weak_ptr&lt;Foo&gt; weak;
std::shared_ptr&lt;Foo&gt; strong{
  new Foo,
  [&amp;weak] (Foo* f) {
    assert(weak.expired());
    delete f;
  },
};

weak = strong;
strong.reset();
</pre></blockquote>
<p>
It seems clear that the intent is that associated <tt>weak_ptr</tt>s are expired,
because otherwise <tt>shared_ptr</tt> deleters could resurrect a reference to an object
that is being deleted.
<p/>
Suggested fix: 23.11.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a> should specify that the decrease in
<tt>use_count()</tt> caused by the destructor is sequenced before the call to the
deleter or the call to <tt>delete p</tt>.
</p>

<p><i>[2016-11-08, Jonathan and STL suggest NAD]</i></p>

<p>
STL and Jonathan feel that the example has unspecified behaviour, and the
assertion is allowed to fire, and that's OK (the program's expectation
is not reasonable). Otherwise it's necessary to move-construct a copy
of the deleter and use that copy to destroy the owned pointer. We do
not want to be required to do that.
</p>
<p>See also <ref iref="2262"/>.</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2762" href="2762">2762.</a> <tt>unique_ptr operator*()</tt> should be <tt>noexcept</tt></h3>
<p><b>Section:</b> 23.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-08-04 <b>Last modified:</b> 2016-11-26 14:11:13 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.observers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See LWG <a href="2337">2337</a>. Since we aren't removing <tt>noexcept</tt> from <tt>shared_ptr</tt>'s 
<tt>operator*</tt>, we should consider adding <tt>noexcept</tt> to <tt>unique_ptr</tt>'s <tt>operator*</tt>.
</p>

<p><i>[2016-08 &mdash; Chicago]</i></p>

<p>Thurs PM: P3, and status to 'LEWG'</p>

<p><i>[2016-08-05 Chicago]</i></p>

<p>
Ville provides an initial proposed wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<blockquote class="note">
<p>
[Drafting note: since this issue is all about consistency, <tt>optional</tt>'s pointer-like operators 
are additionally included.]
</p>
</blockquote>

<ol>
<li><p>In 23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> synopsis, edit as follows:</p>

<blockquote>
<pre>
add_lvalue_reference_t&lt;T&gt; operator*() const <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Before 23.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a>/1, edit as follows:</p>

<blockquote>
<pre>
add_lvalue_reference_t&lt;T&gt; operator*() const <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>In 23.6.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> synopsis, edit as follows:</p>

<blockquote>
<pre>
constexpr T const *operator-&gt;() const <ins>noexcept</ins>;
constexpr T *operator-&gt;() <ins>noexcept</ins>;
constexpr T const &amp;operator*() const &amp; <ins>noexcept</ins>;
constexpr T &amp;operator*() &amp; <ins>noexcept</ins>;
constexpr T &amp;&amp;operator*() &amp;&amp; <ins>noexcept</ins>;
constexpr const T &amp;&amp;operator*() const &amp;&amp; <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Before 99 [optional.object.observe]/1, edit as follows:</p>

<blockquote>
<pre>
constexpr T const* operator-&gt;() const <ins>noexcept</ins>;
constexpr T* operator-&gt;() <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Before 99 [optional.object.observe]/5, edit as follows:</p>

<blockquote>
<pre>
constexpr T const&amp; operator*() const &amp; <ins>noexcept</ins>;
constexpr T&amp; operator*() &amp; <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Before 99 [optional.object.observe]/9, edit as follows:</p>

<blockquote>
<pre>
constexpr T&amp;&amp; operator*() &amp;&amp; <ins>noexcept</ins>;
constexpr const T&amp;&amp; operator*() const &amp;&amp; <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2766" href="2766">2766.</a> Swapping non-swappable types</h3>
<p><b>Section:</b> 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/pairs.spec">[pairs.spec]</a>, 23.5.3.10 <a href="https://timsong-cpp.github.io/cppwp/tuple.special">[tuple.special]</a>, 23.6.9 <a href="https://timsong-cpp.github.io/cppwp/optional.specalg">[optional.specalg]</a>, 23.7.10 <a href="https://timsong-cpp.github.io/cppwp/variant.specalg">[variant.specalg]</a>, 23.11.1.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a>, 26.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a>, 26.6.4.5 <a href="https://timsong-cpp.github.io/cppwp/queue.special">[queue.special]</a>, 26.6.5.4 <a href="https://timsong-cpp.github.io/cppwp/priqueue.special">[priqueue.special]</a>, 26.6.6.5 <a href="https://timsong-cpp.github.io/cppwp/stack.special">[stack.special]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-08-15 <b>Last modified:</b> 2016-09-12 04:09:33 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Related: <a href="2748">2748</a> swappable traits for optionals, <a href="2749">2749</a> swappable traits for variants.
</p>
<p>
The adoption of <a href="http://wg21.link/p0185r1">P0185R1</a> "Adding [nothrow-]swappable traits" makes certain 
non-swappable types indirectly swappable. Consider a type defined as follows:
</p>
<blockquote><pre>
struct non_swappable {
  friend void swap(non_swappable&amp;, non_swappable&amp;) = delete;
};

non_swappable ns1, ns2;
using std::swap;
swap(ns1, ns2); // ill-formed

static_assert(std::is_swappable_v&lt;non_swappable&gt; == false); // holds
</pre></blockquote>
<p>
Lvalues of type <tt>non_swappable</tt> are not swappable, as defined by 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>, 
overload resolution selects the deleted function. Consistently, <tt>is_swappable_v&lt;non_swappable&gt;</tt> yields 
false. It should be noted that since <tt>non_swappable</tt> is move constructible and move assignable, a qualified 
call to <tt>std::swap</tt> would be well-formed, even under P0185. Now consider the following snippet:
</p>
<blockquote><pre>
std::tuple&lt;non_swappable&gt; tns1, tns2;
using std::swap;
swap(tns1, tns2); // previously ill-formed, now well-formed

static_assert(std::is_swappable_v&lt;std::tuple&lt;non_swappable&gt;&gt; == false); // fires
</pre></blockquote>
<p>
Before P0185, this snippet would violate the implicit requirement of specialized swap for tuples that each tuple 
element be swappable. After P0185, this specialized swap overload for tuples would be SFINAEd away, resulting 
in overload resolution selecting the base swap overload, and performing the exchange via move construction and 
move assignment of tuples.
<p/>
This issue affects all of <tt>pair</tt>, <tt>tuple</tt>, <tt>unique_ptr</tt>, <tt>array</tt>, <tt>queue</tt>, 
<tt>priority_queue</tt>, <tt>stack</tt>, and should eventually also apply to <tt>optional</tt> and <tt>variant</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606, except when otherwise noted.</p>

<ol>
<li><p>Modify 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/pairs.spec">[pairs.spec]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y)
  noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
<p/>
-8- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as 
deleted</ins> unless <tt>is_swappable_v&lt;T1&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;T2&gt;</tt> 
is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.3.10 <a href="https://timsong-cpp.github.io/cppwp/tuple.special">[tuple.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;<tt>T<sub>i</sub></tt>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>, where 
<tt>0 &lt;= <i>i</i></tt> and <tt><i>i</i> &lt; sizeof...(Types)</tt>. The expression inside <tt>noexcept</tt> 
is equivalent to:
</p>
<blockquote><pre>
noexcept(x.swap(y))
</pre></blockquote>
<p>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.11.1.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;D&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> Calls <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, size_t N&gt;
  void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>N == 0</tt> or <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.6.4.5 <a href="https://timsong-cpp.github.io/cppwp/queue.special">[queue.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container&gt;
  void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;Container&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.6.5.4 <a href="https://timsong-cpp.github.io/cppwp/priqueue.special">[priqueue.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container, class Compare&gt;
  void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x,
            priority_queue&lt;T, Container, Compare&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <tt>Remarks:</tt> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;Container&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;Compare&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.6.6.5 <a href="https://timsong-cpp.github.io/cppwp/stack.special">[stack.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container&gt;
  void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;Container&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.6.9 <a href="https://timsong-cpp.github.io/cppwp/optional.specalg">[optional.specalg]</a> as indicated:</p>
<blockquote class="note">
<p>
This change should be performed if and only if LWG <a href="2748">2748</a> is accepted and is against the wording of <a href="2748">2748</a>:
</p>
</blockquote>
<blockquote>
<pre>
template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <tt>x.swap(y)</tt>.
<p/>
-2- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.10 <a href="https://timsong-cpp.github.io/cppwp/variant.specalg">[variant.specalg]</a> as indicated:</p>
<blockquote class="note">
<p>
This change should be performed if and only if LWG <a href="2749">2749</a> is accepted and is against the wording of <a href="2749">2749</a>:
</p>
</blockquote>
<blockquote>
<pre>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <tt>v.swap(w)</tt>.
<p/>
-2- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_move_constructible_v&lt;<i>T<sub>i</sub></i>&gt; &amp;&amp; is_swappable_v&lt;<i>T<sub>i</sub></i>&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>. The expression inside <tt>noexcept</tt> is equivalent to <tt>noexcept(v.swap(w))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2772" href="2772">2772.</a> Inconsistency in the <tt>insert(node)</tt> interface</h3>
<p><b>Section:</b> 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 26.4.2 <a href="https://timsong-cpp.github.io/cppwp/associative.map.syn">[associative.map.syn]</a>, 26.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.syn">[unord.map.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2016-09-06 <b>Last modified:</b> 2016-09-12 04:09:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++17 the interface of the unique <tt>map</tt> was extended to include following function:
</p>
<blockquote><pre>
pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; k, Args&amp;&amp;... args); //and move version
iterator try_emplace(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args); //and move version
iterator insert(const_iterator hint, node_type&amp;&amp; nh)
insert_return_type insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
All of the functions share a common property, that they are performing basically no-operation in case when element 
with given key (part of node) is already stored in the map. However there is major difference in their interface. 
The first three functions:
</p>
<blockquote><pre>
pair&lt;iterator, bool&gt; try_emplace(key_type&amp;&amp; k, Args&amp;&amp;... args); //and copy version
iterator try_emplace(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args); //and copy version
iterator insert(const_iterator hint, node_type&amp;&amp; nh)
</pre></blockquote>
<p>
are guaranteeing that the value of the arguments (<tt>k, nh, args...</tt>) will not be changed if the map already 
contains a key with given value, so the programmer is free to reuse it for their own purpose.
<p/>
However, the interface of the fourth function is a bit different:
</p>
<blockquote><pre>
insert_return_type insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
The <tt>insert_return_type</tt> is an unspecified type that contains:
</p>
<blockquote><pre>
bool inserted;
X::iterator position;
X::node_type node;
</pre></blockquote>
<p>
As  we can see, the <tt>insert</tt> function is returning a <tt>node</tt>. This difference is actually
misleading, as the programmer may start to wonder, why the function returns a <tt>node</tt> handle, 
instead of being guaranteed that the argument will not be modified (as other functions do). Most reasonable 
explanation is that, this function actually return a handle to a different <tt>node</tt>, that one passed 
as the argument, i.e. this function replaces an existing node with the <tt>nh</tt> argument and returns the
handle to the old <tt>node</tt>. However, this function actually has the same semantics as the other <tt>insert</tt> 
function and returns a <tt>node</tt> that was passed as argument.
<p/>
In addition, this design makes the interface of the <tt>insert</tt> function for the map inconsistent. Value 
inserting functions are returning <tt>pair&lt;iterator, bool&gt;</tt> while node inserting function is 
returning an unspecified type with guaranteed set of members.
<p/>
The only potential benefit of this signature is that it could potentially allow programmer to use 
decomposition declaration, so instead of:
</p>
<blockquote><pre>
auto nh = node_provider();
if (map.insert(std::move(nh)).second)
  handle_node_in_other_way(std::move(nh));
</pre></blockquote>
<p>
The user would be able to write:
</p>
<blockquote><pre>
if (auto [it, ins, nh] = map.insert(node_provider); ins)
   handle_node_in_other_way(std::move(nh));
</pre></blockquote>
<p>
However, the <tt>insert_return_type</tt> is not currently required to work with decomposition declaration, so 
this is only "potential" benefit that could be added in future.
<p/>
Furthermore, this change is preventing a user to use structured binding with combination with <tt>insert</tt> 
in generic code:
</p>
<blockquote><pre>
template&lt;typename UniqMap, typename Elem&gt;
void log_duplicate_insertion(UniqMap&amp; map, Elem&amp;&amp; elem)
{
  if (auto [it, ins] = map.insert(std::forward&lt;Elem&gt;(elem)); !ins)
    std::cout &lt;&lt; "attempt to insert duplicate for " &lt;&lt; *it;
}
</pre></blockquote>
<p>
Currently, <tt>log_duplicate_insertion</tt> will not work with <tt>node_handle_type</tt>.
<p/>
So, I am proposing to change the interface of the <tt>insert(node_handle)</tt> function for associative containers 
with unique keys, to be consistent with the other <tt>insert</tt> operation and <tt>try_emplace</tt> function. I.e. 
change the signature to:
</p>
<blockquote><pre>
std::pair&lt;iterator, bool&gt; insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
and provide the guarantee that <tt>nh</tt> will be unchanged if an element was not inserted.
</p>

<p><i>[2016-09-06, Howard comments]</i></p>

<p>
This is related to LWG <a href="839">839</a>.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2774" href="2774">2774.</a> <tt>std::function</tt> construction vs assignment</h3>
<p><b>Section:</b> 23.14.13.2.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2016-09-14 <b>Last modified:</b> 2016-10-08 04:10:13 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func.con">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.con">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think there's a minor defect in the <tt>std::function</tt> interface. The constructor template is:
</p>
<blockquote><pre>
template &lt;class F&gt; function(F f);
</pre></blockquote>
<p>
while the assignment operator template is 
</p>
<blockquote><pre>
template &lt;class F&gt; function&amp; operator=(F&amp;&amp; f);
</pre></blockquote>
<p>
The latter came about as a result of LWG <a href="1288">1288</a>, but that one was dealing with a specific issue that 
wouldn't have affected the constructor. I think the constructor should also take <tt>f</tt> by forwarding reference, 
this saves a move in the lvalue/xvalue cases and is also just generally more consistent. Should just make sure 
that it's stored as <tt>std::decay_t&lt;F&gt;</tt> instead of <tt>F</tt>. 
<p/>
Is there any reason to favor a by-value constructor over a forwarding-reference constructor?
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2776" href="2776">2776.</a> <tt>shared_ptr unique()</tt> and <tt>use_count()</tt></h3>
<p><b>Section:</b> 23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2016-09-22 <b>Last modified:</b> 2016-10-08 04:10:13 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The removal of the "debug only" restriction for <tt>use_count()</tt> and <tt>unique()</tt> in <tt>shared_ptr</tt>  
by LWG <a href="2434">2434</a> introduced a bug. In order for <tt>unique()</tt> to produce a useful and reliable value, 
it needs a synchronize clause to ensure that prior accesses through another reference are visible to the successful 
caller of <tt>unique()</tt>. Many current implementations use a relaxed load, and do not provide this guarantee, 
since it's not stated in the standard. For debug/hint usage that was OK. Without it the specification is unclear 
and probably misleading.
<p/>
I would vote for making <tt>unique()</tt> use <tt>memory_order_acquire</tt>, and specifying that reference count 
decrement operations synchronize with <tt>unique()</tt>. That still doesn't give us sequential consistency by default, 
like we're supposed to have. But the violations seem sufficiently obscure that I think it's OK. All uses that 
anybody should care about will work correctly, and the bad uses are clearly bad. I agree with Peter that this 
version of <tt>unique()</tt> may be quite useful.
<p/>
I would prefer to specify <tt>use_count()</tt> as only providing an unreliable hint of the actual count (another way 
of saying debug only). Or deprecate it, as JF suggested. We can't make <tt>use_count()</tt> reliable without adding 
substantially more fencing. We really don't want someone waiting for <tt>use_count() == 2</tt> to determine that 
another thread got that far. And unfortunately, I don't think we currently say anything to make it clear that's a 
mistake.
<p/>
This would imply that <tt>use_count()</tt> normally uses <tt>memory_order_relaxed</tt>, and <tt>unique</tt> is 
neither specified nor implemented in terms of <tt>use_count()</tt>.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2779" href="2779">2779.</a> [networking.ts] Relax requirements on buffer sequence iterators</h3>
<p><b>Section:</b> 99 [networking.ts::buffer.reqmts.mutablebuffersequence] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Vinnie Falco <b>Opened:</b> 2016-10-05 <b>Last modified:</b> 2017-02-22 19:02:51 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We propose to relax the <b>ForwardIterator</b> requirements of buffer sequences
in [networking.ts] by allowing buffer sequence iterators to return rvalues when
dereferenced, and skip providing <tt>operator-&gt;</tt>.
A paraphrased explanation of why the referential equality rules of <b>ForwardIterator</b>
are harmful to the buffer sequence requirements comes from <a href="http://wg21.link/n4128">N4128</a>,
3.3.7 "Ranges For The Standard Library":
</p>
<blockquote><p>
The [networking.ts] dependence on <b>ForwardIterator</b> in the buffer
sequence requirements ties together the traversal and access properties of
iterators. For instance, no forward iterator may return an <i>rvalue</i> proxy
when it is dereferenced; the <b>ForwardIterator</b> concept requires that
unary <tt>operator*</tt> return an lvalue. This problem has serious consequences
for lazy evaluation that applies transformations to buffer sequence elements on
the fly. If the transformation function does not return an <i>lvalue</i>, the
range's iterator can model no concept stronger than <b>InputIterator</b>, even
if the resulting iterator could in theory support
<b>BidirectionalIterator</b>. The result in practice is that most range
adaptors today will not be compatible with [networking.ts], thereby limiting the
types that [networking.ts] can be passed, for no good reason.
</p></blockquote>

<p>
Consider a user defined function <tt>trim</tt> which lazily adapts a
<tt>ConstBufferSequence</tt>, such that when iterating the buffers in the new
sequence, each buffer appears one byte shorter than in the underlying sequence:
</p>

<blockquote><pre>
#include &lt;boost/range/adaptor/transformed.hpp&gt;

struct trim
{
  using result_type = const_buffer;
  result_type operator()(const_buffer b)
  {
    return const_buffer{b.data(), b.size() - 1};
  }
};

template &lt;ConstBufferSequence&gt;
auto
trim(ConstBufferSequence const&amp; buffers)
{
  using namespace boost::adaptors;
  return buffers | transformed(trim{});
}
</pre></blockquote>

<p>
<tt>trim</tt> returns a <b>BidirectionalRange</b>, whose
<tt>const_iterator</tt> returns an rvalue when dereferenced. This breaks the
requirements of <b>ForwardIterator</b>. A solution that meets the referential equality 
rules of <b>ForwardIterator</b>, would be to evaluate the transformed
sequence upon construction (for example, by storing each transformed
<tt>const_buffer</tt> in a <tt>vector</tt>). Unfortunately this work-around is
more expensive since it would add heap allocation which the original example avoids.
</p>

<p>
The requirement of <b>InputIterator</b> <tt>operator-&gt;</tt> is also
unnecessary for buffer sequence iterators, and should be removed. Because
[networking.ts] only requires that a buffer sequence iterator's
<tt>value_type</tt> be convertible to <tt>const_buffer</tt> or
<tt>mutable_buffer</tt>, implementations of [networking.ts] cannot assume the
existence of any particular member functions or data members other than an
implicit conversion to <tt>const_buffer</tt> or <tt>mutable_buffer</tt>.
Removing the requirement for <tt>operator-&gt;</tt> to be present, provides
additional relief from the referential equality requirements of
<b>ForwardIterator</b> and allows transformations of buffer sequences to meet
the requirements of buffer sequences.
</p>

<p>
This proposal imposes no changes on existing implementations of [networking.ts].
It does not change anything in the standard. The proposal is precise, minimal,
and allows range adapters to transform buffer sequences in optimized, compatible
ways.
</p>

<p><i>[Issues processing Telecon 2016-10-07]</i></p>

<p>Status set to LEWG</p>

<p><i>[2017-02-21, Jonathan comments]</i></p>

<p>
The use of the term "strict aliasing" in the issue discussion is
misleading as that refers to type-based alias analysis in compilers,
but the rule for <tt>ForwardIterator</tt>s is related to referential equality
and not strict aliasing.
</p>

<p><i>[2017-02-22, Vinnie Falco comments]</i></p>

<p>
We have eliminated the use of the term "strict aliasing" from the discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4588">N4588</a>.
</p>

<ol>
<li>
<p>
Modify 16.2.1 [buffer.reqmts.mutablebuffersequence] as indicated:
</p>
<blockquote>
<p>
<del>An iterator type meeting the requirements for bidirectional
iterators (C++Std [bidirectional.iterators]) whose value type is
convertible to <tt>mutable_buffer</tt></del>
</p>
<p><ins>
An iterator type whose <tt>reference</tt> type is convertible to
<tt>mutable_buffer</tt>, and which satisfies all the requirements for
bidirectional iterators (C++Std [bidirectional.iterators]) except
that:
</ins></p>
<ol style="list-style-type:lower-alpha">
<li>
<ins>there is no requirement that <tt>operator-&gt;</tt> is provided, and</ins>
</li>
<li>
<ins>there is no requirement that <tt>reference</tt> be a reference type.</ins>
</li>
</ol>
</blockquote>
</li>

<li>
<p>
Modify 16.2.2 [buffer.reqmts.constbuffersequence] as indicated:
</p>
<blockquote>
<p>
<del>An iterator type meeting the requirements for bidirectional
iterators (C++Std [bidirectional.iterators]) whose value type is
convertible to <tt>const_buffer</tt>.</del>
</p>

<p>
<ins>An iterator type whose <tt>reference</tt> type is convertible to
<tt>const_buffer</tt>, and which satisfies all the requirements for
bidirectional iterators (C++Std [bidirectional.iterators]) except
that:
</ins></p>
<ol style="list-style-type:lower-alpha">
<li>
<ins>there is no requirement that <tt>operator-&gt;</tt> is provided, and</ins>
</li>
<li>
<ins>there is no requirement that <tt>reference</tt> be a reference type.</ins>
</li>
</ol>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="2780" href="2780">2780.</a> <tt>basic_string_view::copy</tt> is missing <tt>constexpr</tt></h3>
<p><b>Section:</b> 24.4 <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-10-07 <b>Last modified:</b> 2016-11-21 05:11:01 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.view">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Now that we have C++14 relaxed <tt>constexpr</tt>, we can also take care
of the assignment operator and <tt>copy</tt>.
</p>
<p><i>[Issues processing Telecon 2016-10-07]</i></p>

<p>Split off from <a href="2778">2778</a></p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: Status LEWG</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 24.4.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a>, add <tt>constexpr</tt> to <tt>copy</tt>:</p>

<blockquote>
<pre>
<ins>constexpr </ins>size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>
</blockquote>
</li>

<li><p>In 24.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a>, add <tt>constexpr</tt> to <tt>copy</tt>:</p>

<blockquote>
<pre>
<ins>constexpr </ins>size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2783" href="2783">2783.</a> <tt>stack::emplace()</tt> and <tt>queue::emplace()</tt> should return <tt>decltype(auto)</tt></h3>
<p><b>Section:</b> 26.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/queue.defn">[queue.defn]</a>, 26.6.6.1 <a href="https://timsong-cpp.github.io/cppwp/stack.defn">[stack.defn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-10-14 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>stack</tt> and <tt>queue</tt> adaptors are now defined as:
</p>
<blockquote><pre>
template &lt;class... Args&gt;
reference emplace(Args&amp;&amp;... args) { return c.emplace_back(std::forward&lt;Args&gt;(args)...); }
</pre></blockquote>
<p>
This breaks any code using <tt>queue&lt;UserDefinedSequence&gt;</tt> or <tt>stack&lt;UserDefinedSequence&gt;</tt> 
until the user-defined containers are updated to meet the new C++17 requirements.
<p/>
If we defined them as returning <tt>decltype(auto)</tt> then we don't break any code. When used with <tt>std::vector</tt> 
or <tt>std::deque</tt> they will return <tt>reference</tt>, as required, but when used with C++14-conforming containers 
they will return <tt>void</tt>, as before.
</p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat AM: P2</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Status to Tentatively Ready.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change return type of <tt>emplace</tt> in class definition in 26.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/queue.defn">[queue.defn]</a>:</p>

<blockquote>
<pre>
template &lt;class... Args&gt;
  <del>reference</del><ins>decltype(auto)</ins> emplace(Args&amp;&amp;... args) { return c.emplace_back(std::forward&lt;Args&gt;(args)...); }
</pre>
</blockquote>
</li>

<li><p>Change return type of <tt>emplace</tt> in class definition in 26.6.6.1 <a href="https://timsong-cpp.github.io/cppwp/stack.defn">[stack.defn]</a>:</p>

<blockquote>
<pre>
template &lt;class... Args&gt;
  <del>reference</del><ins>decltype(auto)</ins> emplace(Args&amp;&amp;... args) { return c.emplace_back(std::forward&lt;Args&gt;(args)...); }
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2797" href="2797">2797.</a> Trait precondition violations</h3>
<p><b>Section:</b> 23.15.2 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Russia <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-03-02 19:03:15 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses RU 2</b>
<p/>
Failed prerequirement for the type trait must result in ill-formed program. 
Otherwise hard detectable errors will happen:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;

struct foo;

void damage_type_trait() {
  // must be ill-formed
  std::is_constructible&lt;foo, foo&gt;::value;  
} 

struct foo{};

int main() {
  static_assert(
    // produces invalid result
    std::is_constructible&lt;foo, foo&gt;::value,   
    "foo must be constructible from foo"
  ); 
} 
</pre></blockquote>
<p>
Suggested resolution:
<p/>
Add to the end of the [meta.type.synop] section:
</p>
<blockquote><p>
<ins>Program is ill-formed if precondition for the type trait is violated.</ins>
</p></blockquote>

<p><i>[2016-11-09, Jonathan provides wording]</i></p>


<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 2</p>

<p><i>[2017-03-02, Daniel comments]</i></p>

<p>
LWG <a href="2939">2939</a> has been created to signal that some of our current type trait constraints are
not quite correct and I recommend <em>not</em> to enforce the required diagnostics for traits that
are sensitive to mismatches of the current approximate rules.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Add a new paragraph after 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> paragraph 3:</p>
<blockquote>
<p>
<ins>-?- If an instantiation of any template declared in this subclause fails
to meet the preconditions, the program is ill-formed.</ins>
</p>
</blockquote>
</li>

<li><p>Change the specification for <tt>alignment_of</tt> in Table 39 in 23.15.5 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop.query">[meta.unary.prop.query]</a>:</p>

<blockquote>
<table border="1">
<caption>Table 39 &mdash; Type property queries</caption>
<tr>
<td>
<tt>template &lt;class T&gt; struct alignment_of;</tt>
</td>
<td>
<tt>alignof(T)</tt>.<br/>
<i>Requires:</i> <tt>alignof(T)</tt> shall be a valid expression (5.3.6)<ins>,
otherwise the program is ill-formed</ins>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change the specification for <tt>is_base_of</tt>, <tt>is_convertible</tt>, <tt>is_callable</tt>, and 
<tt>is_nothrow_callable</tt> in Table 40 in 23.15.6 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a>:</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Type relationship predicates</caption>

<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Base, class<br/>
Derived&gt;<br/>
struct is_base_of;</tt>
</td>
<td>
[&hellip;]
</td>
<td>
If <tt>Base</tt> and <tt>Derived</tt> are<br/>
non-union class types and are<br/>
different types (ignoring possible<br/>
<i>cv</i>-qualifiers) then <tt>Derived</tt> shall<br/>
be a complete type<ins>, otherwise the program is ill-formed</ins>.<br/>
[<i>Note:</i> Base classes that<br/>
are private, protected, or ambiguous are,<br/>
nonetheless, base classes. &mdash; <i>end note</i>]
</td>
</tr>

<tr>
<td>
<tt>template &lt;class From, class To&gt;<br/> 
struct is_convertible;</tt>
</td>
<td>
<i>see below</i>
</td>
<td>
<tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly <i>cv</i>-qualified) <tt>void</tt><br/>
types<ins>, otherwise the program is<br/>
ill-formed</ins>.
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class...<br/> 
ArgTypes, class R&gt;<br/> 
struct is_callable&lt;<br/> 
Fn(ArgTypes...), R&gt;;</tt>
</td>
<td>
[&hellip;]
</td>
<td>
<tt>Fn</tt>, <tt>R</tt>, and all types in the<br/>
parameter pack <tt>ArgTypes</tt> shall<br/>
be complete types, (possibly<br/>
<i>cv</i>-qualified) <tt>void</tt>, or arrays of<br/>
unknown bound<ins>,<br/>
otherwise the program is ill-formed</ins>.
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class...<br/> 
ArgTypes, class R&gt;<br/> 
struct is_nothrow_callable&lt;<br/> 
Fn(ArgTypes...), R&gt;;</tt>
</td>
<td>
[&hellip;]
</td>
<td>
<tt>Fn</tt>, <tt>R</tt>, and all types in the<br/>
parameter pack <tt>ArgTypes</tt> shall<br/>
be complete types, (possibly<br/>
<i>cv</i>-qualified) <tt>void</tt>, or arrays of<br/>
unknown bound<ins>,<br/>
otherwise the program is ill-formed</ins>.
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Add a new paragraph after 23.15.7 <a href="https://timsong-cpp.github.io/cppwp/meta.trans">[meta.trans]</a> paragraph 2:</p>
<blockquote>
<p>
-2- Each of the templates in this subclause shall be a <tt>TransformationTrait</tt> (20.15.1).
<p/>
<ins>-?- If an instantiation of any template declared in this subclause fails
to meet the <i>Requires:</i> preconditions, the program is ill-formed.</ins>
</p>
</blockquote>
</li>


</ol>





<hr>
<h3><a name="2798" href="2798">2798.</a> Definition of path in terms of a string</h3>
<p><b>Section:</b> 30.10.8 <a href="https://timsong-cpp.github.io/cppwp/fs.class.path">[fs.class.path]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2016-11-10 <b>Last modified:</b> 2017-03-19 19:03:20 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.class.path">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fs.class.path">[fs.class.path]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 44, LWG <a href="2734">2734</a></b>
<p/>
The explicit definition of <tt>path</tt> in terms of a string 
requires that the abstraction be leaky. Consider that 
the meaning of the expression <tt>p += '/'</tt>  has very 
different behavior in the case that <tt>p</tt> is empty; that a 
<tt>path</tt> can uselessly contain null characters; and that 
iterators must be constant to avoid having to reshuffle 
the packed string.
</p>
<p>
Suggested resolution:
<p/>
Define member functions to express a <tt>path</tt> as a 
string, but define its state in terms of the abstract 
sequence of components (including the leading 
special components) already described by the 
iterator interface. Remove members that rely on 
arbitrary manipulation of a string value.
</p>
<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: "Looks good"</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 2; should be addressed by omnibus Filesystem paper.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li>
<p>Edit [fs.path.concat] as follows:</p>

<blockquote>
<pre>
path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(basic_string_view&lt;value_type&gt; x);
path&amp; operator+=(const value_type * x);
path&amp; operator+=(value_type x);
template &lt;class Source&gt;
    path&amp; operator+=(const Source&amp; x);
template &lt;class EcharT&gt;
    path&amp; operator+=(EcharT x);
template &lt;class Source&gt;
    path&amp; concat(const Source&amp; x);
<del>template &lt;class InputIterator&gt;
    path&amp; concat(InputIterator first, InputIterator last);</del>
</pre>
<blockquote>
<p>
-1- <del><em>Postcondition:</em> <tt>native() == prior_native + <em>effective-argument</em></tt>, 
where <tt>prior_native</tt> is <tt>native()</tt> prior to the call to <tt>operator+=</tt>, and 
<tt><em>effective-argument</em></tt> is:</del>
</p>
<ul>
    <li><del>if <tt>x</tt> is present and is <tt>const path&amp;</tt>, <tt>x.native()</tt>; otherwise,</del></li>
    <li><del>if <tt>source</tt> is present, the effective range of <tt>source</tt>  [ath.re]; 
    otherwise,</del></li>
    <li><del>>if <tt>first</tt> and <tt>last</tt> are present, the range <tt>[first, last)</tt>; otherwise,</del></li>
    <li><del><tt>x</tt>.</del></li>
</ul>
<p>
<del>If the value type of <tt><em>effective-argument</em></tt> would not be <tt>path::value_type</tt>, 
the acctual argument or argument range is first converted  [ath.type.cv] so 
that <tt><em>effective-argument</em></tt> has value type <tt>path::value_type</tt>.</del>
<ins><em>Effects:</em> Equivalent to <tt>pathname.append(path(x).native())</tt> [<em>Note:</em> 
This directly manipulates the value of <tt>native()</tt> and may not be portable between operating systems. 
&mdash; <em>end note</em>]</ins>
<p/>
-2- <em>Returns:</em> <tt>*this</tt>.
</p>
</blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
    path&amp; concat(InputIterator first, InputIterator last);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Equivalent to <tt>pathname.append(path(first, last).native())</tt> [<em>Note:</em> This 
directly manipulates the value of <tt>native()</tt> and may not be portable between operating systems. &mdash; 
<em>end note</em>]</ins>
<p/>
<ins>-?- <em>Returns:</em> <tt>*this</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2799" href="2799">2799.</a> <tt>noexcept</tt>-specifications in <tt>shared_future</tt></h3>
<p><b>Section:</b> 33.6.8 <a href="https://timsong-cpp.github.io/cppwp/futures.shared_future">[futures.shared_future]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2016-11-11 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.shared_future">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.shared_future">[futures.shared_future]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses GB 62</b>
<p/>
There is an implicit precondition on most <tt>shared_future</tt> operations that 
<tt>valid() == true</tt>, 30.6.7p3. The list of exempted functions seems copied 
directly from class <tt>future</tt>, and would also include copy operations for 
<tt>shared_futures</tt>, which are copyable. Similarly, this would be a wide 
contract that cannot throw, so those members would be marked <tt>noexcept</tt>.
</p>
<p>
Suggested resolution:
<p/>
Revise p3:
<p/>
"The effect of calling any member function other than the move constructor, the copy 
constructor, the destructor, the move-assignment operator, the copy-assignment 
operator, or <tt>valid()</tt> on a <tt>shared_future</tt> object for which 
<tt>valid() == false</tt> is undefined." [&hellip;]
<p/>
Add <tt>noexcept</tt> specification to the copy constructor and copy-assignment operator, 
in the class definition and where those members are specified.
</p>

<p><i>[2016-11-10, Zhihao Yuan comments and provides wording]</i></p>

<p>
This resolution should close LWG <a href="2697">2697</a> as well, but that one was filed 
against concurrent TS.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>This is also addressed (but in a slightly different way by <a href="http://wg21.link/P0516R0">P0516R0</a></p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<blockquote class="note">
<p>
[Drafting note: This change supersedes the 1st among 3 edits in LWG <a href="2556">2556</a>, 
please omit that edit and apply the one below.]
</p>
</blockquote>

<ol>
<li>
<p>Modify 33.6.7 <a href="https://timsong-cpp.github.io/cppwp/futures.unique_future">[futures.unique_future]</a>/3 as follows:</p>

<blockquote>
<p>
-3- The effect of calling <del>any member function other than the destructor, the move-assignment operator, 
or <tt>valid</tt></del><ins>the member functions <tt>get</tt>, <tt>wait</tt>, <tt>wait_for</tt>, or 
<tt>wait_until</tt></ins> on a <tt>future</tt> object for which <tt>valid() == false</tt> is undefined. 
[<i>Note:</i> Implementations are encouraged to detect this case and throw an object of type 
<tt>future_error</tt> with an error condition of <tt>future_errc::no_state</tt>. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>

<li>
<p>Change 33.6.8 <a href="https://timsong-cpp.github.io/cppwp/futures.shared_future">[futures.shared_future]</a> as indicated:</p>

<blockquote>
<p>
-3- The effect of calling <del>any member function other than the destructor, the move-assignment operator, or
<tt>valid()</tt></del><ins>the member functions <tt>get</tt>, <tt>wait</tt>, <tt>wait_for</tt>, or 
<tt>wait_until</tt></ins> on a <tt>shared_future</tt> object for which <tt>valid() == false</tt> is undefined. 
[<i>Note:</i> Implementations are encouraged to detect this case and throw an object of type 
<tt>future_error</tt> with an error condition of <tt>future_errc::no_state</tt>. &mdash; <i>end note</i>]
</p>
<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class shared_future {
  public:
    shared_future() noexcept;
    shared_future(const shared_future&amp; rhs) <ins>noexcept</ins>;
    shared_future(future&lt;R&gt;&amp;&amp;) noexcept;
    shared_future(shared_future&amp;&amp; rhs) noexcept;
    ~shared_future();
    shared_future&amp; operator=(const shared_future&amp; rhs) <ins>noexcept</ins>;
    shared_future&amp; operator=(shared_future&amp;&amp; rhs) noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
[&hellip;]
<pre>
shared_future(const shared_future&amp; rhs) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> [&hellip;]
</p>
</blockquote>
[&hellip;]
<pre>
shared_future&amp; operator=(const shared_future&amp; rhs) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-14- <i>Effects:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2800" href="2800">2800.</a> <tt>constexpr swap</tt></h3>
<p><b>Section:</b> 23.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-02-20 21:02:54 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.swap">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.swap">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 108</b>
<p/>
<tt>swap</tt> is a critical function in the standard library, and 
should be declared <tt>constexpr</tt> to support more 
widespread support for <tt>constexpr</tt> in libraries. This 
was proposed in <a href="http://wg21.link/p0202r1">P0202R1</a> which was reviewed 
favourably at Oulu, but the widespread changes to 
the <tt>&lt;algorithm&gt;</tt> header were too risky and unproven 
for C++17. We should not lose <tt>constexpr</tt> support for 
the much simpler (and more important) <tt>&lt;utility&gt;</tt> 
functions because they were attached to a larger 
paper. Similarly, the fundamental value wrappers, <tt>pair</tt> and <tt>tuple</tt>,
should have <tt>constexpr swap</tt> functions, 
and the same should be considered for <tt>optional</tt> and 
<tt>variant</tt>. It is not possible to mark <tt>swap</tt> for <tt>std::array</tt>
as <tt>constexpr</tt> without adopting the rest of the 
<a href="http://wg21.link/p0202r1">P0202R1</a> though, or rewriting the specification 
for array swap to not use <tt>swap_ranges</tt>.
</p>
<p>
Suggested resolution:
<p/>
Adopt the changes to the <tt>&lt;utility&gt;</tt> header proposed in 
<a href="http://wg21.link/p0202r1">P0202R1</a>, i.e., only bullets C, D, and E.
In addition, mark the <tt>swap</tt> functions of <tt>pair</tt> and 
<tt>tuple</tt> as <tt>constexpr</tt>, and consider doing the same for 
<tt>optional</tt> and <tt>variant</tt>.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2808" href="2808">2808.</a> Requirements for <tt>fpos</tt> and <tt>stateT</tt></h3>
<p><b>Section:</b> 30.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-02-20 21:02:54 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fpos.operations">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#fpos.operations">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses GB 60</b>
</p>
<p>
The requirements on the <tt>stateT</tt> type used 
to instantiate class template <tt>fpos</tt> are not 
clear, and the following Table 108 &mdash; "Position 
type requirements" is a bit of a mess. This is 
old wording, and should be cleaned up with better
terminology from the Clause 17 Requirements. For example, 
<tt>stateT</tt> might be require <tt>CopyConstructible</tt>?, 
<tt>CopyAssignable</tt>?, and <tt>Destructible</tt>. Several 
entries in the final column of the table appear to be 
post-conditions, but without the <tt>post</tt> markup to 
clarify they are not assertions or preconditions. They 
frequently refer to identifiers that do not apply to all 
entries in their corresponding <tt>Expression</tt> 
column, leaving some expressions without a clearly defined semantic.
If <tt>stateT</tt> is a trivial type, is <tt>fpos</tt> also a 
trivial type, or is a default constructor not required/supported?
</p>
<p>
Proposed change:
<p/>
Clarify the requirements and the table.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 4; no consensus for any concrete change</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2811" href="2811">2811.</a> "Selected constructor" wording is incorrect for <tt>optional</tt>/<tt>variant</tt>/<tt>any</tt></h3>
<p><b>Section:</b> 23.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>, 23.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a>, 23.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a>, 23.8.3.1 <a href="https://timsong-cpp.github.io/cppwp/any.cons">[any.cons]</a>, 23.8.3.3 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-10-29 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.ctor">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Throughout <tt>optional</tt>/<tt>variant</tt>/<tt>any</tt>'s specification references are made to "the selected constructor 
of <tt>T</tt>". For example, 23.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>/16 says of the constructor from <tt>const T&amp;</tt>:
</p>
<blockquote><p>
-16- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be a 
<tt>constexpr</tt> constructor.
</p></blockquote>
<p>
Similarly, the in-place constructor has this wording (23.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>/25-26):
</p>
<blockquote><p>
-25- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<p/>
-26- <i>Remarks:</i> If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor.
</p></blockquote>
<p>
If <tt>T</tt> is a scalar type, it has no constructor at all. Moreover, even for 
class types, the in-place constructor wording ignores any implicit conversion done on the argument before the selected 
constructor is called, which 1) may not be valid in constant expressions and 2) may throw an exception; such exceptions 
aren't thrown "by the selected constructor of <tt>T</tt>" but outside it.
<p/>
The wording should probably be recast to refer to the entire initialization.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3; Jonathan to provide wording.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2813" href="2813">2813.</a> <tt>std::function</tt> should not return dangling references</h3>
<p><b>Section:</b> 23.14.13.2.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Bi <b>Opened:</b> 2016-11-03 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func.con">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.con">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If a <tt>std::function</tt> has a reference as a return type, and that reference binds to a prvalue 
returned by the callable that it wraps, then the reference is always dangling. Because any use of such 
a reference results in undefined behaviour, the <tt>std::function</tt> should not be allowed to be 
initialized with such a callable. Instead, the program should be ill-formed.
<p/>
A minimal example of well-formed code under the current standard that exhibits this issue:
</p>
<blockquote><pre>
#include &lt;functional&gt;

int main() 
{
  std::function&lt;const int&amp;()&gt; F([]{ return 42; });
  int x = F(); // oops!
}
</pre></blockquote>

<p><i>[2016-11-22, David Krauss comments and suggests wording]</i></p>

<p>
Indirect bindings may also introduce temporaries inside <tt>std::function</tt>, e.g.:
</p>
<blockquote><pre>
void f(std::function&lt;long const&amp;()&gt;); // Retains an observer to a long.

void g() {
  int v;
  f([&amp;]()-&gt;int&amp; { return v; } ); // int lvalue binds to long const&amp; through a temporary.
}
</pre></blockquote>
<p>
A fix has been implemented. Conversions that may be conversion operators are allowed, though, because those can 
produce legitimate glvalues. Before adopting this, it need to be considered considered whether there should be 
SFINAE or a hard error.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 2</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.
</p>
<ol>
<li><p>Add a second paragraph to the remarks section of 23.14.13.2.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>:</p>
<blockquote>
<pre>
template&lt;class F&gt; function(F f);
</pre>
<blockquote>
<p>
-7- <i>Requires:</i> <tt>F</tt> shall be <tt>CopyConstructible</tt>.
<p/>
-8- <i>Remarks:</i> This constructor template shall not participate in overload resolution unless 
</p>
<ul>
<li><p><tt>F</tt> is Lvalue-Callable (23.14.13.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>) for argument types <tt>ArgTypes...</tt> and 
return type <tt>R</tt><ins>, and</ins></p></li>
<li><p><ins>If <tt>R</tt> is type "reference to <tt>T</tt>" and <tt><i>INVOKE</i>(ArgTypes...)</tt> has value category 
<tt><i>V</i></tt> and type <tt>U</tt>:</ins></p>
<ul>
<li><p><ins><tt><i>V</i></tt> is a prvalue, <tt>U</tt> is a class type, and <tt>T</tt> is not reference-related 
(11.6.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.ref">[dcl.init.ref]</a>) to <tt>U</tt>, and</ins></p></li>
<li><p><ins><tt><i>V</i></tt> is an lvalue or xvalue, and either <tt>U</tt> is a class type or <tt>T</tt> is 
reference-related to <tt>U</tt></ins>.</p></li>
</ul>
</li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2814" href="2814">2814.</a> [fund.ts.v2] <tt>to_array</tt> should take rvalue reference as well</h3>
<p><b>Section:</b> 99 [fund.ts.v2::func.wrap.func.con] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2016-11-07 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::func.wrap.func.con">issues</a> in [fund.ts.v2::func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C++ doesn't have a prvalue expression of array type, but
rvalue arrays can still come from different kinds of sources:
</p>
<ol>
<li><p>C99 compound literals <tt>(int[]) {2, 4}</tt>,</p></li>
<li><p><tt>std::move(arr)</tt>,</p></li>
<li><p>Deduction <tt>to_array&lt;int const&gt;({ 2, 4 })</tt>.</p>
<blockquote class="note">
<p>
See also <a href="http://wg21.link/cwg1591">CWG 1591</a>: Deducing array bound and element type from initializer list.
</p>
</blockquote>
</li>
</ol>
<p>
For 3), users are "abusing" <tt>to_array</tt> to get access to uniform
initialization to benefit from initializing elements through
braced-init-list and/or better narrowing conversion support.
<p/>
We should just add rvalue reference support to <tt>to_array</tt>.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Status to LEWG</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4600">N4600</a>.</p>

<ol>
<li>
<p>Add the following signature to  [fund.ts.v2::header.array.synop]:</p>

<blockquote>
<pre>
// 9.2.2, Array creation functions
template &lt;class D = void, class... Types&gt;
  constexpr array&lt;VT, sizeof...(Types)&gt; make_array(Types&amp;&amp;... t);
template &lt;class T, size_t N&gt;
  constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;a)[N]);
<ins>template &lt;class T, size_t N&gt;
  constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;&amp;a)[N]);</ins>
</pre>
</blockquote>
</li>

<li>
<p>Modify  [fund.ts.v2::container.array.creation] as follows:</p>

<blockquote>
<pre>
template &lt;class T, size_t N&gt;
  constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;a)[N]);
<ins>template &lt;class T, size_t N&gt;
  constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;&amp;a)[N]);</ins>
</pre>
<blockquote>
<p>
-6- <i>Returns:</i> <ins>For all <tt><i>i</i></tt>, <tt>0 &le; <i>i</i> &lt; N</tt>, a</ins><del>A</del>n 
<tt>array&lt;remove_cv_t&lt;T&gt;, N&gt;</tt> <del>such that each element is copy-initialized 
with the corresponding element of <tt>a</tt></del><ins>initialized with <tt>{ a[<i>i</i>]... }</tt> for 
the first form, or <tt>{ std::move(a[<i>i</i>])... }</tt> for the second form.</ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2815" href="2815">2815.</a> <tt>quick_exit</tt> can deadlock</h3>
<p><b>Section:</b> 21.5 <a href="https://timsong-cpp.github.io/cppwp/support.start.term">[support.start.term]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jean-Fran&ccedil;ois Bastien <b>Opened:</b> 2016-11-07 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.start.term">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.start.term">[support.start.term]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While SG1 was processing NB comments CA1 and LATE2 regarding <a href="http://wg21.link/p0270r1">P0270R1</a>, 
we decided to remove the proposed guarantee that <tt>quick_exit</tt> be made signal safe.
<p/>
Our reasoning is that functions registered with <tt>at_quick_exit</tt> aren't forbidden from calling 
<tt>quick_exit</tt>, but <tt>quick_exit</tt> implementations likely acquire some form of a lock before 
processing all registered functions (because a note forbids the implementation from introducing data races).
<p/>
The following code can therefore deadlock:
</p>
<blockquote><pre>
#include &lt;cstdlib&gt;

int main() 
{
  std::at_quick_exit([] () { std::quick_exit(0); });
  std::quick_exit(1);
  return 0;
}
</pre></blockquote>
<p>
The same applies if a function registered in <tt>at_quick_exit</tt> handles a signal, and that signal calls 
<tt>quick_exit</tt>. SG1 believes that both issues (same thread deadlock, and signal deadlock) can be resolved 
in the same manner. Either:
</p>
<ol>
<li>Specify that calling <tt>quick_exit</tt> while servicing <tt>quick_exit</tt> is undefined; or</li>
<li>Specifying that calling <tt>quick_exit</tt> while servicing <tt>quick_exit</tt> is defined to not deadlock, 
and instead calls <tt>_Exit</tt> without calling further registered functions.</li>
</ol>
<p>
Option 2. seems preferable, and can be implemented along the lines of:
</p>
<blockquote><pre>
#include &lt;array&gt;
#include &lt;atomic&gt;
#include &lt;cstddef&gt;

namespace {

  typedef void (*func)();
  
  std::array&lt;func, 32&gt; quick_exit_functions;
  
  const auto* quick_exit_functions_ptr = &quick_exit_functions;
  
  std::atomic_flag lock = ATOMIC_FLAG_INIT;
  
  struct scope 
  {
    scope() { while (lock.test_and_set(std::memory_order_acquire)) ; }
    ~scope() { lock.clear(std::memory_order_release); }
  };
  
}

namespace std {

  extern "C" void quick_exit(int status) noexcept
  {
    decltype(quick_exit_functions_ptr) f;
    {
      scope s;
      f = quick_exit_functions_ptr;
      quick_exit_functions_ptr = nullptr;
    }
    if (f) {
      size_t pos = f-&gt;size();
      while (pos &gt; 0)
        (*f)[--pos]();
    }
    _Exit(status);
  }
  
  extern "C++" int at_quick_exit(func f) noexcept
  {
    scope s;
    if (!quick_exit_functions_ptr || quick_exit_functions.size() == quick_exit_functions.max_size())
      return -1;
    quick_exit_functions[quick_exit_functions.size()] = f;
    return 0;
  }

}
</pre></blockquote>
<p>
Ideally, the resolution would also add back the wording which SG1 dropped from <a href="http://wg21.link/p0270r1">P0270R1</a>:
</p>
<blockquote><p>Add at new element to the end of 21.5 <a href="https://timsong-cpp.github.io/cppwp/support.start.term">[support.start.term]</a> p13 (<tt>quick_exit()</tt>):</p>
<blockquote>
<p>
<ins><i>Remarks:</i> The function <tt>quick_exit()</tt> is signal-safe (21.10.3 <a href="https://timsong-cpp.github.io/cppwp/csignal.syn">[csignal.syn]</a>). [<i>Note:</i> It might 
still be unsafe to call <tt>quick_exit()</tt> from a handler, because the functions registered with <tt>at_quick_exit()</tt> 
might not be signal-safe. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4606">N4606</a>.</p>

<ol>
<li>
<p>Add at new element to the end of 21.5 <a href="https://timsong-cpp.github.io/cppwp/support.start.term">[support.start.term]</a> p13 (<tt>quick_exit()</tt>):</p>

<blockquote>
<pre>
[[noreturn]] void quick_exit(int status) noexcept;
</pre>
<blockquote>
<p>
-13- <i>Effects:</i> Functions registered by calls to <tt>at_quick_exit</tt> are called in the reverse order of their
registration, except that a function shall be called after any previously registered functions that had
already been called at the time it was registered. Objects shall not be destroyed as a result of calling
<tt>quick_exit</tt>. If control leaves a registered function called by <tt>quick_exit</tt> because the function does not
provide a handler for a thrown exception, <tt>std::terminate()</tt> shall be called. [<i>Note:</i> <tt>at_quick_exit</tt>
may call a registered function from a different thread than the one that registered it, so registered
functions should not rely on the identity of objects with thread storage duration. &mdash; <i>end note</i>] After
calling registered functions, <tt>quick_exit</tt> shall call <tt>_Exit(status)</tt>. [<i>Note:</i> The standard file 
buffers are not flushed. See: ISO C 7.22.4.5. &mdash; <i>end note</i>]
<p/>
<ins>-?- <i>Remarks:</i> The function <tt>quick_exit()</tt> is signal-safe (21.10.3 <a href="https://timsong-cpp.github.io/cppwp/csignal.syn">[csignal.syn]</a>). [<i>Note:</i> 
It might still be unsafe to call <tt>quick_exit()</tt> from a handler, because the functions registered with 
<tt>at_quick_exit()</tt> might not be signal-safe. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2816" href="2816">2816.</a> <tt>resize_file</tt> has impossible postcondition</h3>
<p><b>Section:</b> 30.10.15.33 <a href="https://timsong-cpp.github.io/cppwp/fs.op.resize_file">[fs.op.resize_file]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-07 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>resize_file</tt> has this postcondition (after resolving late comment 42, see <a href="http://wg21.link/p0489r0">P0489R0</a>):
</p>
<blockquote><p>
<i>Postcondition:</i> <tt>file_size(p) == new_size</tt>.
</p></blockquote>
<p>
This is impossible for an implementation to satisfy, due to the possibility of file system races. 
This is not actually a postcondition; rather, it is an effect that need no longer hold when the function returns.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2818" href="2818">2818.</a> <tt>"::std::"</tt> everywhere rule needs tweaking</h3>
<p><b>Section:</b> 20.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-11-11 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#contents">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[contents]/3 says
</p>
<blockquote><p>
Whenever a name <tt>x</tt> defined in the standard library is mentioned, the name <tt>x</tt> is assumed to be fully 
qualified as <tt>::std::x</tt>, unless explicitly described otherwise. For example, if the <i>Effects</i> section 
for library function <tt>F</tt> is described as calling library function <tt>G</tt>, the function <tt>::std::G</tt> is meant.
</p></blockquote>
<p>
With the introduction of nested namespaces inside <tt>std</tt>, this rule needs tweaking. For instance, 
<tt>time_point_cast</tt>'s <i>Returns</i> clause says "<tt>time_point&lt;Clock, 
ToDuration&gt;(duration_cast&lt;ToDuration&gt;(t.time_since_epoch()))</tt>"; that reference to <tt>duration_cast</tt> 
obviously means <tt>::std::chrono::duration_cast</tt>, not <tt>::std::duration_cast</tt>, which doesn't exist.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 2; Jonathan to provide wording</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2819" href="2819">2819.</a> Unspecified <i>Return type:</i> elements</h3>
<p><b>Section:</b> 33.2.5 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable">[thread.req.lockable]</a>, 33.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-11-12 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current draft contains 14 occurrences of a <i>Return type:</i> clause.
That clause is not covered by 20.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> p3.
This was reported as editorial request <a href="https://github.com/cplusplus/draft/issues/266">#266</a>.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3; Jonathan to provide wording.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2820" href="2820">2820.</a> Clarify <tt>&lt;cstdint&gt;</tt> macros</h3>
<p><b>Section:</b> 21.4 <a href="https://timsong-cpp.github.io/cppwp/cstdint">[cstdint]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-11-12 <b>Last modified:</b> 2017-03-19 12:03:47 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/cstdint">[cstdint]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I would like clarification from LWG regarding the various limit macros like <tt>INT_8_MIN</tt> in <tt>&lt;cstdint&gt;</tt>, 
in pursuit of editorial cleanup of this header's synopsis. I have two questions:
</p>
<ol>
<li><p>At present, macros like <tt>INT_8_MIN</tt> that correspond to the optional type <tt>int8_t</tt> are required 
(unconditionally), whereas the underlying type to which they appertain is only optional. Is this deliberate? 
Should the macros also be optional?</p></li>
<li><p>Is it deliberate that C++ only specifies sized aliases for the sizes 8, 16, 32 and 64, whereas the corresponding 
C header allows type aliases and macros for arbitrary sizes for implementations that choose to provide extended integer 
types? Is the C++ wording more restrictive by accident?</p></li>
</ol>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>C11 ties the macro names to the existence of the types. Marshall to research the second question.</p>
<p>Close <ref iref="2764"/> as a duplicate of this issue.</p>

<p><i>[2017-03-18, Thomas comments and provides wording]</i></p>

<p>
This is as close as I can get to the C wording without resolving part (a) of the issue (whether we deliberately don't 
allow sized type aliases for sizes other than 8, 16, 32, 64, a departure from C). Once we resolve part (a), we need 
to revisit <tt>&lt;cinttypes&gt;</tt> and fix up the synopsis (perhaps to get rid of <tt>N</tt>) and add similar 
wording as the one below to make the formatting macros for the fixed-width types optional. For historical interest,
this issue is related to LWG <a href="553">553</a> and LWG <a href="841">841</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Append the following content to 21.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a> p2:</p>

<blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<ins>In particular, for each of the fixed-width types (<tt>int8_t</tt>, <tt>int16_t</tt>, <tt>int32_t</tt>, 
<tt>int64_t</tt>, <tt>uint8_t</tt>, <tt>uint16_t</tt>, <tt>uint32_t</tt>, <tt>uint64_t</tt>) the type alias and 
the corresponding limit macros are defined if and only if the implementation provides the corresponding type.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2821" href="2821">2821.</a> <tt>std::launder()</tt> should be marked as <tt>[[nodiscard]]</tt></h3>
<p><b>Section:</b> 21.6.4 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tony van Eerd <b>Opened:</b> 2016-11-13 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ptr.launder">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.launder">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As pointed out by Nevin: A use of <tt>std::launder</tt> that does not make use of its return value is always 
pointless; the function has no side effects.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; Nico's upcoming paper <a href="https://wg21.link/P0532">P0532</a> should address this and other issues around launder.</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>This should be handled post-C++17 by Nico's paper <a href="http://wg21.link/P0600">P0600</a>.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2823" href="2823">2823.</a> <tt>std::array</tt> initialization is still not permissive enough</h3>
<p><b>Section:</b> 26.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2016-11-16 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array.overview">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#array.overview">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2590">2590</a>'s resolution is incomplete:
</p>
<blockquote><pre>
std::array&lt;int, 1&gt; arr{{0}};
</pre></blockquote>
<p>
should be fine, but isn't guaranteed, since <tt>{0}</tt> has no type. We should rather go for implicit conversion:
</p>
<blockquote><p>
An array is an aggregate (11.6.1 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.aggr">[dcl.init.aggr]</a>) that can be list-initialized with up to <tt>N</tt> elements 
<del>whose types are convertible to <tt>T</tt></del><ins>that can be implicitly converted to <tt>T</tt></ins>.
</p></blockquote>

<p><i>[2016-11-26, Tim Song comments]</i></p>

<p> 
This is not possible as written, because due to the brace elision rules for aggregate initialization,
<tt>std::array&lt;int, 2&gt; arr{{0}, {1}};</tt> will never work: the <tt>{0}</tt> 
is taken as initializing the inner array, and the <tt>{1}</tt> causes an error.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2; consensus is that the P/R is not quite right.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Change 26.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- An <tt>array</tt> is an aggregate (11.6.1 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.aggr">[dcl.init.aggr]</a>) that can be list-initialized with up to <tt>N</tt> 
elements <del>whose types are convertible</del><ins>that can be implicitly converted</ins> to <tt>T</tt>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2825" href="2825">2825.</a> LWG 2756 breaks class template argument deduction for <tt>optional</tt></h3>
<p><b>Section:</b> 23.6.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-24 <b>Last modified:</b> 2017-02-01 20:02:54 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.optional">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.optional">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2756">2756</a> applies these changes:
</p>
<blockquote><pre>
<del>constexpr optional(const T&amp;);
constexpr optional(T&amp;&amp;);</del>
template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;...);
template &lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);
<ins>template &lt;class U = T&gt; <i>EXPLICIT</i> constexpr optional(U&amp;&amp;);
template &lt;class U&gt; <i>EXPLICIT</i> optional(const optional&lt;U&gt;&amp;);
template &lt;class U&gt; <i>EXPLICIT</i> optional(optional&lt;U&gt;&amp;&amp;);</ins>
</pre></blockquote> 
<p>
These break the ability for <tt>optional</tt> to perform class template argument deduction, as there 
is now no way to map from <tt>optional</tt>'s argument to the template parameter <tt>T</tt>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2</p>

<p><i>[2017-01-30  Ville comments:]</i></p>

<p>Seems like the problem is resolved by a simple deduction guide:</p>
<pre>template &lt;class T&gt; optional(T) -&gt; optional&lt;T&gt;;</pre>
<p>The paper <a href="https://wg21.link/p0433r0">p0433r0</a> seems to suggest a different guide,</p>
<pre>template&lt;class T&gt; optional(T&amp;&amp; t) -&gt; optional&lt;remove_reference_t&lt;T&gt;&gt;;</pre>
<p>but I don't think the paper is up to speed with LWG <a href="2756">2756</a>. There's no reason
to use such an universal reference in the guide and <tt>remove_reference</tt> in its
target, just guide with <tt>T</tt>, with the target <tt>optional&lt;T&gt;</tt>, <tt>optional</tt>'s constructors
do the right thing once the type has been deduced.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2827" href="2827">2827.</a> <tt>is_trivially_constructible</tt> and non-trivial destructors</h3>
<p><b>Section:</b> 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-17 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>
struct S 
{
  ~S(); // non-trivial
};

static_assert(std::is_trivially_constructible&lt;S&gt;::value, "");
</pre></blockquote>
<p>
Should the assert pass? Implementations disagree.
<p/>
Per 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>'s Table 38, this trait looks at whether the following variable definition is 
known to call no operation that is not trivial:
</p>
<blockquote><pre>
S t(create&lt;Args&gt;()...);
</pre></blockquote>
<p>
... where <tt>Args</tt> is an empty pack in this case. That variable definition results in a call to the <tt>S</tt> destructor. 
Should that call be considered by the trait?
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>
<p>This issue interacts with <a href="2116">2116</a></p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2829" href="2829">2829.</a> LWG 2740 leaves behind vacuous words</h3>
<p><b>Section:</b> 23.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-24 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After applying LWG <a href="2740">2740</a>, we have:
</p>
<blockquote>
<pre>
constexpr const T* operator-&gt;() const;
constexpr T* operator-&gt;();
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>*this</tt> contains a value.
<p/>
-2- <i>Returns:</i> <tt>val</tt>.
<p/>
-3- <i>Throws:</i> Nothing.
<p/>
-4- <i>Remarks:</i> These functions shall be <tt>constexpr</tt> functions.
</p>
</blockquote>
</blockquote>
<p>
Paragraph 4 is completely superfluous. We already said these functions were <tt>constexpr</tt> in the synopsis. Can it be removed?
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 2</p>
<p>Jonathan notes: Although Richard is correct, I suggest we don't strike the paragraph, so that we 
remember to fix it as part of <a href="2833">2833</a>, when we know how to say
this properly.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2831" href="2831">2831.</a> Equality can be defined when <tt>Hash</tt> function objects have different behaviour</h3>
<p><b>Section:</b> 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Daniel James <b>Opened:</b> 2016-11-24 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> paragraph 12, it says that the behaviour of <tt>operator==</tt> is undefined unless the 
<tt>Hash</tt> and <tt>Pred</tt> function objects respectively have the same behaviour. This makes comparing containers 
with randomized hashes with different seeds undefined behaviour, but I think that's a valid use case. It's not much 
more difficult to support it when the <tt>Hash</tt> function objects behave differently. I did a little testing and 
both libstdc++ and libc++ appear to support this correctly.
<p/>
I suggest changing the appropriate sentence in 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> paragraph 12: "The behavior of a program that 
uses <tt>operator==</tt> or <tt>operator!=</tt> on unordered containers is undefined unless the <del><tt>Hash</tt> and 
</del><tt>Pred</tt> function <del>objects respectively have</del><ins>object has</ins> the same behavior for both 
containers and the equality comparison operator for Key is a <tt>refinement</tt>"
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>This is a design issue; send to LEWG</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.
</p>
<ol>
<li><p>Change 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> as indicated:</p>
<blockquote>
<p>
-12- Two unordered containers <tt>a</tt> and <tt>b</tt> compare equal if <tt>a.size() == b.size()</tt> and, 
for every equivalent-key group <tt>[Ea1, Ea2)</tt> obtained from <tt>a.equal_range(Ea1)</tt>, there exists 
an equivalent-key group <tt>[Eb1, Eb2)</tt> obtained from <tt>b.equal_range(Ea1)</tt>, such that 
<tt>is_permutation(Ea1, Ea2, Eb1, Eb2)</tt> returns <tt>true</tt>. For <tt>unordered_set</tt> and 
<tt>unordered_map</tt>, the complexity of <tt>operator==</tt> (i.e., the number of calls to the <tt>==</tt>
operator of the <tt>value_type</tt>, to the predicate returned by <tt>key_eq()</tt>, and to the hasher returned 
by <tt>hash_function()</tt>) is proportional to <tt><i>N</i></tt> in the average case and to <tt><i>N</i><sup>2</sup></tt> 
in the worst case, where <tt><i>N</i></tt> is <tt>a.size()</tt>. For <tt>unordered_multiset</tt> and 
<tt>unordered_multimap</tt>, the complexity of <tt>operator==</tt> is proportional to 
&sum; <tt><i>E<sub>i</sub></i><sup>2</sup></tt> in the average case and to <tt><i>N</i><sup>2</sup></tt> in the worst case, 
where <tt><i>N</i></tt> is a.size(), and <tt><i>E<sub>i</sub></i></tt> is the size of the <tt><i>i</i></tt>th 
equivalent-key group in <tt>a</tt>. However, if the respective elements of each corresponding pair of equivalent-key 
groups <tt><i>Ea<sub>i</sub></i></tt> and <tt><i>Eb<sub>i</sub></i></tt> are arranged in the same order (as is commonly 
the case, e.g., if <tt>a</tt> and <tt>b</tt> are unmodified copies of the same container), then the average-case 
complexity for <tt>unordered_multiset</tt> and <tt>unordered_multimap</tt> becomes proportional to <tt><i>N</i></tt> 
(but worst-case complexity remains &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>), e.g., for a pathologically bad hash function).
The behavior of a program that uses <tt>operator==</tt> or <tt>operator!=</tt> on unordered containers is undefined 
unless the <del><tt>Hash</tt> and</del> <tt>Pred</tt> function object<del>s respectively have</del><ins>has</ins> 
the same behavior for both containers and the equality comparison operator for <tt>Key</tt> is a refinement(footnote 258) 
of the partition into equivalent-key groups produced by <tt>Pred</tt>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2832" href="2832">2832.</a> &sect;[fpos.operations] strange requirement for <tt>P(i)</tt></h3>
<p><b>Section:</b> 30.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-11-24 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fpos.operations">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#fpos.operations">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is from editorial issue <a href="https://github.com/cplusplus/draft/issues/1031">#1031</a>.
<p/>
The first row in Table 112 "Position type requirements"
talks about the expression <tt>P(i)</tt> and then has an assertion
<tt>p == P(i)</tt>.  However, there are no constraints on <tt>p</tt>
other than being of type <tt>P</tt>, so (on the face of it) this
seems to require that <tt>operator==</tt> on <tt>P</tt> always returns
true, which is non-sensical.
</p>


<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2833" href="2833">2833.</a> Library needs to specify what it means when it declares a function <tt>constexpr</tt></h3>
<p><b>Section:</b> 23.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-28 <b>Last modified:</b> 2017-02-21 19:02:55 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.ctor">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library has lots of functions declared <tt>constexpr</tt>, but it's not clear what that means. The <tt>constexpr</tt> 
keyword implies that there needs to be <em>some</em> invocation of the function, for <em>some</em> set of template 
arguments and function arguments, that is valid in a constant expression (otherwise the program would be ill-formed, 
with no diagnostic required), along with a few side conditions. I suspect the library intends to require something a 
lot stronger than that from implementations (something along the lines of "all calls that could reasonably be constant 
subexpressions are in fact constant subexpressions, unless otherwise stated").
<p/>
[variant.ctor]/1 contains this, which should also be fixed:
</p>
<blockquote><p>
"This function shall be <tt>constexpr</tt> if and only if the value-initialization of the alternative type <tt>T0</tt> 
would satisfy the requirements for a <tt>constexpr</tt> function."
</p></blockquote>
<p>
This is the wrong constraint: instead of constraining whether the function is <tt>constexpr</tt>, we should constrain 
whether a call to it is a constant subexpression.
</p>
<p>
<b>Daniel:</b>
<p/>
This is has some considerable overlap with LWG <a href="2289">2289</a> but is phrased in a more general way.
</p>

<p><i>[2016-12-16, Issues Telecon]</i></p>

<p>Priority 2; this is also the general case of <a href="2829">2829</a>.</p>

<p><i>[2017-02-20, Alisdair comments and suggests concrete wording]</i></p>

<p>
Below is is draft wording I was working on at Issaquah to try to address both issues.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li>
<p>
Modify 20.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:
</p>
<blockquote>
<h3>17.6.5.6 <tt>constexpr</tt> functions and constructors [constexpr.functions]</h3>
<p>
-1- This International Standard explicitly requires that certain standard library functions are
<tt>constexpr</tt> (10.1.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>).  <ins>If the specification for a templated entity
requires that it shall be a <tt>constexpr</tt> templated entity, then that
templated entity shall be usable in a constant expression.</ins>.  An
implementation <del>shall not</del><ins>may</ins> declare
<del>any</del><ins>additional</ins> standard library function signature as
<tt>constexpr</tt> <del>except for those where it is explicitly required</del>.
Within any header that provides any non-defining declarations of
<tt>constexpr</tt> functions or constructors an implementation shall provide
corresponding definitions.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2836" href="2836">2836.</a> More string operations should be <tt>noexcept</tt></h3>
<p><b>Section:</b> 24.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, 24.3.2.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.find">[string.find]</a>, 24.3.2.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.rfind">[string.rfind]</a>, 24.3.2.7.4 <a href="https://timsong-cpp.github.io/cppwp/string.find.first.of">[string.find.first.of]</a>, 24.3.2.7.5 <a href="https://timsong-cpp.github.io/cppwp/string.find.last.of">[string.find.last.of]</a>, 24.3.2.7.6 <a href="https://timsong-cpp.github.io/cppwp/string.find.first.not.of">[string.find.first.not.of]</a>, 24.3.2.7.7 <a href="https://timsong-cpp.github.io/cppwp/string.find.last.not.of">[string.find.last.not.of]</a>, 24.3.2.7.9 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-12-05 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently some overloads of <tt>basic_string::find</tt> are <tt>noexcept</tt> and some are not. Historically this 
was because some were specified in terms of constructing a temporary <tt>basic_string</tt>, which could throw. In 
practice creating a temporary (and potentially allocating memory) is a silly implementation, and so they could be 
<tt>noexcept</tt>. In the C++17 draft most of them have been changed to create a temporary <tt>basic_string_view</tt> 
instead, which can't throw anyway (P0254R2 made those changes).
<p/>
This is confusing for users, as they need to carefully check which overload their code will resolve to, and consider 
whether that overload can throw. Refactoring code can change whether it calls a throwing or non-throwing overload. 
This is an unnecessary burden on users when realistically none of the functions will ever throw.
<p/>
The <tt>find</tt>, <tt>rfind</tt>, <tt>find_first_of</tt>, <tt>find_last_of</tt>, <tt>find_first_not_of</tt> and 
<tt>find_last_not_of</tt> overloads that are defined in terms of <tt>basic_string_view</tt> should be <tt>noexcept</tt>, 
or "<i>Throws:</i> Nothing." for the ones with narrow contracts (even though those narrow contracts are not enforcable 
or testable).
<p/>
The remaining overloads that are still specified in terms of a temporary string could also be <tt>noexcept</tt>. They 
construct <tt>basic_string</tt> of length one (which won't throw for an SSO implementation anyway), but can easily be 
defined in terms of <tt>basic_string_view</tt> instead.
<p/>
There's one <tt>basic_string::compare</tt> overload that is still defined in terms of a temporary <tt>basic_string</tt>, 
which should be <tt>basic_string_view</tt> and so can also be <tt>noexcept</tt> (the other <tt>compare</tt> overloads can 
throw <tt>out_of_range</tt>).
</p>

<p><i>[2016-12-15, Tim Song comments]</i></p>

<p>
The following overloads invoking <tt>basic_string_view&lt;charT&gt;(s, n)</tt> are implicitly narrow-contract 
(the <tt>basic_string_view</tt> constructor requires <tt>[s, s+n)</tt> to be a valid range) and should be 
"<i>Throws:</i> Nothing" rather than <tt>noexcept</tt>:
</p>
<blockquote><pre>
size_type find(const charT* s, size_type pos, size_type n) const;
size_type rfind(const charT* s, size_type pos, size_type n) const;
size_type find_first_of(const charT* s, size_type pos, size_type n) const;
size_type find_last_of(const charT* s, size_type pos, size_type n) const;
size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
</pre></blockquote>
<p>
Similarly, the <tt>basic_string_view</tt> constructor invoked by this overload of <tt>compare</tt> requires 
<tt>[s, s + traits::length(s))</tt> to be a valid range, and so it should be "<i>Throws:</i> Nothing" rather 
than <tt>noexcept</tt>:
</p>
<blockquote><pre>
int compare(const charT* s) const; 
</pre></blockquote>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2; Jonathan to provide updated wording</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.
</p>
<ol>
<li><p>Change class template synopsis <tt>std::basic_string</tt>, 24.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, as indicated:</p>
<blockquote>
<pre>
size_type find (basic_string_view&lt;charT, traits> sv,
                size_type pos = 0) const noexcept;
size_type find (const basic_string&amp; str, size_type pos = 0) const noexcept;
size_type find (const charT* s, size_type pos, size_type n) const <ins>noexcept</ins>;
size_type find (const charT* s, size_type pos = 0) const;
size_type find (charT c, size_type pos = 0) const <ins>noexcept</ins>;
size_type rfind(basic_string_view&lt;charT, traits&gt; sv,
                size_type pos = npos) const noexcept;
size_type rfind(const basic_string&amp; str, size_type pos = npos) const noexcept;
size_type rfind(const charT* s, size_type pos, size_type n) const <ins>noexcept</ins>;
size_type rfind(const charT* s, size_type pos = npos) const;
size_type rfind(charT c, size_type pos = npos) const <ins>noexcept</ins>;
size_type find_first_of(basic_string_view&lt;charT, traits&gt; sv,
                        size_type pos = 0) const noexcept;
size_type find_first_of(const basic_string&amp; str,
                        size_type pos = 0) const noexcept;
size_type find_first_of(const charT* s,
                        size_type pos, size_type n) const <ins>noexcept</ins>;
size_type find_first_of(const charT* s, size_type pos = 0) const;
size_type find_first_of(charT c, size_type pos = 0) const <ins>noexcept</ins>;
size_type find_last_of (basic_string_view&lt;charT, traits&gt; sv,
                        size_type pos = npos) const noexcept;
size_type find_last_of (const basic_string&amp; str,
                        size_type pos = npos) const noexcept;
size_type find_last_of (const charT* s,
                        size_type pos, size_type n) const <ins>noexcept</ins>;
size_type find_last_of (const charT* s, size_type pos = npos) const;
size_type find_last_of (charT c, size_type pos = npos) const <ins>noexcept</ins>;
size_type find_first_not_of(basic_string_view&lt;charT, traits&gt; sv,
                            size_type pos = 0) const noexcept;
size_type find_first_not_of(const basic_string&amp; str,
                            size_type pos = 0) const noexcept;
size_type find_first_not_of(const charT* s, size_type pos,
                            size_type n) const <ins>noexcept</ins>;
size_type find_first_not_of(const charT* s, size_type pos = 0) const;
size_type find_first_not_of(charT c, size_type pos = 0) const <ins>noexcept</ins>;
size_type find_last_not_of (basic_string_view&lt;charT, traits&gt; sv,
                            size_type pos = npos) const noexcept;
size_type find_last_not_of (const basic_string&amp; str,
                            size_type pos = npos) const noexcept;
size_type find_last_not_of (const charT* s, size_type pos,
                            size_type n) const <ins>noexcept</ins>;
size_type find_last_not_of (const charT* s,
                            size_type pos = npos) const;
size_type find_last_not_of (charT c, size_type pos = npos) const <ins>noexcept</ins>;

basic_string substr(size_type pos = 0, size_type n = npos) const;
int compare(basic_string_view&lt;charT, traits&gt; sv) const noexcept;
int compare(size_type pos1, size_type n1,
            basic_string_view&lt;charT, traits&gt; sv) const;
template&lt;class T&gt;
  int compare(size_type pos1, size_type n1, const T&amp; t,
              size_type pos2, size_type n2 = npos) const;
int compare(const basic_string&amp; str) const noexcept;
int compare(size_type pos1, size_type n1,
            const basic_string&amp; str) const;
int compare(size_type pos1, size_type n1,
            const basic_string&amp; str,
            size_type pos2, size_type n2 = npos) const;
int compare(const charT* s) const <ins>noexcept</ins>;
int compare(size_type pos1, size_type n1,
            const charT* s) const;
int compare(size_type pos1, size_type n1,
            const charT* s, size_type n2) const;
</pre>
</blockquote>
</li>

<li><p>Change 24.3.2.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.find">[string.find]</a> as indicated:</p>

<blockquote>
<pre>
size_type find(const charT* s, size_type pos, size_type n) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> <tt>find(basic_string_view&lt;charT, traits&gt;(s, n), pos)</tt>.
</p>
</blockquote>
<pre>
size_type find(const charT* s, size_type pos = 0) const;
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> <tt>s</tt> points to an array of at least <tt>traits::length(s) + 1</tt> elements of <tt>charT</tt>.
<p/>
-7- <i>Returns:</i> <tt>find(basic_string_view&lt;charT, traits&gt;(s), pos)</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
<pre>
size_type find(charT c, size_type pos = 0) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> <tt>find(basic_string<ins>_view&lt;charT, traits&gt;(addressof(c), 1)</ins><del>(1, c)</del>, pos)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 24.3.2.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.rfind">[string.rfind]</a> as indicated:</p>

<blockquote>
<pre>
size_type rfind(const charT* s, size_type pos, size_type n) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> <tt>rfind(basic_string_view&lt;charT, traits&gt;(s, n), pos)</tt>.
</p>
</blockquote>
<pre>
size_type rfind(const charT* s, size_type pos = npos) const;
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> <tt>s</tt> points to an array of at least <tt>traits::length(s) + 1</tt> elements of <tt>charT</tt>.
<p/>
-7- <i>Returns:</i> <tt>rfind(basic_string_view&lt;charT, traits&gt;(s), pos)</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
<pre>
size_type rfind(charT c, size_type pos = npos) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> <tt>rfind(basic_string<ins>_view&lt;charT, traits&gt;(addressof(c), 1)</ins><del>(1, c)</del>, pos)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 24.3.2.7.4 <a href="https://timsong-cpp.github.io/cppwp/string.find.first.of">[string.find.first.of]</a> as indicated:</p>

<blockquote>
<pre>
size_type
  find_first_of(const charT* s, size_type pos, size_type n) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> <tt>find_first_of(basic_string_view&lt;charT, traits&gt;(s, n), pos)</tt>.
</p>
</blockquote>
<pre>
size_type find_first_of(const charT* s, size_type pos = 0) const;
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> <tt>s</tt> points to an array of at least <tt>traits::length(s) + 1</tt> elements of <tt>charT</tt>.
<p/>
-7- <i>Returns:</i> <tt>find_first_of(basic_string_view&lt;charT, traits&gt;(s), pos)</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
<pre>
size_type find_first_of(charT c, size_type pos = 0) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> <tt>find_first_of(basic_string<ins>_view&lt;charT, traits&gt;(addressof(c), 1)</ins><del>(1, c)</del>, pos)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 24.3.2.7.5 <a href="https://timsong-cpp.github.io/cppwp/string.find.last.of">[string.find.last.of]</a> as indicated:</p>

<blockquote>
<pre>
size_type find_last_of(const charT* s, size_type pos, size_type n) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> <tt>find_last_of(basic_string_view&lt;charT, traits&gt;(s, n), pos)</tt>.
</p>
</blockquote>
<pre>
size_type find_last_of(const charT* s, size_type pos = npos) const;
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> <tt>s</tt> points to an array of at least <tt>traits::length(s) + 1</tt> elements of <tt>charT</tt>.
<p/>
-7- <i>Returns:</i> <tt>find_last_of(basic_string_view&lt;charT, traits&gt;(s), pos)</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
<pre>
size_type find_last_of(charT c, size_type pos = npos) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> <tt>find_last_of(basic_string<ins>_view&lt;charT, traits&gt;(addressof(c), 1)</ins><del>(1, c)</del>, pos)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 24.3.2.7.6 <a href="https://timsong-cpp.github.io/cppwp/string.find.first.not.of">[string.find.first.not.of]</a> as indicated:</p>

<blockquote>
<pre>
size_type
  find_first_not_of(const charT* s, size_type pos, size_type n) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> <tt>find_first_not_of(basic_string_view&lt;charT, traits&gt;(s, n), pos)</tt>.
</p>
</blockquote>
<pre>
size_type find_first_not_of(const charT* s, size_type pos = 0) const;
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> <tt>s</tt> points to an array of at least <tt>traits::length(s) + 1</tt> elements of <tt>charT</tt>.
<p/>
-7- <i>Returns:</i> <tt>find_first_not_of(basic_string_view&lt;charT, traits&gt;(s), pos)</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
<pre>
size_type find_first_not_of(charT c, size_type pos = 0) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> <tt>find_first_not_of(basic_string<ins>_view&lt;charT, traits&gt;(addressof(c), 1)</ins><del>(1, c)</del>, pos)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 24.3.2.7.7 <a href="https://timsong-cpp.github.io/cppwp/string.find.last.not.of">[string.find.last.not.of]</a> as indicated:</p>

<blockquote>
<pre>
size_type find_last_not_of(const charT* s, size_type pos,
                           size_type n) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> <tt>find_last_not_of(basic_string_view&lt;charT, traits&gt;(s, n), pos)</tt>.
</p>
</blockquote>
<pre>
size_type find_last_not_of(const charT* s, size_type pos = npos) const;
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> <tt>s</tt> points to an array of at least <tt>traits::length(s) + 1</tt> elements of <tt>charT</tt>.
<p/>
-7- <i>Returns:</i> <tt>find_last_not_of(basic_string_view&lt;charT, traits&gt;(s), pos)</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
<pre>
size_type find_last_not_of(charT c, size_type pos = npos) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> <tt>find_last_not_of(basic_string<ins>_view&lt;charT, traits&gt;(addressof(c), 1)</ins><del>(1, c)</del>, pos)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 24.3.2.7.9 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a> as indicated:</p>

<blockquote>
<pre>
int compare(const charT* s) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-9- <i>Returns:</i> <tt>compare(basic_string<ins>_view&lt;charT, traits&gt;</ins>(s))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2839" href="2839">2839.</a> Self-move-assignment of library types, again</h3>
<p><b>Section:</b> 20.5.5.15 <a href="https://timsong-cpp.github.io/cppwp/lib.types.movedfrom">[lib.types.movedfrom]</a>, 20.5.4.9 <a href="https://timsong-cpp.github.io/cppwp/res.on.arguments">[res.on.arguments]</a>, 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-09 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2468">2468</a>'s resolution added to <tt>MoveAssignable</tt> the requirement to tolerate self-move-assignment, 
but that does nothing for library types that aren't explicitly specified to meet <tt>MoveAssignable</tt> other than make 
those types not meet <tt>MoveAssignable</tt> any longer.
<p/>
To realize the intent here, we need to carve out an exception to 20.5.4.9 <a href="https://timsong-cpp.github.io/cppwp/res.on.arguments">[res.on.arguments]</a>'s restriction for 
move assignment operators and specify that self-move-assignment results in valid but unspecified state unless otherwise 
specified. The proposed wording below adds that to 20.5.5.15 <a href="https://timsong-cpp.github.io/cppwp/lib.types.movedfrom">[lib.types.movedfrom]</a> since it seems to fit well with the
theme of the current paragraph in that section. 
<p/> In addition, to address the issue with 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> noted in LWG 
<a href="2468">2468</a>'s discussion, the requirement tables in that subclause will need to be edited in a way similar to 
LWG <a href="2468">2468</a>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Add a new paragraph at the end of 20.5.5.15 <a href="https://timsong-cpp.github.io/cppwp/lib.types.movedfrom">[lib.types.movedfrom]</a>:</p>
<blockquote>
<p>
-1- Objects of types defined in the C++ standard library may be moved from (12.8). Move operations may be
explicitly specified or implicitly generated. Unless otherwise specified, such moved-from objects shall be
placed in a valid but unspecified state.
<p/>
<ins>-?- An object of a type defined in the C++ standard library may be move-assigned (15.8.2 <a href="https://timsong-cpp.github.io/cppwp/class.copy.assign">[class.copy.assign]</a>) 
to itself. Such an assignment places the object in a valid but unspecified state unless otherwise specified.</ins>
</p>
</blockquote>
</li>

<li><p>Add a note at the end of 20.5.4.9 <a href="https://timsong-cpp.github.io/cppwp/res.on.arguments">[res.on.arguments]</a>/1, bullet 3, as indicated:</p>
<blockquote>
<p>
-1- Each of the following applies to all arguments to functions defined in the C++ standard library, unless
explicitly stated otherwise.
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; [&hellip;]</p></li>
<li><p>(1.2) &mdash; [&hellip;]</p></li>
<li><p>(1.3) &mdash; If a function argument binds to an rvalue reference parameter, the implementation may 
assume that this parameter is a unique reference to this argument. [<i>Note:</i> If the parameter is a generic parameter
of the form <tt>T&amp;&amp;</tt> and an lvalue of type <tt>A</tt> is bound, the argument binds to an lvalue reference 
(14.8.2.1) and thus is not covered by the previous sentence. &mdash; <i>end note</i>] [<i>Note:</i> If a program 
casts an lvalue to an xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument
<tt>std::move(x)</tt>), the program is effectively asking that function to treat that lvalue as a temporary.
The implementation is free to optimize away aliasing checks which might be needed if the argument
was an lvalue. &mdash; <i>end note</i>] <ins>[<i>Note:</i> This does not apply to the argument passed to a 
move assignment operator (20.5.5.15 <a href="https://timsong-cpp.github.io/cppwp/lib.types.movedfrom">[lib.types.movedfrom]</a>). &mdash; <i>end note</i>]</ins></p></li>
</ol>
</blockquote>
</li>

<li><p>Edit Table 83 "Container requirements" in 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 83 &mdash; Container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td><tt>a = rv</tt></td>
<td><tt>T&amp;</tt></td>
<td>All existing elements of <tt>a</tt><br/> 
are either move<br/> 
assigned to or<br/>  
destroyed</td>
<td><ins>post: If <tt>a</tt> and <tt>rv</tt> do not refer to the same object,</ins><br/> 
<tt>a</tt> shall be equal to the value that<br/>  
<tt>rv</tt> had before this assignment</td>
<td>linear</td>
</tr>

<tr>
<td colspan="5" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Edit Table 86 "Allocator-aware container requirements" in 26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 86 &mdash;  Allocator-aware container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>
<tr>
<td><tt>a = rv</tt></td>
<td><tt>T&amp;</tt></td>
<td>
<i>Requires</i>: If <tt>allocator_traits&lt;allocator_type<br/> 
&gt;::propagate_on_container_move_assignment::value</tt><br/>
is <tt>false</tt>, <tt>T</tt> is <tt>MoveInsertable</tt><br/>  
into <tt>X</tt> and <tt>MoveAssignable</tt>.<br/>  
All existing elements of <tt>a</tt> are either<br/>  
move assigned to or destroyed.<br/>
post: <ins>If <tt>a</tt> and <tt>rv</tt> do not refer<br/>  
to the same object,</ins> <tt>a</tt> shall be equal<br/> 
to the value that <tt>rv</tt> had before this assignment</td>
<td>linear</td>
</tr>
<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>
</table>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2840" href="2840">2840.</a> <tt>directory_iterator::increment</tt> is seemingly narrow-contract but marked <tt>noexcept</tt></h3>
<p><b>Section:</b> 30.10.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a>, 30.10.14.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-09 <b>Last modified:</b> 2017-03-19 19:03:20 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.dir.itr.members">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>directory_iterator::increment</tt> and <tt>recursive_directory_iterator::increment</tt> are specified by 
reference to the input iterator requirements, which is narrow-contract: it has a precondition that the iterator
is dereferenceable. Yet they are marked as <tt>noexcept</tt>.
<p/>
Either the <tt>noexcept</tt> (one of which was added by LWG <a href="2637">2637</a>) should be removed, or the 
behavior of <tt>increment</tt> when given a nondereferenceable iterator should be specified.
<p/>
Currently, libstdc++ and MSVC report an error via the <tt>error_code</tt> argument for a nondereferenceable 
<tt>directory_iterator</tt>, while libc++ and <tt>boost::filesystem</tt> assert.
</p>
<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2; there are some problems with the wording in alternative B.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol style="list-style-type: none">
<li><p>Alternative A (remove the <tt>noexcept</tt>):</p>

<ol>
<li><p>Edit 30.10.13 <a href="https://timsong-cpp.github.io/cppwp/fs.class.directory_iterator">[fs.class.directory_iterator]</a>, class <tt>directory_iterator</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
directory_iterator&amp; operator++();
directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
</blockquote>
</li>

<li><p>Edit 30.10.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a> before p10 as indicated:</p>
<blockquote>
<pre>
directory_iterator&amp; operator++();
directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-10- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3).
<p/>
-11- <i>Returns:</i> <tt>*this</tt>.
<p/>
-12- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 30.10.14 <a href="https://timsong-cpp.github.io/cppwp/fs.class.rec.dir.itr">[fs.class.rec.dir.itr]</a>, class <tt>recursive_directory_iterator</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
</blockquote>
</li>

<li><p>Edit 30.10.14.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> before p23 as indicated:</p>
<blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-23- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3), except that: [&hellip;]
<p/>
-24- <i>Returns:</i> <tt>*this</tt>.
<p/>
-25- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li><p>Alternative B (specify that <tt>increment</tt> reports an error if the iterator is not dereferenceable):</p>

<ol>
<li><p>Edit 30.10.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a> p10 as indicated:</p>
<blockquote>
<pre>
directory_iterator&amp; operator++();
directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-10- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3)<ins>, except that 
<tt>increment</tt> reports an error if <tt>*this</tt> is not dereferenceable</ins>.
<p/>
-11- <i>Returns:</i> <tt>*this</tt>.
<p/>
-12- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 30.10.14.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> p23 as indicated:</p>
<blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-23- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3), except that: 
</p>
<ul>
<li><p><ins><tt>increment</tt> reports an error if <tt>*this</tt> is not dereferenceable.</ins></p></li>
<li><p>If there are no more entries at the current depth, [&hellip;]</p></li>
<li><p>Otherwise if [&hellip;]</p></li>
</ul>
<p>
-24- <i>Returns:</i> <tt>*this</tt>.
<p/>
-25- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>
</ol>







<hr>
<h3><a name="2841" href="2841">2841.</a> Use of "Equivalent to" in [strings]</h3>
<p><b>Section:</b> 24 <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2016-12-09 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#strings">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Reported via <a href="https://github.com/cplusplus/draft/issues/165">editorial issue #165</a>:
<p/>
The following places should probably use the "Equivalent to" wording introduced in
[structure.specifications]/4.
</p>
<blockquote>
<ol>
<li><p>
[string.cons]/18
</p>
<blockquote>
<p>
<i>Effects:</i> Same as <tt>basic_string(il.begin(), il.end(), a)</tt>.
</p>
</blockquote>
</li>
<li><p>
[string.capacity]/3
</p>
<blockquote>
<p>
<i>Returns:</i> <tt>size()</tt>.
</p>
</blockquote>
</li>
<li><p>
[string.capacity]/8
</p>
<blockquote>
<p>
<i>Effects:</i> As if by <tt>resize(n, charT())</tt>.
</p>
</blockquote>
</li>
<li><p>
[string.capacity]/16
</p>
<blockquote>
<p>
<i>Effects:</i> Behaves as if the function calls: <tt>erase(begin(), end());</tt>
</p>
</blockquote>
</li>
<li><p>
[string.capacity]/17
</p>
<blockquote>
<p>
<i>Returns:</i> <tt>size() == 0</tt>.
</p>
</blockquote>
</li>
<li><p>
[string.insert]/27
</p>
<blockquote>
<p>
<i>Effects:</i> As if by <tt>insert(p, il.begin(), il.end())</tt>.
<p/>
<i>Returns:</i> An iterator which refers to the copy of the first inserted character, or <tt>p</tt> if <tt>i1</tt> is empty.
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; Marshall to provide wording.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2843" href="2843">2843.</a> Unclear behavior of <tt>std::pmr::memory_resource::do_allocate()</tt></h3>
<p><b>Section:</b> 23.12.2.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.private">[mem.res.private]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-12-13 <b>Last modified:</b> 2017-02-21 18:02:06 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>do_allocate()</tt> (23.12.2.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.private">[mem.res.private]</a> p2+p3) says:
</p>
<blockquote>
<p>
<i>Returns:</i> A derived class shall implement this function to return a
pointer to allocated storage (3.7.4.2) with a size of at least <tt>bytes</tt>.
The returned storage is aligned to the specified alignment, if such
alignment is supported (3.11); otherwise it is aligned to <tt>max_align</tt>.
<p/>
<i>Throws:</i> A derived class implementation shall throw an appropriate
exception if it is unable to allocate memory with the requested size
and alignment.
</p>
</blockquote>
<p>
It is unclear whether a request for an unsupported alignment
(e.g. larger than <tt>max_align</tt>) yields an exception or the returned
storage is silently aligned to <tt>max_align</tt>.
<p/>
This is <a href="https://github.com/cplusplus/draft/issues/966">editorial issue #966</a>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; Marshall to ping Pablo for intent and provide wording.</p>

<p><i>[2017-02-12 Pablo responds and provides wording]</i></p>

<p>The original intent was:</p>
<ul>
  <li>If the alignment is supported by the implementation (see below), then it must use that alignment or else throw.</li>
  <li>If the alignment is not supported it must use max_align else throw.</li>
</ul>
<p>However, the description of do_allocate might have gone stale as the
aligned-allocation proposal made its way into the standard.</p>

<p>The understanding I take from the definition of extended alignment in
(the current text of) 3.11/3 [basic.align] and "assembling an argument
list" in 5.3.4/14 [expr.new] is that it is intended that, when
allocating space for an object with extended alignment in a well-formed
program, the alignment <i>will</i> be honored and <i>will not be</i>
truncated to max_align. I think this is a change from earlier drafts of
the extended-alignment proposal, where silent truncation to <tt>max_align</tt>
was permitted (I could be wrong). Anyway, it seems wrong to ever ignore
the alignment parameter in <tt>do_allocate()</tt>.</p>


<p><b>Proposed resolution:</b></p>
<p>Change the specification of <tt>do_allocate()</tt> (23.12.2.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.private">[mem.res.private]</a> p2+p3) as follows:</p>

<blockquote>
  <p><i>Returns</i>: A derived class shall implement this function to
  return a pointer to allocated storage (3.7.4.2) with a size of at
  least <tt>bytes</tt><ins>, aligned to the specified
  <tt>alignment</tt></ins>. <del>The returned storage is aligned to the
  specified alignment, if such alignment is supported; otherwise it is
  aligned to <tt>max_align</tt>.</del></p>

<p><i>Throws:</i> A derived class implementation shall throw an
appropriate exception if it is unable to allocate memory with the
requested size and alignment.</p>
</blockquote>





<hr>
<h3><a name="2844" href="2844">2844.</a> Stability of <tt>a_uniq.insert(i, j)</tt></h3>
<p><b>Section:</b> 26.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2016-12-14 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we write <tt>a_uniq.insert(i, j)</tt> and <tt>[i, j)</tt> has multiple elements with keys that compare equivalent, 
which ones get inserted? Consider, for example, inserting into a <tt>map&lt;string, int&gt;</tt> with
</p>
<blockquote><pre>
m.insert({{"red", 5}, {"green", 3}, {"red", 7}, {"blue", 2}, {"pink", 6}});
</pre></blockquote>
<p>
Which value for <tt>"red"</tt> will the map have?
<p/>
On my implementation we got <tt>"red" -&gt; 5</tt>, and I suspect that's true on most or all implementations, but I don't believe 
that's guaranteed by anything in the requirements. The wording in Table 90 just says that it "inserts each element from 
the range <tt>[i, j)</tt> if and only if there is no element with key equivalent to the key of that element", but that 
doesn't tell us what happens if <tt>[i, j)</tt> contains duplicate keys because it doesn't say what order the insertions 
are performed in. The standard should either guarantee that the first value is the one that gets inserted, or explicitly 
say that this is unspecified.
<p/>
The same issue applies to the range constructor, and to the unordered associative containers.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; Nico to provide wording.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2845" href="2845">2845.</a> <tt>enable_if</tt>, <tt>result_of</tt>, <tt>common_type</tt> and <tt>aligned_storage</tt> do not meet the definition 
of <tt>TransformationTrait</tt></h3>
<p><b>Section:</b> 23.15.1 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-14 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.rqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[meta.rqmts]/3 defines <tt>TransformationTrait</tt> as follows:
</p>
<blockquote><p>
A <tt><i>TransformationTrait</i></tt> modifies a property of a type. It shall be a class template that takes 
one template type argument and, optionally, additional arguments that help define the modification. It shall 
define a publicly accessible nested type named <tt>type</tt>, which shall be a synonym for the modified type.
</p></blockquote>
<p>
<tt>enable_if</tt>, <tt>result_of</tt> and <tt>common_type</tt> do not necessarily "define a publicly accessible nested type named <tt>type</tt>". 
<tt>aligned_storage</tt> takes no template type argument (it only has two non-type parameters). Yet [meta.trans]/2 
says that they are all <tt>TransformationTraits</tt>.
<p/>
Incidentally, with the exception of <tt>decay</tt>, it's not clear that any of the traits in [meta.trans.other] 
could really be described as "modify[ing] a property of a type".
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2846" href="2846">2846.</a> Undefined phrase "effectively cast"</h3>
<p><b>Section:</b> 29.5.9 <a href="https://timsong-cpp.github.io/cppwp/cmplx.over">[cmplx.over]</a>, 29.9.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-12-15 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cmplx.over">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/cmplx.over">[cmplx.over]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [cmplx.over] and [cmath.syn], when talking about "sufficient additional overloads", we use the phrase
"effectively cast", but that is not a defined term.
<p/>
A hostile interpretation could read "<tt>reinterpret_cast</tt>" here.
<p/>
Likely we mean "apply floating-point promotions, floating-integral
conversions, and floating-point conversions", but that should be
spelled out somewhere, e.g. in the library definitions section.
<p/>
(Source: <a href="https://github.com/cplusplus/draft/issues/1248">Editorial issue #1248</a>)
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2847" href="2847">2847.</a> <tt>sin(float)</tt> should call <tt>sinf(float)</tt></h3>
<p><b>Section:</b> 29.9.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-12-15 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cmath.syn">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#cmath.syn">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With <a href="http://wg21.link/p0175r1">P0175R1</a>, we now show in [cmath.syn] three overloads for
the <tt>sin</tt> function: One taking a <tt>float</tt>, one taking a <tt>double</tt>,
and one taking a <tt>long double</tt>. However, there is no statement that <tt>sin(long double)</tt> 
should actually invoke <tt>sinl</tt>, presumably delivering extra precision.
<p/>
An implementation like
</p>
<blockquote><pre>
inline long double sin(long double x)
{ return sinf(x); }
</pre></blockquote>
<p>
seems to satisfy the "effectively cast" requirement, but is certainly unintentional.
<p/>
The same issue arises for all math functions inherited from C.
<p/>
(Source: <a href="https://github.com/cplusplus/draft/issues/1247">Editorial issue #1247</a>)
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2848" href="2848">2848.</a> Pass-through threshold for pool allocator</h3>
<p><b>Section:</b> 23.12.5.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.pool.options">[mem.res.pool.options]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-12-15 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.12.5.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.pool.options">[mem.res.pool.options]</a> p3 talks about a "pass-through-threshold".
<p/>
First, the phrase is not defined and it seems it could be easily avoided given the context.
<p/>
Second, given the phrasing here, it seems the implementation is essentially allowed to 
ignore the value <tt>largest_required_pool_block</tt> as it sees fit. It is unclear whether 
that is the intention.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; Jonathan will ask Alisdair for wording.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2849" href="2849">2849.</a> Why does <tt>!is_regular_file(from)</tt> cause <tt>copy_file</tt> to report a "file already exists" error?</h3>
<p><b>Section:</b> 30.10.15.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy_file">[fs.op.copy_file]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-17 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.copy_file">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy_file">[fs.op.copy_file]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.10.15.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy_file">[fs.op.copy_file]</a>/4 says that <tt>copy_file</tt> reports "a file already exists error as specified in 
[fs.err.report] if" any of several error conditions exist.
<p/>
It's not clear how some of those error conditions, such as <tt>!is_regular_file(from)</tt>, can be sensibly described 
as "file already exists". Pretty much everywhere else in the filesystem specification just says "an error" without 
further elaboration.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2; Jonathan to provide updated wording.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit [fs.op.copy_file]/4 as indicated:</p>
<blockquote>
<pre>
bool copy_file(const path&amp; from, const path&amp; to, copy_options options);
bool copy_file(const path&amp; from, const path&amp; to, copy_options options,
               error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> As follows:
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; Report <del>a file already exists</del><ins>an</ins> error as specified in 30.10.7 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a> if:</p></li>
<li>
<ol style="list-style-type: none">
<li><p>(4.1.1) &mdash;[&hellip;]</p></li>
</ol>
</li>
<li><p>(4.2) &mdash;[&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2851" href="2851">2851.</a> <tt>std::filesystem</tt> enum classes are now underspecified</h3>
<p><b>Section:</b> 30.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.file_type">[fs.enum.file_type]</a>, 30.10.10.3 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.copy.opts">[fs.enum.copy.opts]</a>, 30.10.10.6 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.dir.opts">[fs.enum.dir.opts]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-18 <b>Last modified:</b> 2017-03-19 19:03:20 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.enum.file_type">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fs.enum.file_type">[fs.enum.file_type]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2678">2678</a> stripped the numerical values of the enumerators from three enum classes in 30.10.10 <a href="https://timsong-cpp.github.io/cppwp/fs.enum">[fs.enum]</a>; 
in doing so it also removed the implicit specification 1) of the bitmask elements for the two bitmask types (<tt>copy_options</tt> 
and <tt>directory_options</tt>) and 2) that the <tt>file_type</tt> constants are distinct.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2; Jonathan to work with Tim to tweak wording.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 30.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.file_type">[fs.enum.file_type]</a>/1 as indicated:</p>
<blockquote>
<p>
This enum class specifies constants used to identify file types, with the meanings listed in Table 122. <ins>The 
values of the constants are distinct.</ins>
</p>
</blockquote>
</li>

<li><p>Edit 30.10.10.3 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.copy.opts">[fs.enum.copy.opts]</a>/1 as indicated:</p>
<blockquote>
<p>
The <tt>enum class</tt> type <tt>copy_options</tt> is a bitmask type (20.4.2.1.4 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a>) that specifies 
bitmask constants used to control the semantics of copy operations. The constants are specified in option groups with the meanings
listed in Table 123. <ins>The constant <tt>none</tt> represents the empty bitmask, and </ins><del>Constant <tt>none</tt></del> 
is shown in each option group for purposes of exposition; implementations shall provide only a single definition. <ins>Every 
other constant in the table represents a distinct bitmask element.</ins> Calling a library function with more than a single 
constant for an option group results in undefined behavior.
</p>
</blockquote>
</li>

<li><p>Edit 30.10.10.6 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.dir.opts">[fs.enum.dir.opts]</a>/1 as indicated:</p>
<blockquote>
<p>
The <tt>enum class</tt> type <tt>directory_options</tt> is a bitmask type (20.4.2.1.4 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a>) that specifies 
bitmask constants used to identify directory traversal options, with the meanings listed in Table 125. <ins>The constant 
<tt>none</tt> represents the empty bitmask; every other constant in the table represents a distinct bitmask element.</ins>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2852" href="2852">2852.</a> Specifications of <tt>operator==</tt> for <tt>std::basic_string</tt>s and <tt>std::basic_string_view</tt>s are 
difficult to conform to</h3>
<p><b>Section:</b> 24.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.operator==">[string.operator==]</a>, 24.3.2.7.9 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ahti Lepp&auml;nen <b>Opened:</b> 2017-01-09 <b>Last modified:</b> 2017-02-05 16:02:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently (<a href="http://wg21.link/n4618">N4618</a>, 2016-11-28) the specification of <tt>operator==</tt> 
for <tt>std::basic_string</tt> and <tt>std::basic_string_view</tt> objects is clearly defined, but when 
interpreted as written, it may lead to comparison of strings of different sizes being a &#x1d4aa;(n) operation 
instead of a simple size check. Actual implementations in standard libraries vary so that in practice the 
programmers can't rely neither on having the literal version of the standard specification nor reasonable 
performance characteristics.
<p/>
The definition for <tt>basic_string operator==</tt> in N4618 is as follows:
</p>
<blockquote>
<p>
24.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.operator==">[string.operator==]</a>
</p>
<pre>
bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,
                const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>lhs.compare(rhs) == 0</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<p>
24.3.2.7.9 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a>
</p>
<pre>
int compare(const basic_string&amp; str) const noexcept;
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Equivalent to: <tt>return compare(basic_string_view&lt;charT, traits&gt;(str));</tt>
</p>
</blockquote>
</blockquote>

<blockquote>
<p>
24.3.2.7.9 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a>
</p>
<pre>
int compare(basic_string_view&lt;charT, traits&gt; sv) const noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Determines the effective length <tt>rlen</tt> of the strings to compare as the smaller of 
<tt>size()</tt> and <tt>sv.size()</tt>. The function then compares the two strings by calling <tt>traits::compare(data(),
sv.data(), rlen)</tt>.
<p/>
-2- <i>Returns:</i> The nonzero result if the result of the comparison is nonzero. Otherwise, returns a value as
indicated in Table 63.
</p>
</blockquote>
<blockquote>
<table border="1">
<caption>Table 63 &mdash; <tt>compare()</tt> results</caption>
<tr>
<th>Condition</th>
<th>Return Value</th>
</tr>

<tr>
<td><tt>size() &lt; sv.size()</tt></td>
<td><tt>&lt; 0</tt></td>
</tr>

<tr>
<td><tt>size() == sv.size()</tt></td>
<td><tt>0</tt></td>
</tr>

<tr>
<td><tt>size() &gt; sv.size()</tt></td>
<td><tt>&gt; 0</tt></td>
</tr>
</table>

</blockquote>
</blockquote>
<p>
From these it seems that <tt>compare()</tt> of strings of different sizes can't return zero and <tt>operator==</tt> 
will return <tt>false</tt>. However some implementations do not seem to call <tt>traits::compare()</tt> for 
<tt>basic_string</tt>s of different sizes even when the traits and it's <tt>compare()</tt> are user-defined. And those 
that call, make the <tt>operator==</tt> a worst case &#x1d4aa;(n) operation even for strings of different sizes.
<p/>
This defect report does not propose a wording, but on a general level the wording should allow standard library 
implementers to write a standard conforming <tt>operator==</tt> for <tt>basic_string</tt> and <tt>basic_string_view</tt> 
(others?) in such a way that it's performance characteristics are reasonable and the programmers can rely on having 
a consistent behaviour across implementations. Perhaps the key issue here is that <tt>operator==</tt> is defined 
through <tt>compare() == 0</tt>: while it returns the intended result, for some inputs it does computations that 
are not needed by <tt>operator==</tt>. There are also related specifications that may need to be revised, for example 
<tt>operator!=</tt> for <tt>basic_string_view</tt>s is defined in 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a> as
</p>
<blockquote>
<p>
<i>Returns:</i> <tt>lhs.compare(rhs) != 0</tt>
</p>
</blockquote>

<p><i>[2017-01-26, Jonathan Wakely comments and provides proposed resolution]</i></p>

<p>
As mentioned above, some implementations do not make a call to <tt>Traits::compare</tt> if the string lengths are not equal, 
even though in general this is an observable side effect. Some implementations only perform that optimisation for 
<tt>std::string</tt> and <tt>std::wstring</tt>, where we know that calls to <tt>std::char_traits&lt;char&gt;::compare</tt> 
and <tt>std::char_traits&lt;wchar_t&gt;::compare</tt> are not observable.
<p/>
My reading is that the <i>Returns:</i> element describes the value that must be returned, not the precise steps that must be 
taken to calculate that value. If we intended to specify the precise steps that must be taken then we could say that using 
"<i>Effects:</i> Equivalent to [&hellip;]", but we don't do that.
<p/>
I would prefer this issue to be closed NAD with the rationale that my reading is correct and comparing the lengths to avoid 
calling <tt>Traits::compare</tt> is already permitted. But if my reading is wrong we need to permit this obvious optimisation.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2</p>

<p><i>[2017-02-04, Ahti Lepp&auml;nen comments and recommends NAD]</i></p>

<p>
While there seems to be varying interpretations of the standards wording, given the comments in this defect report and 
definitions in  [structure.specification] (N4618):
</p>
<blockquote><p>
<i>Effects:</i> the actions performed by the function
<p/>
<i>Returns:</i> a description of the value(s) returned by the function
</p>
</blockquote>
<p>
I fail to see that the specification of <tt>operator==</tt> "<i>Returns:</i> <tt>lhs.compare(rhs) == 0</tt>" would require call 
to <tt>compare()</tt> and no longer consider the report valid.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol style="list-style-type:upper-alpha">
<li><p>Preferred: NAD</p></li>
<li><p>Alternative:</p>

<ol>
<li><p>Modify 24.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.operator==">[string.operator==]</a> p1 as shown:</p>
<blockquote>
<pre>
template&lt;class charT, class traits, class Allocator&gt;
  bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt><ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a> as shown:</p>
<blockquote>
<p>
[<i>Example:</i> A sample conforming implementation for <tt>operator==</tt> would be:
</p>
<pre>
template&lt;class T&gt; using __identity = decay_t&lt;T&gt;;
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept {
    return <ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0;
  }
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            __identity&lt;basic_string_view&lt;charT, traits&gt;&gt; rhs) noexcept {
    return <ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0;
  }
template&lt;class charT, class traits&gt;
  constexpr bool operator==(__identity&lt;basic_string_view&lt;charT, traits&gt;&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept {
    return <ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0;
  }
</pre>
<p>
&mdash; <i>end example</i>]
</p>
<pre>
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;
</pre>
<blockquote>
<p>
-2- <i>Returns:</i> <tt><ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0</tt>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <tt><ins>lhs.size() != rhs.size() ||</ins> lhs.compare(rhs) != 0</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>

</li>
</ol>





<hr>
<h3><a name="2854" href="2854">2854.</a> <tt>wstring_convert</tt> provides no indication of incomplete input or output</h3>
<p><b>Section:</b> 99 [conversions.string] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> PowerGamer <b>Opened:</b> 2017-01-08 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Example:
</p>
<blockquote><pre>
// Input UTF-16 string is incomplete - only first half of
// UTF-16 surrogate pair L"\xD843\xDEF9":
wchar_t in_utf16[] = L"\xD843";

std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt; cvt;
auto out_utf8 = cvt.to_bytes(in_utf16); // No error.
</pre></blockquote>
<p>
There is no indication that input was incomplete (the value returned
by <tt>cvt.state()</tt> is not documented and so cannot be examined by user for
that purpose). As such the user will not know that more input data
should be provided in additional call to <tt>cvt.to_bytes()</tt>.
<p/>
The output can be incomplete too: MSVC2017 implementation (which as
far as I can tell is standard conforming) produces <tt>"\xF0"</tt> in <tt>out_utf8</tt>.
Again, no indication of incomplete output produced is provided by
<tt>std::wstring_convert</tt>.
<p/>
IMO it makes <tt>std::wstring_convert</tt> in its current state completely
useless (it cannot be relied upon to either produce complete and valid
UTF sequence or throw an error in all situations).
<p/>
Imagine a file has UTF16 encoded text. You want to read all the data
from a file at once and convert it into UTF8 using
<tt>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt;</tt>.
<p/>
Now, if a file contains completely <em>invalid</em> UTF16 (for example,
forbidden or incorrectly encoded Unicode code points) you will get an
exception from <tt>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt;</tt>.
<p/>
But if a file contains <em>incomplete</em> (but in all other regards <em>valid</em>)
UTF16 (for ex. file ends with only the first half of a valid surrogate
pair) you will <em>neither</em> get an error exception from
<tt>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt;</tt> <em>nor</em> any
indication that the input provided to 
<tt>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt;</tt> was incomplete.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; send to LEWG</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2856" href="2856">2856.</a> <tt>std::async</tt> should be marked as <tt>[[nodiscard]]</tt></h3>
<p><b>Section:</b> 33.6.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Andrey Davydov <b>Opened:</b> 2017-01-20 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Because the destructor of the <tt>std::future</tt> returned from the <tt>std::async</tt> blocks until 
the asynchronous operation completes, discarding the <tt>std::async</tt> return value leads to the 
synchronous code execution, which is pointless. For example, in the following code
</p>
<blockquote>
<pre>
void task1();
void task2();

void foo()
{
  std::async(std::launch::async,  task1),
  std::async(std::launch::async,  task2);
}

void bar()
{
  std::async(std::launch::async,  task1);
  std::async(std::launch::async,  task2);
}
</pre>
</blockquote>
<p>
<tt>task1</tt> and <tt>task2</tt> will be concurrently executed in the function 'foo', but sequentially in the function 'bar'.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2; Nico to provide wording.</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>This should be handled by Nico's paper <a href="http://wg21.link/P0600">P0600</a>.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2858" href="2858">2858.</a> LWG 2472: actually an incompatibility with C++03</h3>
<p><b>Section:</b> 27.5.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2017-01-28 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterators">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Further to LWG <a href="2472">2472</a>, the case of <tt>reverse_iterator</tt> comparisons is a regression introduced 
by LWG <a href="280">280</a>.
<p/>
Consider the following program:
</p>
<blockquote><pre>
#include &lt;utility&gt;
#include &lt;iterator&gt;

using namespace std::rel_ops;

bool f(std::reverse_iterator&lt;int *&gt; it) { return it != it; }
</pre></blockquote>
<p>
Under C++03, the <tt>operator!=</tt> in lib.reverse.iterator is more specialized than the <tt>operator!=</tt> in <tt>std::rel_ops</tt>.
<p/>
Following LWG <a href="280">280</a>, neither <tt>operator!=</tt> candidate is more specialized than the other. The program is 
observed to fail with libc++.
<p/>
Online compiler example, see <a href="http://melpon.org/wandbox/permlink/aeOn1wiOi2CRKwwc">here</a>.
<p/>
Suggested resolution:
<p/>
Reintroduce the homogeneous comparison operators from C++03 alongside the new ones.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 4. STL to write a paper deprecating <tt>relops</tt> Alisdair to provide an example for Annex C.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 27.5.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a>, class template <tt>reverse_iterator</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
</blockquote>
</li>

<li><p>Modify 27.5.1.3.13 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.op==">[reverse.iter.op==]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>x.current == y.current</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.5.1.3.14 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.op&lt;">[reverse.iter.op&lt;]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>x.current &gt; y.current</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.5.1.3.15 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.op!=">[reverse.iter.op!=]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>x.current != y.current</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.5.1.3.16 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.op&gt;">[reverse.iter.op&gt;]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>x.current &lt; y.current</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.5.1.3.17 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.op&gt;=">[reverse.iter.op&gt;=]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>x.current &lt;= y.current</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.5.1.3.18 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.op&lt;=">[reverse.iter.op&lt;=]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>x.current &gt;= y.current</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2859" href="2859">2859.</a> Definition of <em>reachable</em> in [ptr.launder] misses pointer arithmetic from pointer-interconvertible object</h3>
<p><b>Section:</b> 21.6.4 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> <b>Status:</b> <a href="lwg-active.html#Core">Core</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2017-01-31 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ptr.launder">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.launder">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Core">Core</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given:
</p>
<blockquote><pre>
struct A { int x, y; };
A a[100];
</pre></blockquote>
<p>
The bytes which compose <tt>a[3]</tt> can be reached from <tt>&amp;a[2].x</tt>:
<tt>reinterpret_cast&lt;A *&gt;(&amp;a[2].x) + 1</tt> points to <tt>a[3]</tt>,
however, the definition of "reachable" in [ptr.launder] does not encompass this case.
</p>
<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 2. Assign this (and <ref iref="2860"/> to Core.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 21.6.4 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T&gt; constexpr T* launder(T* p) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Remarks:</i> An invocation of this function may be used in a core constant expression whenever the value
of its argument may be used in a core constant expression. A byte of storage <ins><tt><i>b</i></tt></ins> is 
reachable through a pointer value that points to an object <tt><i>Y</i></tt> if <ins>there is an object 
<tt><i>Z</i></tt>, pointer-interconvertible with <tt><i>Y</i></tt>, such that <tt><i>b</i></tt></ins> <del>it</del> 
is within the storage occupied by <tt><i><ins>Z</ins><del>Y</del></i></tt>, <del>an object that is 
pointer-interconvertible with <tt><i>Y</i></tt>,</del> or the immediately-enclosing array object if 
<tt><i><ins>Z</ins><del>Y</del></i></tt> is an array element. The program is ill-formed if <tt>T</tt> is a function type or 
(possibly <i>cv</i>-qualified) <tt>void</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2860" href="2860">2860.</a> <tt>launder</tt> and base class subobjects</h3>
<p><b>Section:</b> 21.6.4 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> <b>Status:</b> <a href="lwg-active.html#Core">Core</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2017-01-31 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ptr.launder">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.launder">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Core">Core</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is an apparent oversight in the wording for <tt>launder</tt> that allows it to return base class 
subobjects which differ in their polymorphic behaviour between calls to <tt>launder</tt>.
</p>
<p>
This can be fixed by restricting <tt>launder</tt> from returning pointers to base class subobjects:
</p>
<ol>
<li><p>always, or</p></li>
<li><p>only for polymorphic class types.</p></li>
</ol>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 2. This was discussed in EWG (via a paper). Assign this (and <ref iref="2859"/> to Core.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol style="list-style-type: none">
<li><p>Option 1:</p>

<ol>
<li><p>Modify 21.6.4 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T&gt; constexpr T* launder(T* p) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>p</tt> represents the address <tt><i>A</i></tt> of a byte in memory. An object <tt><i>X</i></tt> 
that is within its lifetime (6.8 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>) and whose type is similar (7.5 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to <tt>T</tt> 
is located at the address <tt><i>A</i></tt>. <ins><tt><i>X</i></tt> shall either be a most derived object, or 
pointer-interconvertible with a most derived object that is within its lifetime.</ins> All bytes of storage that would be 
reachable through the result are reachable through <tt>p</tt> (see below).
</p>
</blockquote>
</blockquote>
</li>

</ol>

</li>
<li><p>Option 2:</p>

<ol>
<li><p>Modify 21.6.4 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T&gt; constexpr T* launder(T* p) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>p</tt> represents the address <tt><i>A</i></tt> of a byte in memory. An object <tt><i>X</i></tt> 
that is within its lifetime (6.8 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>) and whose type is similar (7.5 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to <tt>T</tt> 
is located at the address <tt><i>A</i></tt>. <ins>If <tt>T</tt> is a polymorphic class type, then <tt><i>X</i></tt> shall 
be a most derived object.</ins> All bytes of storage that would be reachable through the result are reachable through 
<tt>p</tt> (see below).
</p>
</blockquote>
</blockquote>
</li>

</ol>

</li>
</ol>





<hr>
<h3><a name="2870" href="2870">2870.</a> Default value of parameter <tt>theta</tt> of <tt>polar</tt> should be dependent</h3>
<p><b>Section:</b> 29.5.7 <a href="https://timsong-cpp.github.io/cppwp/complex.value.ops">[complex.value.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-03 20:02:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.value.ops">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.value.ops">[complex.value.ops]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 25</b></p>

<p>Parameter <tt>theta</tt> of <tt>polar</tt> has the type of the 
template parameter. Therefore, it needs to change the default initial value 
to <tt>T()</tt>. The change of the declaration of this function in 
29.5.1 <a href="https://timsong-cpp.github.io/cppwp/complex.syn">[complex.syn]</a> is accompanied by this change.</p>

<p>
Proposed change:
</p>
<blockquote>
<pre>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = <del>0</del><ins>T()</ins>);
</pre>
</blockquote>

<p><i>[2017-02 pre-Kona]</i></p>

<p>
(twice)
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 29.5.1 <a href="https://timsong-cpp.github.io/cppwp/complex.syn">[complex.syn]</a>, header <tt>&lt;complex&gt;</tt> synopsis, as indicated:</p>

<blockquote><pre>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp;, const T&amp; = <del>0</del><ins>T()</ins>);
</pre></blockquote>
</li>

<li><p>Modify 29.5.7 <a href="https://timsong-cpp.github.io/cppwp/complex.value.ops">[complex.value.ops]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = <del>0</del><ins>T()</ins>);
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2871" href="2871">2871.</a> User specializations of type traits should be ill-formed</h3>
<p><b>Section:</b> 23.15.2 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:01 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 10</b></p>

<p>A user specialization of any type trait should produce 
an ill-formed program, not merely one whose behavior is unspecified.
See also the related comment re 23.19.3 <a href="https://timsong-cpp.github.io/cppwp/execpol.type">[execpol.type]</a>.</p>

<p>
Proposed change:
</p>
<p>
Reword the paragraph as follows:
</p>
<blockquote>
<p>
Unless otherwise specified, a program that adds 
specializations for any of the templates defined in 
this subclause is ill-formed; no diagnostic required.
</p>
</blockquote>

<p>
See also <a href="2909">2909</a>
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 23.15.2 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> as indicated:</p>
<blockquote>
<p>
-1- <del>The behavior of a program that adds specializations for any of the templates defined in this subclause is
undefined unless otherwise specified</del><ins>Unless otherwise specified, a program that adds 
specializations for any of the templates defined in this subclause is ill-formed; no diagnostic required</ins>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2880" href="2880">2880.</a> Relax complexity specifications for non-sequenced policies</h3>
<p><b>Section:</b> 28.4.3 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec">[algorithms.parallel.exec]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-04 01:02:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms.parallel.exec">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec">[algorithms.parallel.exec]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms.parallel.exec">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec">[algorithms.parallel.exec]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses CH 10</b>

<p>Parallel implementations of algorithms may be faster if not restricted to the complexity specifications of serial implementations.</p>
<p>Proposed change: Add a relaxation of complexity specifications for non-sequenced policies.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2881" href="2881">2881.</a> Adopt section III of P0308R0</h3>
<p><b>Section:</b> 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:01 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.variant">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.variant">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses CH 7</b>

<p>Consider making the variant statically <tt>!valueless_by_exception()</tt> for cases where <tt>is_nothrow_move_constructible_v&lt;T_i&gt;</tt> for all alternative types <tt>T<sub><i>i</i></sub></tt></p>
<p>Proposed change: Adopt section III of <a href="http://wg21.link/p0308r0">P0308R0</a>.</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2883" href="2883">2883.</a> The standard library should provide <tt>string_view</tt> parameters instead or in addition for functions 
      defined with <tt>char const *</tt> or <tt>string const &amp;</tt> as parameter types.</h3>
<p><b>Section:</b> 24.4 <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:01 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.view">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses CH 9</b>

<p>
The standard library should provide <tt>string_view</tt> parameters instead or in addition for functions defined with 
<tt>char const *</tt> or <tt>string const &amp;</tt> as parameter types. Most notably in cases where both such 
overloads exist or where an internal copy is expected anyway.
</p>
<p>
It might be doubted that the non-null termination of <tt>string_view</tt> could be an issue with functions that pass 
the <tt>char *</tt> down to OS functions, such as <tt>fstream_buf::open()</tt> etc. and those shouldn't provide it 
and favour generating a <tt>std::string</tt> temporary instead in that case. However, <tt>std::path</tt> demonstrates 
it is usable to have <tt>string_view</tt> overloads and there might be many places where it can be handy, or even better.
</p>

<p>Proposed change: Provide the overloads for <tt>std::regex</tt>, the exception classes, <tt>std::bitset</tt>, 
<tt>std::locale</tt> and more.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2884" href="2884">2884.</a> Relational operators for containers should sfinae; if the underlying type is not comparable, neither should the container be</h3>
<p><b>Section:</b> 26 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>, 23 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:01 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 16</b>

<p>Relational operators for containers should sfinae; if the underlying type is not comparable, neither should the container be. Same applies to <tt>tuple</tt> and <tt>pair</tt>.</p>

<p>Proposed change: Make the relational operators of containers and utility components reflect the validity of the underlying 
element types.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2885" href="2885">2885.</a> The relational operators of <tt>optional</tt> and <tt>variant</tt> completely reflect the semantics of the element 
types &mdash; this is inconsistent with other types in the library</h3>
<p><b>Section:</b> 26 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>, 23 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:01 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 17</b>

<p>The relational operators of optional and variant completely reflect the semantics of the element types; this is inconsistent 
with other types in the library, like <tt>pair</tt>, <tt>tuple</tt> and containers. If we believe it's important that we don't 
synthesize relational operators for wrapper types, we should believe it's important for other types as well. Otherwise comparing 
containers of floating-point types and tuples/pairs etc. of floating point types will give incorrect answers.</p>
<p>Proposed change: Make the relational operators of containers and utility components reflect the semantics of the operators for the underlying element types.</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2886" href="2886">2886.</a> Keep the <tt>empty()</tt> functions in <tt>variant</tt></h3>
<p><b>Section:</b> 99 [section.ref.here] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:01 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#section.ref.here">issues</a> in [section.ref.here].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 7</b>

<p>The proposal <a href="http://wg21.link/p0032">p0032</a> has multiple problems: 1) it turns member function <tt>.empty()</tt> 
into <tt>.has_value()</tt>, negating the logic. Refactoring e.g. existing uses of <tt>std::experimental::any</tt> to use 
<tt>std::any</tt> thus involve non-trivial refactorings that are error- prone and can't be done via simple search-and-replace 
if there are containers in the same source files for which <tt>.empty()</tt> is used (based on the implementation experience 
of making the change in libstdc++ and refactoring the testsuite). Whilst <tt>any</tt> is not a container, the library is failing 
to go towards a direction where there would be a generic way to query for emptiness. 2) The use of function references for 
tag types makes the interface hard to use. The tag types do not have value semantics like every other tag type has, the tag 
types are hard to construct, and present surprises for certain kinds of overload sets. Furthermore, any attempts to decay the 
tag types produces a really surprising effect &mdash; as opposed to what the other tag types do, which is that the result of 
decaying them is the tag type itself, decaying these new tag types results in a pointer to function.</p>

<p>Proposed change: Keep the <tt>.empty()</tt> functions (and introduce them to all the types that are supposed to have a 
homogeneous interface), and make the tag types be regular tag types that are not references to functions.</p>

<p><i>[2017-02-03, Marshall notes]</i></p>

<p><a href="http://wg21.link/p0504r0">P0504R0</a> (adopted in Issaquah) removed use of function references for tag types</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2891" href="2891">2891.</a> Relax library requirements on <tt>volatile</tt> types</h3>
<p><b>Section:</b> 20.5.5 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:22 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#conforming">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 35</b>

<p>Most implementations have poor testing and support for instantiating standard library templates with <tt>volatile</tt>-qualified 
types. We should grant a library-freedom to conforming implementations so that support for <tt>volatile</tt> (and <tt>const volatile</tt>)
qualified types in standard library templates is not required unless explicitly specified &mdash; and mandate such support for all 
templates in the <tt>&lt;type_traits&gt;</tt> header. Additional support is already specified in most places we would be interested 
(e.g., tuple API). We may want to additionally guarantee support through forwarding references.</p>
<p>Proposed change: add a new 17.6.5.x Volatile Qualified Types [res.on.volatile.type] describing the intended level of support for 
<tt>volatile</tt> qualifiers.</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2892" href="2892">2892.</a> Relax the prohibition on libraries adding <tt>constexpr</tt></h3>
<p><b>Section:</b> 20.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-21 18:02:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#constexpr.functions">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 38</b>

<p>Relax the prohibition on libraries adding <tt>constexpr</tt>; this was a constraint requested by library implementers when 
<tt>constexpr</tt> was new, and those same implementers now feel unduly constrained.</p>
<p>Proposed change: Rewrite the whole sub-clause to support libraries adding <tt>constexpr</tt> in a compatible manner, 
much like the freedom to add a <tt>noexcept</tt> specification.</p>

<p><i>[2017-02-20, Marshall adds wording]</i></p>

<p>The simplest change would be to strike the sentence "An implementation shall not [&hellip;] explicitly required". However, 
people seem to want a definite permission here, so I have provided one.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 20.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:</p>
<blockquote>
<p>This International Standard explicitly requires that certain standard library functions are constexpr (7.1.5). <ins>An 
implementation may declare additional standard library function signatures as constexpr</ins><del>An implementation shall 
not declare any standard library function signature as constexpr except for those where it is explicitly required</del>. 
Within any header that provides any non-defining declarations of constexpr functions or constructors an implementation 
shall provide corresponding definitions.</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2893" href="2893">2893.</a> Parsing Hexadecimally in P0067R4</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-23 19:02:59 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utilities">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 45</b>

<p>If <a href="http://wg21.link/p0067r4">P0067R4</a> is applied consider how to parse hexadecimally:</p>
<blockquote>
<p><tt>to_chars(beg, end, 42, 16);</tt> 16 for hex</p>
<p><tt>to_chars(beg, end, 4.2, true);</tt> true means hex</p>
<p><tt>to_chars(beg, end, 4.2, chars_format::hex);</tt></p>
<p><tt>to_chars(beg, end, 4.2, chars_format::hex, 2);</tt></p>
</blockquote>

<p>That is: We have 3 different formats to specify hex depending on value types and whether to use precision.
Which application programmer should remember this?</p>

<p>May be even worse (I am not sure):</p>
<blockquote><tt>to_chars(beg, end, 4.2, 16);</tt></blockquote>
<p>would silently convert 4.2 to 4 and</p>
<blockquote><tt>to_chars(beg, end, 4, chars_format::hex);</tt></blockquote>
<p>would silently convert 4 to 4.000000.</p>

<p>Proposed change: The various options should be harmonized, possibly by use of an extended enum approach, having the values:
dec, hex, scientific, fixed, general
with dec (new!) as default for integral values and general for floats</p>

<p><i>[2017-02-23, Jens Maurer comments]</i></p>

<p>
This issue is NAD; the facility was redesigned with these considerations
in mind before it went into the working draft.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>







<hr>
<h3><a name="2894" href="2894">2894.</a> The function template <tt>std::apply()</tt> is required to be <tt>constexpr</tt>, but <tt>std::invoke()</tt> isn't</h3>
<p><b>Section:</b> 23.14.4 <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-05 23:03:53 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.invoke">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#func.invoke">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 51</b>

<p>The function template <tt>std::apply()</tt> in 23.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/tuple.apply">[tuple.apply]</a> is required to be <tt>constexpr</tt>, 
but <tt>std::invoke()</tt> in 23.14.4 <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a> isn't. The most sensible implementation of <tt>apply_impl()</tt> 
is exactly equivalent to <tt>std::invoke()</tt>, so this requires implementations to have a <tt>constexpr</tt> version of 
<tt>invoke()</tt> for internal use, and the public API <tt>std::invoke</tt>, which must not be <tt>constexpr</tt> even 
though it is probably implemented in terms of the internal version.</p>
<p>Proposed change: Add <tt>constexpr</tt> to <tt>std::invoke</tt>.</p>

<p><i>[2017-02-20, Marshall adds wording]</i></p>


<p><i>[Kona 2017-03-01]</i></p>

<p>We think this needs CWG 1581 to work; accepted as Immediate to resolve NB comment.</p>
<p>Friday: CWG 1581 was not moved in Kona. Status back to Open.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 23.14.4 <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class F, class... Args&gt;
     <ins>constexpr</ins> result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2897" href="2897">2897.</a> <tt>array::iterator</tt> and <tt>array::const_iterator</tt> should be literal types</h3>
<p><b>Section:</b> 26.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Russia <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array.overview">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#array.overview">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses RU 3</b>

<p>Force the literal type requirement for the <tt>iterator</tt> and <tt>const_iterator</tt> in the <tt>std::array</tt> 
so that iterators of <tt>std::array</tt> could be used in <tt>constexpr</tt> functions.</p>
<p>Proposed change: Add to the end of the [array.overview] section: <ins><tt>iterator</tt> and <tt>const_iterator</tt> 
shall be literal types.</ins></p>

<p><i>[2017-02-20 Marshall adds wording]</i></p>

<p>I used the formulation "are literal types", rather than "shall be", since that denotes a requirement on the user.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Add a new paragraph at the end of 26.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>:</p>
<blockquote>
<ins>-?- <tt>iterator</tt> and <tt>const_iterator</tt> are literal types.</ins>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2017-03-01, Kona]</i></p>

<p>
Antony Polukhin provides revised wording.
</p>

<p><i>[2017-03-02, Kona]</i></p>

<p>
Wording tweaks suggested by LWG applied.
</p>

<p><i>[2017-03-02, Tim Song comments]</i></p>

<p>
I don't believe the blanket "all operations" wording is quite correct.
<p/>
First, <tt>T t;</tt> (required by <tt>DefaultConstructible</tt>) isn't usable in a constant expression if the iterator is a 
pointer, since it would leave it uninitialized. 
<p/>
Second, an explicit destructor call <tt>u.~T()</tt> (required by <tt>Destructible</tt>) isn't usable if the iterator is a 
class type because it explicitly invokes a non-<tt>constexpr</tt> function (the destructor); see [expr.const]/2.2.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 2. Lisa and Alisdair to work with Antony to come up with better wording. The same wording can be used for <a href="2938">2938</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Add a new paragraph at the end of 26.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>:</p>
<blockquote>
<p>
-3- An <tt>array</tt> satisfies all of the requirements of a container [&hellip;]
<p/>
<ins>-?- All operations on <tt>iterator</tt> and <tt>const_iterator</tt> that are required to satisfy the 
random access iterator requirements are usable in constant expressions.</ins>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2898" href="2898">2898.</a> Prefer not to use member typedefs as constructor parameters</h3>
<p><b>Section:</b> 20 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:47 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 106</b>

<p>Review the whole library for constructors using member typedefs to name constructor parameters rather than template 
type parameters, as this inhibits class template deduction. e.g., the <tt>unique_lock</tt> explicit constructor 
taking the <tt>mutex_type</tt> typedef would be better served naming <tt>Mutex</tt> directly, to preserve support for deduction.</p>
<p>Proposed change: Review each constructor of each library class template, and revise specification of parameter types as needed.</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2899" href="2899">2899.</a> <tt>is_(nothrow_)move_constructible</tt> and <tt>tuple</tt>, <tt>optional</tt> and <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 23.5 <a href="https://timsong-cpp.github.io/cppwp/tuple">[tuple]</a>, 23.6 <a href="https://timsong-cpp.github.io/cppwp/optional">[optional]</a>, 23.11.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-27 22:02:53 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple">[tuple]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 110</b>

<p>The move constructors for <tt>tuple</tt>, <tt>optional</tt>, and <tt>unique_ptr</tt> should return false for 
<tt>is_(nothrow_)move_constructible_v&lt;<i>TYPE</i>&gt;</tt> when their corresponding <i>Requires</i> clauses are not 
satisfied, as there are now several library clauses that are defined in terms of these traits. The same concern 
applies to the move-assignment operator. Note that <tt>pair</tt> and <tt>variant</tt> already satisfy this constraint.
</p>

<p><i>[2017-02-26, Scott Schurr provides wording]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>
<ol>
<li><p>Modify 23.5.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a> as indicated:</p>

<blockquote>
<pre>
<i>// 20.5.3.1, tuple construction</i>
<i>EXPLICIT</i> constexpr tuple();
<i>EXPLICIT</i> constexpr tuple(const Types&amp;...); <i>// only if sizeof...(Types) &gt;= 1</i>
template &lt;class... UTypes&gt;
<i>EXPLICIT</i> constexpr tuple(UTypes&amp;&amp;...) <ins>noexcept(<i>see below</i>)</ins>; <i>// only if sizeof...(Types) &gt;= 1</i>

tuple(const tuple&amp;) = default;
tuple(tuple&amp;&amp;) = default;

template &lt;class... UTypes&gt;
<i>EXPLICIT</i> constexpr tuple(const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... UTypes&gt;
<i>EXPLICIT</i> constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp;) <ins>noexcept(<i>see below</i>)</ins>;

template &lt;class U1, class U2&gt;
<i>EXPLICIT</i> constexpr tuple(const pair&lt;U1, U2&gt;&amp;); <i>// only if sizeof...(Types) == 2</i>
template &lt;class U1, class U2&gt;
<i>EXPLICIT</i> constexpr tuple(pair&lt;U1, U2&gt;&amp;&amp;) <ins>noexcept(<i>see below</i>)</ins>; <i>// only if sizeof...(Types) == 2</i>

[&hellip;]

<i>// 20.5.3.2, tuple assignment</i>
tuple&amp; operator=(const tuple&amp;);
tuple&amp; operator=(tuple&amp;&amp;) noexcept(<i>see below</i>);

template &lt;class... UTypes&gt;
tuple&amp; operator=(const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... UTypes>
tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp;) <ins>noexcept(<i>see below</i>)</ins>;

template &lt;class U1, class U2&gt;
tuple&amp; operator=(const pair&lt;U1, U2&gt;&amp;); <i>// only if sizeof...(Types) == 2</i>
template &lt;class U1, class U2&gt;
tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp;) <ins>noexcept(<i>see below</i>)</ins>; <i>// only if sizeof...(Types) == 2</i>
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class... UTypes&gt; <i>EXPLICIT</i> constexpr tuple(UTypes&amp;&amp;... u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Initializes the elements in the tuple with the corresponding value in <tt>std::forward&lt;UTypes&gt;(u)</tt>.
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution unless <tt>sizeof...(Types) ==
sizeof...(UTypes)</tt> and <tt>sizeof...(Types) >= 1</tt> and <tt>is_constructible_v&lt;T<sub><i>i</i></sub>, 
U<sub><i>i</i></sub>&amp;&amp;&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>. The constructor is explicit if and only if 
<tt>is_convertible_v&lt;U<sub><i>i</i></sub>&amp;&amp;, T<sub><i>i</i></sub>&gt;</tt> is <tt>false</tt> for at least one 
<tt><i>i</i></tt>. <ins>The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_constructible_v&lt;T<sub><i>i</i></sub>, U<sub><i>i</i></sub>&amp;&amp;&gt;</ins>
</pre></blockquote>
<p>
<ins>where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>Types</tt>, and
<tt>U<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>UTypes</tt>.</ins>
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template &lt;class... UTypes&gt; <i>EXPLICIT</i> constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp; u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-16- <i>Effects:</i> For all <tt><i>i</i></tt>, initializes the <tt><i>i</i></tt><sup>th</sup> element of <tt>*this</tt> with 
<tt>std::forward&lt;U<sub><i>i</i></sub>&gt;(get&lt;<i>i</i>&gt;(u))</tt>.
<p/>
-17- <i>Remarks:</i> This constructor shall not participate in overload resolution unless
<p/>
[&hellip;]
<p/>
The constructor is explicit if and only if <tt>is_convertible_v&lt;U<sub><i>i</i></sub>&amp;&amp;, T<sub><i>i</i></sub>&gt;</tt> 
is <tt>false</tt> for at least one <tt><i>i</i></tt>. <ins>The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_constructible_v&lt;T<sub><i>i</i></sub>, U<sub><i>i</i></sub>&amp;&amp;&gt;</ins>
</pre></blockquote>
<p>
<ins>where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>Types</tt>, and
<tt>U<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>UTypes</tt>.</ins>
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template &lt;class U1, class U2&gt; <i>EXPLICIT</i> constexpr tuple(pair&lt;U1, U2&gt;&amp;&amp; u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-21- <i>Effects:</i> Initializes the first element with <tt>std::forward&lt;U1&gt;(u.first)</tt> and the second element with
<tt>std::forward&lt;U2&gt;(u.second)</tt>.
<p/>
-22- <i>Remarks:</i> This constructor shall not participate in overload resolution unless <tt>sizeof...(Types) == 2</tt>,
<tt>is_constructible_v&lt;T0, U1&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt>is_constructible_v&lt;T1, U2&amp;&amp;&gt;</tt> is <tt>true</tt>.
<p/>
-23- The constructor is explicit if and only if <tt>is_convertible_v&lt;U1&amp;&amp;, T0&gt;</tt> is <tt>false</tt> or 
<tt>is_convertible_v&lt;U2&amp;&amp;, T1&gt;</tt> is <tt>false</tt>. <ins>The expression inside <tt>noexcept</tt> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_constructible_v&lt;T0, U1&amp;&amp;&gt; &amp;&amp; is_nothrow_constructible_v&lt;T1, U2&amp;&amp;&gt;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.assign">[tuple.assign]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class... UTypes&gt; tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp; u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-12- <i>Effects:</i> For all <tt><i>i</i></tt>, assigns <tt>std::forward&lt;U<sub><i>i</i></sub>&gt;(get&lt;<i>i</i>&gt;(u))</tt> 
to <tt>get&lt;<i>i</i>&gt;(*this)</tt>.
<p/>
-13- <i>Remarks:</i> This operator shall not participate in overload resolution unless <tt>is_assignable_v&lt;T<sub><i>i</i></sub>&amp;, 
U<sub><i>i</i></sub>&amp;&amp;&gt; == true</tt> for all <tt><i>i</i></tt> and <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
<ins>The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_assignable_v&lt;T<sub><i>i</i></sub>&amp;, U<sub><i>i</i></sub>&amp;&amp;&gt;</ins>
</pre></blockquote>
<p>
<ins>where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>Types</tt>, and
<tt>U<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>UTypes</tt>.</ins>
</p>
<p>
-14- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template &lt;class U1, class U2&gt; tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp; u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-18- <i>Effects:</i> Assigns <tt>std::forward&lt;U1&gt;(u.first)</tt> to the first element of <tt>*this</tt> and
<tt>std::forward&lt;U2&gt;(u.second)</tt> to the second element of <tt>*this</tt>.
<p/>
-19- <i>Remarks:</i> This operator shall not participate in overload resolution unless <tt>sizeof...(Types) == 2</tt>
and <tt>is_assignable_v&lt;T0&amp;, U1&amp;&amp;&gt;</tt> is <tt>true</tt> for the first type <tt>T0</tt> in <tt>Types</tt> 
and <tt>is_assignable_v&lt;T1&amp;, U2&amp;&amp;&gt;</tt> is <tt>true</tt> for the second type <tt>T1</tt> in <tt>Types</tt>.
<ins>The expression inside <tt>noexcept</tt> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_assignable_v&lt;T0&amp;, U1&amp;&amp;&gt; &amp;&amp; is_nothrow_assignable_v&lt;T1&amp;, U2&amp;&amp;&gt;</ins>
</pre></blockquote>
<p>
-20- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2901" href="2901">2901.</a> Variants cannot properly support allocators</h3>
<p><b>Section:</b> 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-28 07:02:20 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.variant">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.variant">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 113</b>

<p>Variants cannot properly support allocators, as any assignment of a subsequent value throws away the allocator used at 
construction. This is not an easy problem to solve, so <tt>variant</tt> would be better served dropping the illusion of 
allocator support for now, leaving open the possibility to provide proper support once the problems are fully understood.</p>

<p>Proposed change: Strike the 8 allocator aware constructor overloads from the class definition, and strike 
20.7.2.1 [variant.ctor] p34/35. Strike clause 20.7.12 [variant.traits]. Strike the specialization of 
<tt>uses_allocator</tt> for <tt>variant</tt> in the <tt>&lt;variant&gt;</tt> header synopsis, 20.7.1 [variant.general].</p>

<p><i>[2017-02-28, Kona, Casey provides wording]</i></p>

<p>
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Change 23.7.2 <a href="https://timsong-cpp.github.io/cppwp/variant.syn">[variant.syn]</a>, header <tt>&lt;variant&gt;</tt>  synopsis, as follows:</p>

<blockquote><pre>
[&hellip;]
<del><i>// 20.7.13, allocator-related traits</i>
template &lt;class T, class Alloc&gt; struct uses_allocator;
template &lt;class... Types, class Alloc&gt; struct uses_allocator&lt;variant&lt;Types...&gt;, Alloc&gt;;</del>
</pre></blockquote>
</li>

<li><p>Change 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>, class template <tt>variant</tt>  synopsis, as follows:</p>

<blockquote><pre>
[&hellip;]
<del><i>// allocator-extended constructors</i>
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp;);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp;, const variant&amp;);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp;, variant&amp;&amp;);
template &lt;class Alloc, class T&gt;
  variant(allocator_arg_t, const Alloc&amp;, T&amp;&amp;);
template &lt;class Alloc, class T, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp;, in_place_type_t&lt;T&gt;, Args&amp;&amp;...);
template &lt;class Alloc, class T, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp;, in_place_type_t&lt;T&gt;,
          initializer_list&lt;U&gt;, Args&amp;&amp;...);
template &lt;class Alloc, size_t I, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp;, in_place_index_t&lt;I&gt;, Args&amp;&amp;...);
template &lt;class Alloc, size_t I, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp;, in_place_index_t&lt;I&gt;,
          initializer_list&lt;U&gt;, Args&amp;&amp;...);</del>
</pre></blockquote>
</li>

<li><p>Modify 23.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> as indicated:</p>
<blockquote><pre>
<del>template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a, const variant&amp; v);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a, variant&amp;&amp; v);
template &lt;class Alloc, class T&gt;
  variant(allocator_arg_t, const Alloc&amp; a, T&amp;&amp; t);
template &lt;class Alloc, class T, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
template &lt;class Alloc, class T, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_type_t&lt;T&gt;,
          initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
template &lt;class Alloc, size_t I, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);
template &lt;class Alloc, size_t I, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_index_t&lt;I&gt;,
          initializer_list&lt;U&gt; il, Args&amp;&amp;... args);</del>

</pre>
<blockquote>
<p>
<del>-34- <i>Requires:</i> <tt>Alloc</tt> shall meet the requirements for an Allocator (17.5.3.5).</del>
<p/>
<del>-35- <i>Effects:</i> Equivalent to the preceding constructors except that the contained value is constructed with
uses-allocator construction (20.10.7.2).</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.13 <a href="https://timsong-cpp.github.io/cppwp/variant.traits">[variant.traits]</a> as indicated:</p>

<blockquote>
<pre>
<del>template &lt;class... Types, class Alloc&gt;
struct uses_allocator&lt;variant&lt;Types...&gt;, Alloc&gt; : true_type { };</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Requires:</i> <tt>Alloc</tt> shall be an Allocator (17.5.3.5).</del>
<p/>
<del>-2- [<i>Note:</i> Specialization of this trait informs other library components that variant can be constructed
with an allocator, even though it does not have a nested <tt>allocator_type</tt>. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2902" href="2902">2902.</a> <tt>variant</tt> should only support complete types</h3>
<p><b>Section:</b> 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-13 16:02:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.variant">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.variant">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 114</b>

<p><tt>variant</tt> needs to know the size of an object in order to compute the size of its internal buffer, so 
require that any <i>cv</i>-qualified object type in <tt>Types...</tt> be a complete type.</p>
<p>Proposed change: Add 'complete' in p2</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/N4618">N4618</a>.</p>
<ol>
<li><p>Edit 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>/2 as indicated:</p>
<blockquote>
All types in <tt>Types...</tt> shall be (possibly <i>cv</i>-qualified)<ins> complete</ins> object types that are not arrays.
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2906" href="2906">2906.</a> There is no ability to supply an allocator for the control block when constructing a <tt>shared_ptr</tt> from a 
<tt>unique_ptr</tt></h3>
<p><b>Section:</b> 23.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:47 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 130</b>

<p>There is no ability to supply an allocator for the control block when constructing a <tt>shared_ptr</tt> from a <tt>unique_ptr</tt>. 
Note that no further <tt>shared_ptr</tt> constructors need an allocator, as they all have pre-existing control blocks that are shared, 
or already have the allocator overload.</p>
<p>Proposed change: Add an additional <tt>shared_ptr</tt> constructor, 
<tt>template &lt;class Y, class D, class A&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r, A alloc)</tt>, with the same semantics 
as the existing constructor taking a <tt>unique_ptr</tt>, but using the <tt>alloc</tt> argument to supply memory as required.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2907" href="2907">2907.</a> Semantics for destroying the deleter and the control-block of a <tt>shared_ptr</tt> are unclear</h3>
<p><b>Section:</b> 23.11.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 13:02:47 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.dest">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.dest">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 134</b>

<p>The semantics for destroying the deleter and the control-block are unclear. In particular, it is not clear that we 
guarantee a lack of race conditions destroying the control-block and deleter. Possible race-free implementations might 
destroy the deleter after running <tt>d(p)</tt>, and before giving up the weak reference held by this <tt>shared_ptr</tt>; 
running the destructor for <tt>d</tt> only when the last <tt>weak_ptr</tt> is destroyed, potentially at a much later date, 
but ensuring that <tt>d(p)</tt> completes before the <tt>shared_ptr</tt> gives up its weak reference; making a copy of 
<tt>d</tt> in the destructor before manipulating the weak count, and then using this copy to run <tt>d(p)</tt>, even while 
the control-block could be concurrently reclaimed with an expiring <tt>weak_ptr</tt> in another thread. Note that this 
may be related to LWG <a href="2751">2751</a>. (Also, see the note in 20.11.2.2.10 p1 [util.smartptr.getdeleter])</p>

<p>Proposed change: Clarify that the <tt>shared_ptr</tt> weak ownership of the control block is released at the end of the 
destructor, and not as the destructor begins. Otherwise, the deleter might be destroyed even before the destructor gets to 
move a copy to call safely.</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2909" href="2909">2909.</a> User specializations of <tt>is_execution_policy</tt> should be ill-formed</h3>
<p><b>Section:</b> 23.19.3 <a href="https://timsong-cpp.github.io/cppwp/execpol.type">[execpol.type]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 14:02:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 14</b>

<p>A user specialization of any <tt>is_execution_policy</tt> should produce an ill-formed program, not merely one whose behavior is unspecified. See also the related comment re [meta.type.synop] (20.15.2). (US 10)</p>
<p>Proposed change: Reword the paragraph as follows:</p>
<blockquote><p>Unless otherwise specified, a program that adds specializations for <tt>is_execution_policy</tt> is ill-formed; 
no diagnostic required.</p></blockquote>

See also LWG <a href="2871">2871</a>.


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2910" href="2910">2910.</a> Template deduction and <tt>integral_constant</tt></h3>
<p><b>Section:</b> 23.15.2 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-26 18:02:51 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 142</b>

<p>An alias template using the new template template auto deduction would make <tt>integral_constant</tt> slightly easier to use.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Add to the synopsis of <tt>&lt;type_traits&gt;</tt>:</p>
<blockquote><pre>
<ins>template &lt;auto N&gt;
using integer_constant = integral_constant&lt;decltype(N), N&gt;;</ins>
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="2916" href="2916">2916.</a> Insert iterators should each have an instantiation guide to initialize from a container</h3>
<p><b>Section:</b> 27.5.2 <a href="https://timsong-cpp.github.io/cppwp/insert.iterators">[insert.iterators]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 14:02:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#insert.iterators">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/insert.iterators">[insert.iterators]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 151</b>

<p>The three insert iterators should each have an instantiation guide to initialize from a container.</p>
<p>Proposed change:</p>
<p>
Add to the <tt>&lt;iterator&gt;</tt> header synopsis:
</p>
<blockquote><pre>
template &lt;class Container&gt;
back_insert_iterator(Container&amp;) -&gt; back_insert_iterator&lt;Container&gt;;
template &lt;class Container&gt;
front_insert_iterator(Container&amp;) -&gt; back_insert_iterator&lt;Container&gt;;
template &lt;class Container&gt;
insert_iterator(Container&amp;, typename Container::iterator) -&gt; insert_iterator&lt;Container&gt;;
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Add to the synopsis of <tt>&lt;iterator&gt;</tt>:</p>
<blockquote><pre><ins>
template &lt;class Container&gt; back_insert_iterator(Container&amp;) -&gt; back_insert_iterator&lt;Container&gt;;
template &lt;class Container&gt; front_insert_iterator(Container&amp;) -&gt; back_insert_iterator&lt;Container&gt;;
template &lt;class Container&gt; insert_iterator(Container&amp;, typename Container::iterator) -&gt; insert_iterator&lt;Container&gt;;
</ins></pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2922" href="2922">2922.</a> The <tt>*_constant&lt;&gt;</tt> templates do not make use of <tt>template&lt;auto&gt;</tt></h3>
<p><b>Section:</b> 23.15.2 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-03 20:03:51 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 171</b>

<p>The <tt>*_constant&lt;&gt;</tt> templates (including the proposed addition, <tt>bool_constant&lt;&gt;</tt>) do 
not make use of the new <tt>template&lt;auto&gt;</tt> feature.</p>

<p>Proposed change: Add a <tt>constant&lt;&gt;</tt> (subject to bikeshedding) template which uses <tt>template&lt;auto&gt;</tt>. </p>
<p>Define <tt>integral_constant&lt;&gt;</tt> as <tt>using integral_constant&lt;T, V&gt; = constant&lt;T(V)&gt;</tt> or <tt>integral_constant&lt;T, V&gt; = constant&lt;V&gt;</tt>.</p>
<p>Either remove <tt>bool_constant</tt>, define it as using <tt>bool_constant = constant&lt;bool(B)&gt;</tt> or 
<tt>using bool_constant = constant&lt;B&gt;</tt>.</p>

<p><i>[2017-03-03, Kona, LEWG]</i></p>

<p>
Straw polls:
</p>
<table border="1">
<caption>Name:</caption>
<tr style="text-align: left">
<td style="width:70%"><tt>constant</tt></td><td style="width:10%">3</td></tr>
<tr style="text-align: left">
<td><tt>numeric_constant</tt></td><td>8</td></tr>
<tr style="text-align: left">
<td><tt>static_constant</tt></td><td>1</td></tr>
<tr style="text-align: left">
<td><tt>scalar_constant</tt></td><td>7</td></tr>
<tr style="text-align: left">
<td><tt>integer_constant</tt> (Over LWG's dead body)</td><td>1</td></tr>
<tr style="text-align: left">
<td><tt>auto_constant</tt></td><td>4</td></tr>
<tr style="text-align: left">
<td><tt>integral_c</tt></td><td>7</td></tr>
<tr style="text-align: left">
<td><tt>int_</tt></td><td>0</td></tr>
<tr style="text-align: left">
<td colspan="2"><tt>&#x200b;</tt></td></tr>
<tr style="text-align: left">
<td><tt>scalar_constant</tt></td><td>6</td></tr>
<tr style="text-align: left">
<td><tt>numeric_constant</tt></td><td>3</td></tr>
<tr style="text-align: left">
<td><tt>integral_c</tt></td><td>5</td></tr>
</table>

<p>
Accept P0377 with "<tt>scalar_constant</tt>" for C++17 to address LWG 2922 and US 171:
<p/>
SF | F | N | A | SA
<p/>
0  | 1 | 3 | 7 | 5
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>








<hr>
<h3><a name="2923" href="2923">2923.</a> <tt>noexcept</tt> is inconsistently applied across headers which import components of the C standard library</h3>
<p><b>Section:</b> 29.9.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-02-05 14:02:36 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cmath.syn">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#cmath.syn">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 172</b>

<p><tt>noexcept</tt> is inconsistently applied across headers which import components of the C standard library into the C++ library; 
some functions (<tt>std::abort()</tt>, <tt>std::_Exit()</tt>, etc) are defined as <tt>noexcept</tt> in some places, but not in others. 
Some functions which seem like they should be <tt>noexcept</tt> (<tt>std::abs()</tt>, <tt>std::div()</tt>, etc) are not defined as 
<tt>noexcept</tt>.</p>

<p>Proposed change: Make the majority of the C library functions (with exceptions such as <tt>std::qsort()</tt> and 
<tt>std::bsearch()</tt>, which can call user code) <tt>noexcept</tt>.</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>







<hr>
<h3><a name="2929" href="2929">2929.</a> <tt>basic_string</tt> misuses "<i>Effects:</i> Equivalent to"</h3>
<p><b>Section:</b> 24.3.2.6.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.assign">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><tt>basic_string::assign(size_type n, charT c);</tt> says:</p>
<blockquote><p>
<i>Effects:</i> Equivalent to <tt>assign(basic_string(n, c))</tt>.
</p></blockquote>
<p>
This requires that a new <tt>basic_string</tt> is constructed, using a
default-constructed allocator, potentially allocating memory, and then
that new string is copy-assigned to <tt>*this</tt>, potentially propagating the
allocator. This must be done even if <tt>this-&gt;capacity() &gt; n</tt>,
because memory allocation and allocator propagation are observable side
effects. If the allocator doesn't propagate and isn't equal to
<tt>this-&gt;get_allocator()</tt> then a second allocation may be required. This
can't be right; it won't even compile if the allocator isn't default
constructible.
<p/>
<tt>basic_string::assign(InputIterator first, InputIterator last)</tt> has a
similar problem, even if the iterators are random access and
<tt>this-&gt;capacity() &gt; distance(first, last)</tt>.
<p/>
<tt>basic_string::assign(std::initializer_list&lt;charT&gt;</tt> doesn't say
"Equivalent to" so maybe it's OK to not allocate anything if the list
fits in the existing capacity.
<p/>
<tt>basic_string::append(size_type, charT)</tt> and
<tt>basic_string::append(InputIterator, InputIterator)</tt> have the same
problem, although they don't propagate the allocator, but still
require at least one, maybe two allocations.
<p/>
A partial fix would be to ensure all the temporaries are constructed
with <tt>get_allocator()</tt> so that they don't require default constructible
allocators, and so propagation won't alter allocators. The problem of
observable side effects is still present (the temporary might need to
allocate memory, even if <tt>this-&gt;capacity()</tt> is large) but arguably it's
unspecified when construction allocates, to allow for small-string
optimisations.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 3. Thomas to argue on reflector that this is NAD.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2931" href="2931">2931.</a> Missed optimization opportunity with single-argument <tt>std::next</tt></h3>
<p><b>Section:</b> 27.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Morwenn <b>Opened:</b> 2017-02-04 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.operations">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that <tt>std::next</tt> is missing an optimization opportunity when taking a single parameter. The standard 
mandates that <tt>std::next</tt> shall call <tt>std::advance</tt> on the passed iterator and return it. For random-access 
iterators, it means that <tt>operator+=</tt> will be called on the iterator. However, if a single-argument overload was 
added to <tt>std::next</tt>, it could call <tt>++it</tt> directly instead of <tt>std::advance(it, 1)</tt>, which means 
that <tt>operator++</tt> would be called instead of <tt>operator+=</tt>. This might make a small performance difference 
for complicated iterators such as <tt>std::deque</tt>'s ones, where <tt>operator++</tt> has a simpler logic than 
<tt>operator+=</tt>.
<p/>
An equivalent optimization could be allowed by adding a single-argument overload to <tt>std::prev</tt> too.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 3. Alisdair to provide wording.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2932" href="2932">2932.</a> Constraints on parallel algorithm implementations are underspecified</h3>
<p><b>Section:</b> 28.4.3 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec">[algorithms.parallel.exec]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Dietmar K&uuml;hl <b>Opened:</b> 2017-02-05 <b>Last modified:</b> 2017-03-14 02:03:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms.parallel.exec">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec">[algorithms.parallel.exec]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms.parallel.exec">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec">[algorithms.parallel.exec]</a>.</p>
<p><b>Discussion:</b></p>
<p>
Section 28.4.3 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec">[algorithms.parallel.exec]</a> specifies constraints a user of the parallel algorithms has to obey. Notably, 
it specifies in paragraph 3 that executions of element access functions are indeterminately sequenced with respect to each other. Correspondingly, it is the user's obligation to ensure that these calls do not introduce data races (this is also clarified in 
a note on this section).
<p/>
Unfortunately, there is no constraint that, at least, mutating element access functions like <tt>operator++()</tt> on an 
iterator are called on different objects. An odd implementation of a parallel algorithm could increment a shared iterator 
from two threads without synchronisation of its own and the user would be obliged to make sure there is no data race!
<p/>
For example:
</p>
<blockquote><pre>
template &lt;typename FwdIt&gt;
FwdIt adjacent_find(std::execution::parallel_policy, FwdIt it, FwdIt end) 
{
  if (2 &lt;= std::distance(it, end)) {
    FwdIt tmp(it);
    auto f1 = std::async([&amp;tmp](){ ++tmp; });
    auto f2 = std::async([&amp;tmp](){ ++tmp; });
    f1.get();
    f2.get();
  }
  return std::adjancent_find(it, end);
}
</pre></blockquote>
<p>
This code is, obviously, a contrived example but with the current specification a legal implementation of <tt>adjacent_find()</tt>. 
The problem is that, e.g., for pointers there is a data race when incrementing <tt>tmp</tt>, i.e., the function can't be used 
on pointers. I don't think any of the containers makes a guarantee that their iterators can be incremented without synchronisation, 
i.e., the standard library doesn't have any iterators which could be used with this algorithm!
<p/>
Of course, no sane implementation would do anything like that. However, they are allowed to be implemented as above, making it unnecessarily hard and probably inefficient to use the algorithms: in portable code any user of the parallel algorithms needs 
to deal with the possibility that mutating operations on the same object are called from different threads. There is a constraint 
missing for the parallel algorithm implementations which limits calls to, at least, some element access functions to be applied 
only to different objects if there is synchronisation done by the algorithm. At least, obviously mutating operations like the 
iterator increment/decrement operators need to be correspondingly constrained.
<p/>
On the other hand, it seems reasonable that a shared data structure stores, e.g., a predicate used concurrently by all threads. 
This use is quite reasonable and there is nothing wrong. That is, demanding that all element access functions are called on different objects between different threads would possibly adversely over-constraining the algorithms. Only the element access functions deliberately changing the object need to be constrained.
<p/>
Based on checking all algorithms in the standard library taking an <tt>ExecutionPolicy</tt> template parameter there are broadly 
four groups of template parameters:
</p>
<ol>
<li><p>Parameters with a known set of possible arguments: <tt>ExecutionPolicy</tt> (execution policies listed in 
23.19 <a href="https://timsong-cpp.github.io/cppwp/execpol">[execpol]</a>).</p></li>
<li><p>Parameters specifying types of objects which are expected not to change: <tt>BinaryOperation</tt>, <tt>BinaryPredicate</tt>,
<tt>Compare</tt>, <tt>Function</tt>, <tt>Predicate</tt>, <tt>UnaryFunction</tt>, <tt>UnaryOperation</tt>, and <tt>T</tt> (all but 
the last one are function objects although I couldn't locate concepts for some of them &mdash; that may be a separate issue).</p></li>
<li><p>Parameters of mutable types which are also meant to be mutated: <tt>InputIterator</tt>, <tt>OutputIterator</tt>, 
<tt>ForwardIterator</tt>, <tt>BidirectionalIterator</tt>, <tt>RandomAccessIterator</tt>, and <tt>Size</tt> (the concept for 
<tt>Size</tt> also seems to be unspecified).</p></li>
<li><p>Some algorithms use <tt>Generator</tt> which seems to be a mutable function object. However, I couldn't locate a concept 
for this parameter.</p></li>
</ol>
<p>
The problematic group is 3 and possibly 4: mutations on the objects are expected. It seem the general approach of disallowing 
calling non-const functions without synchronisation applies. Note, however, that prohibiting calling of any non-const function 
from the algorithms would put undue burden on the implementation of algorithms: any of the accessor functions may be non-const 
although the concept assume that the function would be const. The constraint should, thus, only apply to functions which may 
mutate the object according to their respective concept.
</p>
<p>
Suggested Resolution:
</p>
<p>
Add a statement prohibiting unsequenced calls to element access functions on the same object which are not applicable to 
const objects according to the corresponding concept. I'm not sure how to best specify the constraint in general, though.
<p/>
Since the current algorithms use relatively few concepts there are fairly few operations actually affected. It may be 
reasonable at least for the initial version (and until we could refer to constructs in concepts in the language) to 
explicitly list the affected operations. I haven't done a full audit but iterator <tt>++</tt>, <tt>--</tt>, <tt>@=</tt> (for 
<tt>@</tt> being any of the operators which can be combined with an assignment), and assignments on all objects may be 
the set of affected element access functions whose use needs to be constrained.
<p/>
Here is a concrete proposal for the change: In 28.4.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.user">[algorithms.parallel.user]</a> add a paragraph:
<p/>
Parallel algorithms are constrained when calling mutating element access functions without synchronisation: if any mutating 
element access function is called on an object there shall be no other unsynchronised accesses to this object. The mutating 
element access functions are those which are specified as mutating object in the concept, notably assignment on any object, 
operators <tt>++</tt>, <tt>--</tt>, <tt>+=</tt>, and <tt>-=</tt> on any of the iterator or <tt>Size</tt> parameters, and 
any <tt>@=</tt> operators on the <tt>Size</tt> parameters.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 28.4.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.user">[algorithms.parallel.user]</a> as indicated:</p>
<blockquote>
<p>
-1- Function objects passed into parallel algorithms as objects of type <tt>Predicate</tt>, <tt>BinaryPredicate</tt>, 
<tt>Compare</tt>, and <tt>BinaryOperation</tt> shall not directly or indirectly modify objects via their arguments.
<p/>
<ins>-?- Parallel algorithms are constrained when calling mutating element access functions without synchronisation: If 
any mutating element access function is called on an object there shall be no other unsynchronised accesses to this object. 
The mutating element access functions are those which are specified as mutating object in the concept, notably assignment 
on any object, operators <tt>++</tt>, <tt>--</tt>, <tt>+=</tt>, and <tt>-=</tt> on any of the iterator or <tt>Size</tt> 
parameters, and any <tt>@=</tt> operators on the <tt>Size</tt> parameters.</ins>
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2017-03-03, Kona]</i></p>

<p>
Dietmar provides improved wording. Issues with the PR before the change:
</p>
<ul>
<li><p>The part before the colon is redundant: we don't need to state that.</p></li>
<li><p>Replace "notably" with "specifically"</p></li>
<li><p><tt>swap()</tt> needs to be in the list.</p></li>
<li><p>Not sure what "called on an object means"</p></li>
<li><p>The assignment side is overconstrained: the right hand side is allowed.</p></li>
</ul>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 28.4.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.user">[algorithms.parallel.user]</a> as indicated:</p>
<blockquote>
<p>
-1- Function objects passed into parallel algorithms as objects of type <tt>Predicate</tt>, <tt>BinaryPredicate</tt>, 
<tt>Compare</tt>, and <tt>BinaryOperation</tt> shall not directly or indirectly modify objects via their arguments.
<p/>
<ins>-?- If an object is mutated by an element access function the algorithm will perform no other unsynchronized 
accesses to that object. The mutating element access functions are those which are specified as mutating the object 
in the relevant concept, such as <tt>swap()</tt>, <tt>++</tt>, <tt>--</tt>, <tt>@=</tt>, and assignments. For the assignment 
and <tt>@=</tt> operators only the left argument is mutated.</ins>
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2017-03-03, Kona]</i></p>

<p>Dietmar finetunes wording after review by SG1.</p>

<p><i>[2017-03-03, Kona]</i></p>

<p>Move to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Add a new paragraph following 28.4.3 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec">[algorithms.parallel.exec]</a> p1 as indicated:</p>
<blockquote>
<p>
-1- Parallel algorithms have template parameters named <tt>ExecutionPolicy</tt> (20.19) which describe the manner in
which the execution of these algorithms may be parallelized and the manner in which they apply the element
access functions.
<p/>
<ins>-?- If an object is modified by an element access function the algorithm will perform no other unsynchronized accesses 
to that object. The modifying element access functions are those which are specified as modifying the object in the relevant 
concept [<i>Note:</i> For example, <tt>swap()</tt>, <tt>++</tt>, <tt>--</tt>, <tt>@=</tt>, and assignments modify the object. 
For the assignment and <tt>@=</tt> operators only the left argument is modified. &mdash; <i>end note</i>].</ins>
<p/>
-2- [&hellip;]
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2933" href="2933">2933.</a> PR for LWG 2773 could be clearer</h3>
<p><b>Section:</b> 23.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2017-02-06 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.creation">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.creation">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current PR for LWG <a href="2773">2773</a> changes <tt>std::ignore</tt> to be a <tt>constexpr</tt> variable. However it says 
nothing about whether using <tt>std::ignore</tt> in <tt>std::tie</tt> is a constant expression. I think the intent was clearly 
to allow this. Therefore I suggest we update the resolution to explicitly call this out in a note. (I don't think new normative 
wording is needed).
<p/>
I propose we update the current PR as follows:
</p>
<ol>
<li><p>Keep the current changes proposed by the PR.</p></li>
<li><p>Add a note after [tuple.creation]/p7 (<tt>std::tie</tt>):</p>
<blockquote><p>
<ins>[<i>Note:</i> The constructors and assignment operators provided by <tt>ignore</tt> shall be <tt>constexpr</tt>]</ins>
</p></blockquote>
</li>
</ol>
<p>
Perhaps LWG feels the existing wording is clear enough, but if not I think the above changes sufficiently clarify it.
<p/>
The ability to <tt>constexpr</tt> assign to <tt>std::ignore</tt> can be important: Here is an extremely contrived example:
</p>
<blockquote><pre>
constexpr bool foo() {
  auto res = std::tie(std::ignore);
  std::get&lt;0&gt;(res) =42; 
  return true;
}
static_assert(foo());
</pre></blockquote>
<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 3. P/R is incorrect; it should be a note. Marshall to work with Eric to get better wording. STL says "use an exposition-only class".</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 23.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.creation">[tuple.creation]</a> as indicated:</p>
<blockquote><pre>
template&lt;class... TTypes&gt;
  constexpr tuple&lt;TTypes&amp;...> tie(TTypes&amp;... t) noexcept;
</pre>
<blockquote>
<p>
-7- <i>Returns:</i> [&hellip;]
<p/>
<ins>-?- [<i>Note:</i> The constructors and assignment operators provided by <tt>ignore</tt> shall be <tt>constexpr</tt>. &mdash; <i>end note</i>]</ins>
<p/>
-8- [<i>Example:</i> [&hellip;] &mdash; <i>end example</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2935" href="2935">2935.</a> What should <tt>create_directories</tt> do when <tt>p</tt> already exists but is not a directory?</h3>
<p><b>Section:</b> 30.10.15.6 <a href="https://timsong-cpp.github.io/cppwp/fs.op.create_directories">[fs.op.create_directories]</a>, 30.10.15.7 <a href="https://timsong-cpp.github.io/cppwp/fs.op.create_directory">[fs.op.create_directory]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2017-02-15 <b>Last modified:</b> 2017-02-22 17:02:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>create_directory</tt> and <tt>create_directories</tt> functions have a postcondition that says 
<tt>is_directory(p)</tt>, but it is unclear how they are supposed to provide this. Both of their effects say that 
they create a directory and return whether it was actually created. It is possible to interpret this as "if 
creation fails due to the path already existing, issue another system call to see if the path is a directory, 
and change the result if so" &mdash; but it seems unfortunate to require both Windows and POSIX to issue more 
system calls in this case.
<p/>
In email discussion Davis Herring and Billy O'Neal discussed this issue and agreed that this was probably 
unintentional. Special thanks for Johnathan Wakely's suggested change to <tt>create_directories</tt>' 
<em>Returns</em> clause.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Make the following edits to 30.10.15.6 <a href="https://timsong-cpp.github.io/cppwp/fs.op.create_directories">[fs.op.create_directories]</a>:</p>

<blockquote>
<pre>
bool create_directories(const path&amp; p);
bool create_directories(const path&amp; p, error_code&amp; ec) noexcept;
</pre>
</blockquote>
<p>
-1- <em>Effects:</em><del> Establishes the postcondition by calling </del><ins>Calls </ins><tt>create_directory()</tt> for <del>any</del><ins>each</ins> element of <tt>p</tt> that does not exist.
<p/>
<del>-2- <em>Postconditions:</em> <tt>is_directory(p)</tt>.</del>
<p/>
-3- <em>Returns:</em> <tt>true</tt> if a new directory was created <ins>for the directory <tt>p</tt> resolves to</ins>, 
otherwise <tt>false</tt>. The signature with argument <tt>ec</tt> returns <tt>false</tt> if an error occurs.
<p/>
-4- <em>Throws:</em> As specified in 30.10.7 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.</p>
<p>
-5- <em>Complexity:</em> &#x1d4aa;(<i>n</i>) where <i>n</i> is the number of elements of <tt>p</tt><del> that do not exist</del>.
</p>
</li>

<li><p>Make the following edits to 30.10.15.7 <a href="https://timsong-cpp.github.io/cppwp/fs.op.create_directory">[fs.op.create_directory]</a>:</p>

<blockquote>
<pre>
bool create_directory(const path&amp; p);
bool create_directory(const path&amp; p, error_code&amp; ec) noexcept;
</pre>
</blockquote>
<p>
-1- <em>Effects:</em><del> Establishes the postcondition by attempting to create</del><ins>Creates</ins> the directory 
<tt>p</tt> resolves to, as if by POSIX <tt>mkdir()</tt> with a second argument of <tt>static_cast&lt;int&gt;(perms::all)</tt>. 
Creation failure because <tt>p</tt> <del>resolves to an existing directory shall not be treated as</del><ins>already exists 
is not</ins> an error.
<p/>
<del>-2- <em>Postconditions:</em> <tt>is_directory(p)</tt>.</del>
<p/>
-3- <em>Returns:</em> <tt>true</tt> if a new directory was created, otherwise <tt>false</tt>. The signature with argument 
<tt>ec</tt> returns <tt>false</tt> if an error occurs.
<p/>
-4- <em>Throws:</em> As specified in 30.10.7 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.
</p>
</li>
</ol>







<hr>
<h3><a name="2936" href="2936">2936.</a> Path comparison is defined in terms of the generic format</h3>
<p><b>Section:</b> 30.10.8.4.8 <a href="https://timsong-cpp.github.io/cppwp/fs.path.compare">[fs.path.compare]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2017-02-21 <b>Last modified:</b> 2017-03-19 19:03:20 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, path comparison is defined elementwise, which implies a conversion from the native format (implied by 
<tt>native()</tt> returning <tt>const string&amp;</tt>). However, the conversion from the native format to the generic 
format might not be information preserving. This would allow two paths <tt>a</tt> and <tt>b</tt> to say 
<tt>a.compare(b) == 0</tt>, but <tt>a.native().compare(b.native()) != 0</tt> as a result of this missing information, 
which is undesirable. We only want that condition to happen if there are redundant directory separators. We also don't 
want to change the path comparison to be in terms of the native format, due to Peter Dimov's example where we want 
<tt>path("a/b")</tt> to sort earlier than <tt>path("a.b")</tt>, and we want <tt>path("a/b") == path("a//////b")</tt>.
<p/>
Citing a Windows example, conversion to the generic format is going to have to drop alternate data streams. This might 
give <tt>path("a/b:ads") == path("a/b")</tt>. I think I should consider the alternate data streams as part of the path 
element though, so this case might be fine, so long as I make <tt>path("b:ads").native()</tt> be <tt>"b:ads"</tt>. 
This might not work for our z/OS friends though, or for folks where the native format looks nothing like the generic format.
<p/>
Additionally, this treats root-directory specially. For example, the current spec wants <tt>path("c:/a/b") == path("c:/a////b")</tt>, 
but <tt>path("c:/a/b") != path("c:///a/b")</tt>, because <tt>native()</tt> for the root-directory path element will literally 
be the slashes or preferred separators.
<p/>
This addresses similar issues to those raised in US 57 &mdash; it won't make absolute paths sort at the beginning or end 
but it will make paths of the same kind sort together.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Make the following edits to 30.10.8.4.8 <a href="https://timsong-cpp.github.io/cppwp/fs.path.compare">[fs.path.compare]</a>:</p>

<blockquote>
<pre>
int compare(const path&amp; p) const noexcept;
</pre>
<blockquote>
<p>
-1- <em>Returns</em>:
</p>
<blockquote>
<p>
<ins>&mdash; Let <tt>rootNameComparison</tt> be the result of <tt>this-&gt;root_name().native().compare(p.root_name().native())</tt>. If <tt>rootNameComparison</tt> is not <tt>0</tt>, <tt>rootNameComparison</tt>; otherwise,</ins>
</p>
<p>
<ins>&mdash; If <tt>this-&gt;has_root_directory()</tt> and <tt>!p.has_root_directory()</tt>, a value less than <tt>0</tt>; otherwise,</ins>
</p>
<p>
<ins>&mdash; If <tt>!this-&gt;has_root_directory()</tt> and <tt>p.has_root_directory()</tt>, a value greater than <tt>0</tt>; otherwise,</ins>
</p>
<p>
<ins>&mdash; A value greater than, less than, or equal to 0, ordering the paths in a depth-first traversal order.</ins>
</p>
</blockquote>
<p>
<ins>-?- [<i>Note:</i> For POSIX and Windows platforms, this is accomplished by lexicographically ordering the half-open ranges <tt>[begin(), end())</tt> of <tt>this-&gt;relative_path()</tt> and <tt>p.relative_path()</tt> as follows:</ins></p>
<blockquote>
<p>
&mdash; A value less than <tt>0</tt>, if <tt>native()</tt> for the elements of <tt><del>*</del>this<ins>-&gt;relative_path()</ins></tt> are lexicographically less than <tt>native()</tt> for the elements of <tt>p<ins>.relative_path()</ins></tt>; otherwise,</p>
<p>
&mdash; a value greater than <tt>0</tt>, if <tt>native()</tt> for the elements of <tt><del>*</del>this<ins>-&gt;relative_path()</ins></tt> are lexicographically greater than <tt>native()</tt> for the elements of <tt>p<ins>.relative_path()</ins></tt>; otherwise,</p>
<p>
&mdash; <tt>0</tt>.</p>
</blockquote>
<p>
<ins>&mdash; <i>end note</i>]</ins>
</p>
<p>
<del>-2- <em>Remarks</em>: The elements are determined as if by iteration over the half-open range <tt>[begin(), end())</tt> 
for <tt>*this</tt> and <tt>p</tt>.</del>
</p>
</blockquote>
<pre>
int compare(const string_type&amp; s) const
int compare(basic_string_view&lt;value_type&gt; s) const;
</pre>
<blockquote>
<p>
<del>-3- <em>Returns</em>: <tt>compare(path(s))</tt></del>
</p>
<blockquote class="note">
<p>
[Editor's note: Delete paragraph 3 entirely and merge the <tt>value_type</tt> overload with those above.]
</p>
</blockquote>
</blockquote>
<pre>
int compare(const value_type* s) const
</pre>
<blockquote>
<p>
-4- <em><del>Returns</del><ins>Effects</ins></em>: <ins>Equivalent to <tt>return 
</tt></ins><tt>compare(path(s))<ins>;</ins><del>.</del></tt>
</p>
</blockquote>
</blockquote>

</li>
</ol>







<hr>
<h3><a name="2937" href="2937">2937.</a> Is <tt>equivalent("existing_thing", "not_existing_thing")</tt> an error?</h3>
<p><b>Section:</b> 30.10.15.12 <a href="https://timsong-cpp.github.io/cppwp/fs.op.equivalent">[fs.op.equivalent]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2017-02-27 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.equivalent">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/fs.op.equivalent">[fs.op.equivalent]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See discussion on the LWG mailing list with subject "Is equivalent("existing_thing", "not_existing_thing") an error?", abreviated below:
<p/>
Billy O'Neal:
</p>
<blockquote>
<p>
The existing "an error is reported" effects say that an error is reported for <tt>!exists(p1) &amp;&amp; !exists(p2)</tt>, but 
I'm not sure that treating <tt>equivalent("existing_thing", "not_existing_thing")</tt> as "<tt>false</tt>, no error" makes any more 
sense than for <tt>equivalent("not_existing_thing", "not_existing_thing")</tt>.
<p/>
It's also unfortunate that the current spec requires reporting an error for <tt>is_other(p1) &amp;&amp; is_other(p2)</tt> &mdash; 
there's no reason that you can't give a sane answer for paths to NT pipes. (Do POSIX FIFOs give garbage answers here?)
</p>
</blockquote>
<p>
Davis Herring:
</p>
<blockquote>
<p>
I'm fine with an error if either path does not exist. See also Late 29: I would much prefer
</p>
<blockquote><pre>
file_identity identity(const path&amp;, bool resolve = true);
</pre></blockquote>
<p>
which would of course produce an error if the path did not exist (or, with the default <tt>resolve</tt>, was a broken symlink).
<p/>
See Late 30 and 32 (31 has been resolved). FIFOs pose no trouble: you can even <tt>fstat(2)</tt> on the naked file 
descriptors produced by <tt>pipe(2)</tt>. (That said, I observe the strange inconsistency that Linux but not macOS 
gives both ends of a pipe the same <tt>st_ino</tt>.)
<p/>
POSIX has no reason that I know of to treat any file type specially for <tt>equivalent()</tt>.
</p>
</blockquote>
<p>
Billy O'Neal:
</p>
<blockquote>
<p>
I think such a <tt>file_identity</tt> feature would be useful but we can always add it in addition to <tt>equivalent</tt> 
post-C++17.
</p>
</blockquote>
<p>
Beman Dawes:
</p>
<blockquote>
<p>
Looks good to me. Maybe submit this as an issue right away in the hopes it can go in C++17?
</p>
</blockquote>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 0; Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Make the following edits to 30.10.15.12 <a href="https://timsong-cpp.github.io/cppwp/fs.op.equivalent">[fs.op.equivalent]</a>:</p>

<blockquote>
<pre>
bool equivalent(const path&amp; p1, const path&amp; p2);
bool equivalent(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
<del>-1- Let <tt>s1</tt> and <tt>s2</tt> be <tt>file_status</tt>s determined as if by <tt>status(p1)</tt> and <tt>status(p2)</tt>, 
respectively.</del>
<p/>
<del>-2- <i>Effects:</i> Determines <tt>s1</tt> and <tt>s2</tt>. If <tt>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; 
is_other(s2))</tt> an error is reported (27.10.7).</del>
<p/>
-3- <i>Returns:</i> <tt>true</tt>, if <del><tt>s1 == s2</tt> and</del> <tt>p1</tt> and <tt>p2</tt> resolve to the same file system 
entity, else <tt>false</tt>. The signature with argument <tt>ec</tt> returns <tt>false</tt> if an error occurs.
<p/>
-4- Two paths are considered to resolve to the same file system entity if two candidate entities reside on the
same device at the same location. <ins>[<i>Note:</i> On POSIX platforms, t</ins><del>T</del>his is determined as if by the values 
of the POSIX <tt>stat</tt> structure, obtained as if by <tt>stat()</tt> for the two paths, having equal <tt>st_dev</tt> values and 
equal <tt>st_ino</tt> values. <ins>&mdash; <i>end note</i>]</ins>
<p/>
<ins>-?- <i>Remarks:</i> <tt>!exists(p1) || !exists(p2)</tt> is an error.</ins>
<p/>
-5- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>

</li>
</ol>







<hr>
<h3><a name="2938" href="2938">2938.</a> <tt>basic_string_view::const_iterator</tt> should be literal types</h3>
<p><b>Section:</b> 24.4.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Antony Polukhin <b>Opened:</b> 2017-03-01 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Force the literal type requirement for the <tt>const_iterator</tt> in the
<tt>std::basic_string_view</tt> so that iterators of <tt>std::basic_string_view</tt>
could be used in <tt>constexpr</tt> functions.
</p>

<p><i>[2017-03-02, Kona]</i></p>

<p>
Wording tweaks suggested by LWG applied.
</p>

<p><i>[2017-03-02, Tim Song comments]</i></p>

<p>
I don't believe the blanket "all operations" wording is quite correct.
<p/>
First, <tt>T t;</tt> (required by <tt>DefaultConstructible</tt>) isn't usable in a constant expression if the iterator is a 
pointer, since it would leave it uninitialized. 
<p/>
Second, an explicit destructor call <tt>u.~T()</tt> (required by <tt>Destructible</tt>) isn't usable if the iterator is a 
class type because it explicitly invokes a non-<tt>constexpr</tt> function (the destructor); see [expr.const]/2.2.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 2. Lisa and Alisdair to work with Antony to come up with better wording. The same wording can be used for <a href="2897">2897</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Add to the end of the 24.4.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a> section:</p>

<blockquote>
<p>
-1- In every specialization <tt>basic_string_view&lt;charT, traits&gt;</tt>, the type traits shall satisfy the character
traits requirements (21.2), and the type <tt>traits::char_type</tt> shall name the same type as <tt>charT</tt>.
<p/>
<ins>-?- All operations on <tt>iterator</tt> and <tt>const_iterator</tt> that are required to satisfy the 
random access iterator requirements are usable in constant expressions.</ins>
</p>
</blockquote>

</li>
</ol>







<hr>
<h3><a name="2939" href="2939">2939.</a> Some type-completeness constraints of traits are overspecified</h3>
<p><b>Section:</b> 23.15.2 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2017-03-02 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2797">2797</a> (RU 2) suggests that certain type-traits should be required to
diagnose violations of their pre-conditions. The basic idea is founded and I see no problems for
requiring this for the mentioned traits <tt>alignment_of</tt> or <tt>is_base_of</tt>,
for example. But if we want to require this diagnostics for some other traits, such as <tt>is_convertible</tt>,
<tt>is_constructible</tt> (and friends), or <tt>is_callable</tt> (and possibly some others), we really should
be sure that our current requirements are OK. 
<p/>
Unfortunately, there exists some cases, where we currently overspecify imposing complete type requirements where they
are not actually required. For example, for the following situation the answer of the trait could 
be given without ever needing the complete type of <tt>X</tt>:
</p>
<blockquote><pre>
struct X; // Never defined

static_assert(std::is_convertible_v&lt;X, const X&amp;&gt;);
</pre></blockquote>
<p>
Unfortunately we cannot <em>always</em> allow incomplete types, because most type constructions or conversions indeed
require a complete type, so <em>generally</em> relaxing the current restrictions is also not an option.
<p/>
The core language has a solution for this "small" gap of situations, where the response of the compiler <em>might</em>
depend on type completeness: Undefined behaviour. So, I believe we need a somewhat more detailled form to express the
intend here. Informally, I would suggest that the program should only be ill-formed in the situation described by 
LWG <a href="2797">2797</a>, if there exists the <em>possibility</em> that the compiler would require complete types for the
considered operation. The example shown above, <tt>std::is_convertible_v&lt;X, const X&amp;&gt;</tt>, would <b>never</b>
require the need to complete <tt>X</tt>, so here no violation should exist.
<p/>
The presented example might seem a tiny one, but the Standard Library type traits are extreme fundamental tools and we should
try to not give the impression that an approximate rule of the current type constraints breaks reasonable code.
<p/>
It is correct, that above example has currently undefined behaviour due to the breakage of pre-conditions, therefore
this issue suggests to fix the current situation <em>before</em> enforcing a diagnostic for such valid situations.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 2. Is related to <a href="2797">2797</a>, but really needs an audit of the type traits.</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2940" href="2940">2940.</a> <tt>result_of</tt> specification also needs a little cleanup</h3>
<p><b>Section:</b> D.12 <a href="https://timsong-cpp.github.io/cppwp/depr.meta.types">[depr.meta.types]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2017-03-04 <b>Last modified:</b> 2017-03-14 03:03:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.meta.types">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/depr.meta.types">[depr.meta.types]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://wg21.link/p0604r0">P0604R0</a> missed a similar adjustment that was performed for the
deprecated type trait templates <tt>is_literal_type</tt> and <tt>is_literal_type_v</tt> via LWG <a href="2838">2838</a>: 
<p/>
Moving the <tt>result_of</tt> to Annex D means that the general prohibition against specializing type traits 
in [meta.type.synop]/1 does no longer exist, so should be explicitly spelled out. Wording will be provided
after publication of the successor of <a href="http://wg21.link/n4640">N4640</a>.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 3</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2941" href="2941">2941.</a> &sect;[thread.req.timing] wording should apply to both member and namespace-level functions</h3>
<p><b>Section:</b> 33.2.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.timing">[thread.req.timing]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Mcdougall <b>Opened:</b> 2017-03-07 <b>Last modified:</b> 2017-03-07 19:03:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.req.timing">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/thread.req.timing">[thread.req.timing]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 33.2.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.timing">[thread.req.timing]</a>, both /3 and /4 talk about "member
functions whose names end in <tt>_for</tt>" and "<tt>_until</tt>", but these clauses
also apply to <tt>this_thread::sleep_for()</tt> and <tt>this_thread::sleep_until()</tt>,
which are namespace-level functions (30.3.2).
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>
<ol>
<li><p>Modify 33.2.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.timing">[thread.req.timing]</a> as indicated::</p>
<blockquote>
<p>
[&hellip;]
<p/>
-3- The <del>member</del> functions whose names end in <tt>_for</tt> take an argument that specifies a duration. [&hellip;]
<p/>
-4- The <del>member</del> functions whose names end in <tt>_until</tt> take an argument that specifies a time point. [&hellip;]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2942" href="2942">2942.</a> LWG 2873's resolution missed <tt>weak_ptr::owner_before</tt></h3>
<p><b>Section:</b> 23.11.2.3.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.weak.obs">[util.smartptr.weak.obs]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-03-09 <b>Last modified:</b> 2017-03-16 20:03:38 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.weak.obs">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.weak.obs">[util.smartptr.weak.obs]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The NB comment asked for <tt>noexcept</tt> on <tt>shared_ptr::owner_before</tt>, <tt>weak_ptr::owner_before</tt>, and 
<tt>owner_less::operator()</tt>, but the PR of LWG <a href="2873">2873</a> only added it to the first and the third one.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Edit 23.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.weak">[util.smartptr.weak]</a>,  class template <tt>weak_ptr</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
<i>// 20.11.2.3.5, observers</i>
[&hellip;]
template&lt;class U&gt; bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const <ins>noexcept</ins>;
template&lt;class U&gt; bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Edit 23.11.2.3.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.weak.obs">[util.smartptr.weak.obs]</a> immediately before p4 as indicated:</p>
<blockquote>
<pre>
template&lt;class U&gt; bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const <ins>noexcept</ins>;
template&lt;class U&gt; bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-4- <i>Returns:</i> An unspecified value such that [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2943" href="2943">2943.</a> Problematic specification of the wide version of <tt>basic_filebuf::open</tt></h3>
<p><b>Section:</b> 30.9.2.3 <a href="https://timsong-cpp.github.io/cppwp/filebuf.members">[filebuf.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-03-09 <b>Last modified:</b> 2017-03-16 19:03:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filebuf.members">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/filebuf.members">[filebuf.members]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2676">2676</a> specified <tt>basic_filebuf::open(const std::filesystem::path::value_type* s, ios_base::openmode mode)</tt> 
by simply reusing the specification for the <tt>const char*</tt> overload, but that specification is incorrect for the wide overload: 
it says that <tt>s</tt> is an NTBS &mdash; a null-terminated byte string &mdash; which it isn't. Moreover, it specifies that 
the file is opened as if by calling <tt>fopen(s, modstr)</tt>, but that call is ill-formed if <tt>s</tt> isn't a <tt>const char*</tt>.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2944" href="2944">2944.</a> LWG 2905 accidentally removed requirement that construction of the deleter doesn't throw an exception</h3>
<p><b>Section:</b> 23.11.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-03-11 <b>Last modified:</b> 2017-03-16 20:03:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.ctor">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording simplification in LWG <a href="2905">2905</a> accidentally deleted the
requirement that construction of the deleter doesn't throw an
exception. While this isn't the end of the world since any exception
will just run into the noexcept on the constructor and result in a
call to <tt>std::terminate()</tt>, the other <tt>unique_ptr</tt> constructors still have
a similar no-exception <i>Requires:</i> clause, leaving us in the odd
situation where throwing an exception results in undefined behavior
for some constructors and <tt>terminate()</tt> for others. If guaranteeing
<tt>std::terminate()</tt> on exception is desirable, that should be done across
the board.
<p/>
The proposed wording below simply restores the nothrow requirement
along with the <tt>Copy/MoveConstructible</tt> requirement. Wording for the
other alternative (guaranteed <tt>std::terminate()</tt>) can be produced if
desired.
<p/>
Suggested wording changes against the <em>expected working draft changes</em>:
</p>

<blockquote>
<pre>
unique_ptr(pointer p, <i>see below</i> d1) noexcept;
unique_ptr(pointer p, <i>see below</i> d2) noexcept;
</pre>
<blockquote>
<p>
-9- The signature of these constructors depends upon whether <tt>D</tt> is a reference type. If <tt>D</tt> 
is a non-reference type <tt>A</tt>, then the signatures are:
<p/>
[&hellip;]
<p/>
-10- If <tt>D</tt> is an lvalue reference type <tt>A&amp;</tt>, then the signatures are:
<p/>
[&hellip;]
<p/>
-11- If <tt>D</tt> is an lvalue reference type <tt>const A&amp;</tt>, then the signatures are:
<p/>
[&hellip;]
<p/>
<ins>-??- <i>Requires:</i> For the first constructor, if <tt>D</tt> is not a reference
type, <tt>D</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> and such
construction shall not exit via an exception. For the second
constructor, if <tt>D</tt> is not a reference type, <tt>D</tt> shall satisfy the
requirements of <tt>MoveConstructible</tt> and such construction shall not exit
via an exception.</ins>
</p>
</blockquote>
</blockquote>

<p><i>[2017-03-16, Daniel comments]</i></p>

<p>
The publication of the new working draft is awaited, before proposed wording against that
new working draft is formally possible.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2945" href="2945">2945.</a> Order of template parameters in <tt>optional</tt> comparisons</h3>
<p><b>Section:</b> 23.6.8 <a href="https://timsong-cpp.github.io/cppwp/optional.comp_with_t">[optional.comp_with_t]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-03-13 <b>Last modified:</b> 2017-03-16 20:03:04 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.comp_with_t">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/optional.comp_with_t">[optional.comp_with_t]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2934">2934</a> added an additional template parameter to the comparison
operators for <tt>std::optional</tt>, but the ones that compare <tt>U</tt> with
<tt>optional&lt;T&gt;</tt> have the parameters backwards compared to the function parameters:
</p>

<blockquote>
<pre>
template &lt;class T, class U&gt; 
constexpr bool operator==(const U&amp;, const optional&lt;T&gt;&amp;);
</pre>
</blockquote>

<p>
Ville confirmed there's no particular reason for this, it's just how
he wrote the proposed resolution, but as this has normative effect we
should consider if we really want the template parameters and function
parameters to be in different orders or not.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2946" href="2946">2946.</a> LWG 2758's resolution missed further corrections</h3>
<p><b>Section:</b> 24.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a>, 24.3.2.6.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a>, 24.3.2.6.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a>, 24.3.2.7 <a href="https://timsong-cpp.github.io/cppwp/string.ops">[string.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2017-03-17 <b>Last modified:</b> 2017-03-19 12:03:20 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2758">2758</a> corrected newly introduced ambiguities of <tt>std::string::assign</tt> and other functions 
that got new overloads taking a <tt>basic_string_view</tt> as argument, but the assignment operator of 
<tt>basic_string</tt> and other functions taking a parameter of type <tt>basic_string_view&lt;charT, traits&gt;</tt> 
were not corrected. Similar to the previous issue the following operations lead now to an ambiguity as well:
 </p>

<blockquote>
<pre>
#include &lt;string&gt;

int main() 
{
  std::string s({"abc", 1});
  s = {"abc", 1};
  s += {"abc", 1};
  s.append({"abc", 1});
  s.assign({"abc", 1});
  s.insert(0, {"abc", 1});
  s.replace(0, 1, {"abc", 1});
  s.replace(s.cbegin(), s.cbegin(), {"abc", 1});
  s.find({"abc", 1});
  s.rfind({"abc", 1});
  s.find_first_of({"abc", 1});
  s.find_last_of({"abc", 1});
  s.find_first_not_of({"abc", 1});
  s.find_last_not_of({"abc", 1});
  s.compare({"abc", 1});
  s.compare(0, 1, {"abc", 1});
}
</pre>
</blockquote>

<p>
The right fix is to convert <em>all</em> member functions taken a <tt>basic_string_view&lt;charT, traits&gt;</tt> parameter 
into constrained function templates.
<p/>
When doing so, it turns out that there occurs an additional problem: The functions that had been massaged by LWG 
<a href="2758">2758</a> are all functions that are not specified to be <tt>noexcept</tt>, but the wider range of 
"string operation" functions taking a <tt>basic_string_view&lt;charT, traits&gt;</tt> parameter are mostly 
<tt>noexcept</tt> because they had a wide contract. Now with the approach of LWG <a href="2758">2758</a>, there are all 
types allowed that are <em>convertible</em> to <tt>basic_string_view&lt;charT, traits&gt;</tt>, but the conversion 
occurs now in the function body, not outside of it. So, if these conversion <em>would</em> be potentially 
exception-throwing, this would lead to a call to <tt>std::terminate</tt>, which is a semantic change compared to 
the previous specification. There are several options to handle this situation:
</p>
<ol>
<li><p>Ignore that and let <tt>std::terminate</tt> come into action. This is a different way of saying that
we impose the requirement of a nothrowing operation.</p></li>
<li><p>Remove <tt>noexcept</tt> from all the affected functions.</p></li>
<li><p>Make these functions conditionally <tt>noexcept</tt>.</p></li>
</ol>
<p>
The submitter has a personal preference for option (3), except that this would complicate the wording a bit, 
because unfortunately there exists yet no trait <tt>std::is_nothrow_convertible</tt> (See LWG <a href="2040">2040</a>). 
A seemingly low-hanging fruit would be the attempt to use <tt>std::is_nothrow_constructible</tt> instead, but this 
trait describes a potentially different initialization context and is therefore inappropriate. Option (1) would 
conserve the existing <tt>noexcept</tt> guarantee for all non-throwing conversions, but now these functions become 
narrow-contract functions and at least according to the <a href="http://wg21.link/n3279">current <tt>noexcept</tt> 
guidelines</a> such functions should <em>not</em> be marked as <tt>noexcept</tt>. But there are exceptions possible 
for that rule, and the initially suggested proposed wording below argues that this exception is reasonable here, 
because the required wording fixes just an unintended side-effects of transforming the functions into functions 
templates, but it doesn't intend to change the actual functionality.
<p/>
Some of the below suggested overload exclusion constraints technically don't require the additional
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt; == false</tt> requirement, but the submitter of this issue
suggests a more advanced approach that should be applied in a synchronous wording adjustment combined with the 
existing LWG <a href="2758">2758</a> wording: It would presumably life easier for implementations (which are allowed
to provide additional member function overloads as conforming extensions), when we would define a mini requirement
set for template parameter type <tt>T</tt> below:
</p>
<ul>
<li><p><tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</p></li>
<li><p><tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</p></li>
<li><p>The implicit conversion to <tt>basic_string_view&lt;charT, traits&gt;</tt> shall not throw an exception.</p></li>
</ul>
<p>
But the corresponding slightly revised wording taking advantage of this "concept-like" requirements set will not be
suggested before the upcoming working draft has been published to allow a simpler coordinated adjustment together with
the LWG <a href="2758">2758</a> wording.
<p/>
It should also be noted that these changes have impact on deduction behaviour and therefore may require further 
adjustments of the deduction rules.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Edit 24.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, class template <tt>basic_string</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]

<i>// 21.3.2.2, construct/copy/destroy</i>
[&hellip;]
<ins>template&lt;class T&gt;</ins>
explicit basic_string(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                      const Allocator&amp; a = Allocator());
[&hellip;]
<ins>template&lt;class T&gt;</ins>
basic_string&amp; operator=(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
basic_string&amp; operator=(const charT* s);
[&hellip;]

<i>// 21.3.2.6, modifiers</i>
[&hellip;]
<ins>template&lt;class T&gt;</ins>
basic_string&amp; operator+=(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
[&hellip;]
<ins>template&lt;class T&gt;</ins>
basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
[&hellip;]
<ins>template&lt;class T&gt;</ins>
basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
[&hellip;]
<ins>template&lt;class T&gt;</ins>
basic_string&amp; insert(size_type pos, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
[&hellip;]
<ins>template&lt;class T&gt;</ins>
basic_string&amp; replace(size_type pos1, size_type n1, 
                      <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
[&hellip;]
<ins>template&lt;class T&gt;</ins>
basic_string&amp; replace(const_iterator i1, const_iterator i2,
                      <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
[&hellip;]

<i>// 21.3.2.7, string operations</i>
[&hellip;]
<ins>template&lt;class T&gt;</ins>
size_type find (<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                size_type pos = 0) const noexcept;
[&hellip;]
<ins>template&lt;class T&gt;</ins>
size_type rfind(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                size_type pos = npos) const noexcept;
[&hellip;]
<ins>template&lt;class T&gt;</ins>
size_type find_first_of(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                        size_type pos = 0) const noexcept;
[&hellip;]
<ins>template&lt;class T&gt;</ins>
size_type find_last_of (<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                        size_type pos = npos) const noexcept;
[&hellip;]
<ins>template&lt;class T&gt;</ins>
size_type find_first_not_of(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                            size_type pos = 0) const noexcept;
[&hellip;]
<ins>template&lt;class T&gt;</ins>
size_type find_last_not_of (<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                            size_type pos = npos) const noexcept;
[&hellip;]
<ins>template&lt;class T&gt;</ins>
int compare(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>) const noexcept;
[&hellip;]
<ins>template&lt;class T&gt;</ins>
int compare(size_type pos1, size_type n1, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>) const;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Edit 24.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
explicit basic_string(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                      const Allocator&amp; a = Allocator());
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> <del>Same as <tt>basic_string(sv.data(), sv.size(), a)</tt>.</del><ins>Creates a variable, <tt>sv</tt>, 
as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> and then behaves the same as 
<tt>basic_string(sv.data(), sv.size(), a)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; operator=(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
</pre>
<blockquote>
<p>
-25- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return assign(sv);
<ins>}</ins>
</pre>
</blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.6.1 <a href="https://timsong-cpp.github.io/cppwp/string.op+=">[string.op+=]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; operator+=(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then c</ins><del>C</del>alls <tt>append(sv)</tt>.
<p/>
-4- <i>Returns:</i> <tt>*this</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.6.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return append(sv.data(), sv.size());
<ins>}</ins>
</pre>
</blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.6.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return assign(sv.data(), sv.size());
<ins>}</ins>
</pre>
</blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.6.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; insert(size_type pos, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return insert(pos, sv.data(), sv.size());
<ins>}</ins>
</pre>
</blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.6.6 <a href="https://timsong-cpp.github.io/cppwp/string.replace">[string.replace]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; replace(size_type pos1, size_type n1,
                      <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return replace(pos1, n1, sv.data(), sv.size());
<ins>}</ins>
</pre>
</blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; replace(const_iterator i1, const_iterator i2,
                      <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>);
</pre>
<blockquote>
<p>
-21- <i>Requires:</i> <tt>[begin(), i1)</tt> and <tt>[i1, i2)</tt> are valid ranges.
<p/>
-22- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then c</ins><del>C</del>alls <tt>replace(i1 - begin(), i2 - i1, sv)</tt>.
<p/>
-23- <i>Returns:</i> <tt>*this</tt>.
</p>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.find">[string.find]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
size_type find(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>, size_type pos = 0) const noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The initialization of <tt>sv</tt>, as specified below, shall not throw an exception.</ins>
<p/>
-1- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then d</ins><del>D</del>etermines the lowest position <tt>xpos</tt>, if possible, such that both of the following conditions
hold: [&hellip;]
<p/>
-2- <i>Returns:</i> <tt>xpos</tt> if the function can determine such a value for <tt>xpos</tt>. Otherwise, returns <tt>npos</tt>.
</p>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.rfind">[string.rfind]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
size_type rfind(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>, size_type pos = npos) const noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The initialization of <tt>sv</tt>, as specified below, shall not throw an exception.</ins>
<p/>
-1- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then d</ins><del>D</del>etermines the highest position <tt>xpos</tt>, if possible, such that both of the following conditions
hold: [&hellip;]
<p/>
-2- <i>Returns:</i> <tt>xpos</tt> if the function can determine such a value for <tt>xpos</tt>. Otherwise, returns <tt>npos</tt>.
</p>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.7.4 <a href="https://timsong-cpp.github.io/cppwp/string.find.first.of">[string.find.first.of]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
size_type find_first_of(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>, size_type pos = 0) const noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The initialization of <tt>sv</tt>, as specified below, shall not throw an exception.</ins>
<p/>
-1- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then d</ins><del>D</del>etermines the lowest position <tt>xpos</tt>, if possible, such that both of the following conditions
hold: [&hellip;]
<p/>
-2- <i>Returns:</i> <tt>xpos</tt> if the function can determine such a value for <tt>xpos</tt>. Otherwise, returns <tt>npos</tt>.
</p>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.7.5 <a href="https://timsong-cpp.github.io/cppwp/string.find.last.of">[string.find.last.of]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
size_type find_last_of(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>, size_type pos = npos) const noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The initialization of <tt>sv</tt>, as specified below, shall not throw an exception.</ins>
<p/>
-1- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then d</ins><del>D</del>etermines the highest position <tt>xpos</tt>, if possible, such that both of the following conditions
hold: [&hellip;]
<p/>
-2- <i>Returns:</i> <tt>xpos</tt> if the function can determine such a value for <tt>xpos</tt>. Otherwise, returns <tt>npos</tt>.
</p>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.7.6 <a href="https://timsong-cpp.github.io/cppwp/string.find.first.not.of">[string.find.first.not.of]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
size_type find_first_not_of(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                            size_type pos = 0) const noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The initialization of <tt>sv</tt>, as specified below, shall not throw an exception.</ins>
<p/>
-1- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then d</ins><del>D</del>etermines the lowest position <tt>xpos</tt>, if possible, such that both of the following conditions
hold: [&hellip;]
<p/>
-2- <i>Returns:</i> <tt>xpos</tt> if the function can determine such a value for <tt>xpos</tt>. Otherwise, returns <tt>npos</tt>.
</p>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.7.7 <a href="https://timsong-cpp.github.io/cppwp/string.find.last.not.of">[string.find.last.not.of]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
size_type find_last_not_of(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                           size_type pos = npos) const noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The initialization of <tt>sv</tt>, as specified below, shall not throw an exception.</ins>
<p/>
-1- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then d</ins><del>D</del>etermines the highest position <tt>xpos</tt>, if possible, such that both of the following conditions
hold: [&hellip;]
<p/>
-2- <i>Returns:</i> <tt>xpos</tt> if the function can determine such a value for <tt>xpos</tt>. Otherwise, returns <tt>npos</tt>.
</p>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 24.3.2.7.9 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a> as indicated:</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
int compare(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>) const noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The initialization of <tt>sv</tt>, as specified below, shall not throw an exception.</ins>
<p/>
-1- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then d</ins><del>D</del>etermines the effective length <tt>rlen</tt> of the strings to compare as the smaller of 
<tt>size()</tt> and <tt>sv.size()</tt>. The function then compares the two strings by calling <tt>traits::compare(data(),
sv.data(), rlen)</tt>.
<p/>
-2- <i>Returns:</i> The nonzero result if the result of the comparison is nonzero. Otherwise, returns a value as
indicated in Table 63.
</p>
[&hellip;]
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
int compare(size_type pos1, size_type n1, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>) const;
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return basic_string_view&lt;charT, traits&gt;(data(), size()).substr(pos1, n1).compare(sv);
<ins>}</ins>
</pre>
</blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






</body>
</html>
