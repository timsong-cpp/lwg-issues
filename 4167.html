<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 4167: Use of "smaller" and "larger" in min,
max, and minmax is unclear</title>
<meta property="og:title" content="Issue 4167: Use of &quot;smaller&quot; and &quot;larger&quot; in min,
max, and minmax is unclear">
<meta property="og:description" content="C++ library issue. Status: New">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/4167.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="4167"><a href="lwg-active.html#4167">4167</a>. Use of "smaller" and "larger" in <code>min</code>,
<code>max</code>, and <code>minmax</code> is unclear</h3>
<p><b>Section:</b> 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2024-10-20 <b>Last modified:</b> 2024-10-20</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://github.com/cplusplus/draft/issues/6747">Editorial issue #6747</a>
finds it inconsistent that
the wording for the <code>max</code>, <code>min</code>, and <code>minmax</code> algorithms
uses "larger" and "smaller"
- terms normally applied to physical quantities -
to refer to relationships between values
which we term "greater" and "lesser"
everywhere else in the Working Paper.
Using "greater" and "lesser" would make it no less (pun intended)
of a problem that we describe the ordering imposed by
an arbitrary binary predicate as if it is a less-than ordering.
</p><p>
For example, 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> para 2 says that
<code>std::ranges::min(13, 42, std::greater{})</code>
"<i>Returns</i>: The smaller value.
Returns the first argument when
the arguments are equivalent."
The smaller of 13 and 42 is 13, which is <em>not</em> what this call yields.
The reader is supposed to somehow know that "The smaller value" actually means
"the value we'd call the lesser if the arguments were numbers and
<code>comp</code> described a less-then ordering."
It would be clearer and more concise to simply say
it returns <code>b</code> if
<code>invoke(comp, invoke(proj, b), invoke(proj, a))</code> yields <code>true</code>
and <code>a</code> otherwise.
</p>


<p id="res-4167"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages â€” C++">N4993</a>.
</p>
<ol>
<li><p>Modify 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> as indicated:</p>
<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
template&lt;class T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr const T&amp; ranges::min(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>-?- Let <code>comp</code> be <code>less{}</code> and
<code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.</ins>
</p><p>
-1- <i>Preconditions</i>:
For the first form, <code>T</code> meets the
<code><i>Cpp17LessThanComparable</i></code> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-2- <del><i>Returns</i>: The smaller value.
Returns the first argument
when the arguments are equivalent.</del>
<ins><i>Effects</i>: Equivalent to:</ins>
</p>
<blockquote><pre><ins>
return invoke(comp, invoke(proj, b), invoke(proj, a)) ? b : a;
</ins></pre></blockquote>
<p><del>
-3- <i>Complexity</i>: Exactly one comparison
and two applications of the projection, if any.
</del></p><p>
-4- <i>Remarks</i>: An invocation may explicitly specify
an argument for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr T min(initializer_list&lt;T&gt; r);
template&lt;class T, class Compare&gt;
  constexpr T min(initializer_list&lt;T&gt; r, Compare comp);
template&lt;copyable T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr T ranges::min(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
  requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
  constexpr range_value_t&lt;R&gt;
    ranges::min(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>-?- Let <code>comp</code> be <code>less{}</code> and <code>proj</code> be
<code>identity{}</code> for the overloads with no parameters by those names.</ins>
</p><p>
-5- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>.
For the overloads in namespace <code>std</code>, <code>T</code> meets the
<i><code>Cpp17CopyConstructible</code></i> requirements
<ins>(Table [tab:cpp17.copyconstructible])</ins>.
For the first form, <code>T</code> meets the
<i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-6- <i>Returns</i>: <del>The smallest value in the input range.
Returns a copy of the leftmost element
when several elements are equivalent to the smallest.</del>
<ins>Returns a copy of the leftmost element <code>e</code>
in the input range <code>r</code> for which
<code>bool(invoke(comp, invoke(proj, x), invoke(proj, e)))</code>
is <code>false</code> for all elements <code>x</code> in <code>r</code>.</ins>
</p><p>
-7- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons and
twice as many applications of the projection<del>, if any</del>.
</p><p>
-8- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
template&lt;class T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr const T&amp; ranges::max(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>
-?- Let <code>comp</code> be <code>less{}</code>
and <code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.
</ins>
</p><p>
-9- <i>Preconditions</i>: For the first form,
<code>T</code> meets the <i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-10- <del><i>Returns</i>: The larger value.
Returns the first argument when the arguments are equivalent.</del>
<ins><i>Effects</i>: Equivalent to:</ins>
<blockquote><pre><ins>
return invoke(comp, invoke(proj, a), invoke(proj, b)) ? b : a;
</ins></pre></blockquote>
</p><p>
<del>-11- <i>Complexity</i>: Exactly one comparison
and two applications of the projection, if any.</del>
</p><p>
-12- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr T max(initializer_list&lt;T&gt; r);
template&lt;class T, class Compare&gt;
  constexpr T max(initializer_list&lt;T&gt; r, Compare comp);
template&lt;copyable T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr T ranges::max(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
  requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
  constexpr range_value_t&lt;R&gt;
    ranges::max(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>
-?- Let <code>comp</code> be <code>less{}</code>
and <code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.
</ins>
</p><p>
-13- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>.
For the overloads in namespace <code>std</code>,
<code>T</code> meets the <i><code>Cpp17CopyConstructible</code></i> requirements
<ins>(Table [tab:cpp17.copyconstructible])</ins>.
For the first form, <code>T</code> meets
the <i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-14- <i>Returns</i>: <del>The largest value in the input range.
Returns a copy of the leftmost element
when several elements are equivalent to the largest.</del>
<ins>Returns a copy of the leftmost element <code>e</code>
in the input range <code>r</code> for which
<code>bool(invoke(comp, invoke(proj, e), invoke(proj, x)))</code>
is <code>false</code> for all elements <code>x</code> in <code>r</code>.</ins>
</p><p>
-15- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons
and twice as many applications of the projection<del>, if any</del>.
</p><p>
-16- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
template&lt;class T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr ranges::minmax_result&lt;const T&amp;&gt;
    ranges::minmax(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>
-?- Let <code>comp</code> be <code>less{}</code>
and <code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.
</ins>
</p><p>
-17- <i>Preconditions</i>: For the first form,
<code>T</code> meets the <i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-18- <i>Returns</i>: <code>{b, a}</code>
if <del><code>b</code> is smaller than <code>a</code></del>
<ins>
<code>bool(invoke(comp, invoke(proj, b), invoke(proj, a)))</code> is <code>true</code>
</ins>,
and <code>{a, b}</code> otherwise.
</p><p>
-19- <i>Complexity</i>: Exactly one comparison
and two applications of the projection<del>, if any</del>.
</p><p>
-20- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare&gt;
  constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);
template&lt;copyable T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr ranges::minmax_result&lt;T&gt;
    ranges::minmax(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
  requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
  constexpr ranges::minmax_result&lt;range_value_t&lt;R&gt;&gt;
    ranges::minmax(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>
-?- Let <code>comp</code> be <code>less{}</code>
and <code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.
</ins>
</p><p>
-21- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>.
For the overloads in namespace <code>std</code>,
<code>T</code> meets the <i><code>Cpp17CopyConstructible</code></i> requirements
<ins>(Table [tab:cpp17.copyconstructible])</ins>.
For the first form, <code>T</code> meets
the <i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-22- <i>Returns</i>: Let <code>X</code> be the return type.
Returns <code>X{x, y}</code>,
where <code>x</code> is a copy of the leftmost element
<del>with the smallest value</del>
<ins>
in the input range <code>r</code> for which
<code>bool(invoke(comp, invoke(proj, e), invoke(proj, x)))</code>
is <code>false</code> for all elements <code>e</code> in <code>r</code>,
</ins>
and <code>y</code> <ins>is</ins> a copy of the rightmost element
<del>with the largest value in the input range</del>
<ins>
in <code>r</code> for which
<code>bool(invoke(comp, invoke(proj, y), invoke(proj, e)))</code>
is <code>false</code> for all elements <code>e</code> in <code>r</code>
</ins>
.
</p><p>
-23- <i>Complexity</i>: At most (3/2)<code>ranges::distance(r)</code>
<del>applications of the corresponding predicate</del><ins>comparisons</ins>
and twice as many applications of the projection<del>, if any</del>.
</p><p>
-24- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.</p>
</li>
</ol>




</body>
</html>
