<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2050: Unordered associative containers do not use allocator_traits to define member types</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="2050" href="lwg-defects.html#2050">2050.</a> Unordered associative containers do not use <tt>allocator_traits</tt> to define member types</h3>
<p><b>Section:</b> 21.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#C++14">C++14</a>
 <b>Submitter:</b> Tom Zieberman <b>Opened:</b> 2011-04-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++14">C++14</a> status.</p>
<p><b>Discussion:</b></p>
<p>The unordered associative containers define their member types <tt>reference</tt>, 
<tt>const_reference</tt>, <tt>pointer</tt>, <tt>const_pointer</tt> in terms of 
their template parameter <tt>Allocator</tt> (via <tt>allocator_type</tt> typedef). As 
a consequence, only the allocator types, that provide sufficient typedefs, are usable 
as allocators for unordered associative containers, while other containers do not have 
this deficiency. In addition to that, the definitions of said typedefs are different 
from ones used in the other containers. This is counterintuitive and introduces a certain 
level of confusion. These issues can be fixed by defining <tt>pointer</tt> and 
<tt>const_pointer</tt> typedefs in terms of <tt>allocator_traits&lt;Allocator&gt;</tt> 
and by defining <tt>reference</tt> and <tt>const_reference</tt> in terms of 
<tt>value_type</tt> as is done in the other containers.
</p>

<p><i>[
2011 Bloomington.
]</i></p>


<p>
Move to Ready.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ul>
<li><p>Change 21.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> paragraph 3 as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
  class unordered_map
  {
  public:
    <i>// types</i>
    typedef Key key_type;
    typedef std::pair&lt;const Key, T&gt; value_type;
    typedef T mapped_type;
    typedef Hash hasher;
    typedef Pred key_equal;
    typedef Allocator allocator_type;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::pointer pointer;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::const_pointer const_pointer;
    typedef <del>typename allocator_type::reference</del><ins>value_type&amp;</ins> reference;
    typedef <del>typename allocator_type::const_reference</del><ins>const value_type&amp;</ins> const_reference;
    typedef <i>implementation-defined</i> size_type;
    typedef <i>implementation-defined</i> difference_type;

    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Change 21.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> paragraph 3 as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
  class unordered_multimap
  {
  public:
    <i>// types</i>
    typedef Key key_type;
    typedef std::pair&lt;const Key, T&gt; value_type;
    typedef T mapped_type;
    typedef Hash hasher;
    typedef Pred key_equal;
    typedef Allocator allocator_type;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::pointer pointer;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::const_pointer const_pointer;
    typedef <del>typename allocator_type::reference</del><ins>value_type&amp;</ins> reference;
    typedef <del>typename allocator_type::const_reference</del><ins>const value_type&amp;</ins> const_reference;
    typedef <i>implementation-defined</i> size_type;
    typedef <i>implementation-defined</i> difference_type;

    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Change 21.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a> paragraph 3 as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Key,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Allocator = std::allocator&lt;Key&gt; &gt;
  class unordered_set
  {
  public:
    <i>// types</i>
    typedef Key key_type;
    typedef Key value_type;
    typedef Hash hasher;
    typedef Pred key_equal;
    typedef Allocator allocator_type;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::pointer pointer;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::const_pointer const_pointer;
    typedef <del>typename allocator_type::reference</del><ins>value_type&amp;</ins> reference;
    typedef <del>typename allocator_type::const_reference</del><ins>const value_type&amp;</ins> const_reference;
    typedef <i>implementation-defined</i> size_type;
    typedef <i>implementation-defined</i> difference_type;

    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Change 21.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a> paragraph 3 as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Key,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Allocator = std::allocator&lt;Key&gt; &gt;
  class unordered_multiset
  {
  public:
    <i>// types</i>
    typedef Key key_type;
    typedef Key value_type;
    typedef Hash hasher;
    typedef Pred key_equal;
    typedef Allocator allocator_type;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::pointer pointer;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::const_pointer const_pointer;
    typedef <del>typename allocator_type::reference</del><ins>value_type&amp;</ins> reference;
    typedef <del>typename allocator_type::const_reference</del><ins>const value_type&amp;</ins> const_reference;
    typedef <i>implementation-defined</i> size_type;
    typedef <i>implementation-defined</i> difference_type;

    [&hellip;]
  };
}
</pre></blockquote>
</li>

</ul>






</body>
</html>
