<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 891: std::thread, std::call_once issue</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-12-02 at 05:12:32 UTC</p>
<hr>
<h3><a name="891" href="891">891.</a> <tt>std::thread</tt>, <tt>std::call_once</tt> issue</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr], 30.4.4.2 [thread.once.callonce] <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I notice that the vararg overloads of <tt>std::thread</tt> and <tt>std::call_once</tt>
(N2723 30.3.1.2 [thread.thread.constr] and 30.4.4.2 [thread.once.callonce]) are no longer specified in terms of
<tt>std::bind</tt>; instead, some of the <tt>std::bind</tt> wording has been inlined into
the specification.
</p>
<p>
There are two problems with this.
</p>
<p>
First, the specification (and implementation) in terms of <tt>std::bind</tt> allows, for example:
</p>

<blockquote><pre>
std::thread th( f, 1, std::bind( g ) );
</pre></blockquote>

<p>
which executes <tt>f( 1, g() )</tt> in a thread. This can be useful. The
"inlined" formulation changes it to execute <tt>f( 1, bind(g) )</tt> in a thread.
</p>
<p>
Second, assuming that we don't want the above, the specification has copied the wording
</p>

<blockquote><p>
<tt>INVOKE(func, w1, w2, ..., wN)</tt> (20.6.2) shall be a valid
expression for some values <tt>w1, w2, ..., wN</tt>
</p></blockquote>

<p>
but this is not needed since we know that our argument list is args; it should simply be
</p>

<blockquote><p>
<tt>INVOKE(func, args...)</tt> (20.6.2) shall be a valid expression
</p></blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Move to open.
</p></blockquote>

<p><i>[
Post Summit Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Leave Open. Await decision for thread variadic constructor.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
See proposed wording for <a href="929">929</a> for this, for the formulation
on how to solve this.  <a href="929">929</a> modifies the thread constructor to
have "pass by value" behavior with pass by reference efficiency through the use
of the <tt>decay</tt> trait.  This same formula would be useful for <tt>call_once</tt>.
</p></blockquote>

<p><i>[
2010-02-11 Anthony updates wording.
]</i></p>


<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 postive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Modify 30.4.4.2 [thread.once.callonce] p1-p2 with the following:
</p>

<blockquote><pre>
template&lt;class Callable, class ...Args&gt;
  void call_once(once_flag&amp; flag, Callable<ins>&amp;&amp;</ins> func, Args&amp;&amp;... args);
</pre><blockquote>

<p><ins>
Given a function as follows:
</ins></p>

<blockquote><pre><ins>
template&lt;typename T&gt; typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v)
   { return std::forward&lt;T&gt;(v); }
</ins></pre></blockquote>

<p>
1 <i>Requires:</i> <del>The template parameters</del> <tt>Callable</tt> and each
<tt>Ti</tt> in <tt>Args</tt> shall <del>be <tt>CopyConstructible</tt> if an
lvalue and otherwise</del> <ins>satisfy the</ins> <tt>MoveConstructible</tt> 
<ins>requirements</ins>.
<tt><i>INVOKE</i>(<ins>decay_copy(std::forward&lt;Callable&gt;(</ins>func<ins>)</ins>,
<del>w1, w2, ..., wN</del>
<ins>decay_copy(std::forward&lt;Args&gt;(args))...</ins>)</tt> (20.14.2 [func.require]) 
shall be a valid expression<del> for some values <tt>w1, w2, ..., wN</tt>, where 
<tt>N == sizeof...(Args)</tt></del>.
</p>

<p>
2 <i>Effects:</i> Calls to <tt>call_once</tt> on the same <tt>once_flag</tt>
object are serialized. If there has been a prior effective call to
<tt>call_once</tt> on the same <tt>once_flag</tt> object, the call to
<tt>call_once</tt> returns without invoking <tt>func</tt>. If there has been no
prior effective call to <tt>call_once</tt> on the same <tt>once_flag</tt>
object, <del>the argument <tt>func</tt> (or a copy thereof) is called as if by
invoking <tt>func(args)</tt></del>
<ins><tt><i>INVOKE</i>(decay_copy(std::forward&lt;Callable&gt;(func)),
decay_copy(std::forward&lt;Args&gt;(args))...)</tt> is executed</ins>. The call
to <tt>call_once</tt> is effective if and only if <del><tt>func(args)</tt></del>
<ins><tt><i>INVOKE</i>(decay_copy(std::forward&lt;Callable&gt;(func)),
decay_copy(std::forward&lt;Args&gt;(args))...)</tt></ins> returns without
throwing an exception. If an exception is thrown it is propagated to the caller.
</p>

</blockquote>

</blockquote>







</body>
</html>
