<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 2451: [fund.ts.v2] optional&lt;T&gt; should 'forward' T's implicit conversions</title>
<meta property="og:title" content="Issue 2451: [fund.ts.v2] optional&lt;T&gt; should 'forward' T's implicit conversions">
<meta property="og:description" content="C++ library issue. Status: TS">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/2451.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="2451"><a href="lwg-defects.html#2451">2451</a>. [fund.ts.v2] <code>optional&lt;T&gt;</code> should 'forward' <code>T</code>'s implicit conversions</h3>
<p><b>Section:</b> 5.3 [fund.ts.v2::optional.object] <b>Status:</b> <a href="lwg-active.html#TS">TS</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2014-10-31 <b>Last modified:</b> 2018-07-08</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::optional.object">issues</a> in [fund.ts.v2::optional.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#TS">TS</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
Code such as the following is currently ill-formed (thanks to STL for the compelling example):
</p>
<blockquote><pre>
optional&lt;string&gt; opt_str = "meow";
</pre></blockquote>
<p>
This is because it would require two user-defined conversions (from <code>const char*</code> to <code>string</code>, 
and from <code>string</code> to <code>optional&lt;string&gt;</code>) where the language permits only one. This is 
likely to be a surprise and an inconvenience for users.
<p/>
<code>optional&lt;T&gt;</code> should be implicitly convertible from any <code>U</code> that is implicitly convertible 
to <code>T</code>. This can be implemented as a non-explicit constructor template <code>optional(U&amp;&amp;)</code>, 
which is enabled via SFINAE only if <code>is_convertible_v&lt;U, T&gt;</code> and <code>is_constructible_v&lt;T, U&gt;</code>, 
plus any additional conditions needed to avoid ambiguity with other constructors (see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4064.html">N4064</a>, particularly the 
"Odd" example, for why <code>is_convertible</code> and <code>is_constructible</code> are both needed; thanks to Howard 
Hinnant for spotting this). 
<p/>
In addition, we may want to support explicit construction from <code>U</code>, which would mean providing a corresponding 
explicit constructor with a complementary SFINAE condition (this is the single-argument case of the "perfect 
initialization" pattern described in N4064).
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: This has status LEWG, but it should be priority 1, since we cannot ship an IS without this. </p>
<p>TK: We assigned our own priorities to LWG-LEWG issues, but haven't actually processed any issues yet. </p>
<p>MC: This is important.</p>

<p><i>[2016-02-17, Ville comments and provides concrete wording]</i></p>

<p>
I have prototype-implemented this wording in libstdc++. I didn't edit
the copy/move-assignment operator tables into the new
<code>operator=</code> templates that take <code>optional</code>s of a different
type; there's a drafting note that suggests copying them
from the existing tables.
</p>

<p><i>[LEWG: 2016-03, Jacksonville]</i></p>

<p>
Discussion of whether <code>variant</code> supports this. We think it does.
<p/>
Take it for C++17.
<p/>
Unanimous yes.
</p>


<p id="res-2451"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>.
</p>

<ol>
<li><p>Edit 22.5.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt;
class optional
{
public:
  typedef T value_type;
  
  <i>// 5.3.1, Constructors</i>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional&amp;);
  optional(optional&amp;&amp;) noexcept(<i>see below</i>);
  constexpr optional(const T&amp;);
  constexpr optional(T&amp;&amp;);
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);
  <ins>template &lt;class U&gt; constexpr optional(U&amp;&amp;);
  template &lt;class U&gt; constexpr optional(const optional&lt;U&gt;&amp;);
  template &lt;class U&gt; constexpr optional(optional&lt;U&gt;&amp;&amp;);</ins>
  
  [&hellip;]
  
  <i>// 5.3.3, Assignment</i>
  optional&amp; operator=(nullopt_t) noexcept;
  optional&amp; operator=(const optional&amp;);
  optional&amp; operator=(optional&amp;&amp;) noexcept(see below);
  template &lt;class U&gt; optional&amp; operator=(U&amp;&amp;);
  <ins>template &lt;class U&gt; optional&amp; operator=(const optional&lt;U&gt;&amp;);
  template &lt;class U&gt; optional&amp; operator=(optional&lt;U&gt;&amp;&amp;);</ins>
  template &lt;class... Args&gt; void emplace(Args&amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);

  [&hellip;]
  
};
</pre>
</blockquote>

</li>

<li><p>In 5.3.1 [fund.ts.v2::optional.object.ctor], insert new signature specifications after p33:</p>

<blockquote>
<p>
<ins>[<i>Note</i>: The following constructors are conditionally specified as <code>explicit</code>. This is typically 
implemented by declaring two such constructors, of which at most one participates in overload resolution. &mdash; 
<i>end note</i>]</ins>
</p>
<pre>
<ins>template &lt;class U&gt;
constexpr optional(U&amp;&amp; v);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> 
with the expression <code>std::forward&lt;U&gt;(v)</code>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <code>*this</code> contains a value.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <code>T</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor 
    shall be a <code>constexpr</code> constructor. This constructor shall not participate in overload resolution unless 
    <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code> is <code>true</code> and <code>U</code> is not the same type as <code>T</code>.
    The constructor is <code>explicit</code> if and only if <code>is_convertible_v&lt;U&amp;&amp;, T&gt;</code> is <code>false</code>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
constexpr optional(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: If <code>rhs</code> contains a value, initializes the contained value as if direct-non-list-initializing 
an object of type <code>T</code> with the expression <code>*rhs</code>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <code>bool(rhs) == bool(*this)</code>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <code>T</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall 
be a <code>constexpr</code> constructor. This constructor shall not participate in overload resolution unless 
<code>is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code>, <code>is_same&lt;decay_t&lt;U&gt;, T&gt;</code> is 
<code>false</code>, <code>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</code> is <code>false</code> and 
<code>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</code> is <code>false</code>. The constructor is <code>explicit</code> 
if and only if <code>is_convertible_v&lt;const U&amp;, T&gt;</code> is <code>false</code>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
constexpr optional(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: If <code>rhs</code> contains a value, initializes the contained value as if 
direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*rhs)</code>. 
<code>bool(rhs)</code> is unchanged.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <code>bool(rhs) == bool(*this)</code>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <code>T</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor 
shall be a <code>constexpr</code> constructor. This constructor shall not participate in overload resolution unless 
<code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code> is <code>true</code>, <code>is_same&lt;decay_t&lt;U&gt;, T&gt;</code> is 
<code>false</code>, <code>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</code> is <code>false</code> and 
<code>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</code> is <code>false</code> and <code>U</code> is not the same type 
as <code>T</code>. The constructor is <code>explicit</code> if and only if <code>is_convertible_v&lt;U&amp;&amp;, T&gt;</code>
is <code>false</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 5.3.3 [fund.ts.v2::optional.object.assign], change as indicated:</p>

<blockquote>
<pre>
template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-22- <i>Remarks:</i> If any exception is thrown, the result of the expression <code>bool(*this)</code> remains unchanged. 
If an exception is thrown during the call to <code>T</code>'s constructor, the state of <code>v</code> is determined by the 
exception safety guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s 
assignment, the state of <code>*val</code> and <code>v</code> is determined by the exception safety guarantee of <code>T</code>'s 
assignment. The function shall not participate in overload resolution unless 
<ins><ins><code>decay_t&lt;U&gt;</code> is not <code>nullopt_t</code> and <code>decay_t&lt;U&gt;</code> is not a specialization of 
<code>optional</code></ins></ins><del><code>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</code> is <code>true</code></del>.
<p/>
<del>-23- <i>Notes</i>: The reason for providing such generic assignment and then constraining it so that effectively 
<code>T == U</code> is to guarantee that assignment of the form <code>o = {}</code> is unambiguous.</del>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <code>is_constructible_v&lt;T, const U&amp;&gt;</code> is <code>true</code> and 
<code>is_assignable_v&lt;T&amp;, const U&amp;&gt;</code> is <code>true</code>.</ins>
<p/>
<ins>-?- <i>Effects</i>:</ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <code>optional::operator=(const optional&lt;U&gt;&amp;)</code> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><code>*this</code> contains a value</b></ins></th>
<th><ins><b><code>*this</code> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><code>rhs</code> contains a value</b></ins></td>
<td><ins>assigns <code>*rhs</code> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<code>T</code> with <code>*rhs</code></ins></td>
</tr>

<tr>
<td><ins><b><code>rhs</code> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <code>val-&gt;T::~T()</code></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <code>*this</code>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <code>bool(rhs) == bool(*this)</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <code>bool(*this)</code> remains unchanged. 
If an exception is thrown during the call to <code>T</code>'s constructor, the state of <code>*rhs.val</code> is determined by the 
exception safety guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s assignment, 
the state of <code>*val</code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s assignment. 
The function shall not participate in overload resolution unless <code>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</code> is 
<code>false</code>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <code>is_constructible_v&lt;T, U&gt;</code> is <code>true</code> and 
<code>is_assignable_v&lt;T&amp;, U&gt;</code> is <code>true</code>.</ins>
<p/>
<ins>-?- <i>Effects</i>: The result of the expression <code>bool(rhs)</code> remains unchanged. </ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <code>optional::operator=(optional&lt;U&gt;&amp;&amp;)</code> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><code>*this</code> contains a value</b></ins></th>
<th><ins><b><code>*this</code> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><code>rhs</code> contains a value</b></ins></td>
<td><ins>assigns <code>std::move(*rhs)</code> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<code>T</code> with <code>std::move(*rhs)</code></ins></td>
</tr>

<tr>
<td><ins><b><code>rhs</code> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <code>val-&gt;T::~T()</code></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <code>*this</code>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <code>bool(rhs) == bool(*this)</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <code>bool(*this)</code> remains unchanged. 
If an exception is thrown during the call to <code>T</code>'s constructor, the state of <code>*rhs.val</code> is determined by the 
exception safety guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s 
assignment, the state of <code>*val</code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s 
assignment. The function shall not participate in overload resolution unless
<code>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</code> is <code>false</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






</body>
</html>
