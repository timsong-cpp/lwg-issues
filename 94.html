<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 94: May library implementors add template parameters to Standard Library classes?</title>
<meta property="og:title" content="Issue 94: May library implementors add template parameters to Standard Library classes?">
<meta property="og:description" content="C++ library issue. Status: NAD">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/94.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="94"><a href="lwg-closed.html#94">94</a>. May library implementors add template parameters to Standard Library classes?</h3>
<p><b>Section:</b> 16.4.6 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-01-22 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#conforming">issues</a> in [conforming].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Is it a permitted extension for library implementors to add template parameters to
standard library classes, provided that those extra parameters have defaults? For example,
instead of defining <code>template &lt;class T, class Alloc = allocator&lt;T&gt; &gt; class
vector;</code> defining it as <code>template &lt;class T, class Alloc = allocator&lt;T&gt;,
int N = 1&gt; class vector;</code> </p>

<p>The standard may well already allow this (I can't think of any way that this extension
could break a conforming program, considering that users are not permitted to
forward-declare standard library components), but it ought to be explicitly permitted or
forbidden. </p>

<p>comment from Steve Cleary via comp.std.c++:</p>
<blockquote>
<p>I disagree [with the proposed resolution] for the following reason:
consider user library code with template template parameters. For
example, a user library object may be templated on the type of
underlying sequence storage to use (deque/list/vector), since these
classes all take the same number and type of template parameters; this
would allow the user to determine the performance tradeoffs of the
user library object. A similar example is a user library object
templated on the type of underlying set storage (set/multiset) or map
storage (map/multimap), which would allow users to change (within
reason) the semantic meanings of operations on that object.</p>
<p>I think that additional template parameters should be forbidden in
the Standard classes. Library writers don't lose any expressive power,
and can still offer extensions because additional template parameters
may be provided by a non-Standard implementation class:</p>
<pre> 
   template &lt;class T, class Allocator = allocator&lt;T&gt;, int N = 1&gt;
   class __vector
   { ... };
   template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
   class vector: public __vector&lt;T, Allocator&gt;
   { ... };
</pre>

</blockquote>



<p id="res-94"><b>Proposed resolution:</b></p>
<p>Add a new subclause [presumably 17.4.4.9] following 16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>:</p>

<blockquote>
  <p>17.4.4.9 Template Parameters</p> <p>A specialization of a
  template class described in the C++ Standard Library behaves the
  same as if the implementation declares no additional template
  parameters.</p> <p>Footnote: Additional template parameters with
  default values are thus permitted.</p>
</blockquote>

<p>Add &quot;template parameters&quot; to the list of subclauses at
the end of 16.4.6 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> paragraph 1.</p>

<p><i>[Kona: The LWG agreed the standard needs clarification. After
discussion with John Spicer, it seems added template parameters can be
detected by a program using template-template parameters. A straw vote
- &quot;should implementors be allowed to add template
parameters?&quot; found no consensus ; 5 - yes, 7 - no.]</i></p>




<p><b>Rationale:</b></p>
<p>
There is no ambiguity; the standard is clear as written.  Library
implementors are not permitted to add template parameters to standard
library classes.  This does not fall under the &quot;as if&quot; rule,
so it would be permitted only if the standard gave explicit license
for implementors to do this.  This would require a change in the 
standard.
</p>

<p>
The LWG decided against making this change, because it would break
user code involving template template parameters or specializations
of standard library class templates.
</p>





</body>
</html>
