<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 1459: Overlapping evaluations are allowed</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="1459" href="#1459">1459.</a> Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-11-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1458">1458</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-21, GB-131</b></p>
<p>
29.4 [atomics.lockfree] p.8 states:
</p>
<blockquote><p>
An atomic store shall only store a value that has
been computed from constants and program input values
by a finite sequence of program evaluations, such
that each evaluation observes the values of variables
as computed by the last prior assignment in the
sequence.
</p></blockquote>
<p>
... but 1.9 [intro.execution] p.13 states:
</p>
<blockquote><p>
If A is not sequenced before B and B is not
sequenced before A, then A and B are unsequenced.
[ <em>Note</em>: The execution of unsequenced
evaluations can overlap. &mdash; <em>end note</em> ]
</p></blockquote>
<p>
Overlapping executions can make it impossible to
construct the sequence described in 29.4 [atomics.lockfree] p.8. We are not
sure of the intention here and do not offer a suggestion for
change, but note that 29.4 [atomics.lockfree] p.8 is the condition that prevents
out-of-thin-air reads.
</p>
<p>
For an example, suppose we have a function invocation
f(e1,e2). The evaluations of e1 and e2 can overlap.
Suppose that the evaluation of e1 writes y and reads x
whereas the evaluation of e2 reads y and writes x, with
reads-from edges as below (all this is within a single
thread).
</p>
<pre>
 e1           e2
Wrlx y--   --Wrlx x
      rf\ /rf
         X
        / \
Rrlx x&lt;-   -&gt;Rrlx y
</pre>
<p>
This seems like it should be allowed, but there seems to
be no way to produce a sequence of evaluations with the
property above.
</p>
<p>
In more detail, here the two evaluations, e1 and e2, are
being executed as the arguments of a function and are
consequently not sequenced-before each other. In
practice we'd expect that they could overlap (as allowed
by 1.9 [intro.execution] p.13), with the two writes taking effect before the two
reads. However, if we have to construct a linear order of
evaluations, as in 29.4 [atomics.lockfree] p.8, then the execution above is not
permited. Is that really intended?
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Please clarify.
</p>

<p><i>[2011-03-09 Hans comments:]</i></p>


<p>I'm not proud of 29.3 [atomics.order] p9 (formerly p8), and I agree with the comments that this
isn't entirely satisfactory. 29.3 [atomics.order] p9 was designed to preclude
out-of-thin-air results for races among <tt>memory_order_relaxed</tt> atomics, in spite of 
the fact that Java experience has shown we don't really know how to do that adequately. In 
the long run, we probably want to revisit this.
<p/>
However, in the short term, I'm still inclined to declare this NAD, for two separate reasons:
</p>

<ol>
<li><p>1.9 [intro.execution] p15 states: "If a side effect on a scalar
object is unsequenced relative to either another side
effect on the same scalar object or a value computation
using the value of the same scalar object, the behavior is undefined."
I think the examples presented here have undefined behavior as a result.
It's not completely clear to me whether examples can be constructed
that exhibit this problem, and don't have undefined behavior.</p></li>

<li><p>This comment seems to be using a different meaning of "evaluation"
from what is used elsewhere in the standard. The sequence of evaluations
here doesn't have to consist of full expression evaluations.  They
can be evaluations of operations like lvalue to rvalue conversion,
or individual assignments. In particular, the reads and writes
executed by <tt>e1</tt> and <tt>e2</tt> in the example could be treated as separate
evaluations for purposes of producing the sequence.
The definition of "sequenced before" in 1.9 [intro.execution] makes
little sense if the term "evaluation" is restricted to any notion
of complete expression. Perhaps we should add yet another note
to clarify this?  29.3 [atomics.order] p10 probably leads to 
the wrong impression here.
<p/>
An alternative resolution would be to simply delete our flakey
attempt at preventing out-of-thin-air reads, by removing 29.3 [atomics.order] p9-11,
possibly adding a note that explains that we technically allow,
but strongly discourage them. If we were starting this from scratch
now, that would probably be my preference.  But it seems like too drastic
a resolution at this stage.
</p></li>
</ol>

<p><i>[2011-03-24 Madrid]</i></p>

<p>
Moved to NAD Future
</p>



<p><b>Proposed resolution:</b></p>





</body>
</html>
