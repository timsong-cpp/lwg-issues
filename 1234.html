<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 1234: "Do the right thing" and NULL</title>
<meta property="og:title" content="Issue 1234: &quot;Do the right thing&quot; and NULL">
<meta property="og:description" content="C++ library issue. Status: C++11">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/1234.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="1234"><a href="lwg-defects.html#1234">1234</a>. "Do the right thing" and <code>NULL</code></h3>
<p><b>Section:</b> 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-10-09 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<p>
On g++ 4.2.4 (x86_64-linux-gnu), the following file gives a compile error:
</p>

<blockquote><pre>
#include &lt;vector&gt;
void foo() { std::vector&lt;int*&gt; v(500L, NULL); }
</pre></blockquote>

<p>
Is this supposed to work? 
</p>

<p>
The issue: if <code>NULL</code> happens to be defined as <code>0L</code>, this is an invocation of
the constructor with two arguments of the same integral type.
23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>/14
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3035.pdf">N3035</a>)
says that this will behave as if the overloaded constructor
</p>

<blockquote><pre>
X(size_type, const value_type&amp; = value_type(),
  const allocator_type&amp; = allocator_type())
</pre></blockquote>

<p>
were called instead, with the arguments
<code>static_cast&lt;size_type&gt;(first)</code>, <code>last</code> and
<code>alloc</code>, respectively. However, it does not say whether this
actually means invoking that constructor with the exact textual form of
the arguments as supplied by the user, or whether the standard permits
an implementation to invoke that constructor with variables of the same
type and value as what the user passed in. In most cases this is a
distinction without a difference. In this particular case it does make a
difference, since one of those things is a null pointer constant and the
other is not.
</p>

<p>
Note that an implementation based on forwarding functions will use the
latter interpretation.
</p>

<p><i>[
2010 Pittsburgh:  Moved to Open.
]</i></p>


<p><i>[
2010-03-19 Daniel provides wording.
]</i></p>


<blockquote>
<ul>
<li>
Adapts the numbering used in the discussion to the recent working paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3035.pdf">N3035</a>.
</li>

<li>
Proposes a resolution that requires implementations to use sfinae-like means to
possibly filter away the too generic template c'tor. In fact this resolution is
equivalent to that used for the <code>pair-NULL</code> problem (<a href="811" title="pair of pointers no longer works with literal 0 (Status: C++11)">811</a>),
the only difference is, that issue 1234 was already a C++03 problem.
</li>
</ul>

<p>
This issue can be considered as a refinement of <a href="438" title="Ambiguity in the &quot;do the right thing&quot; clause (Status: CD1)">438</a>.
</p>

</blockquote>

<p><i>[
Post-Rapperswil
]</i></p>


<p>
Wording was verified to match with the most recent WP. Jonathan Wakely and Alberto Barbati observed that the current 
WP has a defect that should be fixed here as well: The functions signatures <code>fx1</code> and <code>fx3</code> are 
incorrectly referring to <code>iterator</code> instead of <code>const_iterator</code>.
</p>

<blockquote><p>
Moved to Tentatively Ready with revised wording after 7 positive votes on c++std-lib.
</p></blockquote>

<p><i>[
Adopted at 2010-11 Batavia
]</i></p>




<p id="res-1234"><b>Proposed resolution:</b></p>

 
<p>
Change 23.2.3 [sequence.reqmts]/14+15 as indicated:
</p>

<blockquote>
<p>
14 For every sequence container defined in this Clause and in Clause 21:
</p>

<ul>
<li>
<p>
If the constructor
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
X(InputIterator first, InputIterator last,
  const allocator_type&amp; alloc = allocator_type())
</pre></blockquote>

<p>
is called with a type <code>InputIterator</code> that does not qualify as an input
iterator, then the constructor <ins>shall not participate in overload
resolution.</ins><del>will behave as if the overloaded constructor:</del>
</p>

<blockquote><pre><del>
X(size_type, const value_type&amp; = value_type(),
  const allocator_type&amp; = allocator_type())
</del></pre></blockquote>

<p>
<del>were called instead, with the arguments <code>static_cast&lt;size_type&gt;(first)</code>, 
<code>last</code> and <code>alloc</code>, respectively</del>.
</p>
</li>

<li>

<p>
If the member functions of the forms:
</p>

<blockquote><pre>
template &lt;class InputIterator&gt; <i>// such as insert()</i>
rt fx1(<ins>const_</ins>iterator p, InputIterator first, InputIterator last);

template &lt;class InputIterator&gt; <i>// such as append(), assign()</i>
rt fx2(InputIterator first, InputIterator last);

template &lt;class InputIterator&gt; <i>// such as replace()</i>
rt fx3(<ins>const_</ins>iterator i1, <ins>const_</ins>iterator i2, InputIterator first, InputIterator last);
</pre></blockquote>

<p>
are called with a type <code>InputIterator</code> that does not qualify as an input
iterator, then these functions <ins>shall not participate in overload
resolution.</ins><del>will behave as if the overloaded member functions:</del>
</p>

<blockquote><pre>
<del>rt fx1(iterator, size_type, const value_type&amp;);</del>

<del>rt fx2(size_type, const value_type&amp;);</del>

<del>rt fx3(iterator, iterator, size_type, const value_type&amp;);</del>
</pre></blockquote>

<p>
<del>were called instead, with the same arguments.</del>
</p>
</li>

</ul>

<p><del>
15 In the previous paragraph the alternative binding will fail if <code>first</code>
is not implicitly convertible to <code>X::size_type</code> or if <code>last</code> is
not implicitly convertible to <code>X::value_type</code>.
</del></p>
</blockquote>






</body>
</html>
