<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 1202: integral_constant needs a spring clean</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-23 at 07:11:07 UTC</p>
<hr>
<h3><a name="1202" href="1202">1202.</a> <tt>integral_constant</tt> needs a spring clean</h3>
<p><b>Section:</b> 20.15.3 [meta.help] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>integral_constant</tt> has been inherited
essentially unchanged from TR1:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  static const T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
};
</pre></blockquote>

<p>
In light of 0x language changes there are several things we might
consider changing, notably the form of specification for value.
</p>

<p>
The current form requires a static data member have storage allocated
for it, where we could now implement without this using the new enum
syntax:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  <b>enum : T { value = v };</b>
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
The effective difference between these two implementation is:
</p>

<ol style="list-style-type:lower-roman">
<li>
No requirement to allocate storage for data member (which we hope but do
not guarantee compilers strip today)
</li>

<li>
You can no longer take the address of the constant as
<tt>&amp;integral_constant&lt;T,v&gt;::value;</tt>
</li>
</ol>

<p>
Also note the editorial change to drop the explicit qualification of
<tt>integral_constant</tt> in the <tt>typedef type</tt>.  This makes it quite clear we
mean the current instantiation, and cannot be mistaken for a recursive
metaprogram.
</p>

<p>
Even if we don't mandate this implementation, it would be nice to give
vendors freedom under QoI to choose their preferred representation.
</p>

<p>
The other side of this issue is if we choose to retain the static
constant form.  In that case we should go further and insist on
<tt>constexpr</tt>, much like we did throughout <tt>numeric_limits</tt>:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  static <b>constexpr</b> T value = v;
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
[Footnote] It turns out <tt>constexpr</tt> is part of the Tentatively Ready
resolution for <a href="1019">1019</a>.  I don't want to interfere with that issue, but
would like a new issue to consider if the fixed-base enum implementation
should be allowed.
</p>

<p><i>[
2009-09-05 Daniel adds:
]</i></p>


<blockquote>
<p>
I think that the suggested resolution is incomplete and
may have some possible unwanted side-effects. To understand
why, note that <tt>integral_constant</tt> is <em>completely</em> specified
by code in 20.15.3 [meta.help]. While this is usually considered
as a good thing, let me give a possible user-defined
specialization that would break given the suggested changes:
</p>

<blockquote><pre>
enum NodeColor { Red, Black };

std::integral_constant&lt;NodeColor, Red&gt; red;
</pre></blockquote>

<p>
The reason why that breaks is due to the fact that
current core language rules does only allow integral
types as enum-bases, see 7.2 [dcl.enum]/2.
</p>

<p>
So, I think that we cannot leave the implementation the
freedom to decide which way they would like to provide
the implementation, because that is easily user-visible
(I don't speak of addresses, but of instantiation errors),
therefore if applied, this should be either specified or
wording must be added that gives a note about this
freedom of implementation.
</p>

<p>
Another possible disadvantage seems to me that user-expectations
are easy to disappoint if they see a failure
of the test
</p>

<blockquote><pre>
assert(typeid(std::integral_constant&lt;int, 0&gt;::value) == typeid(int));
</pre></blockquote>

<p>
or of
</p>

<blockquote><pre>
static_assert(std::is_same&lt;decltype(std::integral_constant&lt;int, 0&gt;::value), const int&gt;::value, "Bad library");
</pre></blockquote>

</blockquote>

<p><i>[
2010-01-14 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>
<p>
We think that the suggested resolution is incomplete and may have some possible
unwanted side-effects.  (see Daniel's 2009-09-05 comment for details).
</p>


<p><b>Proposed resolution:</b></p>





</body>
</html>
