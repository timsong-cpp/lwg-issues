<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 1202: integral_constant needs a spring clean</title>
<meta property="og:title" content="Issue 1202: integral_constant needs a spring clean">
<meta property="og:description" content="C++ library issue. Status: NAD">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/1202.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="1202"><a href="lwg-closed.html#1202">1202</a>. <code>integral_constant</code> needs a spring clean</h3>
<p><b>Section:</b> 21.3.4 <a href="https://timsong-cpp.github.io/cppwp/meta.help">[meta.help]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>integral_constant</code> has been inherited
essentially unchanged from TR1:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  static const T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
};
</pre></blockquote>

<p>
In light of 0x language changes there are several things we might
consider changing, notably the form of specification for value.
</p>

<p>
The current form requires a static data member have storage allocated
for it, where we could now implement without this using the new enum
syntax:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  <b>enum : T { value = v };</b>
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
The effective difference between these two implementation is:
</p>

<ol style="list-style-type:lower-roman">
<li>
No requirement to allocate storage for data member (which we hope but do
not guarantee compilers strip today)
</li>

<li>
You can no longer take the address of the constant as
<code>&amp;integral_constant&lt;T,v&gt;::value;</code>
</li>
</ol>

<p>
Also note the editorial change to drop the explicit qualification of
<code>integral_constant</code> in the <code>typedef type</code>.  This makes it quite clear we
mean the current instantiation, and cannot be mistaken for a recursive
metaprogram.
</p>

<p>
Even if we don't mandate this implementation, it would be nice to give
vendors freedom under QoI to choose their preferred representation.
</p>

<p>
The other side of this issue is if we choose to retain the static
constant form.  In that case we should go further and insist on
<code>constexpr</code>, much like we did throughout <code>numeric_limits</code>:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  static <b>constexpr</b> T value = v;
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
[Footnote] It turns out <code>constexpr</code> is part of the Tentatively Ready
resolution for <a href="1019" title="Make integral_constant objects useable in integral-constant-expressions (Status: C++11)">1019</a>.  I don't want to interfere with that issue, but
would like a new issue to consider if the fixed-base enum implementation
should be allowed.
</p>

<p><i>[
2009-09-05 Daniel adds:
]</i></p>


<blockquote>
<p>
I think that the suggested resolution is incomplete and
may have some possible unwanted side-effects. To understand
why, note that <code>integral_constant</code> is <em>completely</em> specified
by code in 21.3.4 <a href="https://timsong-cpp.github.io/cppwp/meta.help">[meta.help]</a>. While this is usually considered
as a good thing, let me give a possible user-defined
specialization that would break given the suggested changes:
</p>

<blockquote><pre>
enum NodeColor { Red, Black };

std::integral_constant&lt;NodeColor, Red&gt; red;
</pre></blockquote>

<p>
The reason why that breaks is due to the fact that
current core language rules does only allow integral
types as enum-bases, see 9.7.1 <a href="https://timsong-cpp.github.io/cppwp/dcl.enum">[dcl.enum]</a>/2.
</p>

<p>
So, I think that we cannot leave the implementation the
freedom to decide which way they would like to provide
the implementation, because that is easily user-visible
(I don't speak of addresses, but of instantiation errors),
therefore if applied, this should be either specified or
wording must be added that gives a note about this
freedom of implementation.
</p>

<p>
Another possible disadvantage seems to me that user-expectations
are easy to disappoint if they see a failure
of the test
</p>

<blockquote><pre>
assert(typeid(std::integral_constant&lt;int, 0&gt;::value) == typeid(int));
</pre></blockquote>

<p>
or of
</p>

<blockquote><pre>
static_assert(std::is_same&lt;decltype(std::integral_constant&lt;int, 0&gt;::value), const int&gt;::value, "Bad library");
</pre></blockquote>

</blockquote>

<p><i>[
2010-01-14 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>
<p>
We think that the suggested resolution is incomplete and may have some possible
unwanted side-effects.  (see Daniel's 2009-09-05 comment for details).
</p>


<p id="res-1202"><b>Proposed resolution:</b></p>





</body>
</html>
