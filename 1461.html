<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 1461: Rename all ATOMIC_* macros as STD_ATOMIC_*</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="1461" href="1461">1461.</a> Rename all <tt>ATOMIC_*</tt> macros as <tt>STD_ATOMIC_*</tt></h3>
<p><b>Section:</b> 29 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-1</b></p>
<p>
All <tt>ATOMIC_</tt>... macros should be prefixed with <tt>STD_</tt> as
in <tt>STD_ATOMIC_</tt>... to indicate they are <tt>STD</tt> macros as
other standard macros. The rationale that they all seem too long seems weak.
</p>

<p><i>[2011-03-06: Daniel adapts suggested wording to N3242 and comments]</i></p>


<p>I suggest to declare this issue as NAD. Reason for this suggestion is, that
C1x is currently going to suggest exactly the same macros as additions to
header <tt>&lt;stdatomic.h&gt;</tt>, therefore C++0x should not define a
whole new set. I'm making this suggestion with the understanding that
C1x is intending to keep in sync in this regard. For example, the most
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf">recent 
draft of C1x</a> does contain the macro <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>
which has recently been removed from the C++ working draft.</p>

<p><i>[2011-03-24]</i></p>

<p><b>Rationale:</b></p><p>
C is not going to change the name of these macros, and it is
important they have the same name for compatibility
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Change sub-clause 29.2 [atomics.syn] as indicated:</p>
<blockquote><pre>
[..]
// <em>[atomics.lockfree], lock-free property</em>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>unspecified</em>

// <em>[atomics.types.operations.req], operations on atomic types</em>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
[..]
</pre></blockquote>
</li>
<li>
<p>Change 29.4 [atomics.lockfree] p. 1 as indicated:</p>
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>implementation-defined</em>
</pre><blockquote>
<p>
1 The <tt><ins>STD_</ins>ATOMIC_..._LOCK_FREE</tt> macros indicate the lock-free property of the corresponding atomic types, [..]
</p></blockquote></blockquote>
</li>
<li>
<p>Change 29.6.5 [atomics.types.operations.req] p. 6 as indicated:</p>
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
</pre><blockquote><p>
5 <em>Remarks</em>: The macro expands to a token sequence suitable for constant initialization 
an atomic variable of static storage duration of a type that is initialization-compatible
with <i>value</i>. [ <i>Note</i>: This operation may need to initialize locks. &mdash; <i>end note</i> ] 
Concurrent access to the variable being initialized, even via an atomic operation, constitutes 
a data race. [ <em>Example:</em>
</p><blockquote><pre>
atomic&lt;int&gt; v = <ins>STD_</ins>ATOMIC_VAR_INIT(5);
</pre></blockquote>
<p>&mdash; <em>end example</em> ]</p>
</blockquote></blockquote>
</li>
<li>
<p>Change 29.7 [atomics.flag] p. 1+4 as indicated:</p>
<blockquote><pre>
namespace std {
  [..]
  #define <ins>STD_</ins>ATOMIC_FLAG_INIT <em>see below</em>
}
</pre><blockquote><p>
[..]
4 The macro <tt><ins>STD_</ins>ATOMIC_FLAG_INIT</tt> shall be defined in such a way that it can be used to initialize an object of
type <tt>atomic_flag</tt> to the clear state. For a static-duration object, that initialization shall be static. It is
unspecified whether an unitialized <tt>atomic_flag</tt> object has an initial state of set or clear. [ <em>Example:</em>
</p><blockquote><pre>
atomic_flag guard = <ins>STD_</ins>ATOMIC_FLAG_INIT;
</pre></blockquote>
<p>&mdash; <em>end example</em> ]</p>
</blockquote></blockquote>
</li>
</ol>





</body>
</html>
