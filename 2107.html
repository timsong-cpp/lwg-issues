<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 2107: Some iterator category should guarantee the lifetime of references</title>
<meta property="og:title" content="Issue 2107: Some iterator category should guarantee the lifetime of references">
<meta property="og:description" content="C++ library issue. Status: NAD">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/2107.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="2107"><a href="lwg-closed.html#2107">2107</a>. Some iterator category should guarantee the lifetime of references</h3>
<p><b>Section:</b> 24.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2011-11-21 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Many iterators guarantee that references and pointers returned from
their methods will outlive the iterator itself. Other useful iterators
can't guarantee this, leading to the rule in 24.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> 
p9 that "Destruction of an iterator may invalidate pointers and references 
previously obtained from that iterator."
<p/>
Some algorithms can take advantage of long-lived references by
returning them, while they can adapt to short-lived references by
returning by value instead. However, there doesn't seem to be a way in
the standard to distinguish between these two types of iterators.
<p/>
The <code>ForwardIterator</code> requirements come close by saying "If <code>a</code> and <code>b</code> are
both dereferenceable, then <code>a == b</code> if and only if <code>*a</code> and <code>*b</code> are bound
to the same object." (24.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> p6) However, there are some
subtle ways to satisfy this rule and still return a short-lived reference, meaning 
algorithms can't be guaranteed that <code>forward_iterator_tag</code> will imply 
long-lived references.
<p/>
On the other hand, defect <a href="198" title="Validity of pointers and references unspecified after iterator destruction (Status: CD1)">198</a>, which added the invalidation wording
to iterator.requirements.general, refers to iterators with short-lived references 
being used as arguments to reverse_iterator, which requires <code>BidirectionalIterator</code>s. 
If <code>ForwardIterator</code> required long-lived references, this would be impossible.
<p/>
Either <code>ForwardIterator</code> should be clarified to require long-lived
references, or a new category should be added that does.
<p/>
See also the discussion around c++std-lib-31477.
<p/>
Daniel: Related to this issue is that when applying <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
we unintentionally lost some forward iterator requirements from C++03, where we 
had the post-conditions <code>a == X(a)</code> of <code>X(a)</code>, and <code>u == a</code> 
of any copy operation from <code>a</code> to <code>u</code>. This wording must be restored as well.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to NAD.
</p>
<p>
This issue affects only Input Iterators, as all other categories are required to return
a native reference, and are not (currently) allowed to return proxies.  The issue with
Input Iterators is known, and has been present since the original standard.  Any change
in this regard would be an extension requiring a more substantial paper than treatment
as a simple issue.
</p>



<p id="res-2107"><b>Proposed resolution:</b></p>





</body>
</html>
