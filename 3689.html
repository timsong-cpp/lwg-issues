<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3689: num_get overflow determination unclear and incorrect</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3><a name="3689" href="lwg-active.html#3689">3689.</a> <tt>num_get</tt> overflow determination unclear and incorrect</h3>
<p><b>Section:</b> 30.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2022-03-28 <b>Last modified:</b> 2022-05-17 11:58:16 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> stage 3 specifies that "by the rules of" various <tt>strto*</tt> functions, 
sequences of chars are converted to a numeric value (producing the "converted value" that is referred to).
<p/>
It then goes on to specify various error cases when the "field represents a value" that is outside the range 
of representable values. Clearly, the value that would be returned from the appropriate <tt>strto*</tt> function 
is not outside the range of representable values for <tt>long long</tt>, <tt>unsigned long long</tt>, <tt>float</tt>, 
<tt>double</tt>, and <tt>long double</tt>; therefore (unless if we expect no range-related errors for those types), 
the field "represents a value" other than the "converted value".
<p/>
Issue 1: It is too subtle to have two distinct values without calling more attention to them by giving them names 
aside from the prose descriptions.
<p/>
If the field "represents" a value other than the value that would be returned from the appropriate <tt>strto*</tt> 
function, then what value does the field "represent"?
Note that, strictly speaking, it is the process that results in the converted value that the wording says is obtained 
"by the rules of" the <tt>strto*</tt> functions, which is not the same thing as saying that the value represented is 
interpreted "by the rules of" the <tt>strto*</tt> functions.
<p/>
If the field "represents" the mathematical value, then for unsigned integer types, all negative values cannot be 
represented. This does not match existing practice.
<p/>
If negative integer values are interpreted using the rules of the <tt>strto*</tt> functions by obtaining the 
magnitude and then having it "negated (in the return type)", then the return type of <tt>strtoull</tt> is 
<tt>unsigned long long</tt>, meaning (where <tt>unsigned long long</tt> is 64-bit) that "<tt>-18446744073709551615</tt>" 
is <tt>1</tt> (even when converting to unsigned integer types of less width). That does not match existing practice.
It is also worth noting that negating in the return type does not work well if the magnitude is not representable as 
a positive value in the return type (e.g., for signed integer types and their most negative representable values).
<p/>
Issue 2: The effect of the minus sign with respect to unsigned integer types can reasonably be interpreted in ways 
that do not match existing practice (and are presumably unintended). The interpretation that works better for 
<tt>unsigned long long</tt> does not work as well for <tt>signed long long</tt>.
<p/>
If the field does not "represent" the mathematical value, then for floating-point types, it is unclear whether 
the minus sign takes effect before or after any possible rounding. For literals, the minus sign takes effect after 
rounding.
<p/>
Issue 3: The effect of the minus sign with respect to floating-point types is unclear.
<p/>
Lastly, for floating-point types with signed infinities, there are no finite values outside the range of 
representable values; therefore, conversions of all finite values to such types are specified to "succeed". That 
does not match existing implementation practice.
<p/>
Issue 4: The conditions for identifying range-related errors for conversions to floating-point types do not match 
the conditions that constitute overflow for floating-point types. There is implementation divergence: libc++ appears 
to check for floating-point overflow; libstdc++ appears to check for infinities.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3689"><b>Proposed resolution:</b></p>





</body>
</html>
