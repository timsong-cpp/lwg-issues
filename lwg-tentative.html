<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p><p>Revised 2022-11-10 at 18:27:31 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2116" href="2116">2116.</a> <tt>is_nothrow_constructible</tt> and destructors</h3>
<p><b>Section:</b> 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2022-10-10 10:13:01 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
IMO if we specified <tt>is_[nothrow_]constructible</tt> in terms of a variable
declaration whose validity requires destructibility, it is clearly a bug
in our specification and a failure to realize the actual original
intent. The specification should have been in terms of placement-new.
<p/>
Daniel:<br/>
At the time of the specification this was intended and the solution is
<em>not</em> done by removing the destruction semantics of <tt>is_constructible</tt>.
<p/>
The design of <tt>is_constructible</tt> was also impacted by the previous
<tt>Constructible</tt> concept that <em>explicitly</em> contained destruction semantics,
because during conceptification of the library it turned out to simplify
the constraints  in the library because you did not need to add
<tt>Destructible</tt> all the time. It often was implied but never spoken out
in C++03.
<p/>
Pure construction semantics was considered as useful as well, so <tt>HasConstructor</tt>
did also exist and would surely be useful as trait as well.
<p/>
Another example that is often overlooked: This also affects wrapper types like <tt>pair</tt>,
<tt>tuple</tt>, <tt>array</tt> that contain potentially more than one type:
This is easy to understand if you think of <tt>T1</tt> having a deleted destructor
and <tt>T2</tt> having a constructor that may throw: Obviously the compiler has
potentially need to use the <tt>destructor</tt> of <tt>T1</tt> in the <em>constructor</em>
of <tt>std::pair&lt;T1, T2&gt;</tt> to ensure that the core language requirements
are satisfied (All previous fully constructed sub-objects must be destructed).
<p/>
The core language also honors this fact in  [class.copy] p11:
</p>
<blockquote><p>
A defaulted copy&#47;move constructor for a class <tt>X</tt> is defined as deleted (9.5.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.fct.def.delete">[dcl.fct.def.delete]</a>)
if <tt>X</tt> has:<br/>
[&hellip;]<br/>
&mdash; any direct or virtual base class or non-static data member of a type with a destructor that is deleted
or inaccessible from the defaulted constructor,<br/>
[&hellip;]
</p></blockquote>
<p>
Dave:<br/>
This is about <tt>is_nothrow_constructible</tt> in particular. The fact that it is
foiled by not having a <tt>noexcept</tt> dtor is a defect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
<tt>is_nothrow_constructible</tt> is defined in terms of <tt>is_constructible</tt>, which is defined
by looking at a hypothetical variable and asking whether the variable definition is known not to
throw exceptions. The issue claims that this also examines the type's destructor, given the context,
and thus will return <tt>false</tt> if the destructor can potentially throw. At least one
implementation (Howard's) does return <tt>false</tt> if the constructor is <tt>noexcept(true)</tt>
and the destructor is <tt>noexcept(false)</tt>. So that's not a strained interpretation.
The issue is asking for this to be defined in terms of placement <tt>new</tt>, instead of in terms
of a temporary object, to make it clearer that <tt>is_nothrow_constructible</tt> looks at the
<tt>noexcept</tt> status of only the constructor, and not the destructor.
</p>
<p>
Sketch of what the wording would look like:
</p>
<p>
require <tt>is_constructible</tt>, and then also require that a placement <tt>new</tt> operation
does not throw. (Remembering the title of this issue... What does this imply for <tt>swap</tt>?
</p>
<p>
If we accept this resolution, do we need any changes to <tt>swap</tt>?
</p>
<p> STL argues: no, because you are already forbidden from passing anything with a throwing
destructor to <tt>swap</tt>.
</p>
<p>
Dietmar argues: no, not true. Maybe statically the destructor can conceivably throw for some
values, but maybe there are some values known not to throw. In that case, it's correct to
pass those values to <tt>swap</tt>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Gave the issue a better title</p>
<p>This issue interacts with <a href="2827">2827</a></p>
<p>Ville would like "an evolution group" to take a look at this issue.</p>


<p><i>[2020-08; LWG reflector]</i></p>

<p>
A poll was taken to close the issue as NAD, but only gained three votes in favour
(and one vote against, which was subsequently withdrawn).
</p>

<p><i>[2022-03; LWG reflector]</i></p>

<p>
A poll was taken to close the issue as NAD, with six votes in favour.
(and one vote against, subsequently withdrawn).
</p>
<p>
"Write a paper if you want something else. These traits have well established meaning now."
"Minimizing requirements is not as important a concern for standard library concepts as as minimizing the number of concepts.
Requirements like 'I need to construct but not destroy an object' are niche enough that we don't need to support them."
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2432" href="2432">2432.</a> <tt>initializer_list</tt> assignability</h3>
<p><b>Section:</b> 17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2014-09-30 <b>Last modified:</b> 2022-08-24 18:53:49 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::initializer_list::operator=</tt> 17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> is horribly broken and it needs deprecation:
</p>
<blockquote><pre>
std::initializer_list&lt;foo&gt; a = {{1}, {2}, {3}};
a = {{4}, {5}, {6}};
// New sequence is already destroyed.
</pre></blockquote>
<p>
Assignability of <tt>initializer_list</tt> isn't explicitly specified, but most implementations supply a default assignment 
operator. I'm not sure what 16.3 <a href="https://timsong-cpp.github.io/cppwp/description">[description]</a> says, but it probably doesn't matter.
</p>

<p><i>[Lenexa 2015-05-05: Send to EWG as discussed in Telecon]</i></p>


<p><i>[2022-08-24; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll in October 2021.
</p>
<p>
"If somebody wants to revisit it, they'll need to write a paper to demonstrate
what the change would break, whether that would be a problem in practice,
and convince the evolution groups to make a change. But it's not an LWG issue."
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Edit 17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> p1, class template <tt>initializer_list</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class E&gt; class initializer_list {
  public:
    [&hellip;]
    constexpr initializer_list() noexcept;
  
    <ins>initializer_list(const initializer_list&amp;) = default;</ins>
    <ins>initializer_list(initializer_list&amp;&amp;) = default;</ins>
    <ins>initializer_list&amp; operator=(const initializer_list&amp;) = delete;</ins>
    <ins>initializer_list&amp; operator=(initializer_list&amp;&amp;) = delete;</ins>
    
    constexpr size_t size() const noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="3357" href="3357">3357.</a> [fund.ts.v3] <tt>default_random_engine</tt> is overspecified for per-thread engine</h3>
<p><b>Section:</b> 99 [fund.ts.v3::rand.util.randint] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2019-12-10 <b>Last modified:</b> 2022-10-19 20:26:42 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
Although "implementation may select this type on the basis of performance, size,
quality, or any combination of such factors," but changing this typedef is an ABI-break
for implementations. Specifying per-thread engine to use this typedef results in losses
of performance, size, and/or quality.
<p/>
Since this type is not involved in <tt>randint</tt> facilities' interface (other than its member
typedef), the current specification should be relaxed.
</p>

<p><i>[2020-01 Priority set to 3 and assigned to LEWG after review on the reflector.]</i></p>


<p><i>[2020-05-28; LEWG issue reviewing]</i></p>

<p>
LEWG issue processing voted to reject 3357 as NAD. Status change to Open.
</p>
<blockquote>
<pre>
Reject LWG3357 as NAD

SF  F N A SA
1  10 4 2 1
</pre>
</blockquote>

<p><i>[2022-10-19; Reflector poll]</i></p>

<p>
Set status to "Tentatively NAD" based on LEWG recommendation and reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4840">N4840</a>.</p>

<ol>
<li><p>Modify 9.1.1 [fund.ts.v3::rand.syn], header <tt>&lt;experimental/random&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;random&gt;

namespace std::experimental {
inline namespace fundamentals_v3 {

  <i>// 10.1.2.1, Function template randint</i>
  template &lt;class IntType&gt;
  IntType randint(IntType a, IntType b);
  void reseed();
  void reseed(<del>default_random_engine::result_type</del><ins>uint_fast32_t</ins> value);

} // inline namespace fundamentals_v3
} // namespace std::experimental
</pre>
</blockquote>
</li>

<li><p>Modify 99 [fund.ts.v3::rand.util.randint] as indicated:</p>

<blockquote>
<p>
-1- A separate <i>per-thread engine</i> of <del>type <tt>default_random_engine</tt> 
(C++17 &sect;29.6.5)</del><ins>unspecified type that meets the requirements of random 
number engine (C++17 [rand.req.eng])</ins>, initialized to an unpredictable state, 
shall be maintained for each thread. <ins>[<i>Note:</i> The implementation may choose 
the engine type on the basis of performance, size, quality, or any combination of such 
factors, so as to provide at least acceptable engine behavior for relatively casual, 
inexpert, and/or lightweight use. &mdash; <i>end note</i>]</ins>
</p>
[&hellip;]
<pre>
void reseed();
void reseed(<del>default_random_engine::result_type</del><ins>uint_fast32_t</ins> value);
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Let <tt>g</tt> be the per-thread engine. The first form sets <tt>g</tt> to an unpredictable 
state. The second form invokes <tt>g.seed(value)</tt>.
<p/>
-8- <i>Postconditions:</i> Subsequent calls to <tt>randint</tt> do not depend on values produced by <tt>g</tt> 
before calling reseed. [<i>Note:</i> <tt>reseed</tt> also resets any instances of 
<tt>uniform_int_distribution</tt> used by <tt>randint</tt>. &mdash; <i>end note</i>] 
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3726" href="3726">3726.</a> <tt>reverse_iterator::operator-&gt;</tt> is underconstrained for non-pointer iterators</h3>
<p><b>Section:</b> 25.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-27 <b>Last modified:</b> 2022-08-23 14:22:39 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#reverse.iter.elem">active issues</a> in [reverse.iter.elem].</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.elem">issues</a> in [reverse.iter.elem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For non-pointer types, <tt>reverse_iterator::operator-&gt;</tt> only requires the expression 
<tt>i.operator-&gt;()</tt> to be well-formed.
<p/>
Since the return type of this function is explicitly specified as <tt>pointer</tt>, 
this will cause a hard error in the function body when the return type of <tt>i.operator-&gt;()</tt> 
cannot be converted to <tt>pointer</tt>.
<p/>
We should add a return type constraint for this.
</p>

<p><i>[2022-08-23; Reflector poll: NAD]</i></p>

<p>
<code>pointer</code> is <code>iterator_traits&lt;Iterator&gt;::pointer</code>,
which is required to name <code>decltype(i.operator-&gt;())</code>
(25.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a>/1)
so the postulated problem simply does not arise in valid code.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 25.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> as indicated:</p>

<blockquote>
<pre>
constexpr pointer operator-&gt;() const
  requires (is_pointer_v&lt;Iterator&gt; ||
            requires(const Iterator i) { <ins>{</ins> i.operator-&gt;() <ins>} -&gt; convertible_to&lt;pointer&gt;</ins>; });
</pre>
<blockquote>
<p>
-2- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <tt>Iterator</tt> is a pointer type, equivalent to: <tt>return prev(current);</tt></p></li>
<li><p>(2.2) &mdash; Otherwise, equivalent to: <tt>return prev(current).operator-&gt;();</tt></p>
</li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3727" href="3727">3727.</a> <tt>reverse_iterator</tt>/<tt>common_iterator</tt>'s <tt>operator-&gt;</tt> should not require the underlying iterator's <tt>operator-&gt;</tt> to be a <tt>const</tt> member function</h3>
<p><b>Section:</b> 25.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a>, 25.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/common.iter.access">[common.iter.access]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-27 <b>Last modified:</b> 2022-08-23 14:22:39 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#reverse.iter.elem">active issues</a> in [reverse.iter.elem].</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.elem">issues</a> in [reverse.iter.elem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For non-pointer types, <tt>reverse_iterator::operator-&gt;</tt> requires that the <tt>Iterator</tt> 
must have an <tt>operator-&gt;()</tt> with <tt>const</tt>-qualifier, whereas in the <i>Effects</i> clause, 
it always invokes the non-<tt>const</tt> object's <tt>operator-&gt;()</tt>.
<p/>
<tt>common_iterator::operator-&gt;</tt> also requires that <tt>I::operator-&gt;()</tt> must be 
<tt>const</tt>-qualified, which seems reasonable since the return type of <tt>get&lt;I&gt;(v_)</tt> 
is <tt>const I&amp;</tt>. However, LWG <a href="3672">3672</a> makes <tt>common_iterator::operator-&gt;()</tt> 
always return a value, which makes it unnecessary to detect the constness of <tt>I::operator-&gt;()</tt>, 
because it will be invoked with a non-<tt>const</tt> returned object anyway.
<p/>
I think we should remove this constraint as I don't see the benefit of doing that.
Constraining iterator's <tt>operator-&gt;()</tt> to be <tt>const</tt> and finally invoking non-<tt>const</tt> 
overload doesn't feel right to me either. In <tt>&lt;ranges&gt;</tt>, the exposition-only constraint 
<tt><i>has-arrow</i></tt> (26.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>) for <tt>operator-&gt;()</tt> does not 
require that the underlying iterator's <tt>operator-&gt;()</tt> to be <tt>const</tt>, we should make them 
consistent, and I believe this relaxation of constraints can bring some value.
<p/>
<b>Daniel:</b>
<p/>
This issue's second part of the resolution actually depends on <a href="3672">3672</a> being applied. But
note that the reference wording below is still <a href="https://wg21.link/N4910">N4910</a>.
</p>

<p><i>[2022-08-23; Reflector poll: NAD]</i></p>

<p>
Implicit variations apply to those <i>requires-expressions</i>,
so calling as non-const (and rvalue) is fine.
The PR actually loses that property and makes those overloads truly underconstrained.
Motivation for relaxing it is vague.
As for consistency, we should fix has-arrow instead.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 25.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> as indicated:</p>

<blockquote>
<pre>
constexpr pointer operator-&gt;() const
  requires (is_pointer_v&lt;Iterator&gt; ||
            requires(<del>const</del> Iterator i) { i.operator-&gt;(); });
</pre>
<blockquote>
<p>
-2- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <tt>Iterator</tt> is a pointer type, equivalent to: <tt>return prev(current);</tt></p></li>
<li><p>(2.2) &mdash; Otherwise, equivalent to: <tt>return prev(current).operator-&gt;();</tt></p>
</li>
</ol>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/common.iter.access">[common.iter.access]</a> as indicated:</p>

<blockquote>
<pre>
constexpr decltype(auto) operator-&gt;() const
  requires <i>see below</i>;
</pre>
  <blockquote>
  <p>
  -3- The expression in the <i>requires-clause</i> is equivalent to:
  </p>
  <blockquote><pre>
  indirectly_readable&lt;const I&gt; &amp;&amp;
  (requires(<del>const</del> I<del>&amp;</del> i) { i.operator-&gt;(); } ||
  is_reference_v&lt;iter_reference_t&lt;I&gt;&gt; ||
  constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;)
  </pre></blockquote>
  <p>
  -4- <i>Preconditions</i>: <tt>holds_alternative&lt;I&gt;(v_)</tt> is <tt>true</tt>.
  <p/>
  -5- <i>Effects</i>:
  </p>
  <ol style="list-style-type: none">
  <li><p>(5.1) &mdash; If <tt>I</tt> is a pointer type or if <del>the expression 
  <tt>get&lt;I&gt;(v_).operator-&gt;()</tt> is 
  well-formed</del><ins><tt>requires(I i) { i.operator-&gt;(); }</tt> is <tt>true</tt></ins>, 
  equivalent to: <tt>return get&lt;I&gt;(v_);</tt>  
  </p></li>
  <li><p>(5.2) &mdash; Otherwise, if <tt>iter_reference_t&lt;I&gt;</tt> is a reference type, equivalent to:</p>
  <blockquote><pre>
  auto&amp;&amp; tmp = *get&lt;I&gt;(v_);
  return addressof(tmp);
  </pre></blockquote>
  </li>
  <li><p>(5.3) &mdash; Otherwise, equivalent to: <tt>return <i>proxy</i>(*get&lt;I&gt;(v_));</tt> where 
  <tt><i>proxy</i></tt> is the exposition-only class:</p>
  <blockquote><pre>
  class <i>proxy</i> {
    iter_value_t&lt;I&gt; keep_;
    constexpr <i>proxy</i>(iter_reference_t&lt;I&gt;&amp;&amp; x)
      : keep_(std::move(x)) {}
  public:
    constexpr const iter_value_t&lt;I&gt;* operator-&gt;() const noexcept {
      return addressof(keep_);
    }
  };
  </pre></blockquote>
  </li>
  </ol>
  <p>
  [&hellip;]
  </p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3735" href="3735">3735.</a> <tt>views::adjacent&lt;0&gt;</tt> should be prohibited</h3>
<p><b>Section:</b> 26.7.25.1 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.overview">[range.adjacent.overview]</a>, 26.7.26.1 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.overview">[range.adjacent.transform.overview]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-07-13 <b>Last modified:</b> 2022-08-23 14:22:39 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>views::adjacent</tt> is very similar to <tt>views::slide</tt>, except that the window size 
<tt>N</tt> is given at compile time.
<p/>
Since the case where <tt>N</tt> is <tt>0</tt> does not make sense for <tt>slide_view</tt>, 
LWG <a href="3711">3711</a> and LWG <a href="3712">3712</a> added preconditions to the constructor and 
removed the default constructor, respectively.
<p/>
But for <tt>views::adjacent</tt>, we can still specify <tt>N</tt> to be <tt>0</tt>. According to 
the description of 26.7.25.1 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.overview">[range.adjacent.overview]</a>, 
it will return <tt>views::empty&lt;tuple&lt;&gt;&gt;</tt> as in the case of <tt>views::zip</tt> 
applied to an empty pack. And for <tt>views::adjacent_transform&lt;0&gt;(E, F)</tt>, it will return 
<tt>views::zip_transform(F)</tt> and eventually return <tt>empty_view</tt> for some type.
<p/>
This doesn't seem reasonable to me. The reason why <tt>views::zip</tt> can return 
<tt>views::empty&lt;tuple&lt;&gt;&gt;</tt> is that the parameter pack can indeed be empty, so 
this still makes some sense. However, there is no meaningful sense for the word "adjacent" when 
<tt>N</tt> is <tt>0</tt>.
<p/>
I don't see any observable value in allowing <tt>views::adjacent&lt;0&gt;</tt>, we should disable 
it for consistency with <tt>views::slide</tt>.
</p>

<p><i>[2022-08-23; Reflector poll: NAD]</i></p>

<p>
<code>views::zip()</code> is exactly as meaningful as
<code>views::adjacent&lt;0&gt;(E)</code> - it's just the edge case.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>

<li><p>Modify 26.7.25.1 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.overview">[range.adjacent.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <tt>views::adjacent&lt;N&gt;</tt> denotes a range adaptor object 
(26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>). Given a subexpression <tt>E</tt> and a constant expression 
<tt>N</tt>, the expression <tt>views::adjacent&lt;N&gt;(E)</tt> is expression-equivalent to:
</p>
<ol style="list-style-type:none">
<li><p>(2.1) &mdash; <del><tt>((void)E, auto(views::empty&lt;tuple&lt;&gt;&gt;))</tt></del><ins>I</ins><del>i</del>f 
<tt>N</tt> is equal to <tt>0</tt>, <ins><tt>views::adjacent&lt;N&gt;(E)</tt> is ill-formed.</ins></p></li>
<li><p>(2.2) &mdash; <ins>O</ins><del>o</del>therwise, <tt>adjacent_view&lt;views::all_t&lt;decltype((E))&gt;, N&gt;(E)</tt>.</p></li>
</ol></blockquote>
</li>

<li><p>Modify 26.7.26.1 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.overview">[range.adjacent.transform.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <tt>views::adjacent_transform&lt;N&gt;</tt> denotes a range adaptor object 
(26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>). Given subexpressions <tt>E</tt> and <tt>F</tt> and a constant
expression <tt>N</tt>:
</p>
<ol style="list-style-type:none">
<li><p>(2.1) &mdash; If <tt>N</tt> is equal to <tt>0</tt>, <tt>views::adjacent_transform&lt;N&gt;(E, F)</tt> 
is <ins>ill-formed</ins><del>expression-equivalent to <tt>((void)E, views::zip_transform(F))</tt>, except that 
the evaluations of <tt>E</tt> and <tt>F</tt> are indeterminately sequenced</del>.</p></li>
<li><p>(2.2) &mdash; Otherwise, the expression <tt>views::adjacent_transform&lt;N&gt;(E, F)</tt> is 
expression-equivalent to <tt>adjacent_transform_view&lt;views::all_t&lt;decltype((E))&gt;, 
decay_t&lt;decltype((F))&gt;, N&gt;(E, F)</tt>.</p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3739" href="3739">3739.</a> <tt>chunk_view::size</tt> should preserve the signedness of the size of the underlying range</h3>
<p><b>Section:</b> 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.input">[range.chunk.view.input]</a>, 26.7.27.6 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.fwd">[range.chunk.view.fwd]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-07-15 <b>Last modified:</b> 2022-08-23 14:22:39 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.chunk.view.input">issues</a> in [range.chunk.view.input].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the <i>Effects</i> of <tt>chunk_view::size</tt> simply returns 
<tt><i>to-unsigned-like</i>(<i>div-ceil</i>(ranges::distance(<i>base_</i>), <i>n_</i>))</tt>, 
where <tt><i>div-ceil</i></tt> is defined in 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.input">[range.chunk.view.input]</a> as:
</p>
<pre>
template&lt;class I&gt;
constexpr I <i>div-ceil</i>(I num, I denom) { // <i>exposition only</i>
  I r = num / denom;
  if (num % denom)
    ++r;
  return r;
}
</pre>
<p>
There are two problems here. First, for the const version of <tt>chunk_view::size</tt>, 
the types of <tt>ranges::distance(<i>base_</i>)</tt> and <tt><i>n_</i></tt> are 
<tt>range_difference_t&lt;const V&gt;</tt> and 
<tt>range_difference_t&lt;V&gt;</tt> respectively,   and the two parameters of 
<tt><i>div-ceil</i></tt> have the same type <tt>I</tt>.
Given that the standard does not guarantee that <tt>V</tt> and <tt>const V</tt> must have 
the same <tt>difference_type</tt>,   this makes the <tt><i>div-ceil</i></tt>'s template 
deduction fail when the two are different.
<p/>
Second, the standard does not guarantee that <tt>ranges::size</tt> must return an 
unsigned type, but here we use <tt><i>to-unsigned-like</i></tt> to unconditionally 
convert the return type of <tt>chunk_view::size</tt> to an unsigned type,
which is inconsistent with the behavior of other range adaptors such as 
<tt>take_view</tt> and <tt>drop_view</tt>.
<p/>
We should try to preserve the characteristics of the <tt>range_size_t</tt> of the underlying 
range as much as possible.
</p>

<p><i>[2022-08-23; Reflector poll: NAD (would need a paper for LEWG)]</i></p>

<p>
The "range_difference_t&lt;const V&gt; and range_difference_t&lt;V&gt; can be both valid but have different types" part is something I expect Mr. Carter's eventual paper to outlaw. The "preserve signedness" part is LEWG.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.input">[range.chunk.view.input]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto size() requires sized_range&lt;V&gt;;
constexpr auto size() const requires sized_range&lt;const V&gt;;
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to:
<pre>
return <del><i>to-unsigned-like</i>(</del><i>div-ceil</i>(ranges::<ins>size</ins><del>distance</del>(<i>base_</i>), <ins>static_cast&lt;decltype(ranges::size(<i><i>base_</i></i>))&gt;(</ins><i>n_</i>));
</pre>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.27.6 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.fwd">[range.chunk.view.fwd]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto size() requires sized_range&lt;V&gt;;
constexpr auto size() const requires sized_range&lt;const V&gt;;
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to:
<pre>
return <del><i>to-unsigned-like</i>(</del><i>div-ceil</i>(ranges::<ins>size</ins><del>distance</del>(<i>base_</i>), <ins>static_cast&lt;decltype(ranges::size(<i><i>base_</i></i>))&gt;(</ins><i>n_</i>));
</pre>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3740" href="3740">3740.</a> <tt>slide_view::size</tt> should preserve the signedness of underlying range's size</h3>
<p><b>Section:</b> 26.7.28.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-07-15 <b>Last modified:</b> 2022-08-23 14:22:39 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.slide.view">issues</a> in [range.slide.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <tt>slide_view::size const</tt> has the following <i>Effects</i>:
</p>
<pre>
auto sz = ranges::distance(<i>base_</i>) - <i>n_</i> + 1;
if (sz &gt; 0) sz = 0;
return <i>to-unsigned-like</i>(sz);
</pre>
<p>
There are two problems worth noting here. First, as described in LWG <a href="3739">3739</a>, 
<tt>ranges::distance(<i>base_</i>)</tt> and <tt><i>n_</i></tt> may have 
different types, which makes the actual type of <tt>sz</tt> not deterministic.
Also, the return type is unconditionally converted to an unsigned type, even though 
the underlying range may have a signed size type.
</p>
Second, even if <tt>V</tt> has the same <tt>difference_type</tt> as <tt>const V</tt>, 
there may still be integer promotion issues mentioned by LWG <a href="3730">3730</a>
since we add an integer <tt>1</tt> at the end here.
<p>
I think converting <tt>sz</tt> to the size type of the underlying range before 
returning is the appropriate thing to do.
</p>

<p><i>[2022-08-23; Reflector poll: NAD]</i></p>

<p>
Paper author: "I did consider promotion and decided not to care. The code compiles and conforms to all ranges requirements, and that seems entirely sufficient to me." "Even if we don't outlaw those being different types entirely, people playing those games will still get exactly one unsigned-integer-like type back. It's totally deterministic."
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 26.7.28.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto size() requires sized_range&lt;V&gt;;
constexpr auto size() const requires sized_range&lt;const V&gt;;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to:
<pre>
auto sz = ranges::distance(<i>base_</i>) - <i>n_</i> + 1;
if (sz &lt; 0) sz = 0;
return <ins>static_cast&lt;decltype(ranges::size(<i>base_</i>))&gt;</ins><del><i>to-unsigned-like</i></del>(sz);
</pre>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3741" href="3741">3741.</a> <tt>std::chrono::abs(duration)</tt> is ill-formed with non-reduced periods</h3>
<p><b>Section:</b> 29.5.10 <a href="https://timsong-cpp.github.io/cppwp/time.duration.alg">[time.duration.alg]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Charlie Barto <b>Opened:</b> 2022-07-16 <b>Last modified:</b> 2022-08-23 23:03:41 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently 29.5.10 <a href="https://timsong-cpp.github.io/cppwp/time.duration.alg">[time.duration.alg]</a> specifies <tt>abs(duration)</tt> as:
</p>
<blockquote><p>
<i>Returns:</i> if <tt>d &gt;= d.zero()</tt>, return <tt>d</tt>, otherwise return <tt>-d</tt>.
</p></blockquote>
<p>
Because unary minus on durations is defined to return <tt>common_type_t&lt;duration>(-rep_)</tt>, 
and <tt>common_type_t</tt> for durations is specified to reduce the period, this is ill-formed 
with durations such as <tt>duration&lt;int, ratio&lt;1000, 1000&gt;&gt;</tt>, or any other 
type where the numerator and denominator of the period are not coprime.
</p>

<p><i>[2022-08-23; Reflector poll: NAD]</i></p>

<p>
Not ill-formed, implementation should do a conversion.
Changing it to return the reduced duration as an improvement would be for LEWG.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 29.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>, header <tt>&lt;chrono&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 29.5.10 <a href="https://timsong-cpp.github.io/cppwp/time.duration.alg">[time.duration.alg]</a>, specialized algorithms</i>
template&lt;class Rep, class Period&gt;
  constexpr <ins>common_type_t&lt;</ins>duration&lt;Rep, Period&gt;<ins>&gt;</ins> abs(duration&lt;Rep, Period&gt; d);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 29.5.10 <a href="https://timsong-cpp.github.io/cppwp/time.duration.alg">[time.duration.alg]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> This will cause <tt>abs</tt> to reduce the period before returning it, 
much like the other arithmetic operators. 
<p/>
This is not a breaking change, because code that was using <tt>abs</tt> with a non-reduced 
period before did not compile.
]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class Rep, class Period&gt;
  constexpr <ins>common_type_t&lt;</ins>duration&lt;Rep, Period&gt;<ins>&gt;</ins> abs(duration&lt;Rep, Period&gt; d);
</pre>
<blockquote>
<p>
-1- <i>Constraints:</i> <tt>numeric_limits&lt;Rep&gt;::is_signed</tt> is <tt>true</tt>.
<p/>
-2- <i>Returns:</i> If <tt>d &gt;= d.zero()</tt>, return <tt><ins>+</ins>d</tt>, otherwise return <tt>-d</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3752" href="3752">3752.</a> Should <tt>string::substr</tt> forward the allocator to the newly created string?</h3>
<p><b>Section:</b> 23.4.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/string.substr">[string.substr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Igor Zhukov <b>Opened:</b> 2022-08-10 <b>Last modified:</b> 2022-08-24 18:53:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Adrian Vogelsgesang noticed that libcxx's <tt>string::substr</tt> 
<a href="https://github.com/llvm/llvm-project/blob/0729d00135ccbe1514a49168bbf26986823235c2/libcxx/include/string#L3573">forward 
the allocator to the newly created string</a>.
<p/>
Nikolas Klauser found that 
<a href="https://github.com/microsoft/STL/blob/5aae6780236208577b4e8a000cbe7aa3cbc24c41/stl/inc/xstring#L4673">MSVC 
STL does the same thing</a>.
<p/>
While Casey Carter and we all agree that this is a bug and we will fix it, we've "always" been nonconforming here 
and it's weird though that there was never an issue filed and two implementations have the exact same change.
<p/>
So we want a clarification from LWG.
</p>

<p><i>[2022-08-24; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll.
</p>
<p>
"If you want to provide a different allocator, you can use the substring constructor."
</p>
<p>
"This matches the constructor, whose choice of allocator has been already considered in <a href="2402">2402</a>. Any changes here need a paper."
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3768" href="3768">3768.</a> <tt><i>possibly-const-range</i></tt> is overconstrained</h3>
<p><b>Section:</b> 26.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-09-08 <b>Last modified:</b> 2022-09-23 15:21:08 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ranges.syn">active issues</a> in [ranges.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#ranges.syn">issues</a> in [ranges.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Due to the <tt><i>possibly-const-range</i></tt> constraint that the template parameter <tt>R</tt> 
must model <tt>input_range</tt>, this makes the <tt>ranges::cend</tt> that tries using it 
for meaningful <tt>const</tt> casting never be applied to an <tt>output_range</tt>, even though 
<tt>const_sentinel</tt> does not require the template parameter <tt>S</tt> to model 
<tt>input_iterator</tt>.
<p/>
This is unnecessary, we should relax its constraint.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>Tentatively NAD. "const output ranges don’t seem to be useful."</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>

<li><p>Modify 26.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a> as indicated:</p>

<blockquote>
<pre>
#include &lt;compare&gt;              // <i>see 17.12.1 <a href="https://timsong-cpp.github.io/cppwp/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see 17.11.2 <a href="https://timsong-cpp.github.io/cppwp/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see 25.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a></i>

namespace std::ranges {
  [&hellip;]

  // <i>26.7.21 <a href="https://timsong-cpp.github.io/cppwp/range.as.const">[range.as.const]</a>, as const view</i>
  template&lt;<del>input_</del>range R&gt;
    constexpr auto&amp; <i>possibly-const-range</i>(R&amp; r) {          // <i>exposition only</i>
      if constexpr (constant_range&lt;const R&gt; &amp;&amp; !constant_range&lt;R&gt;) {
        return const_cast&lt;const R&amp;&gt;(r);
      } else {
        return r;
      }
    } 
  
  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3779" href="3779">3779.</a> <tt>ranges::fold_*</tt> can unintentionally <tt>const_cast</tt> and <tt>reinterpret_cast</tt></h3>
<p><b>Section:</b> 27.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Nicole Mazzuca <b>Opened:</b> 2022-09-15 <b>Last modified:</b> 2022-10-12 14:16:51 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the <i>Effects</i> element of <tt>ranges::fold_right</tt>, we get the following code:
</p>
<blockquote><pre>
using U = decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;;
if (first == last)
  return U(std::move(init)); // <span style="color:red;font-weight:bolder">functional-style C cast</span>
[&hellip;]
</pre></blockquote>
<p>
Given the following function object:
</p>
<blockquote><pre>
struct Second {
  static char* operator()(const char*, char* rhs) {
    return rhs;
  }
};
</pre></blockquote>
<p>
calling <tt>fold_right</tt> as:
</p>
<blockquote><pre>
char* p = fold_right(views::empty&lt;char*&gt;, "Hello", Second{});
</pre></blockquote>
<p>
initializes <tt>p</tt> with <tt>const_cast&lt;char*&gt;("Hello")</tt>.
<p/>
The same problem exists in <tt>fold_left_with_iter</tt>, and thus in <tt>fold_left</tt>.
<p/>
One can get the <tt>reinterpret_cast</tt> behavior by replacing <tt>const char*</tt> with 
<tt>unsigned long long</tt>.
</p>

<p><i>[2022-10-12; Reflector poll]</i></p>

<p>
Set status to "Tentatively NAD" after reflector poll.
</p>
<p>
"The example doesn't compile. The accumulator should be be the second param,
but with that fixed the constraints are not satisfied.
The <tt>convertible_to</tt> constraint prevents the undesirable casting."
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>

<li><p>Modify 27.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class T,
         <i>indirectly-binary-right-foldable</i>&lt;T, I&gt; F&gt;
  constexpr auto ranges::fold_right(I first, S last, T init, F f);
template&lt;bidirectional_range R, class T,
         <i>indirectly-binary-right-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
  constexpr auto ranges::fold_right(R&amp;&amp; r, T init, F f);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
using U = decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;;
if (first == last)
  return <ins>static_cast&lt;</ins>U<ins>&gt;</ins>(std::move(init));
I tail = ranges::next(first, last);
U accum = invoke(f, *--tail, std::move(init));
while (first != tail)
  accum = invoke(f, *--tail, std::move(accum));
return accum;
</pre></blockquote>
</blockquote>
[&hellip;]
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T,
         <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
  constexpr <i>see below</i> ranges::fold_left_with_iter(I first, S last, T init, F f);
template&lt;input_range R, class T, <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
  constexpr <i>see below</i> ranges::fold_left_with_iter(R&amp;&amp; r, T init, F f);
</pre>
<blockquote>
<p>
-6- Let <tt>U</tt> be <tt>decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;</tt>.
<p/>
-7- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return {std::move(first), <ins>static_cast&lt;</ins>U<ins>&gt;</ins>(std::move(init))};
U accum = invoke(f, std::move(init), *first);
for (++first; first != last; ++first)
  accum = invoke(f, std::move(accum), *first);
return {std::move(first), std::move(accum)};
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3789" href="3789">3789.</a> Precondition of (not replaced) <tt>operator delete[]</tt></h3>
<p><b>Section:</b> 17.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/new.delete.array">[new.delete.array]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> blacktea hamburger <b>Opened:</b> 2022-09-25 <b>Last modified:</b> 2022-10-10 10:43:23 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.array">issues</a> in [new.delete.array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider (<tt>operator delete[](std::size_t)</tt> and <tt>operator new(std::size_t)</tt> is not replaced):
</p>
<blockquote><pre>
operator delete[](operator new(1));
</pre></blockquote>
<p>
(even not replaced) <tt>void* operator new(std::size_t)</tt> does not return 
<tt>void* operator new[](std::size_t)</tt>. So the behavior is undefined according 
to 17.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/new.delete.array">[new.delete.array]</a> paragraph 9:
</p>
<blockquote><p>
<i>Preconditions</i>: <tt>ptr</tt> is a null pointer or its value represents the address of a block of 
memory allocated by an earlier call to a (possibly replaced) <tt>operator new[](std::size_t)</tt> or 
<tt>operator new[](std::size_t, std::align_val_t)</tt> which has not been invalidated by an intervening 
call to <tt>operator delete[]</tt>.
</p></blockquote>
<p>
However, consider (<tt>operator delete(std::size_t)</tt> and <tt>operator new[](std::size_t)</tt> is not replaced):
</p>
<blockquote><pre>
operator delete(operator new[](1));
</pre></blockquote>
<p>
(not replaced) <tt>operator new[](std::size_t)</tt> simply returns <tt>operator new(std::size_t)</tt> 
according to 17.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/new.delete.array">[new.delete.array]</a> paragraph 4:
</p>
<blockquote><p>
<i>Default behavior</i>: Returns <tt>operator new(size)</tt>, or <tt>operator new(size, alignment)</tt>, respectively.
</p></blockquote>
<p>
So it is well-formed according to 17.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> paragraph 10:
</p>
<blockquote><p>
<i>Preconditions</i>: <tt>ptr</tt> is a null pointer or its value represents the address of a block of memory 
allocated by an earlier call to a (possibly replaced) <tt>operator new(std::size_t)</tt> or 
<tt>operator new(std::size_t, std::align_val_t)</tt> which has not been invalidated by an intervening call to 
<tt>operator delete</tt>.
</p></blockquote>
<p>
The behavior should be consistent.
</p>

<p><i>[2022-10-10; Reflector poll]</i></p>

<p>Set status to "Tentatively NAD" after reflector poll.</p>
<p>
"No reason to carve out an exception covering a case on something which can’t
be observed by the program (whether the allocation operators are replaced).
This just makes things more complicated for no good reason."
"This would require changes to sanitizers and other dynamic analyzers,
for zero practical benefit (except allowing bad code to go un-diagnosed)."
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 17.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/new.delete.array">[new.delete.array]</a> as indicated:</p>

<blockquote>
<pre>
void operator delete[](void* ptr) noexcept;
void operator delete[](void* ptr, std::size_t size) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment) noexcept;
void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
</pre>
<blockquote>
<p>
-9- <i>Preconditions</i>: <tt>ptr</tt> is a null pointer or its value represents the address 
of a block of memory allocated by an earlier call to a (possibly replaced) 
<tt>operator new[](std::size_t)</tt><ins>,</ins> <del>or</del> 
<tt>operator new[](std::size_t, std::align_val_t)</tt><ins>, (not replaced) 
<tt>operator new(std::size_t)</tt>, or <tt>operator new(std::size_t, std::align_val_t)</tt></ins>
which has not been invalidated by an intervening call to <tt>operator delete[]</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3800" href="3800">3800.</a> No deduction guide for <tt>std::match_results</tt></h3>
<p><b>Section:</b> 32.9.1 <a href="https://timsong-cpp.github.io/cppwp/re.results.general">[re.results.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2022-10-25 <b>Last modified:</b> 2022-11-01 17:38:22 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::match_results</tt> meets some of the requirements for an allocator-aware container, which means 
that its <tt>allocator_type</tt> must have the same <tt>value_type</tt> as the container. This means that 
class template argument deduction should work for:
</p>
<blockquote><pre>
std::match_results mr(alloc);
</pre></blockquote>
<p>
The allocator's <tt>value_type</tt> will be the <tt>sub_match&lt;Iter&gt;</tt> type stored in the 
<tt>match_results</tt> object, and so the first template argument for the <tt>match_results</tt> type will 
be <tt>value_type::iterator</tt>.
<p/>
<a href="https://wg21.link/P0433R2">P0433R2</a> added a deduction guide for <tt>std::basic_regex</tt>, but I see no rationale for 
not adding one for <tt>std::match_results</tt>. This seems like a defect, because all other allocator-aware 
containers support deduction from an allocator argument.
</p>

<p><i>[2022-11-01; reflector poll]</i></p>

<p>Status changed to Tentatively NAD. The issue is wrong: other containers
do not support deduction from an allocator type.</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 32.9.1 <a href="https://timsong-cpp.github.io/cppwp/re.results.general">[re.results.general]</a>, class template <tt>match_results</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class BidirectionalIterator,
           class Allocator = allocator&lt;sub_match&lt;BidirectionalIterator&gt;&gt;&gt;
    class match_results {
      [&hellip;]
      void swap(match_results&amp; that);
    };
    
  <ins>template&lt;class Allocator&gt;
    match_results(Allocator) -&gt; match_results&lt;typename Allocator::value_type::iterator, Allocator&gt;;</ins>
}
</pre>
</blockquote>
</li>

</ol>





</body>
</html>
