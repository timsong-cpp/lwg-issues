<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p><p>Revised 2023-06-12 at 11:59:23 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2457" href="2457">2457.</a> <tt>std::begin()</tt> and <tt>std::end()</tt> do not support multi-dimensional arrays correctly</h3>
<p><b>Section:</b> 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Janez &#x17d;emva <b>Opened:</b> 2014-11-16 <b>Last modified:</b> 2023-04-06 13:59:48 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

int main() 
{
  int a[2][3][4] = { { { 1,  2,  3,  4}, { 5,  6,  7,  8}, { 9, 10, 11, 12} },
                     { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } };
  int b[2][3][4];

  assert(std::distance(std::begin(a), std::end(a)) == 2 * 3 * 4);
  std::copy(std::begin(a), std::end(a), std::begin(b));
  std::copy(std::begin(b), std::end(b), std::ostream_iterator&lt;int&gt;(std::cout, ","));
}
</pre></blockquote>
<p>
does not compile. 
<p/>
A possible way to remedy this would be to add the following overloads of
<tt>begin</tt>, <tt>end</tt>, <tt>rbegin</tt>, and <tt>rend</tt> to 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>, 
relying on recursive evaluation:
</p>
<blockquote><pre>
namespace std {

  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  begin(T (&amp;array)[M][N])
  {
    return begin(*array);
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  end(T (&amp;array)[M][N])
  {
    return end(array[M - 1]);
  }

  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rbegin(T (&amp;array)[M][N])
  {
    return decltype(rbegin(array))(end(array[M - 1]));
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rend(T (&amp;array)[M][N])
  {
    return decltype(rend(array))(begin(*array));
  }

}
</pre></blockquote>

<p><i>[2023-04-06; LWG reflector poll in November 2021]</i></p>

<p>
Changed to Tentatively NAD after 12 votes in favour.
Use <code>views::join</code> or <code>mdspan</code> instead.
</p>



<p id="res-2457"><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3635" href="3635">3635.</a> Add <tt>__cpp_lib_deduction_guides</tt> to feature test macros</h3>
<p><b>Section:</b> 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Konstantin Varlamov <b>Opened:</b> 2021-11-09 <b>Last modified:</b> 2023-05-24 14:08:46 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P0433R2">P0433R2</a>, the proposal for adding deduction guides to the standard library, contained a 
recommendation to use <tt>__cpp_lib_deduction_guides</tt> as a feature test macro. However, it appears that this feature test macro has been accidentally omitted from the Standard when the paper was applied and probably needs to be added back.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;deque&gt;, &lt;forward_list&gt;, &lt;list&gt;, &lt;map&gt;, &lt;queue&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2021-11-16; Konstantin Varlamov comments and improves wording]</i></p>

<p>
One potential topic of discussion is whether the new feature test macro needs to be defined in every library 
header that contains an explicit deduction guide. While this would be consistent with the current approach, 
no other macro is associated with such a large set of headers (20 headers in total, whereas the current 
record-holder is <tt>__cpp_lib_nonmember_container_access</tt> with 12 headers). For this reason, it should 
be considered whether perhaps the new macro should only be defined in <tt>&lt;version&gt;</tt> (which would, 
however, make it an outlier). The proposed wording currently contains an exhaustive list (note that the 
deduction guides for <tt>&lt;mutex&gt;</tt> were removed by LWG <a href="2981">2981</a>).
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Several votes for NAD as it's too late to be useful, and code which needs
to be portable to pre-CTAD compilers can just not use CTAD.
</p>

<p><i>[2023-04-21; Reflector poll for 'Tentatively NAD']</i></p>

<p><i>[
"We keep changing the deduction guides, and different libraries might be
conformant in some headers and not others. The status cannot be represented
by a single number."
]</i></p>




<p id="res-3635"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;array&gt;, &lt;deque&gt;, &lt;forward_list&gt;, &lt;functional&gt;, &lt;list&gt;, &lt;map&gt;,
  // &lt;memory&gt;, &lt;optional&gt;, &lt;queue&gt;, &lt;regex&gt;, &lt;scoped_allocator&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;string&gt;, &lt;tuple&gt;, &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;utility&gt;, &lt;valarray&gt;,
  // &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3714" href="3714">3714.</a> Non-single-argument constructors for range adaptors should not be <tt>explicit</tt></h3>
<p><b>Section:</b> 26.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.transform.view">[range.zip.transform.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-10 <b>Last modified:</b> 2023-01-24 10:14:05 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All C++20 range adaptors' non-single-argument constructors are not declared as <tt>explicit</tt>, which makes 
the following initialization well-formed:
</p>
<blockquote><pre>
std::vector v{42};
std::ranges::take_view r1 = {v, 1};
std::ranges::filter_view r2 = {v, [](int) { return true; }};
</pre></blockquote>
<p>
However, the non-single-argument constructors of C++23 range adaptors, except for <tt>join_with_view</tt>, 
are all <tt>explicit</tt>, which makes us no longer able to
</p>
<blockquote><pre>
std::ranges::chunk_view r1 = {v, 1}; // <span style="color:red;font-weight:bolder">ill-formed</span>
std::ranges::chunk_by_view r2 = {v, [](int, int) { return true; }}; // <span style="color:red;font-weight:bolder">ill-formed</span>
</pre></blockquote>
<p>
This seems unnecessary since I don't see the observable benefit of preventing this. In the standard, 
non-single-argument constructors are rarely specified as <tt>explicit</tt> unless it is really undesirable, 
I think the above initialization is what the user expects since it's clearly intentional, and I don't see 
any good reason to reject it from C++23.
</p>
<p><i>[2022-06-11; Daniel comments]</i></p>

<p>
Another possible candidate could be 26.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.take.while.sentinel">[range.take.while.sentinel]</a>'s
</p>
<blockquote><pre>
constexpr explicit <i>sentinel</i>(sentinel_t&lt;<i>Base</i>&gt; end, const Pred* pred);
</pre></blockquote>

<p><i>[2022-06-21; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Send to LEWG.
</p>

<p><i>[2023-01-24; LEWG in Kona]</i></p>

<p>Use alternative approach in <a href="https://wg21.link/P2711">P2711</a> instead.</p>



<p id="res-3714"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 26.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.transform.view">[range.zip.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view : public view_interface&lt;zip_transform_view&lt;F, Views...&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                   <i>// exposition only</i>
    zip_view&lt;Views...&gt; <i>zip_</i>;                <i>// exposition only</i>
    [&hellip;]
  public:
    zip_transform_view() = default;

    constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>fun_</i></tt> with <tt>std::move(fun)</tt> and <tt><i>zip_</i></tt> 
with <tt>std::move(views)...</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.view">[range.adjacent.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view : public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                       <i>// exposition only</i>
    adjacent_view&lt;V, N&gt; <i>inner_</i>;                 <i>// exposition only</i>
    [&hellip;]
  public:
    adjacent_transform_view() = default;
    constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>fun_</i></tt> with <tt>std::move(fun)</tt> and 
<tt><i>inner_</i></tt> with <tt>std::move(base)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.input">[range.chunk.view.input]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                                        <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;                         <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <tt>n &gt; 0</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.6 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.fwd">[range.chunk.view.fwd]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt; : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <tt>n &gt; 0</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.29.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    slide_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.30.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.by.view">[range.chunk.by.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view : public view_interface&lt;chunk_by_view&lt;V, Pred&gt;&gt; {
    V <i>base_</i> = V();                                <i>// exposition only</i>
    <i>copyable-box</i>&lt;Pred&gt; <i>pred_</i> = Pred();            <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_by_view() requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pred&gt; = default;
    constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>pred_</i></tt> with <tt>std::move(pred)</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3901" href="3901">3901.</a> Is uses-allocator construction of a <i>cv</i>-qualified object type still well-formed after LWG 3870?</h3>
<p><b>Section:</b> 20.2.8 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses">[allocator.uses]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-05 <b>Last modified:</b> 2023-03-22 22:35:08 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3870">3870</a> made <tt>std::construct_at</tt> unable to create an object of a <i>cv</i>-qualified type, 
which affects <tt>std::uninitialized_construct_using_allocator</tt>. However, uses-allocator construction is 
currently not required to be equivalent to some call to <tt>std::uninitialized_construct_using_allocator</tt>, 
which possibly implies that uses-allocator construction of a <i>cv</i>-qualified type may still be required to be 
well-formed.
<p/>
Should we make such construction ill-formed?
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.</p>
<p>Not all uses-allocator construction is done using <code>construct_at</code>.
<code>std::tuple&lt;const T&gt;(allocator_arg, alloc)</code> does
uses-allocator construction of a const type, so we can't make it ill-formed.
</p>



<p id="res-3901"><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3908" href="3908">3908.</a> <code>enumerate_view::<i>iterator</i></code> constructor is explicit</h3>
<p><b>Section:</b> 26.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.iterator">[range.enumerate.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-03-23 <b>Last modified:</b> 2023-06-01 14:39:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.enumerate.iterator">active issues</a> in [range.enumerate.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>enumerate_view::<i>iterator</i></code> has this constructor:
</p>
<blockquote>
<pre><code>    constexpr explicit
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre>
</blockquote>

<p>
In <a href="https://wg21.link/P2164R9">P2164R9</a> the detailed description of the function showed a
default argument for the second parameter, which would justify it being
explicit. However, that default argument was not present in the class synopsis
and was removed from the detailed description when applying the paper to the
draft.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll.
</p>



<p id="res-3908"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>
<ol>
<li>
<p>
Modify the class synopsis in 26.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote><pre><code>
    constexpr <del>explicit</del>
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre></blockquote>
</li>

<li>
<p>
Modify the detailed description in 26.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote>
<pre><code>  constexpr <del>explicit</del> <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);
</code></pre>
<p>-2-
<i>Effects</i>: Initializes <code><i>current_</i></code>
with <code>std::move(current)</code> and <code><i>pos_</i></code> with
<code>pos</code>.
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3909" href="3909">3909.</a> Issues about <code>viewable_range</code></h3>
<p><b>Section:</b> 99 [ranges.refinements], 26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-06-01 14:31:30 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After LWG <a href="3724">3724</a>, <code>views::all</code> is well-constrained for view types,
and the constraints are stronger than <code>viewable_range</code>.
The difference is that given an expression such that <code>decltype</code> gives <code>R</code>,
when <code>decay_t&lt;R&gt;</code> is a view type and the implicit conversion of <code>R</code>
to <code>decay_t&lt;R&gt;</code> is forbidden, <code>views::all</code> rejects the expression,
but <code>viewable_range</code> may accept <code>R</code>.
So I think we should remove the additional constraints on <code>views::all_t</code>.
</p>
<p>
While <code>viewable_range</code> is probably not introducing any additional constraint within the standard library,
I think it is still useful to express the constraints on <code>views::all</code>,
so it should be slightly adjusted to match <code>views::all</code>.
</p>
<p>
Furthermore, <code>viewable_range</code> is currently used in 26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>,
but given <a href="https://wg21.link/P2378R3">P2378R3</a> relaxed the requirements for range adaptor closure objects,
I think we should also apply similar relaxation for range adaptor objects.
This should have no impact on standard range adaptor objects.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after three votes in favour during reflector poll.
</p>
<p>
"First change is pointless. Second change is a duplicate of <a href="3896">3896</a>.
Range adaptors return a view over their first argument, so they need to
require it's a <code>viewable_range</code>."
</p>



<p id="res-3909"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>
Change the definition of <code>views::all_t</code> in 26.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a> as indicated:
</p>
<blockquote><pre><code>
   template&lt;<del>viewable_range</del><ins>class</ins> R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));          // freestanding
</code></pre>
</blockquote>
</li>
<li>
<p>
Change the definition of <code>viewable_range</code> in 26.4.5 <a href="https://timsong-cpp.github.io/cppwp/range.refinements">[range.refinements]</a> as indicated:
</p>
<blockquote>
<p>-6-
The <code>viewable_range</code> concept specifies the requirements of a <code>range</code> type
that can be converted to a view safely.
</p>
<pre><code>
template&lt;class T&gt;
  concept viewable_range =
    range&lt;T&gt; &amp;&amp;
    ((view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; <del>constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</del> <ins>convertible_to&lt;T, remove_cvref_t&lt;T&gt;&gt;</ins>) ||
     (!view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      (is_lvalue_reference_v&lt;T&gt; || (movable&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp; !<i>is-initializer-list</i>&lt;T&gt;))));
</code></pre>
</blockquote>
</li>
<li>
<p>
Change 26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> as indicated:
</p>
<blockquote>
<p>-6-
A <i>range adaptor object</i> is a customization point object (16.3.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a>)
that accepts a <code><del>viewable_range</del><ins>range</ins></code> as its first argument
and returns a view.
</p>
<p>
[&hellip;]
</p>
<p>-8-
If a range adaptor object <code>adaptor</code> accepts more than one argument,
then let <code>range</code> be an expression such that <code>decltype((range))</code>
models <code><del>viewable_range</del><ins>range</ins></code>,
let <code>args...</code> be arguments such that <code>adaptor(range, args...)</code>
is a well-formed expression as specified in the rest of subclause 26.7 <a href="https://timsong-cpp.github.io/cppwp/range.adaptors">[range.adaptors]</a>,
and let <code>BoundArgs</code> be a pack that denotes <code>decay_t&lt;decltype((args))&gt;...</code>.
The expression <code>adaptor(args...)</code> produces a range adaptor closure object
<code>f</code> that is a perfect forwarding call wrapper (22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>)
with the following properties: [...]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3930" href="3930">3930.</a> Simplify type trait wording</h3>
<p><b>Section:</b> 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-05-01 <b>Last modified:</b> 2023-06-01 14:21:36 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are many traits that have a requirement that they are instantiated only if
"<tt>T</tt> shall be a complete type, <i>cv</i> <tt>void</tt>, or an array of unknown bound."
<p/>
Breaking down what this means, by supporting <i>cv</i>-<tt>void</tt> and arrays of unknown
bound (almost) the only remaining type-category is incomplete class types.
<p/>
The remaining edge case is incomplete enumerations, but they are required to
have a known fixed-base, so act as complete types, they can be copied,
assigned, etc., without knowing the names of their enumerators.
<p/>
Hence, I suggest clearer wording would be:
"<tt>T</tt> shall not be an incomplete class type."
<p/>
This is easier to understand, as we do not need to mentally enumerate every
type against a list to check it qualifies; it is a simpler test for the library to
check if we were to mandate these restrictions.
<p/>
There are a very small number of traits with subtly different wording, where
incomplete unions are supported, or arrays of unknown bound are not a
concern due to invoking <tt>remove_all_extents</tt> first. The bulk of the changes
can be made to traits with only the precise wording above though, and then
we can review whether any of the remaining restrictions deserve a wording
update of their own.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll,
including a request to withdraw the issue from the submitter.
</p>
<p>
Incomplete enumeration types are found within the <i>enum-specifier</i>
of an enum without a fixed underlying type:
<pre><code>
enum E {
    A = sizeof(E) // error, E is incomplete at this point
};
</code></pre>
and we definitely can't provide an underlying type for this case.
</p>



<p id="res-3930"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>
Throughout 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> replace all occurrences of
</p>
<blockquote><p>
<tt>T</tt> shall be a complete type, <i>cv</i> <tt>void</tt>, or an array of unknown bound.
</p></blockquote>
<p>
by
</p>
<blockquote><p>
<tt>T</tt> shall not be an incomplete class type.
</p></blockquote>

</li>

</ol>





<hr>
<h3><a name="3936" href="3936">3936.</a> Are implementations allowed to deprecate components not in [depr]?</h3>
<p><b>Section:</b> D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-22 <b>Last modified:</b> 2023-06-01 14:06:41 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
D.1 <a href="https://timsong-cpp.github.io/cppwp/depr.general">[depr.general]</a>/2 allows implementations to apply the
<code>deprecated</code> attribute to deprecated components.
However, there doesn't seem to be any wording disallowing applying the
<code>deprecated</code> attribute to non-deprecated components.
</p>
<p>
Is it intended to allow implementations to deprecate every library component
as they want? If so, should we turn the allowance into "<i>Recommended practice</i>" and move it to somewhere in 16.4 <a href="https://timsong-cpp.github.io/cppwp/requirements">[requirements]</a>?
</p>
<p>
There doesn't seem to be wording which formally recommends applying
<code>deprecated</code> attribute to deprecated components either.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after nine votes in favour during reflector poll.
Let implementations decide when to apply these attributes.
</p>



<p id="res-3936"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i>
There are two mutually exclusive proposed resolutions,
depending on whether it is allowed to deprecate components not in
D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a>.
</p>
</blockquote>

<p><strong>Option A:</strong></p>

<ol>
<li>
<p>Insert a paragraph at the end of 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- <i>Recommended practice</i>:
Implementations should not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a>.
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>

<p><strong>Option B:</strong></p>

<ol>
<li>
<p>Insert two paragraphs at the end of 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- Implementations shall not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a>.
</ins>
</p>
<p>
<ins>-?- <i>Recommended practice</i>:
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>





</body>
</html>
