<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2018-03-12 at 13:03:27 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2970" href="2970">2970.</a> Return type of <tt>std::visit</tt> misspecified</h3>
<p><b>Section:</b> 23.7.7 <a href="https://timsong-cpp.github.io/cppwp/variant.visit">[variant.visit]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-05-31 <b>Last modified:</b> 2018-03-03 17:19:23 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.visit">active issues</a> in [variant.visit].</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.visit">issues</a> in [variant.visit].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[variant.visit]/1 correctly uses "type and value category", but then
p3 describes the return type of <tt>visit</tt> to be "the common type of all
possible <tt><i>INVOKE</i></tt> expressions of the <i>Effects:</i> element." 
The type of an expression is never a reference type, due to [expr]/5 removing the
referenceness "prior to any further analysis", so this wording as
written says that <tt>visit</tt> always returns a non-reference type, which is
presumably not the intent.
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Priority 2; Matt to provide wording</p>

<p><i>[2018-01-11, Thomas K&ouml;ppe comments and suggests wording]</i></p>

<p>
The return type of <tt>std::visit</tt> (originating by <a href="http://wg21.link/p0088r3">P0088R3</a> 
accepted during the Oulo 2016 meeting) is currently misspecified and refers only to the common 
<em>type</em> of all the possible visitation calls, without attention to the value category. This 
seems unintended, and we should preserve the value category.
</p>

<p><i>[2017-01-24, Daniel comments]</i></p>

<p>
This issue should be reviewed in common with LWG <a href="3052">3052</a>.
</p>

<p><i>[
2018-02-23 Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4727">N4727</a>.</p>

<ol>
<li><p>Modify 23.7.7 <a href="https://timsong-cpp.github.io/cppwp/variant.visit">[variant.visit]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Visitor, class... Variants&gt;
  constexpr <i>see below</i> visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Returns:</i> <tt><i>e</i>(<i>m</i>)</tt>, where <tt><i>m</i></tt> is the pack for which 
<tt><i>m<sub>i</sub></i></tt> is <tt>vars<i><sub>i</sub></i>.index()</tt> for all 
<tt>0 &lt;= i &lt; n</tt>. The return type is <del>the type of 
<tt><i>e</i>(<i>m</i>)</tt></del><ins><tt>decltype(<i>e</i>(<i>m</i>))</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3062" href="3062">3062.</a> Unnecessary <tt>decay_t</tt> in <tt>is_execution_policy_v</tt> should be <tt>remove_cvref_t</tt></h3>
<p><b>Section:</b> 28.4.5 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.overloads">[algorithms.parallel.overloads]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-02-07 <b>Last modified:</b> 2018-02-13 19:42:20 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Our compiler throughput friends were hissing at us about throughput regressions in C++17 mode caused by 
the addition of the parallel algorithms' signatures. One change to reduce the throughput impact would 
be to remove unnecessary decay here, as LWG has done in other places recently.
</p>

<p><i>[
2018-02-13 Moved to Tentatively Ready after 7 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4713">N4713</a>.</p>

<ol>
<li><p>Modify 28.4.5 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.overloads">[algorithms.parallel.overloads]</a> as indicated:</p>

<blockquote>
<p>
-4- Parallel algorithms shall not participate in overload resolution unless 
<tt>is_execution_policy_v&lt;<del>decay</del><ins>remove_cvref</ins>_t&lt;ExecutionPolicy&gt;&gt;</tt> 
is <tt>true</tt>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3067" href="3067">3067.</a> <tt>recursive_directory_iterator::pop</tt> must invalidate</h3>
<p><b>Section:</b> 30.11.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-02-25 <b>Last modified:</b> 2018-03-07 17:22:08 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fs.rec.dir.itr.members">active issues</a> in [fs.rec.dir.itr.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.rec.dir.itr.members">issues</a> in [fs.rec.dir.itr.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>recursive_directory_iterator::pop</tt> is effectively a "supercharged" <tt>operator++</tt>: it
advances the iterator forward as many steps as are necessary to reach the next entry in the parent
directory. Just as is the case for <tt>operator++</tt>, <tt>pop</tt> must be allowed to invalidate
iterator copies to allow efficient implementation. The most efficient fix seems to be borrowing the
invalidation wording from 27.2.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> Table 87's specification for the required
<tt>++r</tt> expression for input iterators.
</p>

<p><i>[
2018-03-06 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li><p>Change 30.11.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> as indicated:</p>
<blockquote>
<pre>
void pop();
void pop(error_code&amp; ec);
</pre>
<blockquote>
<p>
-26- <i>Effects</i>: If <tt>depth() == 0</tt>, set <tt>*this</tt> to
<tt>recursive_directory_iterator()</tt>. Otherwise, cease iteration of the directory currently being
iterated over, and continue iteration over the parent directory.
</p>
<p>
<ins>-?- <i>Postconditions</i>: Any copies of the previous value of <tt>*this</tt> are no longer
required either to be dereferenceable or to be in the domain of <tt>==</tt>.</ins>
</p>
<p>
-27- <i>Throws</i>: As specified in 30.11.6 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3071" href="3071">3071.</a> [networking.ts] <tt>read_until</tt> still refers to "input sequence"</h3>
<p><b>Section:</b> 84 [networking.ts::buffer.read.until] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2018-02-26 <b>Last modified:</b> 2018-03-07 17:16:45 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses: networking.ts</b>
<p>
When specifying <tt>DynamicBuffers</tt> and their related operations, early drafts of the Networking TS described the buffers in terms of their "input sequence" and "output sequence". This was changed to "readable bytes" and "writable bytes" respectively. Unfortunately, some instances of "input sequence" were missed in section 
84 [networking.ts::buffer.read.until].
</p>

<p><i>[
2018-03-06 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4711">N4711</a>.
</p>

<ol>
<li><p>Change 84 [networking.ts::buffer.read.until] as indicated:</p>
<blockquote>
<pre>
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, char delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                    char delim, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b, string_view delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;&amp; b,
                    string_view delim, error_code&amp; ec);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Reads data from the buffer-oriented synchronous read stream 
(84 [networking.ts::buffer.stream.reqmts.syncreadstream]) object stream by performing zero or more 
calls to the stream's <tt>read_some</tt> member function, until the 
<del>input sequence</del><ins>readable bytes</ins> of the dynamic buffer 
(84 [networking.ts::buffer.reqmts.dynamicbuffer]) object <tt>b</tt> contain<del>s</del> the specified 
delimiter <tt>delim</tt>.
<p/>
-2- Data is placed into the dynamic buffer object b. A mutable buffer sequence (16.2.1) is obtained 
prior to each <tt>read_some</tt> call using <tt>b.prepare(N)</tt>, where <tt>N</tt> is an unspecified 
value such that <tt>N &lt;= max_size() - size()</tt>. [<i>Note:</i> Implementations are encouraged to use
<tt>b.capacity()</tt> when determining <tt>N</tt>, to minimize the number of <tt>read_some</tt>
calls performed on the stream. &mdash; <i>end note</i>] After each <tt>read_some</tt> call, 
the implementation performs <tt>b.commit(n)</tt>, where <tt>n</tt> is the return value from
<tt>read_some</tt>.
<p/>
-3- The synchronous <tt>read_until</tt> operation continues until:
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; the <del>input sequence</del><ins>readable bytes</ins> of <tt>b</tt> contain<del>s</del> 
the delimiter <tt>delim</tt>; or</p></li>
<li><p>(3.2) &mdash; <tt>b.size() == b.max_size()</tt>; or</p></li>
<li><p>(3.3) &mdash; an asynchronous <tt>read_some</tt> operation fails.</p></li>
</ol>
<p/>
-4- On exit, if the <del>input sequence</del><ins>readable bytes</ins> of <tt>b</tt> contain<del>s</del> 
the delimiter, <tt>ec</tt> is set such that <tt>!ec</tt> is <tt>true</tt>. Otherwise, if 
<tt>b.size() == b.max_size()</tt>, <tt>ec</tt> is set such that <tt>ec == stream_errc::not_found</tt>. 
If <tt>b.size() &lt; b.max_size()</tt>, <tt>ec</tt> contains the <tt>error_code</tt> from the most 
recent <tt>read_some</tt> call.
<p/>
-5- <i>Returns:</i> The number of <del>bytes in the input sequence of</del><ins>readable bytes in</ins> 
<tt>b</tt> up to and including the delimiter, if present. [<i>Note:</i> On completion, the buffer may 
contain additional bytes following the delimiter. &mdash; <i>end note</i>] Otherwise returns <tt>0</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3074" href="3074">3074.</a> Non-member functions for <tt>valarray</tt> should only deduce from the <tt>valarray</tt></h3>
<p><b>Section:</b> 29.7.3 <a href="https://timsong-cpp.github.io/cppwp/valarray.nonmembers">[valarray.nonmembers]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-02-28 <b>Last modified:</b> 2018-03-12 12:37:45 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>The expression <tt>(std::valarray&lt;double&gt;{} * 2)</tt> is ill-formed, because argument deduction 
fails for:</p>
<blockquote><pre>
template&lt;class T&gt;
  valarray&lt;T&gt; operator*(const valarray&lt;T&gt;&amp;, const T&amp;);
</pre></blockquote>
<p>
Is there any reason to try and deduce the argument from the scalar, instead of only deducing from the valarray and allowing implicit conversions to the scalar? i.e.
</p>
<blockquote><pre>
template&lt;class T&gt; 
  valarray&lt;T&gt; operator*(const valarray&lt;T&gt;&amp;, const typename valarray&lt;T&gt;::value_type&amp;);
</pre></blockquote>

<p><i>[
2018-03-07 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li>
<p>Edit 29.7.1 <a href="https://timsong-cpp.github.io/cppwp/valarray.syn">[valarray.syn]</a>, header <tt>&lt;valarray&gt;</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
template&lt;class T&gt; valarray&lt;T&gt; operator* (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator* (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator* (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator/ (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator/ (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator/ (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator% (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator% (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator% (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator+ (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator+ (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator+ (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator- (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator- (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator- (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator^ (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator^ (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator^ (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator| (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator| (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator| (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;bool&gt; operator||(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator||(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator||(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;bool&gt; operator==(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator==(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator==(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; abs (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; acos (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; asin (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan (const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; cos (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; cosh (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; exp (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; log (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; log10(const valarray&lt;T&gt;&amp;);

template&lt;class T&gt; valarray&lt;T&gt; pow(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>Edit 29.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/valarray.binary">[valarray.binary]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
template&lt;class T&gt; valarray&lt;T&gt; operator* (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator* (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator/ (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator/ (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator% (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator% (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator+ (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator+ (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator- (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator- (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator^ (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator^ (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&amp; (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator| (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator| (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&lt;&lt;(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; operator&gt;&gt;(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>Edit 29.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/valarray.comparison">[valarray.comparison]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
template&lt;class T&gt; valarray&lt;bool&gt; operator==(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator==(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator!=(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt; (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt; (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&lt;=(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&gt;=(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator&amp;&amp;(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator||(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;bool&gt; operator||(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>Edit 29.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/valarray.transcend">[valarray.transcend]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T&gt; valarray&lt;T&gt; abs (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; acos (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; asin (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; cos (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; cosh (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; exp (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; log (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; log10(const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow (const valarray&lt;T&gt;&amp;, const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow (const <del>T</del><ins>typename valarray&lt;T&gt;::value_type</ins>&amp;, const valarray&lt;T&gt;&amp;);
[&hellip;]
</pre>
</blockquote>
</li>
</ol>





</body>
</html>
