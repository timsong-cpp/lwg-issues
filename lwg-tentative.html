<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p><p>Revised 2023-11-05 at 11:06:54 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2457" href="2457">2457.</a> <tt>std::begin()</tt> and <tt>std::end()</tt> do not support multi-dimensional arrays correctly</h3>
<p><b>Section:</b> 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Janez &#x17d;emva <b>Opened:</b> 2014-11-16 <b>Last modified:</b> 2023-04-06 13:59:48 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

int main() 
{
  int a[2][3][4] = { { { 1,  2,  3,  4}, { 5,  6,  7,  8}, { 9, 10, 11, 12} },
                     { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } };
  int b[2][3][4];

  assert(std::distance(std::begin(a), std::end(a)) == 2 * 3 * 4);
  std::copy(std::begin(a), std::end(a), std::begin(b));
  std::copy(std::begin(b), std::end(b), std::ostream_iterator&lt;int&gt;(std::cout, ","));
}
</pre></blockquote>
<p>
does not compile. 
<p/>
A possible way to remedy this would be to add the following overloads of
<tt>begin</tt>, <tt>end</tt>, <tt>rbegin</tt>, and <tt>rend</tt> to 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>, 
relying on recursive evaluation:
</p>
<blockquote><pre>
namespace std {

  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  begin(T (&amp;array)[M][N])
  {
    return begin(*array);
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  end(T (&amp;array)[M][N])
  {
    return end(array[M - 1]);
  }

  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rbegin(T (&amp;array)[M][N])
  {
    return decltype(rbegin(array))(end(array[M - 1]));
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rend(T (&amp;array)[M][N])
  {
    return decltype(rend(array))(begin(*array));
  }

}
</pre></blockquote>

<p><i>[2023-04-06; LWG reflector poll in November 2021]</i></p>

<p>
Changed to Tentatively NAD after 12 votes in favour.
Use <code>views::join</code> or <code>mdspan</code> instead.
</p>



<p id="res-2457"><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3635" href="3635">3635.</a> Add <tt>__cpp_lib_deduction_guides</tt> to feature test macros</h3>
<p><b>Section:</b> 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Konstantin Varlamov <b>Opened:</b> 2021-11-09 <b>Last modified:</b> 2023-05-24 14:08:46 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P0433R2">P0433R2</a>, the proposal for adding deduction guides to the standard library, contained a 
recommendation to use <tt>__cpp_lib_deduction_guides</tt> as a feature test macro. However, it appears that this feature test macro has been accidentally omitted from the Standard when the paper was applied and probably needs to be added back.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;deque&gt;, &lt;forward_list&gt;, &lt;list&gt;, &lt;map&gt;, &lt;queue&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2021-11-16; Konstantin Varlamov comments and improves wording]</i></p>

<p>
One potential topic of discussion is whether the new feature test macro needs to be defined in every library 
header that contains an explicit deduction guide. While this would be consistent with the current approach, 
no other macro is associated with such a large set of headers (20 headers in total, whereas the current 
record-holder is <tt>__cpp_lib_nonmember_container_access</tt> with 12 headers). For this reason, it should 
be considered whether perhaps the new macro should only be defined in <tt>&lt;version&gt;</tt> (which would, 
however, make it an outlier). The proposed wording currently contains an exhaustive list (note that the 
deduction guides for <tt>&lt;mutex&gt;</tt> were removed by LWG <a href="2981">2981</a>).
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Several votes for NAD as it's too late to be useful, and code which needs
to be portable to pre-CTAD compilers can just not use CTAD.
</p>

<p><i>[2023-04-21; Reflector poll for 'Tentatively NAD']</i></p>

<p><i>[
"We keep changing the deduction guides, and different libraries might be
conformant in some headers and not others. The status cannot be represented
by a single number."
]</i></p>




<p id="res-3635"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine          201902L  <i>// also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_deduction_guides   201703L
  <i>// also in &lt;array&gt;, &lt;deque&gt;, &lt;forward_list&gt;, &lt;functional&gt;, &lt;list&gt;, &lt;map&gt;,
  // &lt;memory&gt;, &lt;optional&gt;, &lt;queue&gt;, &lt;regex&gt;, &lt;scoped_allocator&gt;, &lt;set&gt;, &lt;stack&gt;,
  // &lt;string&gt;, &lt;tuple&gt;, &lt;unordered_map&gt;, &lt;unordered_set&gt;, &lt;utility&gt;, &lt;valarray&gt;,
  // &lt;vector&gt;</i></ins>
#define __cpp_lib_destroying_delete  201806L  <i>// also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3714" href="3714">3714.</a> Non-single-argument constructors for range adaptors should not be <tt>explicit</tt></h3>
<p><b>Section:</b> 26.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.transform.view">[range.zip.transform.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-10 <b>Last modified:</b> 2023-01-24 10:14:05 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All C++20 range adaptors' non-single-argument constructors are not declared as <tt>explicit</tt>, which makes 
the following initialization well-formed:
</p>
<blockquote><pre>
std::vector v{42};
std::ranges::take_view r1 = {v, 1};
std::ranges::filter_view r2 = {v, [](int) { return true; }};
</pre></blockquote>
<p>
However, the non-single-argument constructors of C++23 range adaptors, except for <tt>join_with_view</tt>, 
are all <tt>explicit</tt>, which makes us no longer able to
</p>
<blockquote><pre>
std::ranges::chunk_view r1 = {v, 1}; // <span style="color:red;font-weight:bolder">ill-formed</span>
std::ranges::chunk_by_view r2 = {v, [](int, int) { return true; }}; // <span style="color:red;font-weight:bolder">ill-formed</span>
</pre></blockquote>
<p>
This seems unnecessary since I don't see the observable benefit of preventing this. In the standard, 
non-single-argument constructors are rarely specified as <tt>explicit</tt> unless it is really undesirable, 
I think the above initialization is what the user expects since it's clearly intentional, and I don't see 
any good reason to reject it from C++23.
</p>
<p><i>[2022-06-11; Daniel comments]</i></p>

<p>
Another possible candidate could be 26.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.take.while.sentinel">[range.take.while.sentinel]</a>'s
</p>
<blockquote><pre>
constexpr explicit <i>sentinel</i>(sentinel_t&lt;<i>Base</i>&gt; end, const Pred* pred);
</pre></blockquote>

<p><i>[2022-06-21; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Send to LEWG.
</p>

<p><i>[2023-01-24; LEWG in Kona]</i></p>

<p>Use alternative approach in <a href="https://wg21.link/P2711">P2711</a> instead.</p>



<p id="res-3714"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 26.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.transform.view">[range.zip.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view : public view_interface&lt;zip_transform_view&lt;F, Views...&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                   <i>// exposition only</i>
    zip_view&lt;Views...&gt; <i>zip_</i>;                <i>// exposition only</i>
    [&hellip;]
  public:
    zip_transform_view() = default;

    constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>fun_</i></tt> with <tt>std::move(fun)</tt> and <tt><i>zip_</i></tt> 
with <tt>std::move(views)...</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.view">[range.adjacent.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view : public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                       <i>// exposition only</i>
    adjacent_view&lt;V, N&gt; <i>inner_</i>;                 <i>// exposition only</i>
    [&hellip;]
  public:
    adjacent_transform_view() = default;
    constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>fun_</i></tt> with <tt>std::move(fun)</tt> and 
<tt><i>inner_</i></tt> with <tt>std::move(base)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.input">[range.chunk.view.input]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                                        <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;                         <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <tt>n &gt; 0</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.6 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.fwd">[range.chunk.view.fwd]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt; : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <tt>n &gt; 0</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.29.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    slide_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.30.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.by.view">[range.chunk.by.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view : public view_interface&lt;chunk_by_view&lt;V, Pred&gt;&gt; {
    V <i>base_</i> = V();                                <i>// exposition only</i>
    <i>copyable-box</i>&lt;Pred&gt; <i>pred_</i> = Pred();            <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_by_view() requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pred&gt; = default;
    constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>pred_</i></tt> with <tt>std::move(pred)</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3901" href="3901">3901.</a> Is uses-allocator construction of a <i>cv</i>-qualified object type still well-formed after LWG 3870?</h3>
<p><b>Section:</b> 20.2.8 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses">[allocator.uses]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-05 <b>Last modified:</b> 2023-03-22 22:35:08 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3870">3870</a> made <tt>std::construct_at</tt> unable to create an object of a <i>cv</i>-qualified type, 
which affects <tt>std::uninitialized_construct_using_allocator</tt>. However, uses-allocator construction is 
currently not required to be equivalent to some call to <tt>std::uninitialized_construct_using_allocator</tt>, 
which possibly implies that uses-allocator construction of a <i>cv</i>-qualified type may still be required to be 
well-formed.
<p/>
Should we make such construction ill-formed?
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.</p>
<p>Not all uses-allocator construction is done using <code>construct_at</code>.
<code>std::tuple&lt;const T&gt;(allocator_arg, alloc)</code> does
uses-allocator construction of a const type, so we can't make it ill-formed.
</p>



<p id="res-3901"><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3908" href="3908">3908.</a> <code>enumerate_view::<i>iterator</i></code> constructor is explicit</h3>
<p><b>Section:</b> 26.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.iterator">[range.enumerate.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-03-23 <b>Last modified:</b> 2023-06-01 14:39:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>enumerate_view::<i>iterator</i></code> has this constructor:
</p>
<blockquote>
<pre><code>    constexpr explicit
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre>
</blockquote>

<p>
In <a href="https://wg21.link/P2164R9">P2164R9</a> the detailed description of the function showed a
default argument for the second parameter, which would justify it being
explicit. However, that default argument was not present in the class synopsis
and was removed from the detailed description when applying the paper to the
draft.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll.
</p>



<p id="res-3908"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>
<ol>
<li>
<p>
Modify the class synopsis in 26.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote><pre><code>
    constexpr <del>explicit</del>
      <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);  <i>// exposition only</i>
</code></pre></blockquote>
</li>

<li>
<p>
Modify the detailed description in 26.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.iterator">[range.enumerate.iterator]</a>
as shown:
</p>
<blockquote>
<pre><code>  constexpr <del>explicit</del> <i>iterator</i>(iterator_t&lt;<i>Base</i>&gt; current, difference_type pos);
</code></pre>
<p>-2-
<i>Effects</i>: Initializes <code><i>current_</i></code>
with <code>std::move(current)</code> and <code><i>pos_</i></code> with
<code>pos</code>.
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3909" href="3909">3909.</a> Issues about <code>viewable_range</code></h3>
<p><b>Section:</b> 99 [ranges.refinements], 26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-06-01 14:31:30 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After LWG <a href="3724">3724</a>, <code>views::all</code> is well-constrained for view types,
and the constraints are stronger than <code>viewable_range</code>.
The difference is that given an expression such that <code>decltype</code> gives <code>R</code>,
when <code>decay_t&lt;R&gt;</code> is a view type and the implicit conversion of <code>R</code>
to <code>decay_t&lt;R&gt;</code> is forbidden, <code>views::all</code> rejects the expression,
but <code>viewable_range</code> may accept <code>R</code>.
So I think we should remove the additional constraints on <code>views::all_t</code>.
</p>
<p>
While <code>viewable_range</code> is probably not introducing any additional constraint within the standard library,
I think it is still useful to express the constraints on <code>views::all</code>,
so it should be slightly adjusted to match <code>views::all</code>.
</p>
<p>
Furthermore, <code>viewable_range</code> is currently used in 26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>,
but given <a href="https://wg21.link/P2378R3">P2378R3</a> relaxed the requirements for range adaptor closure objects,
I think we should also apply similar relaxation for range adaptor objects.
This should have no impact on standard range adaptor objects.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after three votes in favour during reflector poll.
</p>
<p>
"First change is pointless. Second change is a duplicate of <a href="3896">3896</a>.
Range adaptors return a view over their first argument, so they need to
require it's a <code>viewable_range</code>."
</p>



<p id="res-3909"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>
Change the definition of <code>views::all_t</code> in 26.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a> as indicated:
</p>
<blockquote><pre><code>
   template&lt;<del>viewable_range</del><ins>class</ins> R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));          // freestanding
</code></pre>
</blockquote>
</li>
<li>
<p>
Change the definition of <code>viewable_range</code> in 26.4.5 <a href="https://timsong-cpp.github.io/cppwp/range.refinements">[range.refinements]</a> as indicated:
</p>
<blockquote>
<p>-6-
The <code>viewable_range</code> concept specifies the requirements of a <code>range</code> type
that can be converted to a view safely.
</p>
<pre><code>
template&lt;class T&gt;
  concept viewable_range =
    range&lt;T&gt; &amp;&amp;
    ((view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; <del>constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</del> <ins>convertible_to&lt;T, remove_cvref_t&lt;T&gt;&gt;</ins>) ||
     (!view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      (is_lvalue_reference_v&lt;T&gt; || (movable&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp; !<i>is-initializer-list</i>&lt;T&gt;))));
</code></pre>
</blockquote>
</li>
<li>
<p>
Change 26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> as indicated:
</p>
<blockquote>
<p>-6-
A <i>range adaptor object</i> is a customization point object (16.3.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a>)
that accepts a <code><del>viewable_range</del><ins>range</ins></code> as its first argument
and returns a view.
</p>
<p>
[&hellip;]
</p>
<p>-8-
If a range adaptor object <code>adaptor</code> accepts more than one argument,
then let <code>range</code> be an expression such that <code>decltype((range))</code>
models <code><del>viewable_range</del><ins>range</ins></code>,
let <code>args...</code> be arguments such that <code>adaptor(range, args...)</code>
is a well-formed expression as specified in the rest of subclause 26.7 <a href="https://timsong-cpp.github.io/cppwp/range.adaptors">[range.adaptors]</a>,
and let <code>BoundArgs</code> be a pack that denotes <code>decay_t&lt;decltype((args))&gt;...</code>.
The expression <code>adaptor(args...)</code> produces a range adaptor closure object
<code>f</code> that is a perfect forwarding call wrapper (22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>)
with the following properties: [...]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3930" href="3930">3930.</a> Simplify type trait wording</h3>
<p><b>Section:</b> 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-05-01 <b>Last modified:</b> 2023-06-01 14:21:36 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are many traits that have a requirement that they are instantiated only if
"<tt>T</tt> shall be a complete type, <i>cv</i> <tt>void</tt>, or an array of unknown bound."
<p/>
Breaking down what this means, by supporting <i>cv</i>-<tt>void</tt> and arrays of unknown
bound (almost) the only remaining type-category is incomplete class types.
<p/>
The remaining edge case is incomplete enumerations, but they are required to
have a known fixed-base, so act as complete types, they can be copied,
assigned, etc., without knowing the names of their enumerators.
<p/>
Hence, I suggest clearer wording would be:
"<tt>T</tt> shall not be an incomplete class type."
<p/>
This is easier to understand, as we do not need to mentally enumerate every
type against a list to check it qualifies; it is a simpler test for the library to
check if we were to mandate these restrictions.
<p/>
There are a very small number of traits with subtly different wording, where
incomplete unions are supported, or arrays of unknown bound are not a
concern due to invoking <tt>remove_all_extents</tt> first. The bulk of the changes
can be made to traits with only the precise wording above though, and then
we can review whether any of the remaining restrictions deserve a wording
update of their own.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after four votes in favour during reflector poll,
including a request to withdraw the issue from the submitter.
</p>
<p>
Incomplete enumeration types are found within the <i>enum-specifier</i>
of an enum without a fixed underlying type:
<pre><code>
enum E {
    A = sizeof(E) // error, E is incomplete at this point
};
</code></pre>
and we definitely can't provide an underlying type for this case.
</p>



<p id="res-3930"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>
Throughout 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> replace all occurrences of
</p>
<blockquote><p>
<tt>T</tt> shall be a complete type, <i>cv</i> <tt>void</tt>, or an array of unknown bound.
</p></blockquote>
<p>
by
</p>
<blockquote><p>
<tt>T</tt> shall not be an incomplete class type.
</p></blockquote>

</li>

</ol>





<hr>
<h3><a name="3936" href="3936">3936.</a> Are implementations allowed to deprecate components not in [depr]?</h3>
<p><b>Section:</b> D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-22 <b>Last modified:</b> 2023-06-01 14:06:41 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
D.1 <a href="https://timsong-cpp.github.io/cppwp/depr.general">[depr.general]</a>/2 allows implementations to apply the
<code>deprecated</code> attribute to deprecated components.
However, there doesn't seem to be any wording disallowing applying the
<code>deprecated</code> attribute to non-deprecated components.
</p>
<p>
Is it intended to allow implementations to deprecate every library component
as they want? If so, should we turn the allowance into "<i>Recommended practice</i>" and move it to somewhere in 16.4 <a href="https://timsong-cpp.github.io/cppwp/requirements">[requirements]</a>?
</p>
<p>
There doesn't seem to be wording which formally recommends applying
<code>deprecated</code> attribute to deprecated components either.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after nine votes in favour during reflector poll.
Let implementations decide when to apply these attributes.
</p>



<p id="res-3936"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i>
There are two mutually exclusive proposed resolutions,
depending on whether it is allowed to deprecate components not in
D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a>.
</p>
</blockquote>

<p><strong>Option A:</strong></p>

<ol>
<li>
<p>Insert a paragraph at the end of 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- <i>Recommended practice</i>:
Implementations should not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a>.
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>

<p><strong>Option B:</strong></p>

<ol>
<li>
<p>Insert two paragraphs at the end of 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>:</p>

<blockquote>
<p>
<ins>
-?- Implementations shall not apply the <code>deprecated</code> attribute
(9.12.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr.deprecated">[dcl.attr.deprecated]</a>) to library entities that are not
specified in D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a>.
</ins>
</p>
<p>
<ins>-?- <i>Recommended practice</i>:
Implementations should apply the <code>deprecated</code> attribute to
library entities specified in D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> whenever possible.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3947" href="3947">3947.</a> Unexpected constraints on <tt>adjacent_transform_view::base()</tt></h3>
<p><b>Section:</b> 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.view">[range.adjacent.transform.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2023-06-17 <b>Last modified:</b> 2023-10-27 21:22:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.view">[range.adjacent.transform.view]</a> the class
<tt>ranges::adjacent_transform_view</tt> got two new <tt>base()</tt> members from
<a href="3848">3848</a>.
<p/>
The first one looks like
</p>
<blockquote><pre>
constexpr V base() const &amp; requires copy_constructible&lt;<i>InnerView</i>&gt;
{ return <i>inner_</i>.base(); }
</pre></blockquote>
<p>
Here the requirement is that <tt><i>InnerView</i></tt> is copy constructible, when it in
fact returns an object of type <tt>V</tt>. That seems odd.
<p/>
I would expect the constraint to instead be <tt>copy_constructible&lt;V&gt;</tt>.
</p>

<p><i>[2023-10-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3947"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li><p>Modify 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.view">[range.adjacent.transform.view]</a>, class template 
<tt>adjacent_transform_view</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, move_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
      regular_invocable&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
      <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view : public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    [&hellip;]
    adjacent_view&lt;V, N&gt; <i>inner_</i>; // <i>exposition only</i>
    
    using <i>InnerView</i> = adjacent_view&lt;V, N&gt;; // <i>exposition only</i>
    [&hellip;]
  public:
    [&hellip;]
    constexpr V base() const &amp; requires copy_constructible&lt;<ins>V</ins><del><i>InnerView</i></del>&gt; { return <i>inner_</i>.base(); }
    constexpr V base() &amp;&amp; { return std::move(<i>inner_</i>).base(); }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3948" href="3948">3948.</a> <tt><i>possibly-const-range</i></tt> and <tt><i>as-const-pointer</i></tt> should be <tt>noexcept</tt></h3>
<p><b>Section:</b> 26.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, 26.3.14 <a href="https://timsong-cpp.github.io/cppwp/range.prim.cdata">[range.prim.cdata]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-06-20 <b>Last modified:</b> 2023-10-27 21:22:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ranges.syn">active issues</a> in [ranges.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#ranges.syn">issues</a> in [ranges.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of <a href="https://wg21.link/P2278R4">P2278R4</a>, several range access CPOs are specified with <tt><i>possibly-const-range</i></tt> 
and <tt><i>as-const-pointer</i></tt>. These helper functions never throw exceptions, but are not marked with 
<tt>noexcept</tt>. As a result, implementations are currently allowed to make a call to 
<tt>ranges::c<i>cpo</i></tt> potentially throwing while the underlying <tt>ranges::<i>cpo</i></tt> call is 
non-throwing, which doesn't seem to be intended.
</p>

<p><i>[2023-10-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3948"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li><p>Modify 26.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, header <tt>&lt;ranges&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
// <i>26.7.21 <a href="https://timsong-cpp.github.io/cppwp/range.as.const">[range.as.const]</a>, as const view</i>
template&lt;input_range R&gt;
  constexpr auto&amp; <i>possibly-const-range</i>(R&amp; r) <ins>noexcept</ins> {      // <i>exposition only</i>
    if constexpr (constant_range&lt;const R&gt; &amp;&amp; !constant_range&lt;R&gt;) {
      return const_cast&lt;const R&amp;&gt;(r);
    } else {
      return r;
    }
  }
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 26.3.14 <a href="https://timsong-cpp.github.io/cppwp/range.prim.cdata">[range.prim.cdata]</a> before p1 as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
constexpr auto <i>as-const-pointer</i>(const T* p) <ins>noexcept</ins> { return p; }    // <i>exposition only</i>
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3949" href="3949">3949.</a> <tt>std::atomic&lt;bool&gt;</tt>'s trivial destructor dropped in C++17 spec wording</h3>
<p><b>Section:</b> 33.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic.general">[atomics.types.generic.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jeremy Hurwitz <b>Opened:</b> 2023-06-20 <b>Last modified:</b> 2023-10-27 21:22:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::atomic&lt;bool&gt;</tt> was originally required to have a trivial default constructor and a trivial destructor 
[C++11 <a href="https://wg21.link/N3337#page=1118">N3337</a>: Section [atomics.types.generic], Paragraph 5], 
the same as the integral [C++11 <a href="https://wg21.link/N3337#page=1118">N3337</a>: Section [atomics.types.generic], 
Paragraph 5] and pointer specializations [C++11 <a href="https://wg21.link/N3337#page=1119">N3337</a>: 
Section [atomics.types.generic], Paragraph 6]. <a href="https://wg21.link/P0558">P0558</a> rearranged the text, 
accidentally (as far as we can tell) removing the constructor and destructor requirements from <tt>std::atomic&lt;bool&gt;</tt>,
which has the surprising effect that <tt>std::atomic&lt;bool&gt;</tt> has no longer the same constructor/destructor 
guarantees as <tt>std::atomic&lt;int&gt;</tt>.
<p/>
C++20 removed the "trivial default constructor" requirement from all specializations. A specialization for floating-point 
types was added with a trivial destructor [<a href="https://wg21.link/N4861#page=1548">N4861</a>: Section [atomics.types.float], 
Paragraph 2)].
</p>

<p><i>[2023-10-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-3949"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li><p>Modify 33.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic.general">[atomics.types.generic.general]</a> as indicated:</p>

<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- The specialization <tt>atomic&lt;bool&gt;</tt> is a standard-layout struct. <ins>It has a trivial destructor.</ins>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3951" href="3951">3951.</a> &sect;[expected.object.swap]: Using <tt>value()</tt> instead of <tt>has_value()</tt></h3>
<p><b>Section:</b> 22.8.6.5 <a href="https://timsong-cpp.github.io/cppwp/expected.object.swap">[expected.object.swap]</a>, 22.8.7.5 <a href="https://timsong-cpp.github.io/cppwp/expected.void.swap">[expected.void.swap]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ben Craig <b>Opened:</b> 2023-06-25 <b>Last modified:</b> 2023-10-27 21:22:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.8.6.5 <a href="https://timsong-cpp.github.io/cppwp/expected.object.swap">[expected.object.swap]</a> p2 has the following text in it:
</p>
<blockquote><p>
For the case where <tt>rhs.value()</tt> is <tt>false</tt> and <tt>this-&gt;has_value()</tt> is <tt>true</tt>, equivalent to: [&hellip;]
</p></blockquote>
<p>
The table preceding that text is a table of <tt>this-&gt;has_value()</tt> vs. <tt>rhs.has_value()</tt>. The <tt>rhs.value()</tt> 
in the text is almost certainly a typo, as a <tt>.value()</tt> call here doesn't make any sense, especially if this is an 
<tt>expected&lt;<i>non-bool</i>, E&gt;</tt>.
<p/>
The same issue is there for 22.8.7.5 <a href="https://timsong-cpp.github.io/cppwp/expected.void.swap">[expected.void.swap]</a> p2.
</p>

<p><i>[2023-10-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-3951"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li><p>Modify 22.8.6.5 <a href="https://timsong-cpp.github.io/cppwp/expected.object.swap">[expected.object.swap]</a> as indicated:</p>


<blockquote>
<pre>
constexpr void swap(expected&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- <i>Effects</i>: See Table 63 [tab:expected.object.swap].
<p/>
For the case where <tt>rhs.<ins>has_</ins>value()</tt> is <tt>false</tt> and <tt>this-&gt;has_value()</tt> is <tt>true</tt>, equivalent to: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 22.8.7.5 <a href="https://timsong-cpp.github.io/cppwp/expected.void.swap">[expected.void.swap]</a> as indicated:</p>


<blockquote>
<pre>
constexpr void swap(expected&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- <i>Effects</i>: See Table 64 [tab:expected.void.swap].
<p/>
For the case where <tt>rhs.<ins>has_</ins>value()</tt> is <tt>false</tt> and <tt>this-&gt;has_value()</tt> is <tt>true</tt>, equivalent to: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="3953" href="3953">3953.</a> <tt>iter_move</tt> for <tt>common_iterator</tt> and <tt>counted_iterator</tt> should return <tt>decltype(auto)</tt></h3>
<p><b>Section:</b> 25.5.5.7 <a href="https://timsong-cpp.github.io/cppwp/common.iter.cust">[common.iter.cust]</a>, 25.5.7.7 <a href="https://timsong-cpp.github.io/cppwp/counted.iter.cust">[counted.iter.cust]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-06-30 <b>Last modified:</b> 2023-10-27 21:22:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Although the customized <tt>iter_move</tt> of both requires the underlying iterator <tt>I</tt> to be <tt>input_iterator</tt>, 
they still explicitly specify the return type as <tt>iter_rvalue_reference_t&lt;I&gt;</tt>,
which makes it always instantiated.
</p>
<p>
From the point of view that its validity is only specified in the <tt>input_iterator</tt> concept, it would be better to remove such 
unnecessary type instantiation, which does not make much sense for an <tt>output_iterator</tt> even if it is still valid.
</p>

<p><i>[2023-10-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3953"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li><p>Modify 25.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/common.iterator">[common.iterator]</a>, class template <tt>common_iterator</tt> synopsis, as indicated:</p>


<blockquote>
<pre>
namespace std {
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    requires (!same_as&lt;I, S&gt; &amp;&amp; copyable&lt;I&gt;)
  class common_iterator {
  public:
    [&hellip;]
    friend constexpr <del>iter_rvalue_reference_t&lt;I&gt;</del><ins>decltype(auto)</ins> iter_move(const common_iterator&amp; i)
      noexcept(noexcept(ranges::iter_move(declval&lt;const I&amp;&gt;())))
        requires input_iterator&lt;I&gt;;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.5.7 <a href="https://timsong-cpp.github.io/cppwp/common.iter.cust">[common.iter.cust]</a> as indicated:</p>

<blockquote>
<pre>
friend constexpr <del>iter_rvalue_reference_t&lt;I&gt;</del><ins>decltype(auto)</ins> iter_move(const common_iterator&amp; i)
  noexcept(noexcept(ranges::iter_move(declval&lt;const I&amp;&gt;())))
    requires input_iterator&lt;I&gt;;
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: [&hellip;]
<p/>
-2- <i>Effects</i>: Equivalent to: <tt>return ranges::iter_move(get&lt;I&gt;(i.v_));</tt>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 25.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/counted.iterator">[counted.iterator]</a>, class template <tt>counted_iterator</tt> synopsis, as indicated:</p>


<blockquote>
<pre>
namespace std {
  template&lt;input_or_output_iterator I&gt;
  class counted_iterator {
  public:
    [&hellip;]
    friend constexpr <del>iter_rvalue_reference_t&lt;I&gt;</del><ins>decltype(auto)</ins> iter_move(const counted_iterator&amp; i)
      noexcept(noexcept(ranges::iter_move(i.current)))
        requires input_iterator&lt;I&gt;;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.7.7 <a href="https://timsong-cpp.github.io/cppwp/counted.iter.cust">[counted.iter.cust]</a> as indicated:</p>

<blockquote>
<pre>
friend constexpr <del>iter_rvalue_reference_t&lt;I&gt;</del><ins>decltype(auto)</ins> 
  iter_move(const counted_iterator&amp; i)
    noexcept(noexcept(ranges::iter_move(i.current)))
    requires input_iterator&lt;I&gt;;
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: [&hellip;]
<p/>
-2- <i>Effects</i>: Equivalent to: <tt>return ranges::iter_move(i.current);</tt>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3957" href="3957">3957.</a> &sect;[container.alloc.reqmts] The value category of <tt>v</tt> should be claimed</h3>
<p><b>Section:</b> 24.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.alloc.reqmts">[container.alloc.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2023-07-10 <b>Last modified:</b> 2023-10-27 21:22:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.alloc.reqmts">active issues</a> in [container.alloc.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.alloc.reqmts">issues</a> in [container.alloc.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.alloc.reqmts">[container.alloc.reqmts]</a> p2 says:
</p>
<blockquote><p>
[&hellip;] an expression <tt>v</tt> of type <tt>T</tt> or <tt>const T</tt>, [&hellip;]
</p></blockquote>
<p>
Then 24.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.alloc.reqmts">[container.alloc.reqmts]</a> bullet (2.4) says:
</p>
<blockquote><p>
<tt>T</tt> is <i>Cpp17CopyInsertable into <tt>X</tt></i> means that, in addition to <tt>T</tt> being 
<i>Cpp17MoveInsertable</i> into <tt>X</tt>, the following expression is well-formed:
</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p, v)
</pre></blockquote>
</blockquote>
<p>
So, what is the value category of the expression <tt>v</tt>? We didn't explicitly phrase the wording. 
The intent may be that the value category of <tt>v</tt> is any defined value category in 7.2.1 <a href="https://timsong-cpp.github.io/cppwp/basic.lval">[basic.lval]</a>, 
however, the intent is not clear in the current wording. Maybe, we can say:
</p>
<blockquote><p>
[&hellip;] the following expression is well-formed:
</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p, v)
</pre></blockquote>
<p>
for <tt>v</tt> of any value category.
</p>
</blockquote>
<p>
which can make the intent meaning clearer.
</p>

<p><i>[2023-10-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3957"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>

<li><p>Modify 24.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.alloc.reqmts">[container.alloc.reqmts]</a> as indicated:</p>

<blockquote>
<p>
-2- Given an allocator type <tt>A</tt> and given a container type <tt>X</tt> having a <tt>value_type</tt> 
identical to <tt>T</tt> and an <tt>allocator_type</tt> identical to <tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;</tt> 
and given an lvalue <tt>m</tt> of type <tt>A</tt>, a pointer <tt>p</tt> of type <tt>T*</tt>, an expression 
<tt>v</tt> <ins>that denotes an lvalue</ins> of type <tt>T</tt> or <tt>const T</tt> <ins>or an rvalue of type <tt>const T</tt></ins>, 
and an rvalue <tt>rv</tt> of type <tt>T</tt>, the following terms are defined. [&hellip;]
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(2.3) &mdash; <tt>T</tt> is <i>Cpp17MoveInsertable into <tt>X</tt></i> means that the following expression is well-formed:</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p, rv)
</pre></blockquote>
<p>and its evaluation causes the following postcondition to hold: The value of <tt>*p</tt> is equivalent to the value
of <tt>rv</tt> before the evaluation.
<p/>
[<i>Note 1</i>: <tt>rv</tt> remains a valid object. Its state is unspecified &mdash; <i>end note</i>]</p></li>
<li><p>(2.4) &mdash; <tt>T</tt> is <i>Cpp17CopyInsertable into <tt>X</tt></i> means that, in addition to <tt>T</tt> being 
<i>Cpp17MoveInsertable</i> into <tt>X</tt>, the following expression is well-formed:</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p, v)
</pre></blockquote>
<p>and its evaluation causes the following postcondition to hold: The value of <tt>v</tt> is unchanged and is
equivalent to <tt>*p</tt>.</p>
</li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3958" href="3958">3958.</a> <tt>ranges::to</tt> should prioritize the "<tt>reserve</tt>" branch</h3>
<p><b>Section:</b> 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-07-17 <b>Last modified:</b> 2023-10-30 16:39:42 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the constructed range object has no range version constructor, <tt>ranges::to</tt> falls into a 
branch designed specifically for C++17-compliant containers, which calls the legacy constructor that 
accepts an iterator pair with <tt>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</tt>.    
<p/>
However, this kind of initialization may bring some performance issues, because we split the original 
range into pairs of iterators, which may lose information contained in the original range, for example:
</p>
<blockquote><pre>
#include &lt;boost/container/vector.hpp&gt;
#include &lt;sstream&gt;
#include &lt;ranges&gt;

int main() {
  std::istringstream ints("1 2 3 4 5");
  std::ranges::subrange s(std::istream_iterator&lt;int&gt;(ints),
                          std::istream_iterator&lt;int&gt;(),
                          5);
  auto r = std::ranges::to&lt;boost::container::vector&gt;(s); // <span style="color:red;font-weight:bolder">discard size info</span>
}
</pre></blockquote>
<p>
Above, <tt>subrange</tt> saves the size information of the stream, but <tt>ranges::to</tt> only extracts 
its iterator pair to create the object, so that the original size information is discarded, resulting in 
unnecessary allocations.
<p/>
I believe we should prefer to use the "<tt>reserve</tt>" branch here because it is really designed for this situation.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD after reflector poll.
"This optimizes exotic cases at the expense of realistic cases."
</p>



<p id="res-3958"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>

<li><p>Modify 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <tt>C</tt> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <tt>C</tt> constructed from the elements of <tt>r</tt> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <tt>C</tt> does not satisfy <tt>input_range</tt> or <tt>convertible_to&lt;range_reference_t&lt;R&gt;, 
range_value_t&lt;C&gt;&gt;</tt> is <tt>true</tt>:</p></li>
<ol style="list-style-type: none">
<li><p>(2.1.1) &mdash; If <tt>constructible_from&lt;C, R, Args...&gt;</tt> is <tt>true</tt>:</p>
<blockquote><tt>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote></li>
<li><p>(2.1.2) &mdash; Otherwise, if <tt>constructible_from&lt;C, from_range_t, R, Args...&gt;</tt> is <tt>true</tt>:</p>
<blockquote><tt>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote></li>
<li><p><del>(2.1.3) &mdash; Otherwise, if</del></p></li>
<ol style="list-style-type: none">
<li><p><del>(2.1.3.1) &mdash; <tt>common_range&lt;R&gt;</tt> is <tt>true</tt>,</del></p></li>
<li><p><del>(2.1.3.2) &mdash; the <i>qualified-id</i>  
<tt>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</tt> is valid and denotes a type that models 
<tt>derived_from&lt;input_iterator_tag&gt;</tt>, and</del></p></li>
<li><p><del>(2.1.3.3) &mdash; <tt>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</tt> 
is <tt>true</tt>:</del></p>
<blockquote><pre><del>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</del></pre></blockquote></li>
</ol>
<li><p>(2.1.4) &mdash; Otherwise, if</p></li>
<ol style="list-style-type: none">
<li><p>(2.1.4.1) &mdash; <tt>constructible_from&lt;C, Args...&gt;</tt> is <tt>true</tt>, and</p></li>
<li><p>(2.1.4.2) &mdash; <tt><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:</p>
<blockquote><pre>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R&gt; &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
  c.reserve(static_cast&lt;range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::copy(r, <i>container-inserter</i>&lt;range_reference_t&lt;R&gt;&gt;(c));
</pre></blockquote></li>
</ol>
<li><p><ins>(?.?.?) &mdash; Otherwise, if</ins></p></li>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?.?) &mdash; <tt>common_range&lt;R&gt;</tt> is <tt>true</tt>,</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; the <i>qualified-id</i> <tt>iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category</tt> 
is valid and denotes a type that models <tt>derived_from&lt;input_iterator_tag&gt;</tt>, and</ins></p></li>
<li><p><ins>(?.?.?.?) &mdash; <tt>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</tt> 
is <tt>true</tt>:</ins></p>
<blockquote><pre><ins>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</ins></pre></blockquote></li>
</ol>
</ol>
<li><p>(2.2) &mdash; Otherwise, if <tt>input_range&lt;range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(2.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3965" href="3965">3965.</a> Incorrect example in [format.string.escaped] p3 for formatting of combining characters</h3>
<p><b>Section:</b> 22.14.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.string.escaped">[format.string.escaped]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tom Honermann <b>Opened:</b> 2023-07-31 <b>Last modified:</b> 2023-10-27 21:22:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++23 DIS contains the following example in 22.14.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.string.escaped">[format.string.escaped]</a> p3. (This example does 
not appear in the most recent <a href="https://wg21.link/N4950">N4950</a> WP or on <a href="https://eel.is/c++draft">https://eel.is/c++draft</a> 
because the project editor has not yet merged changes needed to support rendering of some of the characters involved).
</p>
<blockquote><pre>
string s6 = format("[{:?}]", "&#x1F937;&#x200D;&#x2642;&#xFE0F;"); // s6 has value: ["&#x1F937;\u{200d}&#x2642;\u{fe0f}"]
</pre></blockquote>
<p>
The character to be formatted (&#x1F937;&#x200D;&#x2642;&#xFE0F;) consists of the following sequence of code points 
in the order presented:
</p>
<ul>
<li><p>U+1F937 (SHRUG)</p></li>
<li><p>U+200D (ZERO WIDTH JOINER)</p></li>
<li><p>U+2642 (MALE SIGN)</p></li>
<li><p>U+FE0F (VARIATION SELECTOR-16)</p></li>
</ul>
<p>
22.14.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.string.escaped">[format.string.escaped]</a> bullet 2.2.1 specifies which code points are to be formatted as a 
<tt>\u{<i>hex-digit-sequence</i>}</tt> escape sequence:
</p>
<ol style="list-style-type: none">
<li><p>(2.2.1) &mdash; If <i>X</i> encodes a single character <i>C</i>, then:</p>
<ol style="list-style-type: none">
<li><p>(2.2.1.1) &mdash; If <i>C</i> is one of the characters in Table 75 [tab:format.escape.sequences], then the two characters shown 
as the corresponding escape sequence are appended to <i>E</i>.</p></li>
<li><p>(2.2.1.2) &mdash; Otherwise, if <i>C</i> is not U+0020 SPACE and</p>
<ol style="list-style-type: none">
<li><p>(2.2.1.2.1) &mdash; <i>CE</i> is UTF-8, UTF-16, or UTF-32 and <i>C</i> corresponds to a Unicode scalar value whose
Unicode property <tt>General_Category</tt> has a value in the groups <tt>Separator</tt> (<tt>Z</tt>) or <tt>Other</tt>
(<tt>C</tt>), as described by UAX #44 of the Unicode Standard, or</p></li>
<li><p>(2.2.1.2.2) &mdash; <i>CE</i> is UTF-8, UTF-16, or UTF-32 and <i>C</i> corresponds to a Unicode scalar value with
the Unicode property <tt>Grapheme_Extend=Yes</tt> as described by UAX #44 of the Unicode
Standard and <i>C</i> is not immediately preceded in <i>S</i> by a character <i>P</i> appended to <i>E</i> without
translation to an escape sequence, or</p></li>
<li><p>(2.2.1.2.3) &mdash; <i>CE</i> is neither UTF-8, UTF-16, nor UTF-32 and <i>C</i> is one of an implementation-defined
set of separator or non-printable characters</p></li>
</ol>
<p>
then the sequence <tt>\u{<i>hex-digit-sequence</i>}</tt> is appended to <i>E</i>, where <tt><i>hex-digit-sequence</i></tt>
is the shortest hexadecimal representation of <i>C</i> using lower-case hexadecimal digits.
</p>
</li>
<li><p>(2.2.1.3) &mdash; Otherwise, <i>C</i> is appended to <i>E</i>.</p></li>
</ol>
</li>
</ol>
<p>
The example is not consistent with the above specification for the final code point. 
<a href="https://util.unicode.org/UnicodeJsps/character.jsp?a=FE0F">U+FE0F</a> is a single character, 
is not one of the characters in Table 75, is not U+0020, has a <tt>General_Category</tt> of <tt>Nonspacing Mark (Mn)</tt> 
which is neither <tt>Z</tt> nor <tt>C</tt>, has <tt>Grapheme_Extend=Yes</tt> but the prior character (U+2642) is not 
formatted as an escape sequence, and is not one of an implementation-defined set of separator or non-printable characters 
(for the purposes of this example; the example assumes a UTF-8 encoding). Thus, formatting for this character falls to 
the last bullet point and the character should be appended as is (without translation to an escape sequence). 
Since this character is a combining character, it should  combine with the previous character and thus alter the 
appearance of U+2642 (thus producing <tt>"&#x2642;&#xFE0F;"</tt> instead of <tt>"&#x2642;\u{fe0f}"</tt>).
</p>

<p><i>[2023-10-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3965"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a> plus missing editorial pieces from <a href="https://wg21.link/P2286R8">P2286R8</a>.
</p>

<ol>

<li><p>Modify the example following 22.14.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.string.escaped">[format.string.escaped]</a> p3 as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The presented example was voted in as part of <a href="https://wg21.link/P2286R8">P2286R8</a> during the July 2022 
Virtual Meeting but is not yet accessible in the most recent working draft <a href="https://wg21.link/N4950">N4950</a>.
<p/>
Note that the final character (&#x2642;&#xFE0F;) is composed from the two code points U+2642 and U+FE0F.
]
</p>
</blockquote>


<blockquote>
<p>
</p>
<blockquote><pre>
string s6 = format("[{:?}]", "&#x1F937;&#x200D;&#x2642;&#xFE0F;"); // s6 has value: <del>["&#x1F937;\u{200d}&#x2642;\u{fe0f}"]</del><ins>["&#x1F937;\u{200d}&#x2642;&#xFE0F;"]</ins>
</pre></blockquote>

</blockquote>
</li>
</ol>





<hr>
<h3><a name="3970" href="3970">3970.</a> &sect;[mdspan.syn] Missing definition of <tt>full_extent_t</tt> and <tt>full_extent</tt></h3>
<p><b>Section:</b> 24.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.syn">[mdspan.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2023-08-16 <b>Last modified:</b> 2023-10-27 21:22:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>submdspan</tt> uses a type called <tt>full_extent_t</tt>, but there isn't a definition for that type.
<p/>
It appears that <tt>full_extent_t</tt> (along with <tt>full_extent</tt>) was proposed in <a href="https://wg21.link/P0009">P0009</a> 
before <tt>submdspan</tt> was moved into its own paper, and its definition failed to be included in 
<a href="https://wg21.link/P2630">P2630</a> Submdspan.
</p>

<p><i>[2023-10-27; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-3970"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 24.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.syn">[mdspan.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 24.7.3.7 <a href="https://timsong-cpp.github.io/cppwp/mdspan.submdspan">[mdspan.submdspan]</a>, submdspan creation</i>
template&lt;class OffsetType, class LengthType, class StrideType&gt;
  struct strided_slice;

template&lt;class LayoutMapping&gt;
  struct submdspan_mapping_result;
  
<ins>struct full_extent_t { explicit full_extent_t() = default; };
inline constexpr full_extent_t full_extent{};</ins>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3973" href="3973">3973.</a> Monadic operations should be ADL-proof</h3>
<p><b>Section:</b> 22.8.6.7 <a href="https://timsong-cpp.github.io/cppwp/expected.object.monadic">[expected.object.monadic]</a>, 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.monadic">[optional.monadic]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-08-10 <b>Last modified:</b> 2023-10-30 17:22:20 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#expected.object.monadic">issues</a> in [expected.object.monadic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3938">3938</a> switched to use <tt>**this</tt> to access the value stored in <tt>std::expected</tt>. 
However, as shown in LWG <a href="3969">3969</a>, <tt>**this</tt> can trigger ADL and find an unwanted overload, 
and thus may caused unintended behavior.
<p/>
Current implementations behave correctly (<a href="https://godbolt.org/z/3b1Tbs1jd">Godbolt link</a>): they 
don't direct use <tt>**this</tt>, but use the name of the union member instead.
<p/>
Moreover, <a href="https://wg21.link/P2407R5">P2407R5</a> will change the monadic operations of <tt>std::optional</tt> to use <tt>**this</tt>, 
which is also problematic.
</p>

<p><i>[2023-09-19; Wording update]</i></p>

<p>
Several people preferred to replace <tt>operator*()</tt> by the corresponding union members, so this part of the proposed wording 
has been adjusted, which is a rather mechanical replacement.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3973"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 22.8.6.7 <a href="https://timsong-cpp.github.io/cppwp/expected.object.monadic">[expected.object.monadic]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Effectively replace all occurrences of <tt>**this</tt> by <tt><i>val</i></tt>, except for <tt>decltype</tt>.]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-1- Let <tt>U</tt> be <tt>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(<del>**this</del><ins>(<i>val</i>)</ins>)&gt;&gt;</tt>.
<p/>
-2- [&hellip;]
<p/>
-3- [&hellip;]
<p/>
-4- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (has_value())
  return invoke(std::forward&lt;F&gt;(f), <del>**this</del><ins><i>val</i></ins>);
else
  return U(unexpect, error());
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-5- Let <tt>U</tt> be <tt>remove_cvref_t&lt;invoke_result_t&lt;F, decltype((std::move(<del>**this</del><ins><i>val</i></ins>))&gt;&gt;</tt>.
<p/>
-6- [&hellip;]
<p/>
-7- [&hellip;]
<p/>
-8- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (has_value())
  return invoke(std::forward&lt;F&gt;(f), std::move(<del>**this</del><ins><i>val</i></ins>));
else
  return U(unexpect, std::move(error()));
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto or_else(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto or_else(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-9- Let <tt>G</tt> be <tt>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(error())&gt;&gt;</tt>.
<p/>
-10- <i>Constraints</i>: <tt>is_constructible_v&lt;T, decltype(<del>**this</del><ins>(<i>val</i>)</ins>)&gt;</tt> is <tt>true</tt>.
<p/>
-11- [&hellip;]
<p/>
-12- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (has_value())
  return G(in_place, <del>**this</del><ins><i>val</i></ins>);
else
  return invoke(std::forward&lt;F&gt;(f), error());
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto or_else(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto or_else(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-13- Let <tt>G</tt> be <tt>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(std::move(error()))&gt;&gt;</tt>.
<p/>
-14- <i>Constraints</i>: <tt>is_constructible_v&lt;T, decltype(std::move(<del>**this</del><ins><i>val</i></ins>))&gt;</tt> is <tt>true</tt>.
<p/>
-15- [&hellip;]
<p/>
-16- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (has_value())
  return G(in_place, std::move(<del>**this</del><ins><i>val</i></ins>));
else
  return invoke(std::forward&lt;F&gt;(f), std::move(error()));
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-17- Let <tt>U</tt> be <tt>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(<del>**this</del><ins>(<i>val</i>)</ins>)&gt;&gt;</tt>.
<p/>
-18- [&hellip;]
<p/>
-19- <i>Mandates</i>: <tt>U</tt> is a valid value type for <tt>expected</tt>. If <tt>is_void_v&lt;U&gt;</tt> is <tt>false</tt>, 
the declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), <del>**this</del><ins><i>val</i></ins>));
</pre></blockquote>
<p>
is well-formed.
<p/>
-20- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(20.1) &mdash; [&hellip;]</p></li>
<li><p>(20.2) &mdash; Otherwise, if <tt>is_void_v&lt;U&gt;</tt> is <tt>false</tt>, returns an <tt>expected&lt;U, E&gt;</tt> 
object whose <tt><i>has_val</i></tt> member is <tt>true</tt> and <tt><i>val</i></tt> member is direct-non-list-initialized 
with <tt>invoke(std::forward&lt;F&gt;(f), <del>**this</del><ins><i>val</i></ins>)</tt>.</p></li>
<li><p>(20.3) &mdash; Otherwise, evaluates <tt>invoke(std::forward&lt;F&gt;(f), <del>**this</del><ins><i>val</i></ins>)</tt> 
and then returns <tt>expected&lt;U, E&gt;()</tt>.</p></li>
</ol>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-21- Let <tt>U</tt> be <tt>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(std::move(<del>**this</del><ins><i>val</i></ins>))&gt;&gt;</tt>.
<p/>
-22- [&hellip;]
<p/>
-23- <i>Mandates</i>: <tt>U</tt> is a valid value type for <tt>expected</tt>. If <tt>is_void_v&lt;U&gt;</tt> is <tt>false</tt>, 
the declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), std::move(<del>**this</del><ins><i>val</i></ins>)));
</pre></blockquote>
<p>
is well-formed.
<p/>
-24- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(24.1) &mdash; [&hellip;]</p></li>
<li><p>(24.2) &mdash; Otherwise, if <tt>is_void_v&lt;U&gt;</tt> is <tt>false</tt>, returns an <tt>expected&lt;U, E&gt;</tt> 
object whose <tt><i>has_val</i></tt> member is <tt>true</tt> and <tt><i>val</i></tt> member is direct-non-list-initialized 
with <tt>invoke(std::forward&lt;F&gt;(f), std::move(<del>**this</del><ins><i>val</i></ins>))</tt>.</p></li>
<li><p>(24.3) &mdash; Otherwise, evaluates <tt>invoke(std::forward&lt;F&gt;(f), std::move(<del>**this</del><ins><i>val</i></ins>))</tt> 
and then returns <tt>expected&lt;U, E&gt;()</tt>.</p></li>
</ol>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform_error(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto transform_error(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-25- Let <tt>G</tt> be <tt>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(error())&gt;&gt;</tt>.
<p/>
-26- <i>Constraints</i>: <tt>is_constructible_v&lt;T, decltype(<del>**this</del><ins>(<i>val</i>)</ins>)&gt;</tt> is <tt>true</tt>.
<p/>
-27- <i>Mandates</i>: [&hellip;]
<p/>
-28- <i>Returns</i>: If <tt>has_value()</tt> is <tt>true</tt>, <tt>expected&lt;T, G&gt;(in_place, <del>**this</del><ins><i>val</i></ins>)</tt>; 
otherwise, an <tt>expected&lt;T, G&gt;</tt> object whose <tt><i>has_val</i></tt> member is <tt>false</tt> and 
<tt><i>unex</i></tt> member is direct-non-list-initialized with <tt>invoke(std::forward&lt;F&gt;(f), error())</tt>.
</p>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform_error(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto transform_error(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-29- Let <tt>G</tt> be <tt>remove_cvref_t&lt;invoke_result_t&lt;F, decltype(std::move(error()))&gt;&gt;</tt>.
<p/>
-30- <i>Constraints</i>: <tt>is_constructible_v&lt;T, decltype(std::move(<del>**this</del><ins><i>val</i></ins>))&gt;</tt> is <tt>true</tt>.
<p/>
-31- <i>Mandates</i>: [&hellip;]
<p/>
-32- <i>Returns</i>: If <tt>has_value()</tt> is <tt>true</tt>, <tt>expected&lt;T, G&gt;(in_place, std::move(<del>**this</del><ins><i>val</i></ins>))</tt>; 
otherwise, an <tt>expected&lt;T, G&gt;</tt> object whose <tt><i>has_val</i></tt> member is <tt>false</tt> and 
<tt><i>unex</i></tt> member is direct-non-list-initialized with <tt>invoke(std::forward&lt;F&gt;(f), std::move(error()))</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.monadic">[optional.monadic]</a> as indicated:</p>


<blockquote class="note">
<p>
[<i>Drafting note:</i> Effectively replace all occurrences of <tt>value()</tt> by <tt>*val</tt>.]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-1- Let <tt>U</tt> be <tt>invoke_result_t&lt;F, decltype(<del>value()</del><ins>*val</ins>)&gt;</tt>.
<p/>
-2- [&hellip;]
<p/>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (*this) {
  return invoke(std::forward&lt;F&gt;(f), <del>value()</del><ins>*val</ins>);
} else {
  return remove_cvref_t&lt;U&gt;();
}
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-4- Let <tt>U</tt> be <tt>invoke_result_t&lt;F, decltype(std::move(<del>value()</del><ins>*val</ins>))&gt;</tt>.
<p/>
-5- [&hellip;]
<p/>
-6- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (*this) {
  return invoke(std::forward&lt;F&gt;(f), std::move(<del>value()</del><ins>*val</ins>));
} else {
  return remove_cvref_t&lt;U&gt;();
}
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-7- Let <tt>U</tt> be <tt>remove_cv_t&lt;invoke_result_t&lt;F, decltype(<del>value()</del><ins>*val</ins>)&gt;&gt;</tt>.
<p/>
-8- <i>Mandates</i>: <tt>U</tt> is a non-array object type other than <tt>in_place_t</tt> or <tt>nullopt_t</tt>. The declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), <del>value()</del><ins>*val</ins>));
</pre></blockquote>
<p>
is well-formed for some invented variable <tt>u</tt>.
<p/>
[&hellip;]
<p/>
-9- <i>Returns</i>: If <tt>*this</tt> contains a value, an <tt>optional&lt;U&gt;</tt> object whose contained value is 
direct-non-list-initialized with <tt>invoke(std::forward&lt;F&gt;(f), <del>value()</del><ins>*val</ins>)</tt>; otherwise, 
<tt>optional&lt;U&gt;()</tt>.
</p>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-10- Let <tt>U</tt> be <tt>remove_cv_t&lt;invoke_result_t&lt;F, decltype(std::move(<del>value()</del><ins>*val</ins>))&gt;&gt;</tt>.
<p/>
-11- <i>Mandates</i>: <tt>U</tt> is a non-array object type other than <tt>in_place_t</tt> or <tt>nullopt_t</tt>. The declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), std::move(<del>value()</del><ins>*val</ins>)));
</pre></blockquote>
<p>
is well-formed for some invented variable <tt>u</tt>.
<p/>
[&hellip;]
<p/>
-12- <i>Returns</i>: If <tt>*this</tt> contains a value, an <tt>optional&lt;U&gt;</tt> object whose contained value is 
direct-non-list-initialized with <tt>invoke(std::forward&lt;F&gt;(f), std::move(<del>value()</del><ins>*val</ins>))</tt>; otherwise, 
<tt>optional&lt;U&gt;()</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3974" href="3974">3974.</a> <tt>mdspan::operator[]</tt> should not copy <tt>OtherIndexTypes</tt></h3>
<p><b>Section:</b> 24.7.3.6.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.members">[mdspan.mdspan.members]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2023-08-12 <b>Last modified:</b> 2023-11-03 18:06:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording for <tt>mdspan</tt>'s <tt>operator[]</tt> overloads that accept <tt>span</tt> and <tt>array</tt> is in 
24.7.3.6.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.members">[mdspan.mdspan.members]</a> paragraphs 5 and 6:
</p>
<blockquote><pre>
template&lt;class OtherIndexType&gt;
  constexpr reference operator[](span&lt;OtherIndexType, rank()&gt; indices) const;
template&lt;class OtherIndexType&gt;
  constexpr reference operator[](const array&lt;OtherIndexType, rank()&gt;&amp; indices) const;
</pre>
<p>
-5- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; <tt>is_convertible_v&lt;const OtherIndexType&amp;, index_type&gt;</tt> is <tt>true</tt>, and</p></li>
<li><p>(5.2) &mdash; <tt>is_nothrow_constructible_v&lt;index_type, const OtherIndexType&amp;&gt;</tt> is <tt>true</tt>.</p></li>
</ol>
<p>
-6- <i>Effects</i>: Let <tt>P</tt> be a parameter pack such that
</p>
<blockquote><pre>
is_same_v&lt;make_index_sequence&lt;rank()&gt;, index_sequence&lt;P...&gt;&gt;
</pre></blockquote>
<p>
is <tt>true</tt>. Equivalent to:
</p>
<blockquote><pre>
return operator[](as_const(indices[P])...);
</pre></blockquote>
</blockquote>
<p>
The equivalent code calls the other <tt>operator[]</tt> overload:
</p>
<blockquote><pre>
template&lt;class... OtherIndexTypes&gt;
  constexpr reference operator[](OtherIndexTypes... indices) const;
</pre></blockquote>
<p>
with a pack of <tt>const OtherIndexType</tt> lvalues, but we notably haven't required <tt>OtherIndexTypes</tt> to be copyable &mdash; 
we only require that we can convert them to <tt>index_type</tt>. While one could argue that the use in "<i>Effects</i>: equivalent to" 
implies a requirement of copyability, it's odd that this implicit requirement would be the only requirement for copyable 
<tt>OtherIndexTypes</tt> in the spec. We could fix this by changing the <tt>operator[]</tt> overload accepting <tt>OtherIndexTypes</tt> 
to take them by <tt>const&amp;</tt>, but that would be inconsistent with virtually every other place in the spec where types 
convertible to <tt>index_type</tt> are taken by-value. I think the best localized fix is to perform the conversion to <tt>index_type</tt> 
in the "<i>Effects</i>: equivalent to" code so the actual arguments have type <tt>index_type</tt> which we know is copyable.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-3974"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 24.7.3.6.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.members">[mdspan.mdspan.members]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherIndexType&gt;
  constexpr reference operator[](span&lt;OtherIndexType, rank()&gt; indices) const;
template&lt;class OtherIndexType&gt;
  constexpr reference operator[](const array&lt;OtherIndexType, rank()&gt;&amp; indices) const;
</pre>
<blockquote>
<p>
-5- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; <tt>is_convertible_v&lt;const OtherIndexType&amp;, index_type&gt;</tt> is <tt>true</tt>, and</p></li>
<li><p>(5.2) &mdash; <tt>is_nothrow_constructible_v&lt;index_type, const OtherIndexType&amp;&gt;</tt> is <tt>true</tt>.</p></li>
</ol>
<p>
-6- <i>Effects</i>: Let <tt>P</tt> be a parameter pack such that
</p>
<blockquote><pre>
is_same_v&lt;make_index_sequence&lt;rank()&gt;, index_sequence&lt;P...&gt;&gt;
</pre></blockquote>
<p>
is <tt>true</tt>. Equivalent to:
</p>
<blockquote><pre>
return operator[](<ins>extents_type::<i>index-cast</i>(</ins>as_const(indices[P])<ins>)</ins>...);
</pre></blockquote>
</blockquote>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="3980" href="3980">3980.</a> The read exclusive ownership of an atomic read-modify-write operation and whether its read and write are two operations are unclear</h3>
<p><b>Section:</b> 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-11-03 18:04:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Such two questions are sourced from StackOverflow:
</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/77126045/can-the-read-operations-in-compare-exchange-strong-in-different-two-thread-rea/77126363?noredirect=1#comment135968355_77126363">Can the read operations in <tt>compare_exchange_strong</tt> in different two thread read the same value?</a></p></li>
<li><p><a href="https://stackoverflow.com/questions/65568185/for-purposes-of-ordering-is-atomic-read-modify-write-one-operation-or-two">For purposes of ordering, is atomic read-modify-write one operation or two?</a></p></li>
</ol>
<p>
Given this example:
</p>
<blockquote>
<pre>
#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;

struct SpinLock{
  std::atomic&lt;bool&gt; atomic_;
  void lock(){
    bool expected = false;
    while (!atomic_.compare_exchange_strong(expected,true,std::memory_order_release,std::memory_order_relaxed)) {
    }
  }
  void unlock(){
    atomic_.store(false, std::memory_order_release);
  }
};

int main(){
  SpinLock spin{false};
  auto t1 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  auto t2 = std::thread([&amp;](){
    spin.lock();
    spin.unlock();
  });
  t1.join();
  t2.join();
}
</pre>
</blockquote>
<p>
In the current draft, the relevant phrasing that can interpret that only one read-modify-write operation reads the initial 
value false is 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p10:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write 
associated with the read-modify-write operation.
</p></blockquote>
<p>
However, the wording can have two meanings, each kind of read can result in different explanations for the example
</p>
<ol>
<li><p>The check of the violation is done before the side effect of the RMW is in the modification order, i.e. the rule is 
just checked at the read point.</p></li>
<li><p>The check of the violation is done after the side effect of the RMW is in the modification order, i.e. the rule is 
checked when <tt>RMW</tt> tries to add the side effect that is based on the read-value to the modification order, and that 
side effect wouldn't be added to the modification order if the rule was violated.</p></li>
</ol>
<p>
With the first interpretation, the two RMW operations can read the same initial value because that value is indeed the last value 
in the modification order before such two RMW operations produce the side effect to the modification order.
<p/>
With the second interpretation, there is only one RMW operation that can read the initial value because the latter one in 
the modification order would violate the rule if it read the initial value.
<p/>
Such two interpretations arise from that the wording doesn't clearly specify when that check is performed.
<p/>
So, my proposed wording is:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
Atomic read-modify-write operations shall always read the value from a side effect <tt>X</tt>, where <tt>X</tt> 
immediately precedes the side effect of the read-modify-write operation in the modification order.
</p></blockquote>
<p>
This wording keeps a similar utterance to 6.9.2.2 <a href="https://timsong-cpp.github.io/cppwp/intro.races">[intro.races]</a>, and it can clearly convey the meaning 
that we say the value read by <tt>RWM</tt> is associated with the side effect of <tt>RMW</tt> in the modification order.
<p/>
Relevant discussion can be seen <a href="https://github.com/cplusplus/CWG/issues/423">CWG/issues/423</a> here.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>NAD. The first reading isn't plausible. </p>



<p id="res-3980"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> as indicated:</p>

<blockquote>
<p>
-10- Atomic read-modify-write operations shall always read the <del>last</del> value <ins>from a side effect <i>X</i>, 
where <i>X</i> immediately precedes the side effect of the read-modify-write operation</ins> <del>(</del>in the 
modification order<del>) written before the write associated with the read-modify-write operation</del>.
<p/>
-11- Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3981" href="3981">3981.</a> Range adaptor closure object is underspecified for its return type</h3>
<p><b>Section:</b> 26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-10-30 17:22:20 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.adaptor.object">active issues</a> in [range.adaptor.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.adaptor.object">issues</a> in [range.adaptor.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to provide pipe support for user-defined range adaptors, <a href="https://wg21.link/P2387R3">P2387R3</a> 
removed the specification that the adaptor closure object returns a view, which conforms to the wording of <tt>ranges::to</tt>.
<p/>
However, the current wording seems to be too low-spec so that the range adaptor closure object can return any type 
or even <tt>void</tt>. This makes it possible to break the previous specification when returning types that don't make sense, 
<a href="https://godbolt.org/z/Y4nvjY3xj">for example</a>:
</p>
<blockquote>
<pre>
#include &lt;ranges&gt;

struct Closure : std::ranges::range_adaptor_closure&lt;Closure&gt; {
  struct NonCopyable {
    NonCopyable(const NonCopyable&amp;) = delete;
  };

  const NonCopyable&amp; operator()(std::ranges::range auto&amp;&amp;);
};

auto r = std::views::iota(0) | Closure{}; // <span style="color:red;font-weight:bolder">hard error in stdlibc++ and MSVC-STL</span>
</pre></blockquote>
<p>
Above, since the return type of the pipeline operator is declared as <tt>auto</tt>, this causes the deleted 
copy constructor to be invoked in the function body and produces a hard error.
<p/>
The proposed resolution adds a specification for the range adaptor closure object to return a <i>cv</i>-unqualified class type.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set status to Tentatively NAD.
"The wording says <code>R | C</code> is equivalent to <code>C(R)</code>,
not <code>auto(C(R))</code>."
</p>



<p id="res-3981"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> as indicated:</p>

<blockquote>
<p>
-1- A <i>range adaptor closure object</i> is a unary function object that accepts a range argument. For a range adaptor
closure object <tt>C</tt> and an expression <tt>R</tt> such that <tt>decltype((R))</tt> models <tt>range</tt>, the 
following expressions are equivalent:
</p>
<p>[&hellip;]</p>
<p>
-2- Given an object <tt>t</tt> of type <tt>T</tt>, where
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <tt>t</tt> is a unary function object that accepts a range argument <ins>and returns a 
<i>cv</i>-unqualified class object</ins>,</p></li>
<p>[&hellip;]</p>
</ol>
<p>
then the implementation ensures that <tt>t</tt> is a range adaptor closure object.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3982" href="3982">3982.</a> <tt><i>is-derived-from-view-interface</i></tt> should require that <tt>T</tt> is derived from <tt>view_interface&lt;T&gt;</tt></h3>
<p><b>Section:</b> 26.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.view">[range.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2023-10-30 16:39:42 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.view">issues</a> in [range.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the wording of <tt><i>is-derived-from-view-interface</i></tt> only detects whether type <tt>T</tt> is unambiguously 
derived from one base class <tt>view_interface&lt;U&gt;</tt> where <tt>U</tt> is not required to be <tt>T</tt>, which is not 
the intention of CRTP.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>Set status to Tentatively NAD.
The wording correctly handles the case where T derives from <code>Base</code>
which derives from <code>view_interface&lt;Base&gt;</code>.
We don't want it to only be satisfied for direct inheritance from
<code>view_interface&lt;T&gt;</code>, but from any specialization of
<code>view_interface</code>.
Previously the concept only checked for inheritance from <code>view_base</code>
but it was changed when <code>view_interface</code> stopped inheriting from
<code>view_base</code>.
</p>



<p id="res-3982"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 26.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.view">[range.view]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr bool <i>is-derived-from-view-interface</i> = <i>see below</i>;            // exposition only
template&lt;class T&gt;
  constexpr bool enable_view =
    derived_from&lt;T, view_base&gt; || <i>is-derived-from-view-interface</i>&lt;T&gt;;
</pre>
<blockquote>
<p>
-6- For a type <tt>T</tt>, <tt><i>is-derived-from-view-interface</i>&lt;T&gt;</tt>
is <tt>true</tt> if and only if <tt>T</tt> has exactly one public base class
<tt>view_interface&lt;<ins>T</ins><del>U</del>&gt;</tt> <del>for some type <tt>U</tt></del> and
<tt>T</tt> has no base classes of type <tt>view_interface&lt;<ins>U</ins><del>V</del>&gt;</tt> for any
other type <tt><ins>U</ins><del>V</del></tt>.
<p/>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3987" href="3987">3987.</a> Including <tt>&lt;flat_<i>foo</i>&gt;</tt> doesn't provide <tt>std::begin/end</tt></h3>
<p><b>Section:</b> 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-27 <b>Last modified:</b> 2023-11-03 18:06:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> should also add <tt>&lt;flat_<i>foo</i>&gt;</tt> to the list as the 
latter provides a series of range access member functions such as <tt>begin/end</tt>.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-3987"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> as indicated:</p>

<blockquote>
<p>
-1- In addition to being available via inclusion of the <tt>&lt;iterator&gt;</tt> header, the function templates in
[iterator.range] are available when any of the following headers are included: <tt>&lt;array&gt;</tt>,
<tt>&lt;deque&gt;</tt>, <ins><tt>&lt;flat_map&gt;</tt>, <tt>&lt;flat_set&gt;</tt>,</ins> <tt>&lt;forward_list&gt;</tt>, 
<tt>&lt;list&gt;</tt>, <tt>&lt;map&gt;</tt>, <tt>&lt;regex&gt;</tt>, <tt>&lt;set&gt;</tt>, <tt>&lt;span&gt;</tt>, 
<tt>&lt;string&gt;</tt>, <tt>&lt;string_view&gt;</tt>, <tt>&lt;unordered_map&gt;</tt>, <tt>&lt;unordered_set&gt;</tt>, 
and <tt>&lt;vector&gt;</tt>.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3990" href="3990">3990.</a> Program-defined specializations of <tt>std::tuple</tt> and <tt>std::variant</tt> can't be properly supported</h3>
<p><b>Section:</b> 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, 22.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.variant.general">[variant.variant.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-08-29 <b>Last modified:</b> 2023-11-03 18:06:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, program-defined specializations of <tt>std::tuple</tt> and <tt>std::variant</tt> are not explicitly disallowed. 
However, they can't be properly supported by standard library implementations, because the corresponding <tt>std::get</tt> 
function templates have to inspect the implementation details of these types, and users have no way to make <tt>std::get</tt> 
behave correctly for a program-defined specializations.
<p/>
Perhaps we should explicitly disallow specializing <tt>std::tuple</tt> and <tt>std::variant</tt>.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3990"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class... Types&gt;
  class tuple {
    [&hellip;]
  };

  [&hellip;]
}
</pre>
</blockquote>
<blockquote>
<p>
<ins>-?- If a program declares an explicit or partial specialization of <tt>tuple</tt>, 
the program is ill-formed, no diagnostic required.</ins>
</p>
</blockquote>

</li>

<li><p>Modify 22.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.variant.general">[variant.variant.general]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-3- A program that instantiates the definition of <tt>variant</tt> with no template arguments is ill-formed.
<p/>
<ins>-?- If a program declares an explicit or partial specialization of <tt>variant</tt>, 
the program is ill-formed, no diagnostic required.</ins>
</p>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3996" href="3996">3996.</a> <tt>projected&lt;I, identity&gt;</tt> should just be <tt>I</tt></h3>
<p><b>Section:</b> 25.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/projected">[projected]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-12 <b>Last modified:</b> 2023-11-03 18:04:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#projected">issues</a> in [projected].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <tt>projected</tt> is a wrapper of the implementation type regardless of whether <tt>Proj</tt> is <tt>identity</tt>.
<p/>
Since <tt>identity</tt> always returns a reference, this prevents <tt>projected&lt;I, identity&gt;</tt> from fully 
emulating the properties of the original iterator when its reference is a prvalue. 
<p/>
Such non-equivalence may lead to unexpected behavior in some cases (<a href="https://godbolt.org/z/KM45ndWvh">demo</a>):
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;ranges&gt;
#include &lt;iostream&gt;

int main() {
  auto outer = std::views::iota(0, 5)
             | std::views::transform([](int i) {
                 return std::views::single(i) | std::views::filter([](int) { return true; });
               });
  
  for (auto&amp;&amp; inner : outer)
    for (auto&amp;&amp; elem : inner)
      std::cout &lt;&lt; elem &lt;&lt; " "; // 0 1 2 3 4 
  
  std::ranges::for_each(
    outer,
    [](auto&amp;&amp; inner) {
      // <span  style="color:#C80000;font-weight:bold">error: passing 'const filter_view' as 'this' argument discards qualifiers</span>
      for (auto&amp;&amp; elem : inner)
        std::cout &lt;&lt; elem &lt;&lt; " ";
    });
}
</pre></blockquote>
<p>
In the above example, <tt>ranges::for_each</tt> requires <tt>indirect_unary_predicate&lt;Pred, projected&lt;I, identity&gt;&gt;</tt>
which ultimately requires <tt>invocable&lt;Pred&amp;, iter_common_reference_t&lt;projected&lt;I, identity&gt;&gt;&gt;</tt>.
<p/> 
According to the current wording, the reference and indirect value type of <tt>projected&lt;I, identity&gt;</tt> are 
<tt>filter_view&amp;&amp;</tt> and <tt>filter_view&amp;</tt> respectively, which causes its common reference to be eventually 
calculated as <tt>const filter_view&amp;</tt>. Since the former is not <tt>const</tt>-iterable, this results in a hard error 
during instantiation because <tt>const begin</tt> is called unexpectedly in an unconstrained lambda.
</p>
<p>
It seems like having <tt>projected&lt;I, identity&gt;</tt> just be <tt>I</tt> is a more appropriate choice, 
which makes the concept checking really specific to <tt>I</tt> rather than a potentially incomplete iterator wrapper.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>
NAD. <a href="https://wg21.link/P2997">P2997</a> solves this, and more.
"Applying the projection does in fact materialize prvalues,
so this is just lying unless we special-case identity everywhere."
</p>



<p id="res-3996"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 25.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/projected">[projected]</a> as indicated:</p>

<blockquote>
<p>
-1- Class template <tt>projected</tt> is used to constrain algorithms that accept callable objects and projections 
(3.44 <a href="https://timsong-cpp.github.io/cppwp/defns.projection">[defns.projection]</a>). It combines an <tt>indirectly_readable</tt> type <tt>I</tt> and a callable 
object type <tt>Proj</tt> into a new <tt>indirectly_readable</tt> type whose <tt>reference</tt> type is the 
result of applying <tt>Proj</tt> to the <tt>iter_reference_t</tt> of <tt>I</tt>.
</p>
<blockquote><pre>
namespace std {
  template&lt;class I, class Proj&gt;
  struct <i>projected-impl</i> {                               // <i>exposition only</i>
    struct <i>type</i> {                                       // <i>exposition only</i>
      using value_type = remove_cvref_t&lt;indirect_result_t&lt;Proj&amp;, I&gt;&gt;;
      using difference_type = iter_difference_t&lt;I&gt;;     // <i>present only if</i> I
                                                        // <i>models</i> weakly_incrementable
      indirect_result_t&lt;Proj&amp;, I&gt; operator*() const;    // <i>not defined</i>
    };
  };

  template&lt;indirectly_readable I, indirectly_regular_unary_invocable&lt;I&gt; Proj&gt;
    using projected = <ins>conditional_t&lt;is_same_v&lt;Proj, identity&gt;, I, typename</ins> <i>projected-impl</i>&lt;I, Proj&gt;::type<ins>&gt;</ins>;
}
</pre></blockquote>
</blockquote>


</li>

</ol>





<hr>
<h3><a name="4001" href="4001">4001.</a> <tt>iota_view</tt> should provide <tt>empty</tt></h3>
<p><b>Section:</b> 26.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-27 <b>Last modified:</b> 2023-11-03 18:06:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.iota.view">active issues</a> in [range.iota.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.iota.view">issues</a> in [range.iota.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <tt>iota_view</tt>'s template parameter is not an integer type and does not model <tt><i>advanceable</i></tt>, 
its <tt>size</tt> member will not be provided as constraints are not satisfied.
<p/>
If the type further fails to model the <tt>incrementable</tt>, this results in its <tt>view_interface</tt> base being 
unable to synthesize a valid <tt>empty</tt> member as <tt>iota_view</tt> will just be an <tt>input_range</tt> 
(<a href="https://godbolt.org/z/hG9GWvv97">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
  std::vector&lt;int&gt; v;
  auto it = std::back_inserter(v);
  auto s = std::ranges::subrange(it, std::unreachable_sentinel);
  auto r = std::views::iota(it);
  std::cout &lt;&lt; s.empty() &lt;&lt; "\n"; // 0
  std::cout &lt;&lt; r.empty() &lt;&lt; "\n"; // <span style="color:red;font-weight:bolder">ill-formed</span>
}
</pre></blockquote>
<p>
This seems to be an oversight. I don't see a reason why <tt>iota_view</tt> doesn't provide <tt>empty</tt> 
as it does store the start and end like <tt>subrange</tt>, in which case it's easy to tell if it's empty 
just by comparing the two.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-4001"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964">N4964</a>.
</p>

<ol>

<li><p>Modify 26.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a>, class template <tt>iota_view</tt> synopsis, as indicated:</p>

<blockquote>
<blockquote><pre>
namespace std::ranges {
  [&hellip;]
  template&lt;weakly_incrementable W, semiregular Bound = unreachable_sentinel_t&gt;
    requires <i>weakly-equality-comparable-with</i>&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  class iota_view : public view_interface&lt;iota_view&lt;W, Bound&gt;&gt; {
  private:
    [&hellip;]
    W <i>value_</i> = W();                     // <i>exposition only</i>
    Bound <i>bound_</i> = Bound();             // <i>exposition only</i>
  public:
    [&hellip;]
    constexpr <i>iterator</i> begin() const;
    constexpr auto end() const;
    constexpr <i>iterator</i> end() const requires same_as&lt;W, Bound&gt;;

    <ins>constexpr bool empty() const;</ins>
    constexpr auto size() const requires <i>see below</i>;
  };
  [&hellip;]
}
</pre></blockquote>
<p>
[&hellip;]
</p>
<pre>
constexpr <i>iterator</i> end() const requires same_as&lt;W, Bound&gt;;
</pre>
<blockquote>
<p>
-14- <i>Effects</i>: Equivalent to: <tt>return <i>iterator</i>{<i>bound_</i>};</tt> 
</p>
</blockquote>
<pre>
<ins>constexpr bool empty() const;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <tt>return <i>value_</i> == <i>bound_</i>;</tt></ins>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





</body>
</html>
