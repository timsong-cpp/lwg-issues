<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p><p>Revised 2021-04-24 at 17:24:50 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="3506" href="3506">3506.</a> Missing allocator-extended constructors for <tt>priority_queue</tt></h3>
<p><b>Section:</b> 22.6.5 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2020-11-21 <b>Last modified:</b> 2021-02-26 17:32:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#priority.queue">active issues</a> in [priority.queue].</p>
<p><b>View all other</b> <a href="lwg-index.html#priority.queue">issues</a> in [priority.queue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>priority_queue</tt> has two constructor templates taking a pair of input
iterators in addition to a comparator and a container, but it does not have
allocator-extended constructors corresponding to these constructor templates:
</p>
<blockquote><pre>
template&lt;class InputIterator&gt;
  priority_queue(InputIterator first, InputIterator last, const Compare&amp; x,
                 const Container&amp;);
template&lt;class InputIterator&gt;
  priority_queue(InputIterator first, InputIterator last,
                 const Compare&amp; x = Compare(), Container&amp;&amp; = Container());
</pre></blockquote>

<p><i>[2020-11-29; Reflector prioritization]</i></p>

<p>
Set priority to 3 during reflector discussions. It has been pointed out that this issue
is related to LWG <a href="1199">1199</a>, LWG <a href="2210">2210</a>, and LWG <a href="2713">2713</a>.
</p>

<p><i>[2021-02-17 Tim adds PR]</i></p>


<p><i>[2021-02-26; LWG telecon]</i></p>

<p>
Set status to Tentatively Ready after discussion and poll.
<table>
<tr><th>F</th><th>A</th><th>N</th></tr>
<tr><td>11</td><td>0</td><td>0</td></tr>
</table>
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li><p>Add the following paragraph at the end of 22.6.1 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.general">[container.adaptors.general]</a>:</p>
<blockquote>
<p>
<ins>-6- The exposition-only alias template <i><tt>iter-value-type</tt></i> defined in
22.3.1 <a href="https://timsong-cpp.github.io/cppwp/sequences.general">[sequences.general]</a> may appear in deduction guides for container adaptors.</ins>
</p>
</blockquote>
</li>
<li><p>Modify 22.6.5 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a>, class template <tt>priority_queue</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class T, class Container = vector&lt;T&gt;,
            class Compare = less&lt;typename Container::value_type&gt;&gt;
  class priority_queue {

  // [&hellip;]

  public:
    priority_queue() : priority_queue(Compare()) {}
    explicit priority_queue(const Compare&amp; x) : priority_queue(x, Container()) {}
    priority_queue(const Compare&amp; x, const Container&amp;);
    priority_queue(const Compare&amp; x, Container&amp;&amp;);
    template&lt;class InputIterator&gt;
      priority_queue(InputIterator first, InputIterator last, const Compare&amp; x,
                      const Container&amp;);
    template&lt;class InputIterator&gt;
      priority_queue(InputIterator first, InputIterator last,
                      const Compare&amp; x = Compare(), Container&amp;&amp; = Container());
    template&lt;class Alloc&gt; explicit priority_queue(const Alloc&amp;);
    template&lt;class Alloc&gt; priority_queue(const Compare&amp;, const Alloc&amp;);
    template&lt;class Alloc&gt; priority_queue(const Compare&amp;, const Container&amp;, const Alloc&amp;);
    template&lt;class Alloc&gt; priority_queue(const Compare&amp;, Container&amp;&amp;, const Alloc&amp;);
    template&lt;class Alloc&gt; priority_queue(const priority_queue&amp;, const Alloc&amp;);
    template&lt;class Alloc&gt; priority_queue(priority_queue&amp;&amp;, const Alloc&amp;);
<ins>    template&lt;class InputIterator, class Alloc&gt;
      priority_queue(InputIterator, InputIterator, const Alloc&amp;);
    template&lt;class InputIterator, class Alloc&gt;
      priority_queue(InputIterator, InputIterator, const Compare&amp;, const Alloc&amp;);
    template&lt;class InputIterator, class Alloc&gt;
      priority_queue(InputIterator, InputIterator, const Compare&amp;, const Container&amp;, const Alloc&amp;);
    template&lt;class InputIterator, class Alloc&gt;
      priority_queue(InputIterator, InputIterator, const Compare&amp;, Container&amp;&amp;, const Alloc&amp;);</ins>

  // [&hellip;]

  };

  template&lt;class Compare, class Container&gt;
    priority_queue(Compare, Container)
      -&gt; priority_queue&lt;typename Container::value_type, Container, Compare&gt;;

  template&lt;class InputIterator,
            class Compare = less&lt;<del>typename iterator_traits</del><ins><i>iter-value-type</i></ins>&lt;InputIterator&gt;<del>::value_type</del>&gt;,
            class Container = vector&lt;<del>typename iterator_traits</del><ins><i>iter-value-type</i></ins>&lt;InputIterator&gt;<del>::value_type</del>&gt;&gt;
    priority_queue(InputIterator, InputIterator, Compare = Compare(), Container = Container())
      -&gt; priority_queue&lt;<del>typename iterator_traits</del><ins><i>iter-value-type</i></ins>&lt;InputIterator&gt;<del>::value_type</del>, Container, Compare&gt;;

  template&lt;class Compare, class Container, class Allocator&gt;
    priority_queue(Compare, Container, Allocator)
      -&gt; priority_queue&lt;typename Container::value_type, Container, Compare&gt;;

<ins>  template&lt;class InputIterator, class Allocator&gt;
    priority_queue(InputIterator, InputIterator, Allocator)
      -&gt; priority_queue&lt;<i>iter-value-type</i>&lt;InputIterator&gt;,
                        vector&lt;<i>iter-value-type</i>&lt;InputIterator&gt;, Allocator&gt;,
                        less&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;&gt;;

  template&lt;class InputIterator, class Compare, class Allocator&gt;
    priority_queue(InputIterator, InputIterator, Compare, Allocator)
      -&gt; priority_queue&lt;<i>iter-value-type</i>&lt;InputIterator&gt;,
                        vector&lt;<i>iter-value-type</i>&lt;InputIterator&gt;, Allocator&gt;, Compare&gt;;

  template&lt;class InputIterator, class Compare, class Container, class Allocator&gt;
    priority_queue(InputIterator, InputIterator, Compare, Container, Allocator)
      -&gt; priority_queue&lt;typename Container::value_type, Container, Compare&gt;;</ins>

  // [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Add the following paragraphs to 22.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/priqueue.cons.alloc">[priqueue.cons.alloc]</a>:</p>
<blockquote>
<pre>
template&lt;class InputIterator, class Alloc&gt;
  priority_queue(InputIterator first, InputIterator last, const Alloc&amp; a);
</pre>
<blockquote>
<p>-?- <i>Effects:</i> Initializes <tt>c</tt> with <tt>first</tt> as the first argument, <tt>last</tt> as
the second argument, and <tt>a</tt> as the third argument, and value-initializes <tt>comp</tt>;
calls <tt>make_heap(c.begin(), c.end(), comp)</tt>. </p>
</blockquote>
<pre>
template&lt;class InputIterator, class Alloc&gt;
  priority_queue(InputIterator first, InputIterator last, const Compare&amp; compare, const Alloc&amp; a);
</pre>
<blockquote>
<p>-?- <i>Effects:</i> Initializes <tt>c</tt> with <tt>first</tt> as the first argument, <tt>last</tt> as
the second argument, and <tt>a</tt> as the third argument, and initializes <tt>comp</tt> with <tt>compare</tt>;
calls <tt>make_heap(c.begin(), c.end(), comp)</tt>. </p>
</blockquote>
<pre>
template&lt;class InputIterator, class Alloc&gt;
  priority_queue(InputIterator first, InputIterator last, const Compare&amp; compare, const Container&amp; cont, const Alloc&amp; a);
</pre>
<blockquote>
<p>-?- <i>Effects:</i> Initializes <tt>c</tt> with <tt>cont</tt> as the first argument and <tt>a</tt> as
the second argument, and initializes <tt>comp</tt> with <tt>compare</tt>; calls <tt>c.insert(c.end(), first, last)</tt>;
and finally calls <tt>make_­heap(c.begin(), c.end(), comp)</tt>. </p>
</blockquote>
<pre>
template&lt;class InputIterator, class Alloc&gt;
  priority_queue(InputIterator first, InputIterator last, const Compare&amp; compare, Container&amp;&amp; cont, const Alloc&amp; a);
</pre>
<blockquote>
<p>-?- <i>Effects:</i> Initializes <tt>c</tt> with <tt>std::move(cont)</tt> as the first argument and <tt>a</tt> as
the second argument, and initializes <tt>comp</tt> with <tt>compare</tt>; calls <tt>c.insert(c.end(), first, last)</tt>;
and finally calls <tt>make_­heap(c.begin(), c.end(), comp)</tt>. </p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3517" href="3517">3517.</a> <tt>join_view::<i>iterator</i></tt>'s <tt>iter_swap</tt> is underconstrained</h3>
<p><b>Section:</b> 24.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2021-01-28 <b>Last modified:</b> 2021-03-12 15:09:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.iterator">active issues</a> in [range.join.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.iterator">issues</a> in [range.join.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::ranges::join_view::<i>iterator</i></tt>'s hidden friend <tt>iter_swap</tt> is specified in 
24.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a>/16 as:
</p>
<blockquote>
<pre>
friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
  noexcept(noexcept(ranges::iter_swap(x.<i>inner_</i>, y.<i>inner_</i>)));
</pre>
<blockquote>
<p>
-16- <i>Effects:</i> Equivalent to: <tt>return ranges::iter_swap(x.<i>inner_</i>, y.<i>inner_</i>);</tt>
</p>
</blockquote>
</blockquote>
<p>
Notably, the expression <tt>ranges::iter_swap(<i>meow</i>, <i>woof</i>)</tt> is not valid for all 
iterators <tt><i>meow</i></tt> and <tt><i>woof</i></tt>, or even all input iterators of the same 
type as is the case here. This <tt>iter_swap</tt> overload should be constrained to require the 
type of <tt>iterator::<i>inner_</i></tt> (<tt>iterator_t&lt;range_reference_t&lt;<i>maybe-const</i>&lt;Const, V&gt;&gt;&gt;)</tt> 
to satisfy <tt>indirectly_swappable</tt>. Notably this is already the case for <tt>iter_swap</tt> 
friends of every other iterator adaptor in the Standard Library (<tt>reverse_iterator</tt>, <tt>move_iterator</tt>, 
<tt>common_iterator</tt>, <tt>counted_iterator</tt>, <tt>filter_view::iterator</tt>, <tt>transform_view::iterator</tt>, and <tt>split_view::<i>inner-iterator</i></tt>). The omission for <tt>join_view::<i>iterator</i></tt> seems to 
have simply been an oversight.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>. 
</p>

<ol>
<li><p>Modify 24.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> If <a href="3500">3500</a> is accepted before this issue, it is 
kindly suggested to the Project Editor to apply the equivalent replacement of
"<tt>iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</tt>" by "<tt><i>InnerIter</i></tt>" to
the newly inserted <tt>requires</tt>.
</p>
</blockquote>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt; &amp;&amp;
             (is_reference_v&lt;range_reference_t&lt;V&gt;&gt; ||
             view&lt;range_value_t&lt;V&gt;&gt;)
  template&lt;bool Const&gt;
  struct join_view&lt;V&gt;::<i>iterator</i> {
    [&hellip;]
    
    friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.<i>inner_</i>, y.<i>inner_</i>)))
      <ins>requires indirectly_swappable&lt;iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;&gt;</ins>;
  };
}
</pre>
</blockquote>
[&hellip;]
<blockquote>
<pre>
friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
  noexcept(noexcept(ranges::iter_swap(x.<i>inner_</i>, y.<i>inner_</i>)))
  <ins>requires indirectly_swappable&lt;iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-16- <i>Effects:</i> Equivalent to: <tt>return ranges::iter_swap(x.<i>inner_</i>, y.<i>inner_</i>);</tt>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3518" href="3518">3518.</a> Exception requirements on char trait operations unclear</h3>
<p><b>Section:</b> 21.2.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.require">[char.traits.require]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Zoe Carver <b>Opened:</b> 2021-02-01 <b>Last modified:</b> 2021-03-12 15:09:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#char.traits.require">active issues</a> in [char.traits.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.require">issues</a> in [char.traits.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.2.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.require">[char.traits.require]</a> p1 says:
</p>
<blockquote>
<p>
<tt>X</tt> denotes a traits class defining types and functions for the character container type 
<tt>C</tt> [&hellip;] Operations on <tt>X</tt> shall not throw exceptions.
</p>
</blockquote>
<p>
It should be clarified what "operations on <tt>X</tt>" means. For example, in <a href="https://reviews.llvm.org/D95251">this 
patch</a>, there was some confusion around the exact meaning of "operations on <tt>X</tt>". If it refers to 
the expressions specified in [tab:char.traits.req] or if it refers to all member functions of <tt>X</tt>, 
this should be worded in some clearer way. 
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>. 
</p>

<ol>
<li><p>Modify 21.2.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.require">[char.traits.require]</a> as indicated:</p>

<blockquote>
<p>
-1- In Table [tab:char.traits.req], <tt>X</tt> denotes a traits class defining types and functions for the 
character container type <tt>C</tt>; [&hellip;] <del>Operations on <tt>X</tt> shall not throw exceptions</del><ins>No
expression which is part of the character traits requirements specified in this subclause 21.2.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.require">[char.traits.require]</a> 
shall exit via an exception</ins>.
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3519" href="3519">3519.</a> Incomplete synopses for <tt>&lt;random&gt;</tt> classes</h3>
<p><b>Section:</b> 26.6.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a>, 26.6.5 <a href="https://timsong-cpp.github.io/cppwp/rand.adapt">[rand.adapt]</a>, 26.6.9 <a href="https://timsong-cpp.github.io/cppwp/rand.dist">[rand.dist]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2021-02-02 <b>Last modified:</b> 2021-03-12 17:48:31 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopses for the engine and distribution classes in <tt>&lt;random&gt;</tt> do
not show declarations <tt>operator==</tt>, <tt>operator!=</tt>, <tt>operator&lt;&lt;</tt>, 
and <tt>operator&gt;&gt;</tt>, although they are part of the engine and distribution requirements.
<p/>
Suggested resolution:
<p/>
Add these operators as hidden friends to the respective class synopses.
</p>

<p><i>[2021-02-07: Daniel provides concrete wording]</i></p>

<p>
The proposed wording attempts to use a conservative approach in regard to exception specifications. Albeit 
26.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.general">[rand.eng.general]</a> p3 says that "no function described in 26.6.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a> throws 
an exception" (unless specified otherwise), not all implementations have marked the equality operators 
as <tt>noexcept</tt> (But some do for their engines, such as VS 2019). [No implementations marks the IO 
stream operators as <tt>noexcept</tt> of-course, because these cannot be prevented to throw exceptions in 
general by design].
<p/>
The wording also uses hidden friends of the IO streaming operators ("inserters and extractors") as
suggested by the issue discussion, but it should be noted that at least some existing implementations use 
out-of-class free function templates for their distributions.
<p/>
Note that we intentionally don't declare any <tt>operator!=</tt>, because the auto-generated form already has
the right semantics. The wording also covers the engine adaptor class templates because similar requirements 
apply to them.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set priority to 3 following reflector poll.
</p>


<p><i>[2021-03-12; LWG telecon]</i></p>

<p>
Set status to Tentatively Ready after discussion and poll.
<table>
<tr><th>F</th><th>A</th><th>N</th></tr>
<tr><td>10</td><td>0</td><td>0</td></tr>
</table>
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>. 
</p>

<ol>
<li><p>Modify 26.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.lcong">[rand.eng.lcong]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class UIntType, UIntType a, UIntType c, UIntType m&gt;
class linear_congruential_engine {
  [&hellip;]
  <i>// constructors and seeding functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const linear_congruential_engine&amp; x, const linear_congruential_engine&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const linear_congruential_engine&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, linear_congruential_engine&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.mers">[rand.eng.mers]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class UIntType, size_t w, size_t n, size_t m, size_t r,
            UIntType a, size_t u, UIntType d, size_t s,
            UIntType b, size_t t,
            UIntType c, size_t l, UIntType f&gt;
class mersenne_twister_engine {
  [&hellip;]
  <i>// constructors and seeding functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const mersenne_twister_engine&amp; x, const mersenne_twister_engine&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const mersenne_twister_engine&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, mersenne_twister_engine&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.4.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.sub">[rand.eng.sub]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class UIntType, size_t w, size_t s, size_t r&gt;
class subtract_with_carry_engine {
  [&hellip;]
  <i>// constructors and seeding functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const subtract_with_carry_engine&amp; x, const subtract_with_carry_engine&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const subtract_with_carry_engine&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, subtract_with_carry_engine&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/rand.adapt.disc">[rand.adapt.disc]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Engine, size_t p, size_t r&gt;
class discard_block_engine {
  [&hellip;]
  <i>// constructors and seeding functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const discard_block_engine&amp; x, const discard_block_engine&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const discard_block_engine&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, discard_block_engine&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/rand.adapt.ibits">[rand.adapt.ibits]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Engine, size_t w, class UIntType&gt;
class independent_bits_engine {
  [&hellip;]
  <i>// constructors and seeding functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const independent_bits_engine&amp; x, const independent_bits_engine&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const independent_bits_engine&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, independent_bits_engine&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.adapt.shuf">[rand.adapt.shuf]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Engine, size_t k&gt;
class shuffle_order_engine {
  [&hellip;]
  <i>// constructors and seeding functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const shuffle_order_engine&amp; x, const shuffle_order_engine&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const shuffle_order_engine&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, shuffle_order_engine&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.uni.int">[rand.dist.uni.int]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class IntType = int&gt;
class uniform_int_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const uniform_int_distribution&amp; x, const uniform_int_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const uniform_int_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, uniform_int_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.2.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.uni.real">[rand.dist.uni.real]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class uniform_real_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const uniform_real_distribution&amp; x, const uniform_real_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const uniform_real_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, uniform_real_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern.bernoulli">[rand.dist.bern.bernoulli]</a> as indicated:</p>

<blockquote>
<pre>
class bernoulli_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const bernoulli_distribution&amp; x, const bernoulli_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const bernoulli_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, bernoulli_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern.bin">[rand.dist.bern.bin]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class IntType = int&gt;
class binomial_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const binomial_distribution&amp; x, const binomial_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const binomial_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, binomial_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.3.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern.geo">[rand.dist.bern.geo]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class IntType = int&gt;
class geometric_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const geometric_distribution&amp; x, const geometric_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const geometric_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, geometric_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern.negbin">[rand.dist.bern.negbin]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class IntType = int&gt;
class negative_binomial_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const negative_binomial_distribution&amp; x, const negative_binomial_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const negative_binomial_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, negative_binomial_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.4.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.pois.poisson">[rand.dist.pois.poisson]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class IntType = int&gt;
class poisson_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const poisson_distribution&amp; x, const poisson_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const poisson_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, poisson_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.4.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.pois.exp">[rand.dist.pois.exp]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class exponential_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const exponential_distribution&amp; x, const exponential_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const exponential_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, exponential_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.4.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.pois.gamma">[rand.dist.pois.gamma]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class gamma_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const gamma_distribution&amp; x, const gamma_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const gamma_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, gamma_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.4.4 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.pois.weibull">[rand.dist.pois.weibull]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class weibull_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const weibull_distribution&amp; x, const weibull_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const weibull_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, weibull_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.4.5 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.pois.extreme">[rand.dist.pois.extreme]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class extreme_value_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const extreme_value_distribution&amp; x, const extreme_value_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const extreme_value_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, extreme_value_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.5.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.norm.normal">[rand.dist.norm.normal]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class normal_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const normal_distribution&amp; x, const normal_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const normal_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, normal_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.5.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.norm.lognormal">[rand.dist.norm.lognormal]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class lognormal_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const lognormal_distribution&amp; x, const lognormal_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const lognormal_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, lognormal_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.5.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.norm.chisq">[rand.dist.norm.chisq]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class chi_squared_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const chi_squared_distribution&amp; x, const chi_squared_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const chi_squared_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, chi_squared_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.norm.cauchy">[rand.dist.norm.cauchy]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class cauchy_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const cauchy_distribution&amp; x, const cauchy_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const cauchy_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, cauchy_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.5.5 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.norm.f">[rand.dist.norm.f]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class fisher_f_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const fisher_f_distribution&amp; x, const fisher_f_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const fisher_f_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, fisher_f_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.5.6 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.norm.t">[rand.dist.norm.t]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class student_t_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const student_t_distribution&amp; x, const student_t_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const student_t_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, student_t_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.6.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.discrete">[rand.dist.samp.discrete]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class IntType = int&gt;
class discrete_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const discrete_distribution&amp; x, const discrete_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const discrete_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, discrete_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class piecewise_constant_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const piecewise_constant_distribution&amp; x, const piecewise_constant_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const piecewise_constant_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, piecewise_constant_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.6.9.6.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.plinear">[rand.dist.samp.plinear]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RealType = double&gt;
class piecewise_linear_distribution {
  [&hellip;]
  <i>// constructors and reset functions</i>
  [&hellip;]
  
  <ins><i>// equality operators</i></ins>
  <ins>friend bool operator==(const piecewise_linear_distribution&amp; x, const piecewise_linear_distribution&amp; y);</ins>

  <i>// generating functions</i>
  [&hellip;]
  
  <i>// property functions</i>
  [&hellip;]
  
  <ins><i>// inserters and extractors</i></ins>
  <ins>template&lt;class charT, class traits&gt;
    friend basic_ostream&lt;charT, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const piecewise_linear_distribution&amp; x);
  template&lt;class charT, class traits&gt;
    friend basic_istream&lt;charT, traits&gt;&amp;
      operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, piecewise_linear_distribution&amp; x);</ins>
};
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3520" href="3520">3520.</a> <tt>iter_move</tt> and <tt>iter_swap</tt> are inconsistent for <tt>transform_view::<i>iterator</i></tt></h3>
<p><b>Section:</b> 24.7.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.transform.iterator">[range.transform.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2021-02-03 <b>Last modified:</b> 2021-03-12 17:48:31 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.transform.iterator">issues</a> in [range.transform.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <tt>transform_view::<i>iterator</i></tt>, <tt>iter_move</tt> is specified to operate on the
transformed value but <tt>iter_swap</tt> is specified to operate on the underlying iterator.
<p/>
Consider the following test case:
</p>
<blockquote><pre>
struct X { int x; int y; };
std::vector&lt;X&gt; v = {...};
auto t = v | views::transform(&amp;X::x);
ranges::sort(t);
</pre></blockquote>
<p>
<tt>iter_swap</tt> on <tt>t</tt>'s iterators would swap the whole <tt>X</tt>, including the 
<tt>y</tt> part, but <tt>iter_move</tt> will only move the <tt>x</tt> data member and leave 
the <tt>y</tt> part intact. Meanwhile, <tt>ranges::sort</tt> can use both <tt>iter_move</tt> and
<tt>iter_swap</tt>, and does so in at least one implementation. The mixed behavior means that we 
get neither "sort <tt>X</tt>s by their <tt>x</tt> data member" (as <tt>ranges::sort(v, {}, &amp;X::x)</tt> 
would do), nor "sort the <tt>x</tt> data member of these <tt>X</tt>s and leave the rest unchanged", 
as one might expect, but instead some arbitrary permutation of <tt>y</tt>. This seems like a
questionable state of affairs.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set priority to 2 following reflector poll.
</p>


<p><i>[2021-03-12; LWG telecon]</i></p>

<p>
Set status to Tentatively Ready after discussion and poll.
<table>
<tr><th>F</th><th>A</th><th>N</th></tr>
<tr><td>9</td><td>0</td><td>0</td></tr>
</table>
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>. 
</p>

<ol>
<li><p>Modify 24.7.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.transform.iterator">[range.transform.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V, copy_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  template&lt;bool Const&gt;
  class transform_view&lt;V, F&gt;::<i>iterator</i> {
    [&hellip;]
    <del>friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.<i>current_</i>, y.<i>current_</i>)))
      requires indirectly_swappable&lt;iterator_t&lt;<i>Base</i>&gt;&gt;;</del>
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
<del>friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
  noexcept(noexcept(ranges::iter_swap(x.<i>current_</i>, y.<i>current_</i>)))
  requires indirectly_swappable&lt;iterator_t&lt;<i>Base</i>&gt;&gt;;</del>
</pre>
<blockquote>
<p>
<del>-23- <i>Effects:</i> Equivalent to <tt>ranges::iter_swap(x.<i>current_</i>, y.<i>current_</i>)</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3521" href="3521">3521.</a> Overly strict requirements on <tt>qsort</tt> and <tt>bsearch</tt></h3>
<p><b>Section:</b> 25.12 <a href="https://timsong-cpp.github.io/cppwp/alg.c.library">[alg.c.library]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2021-02-02 <b>Last modified:</b> 2021-03-12 15:09:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.c.library">issues</a> in [alg.c.library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Per 25.12 <a href="https://timsong-cpp.github.io/cppwp/alg.c.library">[alg.c.library]</a>/2, for <tt>qsort</tt> and <tt>bsearch</tt>, we have:
</p>
<blockquote>
<p>
<i>Preconditions:</i> The objects in the array pointed to by <tt>base</tt> are of trivial type.
</p>
</blockquote>
<p>
This seems like an unnecessarily strict requirement. <tt>qsort</tt> only needs the objects to be of a 
trivially-copyable type (because it will use <tt>memcpy</tt> or equivalent to relocate them), and 
<tt>bsearch</tt> doesn't need any particular properties of the array element type. Presumably it 
would be in improvement to specify the more-precise requirements instead.
<p/>
We should also reconsider the other uses of the notion of a trivial type. It's really not a useful or 
meaningful type property by itself, because it doesn't actually require that any operations on the type 
are valid (due to the possibility of them being ambiguous or only some of them being available) and the 
places that consider it very likely actually mean <tt>is_trivially_copyable</tt> plus 
<tt>is_trivially_default_constructible</tt> instead, or perhaps <tt>is_trivially_copy_constructible</tt> 
and <tt>is_trivially_move_constructible</tt> and so on.
<p/>
Other than <tt>qsort</tt> and <tt>bsearch</tt>, the only uses of this type property in the standard are 
to constrain <tt>max_align_t</tt>, <tt>aligned_storage</tt>, <tt>aligned_union</tt>, and the element type 
of <tt>basic_string</tt> (and in the definition of the deprecated <tt>is_pod</tt> trait), all of which 
(other than <tt>is_pod</tt>) I think really mean "is trivially default constructible", not "has at least 
one eligible default constructor and all eligible default constructors are trivial". And in fact I think 
the alignment types are underspecified &mdash; we don't want to require merely that they be 
trivially-copyable, since that doesn't require any particular operation on them to actually be valid &mdash; 
we also want to require that they actually model <tt>semiregular</tt>.
</p>

<p><i>[2021-02-23; Casey Carter provides concrete wording]</i></p>


<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>. 
</p>

<ol>
<li><p>Modify 25.12 <a href="https://timsong-cpp.github.io/cppwp/alg.c.library">[alg.c.library]</a> as indicated:</p>

<blockquote>
<pre>
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
             <i>c-compare-pred</i>* compar);
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              <i>compare-pred</i>* compar);
void qsort(void* base, size_t nmemb, size_t size, <i>c-compare-pred</i>* compar);
void qsort(void* base, size_t nmemb, size_t size, <i>compare-pred</i>* compar);
</pre>
<blockquote>
<p>
-2- <i>Preconditions:</i> <ins>For <tt>qsort</tt>, t</ins><del>T</del>he objects in the array pointed to 
by <i>base</i> are of <del>trivial</del><ins>trivially copyable</ins> type.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3522" href="3522">3522.</a> Missing requirement on <tt>InputIterator</tt> template parameter for <tt>priority_queue</tt> constructors</h3>
<p><b>Section:</b> 22.6.5 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2021-02-17 <b>Last modified:</b> 2021-02-26 17:32:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#priority.queue">active issues</a> in [priority.queue].</p>
<p><b>View all other</b> <a href="lwg-index.html#priority.queue">issues</a> in [priority.queue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is nothing in 22.6.5 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a> or more generally 22.6 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors">[container.adaptors]</a>
saying that <tt>InputIterator</tt> in the following constructor templates has to be an input iterator.
</p>
<blockquote><pre>
template&lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last, const Compare&amp; x,
                    const Container&amp;);
template&lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last,
                    const Compare&amp; x = Compare(), Container&amp;&amp; = Container());
</pre></blockquote>
<p>
The second constructor template above therefore accepts
</p>
<blockquote><pre>
std::priority_queue&lt;int&gt; x = {1, 2};
</pre></blockquote>
<p>
to produce a <tt>priority_queue</tt> that contains a single element <tt>2</tt>. This behavior seems extremely questionable.
</p>

<p><i>[2021-02-26; LWG telecon]</i></p>

<p>
Set status to Tentatively Ready after discussion and poll.
<table>
<tr><th>F</th><th>A</th><th>N</th></tr>
<tr><td>11</td><td>0</td><td>0</td></tr>
</table>
</p>



<p><b>Proposed resolution:</b></p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: Because <a href="https://wg21.link/P1425">an upcoming paper</a>
provides iterator-pair constructors for other container adaptors, the wording below
adds the restriction to 22.6.1 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.general">[container.adaptors.general]</a> so that it also
covers the constructors that will be added by that paper.
&mdash; <i>end drafting note</i>]
</p>
</blockquote>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li><p>Add the following paragraph to 22.6.1 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.general">[container.adaptors.general]</a> after p3:</p>
<blockquote>
<p>
<ins>-?- A constructor template of a container adaptor shall not participate in
overload resolution if it has an <tt>InputIterator</tt> template parameter and a
type that does not qualify as an input iterator is deduced for that parameter.</ins>
</p>
<p>
-4- A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true:
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; It has an <tt>InputIterator</tt> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3523" href="3523">3523.</a> <tt>iota_view::<i>sentinel</i></tt> is not always <tt>iota_view</tt>'s sentinel</h3>
<p><b>Section:</b> 24.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2021-02-17 <b>Last modified:</b> 2021-03-12 15:09:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.iota.view">issues</a> in [range.iota.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P1739R4">P1739R4</a> added the following constructor to
<tt>iota_view</tt>:
</p>
<blockquote><pre>
constexpr iota_view(<i>iterator</i> first, <i>sentinel</i> last) : iota_view(*first, last.<i>bound_</i>) {}
</pre></blockquote>
<p>
However, while <tt>iota_view</tt>'s iterator type is always <tt>iota_view::<i>iterator</i></tt>, its sentinel type
is not always <tt>iota_view::<i>sentinel</i></tt>. First, if <tt>Bound</tt> is <tt>unreachable_sentinel_t</tt>, then
the sentinel type is <tt>unreachable_sentinel_t</tt> too - we don't add an unnecessary level of wrapping
on top. Second, when <tt>W</tt> and <tt>Bound</tt> are the same type, <tt>iota_view</tt> models <tt>common_range</tt>, and
the sentinel type is the same as the iterator type - that is, <tt><i>iterator</i></tt>, not <tt><i>sentinel</i></tt>.
</p>
<p>
Presumably the intent is to use the view's actual sentinel type, rather than always use the
<tt><i>sentinel</i></tt> type.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li><p>Edit 24.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a>, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  // [...]

  template&lt;weakly_­incrementable W, semiregular Bound = unreachable_sentinel_t&gt;
    requires <i>weakly-equality-comparable-with</i>&lt;W, Bound&gt; &amp;&amp; semiregular&lt;W&gt;
  class iota_view : public view_interface&lt;iota_view&lt;W, Bound&gt;&gt; {
  private:
    // [range.iota.iterator], class iota_­view​::​iterator
    struct <i>iterator</i>;            // exposition only
    // [range.iota.sentinel], class iota_­view​::​sentinel
    struct <i>sentinel</i>;            // exposition only
    W <i>value_</i> = W();             // exposition only
    Bound <i>bound_</i> = Bound();     // exposition only
  public:
    iota_view() = default;
    constexpr explicit iota_view(W value);
    constexpr iota_view(type_identity_t&lt;W&gt; value,
                        type_identity_t&lt;Bound&gt; bound);
    constexpr iota_view(<i>iterator</i> first, <i><del>sentinel</del><ins>see below</ins></i> last)<ins>;</ins><del>: iota_view(*first, last.<i>bound_</i>) {}</del>

    constexpr <i>iterator</i> begin() const;
    constexpr auto end() const;
    constexpr <i>iterator</i> end() const requires same_­as&lt;W, Bound&gt;;

    constexpr auto size() const requires see below;
  };

  template&lt;class W, class Bound&gt;
      requires (!<i>is-integer-like</i>&lt;W&gt; || !<i>is-integer-like</i>&lt;Bound&gt; ||
              (<i>is-signed-integer-like</i>&lt;W&gt; == <i>is-signed-integer-like</i>&lt;Bound&gt;))
      iota_view(W, Bound) -&gt; iota_view&lt;W, Bound&gt;;
}
</pre>
<p>[...]</p>
<pre>
constexpr iota_view(type_identity_t&lt;W&gt; value, type_identity_t&lt;Bound&gt; bound);
</pre>
<blockquote>
<p>-8- <i>Preconditions</i>: <tt>Bound</tt> denotes <tt>unreachable_­sentinel_­t</tt> or <tt>bound</tt> is reachable
from <tt>value</tt>. When <tt>W</tt> and <tt>Bound</tt> model <tt>totally_­ordered_­with</tt>, then <tt>bool(value &lt;= bound)</tt> is true.</p>
<p>-9- <i>Effects</i>: Initializes <tt><i>value_</i></tt>­ with <tt>value</tt> and <tt><i>bound_</i></tt> with <tt>bound</tt>.</p>
</blockquote>
<pre>
<ins>constexpr iota_view(<i>iterator</i> first, <i>see below</i> last);</ins>
</pre>
<blockquote>
<p><ins>-?- <i>Effects</i>: Equivalent to:</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; If <tt>same_as&lt;W, Bound&gt;</tt> is <tt>true</tt>, <tt>iota_view(first.<i>value_</i>, last.<i>value_</i>)</tt>.</ins></p></li>
<li><p><ins>(?.2) &mdash; Otherwise, if <tt>Bound</tt> denotes <tt>unreachable_sentinel_t</tt>, <tt>iota_view(first.<i>value_</i>, last)</tt>.</ins></p></li>
<li><p><ins>(?.3) &mdash; Otherwise, <tt>iota_view(first.<i>value_</i>, last.<i>bound_</i>)</tt>.</ins></p></li>
</ol>
<p><ins>-?- <i>Remarks</i>: The type of <tt>last</tt> is:</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; If <tt>same_as&lt;W, Bound&gt;</tt> is <tt>true</tt>, <tt><i>iterator</i></tt>.</ins></p></li>
<li><p><ins>(?.2) &mdash; Otherwise, if <tt>Bound</tt> denotes <tt>unreachable_sentinel_t</tt>, <tt>Bound</tt>.</ins></p></li>
<li><p><ins>(?.3) &mdash; Otherwise, <tt><i>sentinel</i></tt>.</ins></p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3527" href="3527">3527.</a> <tt>uses_allocator_construction_args</tt> handles rvalue pairs of rvalue references incorrectly</h3>
<p><b>Section:</b> 20.10.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2021-02-27 <b>Last modified:</b> 2021-03-12 15:09:53 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.uses.construction">active issues</a> in [allocator.uses.construction].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.uses.construction">issues</a> in [allocator.uses.construction].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For an rvalue pair <tt>pr</tt>, <tt>uses_allocator_construction_args</tt> is specified to forward
<tt>std::move(pr).first</tt> and <tt>std::move(pr).second</tt>. This is correct
for non-references and lvalue references, but wrong for rvalue refrences because
the class member access produces an lvalue (see 7.6.1.5 <a href="https://timsong-cpp.github.io/cppwp/expr.ref">[expr.ref]</a>/6).
<tt>get</tt> produces an xvalue, which is what is desired here.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li><p>Edit 20.10.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T, class Alloc, class U, class V&gt;
  constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                  pair&lt;U, V&gt;&amp;&amp; pr) noexcept -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
return uses_allocator_construction_args&lt;T&gt;(alloc, piecewise_construct,
                                            forward_as_tuple(<del>std::move(pr).first</del><ins>get&lt;0&gt;(std::move(pr))</ins>),
                                            forward_as_tuple(<del>std::move(pr).second</del><ins>get&lt;1&gt;(std::move(pr))</ins>));
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3528" href="3528">3528.</a> <tt>make_from_tuple</tt> can perform (the equivalent of) a C-style cast</h3>
<p><b>Section:</b> 20.5.5 <a href="https://timsong-cpp.github.io/cppwp/tuple.apply">[tuple.apply]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2021-02-28 <b>Last modified:</b> 2021-03-12 15:11:05 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>make_from_tuple</tt> is specified to return <tt>T(get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...)</tt>.
When there is only a single tuple element, this is equivalent to a C-style cast
that may be a <tt>reinterpret_cast</tt>, a <tt>const_cast</tt>,
or an access-bypassing <tt>static_cast</tt>.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set priority to 3 following reflector poll.
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li><p>Edit 20.5.5 <a href="https://timsong-cpp.github.io/cppwp/tuple.apply">[tuple.apply]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T, class Tuple&gt;
  constexpr T make_from_tuple(Tuple&amp;&amp; t);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Effects:</i>  Given the exposition-only function:
</p>
<blockquote><pre>
template&lt;class T, class Tuple, size_t... I&gt;
<ins>  requires is_constructible_v&lt;T, decltype(get&lt;I&gt;(declval&lt;Tuple&gt;()))...></ins>
constexpr T <i>make-from-tuple-impl</i>(Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) {     // exposition only
  return T(get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
}
</pre></blockquote>
<p>
Equivalent to:
</p>
<blockquote><pre>
return <i>make-from-tuple-impl</i>&lt;T&gt;(
  <ins>std::</ins>forward&lt;Tuple&gt;(t),
  make_index_sequence&lt;tuple_size_v&lt;remove_reference_t&lt;Tuple&gt;&gt;&gt;{});
</pre></blockquote>
<p>
[<i>Note 1:</i> The type of T must be supplied as an explicit template parameter,
as it cannot be deduced from the argument list. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3529" href="3529">3529.</a> <code>priority_queue(first, last)</code> should construct <code>c</code> with <code>(first, last)</code></h3>
<p><b>Section:</b> 22.6.5 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2021-03-01 <b>Last modified:</b> 2021-03-12 15:11:10 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#priority.queue">active issues</a> in [priority.queue].</p>
<p><b>View all other</b> <a href="lwg-index.html#priority.queue">issues</a> in [priority.queue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Tim's new constructors for <code>priority_queue</code> (LWG <a href="3506">3506</a>)
are specified so that when you construct
</p>
<blockquote>
<pre>
auto pq = PQ(first, last, a);
</pre>
</blockquote>
<p>
it calls this new-in-LWG3506 constructor:
</p>
<blockquote>
<pre>
template&lt;class InputIterator, class Alloc&gt;
  priority_queue(InputIterator first, InputIterator last, const Alloc&amp; a);
</pre>
<p>
<i>Effects:</i>
Initializes <code>c</code> with <code>first</code> as the first argument,
<code>last</code> as the second argument,
and <code>a</code> as the third argument,
and value-initializes <code>comp</code>;
calls <code>make_heap(c.begin(), c.end(), comp)</code>.
</p>
</blockquote>
<p>
But the pre-existing constructors are specified so that when you construct
</p>
<blockquote>
<pre>
auto pq = PQ(first, last);
</pre>
</blockquote>
<p>
it calls this pre-existing constructor:
</p>
<blockquote>
<pre>
template&lt;class InputIterator&gt;
  priority_queue(InputIterator first, InputIterator last, const Compare&amp; x = Compare(), Container&amp;&amp; y = Container());
</pre>
<p>
<i>Preconditions:</i>
<code>x</code> defines a strict weak ordering ([alg.sorting]).
</p>
<p>
<i>Effects:</i>
Initializes <code>comp</code> with <code>x</code>
and <code>c</code> with <code>y</code>
(copy constructing or move constructing as appropriate);
calls <code>c.insert(c.end(), first, last)</code>;
and finally calls <code>make_heap(c.begin(), c.end(), comp)</code>.
</p>
</blockquote>

<p>
In other words,
</p>
<blockquote>
<pre>
auto pq = PQ(first, last);
</pre>
</blockquote>
<p>
will default-construct a <code>Container</code>,
then move-construct <code>c</code> from that object,
then <code>c.insert(first, last)</code>,
and finally <code>make_heap</code>.
</p>
<p>
But our new
</p>
<blockquote>
<pre>
auto pq = PQ(first, last, a);
</pre>
</blockquote>
<p>
will simply construct <code>c</code> with <code>(first, last)</code>,
then <code>make_heap</code>.
</p>
<p>
The latter is obviously better.
</p>
<p>
Also, Corentin's <a href="https://wg21.link/p1425r3">P1425R3</a>
specifies the new iterator-pair constructors for
<code>stack</code> and <code>queue</code>
to construct <code>c</code> from <code>(first, last)</code>. Good.
</p>
<p>
LWG should refactor the existing constructor overload set so that
the existing non-allocator-taking constructors simply construct <code>c</code>
from <code>(first, last)</code>.
This will improve consistency with the resolutions of LWG3506 and P1425,
and reduce the surprise factor for users.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li>
<p>Edit 22.6.5.1 <a href="https://timsong-cpp.github.io/cppwp/priqueue.overview">[priqueue.overview]</a> as indicated:</p>

<blockquote>
<pre>
<ins>
template&lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last, const Compare&amp; x = Compare());</ins>
template&lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last, const Compare&amp; x, const Container&amp; y);
template&lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last, const Compare&amp; x<del><del> = Compare()</del></del>, Container&amp;&amp; y<del> = Container()</del>);
</pre>
</blockquote>
</li>

<li>
<p>Edit 22.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/priqueue.cons">[priqueue.cons]</a> as indicated:</p>

<blockquote>
<pre>
<ins>
template&lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last, const Compare&amp; x = Compare());
</ins>
</pre>
<p>
<ins>
<i>Preconditions:</i>
<code>x</code> defines a strict weak ordering ([alg.sorting]).
</ins>
</p>
<p>
<ins>
<i>Effects:</i>
Initializes <code>c</code> with <code>first</code> as the first argument and <code>last</code> as the second argument, and initializes <code>comp</code> with <code>x</code>; then calls <code>make_heap(c.begin(), c.end(), comp)</code>.
</ins>
</p>

<pre>
template&lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last, const Compare&amp; x, const Container&amp; y);
template&lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last, const Compare&amp; x<del> = Compare()</del>, Container&amp;&amp; y<del> = Container()</del>);
</pre>
<p>
<i>Preconditions:</i>
<code>x</code> defines a strict weak ordering ([alg.sorting]).
</p>
<p>
<i>Effects:</i>
Initializes <code>comp</code> with <code>x</code> and <code>c</code> with <code>y</code> (copy constructing or
move constructing as appropriate); calls <code>c.insert(c.end(), first, last)</code>;
and finally calls <code>make_heap(c.begin(), c.end(), comp)</code>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3530" href="3530">3530.</a> <tt><i>BUILTIN-PTR-MEOW</i></tt> should not opt the type out of syntactic checks</h3>
<p><b>Section:</b> 20.14.8.8 <a href="https://timsong-cpp.github.io/cppwp/comparisons.three.way">[comparisons.three.way]</a>, 20.14.9 <a href="https://timsong-cpp.github.io/cppwp/range.cmp">[range.cmp]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2021-03-04 <b>Last modified:</b> 2021-03-12 15:11:18 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The use of <tt><i>BUILTIN-PTR-MEOW</i></tt> for the constrained comparison
function objects was needed to disable the semantic requirements on the
associated concepts when the comparison resolves to a built-in operator
comparing pointers: the comparison object is adding special handling for this
case to produce a total order despite the core language saying otherwise,
so requiring the built-in operator to then produce a total order as part
of the semantic requirements doesn't make sense.
<p/>
However, because it is specified as a disjunction on the constraint,
it means that the comparison function objects are now required to accept
types that don't even meet the syntactic requirements of the associated
concept. For example, <tt>ranges::less</tt> requires all six comparison operators
(because of <tt>totally_ordered_with</tt>) to be present &hellip; except when
<tt>operator&lt;</tt> on the arguments resolves to a built-in operator comparing
pointers, in which case it just requires <tt>operator&lt;</tt> and <tt>operator==</tt>
(except that the latter isn't even required to be checked &mdash; it comes from the use
of <tt>ranges::equal_to</tt> in the precondition of <tt>ranges::less</tt>).
This seems entirely arbitrary.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li><p>Edit 20.14.8.8 <a href="https://timsong-cpp.github.io/cppwp/comparisons.three.way">[comparisons.three.way]</a> as indicated:</p>
<blockquote>
<p>
<del>-1- In this subclause, <tt><i>BUILTIN-PTR-THREE-WAY</i>(T, U)</tt> for types <tt>T</tt>
and <tt>U</tt> is a boolean constant expression. <tt><i>BUILTIN-PTR-THREE-WAY</i>(T, U)</tt>
is true if and only if <tt>&lt;=&gt;</tt> in the expression</del>
</p>
<blockquote><pre>
<del>declval&lt;T&gt;() &lt;=&gt; declval&lt;U&gt;()</del>
</pre></blockquote>
<p><del>resolves to a built-in operator comparing pointers.</del></p>

<pre>
struct compare_three_way {
  template&lt;class T, class U&gt;
    <del>requires three_way_comparable_with&lt;T, U&gt; || <i>BUILTIN-PTR-THREE-WAY</i>(T, U)</del>
  constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  using is_transparent = <i>unspecified</i>;
};
</pre>

<pre>
template&lt;class T, class U&gt;
  <del>requires three_way_comparable_with&lt;T, U&gt; || <i>BUILTIN-PTR-THREE-WAY</i>(T, U)</del>
constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const;
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>T</tt> and <tt>U</tt> satisfy <tt>three_way_comparable_with</tt>.</ins>
<p/>
-2- <i>Preconditions:</i> If the expression
<tt>std​::​forward&lt;T&gt;(t) &lt;=&gt; std​::​forward&lt;U&gt;(u)</tt> results in a call
to a built-in operator <tt>&lt;=&gt;</tt> comparing pointers of type <tt>P</tt>, the conversion
sequences from both <tt>T</tt> and <tt>U</tt> to <tt>P</tt> are equality-preserving
(18.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>)<ins>; otherwise, <tt>T</tt> and <tt>U</tt>
model <tt>three_way_comparable_with</tt></ins>.
<p/>
-3- <i>Effects:</i></p>
<ol style="list-style-type: none">
<li><p>
(3.1) &mdash; If the expression <tt>std​::​forward&lt;T&gt;(t) &lt;=&gt; std​::​forward&lt;U&gt;(u)</tt>
results in a call to a built-in operator <tt>&lt;=&gt;</tt> comparing pointers of type <tt>P</tt>,
returns <tt>strong_­ordering​::​less</tt> if (the converted value of) <tt>t</tt> precedes <tt>u</tt> in
the implementation-defined strict total order over pointers (3.27 <a href="https://timsong-cpp.github.io/cppwp/defns.order.ptr">[defns.order.ptr]</a>),
<tt>strong_­ordering​::​greater</tt> if <tt>u</tt> precedes <tt>t</tt>, and otherwise <tt>strong_­ordering​::​equal</tt>.
</p>
</li>
<li><p>
(3.2) &mdash; Otherwise, equivalent to: <tt>return std​::​forward&lt;T&gt;(t) &lt;=&gt; std​::​forward&lt;U&gt;(u);</tt>
</p></li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p>Edit 20.14.9 <a href="https://timsong-cpp.github.io/cppwp/range.cmp">[range.cmp]</a> as indicated:</p>
<blockquote>
<p>
<del>-1- In this subclause, <tt><i>BUILTIN-PTR-CMP</i>(T,</tt> <i>op</i><tt>, U)</tt>
for types <tt>T</tt> and <tt>U</tt> and where <i>op</i> is an equality (7.6.10 <a href="https://timsong-cpp.github.io/cppwp/expr.eq">[expr.eq]</a>)
or relational operator (7.6.9 <a href="https://timsong-cpp.github.io/cppwp/expr.rel">[expr.rel]</a>) is a boolean constant expression.
<tt><i>BUILTIN-PTR-CMP</i>(T,</tt> <i>op</i><tt>, U)</tt>
is true if and only if <i>op</i> in the expression
<tt>declval&lt;T&gt;()</tt> <i>op</i> <tt>declval&lt;U&gt;()</tt>
resolves to a built-in operator comparing pointers.</del></p>

<pre>
struct ranges::equal_to {
  template&lt;class T, class U&gt;
    <del>requires equality_comparable_with&lt;T, U&gt; || <i>BUILTIN-PTR-CMP</i>(T, ==, U)</del>
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  using is_transparent = <i>unspecified</i>;
};
</pre>

<pre>
template&lt;class T, class U&gt;
  <del>requires equality_comparable_with&lt;T, U&gt; || <i>BUILTIN-PTR-CMP</i>(T, ==, U)</del>
constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>T</tt> and <tt>U</tt> satisfy <tt>equality_comparable_with</tt>.</ins>
<p/>
-2- <i>Preconditions:</i> If the expression
<tt>std​::​forward&lt;T&gt;(t) == std​::​forward&lt;U&gt;(u)</tt> results in a call
to a built-in operator <tt>==</tt> comparing pointers of type <tt>P</tt>, the conversion
sequences from both <tt>T</tt> and <tt>U</tt> to <tt>P</tt> are equality-preserving
(18.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>)<ins>; otherwise, <tt>T</tt> and <tt>U</tt>
model <tt>equality_comparable_with</tt></ins>.
<p/>
-3- <i>Effects:</i></p>
<ol style="list-style-type: none">
<li><p>
(3.1) &mdash; If the expression <tt>std​::​forward&lt;T&gt;(t) == std​::​forward&lt;U&gt;(u)</tt>
results in a call to a built-in operator <tt>==</tt> comparing pointers of type <tt>P</tt>,
returns <tt>false</tt> if either (the converted value of) <tt>t</tt> precedes <tt>u</tt> or <tt>u</tt>
precedes <tt>t</tt> in the implementation-defined strict total order over pointers
(3.27 <a href="https://timsong-cpp.github.io/cppwp/defns.order.ptr">[defns.order.ptr]</a>) and otherwise <tt>true</tt>.
</p>
</li>
<li><p>
(3.2) &mdash; Otherwise, equivalent to: <tt>return std​::​forward&lt;T&gt;(t) == std​::​forward&lt;U&gt;(u);</tt>
</p>
</li>
</ol>
</blockquote>
<pre>
struct ranges::not_equal_to {
    template&lt;class T, class U&gt;
        <del>requires equality_comparable_with&lt;T, U&gt; || <i>BUILTIN-PTR-CMP</i>(T, ==, U)</del>
    constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

    using is_transparent = <i>unspecified</i>;
};
</pre>

<pre>
<ins>template&lt;class T, class U&gt;
constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>T</tt> and <tt>U</tt> satisfy <tt>equality_comparable_with</tt>.</ins>
<p/>
-4- <del><tt>operator()</tt> has effects e</del><ins><i>Effects:</i> E</ins>quivalent to:</p>
<blockquote><pre>
return !ranges::equal_to{}(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
</pre></blockquote>
</blockquote>
<pre>
struct ranges::greater {
  template&lt;class T, class U&gt;
    <del>requires totally_ordered_with&lt;T, U&gt; || <i>BUILTIN-PTR-CMP</i>(T, &lt;, U)</del>
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  using is_transparent = <i>unspecified</i>;
};
</pre>

<pre>
template&lt;class T, class U&gt;
constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>T</tt> and <tt>U</tt> satisfy <tt>totally_ordered_with</tt>.</ins>
<p/>
-5- <del><tt>operator()</tt> has effects e</del><ins><i>Effects:</i> E</ins>quivalent to:</p>
<blockquote><pre>
return ranges::less{}(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));
</pre></blockquote>
</blockquote>

<pre>
struct ranges::less {
  template&lt;class T, class U&gt;
    <del>requires totally_ordered_with&lt;T, U&gt; || <i>BUILTIN-PTR-CMP</i>(T, &lt;, U)</del>
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  using is_transparent = <i>unspecified</i>;
};
</pre>

<pre>
template&lt;class T, class U&gt;
  <del>requires totally_ordered_with&lt;T, U&gt; || <i>BUILTIN-PTR-CMP</i>(T, &lt;, U)</del>
constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>T</tt> and <tt>U</tt> satisfy <tt>totally_ordered_with</tt>.</ins>
<p/>
-6- <i>Preconditions:</i> If the expression
<tt>std​::​forward&lt;T&gt;(t) &lt; std​::​forward&lt;U&gt;(u)</tt> results in a call
to a built-in operator <tt>&lt;</tt> comparing pointers of type <tt>P</tt>, the conversion
sequences from both <tt>T</tt> and <tt>U</tt> to <tt>P</tt> are equality-preserving
(18.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>)<ins>; otherwise, <tt>T</tt> and <tt>U</tt>
model <tt>totally_ordered_with</tt></ins>.
For any expressions <tt>ET</tt> and <tt>EU</tt> such that <tt>decltype((ET))</tt> is <tt>T</tt> and
<tt>decltype((EU))</tt> is <tt>U</tt>, exactly one of <tt>ranges::less{}(ET, EU)</tt>, <tt>ranges::less{}(EU, ET)</tt>,
or <tt>ranges::equal_to{}(ET, EU)</tt> is <tt>true</tt>.
<p/>
-7- <i>Effects:</i></p>
<ol style="list-style-type: none">
<li><p>
(7.1) &mdash; If the expression <tt>std​::​forward&lt;T&gt;(t) &lt; std​::​forward&lt;U&gt;(u)</tt>
results in a call to a built-in operator <tt>&lt;</tt> comparing pointers of type <tt>P</tt>,
returns <tt>true</tt> if (the converted value of) <tt>t</tt> precedes <tt>u</tt> in the
implementation-defined strict total order over pointers (3.27 <a href="https://timsong-cpp.github.io/cppwp/defns.order.ptr">[defns.order.ptr]</a>)
and otherwise <tt>false</tt>.
</p>
</li>
<li><p>
(7.2) &mdash; Otherwise, equivalent to: <tt>return std​::​forward&lt;T&gt;(t) &lt; std​::​forward&lt;U&gt;(u);</tt>
</p>
</li>
</ol>
</blockquote>
<pre>
struct ranges::greater_equal {
  template&lt;class T, class U&gt;
    <del>requires totally_ordered_with&lt;T, U&gt; || <i>BUILTIN-PTR-CMP</i>(T, &lt;, U)</del>
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  using is_transparent = <i>unspecified</i>;
};
</pre>

<pre>
<ins>template&lt;class T, class U&gt;
constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>T</tt> and <tt>U</tt> satisfy <tt>totally_ordered_with</tt>.</ins>
<p/>
-8- <del><tt>operator()</tt> has effects e</del><ins><i>Effects:</i> E</ins>quivalent to:</p>
<blockquote><pre>
return !ranges::less{}(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
</pre></blockquote>
</blockquote>

<pre>
struct ranges::less_equal {
  template&lt;class T, class U&gt;
    <del>requires totally_ordered_with&lt;T, U&gt; || <i>BUILTIN-PTR-CMP</i>(T, &lt;, U)</del>
  constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;

  using is_transparent = <i>unspecified</i>;
};
</pre>

<pre>
<ins>template&lt;class T, class U&gt;
constexpr bool operator()(T&amp;&amp; t, U&amp;&amp; u) const;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>T</tt> and <tt>U</tt> satisfy <tt>totally_ordered_with</tt>.</ins>
<p/>
-9- <del><tt>operator()</tt> has effects e</del><ins><i>Effects:</i> E</ins>quivalent to:</p>
<blockquote><pre>
return !ranges::less{}(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3532" href="3532">3532.</a> <tt>split_view&lt;V, P&gt;::<i>inner-iterator</i>&lt;true&gt;::operator++(int)</tt> should depend on <tt><i>Base</i></tt></h3>
<p><b>Section:</b> 24.7.12.5 <a href="https://timsong-cpp.github.io/cppwp/range.split.inner">[range.split.inner]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2021-03-11 <b>Last modified:</b> 2021-04-20 20:35:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>split_view&lt;V, P&gt;::<i>inner-iterator</i>&lt;Const&gt;::operator++(int)</tt> is specified directly in the 
synopsis in 24.7.12.5 <a href="https://timsong-cpp.github.io/cppwp/range.split.inner">[range.split.inner]</a> as:
</p>
<blockquote><pre>
constexpr decltype(auto) operator++(int) {
  if constexpr (forward_range&lt;V&gt;) {
    auto tmp = *this;
    ++*this;
    return tmp;
  } else
    ++*this;
}
</pre></blockquote>
<p>
The dependency on the properties of <tt>V</tt> here is odd given that we are wrapping an iterator obtained from a 
<tt><i>maybe-const</i>&lt;Const, V&gt;</tt> (aka <tt><i>Base</i></tt>). It seems like this function should instead 
be concerned with <tt>forward_range&lt;<i>Base</i>&gt;</tt>.
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>


<ol>
<li><p>Modify 24.7.12.5 <a href="https://timsong-cpp.github.io/cppwp/range.split.inner">[range.split.inner]</a> as indicated:</p>

<blockquote>
<pre>
constexpr decltype(auto) operator++(int) {
  if constexpr (forward_range&lt;<del>V</del><ins><i>Base</i></ins>&gt;) {
    auto tmp = *this;
    ++*this;
    return tmp;
  } else
    ++*this;
}
</pre>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="3533" href="3533">3533.</a> Make <tt>base() const &amp;</tt> consistent across iterator wrappers that supports <tt>input_iterator</tt>s</h3>
<p><b>Section:</b> 24.7.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.filter.iterator">[range.filter.iterator]</a>, 24.7.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.transform.iterator">[range.transform.iterator]</a>, 24.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2021-03-14 <b>Last modified:</b> 2021-04-20 20:33:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of LWG issue <a href="3391">3391</a> changed the <tt>base()</tt> function for the 
<tt>counted_iterator</tt>/<tt>move_iterator</tt> to return <tt>const &amp;</tt>, because the previous 
specification prevented non-mutating uses of the base iterator (comparing against sentinel) and made 
<tt>take_view</tt> unimplementable. However, this change was not applied for all other iterators wrappers, 
that may wrap move-only input iterators. As consequence, we end-up with inconsistency where a user can 
perform the following operations on some adapters, but not on others (e. g. <tt>take_view</tt> uses 
<tt>counted_iterator</tt> so it supports them).
</p>
<ol style="list-style-type:upper-alpha">
<li><p>read the original value of the base iterator, by calling <tt>operator*</tt></p></li>
<li><p>find position of an element in the underlying iterator, when sentinel is sized by calling <tt>operator-</tt> 
(e.g. all input iterators wrapped into <tt>counted_iterator</tt>).</p></li>
</ol>
<p>
To fix above, the proposed wording below proposes to modify the signature of <tt>iterator::base() const &amp;</tt> 
member function for all iterators adapters that support input iterator. These include:
</p>
<ul>
<li><p><tt>filter_view::<i>iterator</i></tt> (uses case B)</p></li>
<li><p><tt>transform_view::<i>iterator</i></tt> (uses case A)</p></li>
<li><p><tt>elements_view::<i>iterator</i></tt> (uses case B)</p></li>
<li><p><tt>lazy_split_view&lt;V, Pattern&gt;::<i>inner-iterator</i></tt> (uses case B) if 
<a href="https://wg21.link/p2210">P2210</a> is accepted</p></li>
</ul>
<p>
Note: <tt>common_iterator</tt> does not expose the <tt>base()</tt> function (because it can either point to 
iterator or sentinel), so changes to above are not proposed. However, both (A) and (B) use cases are supported.
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<blockquote class="note">
<p>
If <a href="https://wg21.link/p2210">P2210</a> would become accepted, the corresponding subclause 
[range.lazy.split.inner] (?) for <tt>lazy_split_view::<i>inner-iterator</i></tt> would require a similar change.
</p>
</blockquote>

<ol>
<li><p>Modify 24.7.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.filter.iterator">[range.filter.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
[&hellip;]
constexpr <ins>const</ins> iterator_t&lt;V&gt;<ins>&amp;</ins> base() const &amp;
  <del>requires copyable&lt;iterator_t&lt;V&gt;&gt;</del>;
[&hellip;]
</pre>
</blockquote>
</blockquote>
[&hellip;]
<blockquote>
<pre>
constexpr <ins>const</ins> iterator_t&lt;V&gt;<ins>&amp;</ins> base() const &amp;
  <del>requires copyable&lt;iterator_t&lt;V&gt;&gt;</del>;
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to: <tt>return <i>current_</i>;</tt>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 24.7.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.transform.iterator">[range.transform.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
[&hellip;]
constexpr <ins>const</ins> iterator_t&lt;<i>Base</i>&gt;<ins>&amp;</ins> base() const &amp;
  <del>requires copyable&lt;iterator_t&lt;<i>Base</i>&gt;&gt;</del>;
[&hellip;]
</pre>
</blockquote>
</blockquote>
[&hellip;]
<blockquote>
<pre>
constexpr <ins>const</ins> iterator_t&lt;<i>Base</i>&gt;<ins>&amp;</ins> base() const &amp;
  <del>requires copyable&lt;iterator_t&lt;<i>Base</i>&gt;&gt;</del>;
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to: <tt>return <i>current_</i>;</tt>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 24.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
[&hellip;]
constexpr <ins>const</ins> iterator_t&lt;<i>Base</i>&gt;<ins>&amp;</ins> base() const &amp;
  <del>requires copyable&lt;iterator_t&lt;<i>Base</i>&gt;&gt;</del>;
[&hellip;]
</pre>
</blockquote>
</blockquote>
[&hellip;]
<blockquote>
<pre>
constexpr <ins>const</ins> iterator_t&lt;<i>Base</i>&gt;<ins>&amp;</ins> base() const &amp;
  <del>requires copyable&lt;iterator_t&lt;<i>Base</i>&gt;&gt;</del>;
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to: <tt>return <i>current_</i>;</tt>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3536" href="3536">3536.</a> Should <tt>chrono::from_stream()</tt> assign zero to <tt>duration</tt> for failure?</h3>
<p><b>Section:</b> 27.5.11 <a href="https://timsong-cpp.github.io/cppwp/time.duration.io">[time.duration.io]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Matt Stephanson <b>Opened:</b> 2021-03-19 <b>Last modified:</b> 2021-04-20 20:39:33 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.io">issues</a> in [time.duration.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>duration</tt> specialization of <tt>from_stream</tt> says in <a href="https://wg21.link/n4878">N4878</a> 
27.5.11 <a href="https://timsong-cpp.github.io/cppwp/time.duration.io">[time.duration.io]</a>/3:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
If the parse parses everything specified by the parsing format flags without error, and yet none of the flags impacts a duration, 
<tt>d</tt> will be assigned a zero value.
</p></blockquote>
<p>
This is in contrast to the other specializations that say, for example, 27.8.3.3 <a href="https://timsong-cpp.github.io/cppwp/time.cal.day.nonmembers">[time.cal.day.nonmembers]</a>/8:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
If the parse fails to decode a valid day, <tt>is.setstate(ios_base::failbit)</tt> is called and <tt>d</tt> 
is not modified.
</p></blockquote>
<p>
The wording ("none of the flags impacts a duration" vs. "parse fails to decode a valid [meow]") and semantics 
("assigned a zero value" vs. "not modified") are different, and it's not clear why that should be so. It also 
leaves unspecified what should be done in case of a parse failure, for example parsing <tt>"%j"</tt> from a 
stream containing <tt>"meow"</tt>. 27.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a>/12 says that <tt>failbit</tt> should be set, 
but neither it nor 27.5.11 <a href="https://timsong-cpp.github.io/cppwp/time.duration.io">[time.duration.io]</a>/3 mention the <tt>duration</tt> result if parsing fails.
<p/>
This has been discussed at the Microsoft STL project, where Howard Hinnant, coauthor of 
<a href="https://wg21.link/p0355R7">P0355R7</a> that added these functions, 
<a href="https://github.com/microsoft/STL/issues/1740#issuecomment-802414649">commented</a>:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
This looks like a bug in the standard to me, due to two errors on my part.
<p/>
I believe that the standard should clearly say that if <tt>failbit</tt> is set, the parsed variable 
(<tt>duration</tt>, <tt>time_point</tt>, whatever) is not modified. I mistakenly believed that the 
definition of unformatted input function covered this behavior. But after review, I don't believe it 
does. Instead each extraction operator seems to say this separately.
<p/>
I also at first did not have my example implementation coded to leave the duration unchanged. So that's how 
the wording got in in the first place. Here's the commit where I fixed my implementation: 
<a href="https://github.com/HowardHinnant/date/commit/d53db7a1cb61dc2651374e5b9660ed07e6d28358">HowardHinnant/date@d53db7a</a>. 
And I failed to propagate that fix into the proposal/standard.
</p>
</blockquote>
<p>
It would be clearer and simpler for users if the <tt>from_stream</tt> specializations were consistent in wording 
and behavior.
<p/>
Thanks to Stephan T. Lavavej, Miya Natsuhara, and Howard Hinnant for valuable investigation and discussion 
of this issue.
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li><p>Modify 27.5.11 <a href="https://timsong-cpp.github.io/cppwp/time.duration.io">[time.duration.io]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits, class Rep, class Period, class Alloc = allocator&lt;charT&gt;&gt;
  basic_istream&lt;charT, traits&gt;&amp;
    from_stream(basic_istream&lt;charT, traits&gt;&amp; is, const charT* fmt,
                duration&lt;Rep, Period&gt;&amp; d,
                basic_string&lt;charT, traits, Alloc&gt;* abbrev = nullptr,
                minutes* offset = nullptr);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Attempts to parse the input stream <tt>is</tt> into the duration <tt>d</tt> using 
the format flags given in the NTCTS <tt>fmt</tt> as specified in 27.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a>. <del>If the parse 
parses everything specified by the parsing format flags without error, and yet none of the flags impacts 
a duration, <tt>d</tt> will be assigned a zero value</del><ins>If the parse fails to decode a valid duration, 
<tt>is.setstate(ios_base::failbit)</tt> is called and <tt>d</tt> is not modified</ins>. If <tt>%Z</tt> is 
used and successfully parsed, that value will be assigned to <tt>*abbrev</tt> if <tt>abbrev</tt> is non-null. 
If <tt>%z</tt> (or a modified variant) is used and successfully parsed, that value will be assigned to 
<tt>*offset</tt> if <tt>offset</tt> is non-null.
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3539" href="3539">3539.</a> <tt>format_to</tt> must not copy models of <tt>output_iterator&lt;const charT&amp;&gt;</tt></h3>
<p><b>Section:</b> 20.20.4 <a href="https://timsong-cpp.github.io/cppwp/format.functions">[format.functions]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2021-03-31 <b>Last modified:</b> 2021-04-20 20:22:19 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#format.functions">issues</a> in [format.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.20.4 <a href="https://timsong-cpp.github.io/cppwp/format.functions">[format.functions]</a> specifies the overloads of <tt>format_to</tt> as:
</p>
<blockquote>
<pre>
template&lt;class Out, class... Args&gt;
  Out format_to(Out out, string_view fmt, const Args&amp;... args);
template&lt;class Out, class... Args&gt;
  Out format_to(Out out, wstring_view fmt, const Args&amp;... args);
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
using context = basic_format_context&lt;Out, decltype(fmt)::value_type&gt;;
return vformat_to(out, fmt, make_format_args&lt;context&gt;(args...));
</pre>
</blockquote>
</blockquote>
<pre>
template&lt;class Out, class... Args&gt;
  Out format_to(Out out, const locale&amp; loc, string_view fmt, const Args&amp;... args);
template&lt;class Out, class... Args&gt;
  Out format_to(Out out, const locale&amp; loc, wstring_view fmt, const Args&amp;... args);
  Out format_to(Out out, wstring_view fmt, const Args&amp;... args);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
using context = basic_format_context&lt;Out, decltype(fmt)::value_type&gt;;
return vformat_to(out, loc, fmt, make_format_args&lt;context&gt;(args...));
</pre>
</blockquote>
</blockquote>
</blockquote>
<p>
but the overloads of <tt>vformat_to</tt> take their first argument by value (from the same subclause):
</p>
<blockquote>
<pre>
template&lt;class Out&gt;
  Out vformat_to(Out out, string_view fmt,
                 format_args_t&lt;type_identity_t&lt;Out&gt;, char&gt; args);
template&lt;class Out&gt;
  Out vformat_to(Out out, wstring_view fmt,
                 format_args_t&lt;type_identity_t&lt;Out&gt;, wchar_t&gt; args);
template&lt;class Out&gt;
  Out vformat_to(Out out, const locale&amp; loc, string_view fmt,
                 format_args_t&lt;type_identity_t&lt;Out&gt;, char&gt; args);
template&lt;class Out>
  Out vformat_to(Out out, const locale&amp; loc, wstring_view fmt,
                 format_args_t&lt;type_identity_t&lt;Out&gt;, wchar_t&gt; args);
</pre>
<blockquote>
<p>
-10- Let <tt>charT</tt> be <tt>decltype(fmt)::value_type</tt>.
<p/>
-11- <i>Constraints:</i> <tt>Out</tt> satisfies <tt>output_iterator&lt;const charT&amp;&gt;</tt>.
<p/>
-12- <i>Preconditions:</i> <tt>Out</tt> models <tt>output_iterator&lt;const charT&amp;&gt;</tt>.
</p>
</blockquote>
</blockquote>
<p>
and require its type to model <tt>output_iterator&lt;const charT&amp;&gt;</tt>. <tt>output_iterator&lt;T, U&gt;</tt> 
refines <tt>input_or_output_iterator&lt;T&gt;</tt> which refines <tt>movable&lt;T&gt;</tt>, but it notably does not 
refine <tt>copyable&lt;T&gt;</tt>. Consequently, the "Equivalent to" code for the <tt>format_to</tt> overloads is 
copying an iterator that could be move-only. I suspect it is not the intent that calls to <tt>format_to</tt> with 
move-only iterators be ill-formed, but that it was simply an oversight that this wording needs updating to be 
consistent with the change to allow move-only single-pass iterators in C++20.
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4885">N4885</a>.
</p>

<ol>
<li><p>Modify 20.20.4 <a href="https://timsong-cpp.github.io/cppwp/format.functions">[format.functions]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Out, class... Args&gt;
  Out format_to(Out out, string_view fmt, const Args&amp;... args);
template&lt;class Out, class... Args&gt;
  Out format_to(Out out, wstring_view fmt, const Args&amp;... args);
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
using context = basic_format_context&lt;Out, decltype(fmt)::value_type&gt;;
return vformat_to(<ins>std::move(</ins>out<ins>)</ins>, fmt, make_format_args&lt;context&gt;(args...));
</pre>
</blockquote>
</blockquote>
<pre>
template&lt;class Out, class... Args&gt;
  Out format_to(Out out, const locale&amp; loc, string_view fmt, const Args&amp;... args);
template&lt;class Out, class... Args&gt;
  Out format_to(Out out, const locale&amp; loc, wstring_view fmt, const Args&amp;... args);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
using context = basic_format_context&lt;Out, decltype(fmt)::value_type&gt;;
return vformat_to(<ins>std::move(</ins>out<ins>)</ins>, loc, fmt, make_format_args&lt;context&gt;(args...));
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3540" href="3540">3540.</a> &sect;[format.arg] There should be no <tt>const</tt> in <tt>basic_format_arg(const T* p)</tt></h3>
<p><b>Section:</b> 20.20.6.1 <a href="https://timsong-cpp.github.io/cppwp/format.arg">[format.arg]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2021-04-07 <b>Last modified:</b> 2021-04-20 20:23:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.arg">active issues</a> in [format.arg].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.arg">issues</a> in [format.arg].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <a href="https://wg21.link/p0645r10">P0645R10</a> "Text formatting" was merged into the draft standard, there was 
a typo: an exposition-only constructor of <tt>basic_format_arg</tt> is declared as accepting <tt>const T*</tt> in the 
class synopsis, but is later declared to accept <tt>T*</tt>. This was 
<a href="https://github.com/cplusplus/draft/issues/3461">editorial issue 3461</a> and was resolved by adding 
<tt>const</tt> to the redeclaration.
<p/>
As it is, constructing <tt>basic_format_arg</tt> from <tt>void*</tt> will select 
<tt>template&lt;class T&gt; explicit basic_format_arg(const T&amp; v)</tt> and store a 
<tt>basic_format_arg::handle</tt> instead of select <tt>template&lt;class T&gt; basic_format_arg(const T*)</tt> and 
store a <tt>const void*</tt>, because <tt>void*</tt> &rarr; <tt>void*const&amp;</tt> is identity conversion, while 
<tt>void*</tt> &rarr; <tt>const void*</tt> is qualification conversion.
<p/>
While this technically works, it seems that storing a <tt>const void*</tt> would be more intuitive.
<p/>
Hence, I think <tt>const</tt> should be removed from both declarations of <tt>basic_format_arg(const T*)</tt>, 
so that construction from <tt>void*</tt> will select this constructor, resulting in more intuitive behavior.
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4885">N4885</a>.
</p>

<ol>
<li><p>Modify 20.20.6.1 <a href="https://timsong-cpp.github.io/cppwp/format.arg">[format.arg]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class Context&gt;
  class basic_format_arg {
  public:
    class handle;

  private:
    using char_type = typename Context::char_type;                     <i>// exposition only</i>

    variant&lt;monostate, bool, char_type,
      int, unsigned int, long long int, unsigned long long int,
      float, double, long double,
      const char_type*, basic_string_view&lt;char_type&gt;,
      const void*, handle&gt; value;                                      <i>// exposition only</i>

    template&lt;class T&gt; explicit basic_format_arg(const T&amp; v) noexcept;  <i>// exposition only</i>
    explicit basic_format_arg(float n) noexcept;                       <i>// exposition only</i>
    explicit basic_format_arg(double n) noexcept;                      <i>// exposition only</i>
    explicit basic_format_arg(long double n) noexcept;                 <i>// exposition only</i>
    explicit basic_format_arg(const char_type* s);                     <i>// exposition only</i>

    template&lt;class traits&gt;
      explicit basic_format_arg(
        basic_string_view&lt;char_type, traits&gt; s) noexcept;              <i>// exposition only</i>

    template&lt;class traits, class Allocator&gt;
      explicit basic_format_arg(
        const basic_string&lt;char_type, traits, Allocator&gt;&amp; s) noexcept; <i>// exposition only</i>
    
    explicit basic_format_arg(nullptr_t) noexcept;                     <i>// exposition only</i>

    template&lt;class T&gt;
      explicit basic_format_arg(<del>const</del> T* p) noexcept;                  <i>// exposition only</i>
  public:
    basic_format_arg() noexcept;

    explicit operator bool() const noexcept;
  };
}
</pre>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template&lt;class T&gt; explicit basic_format_arg(<del>const</del> T* p) noexcept;
</pre>
<blockquote>
<p>
-12- <i>Constraints:</i> <tt>is_void_v&lt;T&gt;</tt> is <tt>true</tt>.
<p/>
-13- <i>Effects:</i> Initializes <tt>value</tt> with <tt>p</tt>.
<p/>
-14- [<i>Note 1</i>: Constructing <tt>basic_format_arg</tt> from a pointer to a member is ill-formed unless the 
user provides an enabled specialization of formatter for that pointer to member type. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3541" href="3541">3541.</a> <tt>indirectly_readable_traits</tt> should be SFINAE-friendly for all types</h3>
<p><b>Section:</b> 23.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/readable.traits">[readable.traits]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Christopher Di Bella <b>Opened:</b> 2021-04-08 <b>Last modified:</b> 2021-04-20 20:17:54 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#readable.traits">issues</a> in [readable.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Following the outcome of LWG <a href="3446">3446</a>, a strict implementation of <tt>std::indirectly_readable_traits</tt> 
isn't SFINAE-friendly for types that have different <tt>value_type</tt> and <tt>element_type</tt> members due to 
the ambiguity between the <tt><i>has-member-value-type</i></tt> and <tt><i>has-member-element-type</i></tt> 
specialisations. Other traits types are empty when requirements aren't met; we should follow suit here.
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4885">N4885</a>.
</p>

<ol>
<li><p>Modify 23.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/readable.traits">[readable.traits]</a> p1 as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class T&gt;
  concept <i>has-member-value-type</i> = requires { typename T::value_type; }; <i>// exposition only</i>

template&lt;class T&gt;
  concept <i>has-member-element-type</i> = requires { typename T::element_type; }; <i>// exposition only</i>

template&lt;class&gt; struct indirectly_readable_traits { };

[&hellip;]

template&lt;<i>has-member-value-type</i> T&gt;
struct indirectly_readable_traits&lt;T&gt;
  : <i>cond-value-type</i>&lt;typename T::value_type&gt; { };

template&lt;<i>has-member-element-type</i> T&gt;
struct indirectly_readable_traits&lt;T&gt;
  : <i>cond-value-type</i>&lt;typename T::element_type&gt; { };

<ins>template&lt;<i>has-member-value-type</i> T&gt;
  requires <i>has-member-element-type</i>&lt;T&gt;
struct indirectly_readable_traits&lt;T&gt; { };</ins>
  
template&lt;<i>has-member-value-type</i> T&gt;
  requires <i>has-member-element-type</i>&lt;T&gt; &amp;&amp;
           same_as&lt;remove_cv_t&lt;typename T::element_type&gt;, remove_cv_t&lt;typename T::value_type&gt;&gt;
struct indirectly_readable_traits&lt;T&gt;
  : <i>cond-value-type</i>&lt;typename T::value_type&gt; { };
[&hellip;]
</pre>
</blockquote>
</li>

</ol>




</body>
</html>
