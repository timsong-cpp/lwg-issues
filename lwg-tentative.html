<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2018-07-04 at 20:07:55 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="708" href="708">708.</a> Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 25 <a href="https://timsong-cpp.github.io/cppwp/localization">[localization]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-07-28 <b>Last modified:</b> 2018-06-24 10:22:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>


<p><i>[
San Francisco: Bill and Nick still intend to provide wording, but this
is a part of the task to be addressed by the group that will look into
issue <a href="860">860</a>.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's our intention to stay in sync with WG14. If WG14 makes a decision
that requires a change in WG21 the issue will be reopened.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: <tt>uselocale()</tt> is bad; pass locales around as objects</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="935" href="935">935.</a> clock error handling needs to be specified</h3>
<p><b>Section:</b> 23.17.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock">[time.clock]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-11-24 <b>Last modified:</b> 2018-06-24 10:22:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Each of the three clocks specified in Clocks 23.17.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock">[time.clock]</a>
provides the member function:
</p>

<blockquote><pre>
static time_point now();
</pre></blockquote>

<p>
The semantics specified by Clock requirements 23.17.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a>
make no mention of error handling. Thus the function may throw <tt>bad_alloc</tt>
or an implementation-defined exception (20.5.5.12 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>
paragraph 4).
</p>

<p>
Some implementations of these functions on POSIX, Windows, and
presumably on other operating systems, may fail in ways only detectable
at runtime. Some failures on Windows are due to supporting chipset
errata and can even occur after successful calls to a clock's <tt>now()</tt>
function.
</p>

<p>
These functions are used in cases where exceptions are not appropriate
or where the specifics of the exception or cause of error need to be
available to the user. See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error
handling (Rev 1)</i>, for more specific discussion of use cases. Thus some change in
the interface of now is required.
</p>

<p>
The proposed resolution has been implemented in the Boost version of the
chrono library. No problems were encountered.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be deferred until the next Committee Draft
has been issued and the prerequisite paper has been accepted.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD future. Too late to make this change without having already
accepted the hybrid error handling proposal.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD. Needs a paper. Proposed resolution no longer applies.</p>


<p><b>Proposed resolution:</b></p>
<p>
Accept the proposed wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error handling (Rev 1)</i>.
</p>

<p>
Change <tt>Clock</tt> requirements 23.17.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a> as indicated:
</p>

<blockquote>
<p>
-2- In Table 55 <tt>C1</tt> and <tt>C2</tt> denote clock types. <tt>t1</tt> and
<tt>t2</tt> are values returned by <tt>C1::now()</tt> where the call 
returning <tt>t1</tt> happens before (1.10) the call returning <tt>t2</tt> and
both of these calls happen before <tt>C1::time_point::max()</tt>.
<ins><tt>ec</tt> denotes an object of type <tt>error_code</tt> 
(22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.overview">[syserr.errcode.overview]</a>).</ins>
</p>

<table border="1">
<caption>Table 55 &mdash; Clock requirements</caption>
<tr>
<th>Expression</th><th>Return type</th><th>Operational semantics</th>
</tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>

<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point</tt></td>
<td>Returns a <tt>time_point</tt> object representing the current point in time.
</td>
</tr>

<tr>
<td><tt><ins>C1::now(ec)</ins></tt></td>
<td><tt><ins>C1::time_point</ins></tt></td>
<td><ins>Returns a <tt>time_point</tt> object representing the current point in time.</ins>
</td>
</tr>
</table>
</blockquote>

<p>
Change class <tt>system_clock</tt> 23.17.7.1 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system">[time.clock.system]</a> as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>monotonic_clock</tt> 99 [time.clock.monotonic] as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>high_resolution_clock</tt> 23.17.7.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock.hires">[time.clock.hires]</a> as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>






<hr>
<h3><a name="1121" href="1121">1121.</a> Support for multiple arguments</h3>
<p><b>Section:</b> 23.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25 <b>Last modified:</b> 2018-06-23 21:17:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both add and multiply could sensibly be called with more than two arguments.
The variadic template facility makes such declarations simple, and is likely
to be frequently wrapped by end users if we do not supply the variant
ourselves.
</p>
<p>
We deliberately ignore divide at this point as it is not transitive.
Likewise, subtract places special meaning on the first argument so I do not
suggest extending that immediately.  Both could be supported with analogous
wording to that for add/multiply below.
</p>
<p>
Note that the proposed resolution is potentially incompatible with that
proposed for <a href="921">921</a>, although the addition of the typedef to ratio would be
equally useful.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The consensus of the group when we reviewed this in Santa Cruz was that
<a href="921">921</a> would proceed to Ready as planned, and the
multi-paramater add/multiply templates should be renamed as
<tt>ratio_sum</tt> and <tt>ratio_product</tt> to avoid the problem
mixing template aliases with partial specializations.
</p>

<p>
It was also suggested to close this issue as NAD Future as it does not
correspond directly to any NB comment.  NBs are free to submit a
specific comment (and re-open) in CD2 though.
</p>

<p>
Walter Brown also had concerns on better directing the order of
evaluation to avoid overflows if we do proceed for 0x rather than TR1,
so wording may not be complete yet.
</p>

<p><i>[
Alisdair updates wording.
]</i></p>


<p><i>[
2009-10-30 Howard:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>PR for <tt>ratio_product</tt> is wrong, uses <tt>ratio_add</tt> instead of <tt>ratio_multiply</tt>.
Recommend NAD: Doesn't meet the bar for standardization: hasn't been requested again in 7 years, easy to implement yourself.</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a future standard.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the following type traits to p3 23.16 <a href="https://timsong-cpp.github.io/cppwp/ratio">[ratio]</a>
</p>

<blockquote><pre>
// ratio arithmetic
template &lt;class R1, class R2&gt; struct ratio_add;
template &lt;class R1, class R2&gt; struct ratio_subtract;
template &lt;class R1, class R2&gt; struct ratio_multiply;
template &lt;class R1, class R2&gt; struct ratio_divide;
<ins>template &lt;class R1, class ... RList&gt; struct ratio_sum;</ins>
<ins>template &lt;class R1, class ... RList&gt; struct ratio_product;</ins>
</pre></blockquote>

<p>
after 23.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p1: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_sum; // declared, never defined

template &lt;class R1&gt; struct ratio_sum&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_sum&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>

<p>
after 23.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p3: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_product; // declared, never defined

template &lt;class R1&gt; struct ratio_product&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_product&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>








<hr>
<h3><a name="1154" href="1154">1154.</a> <tt>complex</tt> should accept integral types</h3>
<p><b>Section:</b> 29.5 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2018-06-24 10:53:02 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in [complex.numbers].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 35</b></p>

<p><b>Description</b></p>
        <p>Instantiations of the class
        template <tt>complex&lt;&gt;</tt> have to be allowed for integral
        types, to reflect existing practice and ISO standards
        (LIA-III).</p>
        
<p><b>Suggestion</b></p>

<p><i>[
2009-10-26 Proposed wording in <a href="http://wg21.link/n3002.pdf">N3002</a>.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Future. Rationale added.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend SG6</p>

<p><i>[2017-03-03, Kona]</i></p>

<p>
SG6 suggests this issue is a new feature, not a problem with the existing
standard, and should therefore be closed NAD. However, SG6 invites papers that bring
the proposal up to date with the current standard.
</p>


<p><b>Rationale:</b></p>
<p>
There is no consensus for making this change at this time.
</p>


<p><b>Proposed resolution:</b></p><p>
Adopt <a href="http://wg21.link/n3002.pdf">N3002</a>.
</p>




<hr>
<h3><a name="1188" href="1188">1188.</a> Unordered containers should have a minimum load factor as well as a maximum</h3>
<p><b>Section:</b> 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 26.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unordered associative containers have a notion of a maximum load factor:
when the number of elements grows large enough, the containers
automatically perform a rehash so that the number of elements per bucket
stays below a user-specified bound. This ensures that the hash table's
performance characteristics don't change dramatically as the size
increases.
</p>

<p>
For similar reasons, Google has found it useful to specify a minimum
load factor: when the number of elements shrinks by a large enough, the
containers automatically perform a rehash so that the number of elements
per bucket stays above a user-specified bound. This is useful for two
reasons. First, it prevents wasting a lot of memory when an unordered
associative container grows temporarily. Second, it prevents amortized
iteration time from being arbitrarily large; consider the case of a hash
table with a billion buckets and only one element. (This was discussed
even before TR1 was published; it was TR issue 6.13, which the LWG
closed as NAD on the grounds that it was a known design feature.
However, the LWG did not consider the approach of a minimum load
factor.)
</p>

<p>
The only interesting question is when shrinking is allowed. In principle
the cleanest solution would be shrinking on erase, just as we grow on
insert. However, that would be a usability problem; it would break a
number of common idioms involving erase. Instead, Google's hash tables
only shrink on insert and rehash.
</p>

<p>
The proposed resolution allows, but does not require, shrinking in
rehash, mostly because a postcondition for rehash that involves the
minimum load factor would be fairly complicated. (It would probably have
to involve a number of special cases and it would probably have to
mention yet another parameter, a minimum bucket count.)
</p>

<p>
The current behavior is equivalent to a minimum load factor of 0. If we
specify that 0 is the default, this change will have no impact on
backward compatibility.
</p>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This seems to a useful extension, but is too late for 0x.

Move to Tentatively NAD Future.
</p></blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Should there be a shrink_to_fit()? Is it too surprising to shrink on insert()? (We understand that shrinking on erase() is not an option.) Maybe make people call rehash(0) to shrink to the min_load_factor? On clear(), the load factor goes to 0 or undefined (0/0), which is likely to violate min_load_factor() min_load_factor(z)'s wording should match max_load_factor(z)'s, e.g. "May change the containerâ€™s maximum load factor" Want a paper exploring whether shrink-on-insert has been surprising. From Titus: Google's experience is that maps don't shrink in the way this would help with. NAD, not worth the time. Write a paper if you can demonstrate a need for this.</p>


<p><b>Proposed resolution:</b></p>
<p>
Add two new rows, and change rehash's postcondition in the unordered
associative container requirements table in 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &mdash; Unordered associative container requirements
(in addition to container)</caption>

<tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><ins>
<tt>a.min_load_factor()</tt>
</ins></td>
<td><ins>
<tt>float</tt>
</ins></td>
<td><ins>
Returns a non-negative number that the container attempts to keep the
load factor greater than or equal to. The container automatically
decreases the number of buckets as necessary to keep the load factor
above this number.
</ins></td>
<td><ins>
constant
</ins></td>
</tr>

<tr>
<td><ins><tt>a.min_load_factor(z)</tt></ins></td>
<td><ins><tt>void</tt></ins></td>
<td><ins>Pre: <tt>z</tt> shall be non-negative. Changes the container's minimum
load factor, using <tt>z</tt> as a hint. [<i>Footnote:</i> the minimum
load factor should be significantly smaller than the maximum. 
If <tt>z</tt> is too large, the implementation may reduce it to a more sensible value.]
</ins></td>
<td><ins>
constant
</ins></td>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <ins><tt>a.bucket_count() &gt;= n</tt>, and <tt>a.size() &lt;= a.bucket_count()
* a.max_load_factor()</tt>. [<i>Footnote:</i> It is intentional that the
postcondition does not mention the minimum load factor.
This member function is primarily intended for cases where the user knows
that the container's size will increase soon, in which case the container's
load factor will temporarily fall below <tt>a.min_load_factor()</tt>.]</ins>
<del>
<tt>a.bucket_cout &gt; a.size() / a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</del>
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</table>
</blockquote>

<p>
Add a footnote to 26.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p12:
</p>

<blockquote>
<p>
The insert members shall not affect the validity of references to
container elements, but may invalidate all iterators to the container.
The erase members shall invalidate only iterators and references to the
erased elements.
</p>

<blockquote><p>
[A consequence of these requirements is that while insert may change the
number of buckets, erase may not. The number of buckets may be reduced
on calls to insert or rehash.]
</p></blockquote>
</blockquote>

<p>
Change paragraph 13:
</p>

<blockquote><p>
The insert members shall not affect the validity of iterators if
<del><tt>(N+n) &lt; z * B</tt></del> <ins><tt>zmin * B &lt;= (N+n) &lt;= zmax * B</tt></ins>,
where <tt>N</tt> is the number of elements in
the container prior to the insert operation, <tt>n</tt> is the number of
elements inserted, <tt>B</tt> is the container's bucket count,
<ins><tt>zmin</tt> is the container's minimum load factor,</ins>
and <tt>z<ins>max</ins></tt> is the container's maximum load factor.
</p></blockquote>

<p>
Add to the <tt>unordered_map</tt> class synopsis in section 26.5.4 <a href="https://timsong-cpp.github.io/cppwp/unord.map">[unord.map]</a>,
the <tt>unordered_multimap</tt> class synopsis
in 26.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap">[unord.multimap]</a>, the <tt>unordered_set</tt> class synopsis in
26.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a>, and the <tt>unordered_multiset</tt> class synopsis
in 26.5.7 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset">[unord.multiset]</a>:
</p>

<blockquote><pre><ins>
float min_load_factor() const;
void min_load_factor(float z);
</ins></pre></blockquote>

<p>
In 26.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a>, 26.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a>, 26.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a>, and
26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a>, change:
</p>

<blockquote><p>
... <tt>max_load_factor()</tt> returns 1.0 <ins>and
<tt>min_load_factor()</tt> returns 0</ins>.
</p></blockquote>





<hr>
<h3><a name="1217" href="1217">1217.</a> Quaternion support</h3>
<p><b>Section:</b> 29.5 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Ted Shaneyfelt <b>Opened:</b> 2009-09-26 <b>Last modified:</b> 2018-06-24 10:53:02 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in [complex.numbers].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Concerning mathematically proper operation of the type:
</p>

<blockquote><pre>
complex&lt;complex&lt;T&gt; &gt;
</pre></blockquote>

<p>
Generally accepted mathematical semantics of such a construct correspond
to quaternions through Cayly-Dickson construct
</p>

<blockquote><pre>
(w+xi) + (y+zi) j
</pre></blockquote>

<p>
The proper implementation seems straightforward by adding a few
declarations like those below. I have included operator definition for
combining real scalars and complex types, as well, which seems
appropriate, as algebra of complex numbers allows mixing complex and
real numbers with operators. It also allows for constructs such as
<tt>complex&lt;double&gt; i=(0,1),  x = 12.34 + 5*i;</tt>
</p>

<p>
Quaternions are often used in areas such as computer graphics, where,
for example, they avoid the problem of Gimbal lock when rotating objects
in 3D space, and can be more efficient than matrix multiplications,
although I am applying them to a different field.
</p>

<pre>
/////////////////////////ALLOW OPERATORS TO COMBINE REAL SCALARS AND COMPLEX VALUES /////////////////////////
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()+a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a+x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()-a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a-x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()*a, x.imag()*a);
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a*x.real(), a*x.imag());
    return result;
}

/////////////////////////PROPERLY IMPLEMENT QUATERNION SEMANTICS/////////////////////////
template&lt;typename T&gt; double normSq(const complex&lt;complex&lt;T&gt; &gt;q) {
    return q.real().real()*q.real().real()
         + q.real().imag()*q.real().imag()
         + q.imag().real()*q.imag().real()
         + q.imag().imag()*q.imag().imag();
}
template&lt;typename T&gt; double norm(const complex&lt;complex&lt;T&gt; &gt;q) {
    return sqrt(normSq(q));
}
/////// Cayley-Dickson Construction
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; conj(const complex&lt;complex&lt;T&gt; &gt; x) {
    complex&lt;complex&lt;T&gt; &gt; result(conj(x.real()),-x.imag());
    return result;
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator*(const complex&lt;complex&lt;T&gt; &gt; ab,const complex&lt;complex&lt;T&gt; &gt; cd) {
    complex&lt;T&gt; re(ab.real()*cd.real()-conj(cd.imag())*ab.imag());
    complex&lt;T&gt; im(cd.imag()*ab.real()+ab.imag()*conj(cd.real()));
    complex&lt;complex&lt;double&gt; &gt; q(re,im);
    return q;
}
//// Quaternion division
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; q,const S a) {
    return q * (1/a);
}
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const S a,const complex&lt;complex&lt;T&gt; &gt; q) {
    return a*conj(q)/normSq(q);
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; n, const complex&lt;complex&lt;T&gt; &gt; d) {
    return n * (conj(d)/normSq(d));
}
</pre>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future. There is no consensus or time to move this into C++0X.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend SG6 - We note that <tt>complex&lt;complex&gt;</tt> is the wrong way to spell this</p>

<p><i>[2017-03-03, Kona]</i></p>

<p>
SG6 suggests this issue is a new feature, not a problem with the existing
standard, and should therefore be closed NAD. However, SG6 invites papers that bring
the proposal up to date with the current standard.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1235" href="1235">1235.</a> Issue with C++0x random number proposal</h3>
<p><b>Section:</b> 29.7.1.6 <a href="https://timsong-cpp.github.io/cppwp/rand.req.dist">[rand.req.dist]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Matthias Troyer <b>Opened:</b> 2009-10-12 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.dist">issues</a> in [rand.req.dist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There exist optimized, vectorized vendor libraries for the creation of
random number generators, such as Intel's MKL [1] and AMD's ACML [2]. In
timing tests we have seen a performance gain of a factor of up to 80
(eighty) compared to a pure C++ implementation (in Boost.Random) when
using these generator to generate a sequence of normally distributed
random numbers. In codes dominated by the generation of random numbers
(we have application codes where random number generation is more than
50% of the CPU time) this factor 80 is very significant.
</p>

<p>
To make use of these vectorized generators, we use a C++ class modeling
the <tt>RandomNumberEngine</tt> concept and forwarding the generation of random
numbers to those optimized generators. For example:
</p>

<blockquote><pre>
namespace mkl {
 class mt19937 {.... };
}
</pre></blockquote>

<p>
For the generation of random variates we also want to dispatch to
optimized vectorized functions in the MKL or ACML libraries. See this
example:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::normal_distribution&lt;double&gt; dist;

double n = dist(eng);
</pre></blockquote>

<p>
Since the variate generation is done through the <tt>operator()</tt> of the
distribution there is no customization point to dispatch to Intel's or
AMD's optimized functions to generate normally distributed numbers based
on the <tt>mt19937</tt> generator. Hence, the performance gain of 80 cannot be
achieved.
</p>

<p>
Contrast this with TR1:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::tr1::normal_distribution&lt;double&gt; dist;
std::tr1::variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; rng(eng,dist);
double n = rng();
</pre></blockquote>

<p>
This - admittedly much uglier from an aestethic point of view - design
allowed optimization by specializing the <tt>variate_generator</tt> template for
<tt>mkl::mt19937</tt>:
</p>

<blockquote><pre>
namespace std { namespace tr1 {

template&lt;&gt;
class variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; { .... };

} }
</pre></blockquote>

<p>
A similar customization point is missing in the C++0x design and
prevents the optimized vectorized version to be used.
</p>

<p>
Suggested resolution:
</p>

<p>
Add a customization point to the distribution concept. Instead of the
<tt>variate_generator</tt> template this can be done through a call to a
free function <tt>generate_variate</tt> found by ADL instead of
<tt>operator()</tt> of the distribution:
</p>

<blockquote><pre>
template &lt;RandomNumberDistribution, class RandomNumberEngine&gt;
typename RandomNumberDistribution ::result_type
generate_variate(RandomNumberDistribution const&amp; dist, RandomNumberEngine&amp; eng);
</pre></blockquote>

<p>
This function can be overloaded for optimized enginges like
<tt>mkl::mt19937</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  No time to add this feature for C++0X.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: The standard has changed enough that the issue doesn't make sense anymore. Write a paper proposing a way to get this performance as changes to the current library.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1282" href="1282">1282.</a> A proposal to add <tt>std::split</tt> algorithm</h3>
<p><b>Section:</b> 28 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Igor Semenov <b>Opened:</b> 2009-12-07 <b>Last modified:</b> 2018-06-23 21:17:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol style="list-style-type:upper-roman">

<li>
<p>
Motivation and Scope
</p>
<p>
Splitting strings into parts by some set of delimiters is an often task, but
there is no simple and generalized solution in C++ Standard. Usually C++
developers use <tt>std::basic_stringstream&lt;&gt;</tt> to split string into
parts, but there are several inconvenient restrictions:
</p>

<ul>
<li>
we cannot explicitly assign the set of delimiters;
</li>
<li>
this approach is suitable only for strings, but not for other types of
containers;
</li>
<li>
we have (possible) performance leak due to string instantiation.
</li>
</ul>
</li>

<li>
<p>
Impact on the Standard
</p>
<p>
This algorithm doesn't interfere with any of current standard algorithms.
</p>
</li>

<li>
<p>
Design Decisions
</p>
<p>
This algorithm is implemented in terms of input/output iterators. Also, there is
one additional wrapper for <tt>const CharType *</tt> specified delimiters.
</p>
</li>

<li>
<p>
Example implementation
</p>
<pre>
template&lt; class It, class DelimIt, class OutIt &gt;
void split( It begin, It end, DelimIt d_begin, DelimIt d_end, OutIt out )
{
   while ( begin != end )
   {
       It it = std::find_first_of( begin, end, d_begin, d_end );
       *out++ = std::make_pair( begin, it );
       begin = std::find_first_of( it, end, d_begin, d_end,
           std::not2( std::equal_to&lt; typename It::value_type &gt;() ) );
   }
}

template&lt; class It, class CharType, class OutIt &gt;
void split( It begin, It end, const CharType * delim, OutIt out )
{
   split( begin, end, delim, delim + std::strlen( delim ), out );
}
</pre>
</li>

<li>
<p>
Usage
</p>
<pre>
std::string ss( "word1 word2 word3" );
std::vector&lt; std::pair&lt; std::string::const_iterator, std::string::const_iterator &gt; &gt; v;
split( ss.begin(), ss.end(), " ", std::back_inserter( v ) );

for ( int i = 0; i &lt; v.size(); ++i )
{
   std::cout &lt;&lt; std::string( v[ i ].first, v[ i ].second ) &lt;&lt; std::endl;
}
// word1
// word2
// word3
</pre>
</li>

</ol>

<p><i>[
2010-01-22 Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Paper encouraged. Have papers for this; <a href="https://wg21.link/LEWG259">LEWG259</a>.</p>



<p><b>Rationale:</b></p>
<p>
The LWG is not considering completely new features for standardization at this
time.  We would like to revisit this good suggestion for a future TR and/or
standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 28.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a>:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );

template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre></blockquote>

<p>
Add a new section [alg.split]:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> splits the range <tt>[first, last)</tt> into parts, using any
element of <tt>[delimiter_first, delimiter_last)</tt> as a delimiter. Results
are pushed to output iterator in the form of <tt>std::pair&lt;ForwardIterator1,
ForwardIterator1&gt;</tt>. Each of these pairs specifies a maximal subrange of
<tt>[first, last)</tt> which does not contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

<pre>
template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> split the range <tt>[first, last)</tt> into parts, using any
element of <tt>delimiters</tt> (interpreted as zero-terminated string) as a
delimiter. Results are pushed to output iterator in the form of
<tt>std::pair&lt;ForwardIterator1, ForwardIterator1&gt;</tt>. Each of these
pairs specifies a maximal subrange of <tt>[first, last)</tt> which does not
contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="1289" href="1289">1289.</a> Generic casting requirements for smart pointers</h3>
<p><b>Section:</b> 23.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Ion Gazta&ntilde;aga <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 40 &mdash; Allocator requirements,
the following expression is required for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>
<tr>
<td><tt>static_cast&lt;X::pointer&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static_cast&lt;X::pointer&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>
</table>
</blockquote>

<p>
To achieve this expression, a smart pointer writer must introduce an explicit
conversion operator from <tt>smart_ptr&lt;void&gt;</tt> to
<tt>smart_ptr&lt;T&gt;</tt> so that
<tt>static_cast&lt;pointer&gt;(void_ptr)</tt> is a valid expression.
Unfortunately this explicit conversion weakens the safety of a smart pointer
since the following expression (invalid for raw pointers) would become valid:
</p>

<blockquote><pre>
smart_ptr&lt;void&gt; smart_v = ...;
smart_ptr&lt;T&gt; smart_t(smart_v);
</pre></blockquote>

<p>
On the other hand, <tt>shared_ptr</tt> also defines its own casting functions in
23.11.3.9 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cast">[util.smartptr.shared.cast]</a>, and although it's unlikely that a
programmer will use <tt>shared_ptr</tt> as <tt>allocator::pointer</tt>, having
two different ways to do the same cast operation does not seem reasonable. A
possible solution would be to replace <tt>static_cast&lt;X::pointer&gt;(w)</tt>
expression with a user customizable (via ADL)
<tt>static_pointer_cast&lt;value_type&gt;(w)</tt>, and establish the
<tt>xxx_pointer_cast</tt> functions introduced by <tt>shared_ptr</tt> as the
recommended generic casting utilities of the standard.
</p>

<p>
Unfortunately, we've experienced problems in Boost when trying to establish
<tt>xxx_pointer_cast</tt> as customization points for generic libraries (<a
href="http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html"
>http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html</a>)
because these casting functions are called with explicit template parameters and
the standard says in 17.9.1 <a href="https://timsong-cpp.github.io/cppwp/temp.arg.explicit">[temp.arg.explicit]</a> p.8 "Explicit template
argument specification":
</p>

<blockquote><p>
8 ...But when a function template with explicit template arguments is used, the
call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call. If no such name is
visible, the call is not syntactically well-formed and argument-dependent lookup
does not apply.
</p></blockquote>

<p>
So we can do this:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_swap(BasePtr p)
{
  //ADL customization point
  swap(p, p);
  //...
}
</pre></blockquote>

<p>
but not the following:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;
  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);
}
</pre></blockquote>

<p>
The solution to make <tt>static_pointer_cast</tt> a customization point is to
add a generic declaration (no definition) of <tt>static_pointer_cast</tt> in a
namespace (like <tt>std</tt>) and apply "<tt>using
std::static_pointer_cast</tt>" declaration to activate ADL:
</p>

<blockquote><pre>
namespace std{

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

}

template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;

  //ADL applies because static_pointer_cast is made
  //  visible according to [temp.arg.explicit]/8
  using std::static_pointer_cast;

  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);

  //...
}
</pre></blockquote>

<p>
A complete solution will need also the definition of
<tt>static_pointer_cast</tt> for raw pointers, and this definition has been
present in Boost (<a
href="http://www.boost.org/boost/pointer_cast.hpp">http://www.boost.org/boost/
pointer_cast.hpp</a>) for years.
</p>

<p><i>[
2010-03-26 Daniel made editorial adjustments to the proposed wording.
]</i></p>


<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>

<blockquote><p>
This is a new feature rather than a defect. 
It can be added later: "this is such a hairy area that people will put up with changes"
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: NAD. Should bring a paper as a proposal for 2020.</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to section 23.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> Utility components, Header
<tt>&lt;utility&gt;</tt> synopsis:
</p>

<blockquote><pre>
// 20.3.X, generic pointer cast functions

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;

//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre></blockquote>

<p>
Add to section 23.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> Utility components, a new subclause
20.3.X Pointer cast utilities [pointer.cast]:
</p>

<blockquote>
<p>
20.3.X Pointer cast utilities [pointer.cast]
</p>

<p>
1 The library defines generic pointer casting function templates so that template code
can explicitly make these names visible and activate argument-dependent lookup
for pointer cast calls.
</p>

<pre>
//Generic declarations
template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;
</pre>

<p>
2 The library also defines overloads of these functions for raw pointers.
</p>

<pre>
//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>static_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>dynamic_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>const_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
#include &lt;utility&gt; //static_pointer_cast
#include &lt;memory&gt;  //pointer_traits

class Base{};
class Derived : public Base{};

template&lt;class BasePtr&gt;
void generic_pointer_code(BasePtr b)
{
   typedef std::pointer_traits&lt;BasePtr&gt;::template
      rebind&lt;Derived&gt; DerivedPtr;

   using std::static_pointer_cast;
   //ADL applies now that static_pointer_cast is visible
   DerivedPtr d = static_pointer_cast&lt;Derived&gt;(b);
}
</pre></blockquote>

<p>
&mdash; <i>end example</i>]
</p>

</blockquote>

<p>
Replace in section 20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> Table 40 &mdash; Allocator
requirements, the following table entries for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(w)</tt></td>
<td><tt>X::const_pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(z) == q</tt></td>
<td>&nbsp;</td>
</tr>

</table>
</blockquote>






<hr>
<h3><a name="1317" href="1317">1317.</a> make_hash</h3>
<p><b>Section:</b> 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Nicolai M. Josuttis <b>Opened:</b> 2010-02-10 <b>Last modified:</b> 2018-06-23 21:17:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the library lacks a convenient way to provide a hash function that
can be used with the provided unordered containers to allow the usage of non
trivial element types.
</p>

<p>
While we can easily declare an
</p>

<blockquote><pre>
std::unordered_set&lt;int&gt;
</pre></blockquote>

<p>
or
</p>

<blockquote><pre>
std::unordered_set&lt;std::string&gt;
</pre></blockquote>

<p>
we have no easy way to declare an <tt>unordered_set</tt> for a user defined
type. IMO, this is a big obstacle to use unordered containers in practice. Note
that in Java, the wide usage of <tt>HashMap</tt> is based on the fact that there
is always a default hash function provided.
</p>

<p>
Of course, a default hash function implies the risk to provide poor hash
functions. But often even poor hash functions are good enough.
</p>

<p>
While I really would like to see a default hash function, I don't propose it
here because this would probably introduce a discussion that's too big for this
state of C++0x.
</p>

<p>
However, I strongly suggest at least to provide a convenience variadic template
function <tt>make_hash&lt;&gt;()</tt> to allow an easy definition of a (possibly
poor) hash function.
</p>

<p>
As a consequence for a user-defined type such as
</p>

<blockquote><pre>
class Customer {
   friend class CustomerHash;
   private:
     string firstname;
     string lastname;
     long   no;
   ...
 };
</pre></blockquote>

<p>
would allow to specify:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return make_hash(c.firstname,c.lastname,c.no);
    }
};
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return std::hash&lt;std::string&gt;()(c.firstname) +
              std::hash&lt;std::string&gt;()(c.lastname) +
              std::hash&lt;long&gt;()(c.no);
    }
};
</pre></blockquote>

<p>
Note that, in principle, we can either specify that
</p>

<blockquote><p>
<tt>make_hash</tt> returns the sum of a call of
<tt>std::hash&lt;T&gt;()(x)</tt> for each argument <tt>x</tt> of type
<tt>T</tt>
</p></blockquote>

<p>
or we can specify that
</p>

<blockquote><p>
<tt>make_hash</tt> provides a hash value for each argument, for which a
<tt>std::hash()</tt> function is provided
</p></blockquote>

<p>
with the possible note that the hash value may be poor or only a good hash value
if the ranges of all passed arguments is equally distributed.
</p>

<p>
For my convenience, I propose wording that describes
the concrete implementation.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial, rationale added below.
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Feature? Needs a paper. (This is <a href="https://wg21.link/LEWG21">LEWG21</a>)</p>



<p><b>Rationale:</b></p>
<p>
There is no consensus to make this change at this time.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Function objects 23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>
in paragraph 2 at the end of the Header <tt>&lt;functional&gt;</tt> synopsis
insert:
</p>

<blockquote><pre>
// convenience functions
template &lt;class T&gt;
  size_t make_hash (const T&amp;);
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp;, const Types&amp;...);
</pre></blockquote>

<p>
In Class template hash 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>
add:
</p>

<blockquote>
<p>
<b>20.7.16.1 Hash creation functions [hash.creation]</b>
</p>

<pre>
template &lt;class T&gt;
  size_t make_hash (const T&amp; val);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val);</tt>
</p></blockquote>

<pre>
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp; val, const Types&amp;... args);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val) + std::make_hash(args...)</tt>
</p></blockquote>

</blockquote>






<hr>
<h3><a name="1406" href="1406">1406.</a> Support hashing smart-pointers based on <i>owner</i></h3>
<p><b>Section:</b> 23.11.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-5</b></p>
<p>
Hash support based on ownership sharing should be
supplied for <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
For two <tt>shared_ptr</tt> objects <tt>p</tt> and <tt>q</tt>, two distinct
equivalence relations can be defined. One is based on
equivalence of pointer values, which is derived from the
expression <tt>p.get() == q.get()</tt> (hereafter called <i>address based
equivalence relation</i>), the other is based on
equivalence of ownership sharing, which is derived from
the expression <tt>!p.owner_before(q) &amp;&amp; !q.owner_before(p)</tt>
(hereafter called <i>ownership-based equivalence relation</i>).
These two equivalence relations are independent in
general. For example, a <tt>shared_ptr</tt> object created by the
constructor of the signature <tt>shared_ptr(shared_ptr&lt;U>
const &amp;, T *)</tt> could reveal a difference between these two
relations. Therefore, hash support based on each
equivalence relation should be supplied for <tt>shared_ptr</tt>.
However, while the standard library provides the hash
support for address-based one (20.9.11.6 paragraph 2), it
lacks the hash support for ownership-based one. In
addition, associative containers work well in combination
with the <tt>shared_ptr</tt>'s ownership-based comparison but
unordered associative containers don't. This is
inconsistent.
</p>
<p>
For the case of <tt>weak_ptr</tt>, hash support for the ownership based
equivalence relation can be safely defined on
<tt>weak_ptr</tt>s, and even on expired ones. The absence of
hash support for the ownership-based equivalence
relation is fatal, especially for expired <tt>weak_ptr</tt>s. And the
absence of such hash support precludes some quite
effective use-cases, e.g. erasing the <tt>unordered_map</tt> entry
of an expired <tt>weak_ptr</tt> key from a customized deleter
supplied to <tt>shared_ptr</tt>s.
</p>
<p>
Hash support for the ownership-based equivalence
relation cannot be provided by any user-defined manner
because information about ownership sharing is not
available to users at all. Therefore, the only way to provide
ownership-based hash support is to offer it intrusively by
the standard library.
</p>
<p>
As far as we know, such hash support is implementable.
Typical implementation of such hash function could return
the hash value of the pointer of the counter object that is
internally managed by <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
</p>

<p><i>[2010 Rapperswil:]</i></p>

<blockquote>
<p>No consensus to make this change at this time.</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Needs a paper. Feature. Exposing an implementation detail (indirectly observable via hash).</p>



<p><b>Proposed resolution:</b></p>
<p>
Add the following non-static member functions to
<tt>shared_ptr</tt> and <tt>weak_ptr</tt> class template;
</p>
<p>
Update [util.smartptr.shared], 20.9.11.2 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class shared_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
Update [util.smartptr.weak], 20.9.11.3 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class weak_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
These functions satisfy the following
requirements. Let <tt>p</tt> and <tt>q</tt> be objects of either
<tt>shared_ptr</tt> or <tt>weak_ptr</tt>, <tt>H</tt> be a hypothetical
function object type that satisfies the hash
requirements ([hash.requirements], 20.2.4) and <tt>h</tt> be an object of the
type <tt>H</tt>. The expression <tt>p.owner_hash()</tt> behaves
as if it were equivalent to the expression <tt>h(p)</tt>. In
addition, <tt>h(p) == h(q)</tt> must become <tt>true</tt> if <tt>p</tt> and
<tt>q</tt> share ownership.
</p>





<hr>
<h3><a name="1499" href="1499">1499.</a> Condition variables preclude wakeup optimization</h3>
<p><b>Section:</b> 33.5 <a href="https://timsong-cpp.github.io/cppwp/thread.condition">[thread.condition]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-193</b></p>

<p>
Condition variables preclude a wakeup optimization.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote><p>
Change condition_variable to allow such
optimization. See Appendix 1 - Additional Details
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed the issue, and deemed it an extension to be handled after C++0x.
</p>

<p><b>Rationale:</b></p><p>The LWG does not wish to make the change at this time.</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: (N4618 numbering) 30.5.1[thread.condition.condvar] p10.3 allows spurious wakeups. This issue is out of date.</p>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
The approach suggested there raises all sorts of issues about <tt>thread_locals</tt>, etc. It's probably way too late 
to change this anyway, but this would have required a careful paper.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2226" href="2226">2226.</a> <tt>wstring_convert</tt> methods do not take allocator instance</h3>
<p><b>Section:</b> D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Glen Fernandes <b>Opened:</b> 2012-12-14 <b>Last modified:</b> 2018-06-24 10:22:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.string">active issues</a> in [depr.conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.string">issues</a> in [depr.conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>wstring_convert</tt> class template, described in D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>, does not 
support custom stateful allocators. It only supports custom stateless allocators.
<p/>
The <tt>to_bytes</tt> member function returns <tt>basic_string&lt;char, char_traits&lt;char&gt;, Byte_alloc&gt;</tt>  
but it does not take an instance of <tt>Byte_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
Similarly the <tt>from_bytes</tt> member function returns <tt>basic_string&lt;Elem, char_traits&lt;Elem&gt;, Wide_alloc&gt;</tt>  
but it does not take an instance of <tt>Wide_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
This makes these two member functions and the <tt>wstring_convert</tt> class template not usable when <tt>Wide_alloc</tt> 
or <tt>Byte_alloc</tt> are stateful allocators.
</p>

<p><i>[2013-01-22, Glen provides wording]</i></p>


<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to NAD Future.
</p>
<p>
This is clearly an extension that the LEWG may want to take a look at, once we have more experience
with appropriate use of allocators with the C++11 model.
</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Does this follow the pattern? Should be discussed as a group. Do we have the experience with 
the C++11 allocator model to know that this is the addition to make?</p>
<p>Should <tt>to_string()</tt> also take an allocator? <tt>substr()</tt>? Any function that returns a string?</p>
<p>This suggests a larger change.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>In D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>/2 and /6 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>from_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Wide_alloc</tt>:</p>

<blockquote><pre>
wide_string from_bytes(char byte<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *ptr<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const byte_string&amp; str<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *first, const char *last<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> /8 specify that this <tt>Wide_alloc</tt> allocator parameter is used to
construct the <tt>wide_string</tt> object returned from the function:</p>

<p>
-7- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>byte</tt> to a wide string.
The second member function shall convert the null-terminated sequence beginning at <tt>ptr</tt> to a wide
string. The third member function shall convert the sequence stored in <tt>str</tt> to a wide string. The fourth
member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a wide string.
<p/>
-8- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Wide_alloc</tt> allocator parameter is used to construct the <tt>wide_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

<li><p>In D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>/2 and /12 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>to_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Byte_alloc</tt>:</p>

<blockquote><pre>
byte_string to_bytes(Elem wchar<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *wptr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const wide_string&amp; wstr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *first, const Elem *last<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> /13 specify that this <tt>Byte_alloc</tt> allocator parameter is used to
construct the <tt>byte_string</tt> object returned from the function:</p>

<p>
-12- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>wchar</tt> to a byte string.
The second member function shall convert the null-terminated sequence beginning at <tt>wptr</tt> to a byte
string. The third member function shall convert the sequence stored in <tt>wstr</tt> to a byte string. The
fourth member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a byte string.
<p/>
-13- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Byte_alloc</tt> allocator parameter is used to construct the <tt>byte_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

</ol>





<hr>
<h3><a name="2417" href="2417">2417.</a> [fund.ts.v2] <tt>std::experimental::optional::operator&lt;</tt> and <tt>LessThanComparable</tt> requirement</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.relops], 99 [fund.ts.v2::optional.comp_with_t] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-06-20 <b>Last modified:</b> 2018-06-24 10:53:02 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
Currently, <tt>std::experimental::optional::operator==</tt> imposes the <tt>EqualityComparable</tt> requirement which provides
two guarantees: It ensures that <tt>operator!=</tt> can rely on the equivalence-relation property and more importantly, that
the <tt>BooleanTestable</tt> requirements suggested by issue <a href="2114">2114</a> are automatically implied.
<p/>
<tt>std::experimental::optional::operator&lt;</tt> doesn't provide a <tt>LessThanComparable</tt> requirement, but there was quite
an historic set of changes involved with that family of types: As of <a href="http://wg21.link/n3527.html">N3527</a>
this operator was defined in terms of <tt>operator&lt;</tt> of the contained type <tt>T</tt> and imposed the <tt>LessThanComparable</tt> 
requirement. In the final acceptance step of <tt>optional</tt> by the committee, the definition was expressed in terms of <tt>std::less</tt>
and the <tt>LessThanComparable</tt> requirement had been removed.
<p/>
The inconsistency between <tt>operator==</tt> and <tt>operator&lt;</tt> should be removed. One possible course of action would be 
to add the <tt>LessThanComparable</tt> to <tt>std::experimental::optional::operator&lt;</tt>. The <tt>EqualityComparable</tt> requirement
of <tt>operator==</tt> could also be removed, but in that case both operators would at least need to require the <tt>BooleanTestable</tt> 
requirements (see <a href="2114">2114</a>) for the result type of <tt>T</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>. 
<p/>
Arguably, corresponding operators for <tt>pair</tt> and <tt>tuple</tt> do not impose <tt>LessThanComparable</tt> (nor
<tt>EqualityComparable</tt>), albeit the definition of the "derived" relation functions depend on properties ensured by
<tt>LessThanComparable</tt>. According to the <a href="https://www.sgi.com/tech/stl/pair.html">SGI definition</a>, the intention was
to imposed both <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt>. If this is not intended, the standard should clarify
this position.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
VV, DK, JY discuss why and when <tt>LessThanComparable</tt> was removed. AM: Move to LEWG. Please tell LWG when you look at it. 
</p>

<p><i>[2016-11-08, Issaquah]</i></p>

<p>Not adopted during NB comment resolution</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: We've done a lot of work getting the C++17 semantics we want in this area; we're not going to change 
them 3 days from DIS or change the TSv2 behavior to be different from '17.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2600" href="2600">2600.</a> <tt>ios_base</tt> must store inaccessible iostate flags</h3>
<p><b>Section:</b> 30.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
DR <a href="41">41</a>, "Ios_base needs <tt>clear()</tt>, <tt>exceptions()</tt>" stopped short of providing the interface 
suggested in its title, but it did require the underlying state to be stored in <tt>ios_base</tt>. Because <tt>rdstate()</tt> 
is also missing, <tt>ios_base</tt> manipulators relying on <tt>iword</tt> and <tt>pword</tt> cannot detect failure. 
The only safe alternative is to manipulate a derived class, which must be a template.
<p/>
libc++ already provides the interface as a nonconforming extension. libstdc++ implements the internal state but leaves 
it frustratingly inaccessible, as specified. Any conforming implementation should be able to provide the interface 
without ABI problems.
</p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
This is really a request for an (feature) API. Passing to LEWG.
</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: iostreams aren't used in this way enough to spend committee time on it. However, a paper could change our minds.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3122" href="3122">3122.</a> <tt>__cpp_lib_chrono_udls</tt> was accidentally dropped</h3>
<p><b>Section:</b> 21.3.1 <a href="https://timsong-cpp.github.io/cppwp/support.limits.general">[support.limits.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2018-06-14 <b>Last modified:</b> 2018-06-25 00:47:25 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>Discussion:</b></p>
<p>
Between <a href="http://wg21.link/p0941r0">P0941R0</a> and 
<a href="http://wg21.link/p0941r1">P0941R1</a>/<a href="http://wg21.link/p0941r2">P0941R2</a>, the feature-test macro 
<tt>__cpp_lib_chrono_udls</tt> was dropped. It wasn't mentioned in the changelog, and Jonathan Wakely and I 
believe that this was unintentional.
</p>

<p><i>[2018-06-23 Moved to Tentatively Ready after 5 positive votes on c++std-lib.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to the post-Rapperswil 2018 working draft.
</p>

<p>In 21.3.1 <a href="https://timsong-cpp.github.io/cppwp/support.limits.general">[support.limits.general]</a>, "Table ??? - Standard library feature-test macros", add the following row:</p>

<blockquote>

<table border="1">
<caption>Table ??? &mdash; Standard library feature-test macros</caption>
<tr style="text-align:center">
<th>Macro name</th>
<th>Value</th>
<th>Headers</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td><ins><tt>__cpp_lib_chrono_udls</tt></ins></td>
<td><ins><tt>201304L</tt></ins></td>
<td><ins><tt>&lt;chrono&gt;</tt></ins></td>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
</table>

</blockquote>





</body>
</html>
