<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2017-02-19 at 15:02:45 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760" href="760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="767">767</a> and to <a href="2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="2164">2164</a> addresses this issue and therefore considers <a href="760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="839" href="839">839.</a> Maps and sets missing splice operation</h3>
<p><b>Section:</b> 23.4 <a href="https://timsong-cpp.github.io/cppwp/associative">[associative]</a>, 23.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Alan Talbot <b>Opened:</b> 2008-05-18 <b>Last modified:</b> 2016-08-10 04:08:18 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative">[associative]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Splice is a very useful feature of <tt>list</tt>. This functionality is also very
useful for any other node based container, and I frequently wish it were
available for maps and sets. It seems like an omission that these
containers lack this capability. Although the complexity for a splice is
the same as for an insert, the actual time can be much less since the
objects need not be reallocated and copied. When the element objects are
heavy and the compare operations are fast (say a <tt>map&lt;int, huge_thingy&gt;</tt>)
this can be a big win.
</p>

<p>
<b>Suggested resolution:</b>
</p>

<p>
Add the following signatures to map, set, multimap, multiset, and the unordered associative containers:
</p>
<blockquote><pre> 
void splice(list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p>
Hint versions of these are also useful to the extent hint is useful.
(I'm looking for guidance about whether hints are in fact useful.)
</p>
 
<blockquote><pre> 
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Don't try to <tt>splice "list"</tt> into the other containers, it should be container-type.
</p>
<p>
<tt>forward_list</tt> already has <tt>splice_after</tt>.
</p>
<p>
Would "<tt>splice</tt>" make sense for an <tt>unordered_map</tt>?
</p>
<p>
Jens, Robert: "<tt>splice</tt>" is not the right term, it implies maintaining ordering in <tt>list</tt>s.
</p>
<p>
Howard: <tt>adopt</tt>?
</p>
<p>
Jens: <tt>absorb</tt>?
</p>
<p>
Alan: <tt>subsume</tt>?
</p>
<p>
Robert: <tt>recycle</tt>?
</p>
<p>
Howard: <tt>transfer</tt>? (but no direction)
</p>
<p>
Jens: <tt>transfer_from</tt>. No.
</p>
<p>
Alisdair: Can we give a nothrow guarantee? If your <tt>compare()</tt> and <tt>hash()</tt> doesn't throw, yes.
</p>
<p>
Daniel: For <tt>unordered_map</tt>, we can't guarantee nothrow.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Martin: this would possibly outlaw an implementation technique that is
currently in use; caching nodes in containers.
</p>
<p>
Alan: if you cache in the allocator, rather than the individual
container, this proposal doesn't interfere with that.
</p>
<p>
Martin: I'm not opposed to this, but I'd like to see an implementation
that demonstrates that it works.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
NAD Future.
</p></blockquote>

<p><i>[
2009-09-19 Howard adds:
]</i></p>


<blockquote>
<p>
I'm not disagreeing with the NAD Future resolution.  But when the future gets
here, here is a possibility worth exploring:
</p>

<blockquote>
<p>
Add to the "unique" associative containers:
</p>

<blockquote><pre>
typedef <i>details</i>      node_ptr;

node_ptr             remove(const_iterator p);
pair&lt;iterator, bool&gt; insert(node_ptr&amp;&amp; nd);
iterator             insert(const_iterator p, node_ptr&amp;&amp; nd);
</pre></blockquote>

<p>
And add to the "multi" associative containers:
</p>

<blockquote><pre>
typedef <i>details</i> node_ptr;

node_ptr remove(const_iterator p);
iterator insert(node_ptr&amp;&amp; nd);
iterator insert(const_iterator p, node_ptr&amp;&amp; nd);
</pre></blockquote>

<p>
<tt>Container::node_ptr</tt> is a smart pointer much like <tt>unique_ptr</tt>.
It owns a node obtained from the container it was removed from.  It maintains a
reference to the allocator in the container so that it can properly deallocate
the node if asked to, even if the allocator is stateful.  This being said, the
<tt>node_ptr</tt> can not outlive the container for this reason.
</p>

<p>
The <tt>node_ptr</tt> offers "<tt>const</tt>-free" access to the node's
<tt>value_type</tt>.
</p>

<p>
With this interface, clients have a great deal of flexibility:
</p>

<ul>
<li>
A client can remove a node from one container, and insert it into another
(without any heap allocation).  This is the splice functionality this issue
asks for.
</li>
<li>
A client can remove a node from a container, change its key or value, and insert
it back into the same container, or another container, all without the cost of
allocating a node.
</li>
<li>
If the Compare function is nothrow (which is very common), then this functionality
is nothrow unless modifying the value throws.  And if this does throw, it does
so outside of the containers involved.
</li>
<li>
If the Compare function does throw, the <tt>insert</tt> function will have the
argument <tt>nd</tt> retain ownership of the node.
</li>
<li>
The <tt>node_ptr</tt> should be independent of the <tt>Compare</tt> parameter
so that a node can be transferred from <tt>set&lt;T, C1, A&gt;</tt>
to <tt>set&lt;T, C2, A&gt;</tt> (for example).
</li>
</ul>

<p>
Here is how the customer might use this functionality:
</p>

<ul>
<li>
<p>
Splice a node from one container to another:
</p>
<blockquote><pre>
m2.insert(m1.remove(i));
</pre></blockquote>
</li>

<li>
<p>
Change the "key" in a <tt>std::map</tt> without the cost of node reallocation:
</p>
<blockquote><pre>
auto p = m.remove(i);
p->first = new_key;
m.insert(std::move(p));
</pre></blockquote>
</li>

<li>
<p>
Change the "value" in a <tt>std::set</tt> without the cost of node reallocation:
</p>
<blockquote><pre>
auto p = s.remove(i);
*p = new_value;
s.insert(std::move(p));
</pre></blockquote>
</li>

<li>
<p>
Move a move-only or heavy object out of an associative container (as opposed to
the proposal in <a href="1041">1041</a>):
</p>
<blockquote><pre>
MoveOnly x = std::move(*s.remove(i));
</pre></blockquote>
<ol>
<li>
<tt>remove(i)</tt> transfers ownership of the node from the set to a temporary
<tt>node_ptr</tt>.
</li>
<li>
The <tt>node_ptr</tt> is dereferenced, and that non-const reference is sent to
<tt>move</tt> to cast it to an rvalue.
</li>
<li>
The rvalue <tt>MoveOnly</tt> is move constructed into <tt>x</tt> from
the <tt>node_ptr</tt>.
</li>
<li>
<tt>~node_ptr()</tt> destructs the moved-from <tt>MoveOnly</tt> and deallocates
the node.
</li>
</ol>

<p>
Contrast this with the <a href="1041">1041</a> solution:
</p>
<blockquote><pre>
MoveOnly x = std::move(s.extract(i).first);
</pre></blockquote>

<p>
The former requires one move construction for <tt>x</tt> while the latter
requires two (one into the <tt>pair</tt> and then one into <tt>x</tt>).  Either
of these constructions can throw (say if there is only a copy constructor for
<tt>x</tt>).  With the former, the point of throw is outside of the container
<tt>s</tt>, after the element has been removed from the container.  With the latter,
one throwing construction takes place prior to the removal of the element, and
the second takes place after the element is removed.
</p>

</li>
</ul>

<p>
The "node insertion" API maintains the API associated with inserting <tt>value_type</tt>s
so the customer can use familiar techniques for getting an iterator to the 
inserted node, or finding out whether it was inserted or not for the "unique"
containers.
</p>

<p>
Lightly prototyped.  No implementation problems.  Appears to work great
for the client.
</p>

</blockquote>
</blockquote>

<p><i>[08-2016, Post-Chicago]</i></p>

<p>Move to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>This functionality is provided by <a href="http://wg21.link/P0083R3">P0083R3</a></p>





<hr>
<h3><a name="1041" href="1041">1041.</a> Add associative/unordered container functions that allow to extract elements</h3>
<p><b>Section:</b> 23.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-08-08 15:08:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 239 [CD1]</b></p>

<p>
It is not possible to take a move-only key out of an unordered
container, such as (<tt>multi</tt>)<tt>set</tt> or
(<tt>multi</tt>)<tt>map</tt>, or the new unordered containers.
</p>

<p>
Add below <tt>a.erase(q)</tt>, <tt>a.extract(q)</tt>, with the following notation:
</p>
<p>
<tt>a.extract(q)></tt>, Return type <tt>pair&lt;key, iterator&gt;</tt>
Extracts the element pointed to by <tt>q</tt> and erases it from the
<tt>set</tt>. Returns a <tt>pair</tt> containing the value pointed to by
<tt>q</tt> and an <tt>iterator</tt> pointing to the element immediately
following <tt>q</tt> prior to the element being erased. If no such
element exists,returns <tt>a.end()</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We look forward to a paper on this topic. We recommend no action until a
paper is available. The paper would need to address exception safety.
</p></blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote><p>
Would <tt>value_type</tt> be a better return type than <tt>key_type</tt>?
</p></blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote><p>
Leave Open. Alisdair to contact Chris Jefferson about this.
</p></blockquote>

<p><i>[
2009-09-20 Howard adds:
]</i></p>


<blockquote><p>
See the 2009-09-19 comment of <a href="839">839</a> for an API which
accomplishes this functionality and also addresses several other use
cases which this proposal does not.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD Future. No consensus to make the change at this time.
</p></blockquote>

<p><strong>Original resolution [SUPERSEDED]:</strong></p>
<blockquote class = "note">
<p>
In 23.2.6 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> Table 85, add:
</p>

<blockquote>
<table border="1">
<caption>Table 85 --  Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</table>
</blockquote>

<p>
In 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> Table 87, add:
</p>

<blockquote>
<table border="1">
<caption>Table 87 -- Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</table>
</blockquote>
</blockquote>

<p><i>[08-2016, Post-Chicago]</i></p>

<p>Move to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>This functionality is provided by <a href="http://wg21.link/P0083R3">P0083R3</a></p>





<hr>
<h3><a name="2179" href="2179">2179.</a> <tt>enable_shared_from_this</tt> and construction from raw pointers</h3>
<p><b>Section:</b> 20.11.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a>, 20.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-08-16 <b>Last modified:</b> 2016-05-06 15:05:52 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
On reflector message <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32927">c++std-lib-32927</a>, 
Matt Austern asked whether the following example should be well-defined or not
</p>
<blockquote><pre>
struct X : public enable_shared_from_this&lt;X&gt; { };
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
pointing out that 20.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> does not seem to allow it, since
<tt>xp1</tt> and <tt>xp2</tt> aren't allowed to share ownership, because each of them is required to have 
<tt>use_count() == 1</tt>. Despite this wording it might be reasonable (and technical possible)
to implement that request.
<p/>
On the other hand, there is the non-normative note in 20.11.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a> p11 (already part of TR1):
</p>
<blockquote><p>
The <tt>shared_ptr</tt> constructors that <span style="color:#C80000;font-weight:bold">create unique pointers</span> 
can detect the presence of an <tt>enable_shared_from_this</tt> base and assign the newly created <tt>shared_ptr</tt> 
to its <tt>__weak_this member</tt>.
</p></blockquote>
<p>
Now according to the specification in 20.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> p3-7:
</p>
<blockquote><pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre></blockquote>
<p>
the notion of <em>creating unique pointers</em> can be read to be included by this note, because the post-condition
of this constructor is <tt>unique() == true</tt>. Evidence for this interpretation seems to be weak, though.
<p/>
Howard Hinnant presented the counter argument, that actually the following is an "anti-idiom" and it seems questionable 
to teach it to be well-defined in any case:
</p>
<blockquote><pre>
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
He also pointed out that the current post-conditions of the affected <tt>shared_ptr</tt> constructor
would need to be reworded.
<p/>
It needs to be decided, which direction to follow. If this idiom seems too much broken to be supported,
the note could be improved. If it should be supported, the constructors in
20.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> need a careful analysis to ensure that post-conditions
are correct.
<p/>
Several library implementations currently do not support this example, instead they typically
cause a crash. Matt points out that there are currently no explicit requirements imposed on
<tt>shared_ptr</tt> objects to prevent them from owning the same underlying object without sharing the 
ownership. It might be useful to add such a requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
More discussion is needed to pick a direction to guide a proposed resolution.
</p>

<p><i>[2013-05-09 Jonathan comments]</i></p>

<p>
The note says the newly created <tt>shared_ptr</tt> is assigned to the <tt>weak_ptr</tt> member. It doesn't 
say before doing that the <tt>shared_ptr</tt> should check if the <tt>weak_ptr</tt> is non-empty and possibly 
share ownership with some other pre-existing <tt>shared_ptr</tt>.
</p>

<p><i>[2015-08-26 Daniel comments]</i></p>

<p>
LWG issue <a href="2529">2529</a> is independent but related to this issue.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper p0033r1 at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2208" href="2208">2208.</a> <tt>std::reverse_iterator</tt> should be a literal type</h3>
<p><b>Section:</b> 24.5.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-30 <b>Last modified:</b> 2016-05-06 20:05:22 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#reverse.iterators">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterators">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
<tt>std::reverse_iterator::reverse_iterator(Iterator)</tt> should be constexpr
so that other constexpr functions can return <tt>reverse_iterator</tt>s. Of the
other methods, the other constructors, <tt>base()</tt>, <tt>operator+</tt>, <tt>operator-</tt>,
<tt>operator[]</tt>, and the non-member operators can probably also be
<tt>constexpr</tt>.
<p/>
<tt>operator*</tt> cannot be constexpr because it involves an assignment to a
member variable. Discussion starting with c++std-lib-33282 indicated
that it would be useful to make reverse_iterator a literal type
despite this restriction on its use at compile time.
</p>



<p><b>Proposed resolution:</b></p>
This issue was Resolved by paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0">P0031R0</a>
adopted at Jacksonville, 2016.





<hr>
<h3><a name="2241" href="2241">2241.</a> <tt>&lt;cstdalign&gt;</tt> and <tt>#define</tt> of <tt>alignof</tt></h3>
<p><b>Section:</b> 18.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2013-02-14 <b>Last modified:</b> 2016-06-28 13:06:39 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.runtime">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 18.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> p2:
</p>

<blockquote><p>
The contents of these headers are the same as the Standard C library headers [..], <tt>&lt;stdalign.h&gt;</tt>, [..]
</p></blockquote>

<p>
Since our base C standard is C99, which doesn't have a <tt>&lt;stdalign.h&gt;</tt>, the reference to a non-existing 
C header is irritating (In this context <tt>&lt;stdalign.h&gt;</tt> doesn't refer to the deprecated C++ header
<tt>&lt;stdalign.h&gt;</tt> described in D.4 <a href="https://timsong-cpp.github.io/cppwp/depr.c.headers">[depr.c.headers]</a>).
<p/>
Furthermore, it would be also important that it doesn not define a macro named <tt>alignof</tt>, which C11 also defines 
in this header. 
<p/>
Currently we only have the following guarantee as part of 18.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> p7:
</p>

<blockquote><p>
The header <tt>&lt;cstdalign&gt;</tt> and the header <tt>&lt;stdalign.h&gt;</tt> shall not define a macro named 
<tt>alignas</tt>.
</p></blockquote>

<p>
It is unclear what the better strategy is: Striking the reference to <tt>&lt;stdalign.h&gt;</tt> in
18.10 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> p2 or upgrading to C11 as new base C standard.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
STL: related to earlier issue on C4, <a href="2201">2201</a>, and now we get a C11 header<br/>
JY: find _Alignof as keyword C11 FDIS has four defines in stdalign.h<br/>
AM: need paper for C11 as base library we should really do that<br/>
STL: really need vendor input<br/>
STL: don't think we need to do anything right now not P1<br/>
AM: any objections to downscale to P2  (no objections)
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Walter: this is on track to go away if we adopt Clark's paper to rebase to C11<br/>
Room: tentatively resolved; revisit after C11 paper: <a href="http://wg21.link/P0063">P0063</a><br/>
</p>

<p><i>[2016-03 Oulu]</i></p>

<p><a href="http://wg21.link/P0063">P0063</a> was adopted.</p>
<p>Change status to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2260" href="2260">2260.</a> Missing requirement for <tt>Allocator::pointer</tt></h3>
<p><b>Section:</b> 17.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-05-14 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For an allocator <tt>A&lt;T&gt;</tt> which defines <tt>A&lt;T&gt;::pointer</tt> to a class type,
i.e. not <tt>T*</tt>, I see no requirement that <tt>A&lt;T&gt;::pointer</tt> is convertible to
<tt>A&lt;U&gt;::pointer</tt>, even if <tt>T*</tt> is convertible to <tt>U*</tt>.  Such conversions are
needed in containers to convert from e.g. <tt>ListNodeBase*</tt> to <tt>ListNode&lt;T&gt;*</tt>.
</p>

<p>The obvious way to do such conversions appears to be
<tt>pointer_traits::pointer_to()</tt>, but that's ill-formed if the static
member function <tt>A&lt;T&gt;::pointer::pointer_to()</tt> doesn't exist and the
allocator requirements don't mention that function, so you need to
cast <tt>A&lt;T&gt;::pointer</tt> to <tt>A&lt;T&gt;::void_pointer</tt> then cast that to
<tt>A&lt;U&gt;::pointer</tt>.
</p>

<p>
Is converting via <tt>void_pointer</tt> really intended, or are we missing a requirement that 
<tt>pointer_traits&lt;A&lt;T&gt;::pointer&gt;::pointer_to()</tt> be well-formed?
</p>

<p>Proposed resolution:</p>

<p>Add to the Allocator requirements table the following requirement:</p>

<blockquote>
<p>
The expression <tt>pointer_traits&lt;XX::pointer&gt;::pointer_to(r)</tt> is well-defined.
</p>
</blockquote>

<p><i>[2013-09 Chicago]</i></p>

<p>
Pablo to come back with proposed wording
</p>

<p><i>[2015-07 Telecon]</i></p>

<p>
Marshall to ping Pablo for proposed wording and disable current wording.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class = "note">
<ol>
<li><p>
Edit Table 28 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z)</tt>
</td>
<td>
<tt>X::const_pointer</tt>
</td>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z) == q</tt>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<ins><tt>pointer_traits&lt;X::pointer&gt;::pointer_to(r)</tt></ins>
</td>
<td>
<ins><tt>X::pointer</tt></ins>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>


</li>
</ol>
</blockquote>


<p><i>[2016-11-12, Issaquah]</i></p>

<p>This is related to <a href="1521">1521</a>.</p>
<p>Sat PM: Restore original P/R and move to tentatively ready.</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>
Edit Table 28 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z)</tt>
</td>
<td>
<tt>X::const_pointer</tt>
</td>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z) == q</tt>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<ins><tt>pointer_traits&lt;X::pointer&gt;::pointer_to(r)</tt></ins>
</td>
<td>
<ins><tt>X::pointer</tt></ins>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>


</li>
</ol>





<hr>
<h3><a name="2294" href="2294">2294.</a> <tt>&lt;cstdlib&gt;</tt> should declare <tt>abs(double)</tt></h3>
<p><b>Section:</b> 26.9 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2013-09-04 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
&hellip; and <tt>abs(float)</tt> and <tt>abs(long double)</tt>. And <tt>&lt;cmath&gt;</tt> should declare 
<tt>abs(int)</tt>, <tt>abs(long)</tt>, and <tt>abs(long long)</tt>.
<p/>
As things currently stand, this program is illegal:
</p>
<blockquote><pre>
#include &lt;cstdlib&gt;

int main() {
  double d = -1.23;
  double dd = std::abs(d);
  return 0;
}
</pre></blockquote>
<p>
The call is ambiguous because of the various integer overloads, that's because <tt>&lt;cstdlib&gt;</tt> provides 
<tt>abs(int)</tt> but not <tt>abs(double)</tt>.
<p/>
This lead one commenter on Stackoverflow to state that <tt>abs</tt> is dangerous, and to recommend using <tt>fabs</tt> instead.
<p/>
In general, it makes sense to declare overloaded functions that take user-defined types in the same header as the 
definition of the user-defined types; it isn't necessary to declare all of the overloads in the same place. But 
here we're not dealing with any user-defined types; we're dealing with builtin types, which are always defined; 
all of the overloads should be defined in the same place, to avoid mysterious problems like the one in the code above.
<p/>
The standard library has six overloads for <tt>abs</tt>:
</p>
<blockquote><pre>
int abs(int);  // &lt;cstdlib&gt;
long abs(long); // &lt;cstdlib&gt;
long long abs(long long); // &lt;cstdlib&gt;

float abs(float); // &lt;cmath&gt;
double abs(double); // &lt;cmath&gt;
long double abs(long double); // &lt;cmath&gt;
</pre></blockquote>
<p>
These should all be declared in both headers.
<p/>
I have no opinion on <tt>&lt;stdlib.h&gt;</tt> and <tt>&lt;math.h&gt;</tt>.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
This issue is related to LWG <a href="2192">2192</a>
<p/>
Move to open
</p>

<p><i>[2014-02-13 Issaquah &mdash; Nicolai Josuttis suggest wording]</i></p>


<p><i>[2015-03-03, Geoffrey Romer provides improved wording]</i></p>

<p>
See proposed resolution of LWG <a href="2192">2192</a>.
</p>

<p><i>[2015-09-11, Telecon]</i></p>

<p>Geoff provided combined wording for <a href="2192">2192</a> after Cologne, Howard to provide updated wording for Kona.</p>
<p>Howard: my notes say I wanted to use <tt>is_unsigned</tt> instead of 'unsigned integral type'.</p>

<strong>Previous resolution from Nicolai [SUPERSEDED]:</strong>
<blockquote class = "note">
<ol>
<li><p>Edit 26.9 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> after p7 as indicated:</p>

<blockquote><p>
-6- In addition to the <tt>int</tt> versions of certain math functions in <tt>&lt;cstdlib&gt;</tt>, C++ adds <tt>long</tt> and <tt>long long</tt>
overloaded versions of these functions, with the same semantics.
<p/>
-7- The added signatures are:
</p>
<blockquote><pre>
long abs(long);                    <i>// labs()</i>
long long abs(long long);          <i>// llabs()</i>
ldiv_t div(long, long);            <i>// ldiv()</i>
lldiv_t div(long long, long long); <i>// lldiv()</i>
</pre></blockquote>
<p>
<ins>-?- To avoid ambiguities, C++ also adds the following overloads of <tt>abs()</tt> to <tt>&lt;cstdlib&gt;</tt>,
with the semantics defined in <tt>&lt;cmath&gt;</tt>:</ins>
</p>
<blockquote><pre>
<ins>float abs(float);
double abs(double);
long double abs(long double);</ins>
</pre></blockquote>
<p>
<ins>-?- To avoid ambiguities, C++ also adds the following overloads of <tt>abs()</tt> to <tt>&lt;cmath&gt;</tt>,
with the semantics defined in <tt>&lt;cstdlib&gt;</tt>:</ins>
</p>
<blockquote><pre>
<ins>int abs(int);
long abs(long);
long long abs(long long);</ins>
</pre></blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-08 Chicago]</i></p>

<p>Resolved by <a href="2192">2192</a></p>


<p><b>Proposed resolution:</b></p>
<p>
See proposed resolution of LWG <a href="2192">2192</a>.
</p>





<hr>
<h3><a name="2337" href="2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2016-01-28 10:01:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a>/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a>/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2343" href="2343">2343.</a> Is the value of the ECMA-262 RegExp object's multiline property really false?</h3>
<p><b>Section:</b> 28.13 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Nayuta Taga <b>Opened:</b> 2013-10-30 <b>Last modified:</b> 2016-08-08 15:08:15 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the following "Multiline" is the value of the ECMA-262 RegExp object's multiline property.
<p/>
In <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">ECMA-262</a>, 
there are some definitions that relate to Multiline:
</p>
<ul>
<li><p>
ECMA-262 15.10.2.6:
</p>
<blockquote>
<p>
If Multiline is true, ^ matches just after LineTerminator.
<p/>
If Multiline is false, ^ does not match just after LineTerminator.
<p/>
If Multiline is true, $ matches just before LineTerminator.
<p/>
If Multiline is false, $ does not match just before LineTerminator.
</p>
</blockquote>
</li>
<li>
<p>
ECMA-262 15.10.4.1, 15.10.7.4:
</p>
<blockquote><p>
By default, Multiline is false.
</p></blockquote>
</li>
</ul>
<p>
So, the C++11 standard says that Multiline is false. As it is false,
^ matches only the beginning of the string, and $ matches only the end
of the string.
<p/>
However, two flags are defined in 28.5.2 <a href="https://timsong-cpp.github.io/cppwp/re.matchflag">[re.matchflag]</a> Table 139:
</p>
<blockquote>
<p>
<tt>match_not_bol</tt>: the character ^ in the regular expression shall not match <tt>[first,first)</tt>.
<p/>
<tt>match_not_eol</tt>: the character "$" in the regular expression shall not match <tt>[last,last)</tt>.
</p>
</blockquote>
<p>
As Multiline is false, the <tt>match_not_bol</tt> and the <tt>match_not_eol</tt> are
meaningless because they only make ^ and $ match none.
<p/>
In my opinion, Multiline should be true.
<p/>
FYI, Multiline of the existing implementations are as follows:
<p/>
<em>Multiline=false:</em>
</p>
<ul>
<li><p>
libstdc++ r206594
</p></li>
<li><p>
libc++ r199174
</p></li>
</ul>
<p>
<em>Multiline=true:</em>
</p>
<ul>
<li><p>
Visual Studio Express 2013
</p></li>
<li><p>
boost 1.55
</p></li>
</ul>

<p><i>[2015-05-22, Daniel comments]</i></p>

<p>
This issue interacts with LWG <a href="2503">2503</a>.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Resolving <a href="2503">2503</a> will resolve this as well.</p>


<p><b>Proposed resolution:</b></p>
<p>Resolved by LWG <a href="2503">2503</a>.</p>





<hr>
<h3><a name="2370" href="2370">2370.</a> Operations involving type-erased allocators should not be <tt>noexcept</tt> in <tt>std::function</tt></h3>
<p><b>Section:</b> 20.14.13.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-02-27 <b>Last modified:</b> 2016-08-11 20:08:28 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following constructors in 20.14.13.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> are declared <tt>noexcept</tt>, even
though it is not possible for an implementation to guarantee that they will not throw:
</p>

<blockquote><pre>
template &lt;class A&gt; function(allocator_arg_t, const A&amp;) noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) noexcept;
</pre></blockquote>

<p>
In addition, the following functions are guaranteed not to throw if the target
is a function pointer or a <tt>reference_wrapper</tt>:
</p>

<blockquote><pre>
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);
template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);
</pre></blockquote>

<p>
In all of the above cases, the function object might need to allocate memory
(an operation that can throw) in order to hold a copy of the type-erased
allocator itself. The first two constructors produce an empty function
object, but the allocator is still needed in case the object is later assigned
to. In this case, we note that the propagation of allocators on assignment is
underspecified for <tt>std::function</tt>. There are three possibilities:
</p>

<ol>
<li><p>The allocator is never copied on copy-assignment, moved on move-assignment, or swapped on swap.</p>
</li>

<li><p>The allocator is always copied on copy-assignment, moved on move-assignment, and swapped on swap.</p>
</li>

<li><p>Whether or not the allocator is copied, moved, or swapped is determined at
   run-time based on the <tt>propagate_on_container_copy_assignment</tt> and
   <tt>propagate_on_container_move_assignment</tt> traits of the allocators at
   construction of the source function, the target function, or both.</p>
</li>
</ol>

<p>
Although the third option seems to be the most consistent with existing
wording in the containers section of the standard, it is problematic in a
number of respects. To begin with, the propagation behavior is determined at
run time based on a pair of type-erased allocators, instead of at compile
time. Such run-time logic is <em>not</em> consistent with the rest of the standard
and is hard to reason about. Additionally, there are two allocator types
involved, rather than one. Any set of rules that attempts to rationally
interpret the propagation traits of both allocators is likely to be arcane
at best, and subtly wrong for some set of codes at worst.
</p>

<p>
The second option is a non-starter. Historically, and in the vast majority of
existing code, an allocator does not change after an object is constructed.
The second option, if adopted, would undermine the programmer's ability to
construct, e.g., an array of function objects, all using the same allocator.
</p>

<p>
The first option is (in Pablo's opinion) the simplest and best. It is
consistent with historical use of allocators, is easy to understand, and
requires minimal wording. It is also consistent with the wording in N3916,
which formalizes type-erased allocators.
</p>

<p>
For cross-referencing purposes: The resolution of this issue should be
harmonized with any resolution to LWG <a href="2062">2062</a>, which questions the <tt>noexcept</tt>
specification on the following member functions of std::function:
</p>

<blockquote><pre>
template &lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt;) noexcept;
void swap(function&amp;) noexcept;
</pre></blockquote>

<p><i>[2015-05 Lenexa]</i></p>

<p>
MC: change to P3 and status to open.
<p/>
STL: note that <tt>noexcept</tt> is an issue and large chunks of allocator should be destroyed.
</p>

<p><i>[2015-12-16, Daniel comments]</i></p>

<p>
See <a href="2564">2564</a> for a corresponding issue addressing library fundamentals v2.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 20.14.13.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>, class template <tt>function</tt> synopsis, as indicated:</p>

<blockquote><pre>
template &lt;class A&gt; function(allocator_arg_t, const A&amp;) <del>noexcept</del>;
template &lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>Change 20.14.13.2.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> as indicated:</p>

<blockquote>
<p>
-1- When any function constructor that takes a first argument of type <tt>allocator_arg_t</tt> is invoked, the second
argument shall have a type that conforms to the requirements for <tt>Allocator</tt> (Table 17.6.3.5). A copy of the
allocator argument is used to allocate memory, if necessary, for the internal data structures of the constructed
function object. <ins> For the remaining constructors, an instance of <tt>allocator&lt;T&gt;</tt>, for some suitable type
<tt>T</tt>, is used to allocate memory, if necessary, for the internal data structures of the constructed function object.</ins>
</p>

<pre>
function() noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp;) <del>noexcept</del>;
</pre>

<blockquote>
<p>
-2- <i>Postconditions</i>: <tt>!*this</tt>.
</p>
</blockquote>

<pre>
function(nullptr_t) noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) <del>noexcept</del>;
</pre>

<blockquote><p>
-3- <i>Postconditions</i>: <tt>!*this</tt>.
</p></blockquote>

<pre>
function(const function&amp; f);
<del>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);</del>
</pre>

<blockquote><p>
-4- <i>Postconditions</i>: <tt>!*this</tt> if <tt>!f</tt>; otherwise, <tt>*this</tt> targets a copy of <tt>f.target()</tt>.
</p>

<p>
-5- <i>Throws</i>: shall not throw exceptions if <tt>f</tt>'s target is a callable object passed
via <tt>reference_wrapper</tt> or a function pointer. Otherwise, may throw <tt>bad_alloc</tt>
or any exception thrown by the copy constructor of the stored callable
object. [<i>Note</i>: Implementations are encouraged to avoid the use of
dynamically allocated memory for small callable objects, for example, where
<tt>f</tt>'s target is an object holding only a pointer or reference to an object and
a member function pointer. &mdash; <i>end note</i>]
</p></blockquote>

<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);</ins>
</pre>

<blockquote><p>
<ins>-?- <i>Postconditions</i>: <tt>!*this</tt> if <tt>!f</tt>; otherwise, <tt>*this</tt> targets a copy of <tt>f.target()</tt>.</ins>
</p></blockquote>

<pre>
function(function&amp;&amp; f);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, function&amp;&amp; f);
</pre>

<blockquote><p>
-6- <i>Effects</i>: If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, move-constructs the target
of <tt>f</tt> into the target of <tt>*this</tt>, leaving <tt>f</tt> in a valid state with an
unspecified value. <ins>If an allocator is not specified, the constructed function will use the same allocator as <tt>f</tt>.</ins>
</p></blockquote>

<pre>
template&lt;class F&gt; function(F f);
template &lt;class F, class A> function(allocator_arg_t, const A&amp; a, F f);
</pre>

<blockquote>
<p>
-7- <i>Requires</i>: <tt>F</tt> shall be <tt>CopyConstructible</tt>. 
<p/>
-8- <i>Remarks</i>: These constructors shall not participate in overload resolution unless <tt>f</tt> is Callable (20.9.11.2)
for argument types <tt>ArgTypes...</tt> and return type <tt>R</tt>.
</p>

<p>
-9- <i>Postconditions</i>: <tt>!*this</tt> if any of the following hold:
</p>
<ul>
<li><p><tt>f</tt> is a null function pointer value.</p></li>
<li><p><tt>f</tt> is a null member pointer value.</p></li>
<li><p><tt>F</tt> is an instance of the function class template, and <tt>!f</tt></p></li>
</ul>

<p>
-10- Otherwise, <tt>*this</tt> targets a copy of <tt>f</tt> initialized with <tt>std::move(f)</tt>.
[<i>Note</i>: Implementations are encouraged to avoid the use of dynamically
allocated memory for small callable objects, for example, where <tt>f</tt>'s target
is an object holding only a pointer or reference to an object and a member
function pointer. &mdash; <i>end note</i>]
</p>

<p>
-11- <i>Throws</i>: shall not throw exceptions when <ins>an allocator is not specified
and</ins> <tt>f</tt> is a function pointer or a <tt>reference_wrapper&lt;T&gt;</tt> for some
<tt>T</tt>. Otherwise, may throw <tt>bad_alloc</tt> or any exception thrown by <tt>F</tt>'s copy or
move constructor<ins> or by <tt>A</tt>'s allocate function</ins>.
</p>
</blockquote>

</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a></p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by acceptance of <a href="http://wg21.link/p0302r1">P0302R1</a>.
</p>





<hr>
<h3><a name="2391" href="2391">2391.</a> <tt>basic_string</tt> is missing non-<tt>const</tt> <tt>data()</tt></h3>
<p><b>Section:</b> 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Michael Bradshaw <b>Opened:</b> 2014-05-27 <b>Last modified:</b> 2016-05-22 17:05:38 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Regarding 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, <tt>std::basic_string&lt;charT&gt;::data()</tt> returns a <tt>const charT*</tt> 
21.3.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/string.accessors">[string.accessors]</a>. While this method is convenient, it doesn't quite match <tt>std::array&lt;T&gt;::data()</tt> 
23.3.7.5 <a href="https://timsong-cpp.github.io/cppwp/array.data">[array.data]</a> or <tt>std::vector&lt;T&gt;::data()</tt> 23.3.11.4 <a href="https://timsong-cpp.github.io/cppwp/vector.data">[vector.data]</a>, both of which provide two 
versions (that return <tt>T*</tt> or <tt>const T*</tt>). An additional <tt>data()</tt> method can be added to 
<tt>std::basic_string</tt> that returns a <tt>charT*</tt> so it can be used in similar situations that <tt>std::array</tt> and 
<tt>std::vector</tt> can be used. Without a non-<tt>const</tt> <tt>data()</tt> method, <tt>std::basic_string</tt> has to be treated 
specially in code that is otherwise oblivious to the container type being used.
<p/>
Adding a <tt>charT*</tt> return type to <tt>data()</tt> would be equivalent to doing <tt>&amp;str[0]</tt> or <tt>&amp;str.front()</tt>.
<p/>
Small discussion on the issue can be found <a href="http://stackoverflow.com/questions/7518732/why-are-stdvectordata-and-stdstringdata-different">here</a>
and in the <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/ll9HuEML6zo/discussion">std-discussion thread</a>  
(which didn't get too much attention).
<p/>
This requires a small change to <tt>std::basic_string</tt>'s definition in 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> to add the method to 
<tt>std::basic_string</tt>, and another small change in 21.3.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/string.accessors">[string.accessors]</a> to define the new method.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Back to LEWG.
</p>

<p><i>[2016-05-22]</i></p>

<p>
Marshall says: this issue has been resolved by P0272R1.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change class template <tt>basic_string</tt> synopsis, 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
  class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {
  public:
    [&hellip;]
    <i>// 21.4.7, string operations:</i>
    const charT* c_str() const noexcept;
    const charT* data() const noexcept;
    <ins>charT* data() noexcept;</ins>
    allocator_type get_allocator() const noexcept;
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Add the following sequence of paragraphs following 21.3.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/string.accessors">[string.accessors]</a> p3, as indicated:</p>
<blockquote>
<pre>
<ins>charT* data() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: A pointer <tt>p</tt> such that <tt>p + i == &amp;operator[](i)</tt> for each <tt>i</tt> in <tt>[0,size()]</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Constant time.</ins>
<p/>
<ins>-?- <i>Requires</i>: The program shall not alter the value stored at <tt>p + size()</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2424" href="2424">2424.</a> 29.5 should state that atomic types are not trivially copyable</h3>
<p><b>Section:</b> 29.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2014-08-14 <b>Last modified:</b> 2017-02-02 20:02:09 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.generic">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.generic">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Otherwise, one could use <tt>memcpy</tt> to save and restore the value according to 3.9p2.
<p/>
It seems the core language rules in 9 <a href="https://timsong-cpp.github.io/cppwp/class">[class]</a>p6 with 12.8 <a href="https://timsong-cpp.github.io/cppwp/class.copy">[class.copy]</a>p12 
(trivial copy constructor) etc. and 8.4.2 <a href="https://timsong-cpp.github.io/cppwp/dcl.fct.def.default">[dcl.fct.def.default]</a>p5 (user-provided) say 
that the atomic types are trivially copyable, which is bad. We shouldn't rely on future core 
changes in that area and simply say in the library section 29.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a> 
that these very special types are not trivially copyable.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>
Lawrence:Definition of "trivially copyable" has been changing.
</p>
<p>
Doesn't hurt to add proposed change, even if the sentence is redundant
</p>
<p>
Move to Review.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
GR has a minor problem with the style of the wording. VV has major issues with implementability.
</p>

<p><i>[2015-03-22, Jens Maurer responses to Cologne discussion]</i></p>

<p>
A library implementation could provide a partial specialization for <tt>is_trivially_copyable&lt;atomic&lt;T&gt;&gt;</tt>, 
to ensure that any such type query would return <tt>false</tt>.
<p/>
Assuming such a specialization would be provided, how could a conforming program observe that per 
language rules an <tt>atomic</tt> specialization would actually be trivially copyable if there 
is no way to call the (deleted) copy constructor or copy assignment operator?
<p/>
The sole effect of the suggested addition of the constraining sentence is that it would make a user program
non-conforming that attempts to invoke <tt>memcpy</tt> (and the like) on <tt>atomic</tt> types, since that
would invoke undefined behaviour.
</p>

<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
SG1 is fine with P/R (and agrees it's needed), but LWG may want to
check the details; it's not entirely an SG1 issue.
</p>

<p><i>[2015-05-05 Lenexa]</i></p>

<p>Marshall: This was discussed on the telecon. Alisdair was going to write something to Mike and send it to Core.</p>
<p>Hwrd: Core says that deleted copies are trivially copyable, which makes no sense to Library people.</p>
<p>STL: There doesn't appear to be a Core issue about it.</p>

<p><i>[2015-09-11 Telecon]</i></p>

<p>Howard: currently <tt>std::is_trivially_copyable&lt;std::atomic&gt;</tt> is true, so this resolution would contradict reality</p>
<p>Jonathan: changing that is good, we don't want it to be trivially copyable, otherwise users can memcpy them, which we really don't want</p>
<p>Howard: is it reasonable to memcpy something that isn't trivially copy constructible or trivially assignable?</p>
<p>Jonathan: no, it's not, but Core says you can, so this resolution is needed to stop people memcpying atomic</p>
<p>Howard: we should fix the core rule</p>
<p>Marshall: there is a separate issue of whether trivially-copyable makes sense, but this resolution is a net good purely because it stops memcpy of atomics</p>
<p>Howard: so should implementations specialize <tt>is_trivially_copyable</tt> the trait to meet this?</p>
<p>Jonathan: or add an empty, user-defined destructor.</p>
<p>Howard: should the spec specify that then?</p>
<p>Over-specification.</p>
<p>Howard: without that I fear implementation divergence.</p>
<p>Ville and Jonathan to investigate potential implementation options.</p>
<p>Ville: request a note on the issue saying we need review other types such as <tt>condition_variable</tt> to see if they are also unintentionally trivially-copyable. N4460 mentions some such types.</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
We think there is something coming from Core to resolve that, and that this will be NAD.<br/>
Until then, defer.<br/>
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>This was resolved by Core Issue 1496</p>

<p><i>[2017-01-19 Jens Maurer comments, issue state to Review]</i></p>

<p>
The previous entry "[2016-03 Jacksonville] This was resolved by Core Issue 1496" is wrong; Core issue 1496 
only modified the definition of "trivial class", not of "trivially copyable". However, as Ville Voutilainen 
observed, Core Issue 1734 made all atomics not trivially copyable, because they do not have at least one 
non-deleted copy/move constructor or copy/move assignment operator.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<ol>
<li><p>Change 29.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a>p3 as indicated:</p>

<blockquote>
<p>
Specializations and instantiations of the <tt>atomic</tt> template shall have a deleted copy constructor, a deleted
copy assignment operator, and a constexpr value constructor. <ins>They are not trivially copyable 
types (3.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>).</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Resolved as NAD.</p>

<p><i>[2017-02-02 Daniel comments and adjusts status]</i></p>

<p>
The NAD resolution is inappropriate, because the group didn't argue against the actual issue, instead the situation was that
core wording changes in an unrelated area had resolved the previous problem indirectly. In this cases the correct resolution 
is Resolved by core wording changes as described by Jens Maurer in the 2017-01-19 comment.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2443" href="2443">2443.</a> <tt>std::array</tt> member functions should be <tt>constexpr</tt></h3>
<p><b>Section:</b> 23.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2014-10-06 <b>Last modified:</b> 2016-08-10 04:08:18 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When experimenting with C++14 relaxed <tt>constexpr</tt> functions I made the observation that I couldn't 
use <tt>std::array</tt> to create a table of data at compile time directly using loops in a function. 
However, a simple substitute I could use instead:
</p>
<blockquote>
<pre>
template &lt;typename T, size_t n&gt;
struct ar {
  T a[n];
  constexpr ar() : a{{}}{}
  constexpr auto data() const { return &amp;a[0];}
  constexpr T const &amp; operator[](size_t i) const { return a[i]; }
  constexpr T &amp; operator[](size_t i) { return a[i]; }
};

template &lt;size_t n&gt;
using arr = ar&lt;size_t, n&gt;; // std::array&lt;size_t, n&gt;;

template &lt;size_t n&gt;
constexpr auto make_tab(){
  arr&lt;n&gt; result;
  for(size_t i=0; i &lt; n; ++i)
    result[i] = (i+1)*(i+1); // cannot define operator[] for mutable array...
  return result;
}

template &lt;size_t n&gt;
constexpr auto squares=make_tab&lt; n&gt;();

int main() {
  int dummy[squares&lt;5&gt;[3]];
}
</pre>
</blockquote>
<p>
Therefore, I suggest that all member functions of <tt>std::array</tt> should be made <tt>constexpr</tt> 
to make the type usable in <tt>constexpr</tt> functions.
<p/>
Wording should be straight forward, may be with the exception of <tt>fill</tt>, which would require 
<tt>fill_n</tt> to be <tt>constexpr</tt> as well.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Move to LEWG</p>
<p>
The extent to which <tt>constexpr</tt> becomes a part of the Library design is a policy
matter best handled initially by LEWG.
</p>

<p><i>[08-2016, Post-Chicago]</i></p>

<p>Move to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>This functionality is provided by <a href="http://wg21.link/P0031R0">P0031R0</a></p>





<hr>
<h3><a name="2501" href="2501">2501.</a> <tt>std::function</tt> requires POCMA/POCCA</h3>
<p><b>Section:</b> 20.14.13.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-05-20 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The idea behind <tt>propagate_on_container_move_assignment</tt> is that you can keep an allocator attached to a container. 
But it's not really designed to work with polymorphism, which introduces the condition where the current allocator is non-POCMA 
and the RHS of assignment, being POCMA, wants to replace it. If function were to respect the literal meaning, any would-be 
attached allocator is at the mercy of every assignment operation. So, <tt>std::function</tt> is inherently POCMA, and passing 
a non-POCMA allocator should be ill-formed.
<p/>
The other alternative, and the status quo, is to ignore POCMA and assume it is true. This seems just dangerous enough to outlaw. 
It is, in theory, possible to properly support POCMA as far as I can see, albeit with difficulty and brittle results. It would 
require function to keep a throwing move constructor, which otherwise can be <tt>noexcept</tt>.
<p/>
The same applies to <tt>propagate_on_container_copy_assignment</tt>. This presents more difficulty because <tt>std::allocator</tt> 
does not set this to true. Perhaps it should. For function to respect this would require inspecting the POCCA of the source allocator, 
slicing the target from the erasure of the source, slicing the allocation from the erasure of the destination, and performing a 
copy with the destination's allocator with the source's target. This comes out of the blue for the destination allocator, which 
might not support the new type anyway. Theoretically possible, but brittle and not very practical. Again, current implementations 
quietly ignore the issue but this isn't very clean.
<p/>
The following code example is intended to demonstrate the issue here:
</p>
<blockquote><pre>
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
struct diag_alloc 
{
  std::string name;

  T* allocate(std::size_t n) const 
  {
    std::cout &lt;&lt; '+' &lt;&lt; name &lt;&lt; '\n';
    return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
  }
  
  void deallocate(T* p, std::size_t) const 
  {
    std::cout &lt;&lt; '-' &lt;&lt; name &lt;&lt; '\n';
    return ::operator delete(p);
  }

  template &lt;typename U&gt;
  operator diag_alloc&lt;U&gt;() const { return {name}; }

  friend bool operator==(const diag_alloc&amp; a, const diag_alloc&amp; b)
  { return a.name == b.name; }
  
  friend bool operator!=(const diag_alloc&amp; a, const diag_alloc&amp; b)
  { return a.name != b.name; }

  typedef T value_type;
  
  template &lt;typename U&gt;
  struct rebind { typedef diag_alloc&lt;U&gt; other; };
};

int main() {
  std::cout &lt;&lt; "VECTOR\n";
  std::vector&lt;int, diag_alloc&lt;int&gt;&gt; foo({1, 2}, {"foo"}); // +foo
  std::vector&lt;int, diag_alloc&lt;int&gt;&gt; bar({3, 4}, {"bar"}); // +bar

  std::cout &lt;&lt; "move\n";
  foo = std::move(bar); // no message

  std::cout &lt;&lt; "more foo\n";
  foo.reserve(40); // +foo -foo
  std::cout &lt;&lt; "more bar\n";
  bar.reserve(40); // +bar -bar

  std::cout &lt;&lt; "\nFUNCTION\n";
  int bigdata[100];
  auto bigfun = [bigdata]{};
  typedef decltype(bigfun) ft;
  std::cout &lt;&lt; "make fizz\n";
  std::function&lt;void()&gt; fizz(std::allocator_arg, diag_alloc&lt;ft&gt;{"fizz"}, bigfun); // +fizz
  std::cout &lt;&lt; "another fizz\n";
  std::function&lt;void()&gt; fizz2;
  fizz2 = fizz; // +fizz as if POCCA
  std::cout &lt;&lt; "make buzz\n";
  std::function&lt;void()&gt; buzz(std::allocator_arg, diag_alloc&lt;ft&gt;{"buzz"}, bigfun); // +buzz
  std::cout &lt;&lt; "move\n";
  buzz = std::move(fizz); // -buzz as if POCMA

  std::cout &lt;&lt; "\nCLEANUP\n";
}
</pre></blockquote>

<p><i>[2016-08, Chicago]</i></p>

<p>Tues PM: Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a>.
</p>





<hr>
<h3><a name="2502" href="2502">2502.</a> <tt>std::function</tt> does not use <tt>allocator::construct</tt></h3>
<p><b>Section:</b> 20.14.13.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-05-20 <b>Last modified:</b> 2016-08-06 21:08:52 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is impossible for <tt>std::function</tt> to construct its target object using the <tt>construct</tt> method of a type-erased 
allocator. More confusingly, it is possible when the allocator and the target are created at the same time. The means 
of target construction should be specified.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a>.
</p>






<hr>
<h3><a name="2505" href="2505">2505.</a> <tt>auto_ptr_ref</tt> creation requirements underspecified</h3>
<p><b>Section:</b> 99 [auto.ptr.conv] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-28 <b>Last modified:</b> 2016-08-09 17:08:10 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#auto.ptr.conv">issues</a> in [auto.ptr.conv].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++14 sub-clause 99 [auto.ptr.conv], there appears to be no requirement that the formation of an 
<tt>auto_ptr_ref&lt;Y&gt;</tt> from an <tt>auto_ptr&lt;X&gt;</tt> is done only when <tt>X*</tt> can be implicitly 
converted to <tt>Y*</tt>.
<p/>
For example, I expect formation of the <tt>auto_ptr_ref&lt;A&gt;</tt> from the prvalue of type <tt>auto_ptr&lt;B&gt;</tt> 
to be invalid in the case below (but the wording does not seem to be there):
</p>
<blockquote><pre>
#include &lt;memory&gt;

struct A { };
struct B { } b;

std::auto_ptr&lt;B&gt; apB() { return std::auto_ptr&lt;B&gt;(&amp;b); }
int main() {
  std::auto_ptr&lt;A&gt; apA(apB());
  apA.release();
}
</pre></blockquote>
<p>
The behaviour of the implementation in question on the case presented above is to compile and execute it successfully 
(which is what the C++14 wording implies). The returned value from <tt>apA.release()</tt> is essentially 
<tt>reinterpret_cast&lt;A*&gt;(&amp;b)</tt>.
<p/>
There is nothing in the specification of
</p>
<blockquote><pre>
template &lt;class X&gt;
template &lt;class Y&gt; operator auto_ptr&lt;X&gt;::auto_ptr_ref&lt;Y&gt;() throw();
</pre></blockquote>
<p>
which implies that <tt>X*</tt> should be implicitly convertible to <tt>Y*</tt>.
<p/>
The implementation in question uses the <tt>reinterpret_cast</tt> interpretation even when <tt>Y</tt> is an accessible, 
unambiguous base class of <tt>X</tt>; the result thereof is that no offset adjustment is performed.
</p>

<p><i>[2015-07, Telecon]</i></p>

<p>
Marshall to resolve.
</p>

<p><i>[2016-03-16, Alisdair Meredith comments]</i></p>

<p>
This issue is a defect in a component we have actively removed
from the standard. I can't think of a clearer example of something
that is no longer a defect!
</p>

<p><i>[2016-08-03, Alisdair Meredith comments]</i></p>

<p>
As C++17 removes <tt>auto_ptr</tt>, I suggest closing this issue as closed by paper 
<a href="http://wg21.link/n4190">N4190</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to ISO/IEC 14882:2014(E).
</p>

<ol>
<li><p>Change 99 [auto.ptr.conv] as indicated:</p>

<blockquote>
<pre>
template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() throw();
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>X*</tt> can be implicitly converted to <tt>Y*</tt>.</ins>
<p/>
-3- <i>Returns</i>: An <tt>auto_ptr_ref&lt;Y&gt;</tt> that holds <tt>*this</tt>.
<p/>
<ins>-?- <i>Notes</i>: Because <tt>auto_ptr_ref</tt> is present for exposition only, the only way to invoke this function 
is by calling one of the <tt>auto_ptr</tt> conversions which take an <tt>auto_ptr_ref</tt> as an argument. Since all 
such conversions will call <tt>release()</tt> on <tt>*this</tt> (in the form of the <tt>auto_ptr</tt> that the 
<tt>auto_ptr_ref</tt> holds a reference to), an implementation of this function may cause instantiation of said 
<tt>release()</tt> function without changing the semantics of the program.</ins>
</p>
</blockquote>
<pre>
template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() throw();
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>X*</tt> can be implicitly converted to <tt>Y*</tt>.</ins>
<p/>
-4- <i>Effects</i>: Calls <tt>release()</tt>.
<p/>
-5- <i>Returns</i>: An <tt>auto_ptr&lt;Y&gt;</tt> that holds the pointer returned from <tt>release()</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by acceptance of <a href="http://wg21.link/n4190">N4190</a>.
</p>





<hr>
<h3><a name="2529" href="2529">2529.</a> Assigning to <tt>enable_shared_from_this::__weak_this</tt> twice</h3>
<p><b>Section:</b> 20.11.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-08-26 <b>Last modified:</b> 2016-08-07 15:08:44 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear what should happen if a pointer to an object with an
<tt>enable_shared_from_this</tt> base is passed to two different <tt>shared_ptr</tt>
constructors.
</p>
<blockquote><pre>
#include &lt;memory&gt;

using namespace std;

int main()
{
  struct X : public enable_shared_from_this&lt;X&gt; { };
  auto xraw = new X;
  shared_ptr&lt;X&gt; xp1(xraw);  // #1
  {
    shared_ptr&lt;X&gt; xp2(xraw, [](void*) { });  // #2
  }
  xraw-&gt;shared_from_this();  // #3
}
</pre></blockquote>
<p>
This is similar to LWG <a href="2179">2179</a>, but involves no undefined behaviour due
to the no-op deleter, and the question is not whether the second
<tt>shared_ptr</tt> should share ownership with the first, but which <tt>shared_ptr</tt>
shares ownership with the <tt>enable_shared_from_this::__weak_this</tt> member.
<p/>
With all three of the major <tt>std::shared_ptr</tt> implementations the <tt>xp2</tt>
constructor modifies the <tt>__weak_this</tt> member so the last line of the
program throws <tt>bad_weak_ptr</tt>, even though all the requirements on the 
<tt>shared_from_this()</tt> function are met (20.11.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a>)/7:
</p>
<blockquote><p>
<i>Requires</i>: <tt>enable_shared_from_this&lt;T&gt;</tt> shall be an accessible base class
of <tt>T</tt>. <tt>*this</tt> shall be a subobject of an object <tt>t</tt> of type <tt>T</tt>. There shall
be at least one <tt>shared_ptr</tt> instance <tt>p</tt> that owns <tt>&amp;t</tt>.
</p></blockquote>
<p>
Boost doesn't update <tt>__weak_this</tt>, leaving it sharing with <tt>xp1</tt>, so the
program doesn't throw. That change was made to <tt>boost::enable_shared_from_this</tt> because 
someone reported exactly this issue as a bug, see <a href="https://svn.boost.org/trac/boost/ticket/2584">Boost issue 2584</a>.
<p/>
On the reflector Peter Dimov explained that there are real-world use
cases that rely on the Boost behaviour, and none which rely on the
behaviour of the current <tt>std::shared_ptr</tt> implementations. We should
specify the behaviour of <tt>enable_shared_from_this</tt> more precisely, and
resolve this issue one way or another.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper <a href="http://wg21.link/p0033r1">p0033r1</a> at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2548" href="2548">2548.</a> Missing <tt>vfscanf</tt> from <tt>&lt;cstdio&gt;</tt></h3>
<p><b>Section:</b> 27.11 <a href="https://timsong-cpp.github.io/cppwp/c.files">[c.files]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Richard Smith  <b>Opened:</b> 2015-10-09 <b>Last modified:</b> 2016-08-05 03:08:05 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.files">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/c.files">[c.files]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C's <tt>vfscanf</tt> function is not present in C++'s <tt>&lt;cstdio&gt;</tt>, and presumably should be. 
It looks like this is the only missing member of C's <tt>[v]{f,s,sn}[w]{printf,scanf}</tt> family.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Resolved by P0175R1</p>
<p>Thurs AM: Moved to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<p>Modify Table 133 as follows:</p>
<p>
<tt>ungetc</tt><br/>
<tt>vfprintf</tt><br/>
<ins><tt>vfscanf</tt></ins><br/>
<tt>vprintf</tt><br/>
<tt>vscanf</tt><br/>
</p>





<hr>
<h3><a name="2663" href="2663">2663.</a> Enable efficient retrieval of file size from <code>directory_entry</code></h3>
<p><b>Section:</b> 27.10.15.14 <a href="https://timsong-cpp.github.io/cppwp/fs.op.file_size">[fs.op.file_size]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Gor Nishanov <b>Opened:</b> 2014-05-22 <b>Last modified:</b> 2016-08-11 20:08:16 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  On Windows, the <code><del>FindFileData</del> <ins>WIN32_FIND_DATA</ins></code> structure, which is the underlying data type for <code>directory_entry</code>, contains the file size as one of the fields.

  Thus efficient enumeration of files and getting their sizes is possible without doing a separate query for the file size.

</p>
  <p><i>[17 Jun 2014 Rapperswil LWG will investigate issue at a subsequent meeting.]</i></p>

  <p><i>[23 Nov 2015 Editorally correct name of data structure mentioned in discussion.]</i></p>


<p><i>[Mar 2016 Jacksonville Beman to provide paper about this]</i></p>


<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><strong>Previous resolution [SUPERSEDED]</strong></p>
<blockquote class="note">
  <p>
    <i>
      In 27.10.12 <a href="https://timsong-cpp.github.io/cppwp/class.directory_entry">[class.directory_entry]</a> Class <code>directory_entry</code> add the
      following observer declarations:
    </i>
  </p>
  <p></p>
  <blockquote>
    <pre>
      uintmax_t file_size();
      uintmax_t file_size(error_code&amp; ec) noexcept;
    </pre>
  </blockquote>
  <p>
    <i>
      In <code>directory_entry</code> observers 27.10.12.3 <a href="https://timsong-cpp.github.io/cppwp/directory_entry.obs">[directory_entry.obs]</a>
      add the following:
    </i>
  </p>
  <p></p>
  <blockquote>
    <pre>
      uintmax_t file_size();
      uintmax_t file_size(error_code&amp; ec) noexcept;
    </pre>
    <p></p>
    <blockquote>
      <p>
        <i>Returns:</i> if <code>*this</code> contains a cached file size, return
        it.
        Otherwise return <code>file_size(path())</code> or <code>file_size(path(), ec)</code>
        respectively.
      </p>
      <p>
        <i>Throws:</i> As specified in Error reporting (7).
      </p>
    </blockquote>
  </blockquote>
</blockquote>

<p><i>[2016-08, Beman comments]</i></p>

<p>
This will be resolved by <a href="http://wg21.link/p0317r1">P0317R1</a>, Directory Entry Caching for Filesystem.
<p>Fri AM: Moved to Tentatively Resolved</p>
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2677" href="2677">2677.</a> <code>directory_entry::status</code> is not allowed to be cached as a quality-of-implementation issue</h3>
<p><b>Section:</b> 27.10.12.3 <a href="https://timsong-cpp.github.io/cppwp/directory_entry.obs">[directory_entry.obs]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Billy O'Neal <b>Opened:</b> 2016-03-03 <b>Last modified:</b> 2016-08-06 20:08:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#directory_entry.obs">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/directory_entry.obs">[directory_entry.obs]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>To fix multi-threading problems in <code>directory_entry</code>, caching behavior
was removed from the type. This is bad for performance reasons,
because the values can no longer be cached from the result of <code>readdir</code>
on POSIX platforms, or from <code>FindFirstFile/FindNextFile</code> on Windows.</p>

<p>It appears that the intent was to allow implementers to fill in the
values for <code>directory_entry::status</code> inside <code>directory_iterator</code>, but as
currently specified:</p>

    <blockquote><i>Returns:</i> <code>status(path()[, ec])</code>.</blockquote>

<p>This is not allowed to be cached, because the target of the path can
change. For example, consider the following program:</p>

<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;

using namespace std;
namespace fs = ::std::filesystem;

void verify(const bool b, const char * const msg) {
    if (!b) {
        printf("fail: %s\n", msg);
        exit(1);
    }
}

void touch_file(const char * const filename) {
    ofstream f(filename);
    f &lt;&lt; '\n' &lt;&lt; endl;
    verify(f.good(), "File write failed");
}

int main() {
    fs::remove_all("subDir");
    fs::create_directory("subDir");
    fs::create_directory("subDir/child");
    touch_file("subDir/child/child");
    fs::current_path("./subDir");
    fs::directory_iterator dir(".");
    ++dir;
    fs::directory_entry entry = *dir;

    verify(entry == "./child",
      "unexpected subdirectory"); //enumerating "subDir" returned the directory "child"

    fs::file_status status = entry.status();
    verify(status.type() == fs::file_type::directory,
        "subDir/child was not a directory");
    fs::current_path("./child");
    status = entry.status(); // REQUIRED to re-stat() on POSIX,
                             // GetFileAttributes() on Windows
    verify(status.type() == fs::file_type::regular,
        "subDir/child/child was not a regular file");
    return 0;
}</pre>

  <p>
    <code>directory_entry</code> should be re-specified to allow implementers to cache
    the value of <code>status(path)</code> at the time <code>irectory_iterator</code> was
    incremented to avoid repeated <code>stat()</code> / <code>GetFileAttributes</code> calls. (This
    may mean additional constructors are necessary for <code>directory_entry</code> as well)
  </p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
Beman is working on a paper to address this.
</p>

<p><i>[2016-08, Beman comments]</i></p>

<p>This will be resolved by <a href="http://wg21.link/p0317r1">P0317R1</a>, Directory Entry Caching for Filesystem.</p>
<p>Fri AM: Moved to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2692" href="2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 17.4.2.1.4 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2717" href="2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 20.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-06-05 16:06:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 20.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





<hr>
<h3><a name="2757" href="2757">2757.</a> <tt>std::string{}.insert(3, "ABCDE", 0, 1)</tt> is ambiguous</h3>
<p><b>Section:</b> 21.3.2.6.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-07-30 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.insert">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Before C++17, we had the following signature to <tt>std::basic_string</tt>:
</p>
<blockquote><pre>
basic_string&amp;
  insert(size_type pos1, const basic_string&amp; str, size_type pos2, size_type n = npos);
</pre></blockquote>
<p>
Unlike most of the other member functions on <tt>std::basic_string</tt>, there were not corresponding
versions that take a <tt>charT*</tt> or <tt>(charT *, size)</tt>.
<p/>
In <a href="http://wg21.link/p0254r2">p0254r2</a>, we added:
</p>
<blockquote><pre>
basic_string&amp;
  insert(size_type pos1, basic_string_view&lt;charT, traits&gt; sv, size_type pos2, size_type n = npos);
</pre></blockquote>
<p>
which made the code above ambiguous. There are two conversions from "<tt>const charT*</tt>", 
one to <tt>basic_string</tt>, and the other to <tt>basic_string_view</tt>, and they're both equally 
good (in the view of the compiler).
<p/>
This ambiguity also occurs with the calls
</p>
<blockquote><pre>
assign(const basic_string&amp; str,             size_type pos, size_type n = npos);
assign(basic_string_view&lt;charT, traits&gt; sv, size_type pos, size_type n = npos);
</pre></blockquote>
<p>
but I will file a separate issue (<a href="2758">2758</a>) for that.
<p/>
A solution is to add <em>even more</em> overloads to <tt>insert</tt>, to make it match all the other member
functions of <tt>basic_string</tt>, which come in fours (<tt>string</tt>, <tt>pointer</tt>, <tt>pointer + size</tt>, 
<tt>string_view</tt>).
</p>

<p><i>[2016-08-03, Chicago, Robert Douglas provides wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> modify the synopsis for <tt>basic_string</tt> as follows:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
  public:
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                         size_type pos2, size_type n = npos);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>In 21.3.2.6.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a>, modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                     size_type pos2, size_type n = npos);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_same_v&lt;T, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-04, Chicago, Robert Douglas comments]</i></p>

<p>
For the sake of simplicity, the previous wording suggestion has been merged into the proposed wording
of LWG <a href="2758">2758</a>.
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Fri PM: Move to Tentatively Ready (along with <a href="2758">2758</a>).</p>

<p><i>[2016-09-09 Issues Resolution Telecon]</i></p>

<p>Since <a href="2758">2758</a> has been moved back to Open, move this one, too</p>

<p><i>[2016-10 Telecon]</i></p>

<p>Ville's wording for <a href="2758">2758</a> has been implemented in libstdc++ and libc++. Move <a href="2758">2758</a> to Tentatively Ready and this one to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>
This issue is resolved by the proposed wording for LWG <a href="2758">2758</a>.
</p>





<hr>
<h3><a name="2768" href="2768">2768.</a> <tt>any_cast</tt> and move semantics</h3>
<p><b>Section:</b> 20.8.4 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-08-27 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.nonmembers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#any.nonmembers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2509">2509</a> made two changes to the specification of <tt>any</tt> in v2 of the library fundamentals TS:
</p>

<ol>
<li>It altered the effects of the <tt>any_cast(any&amp;&amp;)</tt> overload to enable moving the value out of the <tt>any</tt> 
object and/or obtaining an rvalue reference to the contained value.</li>

<li>It made changes to support pathological copyable-but-not-movable contained values, which is madness.</li>
</ol>

<p>
Change 1 has very desirable effects; I propose that we apply the sane part of LWG <a href="2509">2509</a> to <tt>any</tt> 
in the C++17 WP, for all of the reasons cited in the discussion of LWG <a href="2509">2509</a>.
</p>

<p><i>[2016-09-09 Issues Resolution Telecon]</i></p>

<p>P0; move to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 20.8.4 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> p5, edit as follows:</p>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
<blockquote>
<p>
-4- <i>Requires</i>: <tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or <tt>is_copy_constructible_v&lt;ValueType&gt;</tt> 
is <tt>true</tt>. Otherwise the program is ill-formed. 
</p>
<p>
-5- <i>Returns</i>: For the first form, <tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. 
For the second <del>and third</del> form<del>s</del>, <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>. 
<ins>For the third form, <tt>std::forward&lt;ValueType&gt;(*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand))</tt>.</ins>
</p>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>

</blockquote>
<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by the wording provided by LWG <a href="2769">2769</a>.
</p>






<hr>
<h3><a name="2769" href="2769">2769.</a> Redundant <tt>const</tt> in the return type of <tt>any_cast(const any&amp;)</tt></h3>
<p><b>Section:</b> 20.8.4 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-09-02 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.nonmembers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#any.nonmembers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The overload of <tt>any_cast</tt> that accepts a reference to constant <tt>any</tt>:
</p>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
</pre>
</blockquote>
<p>
is specified to return <tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt> in [any.nonmembers]/5. This calls the pointer-to-constant overload of <tt>any_cast</tt>:
</p>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  const ValueType* any_cast(const any* operand) noexcept;
</pre>
</blockquote>
<p>
which is specified as:
</p>
<blockquote>
<i>Returns:</i> If <tt>operand != nullptr &amp;&amp; operand-&gt;type() == typeid(ValueType)</tt>, a pointer to the object contained by <tt>operand</tt>; otherwise, <tt>nullptr</tt>.
</blockquote>
<p>
Since <tt>typeid(T) == typeid(const T)</tt> for all types <tt>T</tt>, <tt>any_cast&lt;add_const_t&lt;T&gt;&gt;(&amp;operand)</tt> is equivalent to <tt>any_cast&lt;T&gt;(&amp;operand)</tt> for all types <tt>T</tt> when operand is a constant lvalue <tt>any</tt>. 
The <tt>add_const_t</tt> in the return specification of the first overload above is therefore redundant.
</p>

<p><i>[2016-09-09 Issues Resolution Telecon]</i></p>

<p>P0; move to Tentatively Ready</p>
<p>Casey will provide combined wording for this and <a href="2768">2768</a>, since they modify the same paragraph.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.4 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
</blockquote>
<p>
-4- <i>Requires:</i> <tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or 
<tt>is_copy_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt>. Otherwise the program is ill-formed.
<p/>
-5- <i>Returns:</i> <del>For the first form, 
<tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. 
For the second and third forms,</del> <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-09-09 Casey improves wording as determined by telecon]</i></p>

<p>
The presented resolution is intended as the common wording for both LWG <a href="2768">2768</a> and LWG <a href="2769">2769</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.4 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
</blockquote>
<p>
-4- <i>Requires:</i> <tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or 
<tt>is_copy_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt>. Otherwise the program is ill-formed.
<p/>
-5- <i>Returns:</i> For the first <del>form, 
<tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. 
For the</del> <ins>and</ins> second <del>and third</del> form<del>s</del>, 
<tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>. <ins>For the third form, 
<tt>std::forward&lt;ValueType&gt;(*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand))</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-10-05, Tomasz and Casey reopen and improve the wording]</i></p>

<p>
The constraints placed on the non-pointer <tt>any_cast</tt> overloads are neither necessary nor sufficient to 
guarantee that the specified effects are well-formed. The current PR for LWG <a href="2769">2769</a> also makes it 
possible to retrieve a dangling lvalue reference to a temporary any with e.g. <tt>any_cast&lt;int&amp;&gt;(any{42})</tt>, 
which should be forbidden.
</p>

<p><i>[2016-10-16, Eric made some corrections to the wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.4 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
</blockquote>
<p>
-4- <i>Requires:</i> <del><tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or 
<tt>is_copy_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt>.</del><ins>For the first 
overload, <tt>is_constructible_v&lt;ValueType, const remove_cv_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&amp;&gt;</tt> 
is <tt>true</tt>. For the second overload, <tt>is_constructible_v&lt;ValueType, 
remove_cv_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&amp;&gt;</tt> is <tt>true</tt>. For the third overload, 
<tt>is_constructible_v&lt;ValueType, remove_cv_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;</tt> is 
<tt>true</tt>.</ins> Otherwise the program is ill-formed.
<p/>
-5- <i>Returns:</i> <del>For the first form, 
<tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. For the second and third 
forms, <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>.</del><ins>For the first and second 
overload, <tt>static_cast&lt;ValueType&gt;(*any_cast&lt;remove_cv_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand))</tt>. For the third overload, <tt>static_cast&lt;ValueType&gt;(std::move(*any_cast&lt;remove_cv_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)))</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-11-10, LWG asks for simplification of the wording]</i></p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.4 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
</blockquote>
<p>
<ins>-?- Let <tt>U</tt> be the type <tt>remove_cv_t&lt;remove_reference_t&lt;ValueType&gt;&gt;</tt>.</ins>
</p>
<p>
-4- <i>Requires:</i> <del><tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or
<tt>is_copy_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt>.</del><ins>For the first
overload, <tt>is_constructible_v&lt;ValueType, const U&amp;&gt;</tt>
is <tt>true</tt>. For the second overload, <tt>is_constructible_v&lt;ValueType,
U&amp;&gt;</tt> is <tt>true</tt>. For the third overload,
<tt>is_constructible_v&lt;ValueType, U&gt;</tt> is
<tt>true</tt>.</ins> Otherwise the program is ill-formed.
<p/>
-5- <i>Returns:</i> <del>For the first form,
<tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. For the second and third
forms, <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>.</del><ins>For the first and second
overload, <tt>static_cast&lt;ValueType&gt;(*any_cast&lt;U&gt;(&amp;operand))</tt>. For the third overload, <tt>static_cast&lt;ValueType&gt;(std::move(*any_cast&lt;U&gt;(&amp;operand)))</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2789" href="2789">2789.</a> Equivalence of contained objects</h3>
<p><b>Section:</b> 20.8.3 <a href="https://timsong-cpp.github.io/cppwp/any.class">[any.class]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 29</b>
<p/>
What does it mean for (the contained) objects to be "equivalent"?
<p/>
Suggested resolution:
<p/>
Add definition (note that using <tt>operator==()</tt> involves complicated questions of overload 
resolution).
</p>

<p><i>[2016-11-08, Jonathan comments and suggests wording]</i></p>

<p>
We can rephrase the copy constructor in terms of equivalence to
construction from the contained object. We need to use in-place
construction to avoid recursion in the case where the contained object
is itself an any.
<p/>
For the move constructor we don't simply want to construct from the
contrained object, because when the contained object is stored in
dynamic memory we don't actually construct anything, we just transfer
ownership of a pointer.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change [any.cons] p2:</p>
<blockquote>
<pre>
any(const any&amp; other);
</pre>
<blockquote>
<p>
<i>Effects:</i> <del>Constructs an object of type <tt>any</tt> with an equivalent
state as <tt>other</tt>.</del><ins>If <tt>other.has_value()</tt> is <tt>false</tt>, 
constructs an object that has no value. Otherwise, equivalent to 
<tt>any(in_place&lt;T&gt;, any_cast&lt;const T&amp;&gt;(other))</tt> where <tt>T</tt> 
is the type of the contained object.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change [any.cons] p4:</p>

<blockquote>
<pre>
any(any&amp;&amp; other);
</pre>
<blockquote>
<p>
<i>Effects:</i> <del>Constructs an object of type <tt>any</tt> with a state equivalent
to the original state of <tt>other</tt>.</del><ins>If <tt>other.has_value()</tt> is <tt>false</tt>, 
constructs an object that has no value. Otherwise, constructs an object of type <tt>any</tt> that contains
either the contained object of <tt>other</tt>, or contains an object of the same type constructed from 
the contained object of other considering that contained object as an rvalue.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2794" href="2794">2794.</a> Missing requirements for allocator pointers</h3>
<p><b>Section:</b> 23.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2016-12-16 20:12:38 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 146</b>
<p/>
An allocator-aware contiguous container must require 
an allocator whose pointer type is a contiguous 
iterator. Otherwise, functions like data for <tt>basic_string</tt>
and <tt>vector</tt> do not work correctly, along with many 
other expectations of the contiguous guarantee.
<p/>
Suggested resolution:
<p/>
Add a second sentence to 23.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p13:
</p>
<blockquote><p>
An allocator-aware contiguous container requires <tt>allocator_traits&lt;Allocator&gt;::pointer</tt> is a 
contiguous iterator.
</p></blockquote>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: Move to 'Tentatively Ready'</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 17.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>/5, edit as follows:</p>
<blockquote>
<p>
-5- An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these pointer types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access 
iterator (<del>24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a></del><ins>24.2.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a></ins>)
<ins>and of a contiguous iterator (24.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2795" href="2795">2795.</a> &sect;[global.functions] provides incorrect example of ADL use</h3>
<p><b>Section:</b> 17.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#global.functions">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#global.functions">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses GB 39</b>
<p/>
The example is supposed to highlight the 'otherwise specified' 
aspect of invoking ADL, yet there is no such specification. It is 
unlikely that we intend to explicitly qualify calls to operator functions, 
so they probably should be exempted from this restriction.
<p/>
Suggested resolution:
<p/>
Fix example (and referenced clause) to specify use of ADL, or exempt operators from 
this clause, and find a better example, probably using <tt>swap</tt>.
</p>

<p><i>[2016-11-09, Jonathan comments and provides wording]</i></p>

<p>
The current wording was added by DR <a href="225">225</a>.
</p>

<p><i>[2016-11-10, Tim Song comments]</i></p>

<p>
The "non-operator" seems to have been added at the wrong spot. The problem at issue is permission 
to call operator functions found via ADL, not permission for operator functions in the standard 
library to ADL all over the place. The problem is not unique to operator functions in the standard 
library &mdash; a significant portion of <tt>&lt;algorithm&gt;</tt> and <tt>&lt;numeric&gt;</tt> 
uses some operator (<tt>==</tt>, <tt>&lt;</tt>, <tt>+</tt>, <tt>*</tt>, etc.) that may be picked 
up via ADL.
<p/>
There is also an existing problem in that the example makes no sense anyway: the constraint in this 
paragraph only applies to non-members, yet <tt>ostream_iterator::operator=</tt> is a member function.
</p>

<p><i>[2016-11-10, Tim Song and Jonathan agree on new wording]</i></p>

<p>
The new wording still doesn't quite get it right:
</p>
<blockquote><p>
"calls to non-operator, non-member functions in the standard library do not use functions from another namespace 
which are found through argument-dependent name lookup" can be interpreted as saying that if a user writes 
"<tt>std::equal(a, b, c, d)</tt>", that call will not use ADL'd "<tt>operator==</tt>" because 
"<tt>std::equal(a, b, c, d)</tt>" is a "call" to a "non-operator, non-member function in the standard library".
</p></blockquote>
<p>
The key point here is that "in the standard library" should be modifying "calls", not "function".
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 17.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> p4:</p>
<blockquote>
<p>
Unless otherwise specified, <ins>non-operator,</ins> non-member functions in the standard library shall not use functions from
another namespace which are found through argument-dependent name lookup (3.4.2). [<i>Note:</i> The phrase
"unless otherwise specified" <ins>applies to cases such as the swappable with requirements (17.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>). 
The exception for overloaded operators allows</ins><del>is intended to allow</del> argument-dependent lookup in cases like that of 
<tt>ostream_iterator::operator=</tt> (24.6.2.2):
</p>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote>
<pre>
*out_stream &lt;&lt; value;
if (delim != 0)
  *out_stream &lt;&lt; delim ;
return *this;
</pre>
</blockquote>
<p>
&mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 17.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> p4:</p>
<blockquote>
<p>
Unless otherwise specified, <ins>calls made by functions in the standard library to non-operator,</ins> non-member functions 
 <del>in the standard library</del> <del>shall</del><ins>do</ins> not use functions from another namespace which are found through 
argument-dependent name lookup (3.4.2). [<i>Note:</i> The phrase "unless otherwise specified" <ins>applies to 
cases such as the swappable with requirements (17.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>). 
The exception for overloaded operators allows</ins><del>is intended to allow</del> argument-dependent lookup in cases like that of 
<tt>ostream_iterator::operator=</tt> (24.6.2.2):
</p>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote>
<pre>
*out_stream &lt;&lt; value;
if (delim != 0)
  *out_stream &lt;&lt; delim ;
return *this;
</pre>
</blockquote>
<p>
&mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2804" href="2804">2804.</a> Unconditional <tt>constexpr</tt> default constructor for <tt>istream_iterator</tt></h3>
<p><b>Section:</b> 24.6.1.1 <a href="https://timsong-cpp.github.io/cppwp/istream.iterator.cons">[istream.iterator.cons]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#istream.iterator.cons">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/istream.iterator.cons">[istream.iterator.cons]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.iterator.cons">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/istream.iterator.cons">[istream.iterator.cons]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 152</b>
<p/>
<i>see below</i> for the default constructor should simply be 
spelled <tt>constexpr</tt>. The current declaration looks like a 
member function, not a constructor, and the <tt>constexpr</tt> 
keyword implicitly does not apply unless the instantiation could 
make it so, under the guarantees al ready present in the Effects clause.
</p>
<p>
Proposed change:
<p/>
Replace <i>see below</i> with <tt>constexpr</tt> in the declaration 
of the default constructor for <tt>istream_iterator</tt> in the 
class definition, and function specification.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Jonathan provides wording, Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>In the class synopsis in 24.6.1 [istream.iterator] change the default constructor:</p>
<blockquote>
<pre>
<del><i>see below</i></del><ins>constexpr</ins> istream_iterator();
istream_iterator(istream_type&amp; s);
istream_iterator(const istream_iterator&amp; x) = default;
~istream_iterator() = default;
</pre>
</blockquote>

<p>Change [istream.iterator.cons] before paragraph 1:</p>
<blockquote>
<pre>
<del><i>see below</i></del><ins>constexpr</ins> istream_iterator();

-1- Effects: ...
</pre>
</blockquote>





<hr>
<h3><a name="2812" href="2812">2812.</a> Range access is available with <tt>&lt;string_view&gt;</tt></h3>
<p><b>Section:</b> 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>, 21.4.1 <a href="https://timsong-cpp.github.io/cppwp/string.view.synop">[string.view.synop]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2016-10-29 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.4.1 <a href="https://timsong-cpp.github.io/cppwp/string.view.synop">[string.view.synop]</a>/1 states
</p>
<blockquote><p>
The function templates defined in 20.2.2 and 24.7 are available when <tt>&lt;string_view&gt;</tt> is included.
</p></blockquote>
<p>
24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>, in p1 is missing <tt>&lt;string_view&gt;</tt>.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li>
<p>Edit 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> p1 as indicated:</p>

<blockquote>
<p>
-1- In addition to being available via inclusion of the <tt>&lt;iterator&gt;</tt> header, the function templates 
in 24.7 are available when any of the following headers are included: <tt>&lt;array&gt;</tt>, <tt>&lt;deque&gt;</tt>, 
<tt>&lt;forward_list&gt;</tt>, <tt>&lt;list&gt;</tt>, <tt>&lt;map&gt;</tt>, <tt>&lt;regex&gt;</tt>, 
<tt>&lt;set&gt;</tt>, <tt>&lt;string&gt;</tt><ins>, <tt>&lt;string_view&gt;</tt></ins>, <tt>&lt;unordered_map&gt;</tt>, 
<tt>&lt;unordered_set&gt;</tt>, and <tt>&lt;vector&gt;</tt>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2824" href="2824">2824.</a> <tt>list::sort</tt> should say that the order of elements is unspecified if an exception is thrown</h3>
<p><b>Section:</b> 23.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-11-16 <b>Last modified:</b> 2017-02-05 17:02:20 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#list.ops">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sometime between N1638 and N1804 the sentence "If an exception is thrown the order of the elements in the list is indeterminate." 
in the specification of <tt>list::sort</tt> went missing. This suspiciously coincided with the editorial change that "consolidated definitions of "Stable" in the library clauses" (N1805).
<p/>
<tt>forward_list::sort</tt> says that "If an exception is thrown the order of the elements in <tt>*this</tt> is unspecified"; 
<tt>list::sort</tt> should do the same.
</p>
<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Edit 23.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p29 as indicated:</p>

<blockquote>
<pre>
void sort();
template &lt;class Compare&gt; void sort(Compare comp);
</pre>
<blockquote>
<p>
-28- <i>Requires:</i> <tt>operator&lt;</tt> (for the first version) or <tt>comp</tt> (for the second version) shall define 
a strict weak ordering (25.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a>).
<p/>
-29- <i>Effects:</i> Sorts the list according to the <tt>operator&lt;</tt> or a <tt>Compare</tt> function object. <ins>If an 
exception is thrown, the order of the elements in <tt>*this</tt> is unspecified.</ins> Does not affect the validity of 
iterators and references.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2826" href="2826">2826.</a> <tt>string_view</tt> iterators use old wording</h3>
<p><b>Section:</b> 21.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.iterators">[string.view.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2016-11-17 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording for <tt>basic_string_view</tt> was written before the definition of
a contiguous iterator was added to C++17 to avoid repeating redundant
wording.
</p>
<p>
Suggested modification of 21.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.iterators">[string.view.iterators]</a> p1 (stealing words from <tt>valarray begin</tt>/<tt>end</tt>):
</p>
<blockquote><p>
-1- <del>A constant random-access iterator type such that, for a <tt>const_iterator it</tt>, if <tt>&amp;*(it + N)</tt> is valid,
then <tt>&amp;*(it + N) == (&amp;*it) + N</tt></del><ins>A type that meets the requirements of a constant random access iterator 
(24.2.7) and of a contiguous iterator (24.2.1) whose <tt>value_type</tt> is the template parameter <tt>charT</tt></ins>.
</p></blockquote>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 21.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.iterators">[string.view.iterators]</a> as indicated:</p>
<blockquote>
<pre>
using const_iterator = <i>implementation-defined</i>;
</pre>
<blockquote>
<p>
-1- A <del>constant random-access iterator type such that, for a <tt>const_iterator it</tt>, if <tt>&amp;*(it + N)</tt> is valid,
then <tt>&amp;*(it + N) == (&amp;*it) + N</tt></del><ins>type that meets the requirements of a constant random access 
iterator (24.2.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>) and of a contiguous iterator (24.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)
whose <tt>value_type</tt> is the template parameter <tt>charT</tt></ins>.
<p/>
-2- For a <tt>basic_string_view str</tt>, any operation that invalidates a pointer in the range <tt>[str.data(),
str.data() + str.size())</tt> invalidates pointers, iterators, and references returned from <tt>str</tt>'s methods.
<p/>
-3- All requirements on container iterators (23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>) apply to 
<tt>basic_string_view::const_iterator</tt> as well.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2834" href="2834">2834.</a> Resolution LWG 2223 is missing wording about end iterators</h3>
<p><b>Section:</b> 21.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a>, 23.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a>, 23.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-11-29 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.capacity">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of LWG <a href="2223">2223</a> added the wording "Reallocation invalidates all the references, pointers, 
and iterators referring to the elements in the sequence." to a number of <tt>shrink_to_fit</tt> operations.
<p/>
This seems to be missing any mention of end iterators. Surely end iterators are invalidated, too?
<p/>
Suggested resolution:
<p/>
For <tt>string</tt>, <tt>deque</tt>, and <tt>vector</tt> each, append as follows:
<p/>
Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence <ins>as 
well as the past-the-end iterator</ins>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.
</p>
<ol>
<li><p>Edit 21.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a> as indicated:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Remarks:</i> Reallocation invalidates all the references, pointers, and iterators referring to the elements in
the sequence <ins>as well as the past-the-end iterator</ins>. If no reallocation happens, they remain valid.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 23.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a> as indicated:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-8- <i>Remarks:</i> <tt>shrink_to_fit</tt> invalidates all the references, pointers, and iterators referring to the elements
in the sequence <ins>as well as the past-the-end iterator</ins>. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 23.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> as indicated:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Remarks:</i> Reallocation invalidates all the references, pointers, and iterators referring to the elements in
the sequence <ins>as well as the past-the-end iterator</ins>. If no reallocation happens, they remain valid. 
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2835" href="2835">2835.</a> LWG 2536 seems to misspecify <tt>&lt;tgmath.h&gt;</tt></h3>
<p><b>Section:</b> 26.9.6 <a href="https://timsong-cpp.github.io/cppwp/ctgmath.syn">[ctgmath.syn]</a>, D.4 <a href="https://timsong-cpp.github.io/cppwp/depr.c.headers">[depr.c.headers]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-11-29 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of LWG <a href="2536">2536</a> touches on the specification of C headers (of the form <tt>foo.h</tt>), but 
while it fixes the specification of <tt>complex.h</tt>, it fails to address the specification of <tt>tgmath.h</tt>.
<p/>
Just like <tt>complex.h</tt>, <tt>tgmath.h</tt> is <b>not</b> defined by C. Rather, <em>our</em> <tt>tgmath.h</tt> 
behaves like <tt>&lt;ctgmath&gt;</tt>, which is specified in [ctgmath.syn].
<p/>
Suggested resolution:
<p/>
Amend [depr.c.headers] p3 as follows:
</p>
<blockquote>
<p>
3. The header <tt>&lt;complex.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ccomplex&gt;</tt>. 
<ins>The header <tt>&lt;tgmath.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ctgmath&gt;</tt>.</ins>
<p/>
4. Every other C header [&hellip;]
</p>
</blockquote>
<p>
See also LWG <a href="2828">2828</a>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.
</p>
<ol>
<li><p>Edit D.4 <a href="https://timsong-cpp.github.io/cppwp/depr.c.headers">[depr.c.headers]</a> as indicated:</p>
<blockquote>
<p>
[&hellip;]
<p/>
-2- The use of any of the C++ headers [&hellip;] is deprecated.
<p/>
-3- The header <tt>&lt;complex.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ccomplex&gt;</tt>.
<ins>The header <tt>&lt;tgmath.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ctgmath&gt;</tt>.</ins>
<p/>
-4- Every other C header, [&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2837" href="2837">2837.</a> <tt>gcd</tt> and <tt>lcm</tt> should support a wider range of input values</h3>
<p><b>Section:</b> 26.8.13 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.gcd">[numeric.ops.gcd]</a>, 26.8.14 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.lcm">[numeric.ops.lcm]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-12-16 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.ops.gcd">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.gcd">[numeric.ops.gcd]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>This is a duplicate of <a href="2792">2792</a>, which addressed LFTS 2.</p>

<p>By the current definition, <tt>gcd((int64_t)1234, (int32_t)-2147483648)</tt> is 
ill-formed (because <tt>2147483648</tt> is not representable as a value of <tt>int32_t</tt>.)
We want to change this case to be well-formed. As long as both <tt>|m|</tt> and <tt>|n|</tt> 
are representable as values of the common type, absolute values can 
be calculate <tt>d</tt> without causing unspecified behavior, by converting <tt>m</tt> and <tt>n</tt> 
to the common type before taking the negation.
<p/>
Suggested resolution:
</p>
<blockquote><p>
<del><tt>|m|</tt> shall be representable as a value of type <tt>M</tt> and <tt>|n|</tt> shall 
be representable as a value of type <tt>N</tt></del><ins><tt>|m|</tt> and <tt>|n|</tt> shall be 
representable as a value of <tt>common_type_t&lt;M, N&gt;</tt></ins>.
</p></blockquote>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4604">N4604</a>.</p>

<ol>
<li><p>Edit 26.8.13 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.gcd">[numeric.ops.gcd]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; gcd(M m, N n);
</pre>
<blockquote>
<p>
-2- <i>Requires:</i> <del><tt>|m|</tt> shall be representable as a value of type <tt>M</tt> and <tt>|n|</tt> shall 
be representable as a value of type <tt>N</tt></del><ins><tt>|m|</tt> and <tt>|n|</tt> shall be representable as 
a value of <tt>common_type_t&lt;M, N&gt;</tt></ins>. [<i>Note:</i> These requirements ensure, for example, that 
<tt>gcd(m, m) = |m|</tt> is representable as a value of type <tt>M</tt>. &mdash; <i>end note</i>] 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 26.8.14 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.lcm">[numeric.ops.lcm]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; lcm(M m, N n);
</pre>
<blockquote>
<p>
-2- <i>Requires:</i> <del><tt>|m|</tt> shall be representable as a value of type <tt>M</tt> and <tt>|n|</tt> shall 
be representable as a value of type <tt>N</tt></del><ins><tt>|m|</tt> and <tt>|n|</tt> shall be representable as 
a value of <tt>common_type_t&lt;M, N&gt;</tt></ins>. The least common multiple of <tt>|m|</tt> and <tt>|n|</tt> shall 
be representable as a value of type <tt>common_type_t&lt;M, N&gt;</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2838" href="2838">2838.</a> <tt>is_literal_type</tt> specification needs a little cleanup</h3>
<p><b>Section:</b> D.11 <a href="https://timsong-cpp.github.io/cppwp/depr.meta.types">[depr.meta.types]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-09 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
D.11 <a href="https://timsong-cpp.github.io/cppwp/depr.meta.types">[depr.meta.types]</a>/3 currently reads:
</p>
<blockquote><p>
<i>Effects:</i> <tt>is_literal_type</tt> has a base-characteristic of <tt>true_type</tt> if <tt>T</tt> is a literal 
type ([basic.types]), and a base-characteristic of <tt>false_type</tt> otherwise.
</p></blockquote>
<p>
First, this doesn't seem like an <i>Effects</i> clause. Second, this wording fails to say that <tt>is_literal_type</tt> 
is an <tt>UnaryTypeTrait</tt>, and misspells <tt>BaseCharacteristic</tt> &mdash; which is only defined for 
<tt>UnaryTypeTraits</tt> and <tt>BinaryTypeTraits</tt>. Third, moving this to Annex D means that the general prohibition 
against specializing type traits in [meta.type.synop]/1 no longer applies, which is presumably unintended.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit D.11 <a href="https://timsong-cpp.github.io/cppwp/depr.meta.types">[depr.meta.types]</a> as indicated:</p>
<blockquote>
<p>
The header <tt>&lt;type_traits&gt;</tt> has the following addition:
</p>
<blockquote>
<pre>
namespace std {
  template &lt;class T&gt; struct is_literal_type;
  
  template &lt;class T&gt; constexpr bool is_literal_type_v = is_literal_type&lt;T&gt;::value;
}
</pre>
</blockquote>
<p>
-2- <i>Requires:</i> <tt>remove_all_extents_t&lt;T&gt;</tt> shall be a complete type or (possibly <i>cv</i>-qualified) <tt>void</tt>.
<p/>
-3- <del><i>Effects:</i> <tt>is_literal_type</tt> has a base-characteristic of <tt>true_type</tt> if <tt>T</tt> is a literal type (3.9), 
and a basecharacteristic of <tt>false_type</tt> otherwise</del><ins><tt>is_literal_type&lt;T&gt;</tt> is a 
<tt>UnaryTypeTrait</tt> (20.15.1 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) with a <tt>BaseCharacteristic</tt> of <tt>true_type</tt> if <tt>T</tt> 
is a literal type (3.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>), and <tt>false_type</tt> otherwise</ins>.
<p/>
<ins>-?- The behavior of a program that adds specializations for <tt>is_literal_type</tt> or <tt>is_literal_type_v</tt> is 
undefined.</ins>
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2842" href="2842">2842.</a> <tt>in_place_t</tt> check for <tt>optional::optional(U&amp;&amp;)</tt> should decay <tt>U</tt></h3>
<p><b>Section:</b> 20.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-13 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.ctor">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.ctor">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As <tt>in_place_t</tt> is a normal tag type again, we need to decay <tt>U</tt> before doing the <tt>is_same_v</tt> check.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 20.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class U = T&gt;
  <i>EXPLICIT</i> constexpr optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-22- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor. This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same_v&lt;<ins>decay_t&lt;</ins>U<ins>&gt;</ins>, 
in_place_t&gt;</tt> is <tt>false</tt>, and <tt>is_same_v&lt;optional&lt;T&gt;, decay_t&lt;U&gt;&gt;</tt> is <tt>false</tt>. 
The constructor is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2850" href="2850">2850.</a> <tt>std::function</tt> move constructor does unnecessary work</h3>
<p><b>Section:</b> 20.14.13.2.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2016-12-15 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func.con">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.con">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider [func.wrap.func.con]/p5:
</p>
<blockquote><pre>
function(function&amp;&amp; f);
</pre>
<blockquote>
<p>
<i>Effects:</i> If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, move constructs the target of <tt>f</tt> into the target 
of <tt>*this</tt>, leaving <tt>f</tt> in a valid state with an unspecified value.
</p>
</blockquote>
</blockquote>
<p>
By my reading, this wording requires the move constructor of <tt>std::function</tt> to construct an entirely new target object. 
This is silly: in cases where the target is held in separately allocated memory (i.e. where the target doesn't fit in 
<tt>std::function</tt>'s internal buffer, if any), <tt>std::function</tt>'s move constructor can be implemented by simply 
transferring ownership of the existing target object (which is a simple pointer assignment), so this requirement forces an 
unnecessary constructor invocation and probably an unnecessary allocation (the latter can be avoided with something like 
double-buffering, but ew). Fixing this would technically be a visible change, but I have a hard time imagining reasonable 
code that would be broken by it, especially since both libstdc++ and libc++ already do the sensible thing, constructing a 
new target only if the target is held in an internal buffer, and otherwise assigning pointers.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 20.14.13.2.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>/5 as indicated:</p>

<blockquote class="note">
<p>
<i>Drafting note:</i> The "equivalent to ... before the construction" wording is based on the wording for <tt>MoveConstructible</tt>.
</p>
</blockquote>

<blockquote>
<pre>
function(function&amp;&amp; f);
</pre>
<blockquote>
<p>
-5- <i><del>Effects</del><ins>Postconditions</ins>:</i> If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, <del>move 
constructs the target of <tt>f</tt> into the target of <tt>*this</tt>, leaving <tt>f</tt></del><ins>the target of <tt>*this</tt> 
is equivalent to the target of <tt>f</tt> before the construction, and <tt>f</tt> is</ins> in a valid state with an 
unspecified value.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2853" href="2853">2853.</a> Possible inconsistency in specification of <tt>erase</tt> in [vector.modifiers]</h3>
<p><b>Section:</b> 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Gerard Stone <b>Opened:</b> 2017-01-16 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.modifiers">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Table 87 (Sequence container requirements) <tt>erase(q)</tt> and <tt>erase(q1, q2)</tt> functions have the following requirements: 
</p>
<blockquote>
<p>
For <tt>vector</tt> and <tt>deque</tt>, <tt>T</tt> shall be <tt>MoveAssignable</tt>.
</p>
</blockquote>
<p>
On the other hand, section [vector.modifiers] has the following specification for erase functions (emphasis mine):
</p> 
<blockquote>
<p>
<i>Throws:</i> Nothing unless an exception is thrown by the <b>copy constructor</b>, <b>move constructor</b>, assignment
operator, or move assignment operator of <tt>T</tt>.
</p>
</blockquote>
<p>
Note that Table 87 requires <tt>T</tt> to be only <tt>MoveAssignable</tt>, it says nothing about <tt>T</tt> 
being copy- or move-constructible. It also says nothing about <tt>T</tt> being <tt>CopyInsertable</tt> and <tt>MoveInsertable</tt>, 
so why is this even there? The only reason might be so that vector could shrink, but in this case <tt>T</tt> should be required 
to be <tt>MoveInsertable</tt> or <tt>CopyInsertable</tt> into <tt>vector</tt>.
<p/>
On the other hand, we expect that vector will neither allocate, nor deallocate any memory during this operation, because in 
<i>Effects</i> it is specified that iterators/references shall be invalidated at or after the point of the erase.
<p/>
So to avoid any confusion, the proposed resolution is to remove mentions of <tt>T</tt>'s copy/move constructors 
from [vector.modifiers] paragraph 5.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> p5 as indicated:</p>
<blockquote>
<pre>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_back();
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Invalidates iterators and references at or after the point of the erase.
<p/>
-4- <i>Complexity:</i> The destructor of <tt>T</tt> is called the number of times equal to the number of the elements
erased, but the assignment operator of <tt>T</tt> is called the number of times equal to the number of elements
in the vector after the erased elements.
<p/>
-5- <i>Throws:</i> Nothing unless an exception is thrown by the <del>copy constructor, move constructor,</del> assignment
operator<del>,</del> or move assignment operator of <tt>T</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2855" href="2855">2855.</a> <tt>std::throw_with_nested("string_literal")</tt></h3>
<p><b>Section:</b> 18.8.7 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-01-17 <b>Last modified:</b> 2017-02-02 00:02:18 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#except.nested">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#except.nested">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[except.nested] says:
</p>
<blockquote>
<pre>
template &lt;class T&gt; [[noreturn]] void throw_with_nested(T&amp;&amp; t);
</pre>
<blockquote>
<p>
Let <tt>U</tt> be <tt>remove_reference_t&lt;T&gt;</tt>.
<p/>
<i>Requires:</i> <tt>U</tt> shall be <tt>CopyConstructible</tt>.
</p>
</blockquote>
</blockquote>
<p>
This forbids <tt>std::throw_with_nested("string literal")</tt> because <tt>T</tt> gets deduced as <tt>const char(&amp;)[15]</tt> 
and so <tt>U</tt> is <tt>const char[15]</tt> which is not <tt>CopyConstructible</tt>.
<p/>
A throw expression decays an array argument to a pointer (5.17 <a href="https://timsong-cpp.github.io/cppwp/expr.throw">[expr.throw]</a> p2) and so works fine with string literals. 
GCC's <tt>throw_with_nested</tt> also worked fine until I added a <tt>static_assert</tt> to enforce the 
<tt>CopyConstructible</tt> requirement.
<p/>
The same problem exists when throwing a function type, which should also decay:
</p>
<blockquote>
<pre>
#include &lt;exception&gt;

void f() { }

int main() {
  std::throw_with_nested(f);
}
</pre>
</blockquote>
<p>
(Note: LWG <a href="1370">1370</a> added the <tt>remove_reference</tt>, which was a step in the right direction but not far enough.)
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 0</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 18.8.7 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T&gt; [[noreturn]] void throw_with_nested(T&amp;&amp; t);
</pre>
<blockquote>
<p>
-6- Let <tt>U</tt> be <tt><del>remove_reference</del><ins>decay</ins>_t&lt;T&gt;</tt>.
<p/>
-7- <i>Requires:</i> <tt>U</tt> shall be <tt>CopyConstructible</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
