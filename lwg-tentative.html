<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p><p>Revised 2021-02-01 at 20:58:16 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="3052" href="3052">3052.</a> <tt>visit</tt> is underconstrained</h3>
<p><b>Section:</b> 20.7.7 <a href="https://timsong-cpp.github.io/cppwp/variant.visit">[variant.visit]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-01-23 <b>Last modified:</b> 2020-11-18 12:14:22 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.visit">issues</a> in [variant.visit].</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::visit</tt> accepts a parameter pack of forwarding references named
<tt>vars</tt> whose types are the parameter pack <tt>Variants</tt>. Despite that:
<ol>
<li>the names of both packs are variants of "variant",</li>
<li>para 1 passes the types in <tt>Variants</tt> (modified) to <tt>variant_size_v</tt>,</li>
<li>para 3 uses the expression <tt>vars<sub><i>i</i></sub>.index()</tt>,</li>
<li>para 4 says "...if any <tt>variant</tt> in <tt>vars</tt> is <tt>valueless_by_exception</tt>,
and</li>
<li>para 5 mentions "..the number of alternative types of <tt>Variants<sub>0</sub></tt>"</li>
</ol>
the <i>Requires</i> element imposes no explicit requirements on the types in <tt>Variants</tt>.
Notably, the <tt>Variants</tt> are not required to be <tt>variant</tt>s. This lack of constraints
appears to be simply an oversight.
</p>

<p><i>[2018-01-24, Daniel comments]</i></p>

<p>
This issue should be reviewed in common with LWG <a href="2970">2970</a>.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 2; status to LEWG</p>

<p><i>[2020-11-18; this will be resolved by <a href="https://wg21.link/p2162">P2162</a>.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.</p>

<ol>
<li><p>Modify 20.7.7 <a href="https://timsong-cpp.github.io/cppwp/variant.visit">[variant.visit]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Visitor, class... Variants&gt;
  constexpr <i>see below</i> visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);
</pre>
<blockquote>
<p>[&hellip;]</p>
<p>
-4- <i>Throws:</i> <tt>bad_variant_access</tt> if <del>any <tt>variant</tt> in <tt>vars</tt> is
<tt>valueless_by_exception()</tt></del><ins><tt>(vars.valueless_by_exception() || ...)</tt> is
<tt>true</tt></ins>.
</p>
<p>-5- <i>Complexity:</i> [&hellip;]</p>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>remove_cvref_t&lt;Variants<sub><i>i</i></sub>&gt;</tt> is a specialization of <tt>variant</tt>
for all <tt>0 &lt;= i &lt; n</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3391" href="3391">3391.</a> Problems with <tt>counted_iterator/move_iterator::base() const &amp;</tt></h3>
<p><b>Section:</b> 23.5.3 <a href="https://timsong-cpp.github.io/cppwp/move.iterators">[move.iterators]</a>, 23.5.6 <a href="https://timsong-cpp.github.io/cppwp/iterators.counted">[iterators.counted]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Patrick Palka <b>Opened:</b> 2020-02-07 <b>Last modified:</b> 2021-01-28 10:06:14 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#move.iterators">issues</a> in [move.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not possible to use the <tt>const &amp;</tt> overloads of <tt>counted_iterator::base()</tt> or
<tt>move_iterator::base()</tt> to get at an underlying move-only iterator in order to compare it 
against a sentinel.
<p/>
More concretely, assuming issue LWG <a href="3389">3389</a> is fixed, this means that
</p>
<blockquote><pre>
auto v = r | views::take(5);
ranges::begin(v) == ranges::end(v);
</pre></blockquote>
<p>
is invalid when <tt>r</tt> is a <tt>view</tt> whose <tt>begin()</tt> is a move-only input iterator.
The code is invalid because <tt>ranges::take_view::sentinel::operator==()</tt> must call 
<tt>counted_iterator::base()</tt> to compare the underlying iterator against its sentinel, and 
therefore this <tt>operator==()</tt> requires that the underlying iterator is <tt>copy_constructible</tt>.
<p/>
Suggested resolution:
<p/>
Make these <tt>const &amp; base()</tt> overloads return the underlying iterator by <tt>const</tt> reference.  
Remove the <tt>copy_constructible</tt> constraint on these overloads. Perhaps the <tt>base()</tt> 
overloads for the iterator wrappers in 24.7 <a href="https://timsong-cpp.github.io/cppwp/range.adaptors">[range.adaptors]</a> could use the same treatment?
</p>

<p><i>[2020-02 Prioritized as P2 Monday morning in Prague]</i></p>


<p><i>[2021-01-28; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/move.iterator">[move.iterator]</a>, class template <tt>move_iterator</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Iterator&gt;
  class move_iterator {
  public:
    using iterator_type = Iterator;
    [&hellip;]
    constexpr <ins>const</ins> iterator_type<ins>&amp;</ins> base() const &amp;;
    constexpr iterator_type base() &amp;&amp;;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/move.iter.op.conv">[move.iter.op.conv]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <ins>const</ins> Iterator<ins>&amp;</ins> base() const &amp;;
</pre>
<blockquote>
<p>
<del>-1- <i>Constraints:</i> <tt>Iterator</tt> satisfies <tt>copy_constructible</tt>.</del>
<p/>
<del>-2- <i>Preconditions:</i> <tt>Iterator</tt> models <tt>copy_constructible</tt>.</del>
<p/>
-3- <i>Returns:</i> <tt>current</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/counted.iterator">[counted.iterator]</a>, class template <tt>counted_iterator</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;input_or_output_iterator I&gt;
  class counted_iterator {
  public:
    using iterator_type = I;
    [&hellip;]
    constexpr <ins>const</ins> I<ins>&amp;</ins> base() const &amp; <del>requires copy_constructible&lt;I&gt;</del>;
    constexpr I base() &amp;&amp;;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.6.3 <a href="https://timsong-cpp.github.io/cppwp/counted.iter.access">[counted.iter.access]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <ins>const</ins> I<ins>&amp;</ins> base() const &amp; <del>requires copy_constructible&lt;I&gt;</del>;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to: <tt>return current;</tt>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3433" href="3433">3433.</a> <tt>subrange::advance(n)</tt> has UB when <tt>n &lt; 0</tt></h3>
<p><b>Section:</b> 24.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.access">[range.subrange.access]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-04-21 <b>Last modified:</b> 2021-01-15 22:03:31 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>subrange::advance(n)</tt> is specified to call <tt>ranges::advance(<i>begin_</i>, n, <i>end_</i>)</tt> 
in both <tt><i>StoreSize</i></tt> and <tt>!<i>StoreSize</i></tt> cases (24.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.access">[range.subrange.access]</a>/9). 
Unfortunately, <tt>ranges::advance(<i>begin_</i>, n, <i>end_</i>)</tt> has undefined behavior when 
<tt>n &lt; 0</tt> unless <tt>[<i>end_</i>, <i>begin_</i>)</tt> denotes a valid range 
(23.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iter.op.advance">[range.iter.op.advance]</a>/5). This would all be perfectly fine &mdash; the UB is exposed to 
the caller via effects-equivalent-to &mdash; were it not the design intent that <tt>subrange::advance(-n)</tt> 
be usable to reverse the effects of <tt>subrange::advance(n)</tt> when the <tt>subrange</tt> has a 
bidirectional iterator type. That is, however, clearly the design intent: <tt>subrange::prev()</tt>, 
for example, is equivalent to <tt>subrange::advance(-1)</tt>.
</p>

<p><i>[2020-05-11; Reflector prioritization]</i></p>

<p>
Set priority to 2 after reflector discussions.
</p>

<p><i>[2021-01-15; Issue processing telecon]</i></p>

<p>
Set status to Tentatively Ready after discussion and poll.
<table>
<tr><th>F</th><th>A</th><th>N</th></tr>
<tr><td>7</td><td>0</td><td>3</td></tr>
</table>
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 24.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.access">[range.subrange.access]</a> as indicated:</p>

<blockquote>
<pre>
constexpr subrange&amp; advance(iter_difference_t&lt;I&gt; n);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> Equivalent to:
<ol style="list-style-type: none">
<li><p><del>(9.1) &mdash; If <tt><i>StoreSize</i></tt> is <tt>true</tt>,</del></p>
<blockquote><pre>
<del>auto d = n - ranges::advance(<i>begin_</i>, n, <i>end_</i>);
if (d &gt;= 0)
  <i>size_</i> -= <i>to-unsigned-like</i>(d);
else
  <i>size_</i> += <i>to-unsigned-like</i>(-d);
return *this;</del>
</pre></blockquote>
</li>
<li><p><del>(9.2) &mdash; Otherwise,</del></p>
<blockquote><pre>
<del>ranges::advance(<i>begin_</i>, n, <i>end_</i>);
return *this;</del>
</pre></blockquote>
</li>
</ol>
<blockquote><pre>
<ins>if constexpr (bidirectional_iterator&lt;I&gt;) {
  if (n &lt; 0) {
    ranges::advance(<i>begin_</i>, n);
    if constexpr (<i>StoreSize</i>)
      <i>size_</i> += <i>to-unsigned-like</i>(-n);
    return *this;
  }
}

auto d = n - ranges::advance(<i>begin_</i>, n, <i>end_</i>);
if constexpr (<i>StoreSize</i>)
  <i>size_</i> -= <i>to-unsigned-like</i>(d);
return *this;</ins>
</pre></blockquote>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3490" href="3490">3490.</a> <tt>ranges::drop_while_view::begin()</tt> is missing a precondition</h3>
<p><b>Section:</b> 24.7.10.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while.view">[range.drop.while.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Michael Schellenberger Costa <b>Opened:</b> 2020-10-13 <b>Last modified:</b> 2020-11-07 19:23:15 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.drop.while.view">issues</a> in [range.drop.while.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Similar to <tt>ranges::filter_view</tt> 24.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.filter.view">[range.filter.view]</a> p3, <tt>ranges::drop_while_view</tt> 
should have a precondition on its <tt>begin()</tt> method that the predicate is set.
<p/>
I propose to add as 24.7.10.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while.view">[range.drop.while.view]</a> p3:
</p>
<blockquote><pre>
<ins><i>Preconditions:</i> <tt><i>pred_</i>.has_value()</tt>.</ins>  
</pre></blockquote>


<p><i>[2020-11-07; Reflector prioritization]</i></p>

<p>
Set priority to 0 and status to Tentatively Ready after six votes in favour during reflector discussions.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4868">N4868</a>. 
</p>

<ol>
<li>
<p>
Modify 24.7.10.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while.view">[range.drop.while.view]</a> as indicated:
</p>

<blockquote class="note">
<p>
Since we usually don't rely on implicit <tt>bool</tt> conversion in <i>Preconditions:</i> elements 
an explicit "is <tt>true</tt>" has been added. Editorial fixes of the referenced paragraph
24.7.10.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while.view">[range.drop.while.view]</a> p3 and similar places have been requested separately.
</p>
</blockquote>

<blockquote>
<pre>
constexpr auto begin();
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <tt><i>pred_</i>.has_value()</tt> is <tt>true</tt>.</ins>
<p/>
-3- <i>Returns:</i> <tt>ranges::find_if_not(<i>base_</i>, cref(*<i>pred_</i>))</tt>.
<p/>
-4- [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3492" href="3492">3492.</a> Minimal improvements to <tt>elements_view::<i>iterator</i></tt></h3>
<p><b>Section:</b> 24.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Michael Schellenberger Costa <b>Opened:</b> 2020-10-28 <b>Last modified:</b> 2020-11-15 13:41:13 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.elements.iterator">active issues</a> in [range.elements.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.elements.iterator">issues</a> in [range.elements.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During code review of <tt>elements_view</tt> for MSVC-STL we found two issues that should be easily addressed:
</p>
<ol>
<li>
<p><tt>elements_view::<i>iterator</i></tt> constraints both <tt>operator++(int)</tt> member functions</p>
<blockquote><pre>
constexpr void operator++(int) requires (!forward_range&lt;<i>Base</i>&gt;);
constexpr <i>iterator</i> operator++(int) requires forward_range&lt;<i>Base</i>&gt;;  
</pre></blockquote>
<p>
However, given that a constrained method would be preferred we only need to constrain one of those. 
The proposal would be to remove the constraint from the <tt>void</tt> returning overload and change 
the declaration to
</p>
<blockquote><pre>
constexpr void operator++(int);
constexpr <i>iterator</i> operator++(int) requires forward_range&lt;<i>Base</i>&gt;;  
</pre></blockquote>
</li>
<li>
<p><tt>elements_view::<i>iterator</i> operator-</tt> is constrained as follows:</p>
<blockquote><pre>
friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
  requires random_access_range&lt;<i>Base</i>&gt;; 
</pre></blockquote>
<p>
However, that requires its base to have <tt>operator-</tt> defined. We should change the constraint to 
<tt>sized_sentinel_for&lt;iterator_t&lt;<i>Base</i>&gt;, iterator_t&lt;Base&gt;&gt;</tt>:
</p>
<blockquote><pre>
friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
  requires sized_sentinel_for&lt;iterator_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>Base</i>&gt;&gt;;
</pre></blockquote>
</li>
</ol>

<p><i>[2020-11-01; Daniel comments]</i></p>

<p>
Bullet (2) of the discussion has already been resolved by LWG <a href="3483">3483</a>, it has therefore
been omitted from the proposed wording below.
</p>

<p><i>[2020-11-15; Reflector prioritization]</i></p>

<p>
Set priority to 0 and status to Tentatively Ready after five votes in favour during reflector discussions.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4868">N4868</a>. 
</p>

<blockquote class="note">
<p>
This wording intentionally only touches <tt>operator++(int)</tt> and <em>not</em> <tt>operator-</tt>,
see the 2020-11-01 comment for the reason why.
</p>
</blockquote>

<ol>
<li>
<p>
Modify 24.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a>, class template <tt>elements_view::<i>iterator</i></tt> synopsis, 
as indicated:
</p>

<blockquote>
<blockquote>
<pre>
[&hellip;]
constexpr <i>iterator</i>&amp; operator++();
constexpr void operator++(int) <del>requires (!forward_range&lt;<i>Base</i>&gt;)</del>;
constexpr <i>iterator</i> operator++(int) requires forward_range&lt;<i>Base</i>&gt;;
[&hellip;]
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr void operator++(int) <del>requires (!forward_range&lt;<i>Base</i>&gt;)</del>;
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Equivalent to: <tt>++<i>current_</i></tt>.
</p>
</blockquote>
<pre>
constexpr <i>iterator</i> operator++(int) requires forward_range&lt;<i>Base</i>&gt;;
</pre>
[&hellip;]
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3494" href="3494">3494.</a> Allow ranges to be conditionally borrowed</h3>
<p><b>Section:</b> 24.7.15 <a href="https://timsong-cpp.github.io/cppwp/range.reverse">[range.reverse]</a>, 24.7.7 <a href="https://timsong-cpp.github.io/cppwp/range.take">[range.take]</a>, 24.7.9 <a href="https://timsong-cpp.github.io/cppwp/range.drop">[range.drop]</a>, 24.7.10 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while">[range.drop.while]</a>, 24.7.14 <a href="https://timsong-cpp.github.io/cppwp/range.common">[range.common]</a>, 24.7.10 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while">[range.drop.while]</a>, 24.7.16 <a href="https://timsong-cpp.github.io/cppwp/range.elements">[range.elements]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2020-11-01 <b>Last modified:</b> 2021-01-15 22:07:14 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following approach to trimming a <tt>std::string</tt>:
</p>
<blockquote><pre>
auto trim(std::string const&amp; s) {
  auto isalpha = [](unsigned char c){ return std::isalpha(c); };
  auto b = ranges::find_if(s, isalpha);
  auto e = ranges::find_if(s | views::reverse, isalpha).base();
  return subrange(b, e);
}
</pre></blockquote>
<p>
This is a fairly nice and, importantly, safe way to implement <tt>trim</tt>. The iterators <tt>b</tt> 
and <tt>e</tt> returned from <tt>find_if</tt> will not dangle, since they point into the <tt>string s</tt> 
whose lifetime outlives the function. But the status quo in C++20 is that <tt>s | views::reverse</tt> 
is not a borrowed range (because <tt>reverse_view&lt;V&gt;</tt> is never a borrowed range for any <tt>V</tt>). 
As a result, <tt>find_if(s | views::reverse, isalpha)</tt> returns <em>dangling</em> rather than 
a real iterator.
<p/>
Instead, you have to write it this way, introducing a new named variable for the reversed view:
</p>
<blockquote><pre>
auto trim(std::string const&amp; s) {
  auto isalpha = [](unsigned char c){ return std::isalpha(c); };
  auto b = ranges::find_if(s, isalpha);
  auto reversed = s | views::reverse;
  auto e = ranges::find_if(reversed, isalpha).base();
  return subrange(b, e);
}
</pre></blockquote>
<p>
But borrowed range can be a transitive property. <tt>s</tt> itself is a borrowed range (as all 
lvalue references are) so <tt>s | views::reverse</tt> could be made to be too, which would allow 
the first example above to work with really no downside. We know such an iterator would not dangle, 
we just need to teach the library this.
<p/>
<a href="https://wg21.link/p2017R1">P2017R1</a> resolves this by making <tt>reverse_view&lt;V&gt;</tt> 
a borrowed range when <tt>V</tt> is a borrowed range (and likewise several other range adapters).
</p>


<p><b>Rationale:</b></p>
Resolved by <a href="https://wg21.link/p2017R1">P2017R1</a>.


<p><i>[2021-01-15; Telecon prioritization]</i></p>

<p>
Set status to Tentatively Ready after five P0 votes in reflector discussion.
</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3500" href="3500">3500.</a> <tt>join_view::iterator::operator-&gt;()</tt> is bogus</h3>
<p><b>Section:</b> 24.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Michael Schellenberger Costa <b>Opened:</b> 2020-11-15 <b>Last modified:</b> 2020-11-21 13:58:36 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.iterator">active issues</a> in [range.join.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.iterator">issues</a> in [range.join.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There seems to be a copy &amp; paste error in the <tt>join_view::iterator::operator-&gt;()</tt> 
specification. According to 24.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a> p8 it is specified as:
</p>
<blockquote>
<pre>
constexpr iterator_t&lt;<i>Base</i>&gt; operator-&gt;() const
  requires <i>has-arrow</i>&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp; copyable&lt;iterator_t&lt;Base&gt;&gt;;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to <tt>return <i>inner_</i>;</tt>
</p>
</blockquote>
</blockquote>
<p>
Now <tt><i>inner_</i></tt> is of type <tt>iterator_t&lt;range_reference_t&lt;Base&gt;&gt;</tt>. So it 
is unclear how that should be converted to <tt>iterator_t&lt;<i>Base</i>&gt;</tt>, or why the 
constraints concern the outer iterator type <tt>iterator_t&lt;<i>Base</i>&gt;</tt>. On the other hand 
returning <tt><i>outer_</i></tt> would not make any sense here.
<p/>
As far as I can tell we should replace <tt>iterator_t&lt;<i>Base</i>&gt;</tt> with 
<tt>iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</tt> so that the new specification would 
read
</p>
<blockquote>
<pre>
constexpr iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt; operator-&gt;() const
 requires <i>has-arrow</i>&lt;iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;&gt; 
   &amp;&amp; copyable&lt;iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;&gt;;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to <tt>return <i>inner_</i>;</tt>
</p>
</blockquote>
</blockquote>
<p>
Generally it would help readability of the specification a lot if we would introduce some exposition only aliases:
</p>
<blockquote>
<pre>
using OuterIter = iterator_t&lt;<i>Base</i>&gt;; <i>//exposition-only</i>
using InnerIter = iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt; <i>//exposition-only</i>
</pre>
</blockquote>
<p>
and use them throughout <tt>join_view::<i>iterator</i></tt>.
</p>

<p><i>[2020-11-21; Reflector prioritization]</i></p>

<p>
Set priority to 0 and status to Tentatively Ready after six votes in favour during reflector discussions.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4868">N4868</a>. 
</p>

<ol>
<li>
<p>
Modify 24.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a>, class template <tt>join_view::<i>iterator</i></tt> synopsis, 
as indicated:
</p>

<blockquote>
<blockquote>
<pre>
template&lt;input_range V&gt;
  requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt; &amp;&amp;
           (is_reference_v&lt;range_reference_t&lt;V&gt;&gt; ||
            view&lt;range_value_t&lt;V&gt;&gt;)
struct join_view&lt;V&gt;::<i>iterator</i> {
private:
  using <i>Parent</i> = <i>// exposition only</i>
    conditional_t&lt;Const, const join_view, join_view&gt;;
  using Base = conditional_t&lt;Const, const V, V&gt;; <i>// exposition only</i>
  <ins>using <i>OuterIter</i> = iterator_t&lt;<i>Base</i>&gt;; <i>//exposition-only</i>
  using <i>InnerIter</i> = iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt; <i>//exposition-only</i></ins>
  static constexpr bool <i>ref-is-glvalue</i> = <i>// exposition only</i>
    is_reference_v&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;;
  <ins><i>OuterIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del> <i>outer_</i> = <ins><i>OuterIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del>(); <i>// exposition only</i>
  <ins><i>InnerIter</i></ins><del>iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del> <i>inner_</i> = <i>// exposition only</i>
    <ins><i>InnerIter</i></ins><del>iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del>();
  <i>Parent</i>* <i>parent_</i> = nullptr; <i>// exposition only</i>
  constexpr void <i>satisfy</i>(); <i>// exposition only</i>
public:
  [&hellip;]
  <i>iterator</i>() = default;
  constexpr <i>iterator</i>(<i>Parent</i>&amp; parent, <ins><i>OuterIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del> outer);
  constexpr <i>iterator</i>(<i>iterator</i>&lt;!Const&gt; i)
    requires Const &amp;&amp;
             convertible_to&lt;iterator_t&lt;V&gt;, <ins><i>OuterIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del>&gt; &amp;&amp;
             convertible_to&lt;iterator_t&lt;<i>InnerRng</i>&gt;,
                            <ins><i>InnerIter</i></ins><del>iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del>&gt;;

  constexpr decltype(auto) operator*() const { return *<i>inner_</i>; }
  
  constexpr <ins><i>InnerIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del> operator-&gt;() const
    requires <i>has-arrow</i>&lt;<ins><i>InnerIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del>&gt; 
      &amp;&amp; copyable&lt;<ins><i>InnerIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del>&gt;;
  
  constexpr <i>iterator</i>&amp; operator++();
  [&hellip;]
</pre>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
constexpr void <i>satisfy</i>(); <i>// exposition only</i>
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
[&hellip;]
if constexpr (<i>ref-is-glvalue</i>)
  <i>inner_</i> = <ins><i>InnerIter</i></ins><del>iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del>();
</pre></blockquote>
</blockquote>
<pre>
constexpr <i>iterator</i>(<i>Parent</i>&amp; parent, <ins><i>OuterIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del> outer);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr <i>iterator</i>(<i>iterator</i>&lt;!Const&gt; i)
  requires Const &amp;&amp;
           convertible_to&lt;iterator_t&lt;V&gt;, <ins><i>OuterIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del>&gt; &amp;&amp;
           convertible_to&lt;iterator_t&lt;<i>InnerRng</i>&gt;,
                          <ins><i>InnerIter</i></ins><del>iterator_t&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del>&gt;;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr <ins><i>InnerIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del> operator-&gt;() const
  requires <i>has-arrow</i>&lt;<ins><i>InnerIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del>&gt; 
    &amp;&amp; copyable&lt;<ins><i>InnerIter</i></ins><del>iterator_t&lt;<i>Base</i>&gt;</del>&gt;;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to <tt>return <i>inner_</i>;</tt>
</p>
</blockquote>
</blockquote>
</li>
</ol>





</body>
</html>
