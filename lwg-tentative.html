<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2017-07-13 at 17:00:16 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="760" href="760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="767">767</a> and to <a href="2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="2164">2164</a> addresses this issue and therefore considers <a href="760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 26.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="2337" href="2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a>/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 23.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a>/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 23.11.1.2.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 23.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 23.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2692" href="2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 20.4.2.1.4 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2017-02-02 00:41:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2717" href="2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-06-05 16:20:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





<hr>
<h3><a name="2870" href="2870">2870.</a> Default value of parameter <tt>theta</tt> of <tt>polar</tt> should be dependent</h3>
<p><b>Section:</b> 29.5.7 <a href="https://timsong-cpp.github.io/cppwp/complex.value.ops">[complex.value.ops]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-06-27 20:22:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.value.ops">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/complex.value.ops">[complex.value.ops]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 25</b></p>

<p>Parameter <tt>theta</tt> of <tt>polar</tt> has the type of the 
template parameter. Therefore, it needs to change the default initial value 
to <tt>T()</tt>. The change of the declaration of this function in 
29.5.1 <a href="https://timsong-cpp.github.io/cppwp/complex.syn">[complex.syn]</a> is accompanied by this change.</p>

<p>
Proposed change:
</p>
<blockquote>
<pre>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = <del>0</del><ins>T()</ins>);
</pre>
</blockquote>

<p><i>[2017-02 pre-Kona]</i></p>

<p>
(twice)
</p>

<p><i>[
2017-06-27 Moved to Tentatively Ready after 7 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.</p>

<ol>
<li><p>Modify 29.5.1 <a href="https://timsong-cpp.github.io/cppwp/complex.syn">[complex.syn]</a>, header <tt>&lt;complex&gt;</tt> synopsis, as indicated:</p>

<blockquote><pre>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp;, const T&amp; = <del>0</del><ins>T()</ins>);
</pre></blockquote>
</li>

<li><p>Modify 29.5.7 <a href="https://timsong-cpp.github.io/cppwp/complex.value.ops">[complex.value.ops]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T&gt; complex&lt;T&gt; polar(const T&amp; rho, const T&amp; theta = <del>0</del><ins>T()</ins>);
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2886" href="2886">2886.</a> Keep the <tt>empty()</tt> functions in <tt>any</tt></h3>
<p><b>Section:</b> 23.8.3.4 <a href="https://timsong-cpp.github.io/cppwp/any.observers">[any.observers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-06-26 19:31:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 7</b>

<p>The proposal <a href="http://wg21.link/p0032">p0032</a> has multiple problems: 1) it turns member function <tt>.empty()</tt> 
into <tt>.has_value()</tt>, negating the logic. Refactoring e.g. existing uses of <tt>std::experimental::any</tt> to use 
<tt>std::any</tt> thus involve non-trivial refactorings that are error- prone and can't be done via simple search-and-replace 
if there are containers in the same source files for which <tt>.empty()</tt> is used (based on the implementation experience 
of making the change in libstdc++ and refactoring the testsuite). Whilst <tt>any</tt> is not a container, the library is failing 
to go towards a direction where there would be a generic way to query for emptiness. 2) The use of function references for 
tag types makes the interface hard to use. The tag types do not have value semantics like every other tag type has, the tag 
types are hard to construct, and present surprises for certain kinds of overload sets. Furthermore, any attempts to decay the 
tag types produces a really surprising effect &mdash; as opposed to what the other tag types do, which is that the result of 
decaying them is the tag type itself, decaying these new tag types results in a pointer to function.</p>

<p>Proposed change: Keep the <tt>.empty()</tt> functions (and introduce them to all the types that are supposed to have a 
homogeneous interface), and make the tag types be regular tag types that are not references to functions.</p>

<p><i>[2017-02-03, Marshall notes]</i></p>

<p><a href="http://wg21.link/p0504r0">P0504R0</a> (adopted in Issaquah) removed use of function references for tag types</p>

<p><i>[
2017-06-26 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2893" href="2893">2893.</a> Parsing Hexadecimally in P0067R4</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-06-26 19:31:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utilities">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 45</b>

<p>If <a href="http://wg21.link/p0067r4">P0067R4</a> is applied consider how to parse hexadecimally:</p>
<blockquote>
<p><tt>to_chars(beg, end, 42, 16);</tt> 16 for hex</p>
<p><tt>to_chars(beg, end, 4.2, true);</tt> true means hex</p>
<p><tt>to_chars(beg, end, 4.2, chars_format::hex);</tt></p>
<p><tt>to_chars(beg, end, 4.2, chars_format::hex, 2);</tt></p>
</blockquote>

<p>That is: We have 3 different formats to specify hex depending on value types and whether to use precision.
Which application programmer should remember this?</p>

<p>May be even worse (I am not sure):</p>
<blockquote><tt>to_chars(beg, end, 4.2, 16);</tt></blockquote>
<p>would silently convert 4.2 to 4 and</p>
<blockquote><tt>to_chars(beg, end, 4, chars_format::hex);</tt></blockquote>
<p>would silently convert 4 to 4.000000.</p>

<p>Proposed change: The various options should be harmonized, possibly by use of an extended enum approach, having the values:
dec, hex, scientific, fixed, general
with dec (new!) as default for integral values and general for floats</p>

<p><i>[2017-02-23, Jens Maurer comments]</i></p>

<p>
This issue is NAD; the facility was redesigned with these considerations
in mind before it went into the working draft.
</p>

<p><i>[
2017-06-26 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>







<hr>
<h3><a name="2901" href="2901">2901.</a> Variants cannot properly support allocators</h3>
<p><b>Section:</b> 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-06-29 16:47:13 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.variant">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.variant">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 113</b>

<p>Variants cannot properly support allocators, as any assignment of a subsequent value throws away the allocator used at 
construction. This is not an easy problem to solve, so <tt>variant</tt> would be better served dropping the illusion of 
allocator support for now, leaving open the possibility to provide proper support once the problems are fully understood.</p>

<p>Proposed change: Strike the 8 allocator aware constructor overloads from the class definition, and strike 
20.7.2.1 [variant.ctor] p34/35. Strike clause 20.7.12 [variant.traits]. Strike the specialization of 
<tt>uses_allocator</tt> for <tt>variant</tt> in the <tt>&lt;variant&gt;</tt> header synopsis, 20.7.1 [variant.general].</p>

<p><i>[2017-02-28, Kona, Casey provides wording]</i></p>


<p><i>[2017-06-29 Moved to Tentatively Ready after 7 positive votes on c++std-lib.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Change 23.7.2 <a href="https://timsong-cpp.github.io/cppwp/variant.syn">[variant.syn]</a>, header <tt>&lt;variant&gt;</tt>  synopsis, as follows:</p>

<blockquote><pre>
[&hellip;]
<del><i>// 23.7.13 <a href="https://timsong-cpp.github.io/cppwp/variant.traits">[variant.traits]</a>, allocator-related traits</i>
template &lt;class T, class Alloc&gt; struct uses_allocator;
template &lt;class... Types, class Alloc&gt; struct uses_allocator&lt;variant&lt;Types...&gt;, Alloc&gt;;</del>
</pre></blockquote>
</li>

<li><p>Change 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>, class template <tt>variant</tt>  synopsis, as follows:</p>

<blockquote><pre>
[&hellip;]
<del><i>// allocator-extended constructors</i>
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp;);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp;, const variant&amp;);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp;, variant&amp;&amp;);
template &lt;class Alloc, class T&gt;
  variant(allocator_arg_t, const Alloc&amp;, T&amp;&amp;);
template &lt;class Alloc, class T, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp;, in_place_type_t&lt;T&gt;, Args&amp;&amp;...);
template &lt;class Alloc, class T, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp;, in_place_type_t&lt;T&gt;,
          initializer_list&lt;U&gt;, Args&amp;&amp;...);
template &lt;class Alloc, size_t I, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp;, in_place_index_t&lt;I&gt;, Args&amp;&amp;...);
template &lt;class Alloc, size_t I, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp;, in_place_index_t&lt;I&gt;,
          initializer_list&lt;U&gt;, Args&amp;&amp;...);</del>
</pre></blockquote>
</li>

<li><p>Modify 23.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> as indicated:</p>
<blockquote><pre>
<del><i>// allocator-extended constructors</i>
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a, const variant&amp; v);
template &lt;class Alloc&gt;
  variant(allocator_arg_t, const Alloc&amp; a, variant&amp;&amp; v);
template &lt;class Alloc, class T&gt;
  variant(allocator_arg_t, const Alloc&amp; a, T&amp;&amp; t);
template &lt;class Alloc, class T, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
template &lt;class Alloc, class T, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_type_t&lt;T&gt;,
          initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
template &lt;class Alloc, size_t I, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);
template &lt;class Alloc, size_t I, class U, class... Args&gt;
  variant(allocator_arg_t, const Alloc&amp; a, in_place_index_t&lt;I&gt;,
          initializer_list&lt;U&gt; il, Args&amp;&amp;... args);</del>
</pre>
<blockquote>
<p>
<del>-34- <i>Requires:</i> <tt>Alloc</tt> shall meet the requirements for an Allocator 
(20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>).</del>
<p/>
<del>-35- <i>Effects:</i> Equivalent to the preceding constructors except that the contained value is constructed with
uses-allocator construction (23.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>).</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.13 <a href="https://timsong-cpp.github.io/cppwp/variant.traits">[variant.traits]</a> as indicated:</p>

<blockquote>
<pre>
<del>template &lt;class... Types, class Alloc&gt;
struct uses_allocator&lt;variant&lt;Types...&gt;, Alloc&gt; : true_type { };</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Requires:</i> <tt>Alloc</tt> shall be an Allocator (20.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>).</del>
<p/>
<del>-2- [<i>Note:</i> Specialization of this trait informs other library components that variant can be constructed
with an allocator, even though it does not have a nested <tt>allocator_type</tt>. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2902" href="2902">2902.</a> <tt>variant</tt> should only support complete types</h3>
<p><b>Section:</b> 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-06 17:34:24 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.variant">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.variant">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 114</b>

<p><tt>variant</tt> needs to know the size of an object in order to compute the size of its internal buffer, so 
require that any <i>cv</i>-qualified object type in <tt>Types...</tt> be a complete type.</p>
<p>Proposed change: Add 'complete' in p2</p>

<p><i>[2017-07-01, Daniel comments]</i></p>

<p>
I recommend to close this issue as NAD: According to 20.5.4.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> p2 plus bullet (2.5):
</p>
<blockquote>
<p>
-2- In particular, the effects are undefined in the following cases:
</p>
<ol style="list-style-type: none">
<li><p>&mdash; [&hellip;]</p></li>
<li><p>(2.5) &mdash; if an incomplete type (6.9) is used as a template argument when instantiating a template component,
unless specifically allowed for that component.</p></li>
</ol>
</blockquote>
<p>
In other words: The standard currently already requires type completeness for all types in <tt>Types...</tt> of
<tt>std::variant&lt;Types...&gt;</tt>, we therefore should not repeat that again (Note that other templates &mdash; such as 
<tt>shared_ptr</tt> &mdash; <em>grant</em> type <b>in</b>completeness allowance for that reason).
<p/>
The criteria for the alternative resolution form <a href="lwg-active.html#Resolved">Resolved</a> do not apply for this case, 
because the quoted constraint do exist since C++98 (see 17.4.3.6 [lib.res.on.functions] p2 b5), so the issue was not 
even an issue at the point of the submission.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/N4618">N4618</a>.</p>
<ol>
<li><p>Edit 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>/2 as indicated:</p>
<blockquote>
All types in <tt>Types...</tt> shall be (possibly <i>cv</i>-qualified)<ins> complete</ins> object types that are not arrays.
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-07-06 Moved to Tentatively NAD after 5 positive votes on c++std-lib.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
The lack of the explicit constraint in 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> is not a defect, because the general requirements in 
20.5.4.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> p2 already impose the requested type completeness constraints.
</p>





<hr>
<h3><a name="2972" href="2972">2972.</a> What is <tt>is_trivially_destructible_v&lt;int&gt;</tt>?</h3>
<p><b>Section:</b> 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2017-06-01 <b>Last modified:</b> 2017-07-05 19:30:12 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The spec for <tt>is_trivially_destructible</tt> says the value is true if "<tt>is_destructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and the indicated destructor is known to be trivial."
<p/>
For a case like <tt>is_trivially_destructible_v&lt;int&gt;</tt>, there is no indicated destructor, so it's unclear what value 
the trait would have but the most plausible reading of these words is that it should be <tt>false</tt>. However, I'm confident 
the intent is that this trait should yield <tt>true</tt> in that situation, and that's what all the implementations I can 
find actually do.
</p>

<p><i>[2017-06-14, Daniel and Jonathan provide wording]</i></p>


<p><i>[2017-07-05 Moved to Tentatively Ready after 5 positive votes on c++std-lib.]</i></p>



<p><b>Proposed resolution:</b></p>
This wording is relative to <a href="http://wg21.link/n4659">N4659</a>.

<ol>
<li><p>Change 23.15.4.3 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>, Table 42 &mdash; "Type property predicates", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 22 &mdash; Type property predicates</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T&gt;<br/>
struct is_trivially_destructible;</tt>
</td>

<td>
<tt>is_destructible_v&lt;T&gt;</tt> is
<tt>true</tt> and <del>the indicated
destructor is known to be
trivial</del><ins><tt>remove_all_extents_t&lt;T&gt;</tt> is 
either a non-class type or a class type with a trivial destructor</ins>.
</td>

<td>
<tt>T</tt> shall be a complete type,
<i>cv</i> <tt>void</tt>, or an array of
unknown bound.
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2980" href="2980">2980.</a> Cannot <tt>compare_exchange</tt> empty pointers</h3>
<p><b>Section:</b> 23.11.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.atomic">[util.smartptr.shared.atomic]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2017-06-15 <b>Last modified:</b> 2017-06-26 20:04:47 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.atomic">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.atomic">[util.smartptr.shared.atomic]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[util.smartptr.shared.atomic] p35 states that two shared pointers are equivalent if
they store the same pointer value, and share <em>ownership</em>. As empty shared pointers
never share ownership, it is not possible to replace an empty shared pointer using
the atomic <tt>compare_exchange</tt> API.
<p/>
Note that through aliasing, empty shared pointers may still point to different objects,
and any resolution must allow for that case too.
</p>

<p><i>[
2017-06-26 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 23.11.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.atomic">[util.smartptr.shared.atomic]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  bool atomic_compare_exchange_weak_explicit(
    shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
    memory_order success, memory_order failure);
template&lt;class T&gt;
  bool atomic_compare_exchange_strong_explicit(
    shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w,
    memory_order success, memory_order failure);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-35- <i>Remarks:</i> Two <tt>shared_ptr</tt> objects are equivalent if they store the same pointer value and share
ownership<ins>, or if they store the same pointer value and both are empty</ins>. The weak form may fail spuriously. 
See 32.6.1.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2988" href="2988">2988.</a> Clause 32 cleanup missed one <tt>typename</tt></h3>
<p><b>Section:</b> 32.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2017-06-25 <b>Last modified:</b> 2017-06-26 19:31:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.syn">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.syn">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/p0558r1">P0558R1</a> missed updating one of the <tt>std::atomic_exchange</tt> 
signatures to avoid independent deduction for <tt>T</tt> on the second parameter.
</p>

<p><i>[
2017-06-26 Moved to Tentatively Ready after 6 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 32.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>, header <tt>&lt;atomic&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
T atomic_exchange(volatile atomic&lt;T&gt;*, <ins>typename atomic&lt;</ins>T<ins>&gt;::value_type</ins>) noexcept;
</pre>
</blockquote>
</li>
</ol>




</body>
</html>
