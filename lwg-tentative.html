<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p><p>Revised 2023-02-01 at 20:48:23 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="3204" href="3204">3204.</a> <tt>sub_match::swap</tt> only swaps the base class</h3>
<p><b>Section:</b> 32.8 <a href="https://timsong-cpp.github.io/cppwp/re.submatch">[re.submatch]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2019-05-07 <b>Last modified:</b> 2022-11-30 09:50:57 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.submatch">active issues</a> in [re.submatch].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.submatch">issues</a> in [re.submatch].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>sub_match&lt;I&gt;</tt> derives publicly from <tt>pair&lt;I,I&gt;</tt>, and so inherits 
<tt>pair::swap(pair&amp;)</tt>. This means that the following program fails:
</p>
<blockquote><pre>
#include &lt;regex&gt;
#include &lt;cassert&gt;

int main()
{
  std::sub_match&lt;const char*&gt; a, b;
  a.matched = true;
  a.swap(b);
  assert(b.matched);
}
</pre></blockquote>
<p>
The <tt>pair::swap(pair&amp;)</tt> member should be hidden by a <tt>sub_match::swap(sub_match&amp;)</tt> 
member that does the right thing.
</p>

<p><i>[2019-06-12 Priority set to 3 after reflector discussion]</i></p>


<p><i>[2020-05-01; Daniel adjusts wording to recent working draft]</i></p>


<p><i>[2022-04-25; Daniel adjusts wording to recent working draft]</i></p>

<p>
In addition the revised wording uses the new standard phrase "The exception specification is equivalent to"
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 32.8 <a href="https://timsong-cpp.github.io/cppwp/re.submatch">[re.submatch]</a>, class template <tt>sub_match</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template&lt;class BidirectionalIterator&gt;
class sub_match : public pair&lt;BidirectionalIterator, BidirectionalIterator&gt; {
public:
  [&hellip;]
  int compare(const sub_match&amp; s) const;
  int compare(const string_type&amp; s) const;
  int compare(const value_type* s) const;
  
  <ins>void swap(sub_match&amp; s) noexcept(<i>see below</i>);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 32.8.2 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.members">[re.submatch.members]</a> as indicated:</p>

<blockquote>
<pre>
int compare(const value_type* s) const;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
<ins>void swap(sub_match&amp; s) noexcept(<i>see below</i>);</ins>
</pre>
<blockquote class="note">
[<i>Drafting note:</i> The swappable requirement should really be unnecessary because <i>Cpp17Iterator</i> 
requires it, but there is no wording that requires <tt>BidirectionalIterator</tt> in Clause
32 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> in general meets the bidirectional iterator requirements. Note that the definition found
in 27.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> does not extend to 32 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> normatively. &mdash; 
<i>end drafting note</i>]
</blockquote>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> Lvalues of type <tt>BidirectionalIterator</tt> are swappable 
(16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>).</ins>
<p/>
<ins>-?- <i>Effects:</i> Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>this-&gt;pair&lt;BidirectionalIterator, BidirectionalIterator&gt;::swap(s);
std::swap(matched, s.matched);</ins>
</pre></blockquote>
<p>
<ins>-?- <i>Remarks:</i> The exception specification is equivalent to 
<tt>is_nothrow_swappable_v&lt;BidirectionalIterator&gt;</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-11-06; Daniel comments and improves wording]</i></p>

<p>
With the informal acceptance of <a href="https://isocpp.org/files/papers/P2696R0.html">P2696R0</a> by 
LWG during a pre-Kona telecon, we should use the new requirement set <i>Cpp17Swappable</i> instead of 
the "LValues are swappable" requirements.
</p>


<p><i>[2022-11-30; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3204"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a> <b>and assumes the acceptance of <a href="https://isocpp.org/files/papers/P2696R0.html">P2696R0</a></b>.
</p>

<ol>
<li><p>Modify 32.8 <a href="https://timsong-cpp.github.io/cppwp/re.submatch">[re.submatch]</a>, class template <tt>sub_match</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template&lt;class BidirectionalIterator&gt;
class sub_match : public pair&lt;BidirectionalIterator, BidirectionalIterator&gt; {
public:
  [&hellip;]
  int compare(const sub_match&amp; s) const;
  int compare(const string_type&amp; s) const;
  int compare(const value_type* s) const;
  
  <ins>void swap(sub_match&amp; s) noexcept(<i>see below</i>);</ins>
};
</pre>
</blockquote>
</li>

<li><p>Modify 32.8.2 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.members">[re.submatch.members]</a> as indicated:</p>

<blockquote>
<pre>
int compare(const value_type* s) const;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
<ins>void swap(sub_match&amp; s) noexcept(<i>see below</i>);</ins>
</pre>
<blockquote class="note">
[<i>Drafting note:</i> The <i>Cpp17Swappable</i> requirement should really be unnecessary because <i>Cpp17Iterator</i> 
requires it, but there is no wording that requires <tt>BidirectionalIterator</tt> in Clause
32 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> in general meets the bidirectional iterator requirements. Note that the definition found
in 27.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> does not extend to 32 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> normatively. &mdash; 
<i>end drafting note</i>]
</blockquote>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <tt>BidirectionalIterator</tt> meets the <i>Cpp17Swappable</i> requirements 
(16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>).</ins>
<p/>
<ins>-?- <i>Effects:</i> Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>this-&gt;pair&lt;BidirectionalIterator, BidirectionalIterator&gt;::swap(s);
std::swap(matched, s.matched);</ins>
</pre></blockquote>
<p>
<ins>-?- <i>Remarks:</i> The exception specification is equivalent to 
<tt>is_nothrow_swappable_v&lt;BidirectionalIterator&gt;</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3714" href="3714">3714.</a> Non-single-argument constructors for range adaptors should not be <tt>explicit</tt></h3>
<p><b>Section:</b> 26.7.24.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.transform.view">[range.zip.transform.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-10 <b>Last modified:</b> 2023-01-24 10:14:05 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>Discussion:</b></p>
<p>
All C++20 range adaptors' non-single-argument constructors are not declared as <tt>explicit</tt>, which makes 
the following initialization well-formed:
</p>
<blockquote><pre>
std::vector v{42};
std::ranges::take_view r1 = {v, 1};
std::ranges::filter_view r2 = {v, [](int) { return true; }};
</pre></blockquote>
<p>
However, the non-single-argument constructors of C++23 range adaptors, except for <tt>join_with_view</tt>, 
are all <tt>explicit</tt>, which makes us no longer able to
</p>
<blockquote><pre>
std::ranges::chunk_view r1 = {v, 1}; // <span style="color:red;font-weight:bolder">ill-formed</span>
std::ranges::chunk_by_view r2 = {v, [](int, int) { return true; }}; // <span style="color:red;font-weight:bolder">ill-formed</span>
</pre></blockquote>
<p>
This seems unnecessary since I don't see the observable benefit of preventing this. In the standard, 
non-single-argument constructors are rarely specified as <tt>explicit</tt> unless it is really undesirable, 
I think the above initialization is what the user expects since it's clearly intentional, and I don't see 
any good reason to reject it from C++23.
</p>
<p><i>[2022-06-11; Daniel comments]</i></p>

<p>
Another possible candidate could be 26.7.11.3 <a href="https://timsong-cpp.github.io/cppwp/range.take.while.sentinel">[range.take.while.sentinel]</a>'s
</p>
<blockquote><pre>
constexpr explicit <i>sentinel</i>(sentinel_t&lt;<i>Base</i>&gt; end, const Pred* pred);
</pre></blockquote>

<p><i>[2022-06-21; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Send to LEWG.
</p>

<p><i>[2023-01-24; LEWG in Kona]</i></p>

<p>Use alternative approach in <a href="https://wg21.link/P2711">P2711</a> instead.</p>



<p id="res-3714"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 26.7.24.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.transform.view">[range.zip.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view : public view_interface&lt;zip_transform_view&lt;F, Views...&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                   <i>// exposition only</i>
    zip_view&lt;Views...&gt; <i>zip_</i>;                <i>// exposition only</i>
    [&hellip;]
  public:
    zip_transform_view() = default;

    constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> zip_transform_view(F fun, Views... views);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>fun_</i></tt> with <tt>std::move(fun)</tt> and <tt><i>zip_</i></tt> 
with <tt>std::move(views)...</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.26.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.view">[range.adjacent.transform.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view : public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    <i>copyable-box</i>&lt;F&gt; <i>fun_</i>;                       <i>// exposition only</i>
    adjacent_view&lt;V, N&gt; <i>inner_</i>;                 <i>// exposition only</i>
    [&hellip;]
  public:
    adjacent_transform_view() = default;
    constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> adjacent_transform_view(V base, F fun);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>fun_</i></tt> with <tt>std::move(fun)</tt> and 
<tt><i>inner_</i></tt> with <tt>std::move(base)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.input">[range.chunk.view.input]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                                        <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;                         <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <tt>n &gt; 0</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.27.6 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.view.fwd">[range.chunk.view.fwd]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt; : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> <tt>n &gt; 0</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.28.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i> = 0;       <i>// exposition only</i>
    [&hellip;]
  public:
    slide_view() requires default_initializable&lt;V&gt; = default;
    constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> slide_view(V base, range_difference_t&lt;V&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>n_</i></tt> with <tt>n</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.29.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.by.view">[range.chunk.by.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view : public view_interface&lt;chunk_by_view&lt;V, Pred&gt;&gt; {
    V <i>base_</i> = V();                                <i>// exposition only</i>
    <i>copyable-box</i>&lt;Pred&gt; <i>pred_</i> = Pred();            <i>// exposition only</i>
    [&hellip;]
  public:
    chunk_by_view() requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pred&gt; = default;
    constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre>
constexpr <del>explicit</del> chunk_by_view(V base, Pred pred);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>pred_</i></tt> with <tt>std::move(pred)</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3733" href="3733">3733.</a> <tt>ranges::to</tt> misuses <tt><i>cpp17-input-iterator</i></tt></h3>
<p><b>Section:</b> 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2022-07-10 <b>Last modified:</b> 2023-01-11 17:56:28 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>ranges::to</tt> uses <tt><i>cpp17-input-iterator</i>&lt;iterator_t&lt;R&gt;&gt;</tt> to check 
whether an iterator is a <i>Cpp17InputIterator</i>, which misbehaves if there is a 
<tt>std::iterator_traits</tt> specialization for that iterator (e.g. if the iterator is a 
<tt>std::common_iterator</tt>).
</p>
<blockquote><pre>
struct MyContainer {
    template&lt;class Iter&gt;
    MyContainer(Iter, Iter);

    char* begin();
    char* end();
};

auto nul_terminated = std::views::take_while([](char ch) { return ch != '\0'; });
auto c = nul_terminated("") | std::views::common | std::ranges::to&lt;MyContainer&gt;();  // <span style="color:red;font-weight:bolder">error</span>
</pre></blockquote>
<p>
I believe that <tt>ranges::to</tt> should instead use 
<tt>derived_from&lt;typename iterator_traits&lt;iterator_t&lt;R&gt;&gt;::iterator_category, input_iterator_tag&gt;</tt>, 
which correctly detects the iterator category of a <tt>std::common_iterator</tt>.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>

<li><p>Modify 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Returns</i>: An object of type <tt>C</tt> constructed from the elements of <tt>r</tt> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If <tt>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</tt> is <tt>true</tt>:</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.1) &mdash; If <tt>constructible_from&lt;C, R, Args...&gt;</tt> is <tt>true</tt>:</p>
<blockquote><tt>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote></li>
<li><p>(1.1.2) &mdash; Otherwise, if <tt>constructible_from&lt;C, from_range_t, R, Args...&gt;</tt> is <tt>true</tt>:</p>
<blockquote><tt>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote></li>
<li><p>(1.1.3) &mdash; Otherwise, if</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.3.1) &mdash; <tt>common_range&lt;R&gt;</tt> is <tt>true</tt>,</p></li>
<li><p>(1.1.3.2) &mdash; <tt><del><i>cpp17-input-iterator</i></del><ins>derived_from&lt;typename 
iterator_traits</ins>&lt;iterator_t&lt;R&gt;&gt;<ins>::iterator_category, input_iterator_tag&gt;</ins></tt> 
is <tt>true</tt>, and</p></li>
<li><p>(1.1.3.3) &mdash; <tt>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</tt> is <tt>true</tt>:</p>
<blockquote><tt>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote></li>
</ol>
<li><p>(1.1.4) &mdash; Otherwise, if</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.4.1) &mdash; <tt>constructible_from&lt;C, Args...&gt;</tt> is <tt>true</tt>, and</p></li>
<li><p>(1.1.4.2) &mdash; <tt><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:</p>
<blockquote><pre>
[&hellip;]
</pre></blockquote></li>
</ol>
</ol>
<li><p>(1.2) &mdash; Otherwise, if <tt>input_range&lt;range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(1.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2022-08-27; Hewill Kang reopens and suggests a different resolution]</i></p>

<p>
This issue points out that the standard misuses <tt><i>cpp17-input-iterator</i></tt> to check 
whether the iterator meets the requirements of <i>Cpp17InputIterator</i>, and proposes to use 
<tt>iterator_traits&lt;I&gt;::iterator_category</tt> to check the iterator's category directly, 
which may lead to the following potential problems:
<p/>
First, for the range types that model both <tt>common_range</tt> and <tt>input_range</tt>, 
the expression <tt>iterator_traits&lt;I&gt;::iterator_category</tt> may not be valid, consider
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct I {
  using difference_type = int;
  using value_type = int;
  int operator*() const;
  I&amp; operator++();
  void operator++(int);
  bool operator==(const I&amp;) const;
  bool operator==(std::default_sentinel_t) const;
};

int main() {
  auto r = std::ranges::subrange(I{}, I{});
  auto v = r | std::ranges::to&lt;std::vector&lt;int&gt;&gt;(0);
}
</pre></blockquote>
<p>
Although <tt>I</tt> can serve as its own sentinel, it does not model 
<tt><i>cpp17-input-iterator</i></tt> since postfix <tt>operator++</tt> returns <tt>void</tt>, 
which causes <tt>iterator_traits&lt;R&gt;</tt> to be an empty class, making the 
expression <tt>derived_from&lt;iterator_traits&lt;I&gt;::iterator_category, input_iterator_tag&gt;</tt> ill-formed.
<p/>
Second, for <tt>common_iterator</tt>, <tt>iterator_traits&lt;I&gt;::iterator_category</tt> 
does not guarantee a strictly correct iterator category in the current standard.
<p/>
For example, when the above <tt>I::operator*</tt> returns a non-<tt>copyable</tt> object that 
can be converted to <tt>int</tt>, this makes <tt>common_iterator&lt;I, default_sentinel_t&gt;</tt> 
unable to synthesize a C++17-conforming postfix <tt>operator++</tt>, however, 
<tt>iterator_traits&lt;common_iterator&lt;I, S&gt;&gt;::iterator_category</tt> will still 
give <tt>input_iterator_tag</tt> even though it's not even a C++17 iterator.
<p/>
Another example is that for <tt>input_iterator</tt>s with difference type of integer-class type, 
the difference type of the <tt>common_iterator</tt> wrapped on it is still of the integer-class type, 
but the <tt>iterator_category</tt> obtained by the <tt>iterator_traits</tt> is <tt>input_iterator_tag</tt>. 
<p/>
The proposed resolution only addresses the first issue since I believe that the problem with 
<tt>common_iterator</tt> requires a paper.
</p>

<p><i>[2023-01-11; LWG telecon]</i></p>

<p>
Set status to Tentatively Ready (poll results F6/A0/N1)
</p>



<p id="res-3733"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Returns</i>: An object of type <tt>C</tt> constructed from the elements of <tt>r</tt> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If <tt>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</tt> is <tt>true</tt>:</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.1) &mdash; If <tt>constructible_from&lt;C, R, Args...&gt;</tt> is <tt>true</tt>:</p>
<blockquote><tt>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote></li>
<li><p>(1.1.2) &mdash; Otherwise, if <tt>constructible_from&lt;C, from_range_t, R, Args...&gt;</tt> is <tt>true</tt>:</p>
<blockquote><tt>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote></li>
<li><p>(1.1.3) &mdash; Otherwise, if</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.3.1) &mdash; <tt>common_range&lt;R&gt;</tt> is <tt>true</tt>,</p></li>
<li><p>(1.1.3.2) &mdash; <del><tt><i>cpp17-input-iterator</i></tt></del><ins>if the <i>qualified-id</i>  
<tt>iterator_traits</tt></ins><tt>&lt;iterator_t&lt;R&gt;&gt;</tt><ins><tt>::iterator_category</tt> </ins>is<ins> 
<del><tt>true</tt></del> valid and denotes a type that models <tt>derived_from&lt;input_iterator_tag&gt;</tt></ins>, and</p></li>
<li><p>(1.1.3.3) &mdash; <tt>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</tt>:</p>
<blockquote><tt>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote></li>
</ol>
<li><p>(1.1.4) &mdash; Otherwise, if</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.4.1) &mdash; <tt>constructible_from&lt;C, Args...&gt;</tt> is <tt>true</tt>, and</p></li>
<li><p>(1.1.4.2) &mdash; <tt><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:</p>
<blockquote><pre>
[&hellip;]
</pre></blockquote></li>
</ol>
</ol>
<li><p>(1.2) &mdash; Otherwise, if <tt>input_range&lt;range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(1.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3742" href="3742">3742.</a> <tt>deque::prepend_range</tt> needs to permute</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2022-07-16 <b>Last modified:</b> 2022-11-30 09:50:57 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the range to be inserted is neither bidirectional nor sized, it's simpler to prepend 
elements one at a time, and then reverse the prepended elements. When the range to be 
inserted is neither forward nor sized, I believe this approach is necessary to implement 
<tt>prepend_range</tt> at all &mdash; there is no way to determine the length of the range 
modulo the block size of the <tt>deque</tt> ahead of time so as to insert the new elements 
in the proper position.
<p/>
The container requirements do not allow <tt>prepend_range</tt> to permute elements in a 
<tt>deque</tt>. I believe we <em>must</em> allow permutation when the range is neither 
forward nor sized, and we <em>should</em> allow permutation when the range is not bidirectional 
to allow implementations the freedom to make a single pass through the range.
</p>

<p><i>[2022-07-17; Daniel comments]</i></p>

<p>
The below suggested wording follows the existing style used in the specification of <tt>insert</tt>
and <tt>insert_range</tt>, for example. Unfortunately, this existing practice violates the usual
wording style that a <i>Cpp17XXX</i> requirement shall be <em>met</em> and that we should better
say that "lvalues of type <tt>T</tt> are swappable (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>)" to 
be clearer about the specific swappable context. A separate editorial issue will be reported to take
care of this problem.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote>
<pre>
a.prepend_range(rg)
</pre>
<blockquote>
<p>
-94- <i>Result:</i> <tt>void</tt>
<p/>
-95- <i>Preconditions:</i> <tt>T</tt> is <i>Cpp17EmplaceConstructible</i> into <tt>X</tt> 
from <tt>*ranges::begin(rg)</tt>. <ins>For <tt>deque</tt>, <tt>T</tt> is also 
<tt>Cpp17MoveInsertable</tt> into <tt>X</tt>, <i>Cpp17MoveConstructible</i>, 
<i>Cpp17MoveAssignable</i>, and swappable (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>).</ins>
<p/>
-96- <i>Effects:</i> Inserts copies of elements in <tt>rg</tt> before <tt>begin()</tt>. 
Each iterator in the range <tt>rg</tt> is dereferenced exactly once.
<p/>
[<i>Note 3</i>: The order of elements in <tt>rg</tt> is not reversed. &mdash; <i>end note</i>]
<p/>
-97- <i>Remarks:</i> Required for <tt>deque</tt>, <tt>forward_list</tt>, and <tt>list</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2022-11-07; Daniel reopens and comments]</i></p>

<p>
The proposed wording has two problems:
</p>
<ol>
<li><p>It still uses "swappable" instead of "swappable lvalues", which
with the (informal) acceptance of <a href="https://isocpp.org/files/papers/P2696R0.html">P2696R0</a>
should now become <i>Cpp17Swappable</i>.</p></li>
<li><p>It uses an atypical form to say "<tt>T</tt> (is) <i>Cpp17MoveConstructible</i>,
<i>Cpp17MoveAssignable</i>" instead of the more correct form "<tt>T</tt> meets the
<i>Cpp17MoveConstructible</i> and <i>Cpp17MoveAssignable</i> requirements". This
form was also corrected by <a href="https://isocpp.org/files/papers/P2696R0.html">P2696R0</a>.</p></li>
</ol>
<p>
The revised wording uses the <a href="https://isocpp.org/files/papers/P2696R0.html">P2696R0</a>
wording approach to fix both problems.
</p>

<p><i>[Kona 2022-11-12; Set priority to 2]</i></p>



<p><i>[2022-11-30; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3742"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a> <b>assuming that <a href="https://isocpp.org/files/papers/P2696R0.html">P2696R0</a>
has been accepted</b>.
</p>

<ol>
<li><p>Modify 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote>
<pre>
a.prepend_range(rg)
</pre>
<blockquote>
<p>
-94- <i>Result:</i> <tt>void</tt>
<p/>
-95- <i>Preconditions:</i> <tt>T</tt> is <i>Cpp17EmplaceConstructible</i> into <tt>X</tt> 
from <tt>*ranges::begin(rg)</tt>. <ins>For <tt>deque</tt>, <tt>T</tt> is also 
<tt>Cpp17MoveInsertable</tt> into <tt>X</tt>, and <tt>T</tt> meets the <i>Cpp17MoveConstructible</i>, 
<i>Cpp17MoveAssignable</i>, and <i>Cpp17Swappable</i> (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>) requirements.</ins>
<p/>
-96- <i>Effects:</i> Inserts copies of elements in <tt>rg</tt> before <tt>begin()</tt>. 
Each iterator in the range <tt>rg</tt> is dereferenced exactly once.
<p/>
[<i>Note 3</i>: The order of elements in <tt>rg</tt> is not reversed. &mdash; <i>end note</i>]
<p/>
-97- <i>Remarks:</i> Required for <tt>deque</tt>, <tt>forward_list</tt>, and <tt>list</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3790" href="3790">3790.</a> P1467 accidentally changed <tt>nexttoward</tt>'s signature</h3>
<p><b>Section:</b> 28.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> David Olsen <b>Opened:</b> 2022-09-30 <b>Last modified:</b> 2023-01-11 17:36:55 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cmath.syn">active issues</a> in [cmath.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#cmath.syn">issues</a> in [cmath.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P1467">P1467</a> (Extended floating-point types), which was adopted for C++23 at the July plenary, 
has a typo (which is entirely my fault) that no one noticed during wording review.  The changes to the 
<tt>&lt;cmath&gt;</tt> synopsis in the paper included changing this:
</p>
<blockquote><pre>
constexpr float nexttoward(float x, long double y);       // see [library.c]
constexpr double nexttoward(double x, long double y);
constexpr long double nexttoward(long double x, long double y);   // see [library.c]
</pre></blockquote>
<p>
to this:
</p>
<blockquote><pre>
constexpr <i>floating-point-type</i> nexttoward(<i>floating-point-type</i> x, <i>floating-point-type</i> y);
</pre></blockquote>
<p>
That changed the second parameter of <tt>nexttoward</tt> from always being <tt>long double</tt> to being 
<tt><i>floating-point-type</i></tt>, which matches the type of the first parameter.
<p/>
The change is obviously incorrect. The purpose of the changes to <tt>&lt;cmath&gt;</tt> was to add overloads 
of the functions for extended floating-point types, not to change any existing signatures.
</p>

<p><i>[2022-10-10; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll. Discussion during prioritization
revolved around whether to delete <code>nexttoward</code> for new FP types
or just restore the C++20 signatures, which might accept the new types via
implicit conversions (and so return a different type, albeit with the same
representation and same set of values).
</p>
<p>
"When the first argument to <code>nexttoward</code> is an extended
floating-point type that doesn't have the same representation as a standard
floating-point type, such as <code>std::float16_t</code>,
<code>std::bfloat16_t</code>, or <code>std::float128_t</code> (on some systems),
the call to <code>nexttoward</code> is ambiguous and ill-formed,
so the unexpected return type is not an issue.
Going through the extra effort of specifying '= delete' for
<code>nexttoward</code> overloads that have extended floating-point arguments
is a solution for a problem that doesn't really exist."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 28.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>, header <tt>&lt;cmath&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
constexpr <i>floating-point-type</i> nexttoward(<i>floating-point-type</i> x, <del><i>floating-point-type</i></del><ins>long double</ins> y);
constexpr float nexttowardf(float x, long double y);
constexpr long double nexttowardl(long double x, long double y);
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-10-04; David Olsen comments and provides improved wording]</i></p>

<p>
C23 specifies variants of most of the functions in <tt>&lt;math.h&gt;</tt> for the <tt>_FloatN</tt> types 
(which are C23's equivalent of C++23's <tt>std::floatN_t</tt> types). But it does not specify those variants 
for <tt>nexttoward</tt>.
<p/>
Based on what C23 is doing, I think it would be reasonable to leave <tt>nexttoward</tt>'s signature unchanged 
from C++20. There would be no requirement to provide overloads for extended floating-point types, only for 
the standard floating-point types. Instead of explicitly deleting the overloads with extended floating-point 
types, we can just never declare them in the first place.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 28.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>, header <tt>&lt;cmath&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>constexpr float nexttoward(float x, long double y);</ins>
<ins>constexpr double nexttoward(double x, long double y);</ins>
<ins>constexpr long double nexttoward(long double x, long double y);</ins>
<del>constexpr <i>floating-point-type</i> nexttoward(<i>floating-point-type</i> x, <i>floating-point-type</i> y);</del>
constexpr float nexttowardf(float x, long double y);
constexpr long double nexttowardl(long double x, long double y);
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</blockquote>


<p><i>[2022-11-12; Tomasz comments and provides improved wording]</i></p>

<p>
During 2022-10-26 LWG telecon we decided that we want to make the calls of the <code>nexttoward</code>
to be ill-formed (equivalent of Mandates) when the first argument is extended floating-point type.
</p>


<p><i>[2023-01-11; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-3790"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
	
<li><p>Modify 28.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>, header <tt>&lt;cmath&gt;</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
constexpr <i>floating-point-type</i> nexttoward(<i>floating-point-type</i> x, <del><i>floating-point-type</i></del><ins>long double</ins> y);
constexpr float nexttowardf(float x, long double y);
constexpr long double nexttowardl(long double x, long double y);
[&hellip;]
</pre>
</blockquote>
</li>


<li><p>Add following paragraph at the end of 28.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>, header <tt>&lt;cmath&gt;</tt> synopsis:</p>

<blockquote>
<ins>-?- An invocation of <tt>nexttoward</tt> is ill-formed if the argument corresponding to the <i>floating-point-type</i>
parameter has extended floating-point type.</ins>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3819" href="3819">3819.</a> <tt>reference_<i>meow</i>s_from_temporary</tt> should not use <tt>is_<i>meow</i>ible</tt></h3>
<p><b>Section:</b> 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2022-11-08 <b>Last modified:</b> 2022-11-10 23:33:13 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The intent of <a href="https://wg21.link/P2255R2">P2255R2</a> is for the <tt>reference_<i>meow</i>s_from_temporary</tt> traits 
to fully support cases where a prvalue is used as the source. Unfortunately the wording fails 
to do so because it tries to use the <tt>is_<i>meow</i>ible</tt> traits to say 
"the initialization is well-formed", but those traits only consider initialization from xvalues, 
not prvalues. For example, given:
</p>
<blockquote>
<pre>
struct U {
  U();
  U(U&amp;&amp;) = delete;
};

struct T {
  T(U);
};
</pre>
</blockquote>
<p>
<tt>reference_constructs_from_temporary_v&lt;const T&amp;, U&gt;</tt> should be true, but is currently defined as <tt>false</tt>. 
We need to spell out the "is well-formed" condition directly.
</p>

<p><i>[Kona 2022-11-08; Move to Tentatively Ready]</i></p>




<p id="res-3819"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The note is already repeated every time we talk about "immediate context".]
</p>
</blockquote>

<ol>
<li><p>Modify 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>, Table 46 ([tab:meta.unary.prop]) &mdash; 
"Type property predicates" &mdash; as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 46: Type property predicates [tab:meta.unary.prop]</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template&lt;class T, class U&gt;<br/>
struct reference_constructs_from_temporary;</tt>
</td>

<td>
<del><tt>conjunction_v&lt;is_reference&lt;T&gt;, is_constructible&lt;T, U&gt;&gt;</tt> is
<tt>true</tt></del><ins><tt>T</tt> is a reference type</ins>,
and the initialization <tt>T t(<i>VAL</i>&lt;U&gt;);</tt> <ins>is well-formed and</ins> binds <tt>t</tt> to a
temporary object whose lifetime is extended (6.7.7 <a href="https://timsong-cpp.github.io/cppwp/class.temporary">[class.temporary]</a>).
<ins>Access checking is performed as if in a context unrelated to <tt>T</tt> and <tt>U</tt>. 
Only the validity of the immediate context of the variable initialization is considered. 
[<i>Note ?:</i> The initialization can result in effects such as the instantiation of class template 
specializations and function template specializations, the generation of implicitly-defined functions, 
and so on. Such effects are not in the "immediate context" and can result in the program being ill-formed.
<i>&mdash; end note]</i></ins>
</td>

<td>
<tt>T</tt> and <tt>U</tt> shall be complete types, <i>cv</i> <tt>void</tt>, or arrays of unknown bound.
</td>
</tr>

<tr>
<td>
<tt>template&lt;class T, class U&gt;<br/>
struct reference_converts_from_temporary;</tt>
</td>

<td>
<del><tt>conjunction_v&lt;is_reference&lt;T&gt;, is_convertible&lt;U, T&gt;&gt;</tt> is
<tt>true</tt></del><ins><tt>T</tt> is a reference type</ins>, and the initialization
<tt>T t = <i>VAL</i>&lt;U&gt;;</tt> <ins>is well-formed and</ins> binds <tt>t</tt> to a
temporary object whose lifetime is extended (6.7.7 <a href="https://timsong-cpp.github.io/cppwp/class.temporary">[class.temporary]</a>).
<ins>Access checking is performed as if in a context unrelated to <tt>T</tt> and <tt>U</tt>. 
Only the validity of the immediate context of the variable initialization is considered. 
[<i>Note ?:</i> The initialization can result in effects such as the instantiation of class template 
specializations and function template specializations, the generation of implicitly-defined functions, 
and so on. Such effects are not in the "immediate context" and can result in the program being ill-formed.
<i>&mdash; end note]</i></ins>
</td>

<td>
<tt>T</tt> and <tt>U</tt> shall be complete types, <i>cv</i> <tt>void</tt>, or arrays of unknown bound.
</td>
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="3821" href="3821">3821.</a> <tt>uses_allocator_construction_args</tt> should have overload for <i><tt>pair-like</tt></i></h3>
<p><b>Section:</b> 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2022-11-08 <b>Last modified:</b> 2023-01-11 17:49:26 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.uses.construction">active issues</a> in [allocator.uses.construction].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.uses.construction">issues</a> in [allocator.uses.construction].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P2165R4">P2165R4</a> added a <tt><i>pair-like</i></tt> constructor to 
<tt>std::pair</tt> but didn't add a corresponding <tt>uses_allocator_construction_args</tt> overload. 
It was in <a href="https://wg21.link/P2165R3">P2165R3</a> but incorrectly removed during the small group review.
<p/>
Without LWG <a href="3525">3525</a>, not having the overload would have caused emplacing a <tt><i>pair-like</i></tt> into a 
<tt>pmr::vector&lt;pair&gt;</tt> to be outright ill-formed. 
<p/>
With that issue's resolution, in cases where the constructor is not explicit we would create a temporary pair 
and then do uses-allocator construction using its pieces, and it still won't work when the constructor is explicit.
<p/>
We should just do this properly.
</p>

<p><i>[2022-11-09 Tim updates wording following LWG review]</i></p>

<p>
During review of this issue LWG noticed that neither the constructor nor the new overload should accept <tt>subrange</tt>.
<p/>
The <tt>remove_cv_t</tt> in the new paragraph is added for consistency with LWG <a href="3677">3677</a>.
</p> 

<p><i>[Kona 2022-11-12; Set priority to 2]</i></p>



<p><i>[2023-01-11; LWG telecon]</i></p>

<p>
Replace <tt>P</tt> with <tt>U</tt> in p17 and
set status to Tentatively Ready (poll result: 8/0/0).
</p>



<p id="res-3821"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a> after the application of LWG <a href="3677">3677</a>.
</p>
<ol>
<li><p>Edit 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class U1, class U2&gt; constexpr explicit(<i>see below</i>) pair(pair&lt;U1, U2&gt;&amp; p);
template&lt;class U1, class U2&gt; constexpr explicit(<i>see below</i>) pair(const pair&lt;U1, U2&gt;&amp; p);
template&lt;class U1, class U2&gt; constexpr explicit(<i>see below</i>) pair(pair&lt;U1, U2&gt;&amp;&amp; p);
template&lt;class U1, class U2&gt; constexpr explicit(<i>see below</i>) pair(const pair&lt;U1, U2&gt;&amp;&amp; p);
template&lt;<i>pair-like</i> P&gt; constexpr explicit(<i>see below</i>) pair(P&amp;&amp; p);
</pre>
<blockquote>
<p>
-14- Let <tt><i>FWD</i>(u)</tt> be <tt>static_cast&lt;decltype(u)&gt;(u)</tt>.
<p/>
-15- <i>Constraints:</i>
</p>
<ol style="list-style-type: none">
<li><p><ins>(15.?) &mdash; For the last overload, <tt>remove_cvref_t&lt;P&gt;</tt> is not a specialization of <tt>ranges::subrange</tt>,</ins></p></li>
<li><p>(15.1) &mdash; <tt>is_constructible_v&lt;T1, decltype(get&lt;0&gt;(<i>FWD</i>(p)))&gt;</tt> is <tt>true</tt> and</p></li>
<li><p>(15.2) &mdash; <tt>is_constructible_v&lt;T2, decltype(get&lt;1&gt;(<i>FWD</i>(p)))&gt;</tt> is <tt>true</tt>.</p></li>
</ol>
<p>
-16- <i>Effects:</i> Initializes <tt>first</tt> with <tt>get&lt;0&gt;(<i>FWD</i>(p))</tt> 
and <tt>second</tt> with <tt>get&lt;1&gt;(<i>FWD</i>(p))</tt>.
</p>
</blockquote>
</blockquote>
</li>
<li><p>Edit 20.2.2 <a href="https://timsong-cpp.github.io/cppwp/memory.syn">[memory.syn]</a>, header <tt>&lt;memory&gt;</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  <i>// 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>, uses-allocator construction</i>
  [&hellip;]
  template&lt;class T, class Alloc, class U, class V&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                    pair&lt;U, V&gt;&amp; pr) noexcept;

  template&lt;class T, class Alloc, class U, class V&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                    const pair&lt;U, V&gt;&amp; pr) noexcept;

  template&lt;class T, class Alloc, class U, class V&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                    pair&lt;U, V&gt;&amp;&amp; pr) noexcept;

  template&lt;class T, class Alloc, class U, class V&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc,
                                                    const pair&lt;U, V&gt;&amp;&amp; pr) noexcept;
<ins>  template&lt;class T, class Alloc, <i>pair-like</i> P&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc, P&amp;&amp; p) noexcept;</ins>
    
  template&lt;class T, class Alloc, class U&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc, U&amp;&amp; u) noexcept;
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Add the following to 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>:</p>
<blockquote>
<pre>
<ins>  template&lt;class T, class Alloc, <i>pair-like</i> P&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc, P&amp;&amp; p) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>remove_cv_t&lt;T&gt;</tt> is a specialization of <tt>pair</tt> 
and <tt>remove_cvref_t&lt;P&gt;</tt> is not a specialization of <tt>ranges::subrange</tt>.</ins>
<p/>
<ins>-?- <i>Effects:</i> Equivalent to:</ins>
</p>
<blockquote><pre><ins>
return uses_allocator_construction_args&lt;T&gt;(alloc, piecewise_construct,
                                            forward_as_tuple(get&lt;0&gt;(std::forward&lt;P&gt;(p))),
                                            forward_as_tuple(get&lt;1&gt;(std::forward&lt;P&gt;(p))));
</ins></pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Edit 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> p17:</p>
<blockquote>
<pre>
  template&lt;class T, class Alloc, class U&gt;
    constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc, U&amp;&amp; u) noexcept;
</pre>
<blockquote>
<p>
-16- Let <tt><i>FUN</i></tt> be the function template:
</p>
<blockquote><pre>
  template&lt;class A, class B&gt;
  void <i>FUN</i>(const pair&lt;A, B&gt;&amp;);
</pre></blockquote>
<p>
-17- <i>Constraints:</i> <tt>remove_cv_t&lt;T&gt;</tt> is a specialization of <tt>pair</tt>, <ins>and either:</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(17.1) &mdash; <tt>remove_cvref_t&lt;U&gt;</tt> is a specialization of <tt>ranges::subrange</tt>, or</ins></p></li>
<li><p><ins>(17.2) &mdash; <tt>U</tt> does not satisfy <i><tt>pair-like</tt></i></ins>
and the expression <tt><i>FUN</i>(u)</tt> is not well-formed when considered as an unevaluated operand..</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3834" href="3834">3834.</a> Missing <tt>constexpr</tt> for <tt>std::intmax_t</tt> math functions in <tt>&lt;cinttypes&gt;</tt></h3>
<p><b>Section:</b> 31.13.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> George Tokmaji <b>Opened:</b> 2022-11-27 <b>Last modified:</b> 2023-01-06 14:25:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P0533R9">P0533R9</a> adds <tt>constexpr</tt> to math functions in <tt>&lt;cmath&gt;</tt> 
and <tt>&lt;cstdlib&gt;</tt>, which includes <tt>std::abs</tt> and <tt>std::div</tt>. This 
misses the overloads for <tt>std::intmax_t</tt> in <tt>&lt;cinttypes&gt;</tt>, as well as 
<tt>std::imaxabs</tt> and <tt>std::imaxdiv</tt>, which seems like an oversight.
</p>

<p><i>[2023-01-06; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3834"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 31.13.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a>, header <tt>&lt;cinttypes&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<blockquote><pre>
[&hellip;]
namespace std {
  using imaxdiv_t = <i>see below</i>;
  
  <ins>constexpr</ins> intmax_t imaxabs(intmax_t j);
  <ins>constexpr</ins> imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
  intmax_t strtoimax(const char* nptr, char** endptr, int base);
  uintmax_t strtoumax(const char* nptr, char** endptr, int base);
  intmax_t wcstoimax(const wchar_t* nptr, wchar_t** endptr, int base);
  uintmax_t wcstoumax(const wchar_t* nptr, wchar_t** endptr, int base);

  <ins>constexpr</ins> intmax_t abs(intmax_t);            // <i>optional, see below</i>
  <ins>constexpr</ins> imaxdiv_t div(intmax_t, intmax_t); // <i>optional, see below</i>
  [&hellip;]
}
[&hellip;]
</pre></blockquote>
<p>
-1- The contents and meaning of the header <tt>&lt;cinttypes&gt;</tt> are the same as the C standard library header
<tt>&lt;inttypes.h&gt;</tt>, with the following changes:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; The header <tt>&lt;cinttypes&gt;</tt> includes the header <tt>&lt;cstdint&gt;</tt> 
(17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>) instead of <tt>&lt;stdint.h&gt;</tt>, and</p></li>
<li><p>(1.2) &mdash; if and only if the type <tt>intmax_t</tt> designates an extended integer type 
(6.8.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>), the following function signatures are added:</p>
<blockquote><pre>
<ins>constexpr</ins> intmax_t abs(intmax_t);
<ins>constexpr</ins> imaxdiv_t div(intmax_t, intmax_t);
</pre></blockquote>
<p>which shall have the same semantics as the function signatures 
<tt><ins>constexpr</ins> intmax_t imaxabs(intmax_t)</tt> and
<tt><ins>constexpr</ins> imaxdiv_t imaxdiv(intmax_t, intmax_t)</tt>, respectively.</p></li>
</ol>

</blockquote>
</li>
</ol>






<hr>
<h3><a name="3839" href="3839">3839.</a> <tt>range_formatter</tt>'s <tt>set_separator</tt>, <tt>set_brackets</tt>, and <tt>underlying</tt> functions should be <tt>noexcept</tt></h3>
<p><b>Section:</b> 22.14.7.2 <a href="https://timsong-cpp.github.io/cppwp/format.range.formatter">[format.range.formatter]</a>, 22.14.7.3 <a href="https://timsong-cpp.github.io/cppwp/format.range.fmtdef">[format.range.fmtdef]</a>, 22.14.9 <a href="https://timsong-cpp.github.io/cppwp/format.tuple">[format.tuple]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-12-11 <b>Last modified:</b> 2023-01-06 14:41:04 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>set_separator</tt> and <tt>set_brackets</tt> of <tt>range_formatter</tt> only invoke 
<tt>basic_string_view</tt>'s assignment operator, which is <tt>noexcept</tt>, we should add <tt>noexcept</tt> 
specifications for them.
<p/>
In addition, its <tt>underlying</tt> function returns a reference to the underlying <tt>formatter</tt>, 
which never throws, they should also be <tt>noexcept</tt>.
<p/>
Similar rules apply to <tt><i>range-default-formatter</i></tt> and <tt>formatter</tt>'s <tt>tuple</tt> specialization.
</p>

<p><i>[2023-01-06; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-3839"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 22.14.7.2 <a href="https://timsong-cpp.github.io/cppwp/format.range.formatter">[format.range.formatter]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class T, class charT = char&gt;
    requires same_as&lt;remove_cvref_t&lt;T&gt;, T&gt; &amp;&amp; formattable&lt;T, charT&gt;
  class range_formatter {
    formatter&lt;T, charT&gt; <i>underlying_</i>;                                          // <i>exposition only</i>
    basic_string_view&lt;charT> <i>separator_</i> = <i>STATICALLY-WIDEN</i>&lt;charT&gt;(", ");      // <i>exposition only</i>
    basic_string_view&lt;charT> <i>opening-bracket_</i> = <i>STATICALLY-WIDEN</i>&lt;charT&gt;("["); // <i>exposition only</i>
    basic_string_view&lt;charT> <i>closing-bracket_</i> = <i>STATICALLY-WIDEN</i>&lt;charT&gt;("]"); // <i>exposition only</i>

  public:
    constexpr void set_separator(basic_string_view&lt;charT&gt; sep) <ins>noexcept</ins>;
    constexpr void set_brackets(basic_string_view&lt;charT&gt; opening,
                                basic_string_view&lt;charT&gt; closing) <ins>noexcept</ins>;
    constexpr formatter&lt;T, charT&gt;&amp; underlying() <ins>noexcept</ins> { return <i>underlying_</i>; }
    constexpr const formatter&lt;T, charT&gt;&amp; underlying() const <ins>noexcept</ins> { return <i>underlying_</i>; }

    [&hellip;]
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr void set_separator(basic_string_view&lt;charT&gt; sep) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Equivalent to: <tt><i>separator_</i> = sep;</tt>
</p>
</blockquote>
<pre>
constexpr void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to:
<pre>
<i>opening-bracket_</i> = opening;
<i>closing-bracket_</i> = closing;
</pre>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.14.7.3 <a href="https://timsong-cpp.github.io/cppwp/format.range.fmtdef">[format.range.fmtdef]</a> as indicated:</p>
  
<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;ranges::input_range R, class charT&gt;
  struct <i>range-default-formatter</i>&lt;range_format::sequence, R, charT&gt; {    // <i>exposition only</i>
  private:
    using <i>maybe-const-r</i> = <i>fmt-maybe-const</i>&lt;R, charT&gt;;                    // <i>exposition only</i>
    range_formatter&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;<i>maybe-const-r</i>&gt;&gt;,
                    charT&gt; <i>underlying_</i>;                                 // <i>exposition only</i>

  public:
    constexpr void set_separator(basic_string_view&lt;charT&gt; sep) <ins>noexcept</ins>;
    constexpr void set_brackets(basic_string_view&lt;charT&gt; opening,
                                basic_string_view&lt;charT&gt; closing) <ins>noexcept</ins>;
  
    [&hellip;]
  };
}
</pre>
</blockquote>
<pre>
constexpr void set_separator(basic_string_view&lt;charT&gt; sep) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to: <tt><i>underlying_</i>.set_separator(sep);</tt>.
</p>
</blockquote>
<pre>
constexpr void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Equivalent to: <tt><i>underlying_</i>.set_brackets(opening, closing);</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.14.9 <a href="https://timsong-cpp.github.io/cppwp/format.tuple">[format.tuple]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, formattable&lt;charT&gt;... Ts&gt;
  struct formatter&lt;<i>pair-or-tuple</i>&lt;Ts...&gt;, charT&gt; {
  private:
    tuple&lt;formatter&lt;remove_cvref_t&lt;Ts&gt;, charT&gt;...&gt; <i>underlying_</i>;               // <i>exposition only</i>
    basic_string_view&lt;charT> <i>separator_</i> = <i>STATICALLY-WIDEN</i>&lt;charT&gt;(", ");      // <i>exposition only</i>
    basic_string_view&lt;charT> <i>opening-bracket_</i> = <i>STATICALLY-WIDEN</i>&lt;charT&gt;("("); // <i>exposition only</i>
    basic_string_view&lt;charT> <i>closing-bracket_</i> = <i>STATICALLY-WIDEN</i>&lt;charT&gt;(")"); // <i>exposition only</i>

  public:
    constexpr void set_separator(basic_string_view&lt;charT&gt; sep) <ins>noexcept</ins>;
    constexpr void set_brackets(basic_string_view&lt;charT&gt; opening,
                                basic_string_view&lt;charT&gt; closing) <ins>noexcept</ins>;

    [&hellip;]
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr void set_separator(basic_string_view&lt;charT&gt; sep) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to: <tt><i>separator_</i> = sep;</tt>
</p>
</blockquote>
<pre>
constexpr void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Equivalent to:
<pre>
<i>opening-bracket_</i> = opening;
<i>closing-bracket_</i> = closing;
</pre>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3841" href="3841">3841.</a> <tt>&lt;version&gt;</tt> should not be "<i>all freestanding</i>"</h3>
<p><b>Section:</b> 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2022-12-14 <b>Last modified:</b> 2023-01-06 14:39:29 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It's reasonable for the <tt>&lt;version&gt;</tt> header to be required for freestanding, 
so that users can include it and see the "implementation-dependent information &hellip; 
(e.g. version number and release date)", and also to ask which features are present 
(which is the real intended purpose of <tt>&lt;version&gt;</tt>). 
It seems less reasonable to require every macro to be present on freestanding implementations, 
even the ones that correspond to non-freestanding features.
<p/>
<a href="https://wg21.link/P2198R7">P2198R7</a> will fix this situation for C++26, but we should also do something for 
C++23 before publishing it. 
It seems sensible not to require any of the macros to be present, and then allow implementations 
to define them for the features that they support.
</p>

<p><i>[2023-01-06; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-3841"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a>, header <tt>&lt;version&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<p>
-2- Each of the macros defined in <tt>&lt;version&gt;</tt> is also defined after inclusion of any member 
of the set of library headers indicated in the corresponding comment in this synopsis.
<p/>
[<i>Note 1</i>: Future revisions of C++ might replace the values of these macros with greater values. &mdash; <i>end note</i>]
</p>
<blockquote><pre>
<del><i>// all freestanding</i></del>
#define __cpp_lib_addressof_constexpr          201603L // also in &lt;memory&gt;
[&hellip;]
</pre></blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3842" href="3842">3842.</a> Unclear wording for <i>precision</i> in <i>chrono-format-spec</i></h3>
<p><b>Section:</b> 29.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2022-12-14 <b>Last modified:</b> 2023-01-06 14:39:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.format">active issues</a> in [time.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.format">issues</a> in [time.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> says:
</p>
<blockquote><p>
[&hellip;] Giving a <i>precision</i> specification in the <i>chrono-format-spec</i> is valid only for 
<tt>std::chrono::duration</tt> types where the representation type
<tt>Rep</tt> is a floating-point type. 
For all other <tt>Rep</tt> types, an exception of type <tt>format_error</tt> is thrown if the 
<i>chrono-format-spec</i> contains a <i>precision</i> specification. [&hellip;]
</p></blockquote>
<p>
It's unclear whether the restriction in the first sentence applies to all types, or only duration types. 
The second sentence seems to restrict the exceptional case to only types with a non-floating-point <tt>Rep</tt>, 
but what about types with no <tt>Rep</tt> type at all?
<p/>
Can you use a precision with <tt>sys_time&lt;duration&lt;float&gt;&gt;</tt>? That is not a <tt>duration</tt> type at all, 
so does the restriction apply? What about <tt>hh_mm_ss&lt;duration&lt;int&gt;&gt;</tt>? That's not a 
<tt>duration</tt> type, but it uses one, and its <tt>Rep</tt> is not a floating-point type. 
What about <tt>sys_info</tt>? That's not a <tt>duration</tt> and doesn't have any associated <tt>duration</tt>, 
or <tt>Rep</tt> type.
<p/>
What is the intention here?
<p/>
Less importantly, I don't like the use of <tt>Rep</tt> here. That's the template parameter of the 
<tt>duration</tt> class template, but that name isn't in scope here. Why aren't we talking about the 
<tt>duration</tt> type's <tt>rep</tt> type, which is the public name for it? Or about a concrete 
specialization <tt>duration&lt;Rep, Period&gt;</tt>, instead of the class template?
<p/>
The suggested change below would preserve the intended meaning, but with more &hellip; <i>precision</i>.
</p>

<p><i>[2023-01-06; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-3842"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 29.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> as indicated:</p>

<blockquote>
<p>
-1- [&hellip;]
<p/>
The productions <i>fill-and-align</i>, <i>width</i>, and <i>precision</i> are described in 22.14.2 <a href="https://timsong-cpp.github.io/cppwp/format.string">[format.string]</a>. 
Giving a <i>precision</i> specification in the <i>chrono-format-spec</i> is valid only for 
<ins>types that are specializations of</ins> <tt>std::chrono::duration</tt> <del>types where the representation type
<tt>Rep</tt> is</del><ins>for which the nested <i>typedef-name</i> <tt>rep</tt> denotes</ins> a floating-point type. 
For all other <del><tt>Rep</tt></del> types, an exception of type <tt>format_error</tt> is thrown if the 
<i>chrono-format-spec</i> contains a <i>precision</i> specification. [&hellip;]

</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3848" href="3848">3848.</a> <tt>adjacent_view</tt>, <tt>adjacent_transform_view</tt> and <tt>slide_view</tt> missing <tt>base</tt> accessor</h3>
<p><b>Section:</b> 26.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.view">[range.adjacent.view]</a>, 26.7.26.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.view">[range.adjacent.transform.view]</a>, 26.7.28.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-06 <b>Last modified:</b> 2023-02-01 20:28:28 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Like most range adaptors, these three views accept a single range
and store it as a member variable. 
However, they do not provide a <tt>base()</tt> member function for accessing
the underlying range, which seems like an oversight.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p id="res-3848"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 26.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.view">[range.adjacent.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  class adjacent_view : public view_interface&lt;adjacent_view&lt;V, N&gt;&gt; {
    V <i>base_</i> = V();                      <i>// exposition only</i>
    [&hellip;]
  public:
    adjacent_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit adjacent_view(V base);

    <ins>constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return <i>base_</i>; }</ins>
    <ins>constexpr V base() &amp;&amp; { return std::move(<i>base_</i>); }</ins>
    [&hellip;]
  };
}
</pre>
</blockquote>
</blockquote>
</li>
<li><p>Modify 26.7.26.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.transform.view">[range.adjacent.transform.view]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, move_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             <i>can-reference</i>&lt;invoke_result_t&lt;F&amp;, <i>REPEAT</i>(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view : public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    <i>movable-box</i>&lt;F&gt; <i>fun_</i>;                        <i>// exposition only</i>
    adjacent_view&lt;V, N&gt; <i>inner_</i>;                 <i>// exposition only</i>

    using <i>InnerView</i> = adjacent_view&lt;V, N&gt;;      <i>// exposition only</i>
    [&hellip;]
  public:
    adjacent_transform_view() = default;
    constexpr explicit adjacent_transform_view(V base, F fun);

    <ins>constexpr V base() const &amp; requires copy_constructible&lt;<i>InnerView</i>&gt; { return <i>inner_</i>.base(); }</ins>
    <ins>constexpr V base() &amp;&amp; { return std::move(<i>inner_</i>).base(); }</ins>
    [&hellip;]
  };
}
</pre>
</blockquote>
</blockquote>
</li>
<li><p>Modify 26.7.28.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V <i>base_</i>;                            <i>// exposition only</i>
    range_difference_t&lt;V&gt; <i>n_</i>;           <i>// exposition only</i>
    [&hellip;]
  public:
    constexpr explicit slide_view(V base, range_difference_t&lt;V&gt; n);

    <ins>constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return <i>base_</i>; }</ins>
    <ins>constexpr V base() &amp;&amp; { return std::move(<i>base_</i>); }</ins>
    [&hellip;]
  };
  [&hellip;]
}
</pre>
  </blockquote>
  </blockquote>
  </li>

</ol>





<hr>
<h3><a name="3849" href="3849">3849.</a> <tt>cartesian_product_view::<i>iterator</i></tt>'s default constructor is overconstrained</h3>
<p><b>Section:</b> 99 [ranges.cartesian.iterator] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-06 <b>Last modified:</b> 2023-02-01 20:33:52 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ranges.cartesian.iterator">active issues</a> in [ranges.cartesian.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#ranges.cartesian.iterator">issues</a> in [ranges.cartesian.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <tt>cartesian_product_view::<i>iterator</i></tt> only provides
the default constructor when the first range models <tt>forward_range</tt>,
which seems too restrictive since several input iterators like
<tt>istream_iterator</tt> are still default-constructible.
</p>
<p>
It would be more appropriate to constrain the default constructor
only by whether the underlying iterator satisfies
<tt>default_initializable</tt>, as most other range adaptors do.
Since <tt>cartesian_product_view::<i>iterator</i></tt> contains
a <tt>tuple</tt> member that already has a constrained default constructor,
the proposed resolution simply removes the constraint.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>



<p id="res-3849"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 99 [ranges.cartesian.iterator] as indicated:</p>
<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;)
  template&lt;bool Const&gt;
  class cartesian_product_view&lt;First, Vs...&gt;::<i>iterator</i> {
  public:
    [&hellip;]
    iterator() <del>requires forward_range&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt;</del> = default;
    [&hellip;]
  private:
    using Parent = <i>maybe-const</i>&lt;Const, cartesian_product_view&gt;;          <i>// exposition only</i>
    Parent* <i>parent_</i> = nullptr;                                          <i>// exposition only</i>
    tuple&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt;,
      iterator_t&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;...&gt; <i>current_</i>;                  <i>// exposition only</i>
    [&hellip;]
  };
}
</pre>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3850" href="3850">3850.</a> <tt>views::as_const</tt> on <tt>empty_view&lt;T&gt;</tt> should return <tt>empty_view&lt;const T&gt;</tt></h3>
<p><b>Section:</b> 26.7.21.1 <a href="https://timsong-cpp.github.io/cppwp/range.as.const.overview">[range.as.const.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-06 <b>Last modified:</b> 2023-02-01 20:35:14 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.as.const.overview">active issues</a> in [range.as.const.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.as.const.overview">issues</a> in [range.as.const.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, applying <tt>views::as_const</tt> to an <tt>empty_view&lt;int&gt;</tt>
will result in an <tt>as_const_view&lt;empty_view&lt;int&gt;&gt;</tt>,
and its iterator type will be <tt>basic_const_iterator&lt;int*&gt;</tt>.
</p>
<p>
This amount of instantiation is not desirable for such a simple view,
in which case simply returning <tt>empty_view&lt;const int&gt;</tt> should be enough.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p id="res-3850"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 26.7.21.1 <a href="https://timsong-cpp.github.io/cppwp/range.as.const.overview">[range.as.const.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <tt>views::as_const</tt> denotes a range adaptor object (26.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>). 
Let <tt>E</tt> be an expression, let <tt>T</tt> be <tt>decltype((E))</tt>, and let <tt>U</tt> be 
<tt>remove_cvref_t&lt;T&gt;</tt>. The expression <tt>views::as_const(E)</tt> is expression-equivalent
to:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <tt>views::all_t&lt;T&gt;</tt> models <tt>constant_range</tt>, then <tt>views::all(E)</tt>.</p></li>
<li><p><ins>(2.?) &mdash; Otherwise, if <tt>U</tt> denotes <tt>empty_view&lt;X&gt;</tt> for some type <tt>X</tt>, then <tt>auto(views::empty&lt;const X&gt;)</tt>.</ins></p></li>
<li><p>(2.2) &mdash; Otherwise, if <tt>U</tt> denotes <tt>span&lt;X, Extent&gt;</tt> for some type <tt>X</tt> and some 
extent <tt>Extent</tt>, then <tt>span&lt;const X, Extent&gt;(E)</tt>.</p></li>
<li><p>(2.3) &mdash; Otherwise, if <tt>E</tt> is an lvalue, <tt>const U</tt> models <tt>constant_range</tt>, and 
<tt>U</tt> does not model <tt>view</tt>, then <tt>ref_view(static_cast&lt;const U&amp;&gt;(E))</tt>.</p></li>
<li><p>(2.4) &mdash; Otherwise, <tt>as_const_view(E)</tt>.</p></li>
</ol>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3851" href="3851">3851.</a> <tt>chunk_view::<i>inner-iterator</i></tt> missing custom <tt>iter_move</tt> and <tt>iter_swap</tt></h3>
<p><b>Section:</b> 26.7.27.5 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.inner.iter">[range.chunk.inner.iter]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-06 <b>Last modified:</b> 2023-02-01 20:36:59 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For the input version of <tt>chunk_view</tt>,
its <tt><i>inner-iterator</i>::operator*()</tt> simply 
dereferences the underlying input iterator.
However, there are no customized <tt>iter_move</tt> and <tt>iter_swap</tt>
overloads for the <tt><i>inner-iterator</i></tt>,
which prevents customized behavior when applying <tt>views::chunk</tt>
to a range whose iterator type is a proxy iterator,
<a href="https://godbolt.org/z/ETh5o6GYj">for example</a>:
</p>
<pre>
    #include &lt;algorithm&gt;
    #include &lt;cassert&gt;
    #include &lt;ranges&gt;
    #include &lt;sstream&gt;
    #include &lt;vector&gt;

    int main() {
      auto ints = std::istringstream{"0 1 2 3 4"};
      std::vector&lt;std::string&gt; vs{"the", "quick", "brown", "fox"};
      auto r = std::views::zip(vs, std::views::istream&lt;int&gt;(ints))
              | std::views::chunk(2)
              | std::views::join;
      std::vector&lt;std::tuple&lt;std::string, int&gt;&gt; res;
      std::ranges::copy(std::move_iterator(r.begin()), std::move_sentinel(r.end()), 
                        std::back_inserter(res));
      assert(vs.front().empty()); // <span style="color:red;font-weight:bolder">assertion failed</span>
    }
</pre>
<p>
<tt>zip</tt> iterator has a customized <tt>iter_move</tt> behavior,
but since there is no <tt>iter_move</tt> specialization for
<tt><i>inner-iterator</i></tt>,
when we try to move elements in <tt>chunk_view</tt>,
<tt>move_iterator</tt> will fallback to use the default implementation of
<tt>iter_move</tt>, making <tt>string</tt>s not moved as expected
from the original <tt>vector</tt> but copied instead.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p id="res-3851"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 26.7.27.5 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.inner.iter">[range.chunk.inner.iter]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view&lt;V&gt;::<i>inner-iterator</i> {
    chunk_view* <i>parent_</i>;                                                <i>// exposition only</i>

    constexpr explicit <i>inner-iterator</i>(chunk_view&amp; parent) noexcept;     <i>// exposition only</i>

  public:
    [&hellip;]
    friend constexpr difference_type operator-(default_sentinel_t y, const <i>inner-iterator</i>&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    friend constexpr difference_type operator-(const <i>inner-iterator</i>&amp; x, default_sentinel_t y)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;

<ins>    friend constexpr range_rvalue_reference_t&lt;V&gt; iter_move(const <i>inner-iterator</i>&amp; i)
      noexcept(noexcept(ranges::iter_move(*i.<i>parent_</i>-><i>current_</i>)));

    friend constexpr void iter_swap(const <i>inner-iterator</i>&amp; x, const <i>inner-iterator</i>&amp; y)
      noexcept(noexcept(ranges::iter_swap(*x.<i>parent_</i>-><i>current_</i>, *y.<i>parent_</i>-><i>current_</i>)))
      requires indirectly_swappable&lt;iterator_t&lt;V&gt;&gt;;</ins>
  };
}
</pre>
</blockquote>
[&hellip;]
<pre><ins>friend constexpr range_rvalue_reference_t&lt;V&gt; iter_move(const <i>inner-iterator</i>&amp; i)
  noexcept(noexcept(ranges::iter_move(*i.<i>parent_</i>-><i>current_</i>)));</ins>
</pre>
<blockquote>
<p>
<ins>
-?- <i>Effects:</i> Equivalent to: <tt>return ranges::iter_move(*i.<i>parent_</i>-><i>current_</i>);</tt>
</ins>
</p>
</blockquote>
<pre><ins>friend constexpr void iter_swap(const <i>inner-iterator</i>&amp; x, const <i>inner-iterator</i>&amp; y)
  noexcept(noexcept(ranges::iter_swap(*x.<i>parent_</i>-><i>current_</i>, *y.<i>parent_</i>-><i>current_</i>)))
  requires indirectly_swappable&lt;iterator_t&lt;V&gt;&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>
-?- <i>Effects:</i> Equivalent to: <tt>ranges::iter_swap(*x.<i>parent_</i>-><i>current_</i>, *y.<i>parent_</i>-><i>current_</i>)</tt>.
</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3853" href="3853">3853.</a> <tt>basic_const_iterator&lt;volatile int*&gt;::operator-&gt;</tt> is ill-formed</h3>
<p><b>Section:</b> 25.5.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators">[const.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-06 <b>Last modified:</b> 2023-02-01 20:39:10 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#const.iterators">active issues</a> in [const.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#const.iterators">issues</a> in [const.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <tt>basic_const_iterator::operator-&gt;</tt> constrains the value type
of the underlying iterator to be only the <i>cv</i>-unqualified type of its reference type, 
which is true for raw pointers.
</p>
<p>
However, since it also explicitly specifies returning a pointer to a <tt>const</tt> value type,
this will cause a hard error when the value type is actually <tt>volatile</tt>-qualified:
</p>
<blockquote>
<pre>
std::basic_const_iterator&lt;volatile int*&gt; it;
auto* p = it.operator-&gt;(); // <span style="color:red;font-weight:bolder">invalid conversion from 'volatile int*' to 'const int*'</span>
</pre>
</blockquote>
<p>
The proposed resolution changes the return type from <tt>const value_type*</tt>
to <tt>const auto*</tt>,
which makes it deduce the correct type in the above example,
i.e. <tt>const volatile int*</tt>.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3853"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 25.5.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators">[const.iterators]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class I&gt;
    concept <i>not-a-const-iterator</i> = <i>see below</i>;

  template&lt;input_iterator Iterator&gt;
  class basic_const_iterator {
    Iterator <i>current_</i> = Iterator();                             // <i>exposition only</i>
    using <i>reference</i> = iter_const_reference_t&lt;Iterator&gt;;         // <i>exposition only</i>
  
  public:
    [&hellip;]
    constexpr <i>reference</i> operator*() const;
    constexpr const <ins>auto</ins><del>value_type</del>* operator-&gt;() const
       requires is_lvalue_reference_v&lt;iter_reference_t&lt;Iterator&gt;&gt; &amp;&amp;
                same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;Iterator&gt;&gt;, value_type&gt;;
    [&hellip;]
  };
}
</pre>
[&hellip;]
<pre>
constexpr const <ins>auto</ins><del>value_type</del>* operator-&gt;() const
  requires is_lvalue_reference_v&lt;iter_reference_t&lt;Iterator&gt;&gt; &amp;&amp;
           same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;Iterator&gt;&gt;, value_type&gt;;
</pre>
<p>
-7- <i>Returns</i>: If <tt>Iterator</tt> models <tt>contiguous_iterator</tt>, <tt>to_address(<i>current_</i>)</tt>; otherwise, 
<tt>addressof(*<i>current_</i>)</tt>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3857" href="3857">3857.</a> <tt>basic_string_view</tt> should allow explicit conversion when only traits vary</h3>
<p><b>Section:</b> 23.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.cons">[string.view.cons]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2023-01-10 <b>Last modified:</b> 2023-02-01 20:47:37 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view.cons">issues</a> in [string.view.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>basic_string_view</tt> has a constructor that converts appropriate contiguous ranges to <tt>basic_string_view</tt>. 
This constructor accepts an argument by forwarding reference (<tt>R&amp;&amp;</tt>), and has several constraints 
including that specified in 23.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.cons">[string.view.cons]</a>/12.6: 
</p>
<blockquote><p>
if the <i>qualified-id</i> <tt>remove_reference_t&lt;R&gt;::traits_type</tt> is valid and denotes a type, 
<tt>is_same_v&lt;remove_reference_t&lt;R&gt;::traits_type, traits&gt;</tt> is <tt>true</tt>. 
</p></blockquote>
<p>
This constraint prevents conversions from <tt>basic_string_view&lt;C, T1&gt;</tt> and <tt>basic_string&lt;C, T1, A&gt;</tt> 
to <tt>basic_string_view&lt;C, T2&gt;</tt>. Preventing such seemingly semantic-affecting conversions from happening 
implicitly was a good idea, but since the constructor was changed to be explicit it no longer seems necessary to 
forbid these conversions. If a user wants to convert a <tt>basic_string_view&lt;C, T2&gt;</tt> to 
<tt>basic_string_view&lt;C, T1&gt;</tt> with <tt>static_cast&lt;basic_string_view&lt;C, T1&gt;&gt;(meow)</tt>
instead of by writing out <tt>basic_string_view&lt;C, T1&gt;{meow.data(), meow.size()}</tt> that seems fine to me.
Indeed, if we think conversions like this are so terribly dangerous we probably shouldn't be performing them ourselves 
in 22.14.8.1 <a href="https://timsong-cpp.github.io/cppwp/format.arg">[format.arg]</a>/9 and 22.14.8.1 <a href="https://timsong-cpp.github.io/cppwp/format.arg">[format.arg]</a>/10.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p id="res-3857"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 23.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.cons">[string.view.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R&gt;
  constexpr explicit basic_string_view(R&amp;&amp; r);
</pre>
<blockquote>
<p>
-11- Let <tt>d</tt> be an lvalue of type <tt>remove_cvref_t&lt;R&gt;</tt>.
<p/>
-12- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(12.1) &mdash; <tt>remove_cvref_t&lt;R&gt;</tt> is not the same type as <tt>basic_string_view</tt>,</p></li>
<li><p>(12.2) &mdash; <tt>R</tt> models <tt>ranges::contiguous_range</tt> and <tt>ranges::sized_range</tt>,</p></li>
<li><p>(12.3) &mdash; <tt>is_same_v&lt;ranges::range_value_t&lt;R&gt;, charT&gt;</tt> is <tt>true</tt>,</p></li>
<li><p>(12.4) &mdash; <tt>is_convertible_v&lt;R, const charT*&gt;</tt> is <tt>false</tt>, <ins>and</ins></p></li>
<li><p>(12.5) &mdash; <tt>d.operator ::std::basic_string_view&lt;charT, traits&gt;()</tt> is not a valid expression<del>, and</del><ins>.</ins></p></li>
<li><p><del>(12.6) &mdash; if the <i>qualified-id</i> <tt>remove_reference_t&lt;R&gt;::traits_type</tt> is valid and denotes a type, 
<tt>is_same_v&lt;remove_reference_t&lt;R&gt;::traits_type, traits&gt;</tt> is <tt>true</tt>.</del></p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





</body>
</html>
