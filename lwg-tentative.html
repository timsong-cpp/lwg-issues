<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2019-11-06 at 19:04:02 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="2155" href="2155">2155.</a> Macro <tt>__bool_true_false_are_defined</tt> should be removed</h3>
<p><b>Section:</b> 17.13 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2012-04-30 <b>Last modified:</b> 2019-03-23 12:04:39 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Since C99, the C standard describes a macro named  <tt>__bool_true_false_are_defined</tt>.
<p/>
In the process of harmonizing C++11 with C99, this name became part of the C++ standard.
<p/>
I propose that all mention of this name should be removed from the C and C++ standards.
<p/>
Here's the problem: The name was originally proposed as a transition tool, so that the headers for a 
project could contain lines like the following.
</p>
<blockquote><pre>
#if !defined(__bool_true_false_are_defined)
#define bool int /* or whatever */
#define true 1
#define false 0
#endif
</pre></blockquote>
<p>
Then when the project was compiled by a "new" compiler that implemented <tt>bool</tt> as defined by the 
evolving C++98 or C99 standards, those lines would be skipped; but when compiled by an "old" compiler that 
didn't yet provide <tt>bool</tt>, <tt>true</tt>, and <tt>false</tt>, then the <tt>#define</tt>'s would provide a
simulation that worked for most purposes.
<p/>
It turns out that there is an unfortunate ambiguity in the name.  One interpretation is as shown above, but 
a different reading says "bool, true, and false are #define'd", i.e. that the meaning of the macro is to
assert that these names are macros (not built-in) ... which is true in C, but not in C++.
<p/>
In C++11, the name appears in parentheses followed by a stray period, so
some editorial change is needed in any event:
<p/>
17.13 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> para 1:
</p>
<blockquote><p>
Headers <tt>&lt;csetjmp&gt;</tt> (nonlocal jumps), <tt>&lt;csignal&gt;</tt> (signal handling), <tt>&lt;cstdalign&gt;</tt> 
(alignment), <tt>&lt;cstdarg&gt;</tt> (variable arguments), <tt>&lt;cstdbool&gt;</tt> (<tt>__bool_true_false_are_defined</tt>). 
<tt>&lt;cstdlib&gt;</tt> (runtime environment <tt>getenv()</tt>, <tt>system()</tt>), and <tt>&lt;ctime&gt;</tt> 
(system clock <tt>clock()</tt>, <tt>time()</tt>) provide further compatibility with C code.
</p></blockquote>
<p>
However, para 2 says
</p>
<blockquote><p>
"The contents of these headers are the same as the Standard C library headers <tt>&lt;setjmp.h&gt;</tt>, 
<tt>&lt;signal.h&gt;</tt>, <tt>&lt;stdalign.h&gt;</tt>, <tt>&lt;stdarg.h&gt;</tt>, <tt>&lt;stdbool.h&gt;</tt>, 
<tt>&lt;stdlib.h&gt;</tt>, and <tt>&lt;time.h&gt;</tt>, respectively, with the following 
changes:",
</p></blockquote>
<p>
and para 8 says 
</p>
<blockquote><p>
"The header <tt>&lt;cstdbool&gt;</tt> and the header <tt>&lt;stdbool.h&gt;</tt> shall 
not define macros named <tt>bool</tt>, <tt>true</tt>, or <tt>false</tt>."
</p></blockquote>
<p>
Thus para 8 doesn't exempt the C++ implementation from the arguably clear requirement of the C standard, to 
provide a macro named <tt>__bool_true_false_are_defined</tt> defined to be 1.
<p/>
Real implementations of the C++ library differ, so the user cannot count upon any consistency; furthermore, the 
usefulness of the transition tool has faded long ago.
<p/>
That's why my suggestion is that both C and C++ standards should eliminate any mention of 
<tt>__bool_true_false_are_defined</tt>.  In that case, the name belongs to implementers to provide, or not, as 
they choose.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
While not strictly necessary, the clean-up look good.
</p>
<p>
We would like to hear from our C liaison before moving on this issue though.
</p>

<p><i>[2015-05 Lenexa]</i></p>

<p>
LWG agrees. Jonathan provides wording.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>The reference to &lt;cstdbool&gt; in p2 needs to be struck as well. Continue the discussion on the reflector once the DIS is available.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4296.</p>

<ol>
<li>
<p>Edit the footnote on 16.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a> p7:</p>
<blockquote>
<p>
176) In particular, including <ins>any of</ins> the standard header<ins>s <tt>&lt;stdbool.h&gt;</tt>, <tt>&lt;cstdbool&gt;</tt>,</ins> <tt>&lt;iso646.h&gt;</tt> or <tt>&lt;ciso646&gt;</tt> has no effect.
</p>
</blockquote>
</li>

<li>
<p>Edit 17.13 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> p1 as indicated (and remove the index entry for <tt>__bool_true_false_are_defined</tt>):</p>

<blockquote>
<p>
-1- Headers <tt>&lt;csetjmp&gt;</tt> (nonlocal jumps), <tt>&lt;csignal&gt;</tt> (signal handling), <tt>&lt;cstdalign&gt;</tt> (alignment), <tt>&lt;cstdarg&gt;</tt> (variable arguments), <tt>&lt;cstdbool&gt;</tt><ins>,</ins><del> (<tt>__bool_true_false_are_defined</tt>).</del> <tt>&lt;cstdlib&gt;</tt> (runtime environment <tt>getenv()</tt>, <tt>system()</tt>), and <tt>&lt;ctime&gt;</tt> (system clock <tt>clock()</tt>, <tt>time()</tt>) provide further compatibility with C code.
</p>
</blockquote>
</li>

<li>
<p>Remove Table 38 &mdash; Header <tt>&lt;cstdbool&gt;</tt> synopsis [tab:support.hdr.cstdbool] from 17.13 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> </p>
<blockquote>
<table border="1">
<caption> Table 38 &mdash; Header <tt>&lt;cstdbool&gt;</tt> synopsis </caption>
<tr><td><b>Type</b></td><td><b>Name(s)</b></td></tr>
<tr><td><b>Macro:</b></td><td><tt>__bool_true_false_are_defined</tt></td></tr>
</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-03-18; Daniel comments and eliminates previously proposed wording]</i></p>

<p>
With the approval of <a href="http://wg21.link/p0619r4">P0619R4</a> in Rapperswil, the offending wording has now been eliminated 
from the working draft. I suggest to close this issue as: Resolved by <a href="http://wg21.link/p0619r4">P0619R4</a>.
</p>


<p><b>Rationale:</b></p>
Resolved by <a href="http://wg21.link/p0619r4">P0619R4</a>.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2292" href="2292">2292.</a> Find a better phrasing for "shall not participate in overload resolution"</h3>
<p><b>Section:</b> 16.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2013-09-03 <b>Last modified:</b> 2019-03-22 17:52:05 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++14 CD has 25 sections including the phrase "X shall not
participate in overload resolution ...". Most of these uses are double
negatives, which are hard to interpret. "shall not ... unless" tends
to be the easiest to read, since the condition is true when the
function is available, but we also have a lot of "if X is not Y, then
Z shall not participate", which actually means "You can call Z if X is
Y." The current wording is also clumsy and long-winded. We should find
a better and more concise phrasing.
<p/>
As an initial proposal, I'd suggest using "X is enabled if and only if Y" in prose
and adding an "<i>Enabled If:</i> ..." element to 16.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>.
<p/>
Daniel:
<p/>
I suggest to name this new specification element for 16.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>
as "<i>Template Constraints:</i>" instead, because the mentioned wording form was intentionally provided 
starting with LWG <a href="1237">1237</a> to give implementations more freedom to realize the 
concrete constraints. Instead of the original <tt>std::enable_if</tt>-based specifications
we can use better forms of "SFINAE" constraints today and it eases the path to possible language-based
constraints in the future.
</p>

<p><i>[2019-03-21; Daniel comments ]</i></p>

<p>
Apparently the adoption of <a href="http://wg21.link/p0788r3">P0788R3</a> at the Rapperswil 2018 meeting 
has resolved this issue by introduction of the new <i>Constraints:</i> element.
</p>



<p><b>Rationale:</b></p>
Resolved by <a href="http://wg21.link/p0788r3">P0788R3</a>.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2808" href="2808">2808.</a> Requirements for <tt>fpos</tt> and <tt>stateT</tt></h3>
<p><b>Section:</b> 29.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2019-03-22 17:53:09 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fpos.operations">active issues</a> in [fpos.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#fpos.operations">issues</a> in [fpos.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses GB 60</b>
</p>
<p>
The requirements on the <tt>stateT</tt> type used 
to instantiate class template <tt>fpos</tt> are not 
clear, and the following Table 108 &mdash; "Position 
type requirements" is a bit of a mess. This is 
old wording, and should be cleaned up with better
terminology from the Clause 17 Requirements. For example, 
<tt>stateT</tt> might be require <tt>CopyConstructible</tt>?, 
<tt>CopyAssignable</tt>?, and <tt>Destructible</tt>. Several 
entries in the final column of the table appear to be 
post-conditions, but without the <tt>post</tt> markup to 
clarify they are not assertions or preconditions. They 
frequently refer to identifiers that do not apply to all 
entries in their corresponding <tt>Expression</tt> 
column, leaving some expressions without a clearly defined semantic.
If <tt>stateT</tt> is a trivial type, is <tt>fpos</tt> also a 
trivial type, or is a default constructor not required/supported?
</p>
<p>
Proposed change:
<p/>
Clarify the requirements and the table.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 4; no consensus for any concrete change</p>

<p><i>[2019-03-17; Daniel comments]</i></p>

<p>
With the acceptance of <a href="http://wg21.link/p0759r1">P0759R1</a> at the Rapperswil 2018 meeting
this issue should be closed as <b>Resolved</b> (Please note that this paper resolves a historic
NB comment that was originally written against C++17 but was at that time responded: "invite a paper 
if anybody wants to change it - no concensus for change").
</p>


<p><b>Rationale:</b></p>
Resolved by <a href="http://wg21.link/p0759r1">P0759R1</a>.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2832" href="2832">2832.</a> &sect;[fpos.operations] strange requirement for <tt>P(i)</tt></h3>
<p><b>Section:</b> 29.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-11-24 <b>Last modified:</b> 2019-03-22 17:53:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fpos.operations">active issues</a> in [fpos.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#fpos.operations">issues</a> in [fpos.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is from editorial issue <a href="https://github.com/cplusplus/draft/issues/1031">#1031</a>.
<p/>
The first row in Table 112 "Position type requirements"
talks about the expression <tt>P(i)</tt> and then has an assertion
<tt>p == P(i)</tt>.  However, there are no constraints on <tt>p</tt>
other than being of type <tt>P</tt>, so (on the face of it) this
seems to require that <tt>operator==</tt> on <tt>P</tt> always returns
true, which is non-sensical.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>

<p><i>[2019-03-17; Daniel comments]</i></p>

<p>
With the acceptance of <a href="http://wg21.link/p0759r1">P0759R1</a> at the Rapperswil 2018 meeting
this issue should be closed as <b>Resolved</b>.
</p>


<p><b>Rationale:</b></p>
Resolved by <a href="http://wg21.link/p0759r1">P0759R1</a>.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2999" href="2999">2999.</a> &sect;[thread.decaycopy] issue</h3>
<p><b>Section:</b> 16.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/expos.only.func">[expos.only.func]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2017-07-11 <b>Last modified:</b> 2019-06-18 01:53:18 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[thread.decaycopy] says:
</p>
<blockquote><p>
In several places in this Clause the operation <tt><i>DECAY_COPY</i>(x)</tt> is used. All such uses mean call the function 
<tt>decay_copy(x)</tt> and use the result, where <tt>decay_copy</tt> is defined as follows:
</p></blockquote>
<p>
but <tt>decay_copy</tt> is not defined in any synopsis.
<p/>
The Ranges TS has a similar use of <tt><i>DECAY_COPY</i></tt>, except that theirs is also <tt>constexpr</tt> and <tt>noexcept</tt>.
<p/>
We should mark the function <tt>decay_copy</tt> as "exposition only" and <tt>constexpr</tt> and <tt>noexcept</tt>.
</p>

<p><i>[2017-07-16, Daniel comments]</i></p>

<p>
Currently there exists no proper way to mark <tt>decay_copy</tt> as conditionally <tt>noexcept</tt> as explained in
<a href="http://wg21.link/n3255#Adding">N3255 section "Adding to the Standard"</a>. This is also slighly related to 
the request to add an <tt>is_nothrow_convertible</tt> trait, as requested by LWG <a href="2040">2040</a>.
</p>

<p><i>[
2017-11-01 P3 as result of c++std-lib online vote.
]</i></p>


<p><i>[2019-03-22; Daniel comments]</i></p>

<p>
Starting with <a href="http://wg21.link/n4800">N4800</a> have now a <tt>constexpr</tt> and conditionally <tt>noexcept</tt> 
<tt><i>decay-copy</i></tt> in the working draft (16.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/expos.only.func">[expos.only.func]</a>). The pre-condition for that specification 
helper became possible by adoption of <a href="http://wg21.link/p0758r1">P0758R1</a>, which introduced the missing
<tt>is_nothrow_convertible</tt> trait.
</p>


<p><b>Rationale:</b></p>
Resolved by editorial creation of <tt><i>decay-copy</i></tt> after acceptance of <a href="http://wg21.link/p0758r1">P0758R1</a>.


<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="3178" href="3178">3178.</a> <tt>std::mismatch</tt> is missing an upper bound</h3>
<p><b>Section:</b> 25.5.10 <a href="https://timsong-cpp.github.io/cppwp/mismatch">[mismatch]</a> <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2018-12-20 <b>Last modified:</b> 2019-03-24 16:07:34 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#mismatch">issues</a> in [mismatch].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following code:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v1 = {1, 2, 3, 4};
std::vector&lt;int&gt; v2 = {1, 2, 3, 5};
auto result = std::mismatch(v1.begin(), v1.begin() + 2, v2.begin(), v2.begin() + 2);
</pre></blockquote>
<p>
The current wording of [mismatch] seems to require <tt>result</tt> to be <tt>{v1.begin() + 3, v2.begin() + 3}</tt>, because 3
is the smallest integer <tt>n</tt> such that <tt>*(v1.begin() + n) != *(v2.begin + n)</tt>. In other words, if there's a
mismatch that's reachable from <tt>first1</tt> and <tt>first2</tt>, then <tt>std::mismatch</tt> must find and return it,
even if it's beyond the end iterators passed by the user.
<p/>
This is doubly unimplementable: the library has no way of knowing that it's safe to keep going past the end of the user-supplied
range, and even if it could, doing so would violate the complexity requirements. More importantly, it would violate the
fundamental convention that STL algorithms operate on user-supplied ranges, not on the underlying containers.
</p>

<p><i>[2019-01-26 Priority to 0 and Status to Tentatively Ready after discussions on the reflector]</i></p>

<p>
During that reflector discussion several contributers argued in favour for changing the current wording in
25.5.10 <a href="https://timsong-cpp.github.io/cppwp/mismatch">[mismatch]</a> p3 from "smallest integer" to "smallest <ins>nonnegative</ins> integer". This minor 
wording delta has also been added to the original proposed wording.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<ol>
<li><p>Change 25.5.10 <a href="https://timsong-cpp.github.io/cppwp/mismatch">[mismatch]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class InputIterator1, class InputIterator2&gt;
  constexpr pair&lt;InputIterator1, InputIterator2&gt;
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2);
[&hellip;]
namespace ranges {
  template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
           class Proj1 = identity, class Proj2 = identity,
           IndirectRelation&lt;projected&lt;I1, Proj1&gt;,
           projected&lt;I2, Proj2&gt;&gt; Pred = ranges::equal_to&lt;&gt;&gt;
    constexpr mismatch_result&lt;I1, I2>
      mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
  template&lt;InputRange R1, InputRange R2,
           class Proj1 = identity, class Proj2 = identity,
           IndirectRelation&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
           projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt; Pred = ranges::equal_to&lt;&gt;&gt;
    constexpr mismatch_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;&gt;
      mismatch(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
}
</pre>
<blockquote>
<p>
-1- Let <tt>last2</tt> be <tt>first2 + (last1 - first1)</tt> for the overloads with no parameter <tt>last2</tt> or <tt>r2</tt>.
<p/>
-2- Let <tt><i>E</i></tt> be:
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <tt>!(*(first1 + n) == *(first2 + n))</tt> for the overloads with no parameter <tt>pred</tt>,</p></li>
<li><p>(2.2) &mdash; <tt>pred(*(first1 + n), *(first2 + n)) == false</tt> for the overloads with a parameter <tt>pred</tt> and
no parameter <tt>proj1</tt>,</p></li>
<li><p>(2.3) &mdash; <tt>!invoke(pred, invoke(proj1, *(first1 + n)), invoke(proj2, *(first2 + n)))</tt> for the overloads with
both parameters <tt>pred</tt> and <tt>proj1</tt>.</p></li>
</ol>
<ins>-?- Let <tt><i>N</i></tt> be <tt>min(last1 - first1, last2 - first2)</tt>.</ins>
<p/>
-3- <i>Returns:</i> <tt>{ first1 + n, first2 + n }</tt>, where <tt>n</tt> is the smallest <ins>nonnegative</ins> integer such 
that <tt><i>E</i></tt> holds, or <tt><del>min(last1 - first1, last2 - first2)</del><ins><i>N</i></ins></tt> if no such integer 
<ins>less than <tt><i>N</i></tt></ins> exists.
<p/>
-4- <i>Complexity:</i> At most <tt><del>min(last1 - first1, last2 - first2)</del><ins><i>N</i></ins></tt> applications of the
corresponding predicate and any projections.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-03-15; Daniel comments]</i></p>

<p>
The <a href="https://github.com/cplusplus/draft/issues/2611">editorial issue #2611</a> had been
resolved via this <a href="https://github.com/cplusplus/draft/pull/2613">pull request #2613</a>.
The editorial changes should make the suggested wording changes obsolete and I recommend to close
this issue as <b>Resolved</b>.
</p>


<p><b>Rationale:</b></p>
Resolved by editorial <a href="https://github.com/cplusplus/draft/pull/2613">pull request #2613</a>.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3207" href="3207">3207.</a> <tt>N</tt> in <tt>ssize(const T (&amp;)[N])</tt> should be <tt>size_t</tt></h3>
<p><b>Section:</b> 23.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2019-05-23 <b>Last modified:</b> 2019-06-10 05:16:56 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>Discussion:</b></p>
<p>
The <tt>N</tt> in <tt>ssize(const T (&amp;)[N])</tt> is specified to be of type <tt>ptrdiff_t</tt>.  
It should be <tt>size_t</tt> to be consistent with the rest of the standard library, such as the
array overloads for all other range access functions, the <tt>swap</tt> overload for arrays, and
other function template overloads for arrays. (Note: the return type of this function should still 
be <tt>ptrdiff_t</tt>.)
</p>

<p><i>[2019-06-12 Tentatively NAD after reflector discussion]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 23.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, <del>ptrdiff</del><ins>size</ins>_t N&gt; constexpr ptrdiff_t ssize(const T (&amp;array)[N]) noexcept;
</pre>
<blockquote>
<p>
-19- <i>Returns:</i> <tt><ins>static_cast&lt;ptrdiff_t&gt;(</ins>N<ins>)</ins></tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3284" href="3284">3284.</a> <tt>random_access_iterator</tt> semantic constraints accidentally promote difference type
 using unary negate</h3>
<p><b>Section:</b> 23.3.4.13 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.random.access">[iterator.concept.random.access]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2019-09-10 <b>Last modified:</b> 2019-10-12 11:33:15 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.concept.random.access">active issues</a> in [iterator.concept.random.access].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.concept.random.access">issues</a> in [iterator.concept.random.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.3.4.13 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.random.access">[iterator.concept.random.access]</a>/p2.7 says:
</p>
<blockquote><p>
<tt>(b += -n)</tt> is equal to <tt>a</tt>
</p></blockquote>
<p>
Unary minus can do integer promotion. That is not the intent here.
</p>

<p><i>[2019-10-12 Issue Prioritization]</i></p>

<p>Status to Tentatively Ready and priority to 0 after five positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 23.3.4.13 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.random.access">[iterator.concept.random.access]</a> as indicated:</p>

<blockquote>
<p>
-2- Let <tt>a</tt> and <tt>b</tt> be valid iterators of type <tt>I</tt> such that <tt>b</tt> 
is reachable from <tt>a</tt> after <tt>n</tt> applications of <tt>++a</tt>, let <tt>D</tt> be
<tt>iter_difference_t&lt;I&gt;</tt>, and let <tt>n</tt> denote a value of type <tt>D</tt>. 
<tt>I</tt> models <tt>random_access_iterator</tt> only if:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <tt>(a += n)</tt> is equal to <tt>b</tt>.</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(2.7) &mdash; <tt>(b += <ins>D(</ins>-n<ins>)</ins>)</tt> is equal to <tt>a</tt>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3285" href="3285">3285.</a> The type of a customization point object shall satisfy <tt>semiregular</tt></h3>
<p><b>Section:</b> 16.4.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2019-09-10 <b>Last modified:</b> 2019-10-12 12:08:51 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We should be testing the un-<i>cv</i>-qualified type of a customization point object.
</p>

<p><i>[2019-10-12 Issue Prioritization]</i></p>

<p>Status to Tentatively Ready and priority to 0 after seven positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 16.4.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a> as indicated:</p>

<blockquote>
<p>
-2- The type of a customization point object <ins>ignoring <i>cv</i>-qualifiers</ins> shall 
model <tt>semiregular</tt> (18.6 <a href="https://timsong-cpp.github.io/cppwp/concepts.object">[concepts.object]</a>).
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3286" href="3286">3286.</a> <tt>ranges::size</tt> is not required to be valid after a call to <tt>ranges::begin</tt> on an input range</h3>
<p><b>Section:</b> 24.7.6.2 <a href="https://timsong-cpp.github.io/cppwp/range.take.view">[range.take.view]</a>, 24.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.ctor">[range.subrange.ctor]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2019-09-10 <b>Last modified:</b> 2019-10-12 11:45:31 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
On an input (but not forward) range, <tt>begin(rng)</tt> is not required to be an equality-preserving 
expression (24.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.range">[range.range]</a>/3.3). If the range is <em>also</em> sized, then it is not valid 
to call <tt>size(rng)</tt> after <tt>begin(rng)</tt> (24.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>/2.2). In several 
places in the ranges clause, this precondition is violated. A trivial re-expression of the effects 
clause fixes the problem.
</p>

<p><i>[2019-10-12 Issue Prioritization]</i></p>

<p>Status to Tentatively Ready and priority to 0 after seven positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 24.7.6.2 <a href="https://timsong-cpp.github.io/cppwp/range.take.view">[range.take.view]</a>, class template <tt>take_view</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
  class take_view : public view_interface&lt;take_view&lt;V&gt;&gt; {
  private:
    [&hellip;]
  public:
    [&hellip;]
    constexpr auto begin() requires (!<i>simple-view</i>&lt;V&gt;) {
      if constexpr (sized_range&lt;V&gt;) {
        if constexpr (random_access_range&lt;V&gt;)
          return ranges::begin(base_);
        else <ins>{
          auto sz = size();</ins>
          return counted_iterator{ranges::begin(base_), <del>size()</del><ins>sz</ins>};
        <ins>}</ins>
      } else
        return counted_iterator{ranges::begin(base_), count_};
    }

    constexpr auto begin() const requires range&lt;const V&gt; {
      if constexpr (sized_range&lt;const V&gt;) {
        if constexpr (random_access_range&lt;const V&gt;)
          return ranges::begin(base_);
        else <ins>{
          auto sz = size();</ins>
          return counted_iterator{ranges::begin(base_), <del>size()</del><ins>sz</ins>};
        <ins>}</ins>
      } else
        return counted_iterator{ranges::begin(base_), count_};
    }
    
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 24.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.ctor">[range.subrange.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>not-same-as</i>&lt;subrange&gt; R&gt;
  requires forwarding-range&lt;R&gt; &amp;&amp;
    convertible_to&lt;iterator_t&lt;R&gt;, I&gt; &amp;&amp; convertible_to&lt;sentinel_t&lt;R&gt;, S&gt;
constexpr subrange(R&amp;&amp; r) requires (!StoreSize || sized_range&lt;R&gt;);
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Equivalent to:
<ol style="list-style-type: none">
<li><p>(6.1) &mdash; If <tt>StoreSize</tt> is <tt>true</tt>, <tt>subrange{<del>ranges::begin(r), 
ranges::end(r)</del><ins>r</ins>, ranges::size(r)}</tt>.</p></li>
<li><p>(6.2) &mdash; Otherwise, <tt>subrange{ranges::begin(r), ranges::end(r)}</tt>.</p></li>
</ol>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3291" href="3291">3291.</a> <tt>iota_view::iterator</tt> has the wrong <tt>iterator_category</tt></h3>
<p><b>Section:</b> 24.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/range.iota.iterator">[range.iota.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2019-09-13 <b>Last modified:</b> 2019-11-01 11:03:56 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the old way of looking at the world, forward iterators need to return real references. Since 
dereferencing <tt>iota_view</tt>'s iterators returns by value, it cannot be a C++17 forward 
iterator. (It can, however, be a C++20 <tt>forward_iterator</tt>.) However, <tt>iota_view</tt>'s 
iterator has an <tt>iterator_category</tt> that (sometimes) falsely claims that it is forward or 
better (depending on the properties of the <tt>weakly_incrementable</tt> type it wraps).
</p>

<p><i>[2019-10-19 Issue Prioritization]</i></p>

<p>Status to Tentatively Ready and priority to 0 after eight positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 24.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/range.iota.iterator">[range.iota.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;class W, class Bound&gt;
  struct iota_view&lt;W, Bound&gt;::iterator {
  private:
    [&hellip;]
  public:
    using iterator_c<ins>oncept</ins><del>ategory</del> = <i>see below</i>;
    <ins>using iterator_category = input_iterator_tag;</ins>
    using value_type = W;
    using difference_type = <i>IOTA-DIFF-T</i>(W);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<p>
-1- <tt>iterator::iterator_c<ins>oncept</ins><del>ategory</del></tt> is defined as follows:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If <tt>W</tt> models <tt><i>advanceable</i></tt>, then 
<tt>iterator_c<ins>oncept</ins><del>ategory</del></tt> is <tt>random_access_iterator_tag</tt>.</p></li>
<li><p>(1.2) &mdash; Otherwise, if <tt>W</tt> models <tt><i>decrementable</i></tt>, then 
<tt>iterator_c<ins>oncept</ins><del>ategory</del></tt> is <tt>bidirectional_iterator_tag</tt>.</p></li>
<li><p>(1.3) &mdash; Otherwise, if <tt>W</tt> models <tt>incrementable</tt>, then 
<tt>iterator_c<ins>oncept</ins><del>ategory</del></tt> is <tt>forward_iterator_tag</tt>.</p></li>
<li><p>(1.4) &mdash; Otherwise, <tt>iterator_c<ins>oncept</ins><del>ategory</del></tt> is 
<tt>input_iterator_tag</tt>.</p></li>
</ol>

</blockquote>
</li>

</ol>





<hr>
<h3><a name="3294" href="3294">3294.</a> <tt>zoned_time</tt> deduction guides misinterprets <tt>string</tt>/<tt>char*</tt></h3>
<p><b>Section:</b> 27.11.7.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.zonedtime.overview">[time.zone.zonedtime.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2019-09-14 <b>Last modified:</b> 2019-10-31 18:54:10 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.zone.zonedtime.overview">active issues</a> in [time.zone.zonedtime.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.zone.zonedtime.overview">issues</a> in [time.zone.zonedtime.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current deduction guide for <code>zoned_time</code> for the following declarations
</p>
<blockquote>
<pre>
zoned_time zpc("America/New_York", std::chrono::system_clock::now());
zoned_time zps(std::string("America/New_York"), std::chrono::system_clock::now());
</pre>
</blockquote>
<p>
will attempt to produce a <code>zoned_time</code> instance with <code>const char*</code> 
(for <tt>zpc</tt>) and with <code>std::string</code> (for <tt>zps</tt>), respectively, 
as the deduced type for the <tt>TimeZonePtr</tt> template parameter. This is caused by 
the fact that the unconstrained <code>TimeZonePtr</code> deduction guide template will 
produce better candidates and will be selected by overload resolution.
<p/>
The proposed resolution merges the deduction of the 
<code>std::string_view</code>/<code>TimeZonePtr</code> deduction guides
into one guide, that deduces <code>const time_zone*</code> for any type
convertible to <code>string_view</code>. This is necessary to override
the deduction from <code>TimeZonePtr</code> constructor candidates.
<p/>
In addition, we disable the deduction from <code>string_view</code>
constructors, that would produce better candidates than the deduction guides
and create <code>zoned_time</code> instances with durations coarser than
<code>seconds</code> (causing similar issue as LWG <a href="3232">3232</a>):
</p>
<blockquote>
<pre>
std::chrono::local_time&lt;hours&gt; lh(10h);
std::chrono::zoned_time zt1("Europe/Helsinki", lh);
std::chrono::zoned_time zt2(std::string("Europe/Helsinki"), lh);
std::chrono::zoned_time zt3(std::string_view("Europe/Helsinki"), lh);
</pre>
</blockquote>
<p>
Without disabling the deduction from the <code>string_view</code>
constructor, the type of the <code>zt3</code> variable would be deduced to 
<code>zoned_time&lt;hours&gt;</code>, with the proposed change the types
of the variables <code>zt1</code>, <code>zt2</code>, and <code>zt3</code> 
are consistently deduced as <code>zoned_time&lt;seconds&gt;</code>.
<p/>
Finally, the wording eliminates the unnecessary <code>zoned_time&lt;Duration&gt;</code> 
guide (covered by <code>zoned_time&lt;Duration, TimeZonePtr2&gt;</code>).
<p/>
The change was implemented in the example implementation. The dedicated
test can be found 
<a href="https://github.com/HowardHinnant/date/blob/master/test/tz_test/zoned_time_deduction.pass.cpp">here</a>.
</p>

<p><i>[2019-10-31 Issue Prioritization]</i></p>

<p>Status to Tentatively Ready and priority to 0 after five positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 27.11.7.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.zonedtime.overview">[time.zone.zonedtime.overview]</a>, class template <tt>zoned_time</tt> 
synopsis, as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::chrono {
  [&hellip;]
  zoned_time() -&gt; zoned_time&lt;seconds&gt;;
  
  template&lt;class Duration&gt;
    zoned_time(sys_time&lt;Duration&gt;)
      -&gt; zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;;
      
  <ins>template&lt;class TimeZonePtrOrName&gt;
    using <i>time-zone-representation</i> =
      conditional_t&lt;is_convertible_v&lt;TimeZonePtrOrName, string_view&gt;, 
        const time_zone*,
        remove_cv_ref&lt;TimeZonePtrOrName&gt;&gt;; <i>// exposition only</i>

  template&lt;class TimeZonePtrOrName&gt;
    zoned_time(TimeZonePtrOrName&amp;&amp;)
      -&gt; zoned_time&lt;seconds, <i>time-zone-representation</i>&lt;TimeZonePtr&gt;&gt;;</ins>
  
  template&lt;class TimeZonePtr<ins>OrName</ins>, class Duration&gt;
    zoned_time(TimeZonePtr<ins>OrName&amp;&amp;</ins>, sys_time&lt;Duration&gt;)
      -&gt; zoned_time&lt;common_type_t&lt;Duration, seconds&gt;, 
        <ins><i>time-zone-representation</i>&lt;</ins>TimeZonePtr<ins>OrName&gt;</ins>&gt;;
  
  template&lt;class TimeZonePtr<ins>OrName</ins>, class Duration&gt;
    zoned_time(TimeZonePtr<ins>OrName&amp;&amp;</ins>, local_time&lt;Duration&gt;, choose = choose::earliest)
      -&gt; zoned_time&lt;common_type_t&lt;Duration, seconds&gt;, 
        <ins><i>time-zone-representation</i>&lt;</ins>TimeZonePtr<ins>OrName&gt;</ins>&gt;;
  
  <del>template&lt;class TimeZonePtr, class Duration&gt;
    zoned_time(TimeZonePtr, zoned_time&lt;Duration&gt;, choose = choose::earliest)
      -&gt;> zoned_time&lt;common_type_t&lt;Duration, seconds&gt;, TimeZonePtr&gt;;
  
  zoned_time(string_view) -&gt; zoned_time&lt;seconds&gt;;

  template&lt;class Duration&gt;
    zoned_time(string_view, sys_time&lt;Duration&gt;)
      -&gt; zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;;
  
  template&lt;class Duration&gt;
    zoned_time(string_view, local_time&lt;Duration&gt;, choose = choose::earliest)
      -&gt; zoned_time&lt;common_type_t&lt;Duration, seconds&gt;&gt;;</del>
  
  template&lt;class Duration, class TimeZonePtr<ins>OrName</ins>, class TimeZonePtr2&gt;
    zoned_time(TimeZonePtr<ins>OrName&amp;&amp;</ins>, zoned_time&lt;Duration, TimeZonePtr2&gt;, choose = choose::earliest)
     -&gt; zoned_time&lt;Duration, <ins><i>time-zone-representation</i>&lt;</ins>TimeZonePtr<ins>OrName&gt;</ins>&gt;;
}
</pre>
</blockquote>
<p>
-1- <tt>zoned_time</tt> represents a logical pairing of a <tt>time_zone</tt> and a <tt>time_point</tt> 
with precision <tt>Duration</tt>. <tt>zoned_time&lt;Duration&gt;</tt> maintains the invariant that it 
always refers to a valid time zone and represents a point in time that exists and is not ambiguous in 
that time zone.
<p/>
-2- If <tt>Duration</tt> is not a specialization of <tt>chrono::duration</tt>, the program is ill-formed.
<p/>
<ins>-?- Every constructor of <tt>zoned_time</tt> that accepts a <tt>string_view</tt> as first parameter 
does not participate in class template argument deduction (12.4.1.8 <a href="https://timsong-cpp.github.io/cppwp/over.match.class.deduct">[over.match.class.deduct]</a>).</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3296" href="3296">3296.</a> Inconsistent default argument for <tt>basic_regex&lt;&gt;::assign</tt></h3>
<p><b>Section:</b> 30.8 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Mark de Wever <b>Opened:</b> 2019-09-16 <b>Last modified:</b> 2019-10-31 18:49:00 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.regex">active issues</a> in [re.regex].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The declaration of the overload of <tt>basic_regex&lt;&gt;::assign(const charT* p, size_t len, flag_type f)</tt>
has an inconsistent default argument for the <tt>flag_type f</tt> parameter.
<p/>
30.8 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a> p3:
</p>
<blockquote><pre>
basic_regex&amp; assign(const charT* p, size_t len, flag_type f);
</pre></blockquote>
<p>
30.8.2 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a> before p12:
</p>
<blockquote><pre>
basic_regex&amp; assign(const charT* ptr, size_t len, flag_type f = regex_constants::ECMAScript);
</pre></blockquote>
<p>
Since all other overloads have a default argument in both 30.8 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a> and
30.8.2 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a> I propose to add a default argument for this overload
in the declaration in 30.8 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a>.
<p/>
It should be pointed out that there exists implementation divergence due to the current
wording state: libc++ and libstdc++ do <em>not</em> implement the default argument.
The MS STL library <em>does</em> have the default argument.
</p>

<p><i>[2019-10-31 Issue Prioritization]</i></p>

<p>Status to Tentatively Ready and priority to 0 after six positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 30.8 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a>, class template <tt>basic_regex</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 30.8.2 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a>, assign</i>
[&hellip;]
basic_regex&amp; assign(const charT* ptr, flag_type f = regex_constants::ECMAScript);
basic_regex&amp; assign(const charT* p, size_t len, flag_type f <ins>= regex_constants::ECMAScript</ins>);
template&lt;class string_traits, class A&gt;
  basic_regex&amp; assign(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
                      flag_type f = regex_constants::ECMAScript);
template&lt;class InputIterator&gt;
  basic_regex&amp; assign(InputIterator first, InputIterator last,
                      flag_type f = regex_constants::ECMAScript);
basic_regex&amp; assign(initializer_list&lt;charT&gt;,
                    flag_type = regex_constants::ECMAScript);
[&hellip;]
</pre>
</blockquote>
</li>
</ol>




</body>
</html>
