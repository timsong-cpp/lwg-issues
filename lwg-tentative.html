<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p><p>Revised 2022-07-30 at 17:05:04 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="3579" href="3579">3579.</a> Complexity guarantees for <tt>resize()</tt> and <tt>append()</tt> functions across the library</h3>
<p><b>Section:</b> 23.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a>, 24.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a>, 24.3.10.3 <a href="https://timsong-cpp.github.io/cppwp/list.capacity">[list.capacity]</a>, 24.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>, 24.3.9.5 <a href="https://timsong-cpp.github.io/cppwp/forward.list.modifiers">[forward.list.modifiers]</a>, 28.6.2.8 <a href="https://timsong-cpp.github.io/cppwp/valarray.members">[valarray.members]</a>, 23.4.3.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a>, 31.12.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/fs.path.append">[fs.path.append]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Louis Dionne <b>Opened:</b> 2021-08-11 <b>Last modified:</b> 2022-02-23 10:30:24 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.capacity">active issues</a> in [string.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.capacity">issues</a> in [string.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue requests to clarify the complexity requirements for <tt>resize</tt> and <tt>append</tt> 
member functions across the library. Currently, none of them have complexity requirements associated to them, 
which means that implementations are free to use a geometric growth approach or not. A geometric growth 
approach (like what's required by <tt>push_back</tt>) implies that calling <tt>resize/append</tt> with 
successively larger sizes will have amortized <tt>&#x1d4aa;(<i>N</i>)</tt> complexity, whereas using a 
<tt>resize</tt>-exactly approach makes that pattern <tt>&#x1d4aa;(<i>N</i><sup>2</sup>)</tt>.
<p/>
I believe the Standard should either specify that those member functions are required to have behavior that 
is consistent with <tt>push_back</tt>, or explicitly mention that implementations are allowed to use whatever 
growth strategy they want. If we do the former, users could start relying on this guarantee in a portable manner. 
If we do the latter, it would make it clear to users that they should not rely on the amortized 
<tt>&#x1d4aa;(<i>N</i>)</tt> guarantee if they want their code to be portable.
<p/>
The following classes have a <tt>resize()</tt> member function and also a <tt>push_back()</tt> member function:
</p>
<ul>
<li><p>23.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a></p></li>
<li><p>24.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a></p></li>
<li><p>24.3.10.3 <a href="https://timsong-cpp.github.io/cppwp/list.capacity">[list.capacity]</a></p></li>
<li><p>24.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a></p></li>
</ul>
<p>
The following classes have a <tt>resize()</tt> member function but do not support <tt>push_back()</tt>:
</p>
<ul>
<li><p>24.3.9.5 <a href="https://timsong-cpp.github.io/cppwp/forward.list.modifiers">[forward.list.modifiers]</a></p></li>
<li><p>28.6.2.8 <a href="https://timsong-cpp.github.io/cppwp/valarray.members">[valarray.members]</a></p></li>
</ul>
<p>
The following classes have an <tt>append()</tt> member function:
</p>
<ul>
<li><p>23.4.3.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a></p></li>
<li><p>31.12.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/fs.path.append">[fs.path.append]</a></p></li>
</ul>
<p>
None of them specify a complexity requirement. I think we should update all of them to describe 
what is expected or permitted in an implementation.
</p>

<p><i>[2021-08-20; Reflector poll]</i></p>

<p>
Set priority to 3 and status to "LEWG" after reflector poll.
</p>

<p><i>[2022-02-22 LEWG telecon;  Status changed: LEWG &rarr; Tentatively NAD.]</i></p>

<p>
A paper would be needed.
Such a paper would need to include discussion on whether
<code>allocate_at_least</code> (new for C++23) has an impact.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3611" href="3611">3611.</a> Should <tt>compare_exchange</tt> be allowed to modify the <tt>expected</tt> value on success?</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-09-29 <b>Last modified:</b> 2022-07-14 11:37:55 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently a <tt>compare_exchange</tt> will only update the <tt>expected</tt> parameter if the
<tt>compare_exchange</tt> fails. This precludes unconditionally clearing the padding bits of the
<tt>expected</tt> object prior to doing the <tt>compare_exchange</tt>, which complicates the
implementation by requiring additional work (e.g. making a copy of the <tt>expected</tt> value
and clearing the copy's padding, then copying it back to expected only if the <tt>compare_exchange</tt> fails).
<p/>
We should consider whether we want to allow modifications to <tt>expected</tt> in the success case,
if such modifications only affect padding bits (i.e. do not alter the value). If we want to allow it,
we need to say so explicitly. The current wording does not permit modifications in the success case,
and any such modification could create a data race if another thread is reading the same memory location
(if it knows a priori that a <tt>compare_exchange_strong</tt> would succeed and so not write to that location).
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll. Send to SG1.
</p>
<p>
This is <a href="2426">2426</a> again,
but the new requirement to clear padding bits changes things.
</p>

<p><i>[2022-07-06; Move to "Open" following SG1 feedback]</i></p>

<p>
Allow compare_exchange to modify the expected value on success?
<table>
<tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>5</td><td>4</td></tr>
</table>
</p>

<p><i>[2022-07-14; Move to "Tentatively NAD" following reflector poll]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3667" href="3667">3667.</a> <tt>std::cout &lt;&lt; &amp;X::f</tt> prints <tt>1</tt></h3>
<p><b>Section:</b> 31.7.5.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted">[ostream.formatted]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2022-01-31 <b>Last modified:</b> 2022-03-04 14:32:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
At present, the program
</p>
<blockquote><pre>
#include &lt;iostream&gt;

struct X
{
  void f() {}
};

int main()
{
  std::cout &lt;&lt; &amp;X::f;
}
</pre></blockquote>
<p>
prints <tt>1</tt>. That's because member pointers implicitly convert
to <tt>bool</tt>, and there's <tt>operator&lt;&lt;</tt> overload for <tt>bool</tt> in
31.7.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.arithmetic">[ostream.inserters.arithmetic]</a>.
<p/>
This behavior is rarely useful. In C++20, we added deleted
overloads to prevent a similar counter-intuitive output for
the case in which e.g. <tt>L"str"</tt> is output to <tt>std::cout</tt>,
which used to print the pointer value using the <tt>operator&lt;&lt;</tt>
overload for <tt>const void*</tt>.
<p/>
We should similarly consider adding a deleted overload for member pointers.
</p>

<p><i>[2022-03-04; Reflector poll; Status changed: New &rarr; Tentatively NAD]</i></p>

<p>
 Needs a paper to LEWG if anything should change here.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 31.7.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.general">[ostream.general]</a>, class template <tt>basic_ostream</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  
  template&lt;class traits&gt;
    basic_ostream&lt;wchar_t, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;wchar_t, traits&gt;&amp;, const char16_t*) = delete;
  template&lt;class traits&gt;
    basic_ostream&lt;wchar_t, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;wchar_t, traits&gt;&amp;, const char32_t*) = delete;
      
  <ins>template&lt;class charT, class traits, class T, class C&gt;
    basic_ostream&lt;charT, traits&gt;&amp; 
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;, T C::*) = delete;</ins>
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3695" href="3695">3695.</a> The standard-layout property of char-like types serves for nothing</h3>
<p><b>Section:</b> 23.1 <a href="https://timsong-cpp.github.io/cppwp/strings.general">[strings.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-05-07 <b>Last modified:</b> 2022-05-17 11:57:55 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#strings.general">active issues</a> in [strings.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#strings.general">issues</a> in [strings.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently char-like types are defined as non-array trivial and standard-layout types (23.1 <a href="https://timsong-cpp.github.io/cppwp/strings.general">[strings.general]</a>). 
However, as far as I know, there is no actual operation specified in the standard or used in implementations 
requiring a char-like type to be standard-layout (unlike the triviality, which is related to <tt>charT()</tt>, etc.). 
Implementations are merely <tt>static_assert</tt>-ing the standard-layout property of element types.
<p/>
As the standard library almost never requires a user-provided type to be standard-layout now (other suspicious 
exceptions are program-defined specializations of <tt>std::atomic&lt;T*&gt;</tt>), I think char-like types should 
just be non-array trivial types.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Six votes for NAD.
Changing this would require a proposal through LEWG.
</p>



<p><b>Proposed resolution:</b></p>





</body>
</html>
