<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p><p>Revised 2018-08-24 at 13:31:33 UTC</p>
</p><h2>Tentative Issues</h2>
<hr>
<h3><a name="708" href="708">708.</a> Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 26 <a href="https://timsong-cpp.github.io/cppwp/localization">[localization]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-07-28 <b>Last modified:</b> 2018-06-24 10:22:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>


<p><i>[
San Francisco: Bill and Nick still intend to provide wording, but this
is a part of the task to be addressed by the group that will look into
issue <a href="860">860</a>.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's our intention to stay in sync with WG14. If WG14 makes a decision
that requires a change in WG21 the issue will be reopened.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: <tt>uselocale()</tt> is bad; pass locales around as objects</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="935" href="935">935.</a> clock error handling needs to be specified</h3>
<p><b>Section:</b> 25.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock">[time.clock]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-11-24 <b>Last modified:</b> 2018-06-24 10:22:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Each of the three clocks specified in Clocks 25.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock">[time.clock]</a>
provides the member function:
</p>

<blockquote><pre>
static time_point now();
</pre></blockquote>

<p>
The semantics specified by Clock requirements 25.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a>
make no mention of error handling. Thus the function may throw <tt>bad_alloc</tt>
or an implementation-defined exception (15.5.5.12 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>
paragraph 4).
</p>

<p>
Some implementations of these functions on POSIX, Windows, and
presumably on other operating systems, may fail in ways only detectable
at runtime. Some failures on Windows are due to supporting chipset
errata and can even occur after successful calls to a clock's <tt>now()</tt>
function.
</p>

<p>
These functions are used in cases where exceptions are not appropriate
or where the specifics of the exception or cause of error need to be
available to the user. See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error
handling (Rev 1)</i>, for more specific discussion of use cases. Thus some change in
the interface of now is required.
</p>

<p>
The proposed resolution has been implemented in the Boost version of the
chrono library. No problems were encountered.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be deferred until the next Committee Draft
has been issued and the prerequisite paper has been accepted.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD future. Too late to make this change without having already
accepted the hybrid error handling proposal.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD. Needs a paper. Proposed resolution no longer applies.</p>


<p><b>Proposed resolution:</b></p>
<p>
Accept the proposed wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error handling (Rev 1)</i>.
</p>

<p>
Change <tt>Clock</tt> requirements 25.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a> as indicated:
</p>

<blockquote>
<p>
-2- In Table 55 <tt>C1</tt> and <tt>C2</tt> denote clock types. <tt>t1</tt> and
<tt>t2</tt> are values returned by <tt>C1::now()</tt> where the call 
returning <tt>t1</tt> happens before (1.10) the call returning <tt>t2</tt> and
both of these calls happen before <tt>C1::time_point::max()</tt>.
<ins><tt>ec</tt> denotes an object of type <tt>error_code</tt> 
(18.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.overview">[syserr.errcode.overview]</a>).</ins>
</p>

<table border="1">
<caption>Table 55 &mdash; Clock requirements</caption>
<tr>
<th>Expression</th><th>Return type</th><th>Operational semantics</th>
</tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>

<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point</tt></td>
<td>Returns a <tt>time_point</tt> object representing the current point in time.
</td>
</tr>

<tr>
<td><tt><ins>C1::now(ec)</ins></tt></td>
<td><tt><ins>C1::time_point</ins></tt></td>
<td><ins>Returns a <tt>time_point</tt> object representing the current point in time.</ins>
</td>
</tr>
</table>
</blockquote>

<p>
Change class <tt>system_clock</tt> 25.7.1 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system">[time.clock.system]</a> as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>monotonic_clock</tt> 99 [time.clock.monotonic] as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>high_resolution_clock</tt> 25.7.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock.hires">[time.clock.hires]</a> as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>






<hr>
<h3><a name="1121" href="1121">1121.</a> Support for multiple arguments</h3>
<p><b>Section:</b> 19.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25 <b>Last modified:</b> 2018-06-23 21:17:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both add and multiply could sensibly be called with more than two arguments.
The variadic template facility makes such declarations simple, and is likely
to be frequently wrapped by end users if we do not supply the variant
ourselves.
</p>
<p>
We deliberately ignore divide at this point as it is not transitive.
Likewise, subtract places special meaning on the first argument so I do not
suggest extending that immediately.  Both could be supported with analogous
wording to that for add/multiply below.
</p>
<p>
Note that the proposed resolution is potentially incompatible with that
proposed for <a href="921">921</a>, although the addition of the typedef to ratio would be
equally useful.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The consensus of the group when we reviewed this in Santa Cruz was that
<a href="921">921</a> would proceed to Ready as planned, and the
multi-paramater add/multiply templates should be renamed as
<tt>ratio_sum</tt> and <tt>ratio_product</tt> to avoid the problem
mixing template aliases with partial specializations.
</p>

<p>
It was also suggested to close this issue as NAD Future as it does not
correspond directly to any NB comment.  NBs are free to submit a
specific comment (and re-open) in CD2 though.
</p>

<p>
Walter Brown also had concerns on better directing the order of
evaluation to avoid overflows if we do proceed for 0x rather than TR1,
so wording may not be complete yet.
</p>

<p><i>[
Alisdair updates wording.
]</i></p>


<p><i>[
2009-10-30 Howard:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>PR for <tt>ratio_product</tt> is wrong, uses <tt>ratio_add</tt> instead of <tt>ratio_multiply</tt>.
Recommend NAD: Doesn't meet the bar for standardization: hasn't been requested again in 7 years, easy to implement yourself.</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a future standard.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the following type traits to p3 19.16 <a href="https://timsong-cpp.github.io/cppwp/ratio">[ratio]</a>
</p>

<blockquote><pre>
// ratio arithmetic
template &lt;class R1, class R2&gt; struct ratio_add;
template &lt;class R1, class R2&gt; struct ratio_subtract;
template &lt;class R1, class R2&gt; struct ratio_multiply;
template &lt;class R1, class R2&gt; struct ratio_divide;
<ins>template &lt;class R1, class ... RList&gt; struct ratio_sum;</ins>
<ins>template &lt;class R1, class ... RList&gt; struct ratio_product;</ins>
</pre></blockquote>

<p>
after 19.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p1: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_sum; // declared, never defined

template &lt;class R1&gt; struct ratio_sum&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_sum&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>

<p>
after 19.16.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p3: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_product; // declared, never defined

template &lt;class R1&gt; struct ratio_product&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_product&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>








<hr>
<h3><a name="1154" href="1154">1154.</a> <tt>complex</tt> should accept integral types</h3>
<p><b>Section:</b> 24.5 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2018-06-24 10:53:02 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in [complex.numbers].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 35</b></p>

<p><b>Description</b></p>
        <p>Instantiations of the class
        template <tt>complex&lt;&gt;</tt> have to be allowed for integral
        types, to reflect existing practice and ISO standards
        (LIA-III).</p>
        
<p><b>Suggestion</b></p>

<p><i>[
2009-10-26 Proposed wording in <a href="http://wg21.link/n3002.pdf">N3002</a>.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Future. Rationale added.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend SG6</p>

<p><i>[2017-03-03, Kona]</i></p>

<p>
SG6 suggests this issue is a new feature, not a problem with the existing
standard, and should therefore be closed NAD. However, SG6 invites papers that bring
the proposal up to date with the current standard.
</p>


<p><b>Rationale:</b></p>
<p>
There is no consensus for making this change at this time.
</p>


<p><b>Proposed resolution:</b></p><p>
Adopt <a href="http://wg21.link/n3002.pdf">N3002</a>.
</p>




<hr>
<h3><a name="1188" href="1188">1188.</a> Unordered containers should have a minimum load factor as well as a maximum</h3>
<p><b>Section:</b> 21.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 21.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unordered associative containers have a notion of a maximum load factor:
when the number of elements grows large enough, the containers
automatically perform a rehash so that the number of elements per bucket
stays below a user-specified bound. This ensures that the hash table's
performance characteristics don't change dramatically as the size
increases.
</p>

<p>
For similar reasons, Google has found it useful to specify a minimum
load factor: when the number of elements shrinks by a large enough, the
containers automatically perform a rehash so that the number of elements
per bucket stays above a user-specified bound. This is useful for two
reasons. First, it prevents wasting a lot of memory when an unordered
associative container grows temporarily. Second, it prevents amortized
iteration time from being arbitrarily large; consider the case of a hash
table with a billion buckets and only one element. (This was discussed
even before TR1 was published; it was TR issue 6.13, which the LWG
closed as NAD on the grounds that it was a known design feature.
However, the LWG did not consider the approach of a minimum load
factor.)
</p>

<p>
The only interesting question is when shrinking is allowed. In principle
the cleanest solution would be shrinking on erase, just as we grow on
insert. However, that would be a usability problem; it would break a
number of common idioms involving erase. Instead, Google's hash tables
only shrink on insert and rehash.
</p>

<p>
The proposed resolution allows, but does not require, shrinking in
rehash, mostly because a postcondition for rehash that involves the
minimum load factor would be fairly complicated. (It would probably have
to involve a number of special cases and it would probably have to
mention yet another parameter, a minimum bucket count.)
</p>

<p>
The current behavior is equivalent to a minimum load factor of 0. If we
specify that 0 is the default, this change will have no impact on
backward compatibility.
</p>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This seems to a useful extension, but is too late for 0x.

Move to Tentatively NAD Future.
</p></blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Should there be a shrink_to_fit()? Is it too surprising to shrink on insert()? (We understand that shrinking on erase() is not an option.) Maybe make people call rehash(0) to shrink to the min_load_factor? On clear(), the load factor goes to 0 or undefined (0/0), which is likely to violate min_load_factor() min_load_factor(z)'s wording should match max_load_factor(z)'s, e.g. "May change the container’s maximum load factor" Want a paper exploring whether shrink-on-insert has been surprising. From Titus: Google's experience is that maps don't shrink in the way this would help with. NAD, not worth the time. Write a paper if you can demonstrate a need for this.</p>


<p><b>Proposed resolution:</b></p>
<p>
Add two new rows, and change rehash's postcondition in the unordered
associative container requirements table in 21.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &mdash; Unordered associative container requirements
(in addition to container)</caption>

<tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><ins>
<tt>a.min_load_factor()</tt>
</ins></td>
<td><ins>
<tt>float</tt>
</ins></td>
<td><ins>
Returns a non-negative number that the container attempts to keep the
load factor greater than or equal to. The container automatically
decreases the number of buckets as necessary to keep the load factor
above this number.
</ins></td>
<td><ins>
constant
</ins></td>
</tr>

<tr>
<td><ins><tt>a.min_load_factor(z)</tt></ins></td>
<td><ins><tt>void</tt></ins></td>
<td><ins>Pre: <tt>z</tt> shall be non-negative. Changes the container's minimum
load factor, using <tt>z</tt> as a hint. [<i>Footnote:</i> the minimum
load factor should be significantly smaller than the maximum. 
If <tt>z</tt> is too large, the implementation may reduce it to a more sensible value.]
</ins></td>
<td><ins>
constant
</ins></td>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <ins><tt>a.bucket_count() &gt;= n</tt>, and <tt>a.size() &lt;= a.bucket_count()
* a.max_load_factor()</tt>. [<i>Footnote:</i> It is intentional that the
postcondition does not mention the minimum load factor.
This member function is primarily intended for cases where the user knows
that the container's size will increase soon, in which case the container's
load factor will temporarily fall below <tt>a.min_load_factor()</tt>.]</ins>
<del>
<tt>a.bucket_cout &gt; a.size() / a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</del>
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</table>
</blockquote>

<p>
Add a footnote to 21.2.7 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p12:
</p>

<blockquote>
<p>
The insert members shall not affect the validity of references to
container elements, but may invalidate all iterators to the container.
The erase members shall invalidate only iterators and references to the
erased elements.
</p>

<blockquote><p>
[A consequence of these requirements is that while insert may change the
number of buckets, erase may not. The number of buckets may be reduced
on calls to insert or rehash.]
</p></blockquote>
</blockquote>

<p>
Change paragraph 13:
</p>

<blockquote><p>
The insert members shall not affect the validity of iterators if
<del><tt>(N+n) &lt; z * B</tt></del> <ins><tt>zmin * B &lt;= (N+n) &lt;= zmax * B</tt></ins>,
where <tt>N</tt> is the number of elements in
the container prior to the insert operation, <tt>n</tt> is the number of
elements inserted, <tt>B</tt> is the container's bucket count,
<ins><tt>zmin</tt> is the container's minimum load factor,</ins>
and <tt>z<ins>max</ins></tt> is the container's maximum load factor.
</p></blockquote>

<p>
Add to the <tt>unordered_map</tt> class synopsis in section 21.5.4 <a href="https://timsong-cpp.github.io/cppwp/unord.map">[unord.map]</a>,
the <tt>unordered_multimap</tt> class synopsis
in 21.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap">[unord.multimap]</a>, the <tt>unordered_set</tt> class synopsis in
21.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a>, and the <tt>unordered_multiset</tt> class synopsis
in 21.5.7 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset">[unord.multiset]</a>:
</p>

<blockquote><pre><ins>
float min_load_factor() const;
void min_load_factor(float z);
</ins></pre></blockquote>

<p>
In 21.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a>, 21.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a>, 21.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a>, and
21.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a>, change:
</p>

<blockquote><p>
... <tt>max_load_factor()</tt> returns 1.0 <ins>and
<tt>min_load_factor()</tt> returns 0</ins>.
</p></blockquote>





<hr>
<h3><a name="1217" href="1217">1217.</a> Quaternion support</h3>
<p><b>Section:</b> 24.5 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Ted Shaneyfelt <b>Opened:</b> 2009-09-26 <b>Last modified:</b> 2018-06-24 10:53:02 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in [complex.numbers].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Concerning mathematically proper operation of the type:
</p>

<blockquote><pre>
complex&lt;complex&lt;T&gt; &gt;
</pre></blockquote>

<p>
Generally accepted mathematical semantics of such a construct correspond
to quaternions through Cayly-Dickson construct
</p>

<blockquote><pre>
(w+xi) + (y+zi) j
</pre></blockquote>

<p>
The proper implementation seems straightforward by adding a few
declarations like those below. I have included operator definition for
combining real scalars and complex types, as well, which seems
appropriate, as algebra of complex numbers allows mixing complex and
real numbers with operators. It also allows for constructs such as
<tt>complex&lt;double&gt; i=(0,1),  x = 12.34 + 5*i;</tt>
</p>

<p>
Quaternions are often used in areas such as computer graphics, where,
for example, they avoid the problem of Gimbal lock when rotating objects
in 3D space, and can be more efficient than matrix multiplications,
although I am applying them to a different field.
</p>

<pre>
/////////////////////////ALLOW OPERATORS TO COMBINE REAL SCALARS AND COMPLEX VALUES /////////////////////////
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()+a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a+x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()-a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a-x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()*a, x.imag()*a);
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a*x.real(), a*x.imag());
    return result;
}

/////////////////////////PROPERLY IMPLEMENT QUATERNION SEMANTICS/////////////////////////
template&lt;typename T&gt; double normSq(const complex&lt;complex&lt;T&gt; &gt;q) {
    return q.real().real()*q.real().real()
         + q.real().imag()*q.real().imag()
         + q.imag().real()*q.imag().real()
         + q.imag().imag()*q.imag().imag();
}
template&lt;typename T&gt; double norm(const complex&lt;complex&lt;T&gt; &gt;q) {
    return sqrt(normSq(q));
}
/////// Cayley-Dickson Construction
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; conj(const complex&lt;complex&lt;T&gt; &gt; x) {
    complex&lt;complex&lt;T&gt; &gt; result(conj(x.real()),-x.imag());
    return result;
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator*(const complex&lt;complex&lt;T&gt; &gt; ab,const complex&lt;complex&lt;T&gt; &gt; cd) {
    complex&lt;T&gt; re(ab.real()*cd.real()-conj(cd.imag())*ab.imag());
    complex&lt;T&gt; im(cd.imag()*ab.real()+ab.imag()*conj(cd.real()));
    complex&lt;complex&lt;double&gt; &gt; q(re,im);
    return q;
}
//// Quaternion division
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; q,const S a) {
    return q * (1/a);
}
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const S a,const complex&lt;complex&lt;T&gt; &gt; q) {
    return a*conj(q)/normSq(q);
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; n, const complex&lt;complex&lt;T&gt; &gt; d) {
    return n * (conj(d)/normSq(d));
}
</pre>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future. There is no consensus or time to move this into C++0X.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend SG6 - We note that <tt>complex&lt;complex&gt;</tt> is the wrong way to spell this</p>

<p><i>[2017-03-03, Kona]</i></p>

<p>
SG6 suggests this issue is a new feature, not a problem with the existing
standard, and should therefore be closed NAD. However, SG6 invites papers that bring
the proposal up to date with the current standard.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1235" href="1235">1235.</a> Issue with C++0x random number proposal</h3>
<p><b>Section:</b> 24.7.2.6 <a href="https://timsong-cpp.github.io/cppwp/rand.req.dist">[rand.req.dist]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Matthias Troyer <b>Opened:</b> 2009-10-12 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.dist">issues</a> in [rand.req.dist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There exist optimized, vectorized vendor libraries for the creation of
random number generators, such as Intel's MKL [1] and AMD's ACML [2]. In
timing tests we have seen a performance gain of a factor of up to 80
(eighty) compared to a pure C++ implementation (in Boost.Random) when
using these generator to generate a sequence of normally distributed
random numbers. In codes dominated by the generation of random numbers
(we have application codes where random number generation is more than
50% of the CPU time) this factor 80 is very significant.
</p>

<p>
To make use of these vectorized generators, we use a C++ class modeling
the <tt>RandomNumberEngine</tt> concept and forwarding the generation of random
numbers to those optimized generators. For example:
</p>

<blockquote><pre>
namespace mkl {
 class mt19937 {.... };
}
</pre></blockquote>

<p>
For the generation of random variates we also want to dispatch to
optimized vectorized functions in the MKL or ACML libraries. See this
example:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::normal_distribution&lt;double&gt; dist;

double n = dist(eng);
</pre></blockquote>

<p>
Since the variate generation is done through the <tt>operator()</tt> of the
distribution there is no customization point to dispatch to Intel's or
AMD's optimized functions to generate normally distributed numbers based
on the <tt>mt19937</tt> generator. Hence, the performance gain of 80 cannot be
achieved.
</p>

<p>
Contrast this with TR1:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::tr1::normal_distribution&lt;double&gt; dist;
std::tr1::variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; rng(eng,dist);
double n = rng();
</pre></blockquote>

<p>
This - admittedly much uglier from an aestethic point of view - design
allowed optimization by specializing the <tt>variate_generator</tt> template for
<tt>mkl::mt19937</tt>:
</p>

<blockquote><pre>
namespace std { namespace tr1 {

template&lt;&gt;
class variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; { .... };

} }
</pre></blockquote>

<p>
A similar customization point is missing in the C++0x design and
prevents the optimized vectorized version to be used.
</p>

<p>
Suggested resolution:
</p>

<p>
Add a customization point to the distribution concept. Instead of the
<tt>variate_generator</tt> template this can be done through a call to a
free function <tt>generate_variate</tt> found by ADL instead of
<tt>operator()</tt> of the distribution:
</p>

<blockquote><pre>
template &lt;RandomNumberDistribution, class RandomNumberEngine&gt;
typename RandomNumberDistribution ::result_type
generate_variate(RandomNumberDistribution const&amp; dist, RandomNumberEngine&amp; eng);
</pre></blockquote>

<p>
This function can be overloaded for optimized enginges like
<tt>mkl::mt19937</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  No time to add this feature for C++0X.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: The standard has changed enough that the issue doesn't make sense anymore. Write a paper proposing a way to get this performance as changes to the current library.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1282" href="1282">1282.</a> A proposal to add <tt>std::split</tt> algorithm</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Igor Semenov <b>Opened:</b> 2009-12-07 <b>Last modified:</b> 2018-06-23 21:17:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol style="list-style-type:upper-roman">

<li>
<p>
Motivation and Scope
</p>
<p>
Splitting strings into parts by some set of delimiters is an often task, but
there is no simple and generalized solution in C++ Standard. Usually C++
developers use <tt>std::basic_stringstream&lt;&gt;</tt> to split string into
parts, but there are several inconvenient restrictions:
</p>

<ul>
<li>
we cannot explicitly assign the set of delimiters;
</li>
<li>
this approach is suitable only for strings, but not for other types of
containers;
</li>
<li>
we have (possible) performance leak due to string instantiation.
</li>
</ul>
</li>

<li>
<p>
Impact on the Standard
</p>
<p>
This algorithm doesn't interfere with any of current standard algorithms.
</p>
</li>

<li>
<p>
Design Decisions
</p>
<p>
This algorithm is implemented in terms of input/output iterators. Also, there is
one additional wrapper for <tt>const CharType *</tt> specified delimiters.
</p>
</li>

<li>
<p>
Example implementation
</p>
<pre>
template&lt; class It, class DelimIt, class OutIt &gt;
void split( It begin, It end, DelimIt d_begin, DelimIt d_end, OutIt out )
{
   while ( begin != end )
   {
       It it = std::find_first_of( begin, end, d_begin, d_end );
       *out++ = std::make_pair( begin, it );
       begin = std::find_first_of( it, end, d_begin, d_end,
           std::not2( std::equal_to&lt; typename It::value_type &gt;() ) );
   }
}

template&lt; class It, class CharType, class OutIt &gt;
void split( It begin, It end, const CharType * delim, OutIt out )
{
   split( begin, end, delim, delim + std::strlen( delim ), out );
}
</pre>
</li>

<li>
<p>
Usage
</p>
<pre>
std::string ss( "word1 word2 word3" );
std::vector&lt; std::pair&lt; std::string::const_iterator, std::string::const_iterator &gt; &gt; v;
split( ss.begin(), ss.end(), " ", std::back_inserter( v ) );

for ( int i = 0; i &lt; v.size(); ++i )
{
   std::cout &lt;&lt; std::string( v[ i ].first, v[ i ].second ) &lt;&lt; std::endl;
}
// word1
// word2
// word3
</pre>
</li>

</ol>

<p><i>[
2010-01-22 Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Paper encouraged. Have papers for this; <a href="https://wg21.link/LEWG259">LEWG259</a>.</p>



<p><b>Rationale:</b></p>
<p>
The LWG is not considering completely new features for standardization at this
time.  We would like to revisit this good suggestion for a future TR and/or
standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 23.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a>:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );

template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre></blockquote>

<p>
Add a new section [alg.split]:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> splits the range <tt>[first, last)</tt> into parts, using any
element of <tt>[delimiter_first, delimiter_last)</tt> as a delimiter. Results
are pushed to output iterator in the form of <tt>std::pair&lt;ForwardIterator1,
ForwardIterator1&gt;</tt>. Each of these pairs specifies a maximal subrange of
<tt>[first, last)</tt> which does not contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

<pre>
template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> split the range <tt>[first, last)</tt> into parts, using any
element of <tt>delimiters</tt> (interpreted as zero-terminated string) as a
delimiter. Results are pushed to output iterator in the form of
<tt>std::pair&lt;ForwardIterator1, ForwardIterator1&gt;</tt>. Each of these
pairs specifies a maximal subrange of <tt>[first, last)</tt> which does not
contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="1289" href="1289">1289.</a> Generic casting requirements for smart pointers</h3>
<p><b>Section:</b> 19.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Ion Gazta&ntilde;aga <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 15.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 40 &mdash; Allocator requirements,
the following expression is required for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>
<tr>
<td><tt>static_cast&lt;X::pointer&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static_cast&lt;X::pointer&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>
</table>
</blockquote>

<p>
To achieve this expression, a smart pointer writer must introduce an explicit
conversion operator from <tt>smart_ptr&lt;void&gt;</tt> to
<tt>smart_ptr&lt;T&gt;</tt> so that
<tt>static_cast&lt;pointer&gt;(void_ptr)</tt> is a valid expression.
Unfortunately this explicit conversion weakens the safety of a smart pointer
since the following expression (invalid for raw pointers) would become valid:
</p>

<blockquote><pre>
smart_ptr&lt;void&gt; smart_v = ...;
smart_ptr&lt;T&gt; smart_t(smart_v);
</pre></blockquote>

<p>
On the other hand, <tt>shared_ptr</tt> also defines its own casting functions in
19.11.3.9 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cast">[util.smartptr.shared.cast]</a>, and although it's unlikely that a
programmer will use <tt>shared_ptr</tt> as <tt>allocator::pointer</tt>, having
two different ways to do the same cast operation does not seem reasonable. A
possible solution would be to replace <tt>static_cast&lt;X::pointer&gt;(w)</tt>
expression with a user customizable (via ADL)
<tt>static_pointer_cast&lt;value_type&gt;(w)</tt>, and establish the
<tt>xxx_pointer_cast</tt> functions introduced by <tt>shared_ptr</tt> as the
recommended generic casting utilities of the standard.
</p>

<p>
Unfortunately, we've experienced problems in Boost when trying to establish
<tt>xxx_pointer_cast</tt> as customization points for generic libraries (<a
href="http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html"
>http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html</a>)
because these casting functions are called with explicit template parameters and
the standard says in 12.9.1 <a href="https://timsong-cpp.github.io/cppwp/temp.arg.explicit">[temp.arg.explicit]</a> p.8 "Explicit template
argument specification":
</p>

<blockquote><p>
8 ...But when a function template with explicit template arguments is used, the
call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call. If no such name is
visible, the call is not syntactically well-formed and argument-dependent lookup
does not apply.
</p></blockquote>

<p>
So we can do this:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_swap(BasePtr p)
{
  //ADL customization point
  swap(p, p);
  //...
}
</pre></blockquote>

<p>
but not the following:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;
  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);
}
</pre></blockquote>

<p>
The solution to make <tt>static_pointer_cast</tt> a customization point is to
add a generic declaration (no definition) of <tt>static_pointer_cast</tt> in a
namespace (like <tt>std</tt>) and apply "<tt>using
std::static_pointer_cast</tt>" declaration to activate ADL:
</p>

<blockquote><pre>
namespace std{

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

}

template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;

  //ADL applies because static_pointer_cast is made
  //  visible according to [temp.arg.explicit]/8
  using std::static_pointer_cast;

  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);

  //...
}
</pre></blockquote>

<p>
A complete solution will need also the definition of
<tt>static_pointer_cast</tt> for raw pointers, and this definition has been
present in Boost (<a
href="http://www.boost.org/boost/pointer_cast.hpp">http://www.boost.org/boost/
pointer_cast.hpp</a>) for years.
</p>

<p><i>[
2010-03-26 Daniel made editorial adjustments to the proposed wording.
]</i></p>


<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>

<blockquote><p>
This is a new feature rather than a defect. 
It can be added later: "this is such a hairy area that people will put up with changes"
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: NAD. Should bring a paper as a proposal for 2020.</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to section 19.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> Utility components, Header
<tt>&lt;utility&gt;</tt> synopsis:
</p>

<blockquote><pre>
// 20.3.X, generic pointer cast functions

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;

//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre></blockquote>

<p>
Add to section 19.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> Utility components, a new subclause
20.3.X Pointer cast utilities [pointer.cast]:
</p>

<blockquote>
<p>
20.3.X Pointer cast utilities [pointer.cast]
</p>

<p>
1 The library defines generic pointer casting function templates so that template code
can explicitly make these names visible and activate argument-dependent lookup
for pointer cast calls.
</p>

<pre>
//Generic declarations
template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;
</pre>

<p>
2 The library also defines overloads of these functions for raw pointers.
</p>

<pre>
//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>static_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>dynamic_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>const_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
#include &lt;utility&gt; //static_pointer_cast
#include &lt;memory&gt;  //pointer_traits

class Base{};
class Derived : public Base{};

template&lt;class BasePtr&gt;
void generic_pointer_code(BasePtr b)
{
   typedef std::pointer_traits&lt;BasePtr&gt;::template
      rebind&lt;Derived&gt; DerivedPtr;

   using std::static_pointer_cast;
   //ADL applies now that static_pointer_cast is visible
   DerivedPtr d = static_pointer_cast&lt;Derived&gt;(b);
}
</pre></blockquote>

<p>
&mdash; <i>end example</i>]
</p>

</blockquote>

<p>
Replace in section 15.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> Table 40 &mdash; Allocator
requirements, the following table entries for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(w)</tt></td>
<td><tt>X::const_pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(z) == q</tt></td>
<td>&nbsp;</td>
</tr>

</table>
</blockquote>






<hr>
<h3><a name="1317" href="1317">1317.</a> make_hash</h3>
<p><b>Section:</b> 19.14.16 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Nicolai M. Josuttis <b>Opened:</b> 2010-02-10 <b>Last modified:</b> 2018-06-23 21:17:35 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the library lacks a convenient way to provide a hash function that
can be used with the provided unordered containers to allow the usage of non
trivial element types.
</p>

<p>
While we can easily declare an
</p>

<blockquote><pre>
std::unordered_set&lt;int&gt;
</pre></blockquote>

<p>
or
</p>

<blockquote><pre>
std::unordered_set&lt;std::string&gt;
</pre></blockquote>

<p>
we have no easy way to declare an <tt>unordered_set</tt> for a user defined
type. IMO, this is a big obstacle to use unordered containers in practice. Note
that in Java, the wide usage of <tt>HashMap</tt> is based on the fact that there
is always a default hash function provided.
</p>

<p>
Of course, a default hash function implies the risk to provide poor hash
functions. But often even poor hash functions are good enough.
</p>

<p>
While I really would like to see a default hash function, I don't propose it
here because this would probably introduce a discussion that's too big for this
state of C++0x.
</p>

<p>
However, I strongly suggest at least to provide a convenience variadic template
function <tt>make_hash&lt;&gt;()</tt> to allow an easy definition of a (possibly
poor) hash function.
</p>

<p>
As a consequence for a user-defined type such as
</p>

<blockquote><pre>
class Customer {
   friend class CustomerHash;
   private:
     string firstname;
     string lastname;
     long   no;
   ...
 };
</pre></blockquote>

<p>
would allow to specify:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return make_hash(c.firstname,c.lastname,c.no);
    }
};
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return std::hash&lt;std::string&gt;()(c.firstname) +
              std::hash&lt;std::string&gt;()(c.lastname) +
              std::hash&lt;long&gt;()(c.no);
    }
};
</pre></blockquote>

<p>
Note that, in principle, we can either specify that
</p>

<blockquote><p>
<tt>make_hash</tt> returns the sum of a call of
<tt>std::hash&lt;T&gt;()(x)</tt> for each argument <tt>x</tt> of type
<tt>T</tt>
</p></blockquote>

<p>
or we can specify that
</p>

<blockquote><p>
<tt>make_hash</tt> provides a hash value for each argument, for which a
<tt>std::hash()</tt> function is provided
</p></blockquote>

<p>
with the possible note that the hash value may be poor or only a good hash value
if the ranges of all passed arguments is equally distributed.
</p>

<p>
For my convenience, I propose wording that describes
the concrete implementation.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial, rationale added below.
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Feature? Needs a paper. (This is <a href="https://wg21.link/LEWG21">LEWG21</a>)</p>



<p><b>Rationale:</b></p>
<p>
There is no consensus to make this change at this time.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Function objects 19.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>
in paragraph 2 at the end of the Header <tt>&lt;functional&gt;</tt> synopsis
insert:
</p>

<blockquote><pre>
// convenience functions
template &lt;class T&gt;
  size_t make_hash (const T&amp;);
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp;, const Types&amp;...);
</pre></blockquote>

<p>
In Class template hash 19.14.16 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>
add:
</p>

<blockquote>
<p>
<b>20.7.16.1 Hash creation functions [hash.creation]</b>
</p>

<pre>
template &lt;class T&gt;
  size_t make_hash (const T&amp; val);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val);</tt>
</p></blockquote>

<pre>
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp; val, const Types&amp;... args);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val) + std::make_hash(args...)</tt>
</p></blockquote>

</blockquote>






<hr>
<h3><a name="1406" href="1406">1406.</a> Support hashing smart-pointers based on <i>owner</i></h3>
<p><b>Section:</b> 19.11.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-5</b></p>
<p>
Hash support based on ownership sharing should be
supplied for <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
For two <tt>shared_ptr</tt> objects <tt>p</tt> and <tt>q</tt>, two distinct
equivalence relations can be defined. One is based on
equivalence of pointer values, which is derived from the
expression <tt>p.get() == q.get()</tt> (hereafter called <i>address based
equivalence relation</i>), the other is based on
equivalence of ownership sharing, which is derived from
the expression <tt>!p.owner_before(q) &amp;&amp; !q.owner_before(p)</tt>
(hereafter called <i>ownership-based equivalence relation</i>).
These two equivalence relations are independent in
general. For example, a <tt>shared_ptr</tt> object created by the
constructor of the signature <tt>shared_ptr(shared_ptr&lt;U>
const &amp;, T *)</tt> could reveal a difference between these two
relations. Therefore, hash support based on each
equivalence relation should be supplied for <tt>shared_ptr</tt>.
However, while the standard library provides the hash
support for address-based one (20.9.11.6 paragraph 2), it
lacks the hash support for ownership-based one. In
addition, associative containers work well in combination
with the <tt>shared_ptr</tt>'s ownership-based comparison but
unordered associative containers don't. This is
inconsistent.
</p>
<p>
For the case of <tt>weak_ptr</tt>, hash support for the ownership based
equivalence relation can be safely defined on
<tt>weak_ptr</tt>s, and even on expired ones. The absence of
hash support for the ownership-based equivalence
relation is fatal, especially for expired <tt>weak_ptr</tt>s. And the
absence of such hash support precludes some quite
effective use-cases, e.g. erasing the <tt>unordered_map</tt> entry
of an expired <tt>weak_ptr</tt> key from a customized deleter
supplied to <tt>shared_ptr</tt>s.
</p>
<p>
Hash support for the ownership-based equivalence
relation cannot be provided by any user-defined manner
because information about ownership sharing is not
available to users at all. Therefore, the only way to provide
ownership-based hash support is to offer it intrusively by
the standard library.
</p>
<p>
As far as we know, such hash support is implementable.
Typical implementation of such hash function could return
the hash value of the pointer of the counter object that is
internally managed by <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
</p>

<p><i>[2010 Rapperswil:]</i></p>

<blockquote>
<p>No consensus to make this change at this time.</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Needs a paper. Feature. Exposing an implementation detail (indirectly observable via hash).</p>



<p><b>Proposed resolution:</b></p>
<p>
Add the following non-static member functions to
<tt>shared_ptr</tt> and <tt>weak_ptr</tt> class template;
</p>
<p>
Update [util.smartptr.shared], 20.9.11.2 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class shared_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
Update [util.smartptr.weak], 20.9.11.3 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class weak_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
These functions satisfy the following
requirements. Let <tt>p</tt> and <tt>q</tt> be objects of either
<tt>shared_ptr</tt> or <tt>weak_ptr</tt>, <tt>H</tt> be a hypothetical
function object type that satisfies the hash
requirements ([hash.requirements], 20.2.4) and <tt>h</tt> be an object of the
type <tt>H</tt>. The expression <tt>p.owner_hash()</tt> behaves
as if it were equivalent to the expression <tt>h(p)</tt>. In
addition, <tt>h(p) == h(q)</tt> must become <tt>true</tt> if <tt>p</tt> and
<tt>q</tt> share ownership.
</p>





<hr>
<h3><a name="1499" href="1499">1499.</a> Condition variables preclude wakeup optimization</h3>
<p><b>Section:</b> 30.5 <a href="https://timsong-cpp.github.io/cppwp/thread.condition">[thread.condition]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-193</b></p>

<p>
Condition variables preclude a wakeup optimization.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote><p>
Change condition_variable to allow such
optimization. See Appendix 1 - Additional Details
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed the issue, and deemed it an extension to be handled after C++0x.
</p>

<p><b>Rationale:</b></p><p>The LWG does not wish to make the change at this time.</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: (N4618 numbering) 30.5.1[thread.condition.condvar] p10.3 allows spurious wakeups. This issue is out of date.</p>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
The approach suggested there raises all sorts of issues about <tt>thread_locals</tt>, etc. It's probably way too late 
to change this anyway, but this would have required a careful paper.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2226" href="2226">2226.</a> <tt>wstring_convert</tt> methods do not take allocator instance</h3>
<p><b>Section:</b> D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Glen Fernandes <b>Opened:</b> 2012-12-14 <b>Last modified:</b> 2018-06-24 10:22:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.string">active issues</a> in [depr.conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.string">issues</a> in [depr.conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>wstring_convert</tt> class template, described in D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>, does not 
support custom stateful allocators. It only supports custom stateless allocators.
<p/>
The <tt>to_bytes</tt> member function returns <tt>basic_string&lt;char, char_traits&lt;char&gt;, Byte_alloc&gt;</tt>  
but it does not take an instance of <tt>Byte_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
Similarly the <tt>from_bytes</tt> member function returns <tt>basic_string&lt;Elem, char_traits&lt;Elem&gt;, Wide_alloc&gt;</tt>  
but it does not take an instance of <tt>Wide_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
This makes these two member functions and the <tt>wstring_convert</tt> class template not usable when <tt>Wide_alloc</tt> 
or <tt>Byte_alloc</tt> are stateful allocators.
</p>

<p><i>[2013-01-22, Glen provides wording]</i></p>


<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to NAD Future.
</p>
<p>
This is clearly an extension that the LEWG may want to take a look at, once we have more experience
with appropriate use of allocators with the C++11 model.
</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Does this follow the pattern? Should be discussed as a group. Do we have the experience with 
the C++11 allocator model to know that this is the addition to make?</p>
<p>Should <tt>to_string()</tt> also take an allocator? <tt>substr()</tt>? Any function that returns a string?</p>
<p>This suggests a larger change.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>In D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>/2 and /6 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>from_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Wide_alloc</tt>:</p>

<blockquote><pre>
wide_string from_bytes(char byte<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *ptr<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const byte_string&amp; str<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *first, const char *last<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> /8 specify that this <tt>Wide_alloc</tt> allocator parameter is used to
construct the <tt>wide_string</tt> object returned from the function:</p>

<p>
-7- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>byte</tt> to a wide string.
The second member function shall convert the null-terminated sequence beginning at <tt>ptr</tt> to a wide
string. The third member function shall convert the sequence stored in <tt>str</tt> to a wide string. The fourth
member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a wide string.
<p/>
-8- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Wide_alloc</tt> allocator parameter is used to construct the <tt>wide_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

<li><p>In D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>/2 and /12 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>to_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Byte_alloc</tt>:</p>

<blockquote><pre>
byte_string to_bytes(Elem wchar<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *wptr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const wide_string&amp; wstr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *first, const Elem *last<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In D.14.1 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> /13 specify that this <tt>Byte_alloc</tt> allocator parameter is used to
construct the <tt>byte_string</tt> object returned from the function:</p>

<p>
-12- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>wchar</tt> to a byte string.
The second member function shall convert the null-terminated sequence beginning at <tt>wptr</tt> to a byte
string. The third member function shall convert the sequence stored in <tt>wstr</tt> to a byte string. The
fourth member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a byte string.
<p/>
-13- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Byte_alloc</tt> allocator parameter is used to construct the <tt>byte_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

</ol>





<hr>
<h3><a name="2417" href="2417">2417.</a> [fund.ts.v2] <tt>std::experimental::optional::operator&lt;</tt> and <tt>LessThanComparable</tt> requirement</h3>
<p><b>Section:</b> 5.7 [fund.ts.v2::optional.relops], 5.9 [fund.ts.v2::optional.comp_with_t] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-06-20 <b>Last modified:</b> 2018-06-24 10:53:02 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
Currently, <tt>std::experimental::optional::operator==</tt> imposes the <tt>EqualityComparable</tt> requirement which provides
two guarantees: It ensures that <tt>operator!=</tt> can rely on the equivalence-relation property and more importantly, that
the <tt>BooleanTestable</tt> requirements suggested by issue <a href="2114">2114</a> are automatically implied.
<p/>
<tt>std::experimental::optional::operator&lt;</tt> doesn't provide a <tt>LessThanComparable</tt> requirement, but there was quite
an historic set of changes involved with that family of types: As of <a href="http://wg21.link/n3527.html">N3527</a>
this operator was defined in terms of <tt>operator&lt;</tt> of the contained type <tt>T</tt> and imposed the <tt>LessThanComparable</tt> 
requirement. In the final acceptance step of <tt>optional</tt> by the committee, the definition was expressed in terms of <tt>std::less</tt>
and the <tt>LessThanComparable</tt> requirement had been removed.
<p/>
The inconsistency between <tt>operator==</tt> and <tt>operator&lt;</tt> should be removed. One possible course of action would be 
to add the <tt>LessThanComparable</tt> to <tt>std::experimental::optional::operator&lt;</tt>. The <tt>EqualityComparable</tt> requirement
of <tt>operator==</tt> could also be removed, but in that case both operators would at least need to require the <tt>BooleanTestable</tt> 
requirements (see <a href="2114">2114</a>) for the result type of <tt>T</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>. 
<p/>
Arguably, corresponding operators for <tt>pair</tt> and <tt>tuple</tt> do not impose <tt>LessThanComparable</tt> (nor
<tt>EqualityComparable</tt>), albeit the definition of the "derived" relation functions depend on properties ensured by
<tt>LessThanComparable</tt>. According to the <a href="https://www.sgi.com/tech/stl/pair.html">SGI definition</a>, the intention was
to imposed both <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt>. If this is not intended, the standard should clarify
this position.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
VV, DK, JY discuss why and when <tt>LessThanComparable</tt> was removed. AM: Move to LEWG. Please tell LWG when you look at it. 
</p>

<p><i>[2016-11-08, Issaquah]</i></p>

<p>Not adopted during NB comment resolution</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: We've done a lot of work getting the C++17 semantics we want in this area; we're not going to change 
them 3 days from DIS or change the TSv2 behavior to be different from '17.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2600" href="2600">2600.</a> <tt>ios_base</tt> must store inaccessible iostate flags</h3>
<p><b>Section:</b> 27.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2018-06-22 06:38:21 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
DR <a href="41">41</a>, "Ios_base needs <tt>clear()</tt>, <tt>exceptions()</tt>" stopped short of providing the interface 
suggested in its title, but it did require the underlying state to be stored in <tt>ios_base</tt>. Because <tt>rdstate()</tt> 
is also missing, <tt>ios_base</tt> manipulators relying on <tt>iword</tt> and <tt>pword</tt> cannot detect failure. 
The only safe alternative is to manipulate a derived class, which must be a template.
<p/>
libc++ already provides the interface as a nonconforming extension. libstdc++ implements the internal state but leaves 
it frustratingly inaccessible, as specified. Any conforming implementation should be able to provide the interface 
without ABI problems.
</p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
This is really a request for an (feature) API. Passing to LEWG.
</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: iostreams aren't used in this way enough to spend committee time on it. However, a paper could change our minds.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2840" href="2840">2840.</a> <tt>directory_iterator::increment</tt> is seemingly narrow-contract but marked <tt>noexcept</tt></h3>
<p><b>Section:</b> 27.11.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a>, 27.11.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-09 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.dir.itr.members">issues</a> in [fs.dir.itr.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>directory_iterator::increment</tt> and <tt>recursive_directory_iterator::increment</tt> are specified by 
reference to the input iterator requirements, which is narrow-contract: it has a precondition that the iterator
is dereferenceable. Yet they are marked as <tt>noexcept</tt>.
<p/>
Either the <tt>noexcept</tt> (one of which was added by LWG <a href="2637">2637</a>) should be removed, or the 
behavior of <tt>increment</tt> when given a nondereferenceable iterator should be specified.
<p/>
Currently, libstdc++ and MSVC report an error via the <tt>error_code</tt> argument for a nondereferenceable 
<tt>directory_iterator</tt>, while libc++ and <tt>boost::filesystem</tt> assert.
</p>
  
<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2; there are some problems with the wording in alternative B.</p>
  
<p><i>[2018-01-24 Tim Song comments]</i></p>

<p> LWG <a href="3013">3013</a> will remove this <tt>noexcept</tt> (for a different reason). The behavior of
  calling <tt>increment</tt> on a nondereferenceble iterator should still be clarified, as I was informed
  that LWG wanted it to be well-defined. </p>

<p><i>[2018-1-26 issues processing telecon]</i></p>

<p>Part A is already done by <a href="3013">3013</a>.</p>
<p>Marshall to talk to Tim about Part B; it would be odd if <tt>operator++</tt> was undefined behaviour, but <tt>increment</tt> on the same iterator returned an error</p>

<p><i>[2018-8-15 Offline discussions]</i></p>

<p>Tim and Marshall recommend NAD for about Part B</p>

<p><i>[2018-08-20 Batavia Issues processing]</i></p>

<p>Status to Tentatively NAD</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol style="list-style-type: none">
<li><p>Alternative A (remove the <tt>noexcept</tt>):</p>

<ol>
<li><p>Edit 27.11.12 <a href="https://timsong-cpp.github.io/cppwp/fs.class.directory_iterator">[fs.class.directory_iterator]</a>, class <tt>directory_iterator</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
directory_iterator&amp; operator++();
directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
</blockquote>
</li>

<li><p>Edit 27.11.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a> before p10 as indicated:</p>
<blockquote>
<pre>
directory_iterator&amp; operator++();
directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-10- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3).
<p/>
-11- <i>Returns:</i> <tt>*this</tt>.
<p/>
-12- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 27.11.13 <a href="https://timsong-cpp.github.io/cppwp/fs.class.rec.dir.itr">[fs.class.rec.dir.itr]</a>, class <tt>recursive_directory_iterator</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
</blockquote>
</li>

<li><p>Edit 27.11.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> before p23 as indicated:</p>
<blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-23- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3), except that: [&hellip;]
<p/>
-24- <i>Returns:</i> <tt>*this</tt>.
<p/>
-25- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>

<li><p>Alternative B (specify that <tt>increment</tt> reports an error if the iterator is not dereferenceable):</p>

<ol>
<li><p>Edit 27.11.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a> p10 as indicated:</p>
<blockquote>
<pre>
directory_iterator&amp; operator++();
directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-10- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3)<ins>, except that 
<tt>increment</tt> reports an error if <tt>*this</tt> is not dereferenceable</ins>.
<p/>
-11- <i>Returns:</i> <tt>*this</tt>.
<p/>
-12- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 27.11.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> p23 as indicated:</p>
<blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-23- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3), except that: 
</p>
<ul>
<li><p><ins><tt>increment</tt> reports an error if <tt>*this</tt> is not dereferenceable.</ins></p></li>
<li><p>If there are no more entries at the current depth, [&hellip;]</p></li>
<li><p>Otherwise if [&hellip;]</p></li>
</ul>
<p>
-24- <i>Returns:</i> <tt>*this</tt>.
<p/>
-25- <i>Throws:</i> As specified in 27.10.7.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>
</ol>







<hr>
<h3><a name="2943" href="2943">2943.</a> Problematic specification of the wide version of <tt>basic_filebuf::open</tt></h3>
<p><b>Section:</b> 27.9.2.3 <a href="https://timsong-cpp.github.io/cppwp/filebuf.members">[filebuf.members]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-03-09 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2676">2676</a> specified <tt>basic_filebuf::open(const std::filesystem::path::value_type* s, ios_base::openmode mode)</tt> 
by simply reusing the specification for the <tt>const char*</tt> overload, but that specification is incorrect for the wide overload: 
it says that <tt>s</tt> is an NTBS &mdash; a null-terminated byte string &mdash; which it isn't. Moreover, it specifies that 
the file is opened as if by calling <tt>fopen(s, modstr)</tt>, but that call is ill-formed if <tt>s</tt> isn't a <tt>const char*</tt>.
</p>

<p><i>[2017-07 Toronto Wed Issue Prioritization]</i></p>

<p>Priority 2</p>

<p><i>[2017-11 Albuquerque Wednesday issue processing]</i></p>

<p>Status to Open; Jonathan to provide wording.</p>

<p><i>[2018-01-16; Jonathan and Tim Song provide wording]</i></p>

<p>
We'll have to ask the Microsoft guys if "as by a call to <tt>fopen</tt>" is OK for them. There are 
paths that can be represented as a wide character string that can't reliably be converted to narrow 
characters (because they become dependent on the current codepage, or some other Windows nonsense) 
so they definitely won't use <tt>fopen</tt>. But as long as they call something that behaves like 
it (which should allow <tt>_fwopen</tt>), I think they'll still meet the spirit of the wording.
</p>

<p><i>[2018-08-14; Marshall corrects a grammar nit in the P/R]</i></p>

<p>The Microsoft guys note that "as by a call to <tt>fopen</tt>" is OK by them.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4713">N4713</a>.</p>

<ol>
<li><p>Edit 27.9.2.3 <a href="https://timsong-cpp.github.io/cppwp/filebuf.members">[filebuf.members]</a> as indicated:</p>
<blockquote>
<pre>
basic_filebuf* open(const char* s, ios_base::openmode mode);
basic_filebuf* open(const filesystem::path::value_type* s,
                    ios_base::openmode mode); <i>// wide systems only; see 27.9.1 <a href="https://timsong-cpp.github.io/cppwp/fstream.syn">[fstream.syn]</a></i>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <tt>s</tt> shall point to a NTCTS (15.3.17 <a href="https://timsong-cpp.github.io/cppwp/defns.ntcts">[defns.ntcts]</a>).</ins>
<p/>
-2- <i>Effects:</i> If <tt>is_open() != false</tt>, returns a null pointer. Otherwise, initializes the 
<tt>filebuf</tt> as required. It then opens <ins>the file to which <tt>s</tt> resolves, if possible, as 
if by a call to <tt>fopen</tt> with the second argument</ins><del>a file, if possible, whose name is the 
<span style="font-variant:small-caps">ntbs</span> <tt>s</tt> (as if by calling <tt>fopen(s, modstr))</tt>. 
The <span style="font-variant:small-caps">ntbs</span> <tt>modstr</tt> is</del> determined from 
<tt>mode &amp; ~ios_base::ate</tt> as indicated in Table 117. If <tt>mode</tt> is not some combination 
of flags shown in the table then the open fails.
<p/>
-3- If the open operation succeeds and <tt>(mode &amp; ios_base::ate) != 0</tt>, positions the file to 
the end (as if by calling <tt>fseek(file, 0, SEEK_END)</tt><ins>, where <tt>file</tt> is the pointer 
returned by calling <tt>fopen</tt></ins>).(footnote 330)
<p/>
-4- If the repositioning operation fails, calls <tt>close()</tt> and returns a null pointer to indicate failure.
<p/>
-5- <i>Returns:</i> <tt>this</tt> if successful, a null pointer otherwise.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Adopted after changing 'Requires' -> 'Expects' in the P/R.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4713">N4713</a>.</p>

<ol>
<li><p>Edit 27.9.2.3 <a href="https://timsong-cpp.github.io/cppwp/filebuf.members">[filebuf.members]</a> as indicated:</p>
<blockquote>
<pre>
basic_filebuf* open(const char* s, ios_base::openmode mode);
basic_filebuf* open(const filesystem::path::value_type* s,
                    ios_base::openmode mode); <i>// wide systems only; see 27.9.1 <a href="https://timsong-cpp.github.io/cppwp/fstream.syn">[fstream.syn]</a></i>
</pre>
<blockquote>
<p>
<ins>-?- <i>Expects:</i> <tt>s</tt> shall point to a NTCTS (15.3.17 <a href="https://timsong-cpp.github.io/cppwp/defns.ntcts">[defns.ntcts]</a>).</ins>
<p/>
-2- <i>Effects:</i> If <tt>is_open() != false</tt>, returns a null pointer. Otherwise, initializes the 
<tt>filebuf</tt> as required. It then opens <ins>the file to which <tt>s</tt> resolves, if possible, as 
if by a call to <tt>fopen</tt> with the second argument</ins><del>a file, if possible, whose name is the 
<span style="font-variant:small-caps">ntbs</span> <tt>s</tt> (as if by calling <tt>fopen(s, modstr))</tt>. 
The <span style="font-variant:small-caps">ntbs</span> <tt>modstr</tt> is</del> determined from 
<tt>mode &amp; ~ios_base::ate</tt> as indicated in Table 117. If <tt>mode</tt> is not some combination 
of flags shown in the table then the open fails.
<p/>
-3- If the open operation succeeds and <tt>(mode &amp; ios_base::ate) != 0</tt>, positions the file to 
the end (as if by calling <tt>fseek(file, 0, SEEK_END)</tt><ins>, where <tt>file</tt> is the pointer 
returned by calling <tt>fopen</tt></ins>).(footnote 330)
<p/>
-4- If the repositioning operation fails, calls <tt>close()</tt> and returns a null pointer to indicate failure.
<p/>
-5- <i>Returns:</i> <tt>this</tt> if successful, a null pointer otherwise.
</p>
</blockquote>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="2960" href="2960">2960.</a> [fund.ts.v3] <tt>nonesuch</tt> is insufficiently useless</h3>
<p><b>Section:</b> 3.3 [fund.ts.v3::meta] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-05-08 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
The definition of <tt>std::experimental::nonesuch</tt> (with a deleted default
constructor, destructor, copy constructor, and copy assignment
operator) means that it is an aggregate, which means that it can be
initialized from <tt>{}</tt> in contexts where the availability of the
destructor is not considered (e.g., overload resolution or a
new-expression).
<p/>
The deleted default constructor also has this effect standing alone,
because it doesn't affect the formation of implicit conversion
sequences (and hence overload resolution). The net result is
ambiguities in situations like:
</p>
<blockquote><pre>
struct such {};
void f(const such&amp;);
void f(const nonesuch&amp;);
f({});
</pre></blockquote>
<p>
For a real-life example of such ambiguity, see 
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79141">GCC bug 79141</a>,
involving libstdc++'s internal <tt>__nonesuch</tt> type defined just like the
one in the fundamentals TS.
<p/>
I believe that <tt>nonesuch</tt> would be substantially more useful if the ICS
from <tt>{}</tt> is gone. <tt>nonesuch</tt> should have no default constructor (rather
than a deleted one), and it shouldn't be an aggregate.
</p>

<p><i>[2017-11-20 Priority set to 2 after discussion on the reflector.]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4617">N4617</a>.</p>

<ol>
<li>
<p>Edit 3.3.1 [fund.ts.v3::meta.type.synop] as indicated, moving the definition of
<tt>nonesuch</tt> to 3.3.3 [fund.ts.v3::meta.detect]:</p>

<blockquote>
<pre>
<i>//3.3.3 [fund.ts.v3::meta.detect], Detection idiom</i>
[&hellip;]

struct nonesuch<del>{
  nonesuch() = delete;
  ~nonesuch() = delete;
  nonesuch(nonesuch const&amp;) = delete;
  void operator=(nonesuch const&amp;) = delete;
}</del>;
[&hellip;]
</pre>
<blockquote>
<p>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Insert at the beginning of 3.3.3 [fund.ts.v3::meta.detect] the following paragraphs:</p>
 
<blockquote class="note">
<p>
[<i>Drafting note</i>: The seemingly redundant statement about default and initializer-list constructors
  is intended to negate the usual leeway for implementations to declare additional member function signatures 
  granted in 15.5.5.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
<blockquote>
<pre>
<ins>struct nonesuch {
  ~nonesuch() = delete;
  nonesuch(nonesuch const&amp;) = delete;
  void operator=(nonesuch const&amp;) = delete;
};</ins>
</pre>
<blockquote>
<p>
<ins>-?- <tt>nonesuch</tt> has no default constructor (C++14 &sect;[class.ctor]) or initializer-list 
  constructor (C++14 &sect;[dcl.init.list]), and is not an aggregate (C++14 &sect;[dcl.init.aggr]).</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Change C++14 references to C++17, and all the LFTS2 references to LFTS3</p>
<p>Status to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4617">N4617</a>.</p>

<ol>
<li>
<p>Edit 3.3.1 [fund.ts.v3::meta.type.synop] as indicated, moving the definition of
<tt>nonesuch</tt> to 3.3.3 [fund.ts.v3::meta.detect]:</p>

<blockquote>
<pre>
<i>//3.3.3 [fund.ts.v3::meta.detect], Detection idiom</i>
[&hellip;]

struct nonesuch<del>{
  nonesuch() = delete;
  ~nonesuch() = delete;
  nonesuch(nonesuch const&amp;) = delete;
  void operator=(nonesuch const&amp;) = delete;
}</del>;
[&hellip;]
</pre>
<blockquote>
<p>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Insert at the beginning of 3.3.3 [fund.ts.v3::meta.detect] the following paragraphs:</p>
 
<blockquote class="note">
<p>
[<i>Drafting note</i>: The seemingly redundant statement about default and initializer-list constructors
  is intended to negate the usual leeway for implementations to declare additional member function signatures 
  granted in 15.5.5.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
<blockquote>
<pre>
<ins>struct nonesuch {
  ~nonesuch() = delete;
  nonesuch(nonesuch const&amp;) = delete;
  void operator=(nonesuch const&amp;) = delete;
};</ins>
</pre>
<blockquote>
<p>
<ins>-?- <tt>nonesuch</tt> has no default constructor (C++17 &sect;[class.ctor]) or initializer-list 
  constructor (C++17 &sect;[dcl.init.list]), and is not an aggregate (C++17 &sect;[dcl.init.aggr]).</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3008" href="3008">3008.</a> <tt>make_shared</tt> (sub)object destruction semantics are not specified</h3>
<p><b>Section:</b> 19.11.3.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Glen Joseph Fernandes <b>Opened:</b> 2017-08-06 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The remarks for the <tt>make_shared</tt> and <tt>allocate_shared</tt> functions 
do not specify how the objects managed by the returned <tt>shared_ptr</tt> are 
destroyed. It is implied that when objects are constructed via a placement new 
expression, they are destroyed by calling the destructor, and that when objects 
are constructed via an allocator, they are destroyed using that allocator. This 
should be explicitly specified.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 2</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This resolution is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 19.11.3.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, ...&gt;
shared_ptr&lt;T&gt; make_shared(<i>args</i>);
template&lt;class T, class A, ...&gt;
shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, <i>args</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Remarks:</i>
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(7.9) &mdash; When the lifetime of the object managed by the return value ends, or when the initialization of
an array element throws an exception, the initialized elements should be destroyed in the reverse
order of their construction.</p></li>
<li><p><ins>(7.?) &mdash; When a (sub)object of a non-array type <tt>U</tt> that was initialized by
<tt>make_shared</tt> is to be destroyed, it shall be destroyed via the expression <tt>pv-&gt;~U()</tt> 
where <tt>pv</tt> points to that object of type <tt>U</tt>.</ins></p></li>
<li><p><ins>(7.?) &mdash; When a (sub)object of a non-array type <tt>U</tt> that was initialized by
<tt>allocate_shared</tt> is to be destroyed, it shall be destroyed via the expression 
<tt>allocator_traits&lt;A2&gt;::destroy(a2, pv)</tt> where <tt>pv</tt> points to that object of type 
<i>cv</i>-unqualified <tt>U</tt> and <tt>a2</tt> of type <tt>A2</tt> is a rebound copy of the allocator
<tt>a</tt> passed to <tt>allocate_shared</tt> such that its <tt>value_type</tt> is 
<tt>remove_cv_t&lt;U&gt;</tt>.</ins></p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol></blockquote>

<p><i>[2018-06 Rapperswil Wednesday night issues processing]</i></p>

<p>
CC: what is "of type <i>cv</i>-unqualified <tt>U</tt>" and "<tt>remove_cv_T&lt;U&gt;</tt>" about?<br/>
DK: again, it isn't new wording; it is in p 7.5.2<br/>
JW: but none of the words use "of type <i>cv</i>-unqualified <tt>U</tt>"<br/>
CT: so we should also used <tt>remove_cv_T&lt;U&gt;</tt> instead?<br/>
JW: I would like to talk to Glen<br/>
FB: does anybody know how it works for an array of arrays? It seems to cover the case<br/>
JW: we could leave it vague as it is now or specify it to exactly what it does<br/>
DK: I think we should split the thing into two parts and start with definitions<br/>
DK: ACTION I can refactor the wording<br/>
MC: there was a fairly long message thread when we talked about this 
<p/>
Daniel comments and improves wording:
<p/>
The currently allocator requirements support only the construction of <i>cv</i>-unqualified
object types (See Table 30 type <tt>C</tt> and pointer variable <tt>c</tt> as well as
Table 31 expressions "<tt>a.construct(c, args)</tt>" and "<tt>a.destroy(c)</tt>"), therefore a 
conforming implementation needs to effectively construct an object pointer that holds an object of type 
<tt>remove_cv_T&lt;U&gt;</tt> and similarly destroy such an object. Albeit it seems to be an artificial 
restriction to construct and destroy only non-<i>cv</i>-qualified object types, this is, if any, 
a different issue. But given this current state, the wording for <tt>allocate_shared</tt> needs 
to make a special wording dance via <tt>remove_cv_T&lt;U&gt;</tt>.
For <tt>construct</tt> the existing wording prevents to speak about that detail by using the more indirect
phrase "where <tt>pv</tt> points to storage suitable to hold an object of type <tt>U</tt>", but since
object types <tt>U</tt> and <tt>const U</tt> have exactly the same storage and alignment requirements,
this sentence is correct for <tt>remove_cv_T&lt;U&gt;</tt> as well.
</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively Ready.</p>


<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4750">N4750</a>.</p>

<ol>
<li><p>Edit 19.11.3.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, ...&gt;
shared_ptr&lt;T&gt; make_shared(<i>args</i>);
template&lt;class T, class A, ...&gt;
shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, <i>args</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Remarks:</i>
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(7.9) &mdash; When the lifetime of the object managed by the return value ends, or when the initialization of
an array element throws an exception, the initialized elements are destroyed in the reverse
order of their original construction.</p></li>
<li><p><ins>(7.?) &mdash; When a (sub)object of a non-array type <tt>U</tt> that was initialized by
<tt>make_shared</tt> is to be destroyed, it is destroyed via the expression <tt>pv-&gt;~U()</tt> 
where <tt>pv</tt> points to that object of type <tt>U</tt>.</ins></p></li>
<li><p><ins>(7.?) &mdash; When a (sub)object of a non-array type <tt>U</tt> that was initialized by
<tt>allocate_shared</tt> is to be destroyed, it is destroyed via the expression 
<tt>allocator_traits&lt;A2&gt;::destroy(a2, pv)</tt> where <tt>pv</tt> points to that object of type 
<tt>remove_cv_t&lt;U&gt;</tt> and <tt>a2</tt> of type <tt>A2</tt> is a rebound copy of the allocator
<tt>a</tt> passed to <tt>allocate_shared</tt> such that its <tt>value_type</tt> is 
<tt>remove_cv_t&lt;U&gt;</tt>.</ins></p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3025" href="3025">3025.</a> Map-like container deduction guides should use <tt>pair&lt;Key, T&gt;</tt>, not <tt>pair&lt;const Key, T&gt;</tt></h3>
<p><b>Section:</b> 21.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/map.overview">[map.overview]</a>, 21.4.5.1 <a href="https://timsong-cpp.github.io/cppwp/multimap.overview">[multimap.overview]</a>, 21.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a>, 21.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2017-10-08 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#map.overview">issues</a> in [map.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the deduction guides as specified currently, code like this doesn't work:
</p>
<blockquote><pre>
map m{pair{1, 1}, {2, 2}, {3, 3}};
</pre></blockquote>
<p>
Same problem occurs with <tt>multimap</tt>, <tt>unordered_map</tt> and <tt>unordered_multimap</tt>.
The problem is in deduction guides like
</p>
<blockquote><pre>
template&lt;class Key, class T, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;
map(initializer_list&lt;pair&lt;const Key, T&gt;&gt;, Compare = Compare(),
    Allocator = Allocator()) -&gt; map&lt;Key, T, Compare, Allocator&gt;;
</pre></blockquote>
<p>
The <tt>pair&lt;const Key, T&gt;</tt> is not matched by a <tt>pair&lt;int, int&gt;</tt>, because 
<tt>int</tt> can't match a <tt>const Key</tt>. Dropping the <tt>const</tt> from the parameter of the 
deduction guide makes it work with no loss of functionality.
</p>

<p><i>[2017-11-03, Zhihao Yuan comments]</i></p>

<p>
The fix described <a href=" https://wandbox.org/permlink/VFFelmbsAs1Zy0UB">here</a> prevents
</p>
<blockquote><pre>
std::map m2{m0.begin(), m0.end()};
</pre></blockquote>
<p>
from falling back to direct-non-list-initialization. Treating a uniform initialization with &gt;1 clauses
of the same un-cvref type as <tt>std::initializer_list</tt> is the only consistent interpretation I found 
so far.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 2</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Change 21.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/map.overview">[map.overview]</a> p3, class template <tt>map</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class Key, class T, class Compare = less&lt;Key&gt;,
         class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;
  map(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, Compare = Compare(), Allocator = Allocator())
    -&gt; map&lt;Key, T, Compare, Allocator&gt;;
[&hellip;]
template&lt;class Key, class T, class Allocator&gt;
  map(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, Allocator) -&gt; map&lt;Key, T, less&lt;Key&gt;, Allocator&gt;;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 21.4.5.1 <a href="https://timsong-cpp.github.io/cppwp/multimap.overview">[multimap.overview]</a> p3, class template <tt>multimap</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class Key, class T, class Compare = less&lt;Key&gt;,
         class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;
  multimap(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, Compare = Compare(), Allocator = Allocator())
    -&gt; multimap&lt;Key, T, Compare, Allocator&gt;;
[&hellip;]
template&lt;class Key, class T, class Allocator&gt;
  multimap(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, Allocator)
    -&gt; multimap&lt;Key, T, less&lt;Key&gt;, Allocator&gt;;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 21.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> p3, class template <tt>unordered_map</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class Key, class T, class Hash = hash&lt;Key&gt;,
         class Pred = equal_to&lt;Key&gt;, class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;
  unordered_map(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, typename <i>see below</i>::size_type = <i>see below</i>, Hash = Hash(),
                Pred = Pred(), Allocator = Allocator())
    -&gt; unordered_map&lt;Key, T, Hash, Pred, Allocator&gt;;
[&hellip;]
template&lt;class Key, class T, typename Allocator&gt;
  unordered_map(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, typename <i>see below</i>::size_type,
                Allocator)
    -&gt; unordered_map&lt;Key, T, hash&lt;Key&gt;, equal_to&lt;Key&gt;, Allocator&gt;;

template&lt;class Key, class T, typename Allocator&gt;
  unordered_map(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, Allocator)
    -&gt; unordered_map&lt;Key, T, hash&lt;Key&gt;, equal_to&lt;Key&gt;, Allocator&gt;;

template&lt;class Key, class T, class Hash, class Allocator&gt;
  unordered_map(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, typename <i>see below</i>::size_type, Hash,
                Allocator)
    -&gt; unordered_map&lt;Key, T, Hash, equal_to&lt;Key&gt;, Allocator&gt;;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 21.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> p3, class template <tt>unordered_multimap</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class Key, class T, class Hash = hash&lt;Key&gt;,
         class Pred = equal_to&lt;Key&gt;, class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;
  unordered_multimap(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;,
                     typename <i>see below</i>::size_type = <i>see below</i>,
                     Hash = Hash(), Pred = Pred(), Allocator = Allocator())
    -&gt; unordered_multimap&lt;Key, T, Hash, Pred, Allocator&gt;;
[&hellip;]
template&lt;class Key, class T, typename Allocator&gt;
  unordered_multimap(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, typename <i>see below</i>::size_type,
                     Allocator)
    -&gt; unordered_multimap&lt;Key, T, hash&lt;Key&gt;, equal_to&lt;Key&gt;, Allocator&gt;;

template&lt;class Key, class T, typename Allocator&gt;
  unordered_multimap(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, Allocator)
    -> unordered_multimap&lt;Key, T, hash&lt;Key&gt;, equal_to&lt;Key&gt;, Allocator&gt;;

template&lt;class Key, class T, class Hash, class Allocator&gt;
  unordered_multimap(initializer_list&lt;pair&lt;<del>const</del> Key, T&gt;&gt;, typename <i>see below</i>::size_type,
                     Hash, Allocator)
    -&gt; unordered_multimap&lt;Key, T, Hash, equal_to&lt;Key&gt;, Allocator&gt;;
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3031" href="3031">3031.</a> Algorithms and predicates with non-const reference arguments</h3>
<p><b>Section:</b> 23.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-11-08 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This doesn't compile with any major implementation:
</p>
<blockquote><pre>
int i[1] = { };
std::stable_sort(i, i, [](int&amp; x, int&amp; y) { return x &lt; y; });
</pre></blockquote>
<p>
The problem is that the <tt>Compare</tt> expects non-const references. We say "It is assumed that
<tt>comp</tt> will not apply any non-constant function through the dereferenced iterator" But that
isn't sufficient to forbid the example.
<p/>
My first thought was to modify [alg.sorting] to make the <tt>Compare</tt> requirements use
<tt>comp(as_const(x), as_const(x))</tt> but that would get very verbose to add to every expression
using <tt>comp</tt>.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 2; Jonathan to improve the statement of the problem.</p>

<p><i>[2018-02 David Jones provided this <a href="https://bugs.llvm.org/show_bug.cgi?id=34536">truly awful example</a>:]</i></p>

<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Base {
    Base(int value) : v(value) {}
    friend bool operator&lt;(const Base&amp; l, const Base&amp; r) { return l.v &lt; r.v; }
    int v;
};

struct Derived : public Base {
    using Base::Base;
    bool operator&lt;(const Derived&amp; o) /* no const here */ { return v &gt; o.v; }
};

int main(void) {
    std::vector&lt;Base&gt; b = {{1}, {5}, {0}, {3}};
    std::vector&lt;Derived&gt; d = {{0}, {1}, {3}, {5}};

    std::cout &lt;&lt; std::lower_bound(d.begin(), d.end(), 4)-&gt;v &lt;&lt; std::endl;

    std::sort(b.begin(), b.end());
    for (const auto &amp;x : b) std::cout &lt;&lt; x.v &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;

    std::sort(d.begin(), d.end());
    for (const auto &amp;x : d) std::cout &lt;&lt; x.v &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;
}

libc++:
=====
$ bin/clang++ -std=c++11 -stdlib=libc++ tmp/ex.cc &amp;&amp; ./a.out
5
0 1 3 5 
0 1 3 5 
=====

libstdc++:
=====
$ bin/clang++ -std=c++11 -stdlib=libstdc++ tmp/ex.cc &amp;&amp; ./a.out
0
0 1 3 5 
5 3 1 0 
=====
</pre></blockquote>

<p><i>[2018-08 Batavia Monday issue discussion]</i></p>

<p>Tim to provide wording; status to 'Open'</p>

<p><i>[ 2018-08-20, Tim adds P/R based on Batavia discussion.]</i></p>

<p>
Similar to the Ranges TS design, the P/R below requires <tt>Predicate</tt>,
<tt>BinaryPredicate</tt>, and <tt>Compare</tt> to accept all mixes of
<tt>const</tt> and non-<tt>const</tt> arguments.
</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively Ready after minor wording nit (corrected in place)</p>


<p><b>Proposed resolution:</b></p>
<p> This wording is relative to <a href="https://wg21.link/N4762">N4762</a>.</p>
<ol>
<li>
<p>Edit 23.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> p6-7 as indicated: </p>
<blockquote>
<p>
-6- The <tt>Predicate</tt> parameter is used whenever an algorithm expects a function object
(19.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>) that, when applied to the result of dereferencing the
corresponding iterator, returns a value testable as <tt>true</tt>. In other words, if an
algorithm takes <tt>Predicate pred</tt> as its argument and <tt>first</tt> as its iterator
argument<ins> with value type <tt>T</tt></ins>, it should work correctly in the construct
<tt>pred(*first)</tt> contextually converted to <tt>bool</tt> (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>). The
function object <tt>pred</tt> shall not apply any non-constant function through the
dereferenced iterator.<ins> Given a glvalue <tt>u</tt> of type (possibly <tt>const</tt>)
<tt>T</tt> that designates the same object as <tt>*first</tt>, <tt>pred(u)</tt> shall be a
valid expression that is equal to <tt>pred(*first)</tt>.</ins>
<p/>
-7- The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a function
object that when applied to the result of dereferencing two corresponding iterators or to
dereferencing an iterator and type <tt>T</tt> when <tt>T</tt> is part of the signature
returns a value testable as <tt>true</tt>. In other words, if an algorithm takes
<tt>BinaryPredicate binary_pred</tt> as its argument and <tt>first1</tt> and <tt>first2</tt>
as its iterator arguments<ins> with respective value types <tt>T1</tt> and <tt>T2</tt></ins>,
it should work correctly in the construct <tt>binary_pred(*first1, *first2)</tt>
contextually converted to <tt>bool</tt> (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>).
<ins>Unless otherwise specified, </ins><tt>BinaryPredicate</tt> always takes the first iterator's
<tt>value_type</tt> as its first argument, that is, in those cases when <tt>T value</tt> is part
of the signature, it should work correctly in the construct <tt>binary_pred(*first1, value)</tt>
contextually converted to <tt>bool</tt> (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>). <tt>binary_pred</tt> shall not
apply any non-constant function through the dereferenced iterators. <ins>Given a glvalue <tt>u</tt>
of type (possibly <tt>const</tt>) <tt>T1</tt> that designates the same object as <tt>*first1</tt>,
and a glvalue <tt>v</tt> of type (possibly <tt>const</tt>) <tt>T2</tt> that designates the
same object as <tt>*first2</tt>, <tt>binary_pred(u, *first2)</tt>, <tt>binary_pred(*first1, v)</tt>,
and <tt>binary_pred(u, v)</tt> shall each be a valid expression that is equal to
<tt>binary_pred(*first1, *first2)</tt>, and <tt>binary_pred(u, value)</tt> shall
be a valid expression that is equal to <tt>binary_pred(*first1, value)</tt>.</ins>
</p>
</blockquote>
</li>
<li>
<p>Edit 23.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> p2 as indicated: </p>
<blockquote>
<p>
<tt>Compare</tt> is a function object type (19.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>)<ins> that meets the
requirements for a template parameter named <tt>BinaryPredicate</tt>
(23.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>)</ins>. The return value of the function call operation
applied to an object of type <tt>Compare</tt>, when contextually converted to <tt>bool</tt>
(7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>), yields <tt>true</tt> if the first argument of the call is less than the second,
and <tt>false</tt> otherwise. <tt>Compare comp</tt> is used throughout for algorithms assuming an
ordering relation. <del>It is assumed that <tt>comp</tt> will not apply any non-constant function
through the dereferenced iterator.</del>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3037" href="3037">3037.</a> <tt>polymorphic_allocator</tt> and incomplete types</h3>
<p><b>Section:</b> 19.12.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class">[mem.poly.allocator.class]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2017-11-15 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#mem.poly.allocator.class">active issues</a> in [mem.poly.allocator.class].</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.poly.allocator.class">issues</a> in [mem.poly.allocator.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>polymorphic_allocator</tt> can trivially support the allocator completeness
requirements (15.5.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.completeness">[allocator.requirements.completeness]</a>) just as does
the default allocator. Doing so imposes no implementation burden, and enables
<tt>pmr::forward_list</tt>, <tt>pmr::list</tt>, and <tt>pmr::vector</tt> to
support incomplete types as do the non-<tt>pmr</tt> equivalents.
</p>

<p><i>[2018-01; Priority set to 2 after mailing list discussion]</i></p>


<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
Wording relative to <a href="http://wg21.link/n4700">N4700</a>.
</p>

<ol>
<li>
<p>
Add a new paragraph in 19.12.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class">[mem.poly.allocator.class]</a> after para 1:
</p>
<blockquote>
<p>
1 A specialization of class template <tt>pmr::polymorphic_allocator</tt> conforms
to the <tt>Allocator</tt> requirements [...]
</p>
<p>
<ins>-?- All specializations of class template <tt>pmr::polymorphic_allocator</tt>
satisfy the allocator completeness requirements (15.5.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.completeness">[allocator.requirements.completeness]</a>).</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3038" href="3038">3038.</a> <tt>polymorphic_allocator::allocate</tt> should not allow integer overflow to create vulnerabilities</h3>
<p><b>Section:</b> 19.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2017-11-16 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#mem.poly.allocator.mem">active issues</a> in [mem.poly.allocator.mem].</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.poly.allocator.mem">issues</a> in [mem.poly.allocator.mem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
At the moment <tt>polymorphic_allocator</tt> is specified to do <tt>sizeof(T) * n</tt> directly; this may allow an attacker 
to cause this calculation to overflow, resulting in <tt>allocate()</tt> not meeting its postcondition of returning a buffer 
suitable to store <tt>n</tt> copies of <tt>T</tt>; this is a common bug described in 
<a href="http://cwe.mitre.org/data/definitions/190.html">CWE-190</a>.
<p/>
Making this into a saturating multiply should be sufficient to avoid this problem; any <tt>memory_resource</tt> 
underneath <tt>polymorphic_allocator</tt> is going to have to throw <tt>bad_alloc</tt> (or another exception) for a request 
of <tt>SIZE_MAX</tt>.
<p/>
(There's also a minor editorial thing here that <i>Returns</i> should be <i>Effects</i>)
</p>

<p><i>[2018-06 Rapperswil Thursday issues processing]</i></p>

<p>Consensus was that the overflow should be detected and an exception thrown rather than leaving that to the 
underlying memory resource. Billy to reword, and then get feedback on the reflector. Status to Open.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
Wording relative to <a href="http://wg21.link/n4700">N4700</a>.
</p>

<ol>
<li>
<p>
Edit 19.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:
</p>
<blockquote>
<pre>
Tp* allocate(size_t n);
</pre>
<blockquote>
<p>
-1- <i><del>Returns</del><ins>Effects</ins>:</i> Equivalent to
</p>
<blockquote>
<pre>
return static_cast&lt;Tp*&gt;(memory_rsrc-&gt;allocate(<ins>SIZE_MAX / sizeof(Tp) &lt; n ? SIZE_MAX :</ins> n * sizeof(Tp), alignof(Tp)));
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively Ready with updated wording</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
Wording relative to <a href="http://wg21.link/n4762">N4762</a>.
</p>

<ol>
<li>
<p>
Edit 19.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:
</p>
<blockquote>
<pre>
Tp* allocate(size_t n);
</pre>
<blockquote>
<p>
-1- <i>Effects: </i><ins>If <tt>SIZE_MAX / sizeof(Tp) &lt; n</tt>, throws <tt>length_error</tt>, then</ins> <del>E</del><ins>e</ins>quivalent to:
</p>
<blockquote>
<pre>
return static_cast&lt;Tp*&gt;(memory_rsrc-&gt;allocate(n * sizeof(Tp), alignof(Tp)));
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
Wording relative to <a href="http://wg21.link/n4762">N4762</a>.
</p>

<ol>
<li>
<p>
Edit 19.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:
</p>
<blockquote>
<pre>
Tp* allocate(size_t n);
</pre>
<blockquote>
<p>
-1- <i>Effects: </i><ins>If <tt>SIZE_MAX / sizeof(Tp) &lt; n</tt>, throws <tt>length_error</tt>. Otherwise</ins> <del>E</del><ins>e</ins>quivalent to:
</p>
<blockquote>
<pre>
return static_cast&lt;Tp*&gt;(memory_rsrc-&gt;allocate(n * sizeof(Tp), alignof(Tp)));
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3065" href="3065">3065.</a> LWG 2989 missed that all <tt>path</tt>'s other operators should be hidden friends as well</h3>
<p><b>Section:</b> 27.11.7.7 <a href="https://timsong-cpp.github.io/cppwp/fs.path.nonmember">[fs.path.nonmember]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-02-13 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following program:
</p>
<blockquote><pre>
// <a href="https://godbolt.org/g/2wwqe8">See godbolt link</a>
#include &lt;assert.h&gt;
#include &lt;string&gt;
#include &lt;filesystem&gt;

using namespace std;
using namespace std::filesystem;

int main() {
  bool b = L"a//b" == std::string("a/b");
  assert(b); // passes. What?!
  return b;
}
</pre></blockquote>
<p>
<tt>L"a"</tt> gets converted into a <tt>path</tt>, and the string gets converted into a <tt>path</tt>, 
and then those paths are compared for equality. But <tt>path</tt> equality comparison doesn't work 
anything like string equality comparison, leading to surprises.
<p/>
<tt>path</tt>'s other operators should be made hidden friends as well, so that one side or the other 
of a given operator is of type <tt>path</tt> before those conversions apply.
</p>

<p><i>[2018-02-20, Priority set to 2 after mailing list discussion]</i></p>


<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4713">N4713</a>.
<p/>
All drafting notes from LWG <a href="2989">2989</a> apply here too.
</p>

<ol>
<li><p>Modify 27.11.5 <a href="https://timsong-cpp.github.io/cppwp/fs.filesystem.syn">[fs.filesystem.syn]</a>, header <tt>&lt;filesystem&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 27.11.7.7 <a href="https://timsong-cpp.github.io/cppwp/fs.path.nonmember">[fs.path.nonmember]</a>, path non-member functions</i>
void swap(path&amp; lhs, path&amp; rhs) noexcept;
size_t hash_value(const path&amp; p) noexcept;

<del>bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;
bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;
bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;
bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;
bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;
bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;

path operator/ (const path&amp; lhs, const path&amp; rhs);</del>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 27.11.7.7 <a href="https://timsong-cpp.github.io/cppwp/fs.path.nonmember">[fs.path.nonmember]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>friend</ins> bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;
[&hellip;]
<ins>friend</ins> bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;
[&hellip;]
<ins>friend</ins> bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;
[&hellip;]
<ins>friend</ins> bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;
[&hellip;]
<ins>friend</ins> bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;
[&hellip;]
<ins>friend</ins> bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;
[&hellip;]
<ins>friend</ins> path operator/ (const path&amp; lhs, const path&amp; rhs);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 27.11.7 <a href="https://timsong-cpp.github.io/cppwp/fs.class.path">[fs.class.path]</a>, class <tt>path</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class path {
public:
  [&hellip;]
  <i>// 27.11.7.4.5 <a href="https://timsong-cpp.github.io/cppwp/fs.path.modifiers">[fs.path.modifiers]</a>, modifiers</i>
  [&hellip;]
  
  <ins><i>// 27.11.7.7 <a href="https://timsong-cpp.github.io/cppwp/fs.path.nonmember">[fs.path.nonmember]</a>, non-member operators</i></ins>
  <ins>friend bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;</ins>
  <ins>friend bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;</ins>
  <ins>friend bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;</ins>
  <ins>friend bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;</ins>
  <ins>friend bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;</ins>
  <ins>friend bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;</ins>
  
  <ins>friend path operator/ (const path&amp; lhs, const path&amp; rhs);</ins>
  
  <i>// 27.11.7.4.6 <a href="https://timsong-cpp.github.io/cppwp/fs.path.native.obs">[fs.path.native.obs]</a>, native format observers</i>
  [&hellip;]
};
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3096" href="3096">3096.</a> <tt>path::lexically_relative</tt> is confused by trailing slashes</h3>
<p><b>Section:</b> 27.11.7.4.11 <a href="https://timsong-cpp.github.io/cppwp/fs.path.gen">[fs.path.gen]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-04-04 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fs.path.gen">active issues</a> in [fs.path.gen].</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.path.gen">issues</a> in [fs.path.gen].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>filesystem::proximate("/dir", "/dir/")</tt> returns <tt>"."</tt> when <tt>"/dir"</tt> exists, and <tt>".."</tt> 
otherwise. It should always be <tt>"."</tt> because whether it exists shouldn't matter.
<p/>
The problem is in <tt>filesystem::path::lexically_relative</tt>, as shown by:
</p>
<blockquote><pre>
path("/dir").lexically_relative("/dir/.");  <i>// yields ""</i>
path("/dir").lexically_relative("/dir/");   <i>// yields ".."</i>
</pre></blockquote>
<p>
The two calls should yield the same result, and when iteration of a <tt>path</tt> with a trailing slash gave "." as the final 
element they did yield the same result. In the final C++17 spec the trailing slash produces an empty filename in the 
iteration sequence, and <tt>lexically_relative</tt> doesn't handle that correctly.
</p>

<p><i>[2018-04-10, Jonathan comments]</i></p>

<p>
There are more inconsistencies with paths that are "obviously" equivalent to the human reader:
</p>
<blockquote><pre>
path("a/b/c").lexically_relative("a/b/c")    <i>// yields</i> "."
path("a/b/c").lexically_relative("a/b/c/")   <i>// yields</i> ".."
path("a/b/c").lexically_relative("a/b/c/.")  <i>// yields</i> ""
path("a/b/c/").lexically_relative("a/b/c")   <i>// yields</i> ""
path("a/b/c/.").lexically_relative("a/b/c")  <i>// yields</i> "."
path("a/b/c/.").lexically_relative("a/b/c/") <i>// yields</i> "../."
</pre></blockquote>
<p>
I think the right solution is:
</p>
<ol>
<li><p>
when counting <tt>[b, base.end())</tt> in bullet (4.2) handle empty filename elements (which can only occur as the last 
element, due to a trailing slash) equivalently to dot elements; and
</p></li>
<li><p>
add a new condition for the case where <tt>n == 0</tt> and <tt>[a, end())</tt> contains no non-empty elements, i.e. the 
paths are equivalent except for final dots or a final slash, which don't introduce any relative difference between the paths.
</p></li>
</ol>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 2</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li>
<p>Edit 27.11.7.4.11 <a href="https://timsong-cpp.github.io/cppwp/fs.path.gen">[fs.path.gen]</a> as indicated:</p>
<blockquote>
<pre>
path lexically_relative(const path&amp; base) const;
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <tt>*this</tt> made relative to <tt>base</tt>. Does not resolve (27.11.7 <a href="https://timsong-cpp.github.io/cppwp/fs.class.path">[fs.class.path]</a>) symlinks. 
Does not first normalize (27.11.7.1 <a href="https://timsong-cpp.github.io/cppwp/fs.path.generic">[fs.path.generic]</a>) <tt>*this</tt> or <tt>base</tt>.
<p/>
-4- <i>Effects:</i> If <tt>root_name() != base.root_name()</tt> is <tt>true</tt> or <tt>is_absolute() != base.is_absolute()</tt>
is <tt>true</tt> or <tt>!has_root_directory() &amp;&amp; base.has_root_directory()</tt> is <tt>true</tt>, returns <tt>path()</tt>. 
Determines the first mismatched element of <tt>*this</tt> and <tt>base</tt> as if by:
</p>
<blockquote><pre>
auto [a, b] = mismatch(begin(), end(), base.begin(), base.end());
</pre></blockquote>
<p>
Then,
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; if <tt>a == end()</tt> and <tt>b == base.end()</tt>, returns <tt>path(".")</tt>; otherwise</p></li>
<li><p>(4.2) &mdash; let <tt>n</tt> be the number of <i>filename</i> elements in <tt>[b, base.end())</tt> that are not dot 
or dot-dot <ins>or empty,</ins> minus the number that are dot-dot. If <tt>n&lt;0</tt>, returns <tt>path()</tt>; otherwise</p></li>
<li><p><ins>(4.?) &mdash; if <tt>n == 0</tt> and <tt>(a == end() || a-&gt;empty())</tt>, returns <tt>path(".")</tt>; otherwise</ins></p></li>
<li><p>(4.3) &mdash; returns an object of class <tt>path</tt> that is default-constructed, followed by [&hellip;]</p></li>
</ol>

</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3106" href="3106">3106.</a> <tt>nothrow</tt> should be <tt>inline constexpr</tt> rather that <tt>extern const</tt></h3>
<p><b>Section:</b> 16.6.1 <a href="https://timsong-cpp.github.io/cppwp/new.syn">[new.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Antony Polukhin <b>Opened:</b> 2018-04-25 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::nothrow</tt> in [new.syn] is declared as '<tt>extern const nothrow_t nothrow;</tt>'. Unfortunately 
this declaration requires linking with Standard Library (which does not work well on GCC with <tt>-nostdlib</tt> flag).
Moreover the declaration differs from other Standard Library tags that are '<tt>inline constexpr</tt>'.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 2</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively NAD - if we had a status 'Wont Fix' that would be correct.</p>
<p>This is an ABI break for most implementations, and people can define their 
own variable of type <tt>std::nothrow_t</tt> if they want a constexpr one.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4741">N4741</a>.
</p>

<ol>
<li>
<p>Edit 16.6.1 <a href="https://timsong-cpp.github.io/cppwp/new.syn">[new.syn]</a> as indicated:</p>
<blockquote>
<pre>
struct nothrow_t { explicit nothrow_t() = default; };
<del>extern const</del><ins>inline constexpr</ins> nothrow_t nothrow;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3122" href="3122">3122.</a> <tt>__cpp_lib_chrono_udls</tt> was accidentally dropped</h3>
<p><b>Section:</b> 16.3.1 <a href="https://timsong-cpp.github.io/cppwp/support.limits.general">[support.limits.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2018-06-14 <b>Last modified:</b> 2018-06-25 00:47:25 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.limits.general">active issues</a> in [support.limits.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.limits.general">issues</a> in [support.limits.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Between <a href="http://wg21.link/p0941r0">P0941R0</a> and 
<a href="http://wg21.link/p0941r1">P0941R1</a>/<a href="http://wg21.link/p0941r2">P0941R2</a>, the feature-test macro 
<tt>__cpp_lib_chrono_udls</tt> was dropped. It wasn't mentioned in the changelog, and Jonathan Wakely and I 
believe that this was unintentional.
</p>

<p><i>[2018-06-23 Moved to Tentatively Ready after 5 positive votes on c++std-lib.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to the post-Rapperswil 2018 working draft.
</p>

<p>In 16.3.1 <a href="https://timsong-cpp.github.io/cppwp/support.limits.general">[support.limits.general]</a>, "Table ??? - Standard library feature-test macros", add the following row:</p>

<blockquote>

<table border="1">
<caption>Table ??? &mdash; Standard library feature-test macros</caption>
<tr style="text-align:center">
<th>Macro name</th>
<th>Value</th>
<th>Headers</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td><ins><tt>__cpp_lib_chrono_udls</tt></ins></td>
<td><ins><tt>201304L</tt></ins></td>
<td><ins><tt>&lt;chrono&gt;</tt></ins></td>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
</table>

</blockquote>





<hr>
<h3><a name="3127" href="3127">3127.</a> <tt>basic_osyncstream::rdbuf</tt> needs a <tt>const_cast</tt></h3>
<p><b>Section:</b> 27.10.3.1 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.overview">[syncstream.osyncstream.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-06-29 <b>Last modified:</b> 2018-07-20 21:06:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <tt>basic_osyncstream::rdbuf()</tt> is
</p>
<blockquote>
<pre>
    syncbuf_type* rdbuf() const noexcept { return &amp;sb; }
</pre>
</blockquote>
<p>
This is ill-formed because the exposition-only member <tt>sb</tt> is <tt>const</tt> inside this <tt>const</tt> member function,
but the return type is a pointer to non-<tt>const</tt> <tt>syncbuf_type</tt>. It needs to cast away the constness, consistent
with the other streams with embedded stream buffers (such as string and file streams).
</p>

<p><i>[2018-07-20 Status set to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.
</p>

<ol>
<li>
<p>Change 27.10.3.1 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.overview">[syncstream.osyncstream.overview]</a>, class template <tt>basic_osyncstream</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits, class Allocator&gt;
  class basic_osyncstream : public basic_ostream&lt;charT, traits&gt; {
  public:
    [&hellip;]

    // 27.10.3.4 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.members">[syncstream.osyncstream.members]</a>, member functions
    void emit();
    streambuf_type* get_wrapped() const noexcept;
    syncbuf_type* rdbuf() const noexcept { return <ins>const_cast&lt;syncbuf_type*&gt;(</ins>&amp;sb<ins>)</ins>; }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3128" href="3128">3128.</a> <tt>strstream::rdbuf</tt> needs a <tt>const_cast</tt></h3>
<p><b>Section:</b> D.8.5.3 <a href="https://timsong-cpp.github.io/cppwp/depr.strstream.oper">[depr.strstream.oper]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-06-30 <b>Last modified:</b> 2018-07-20 21:06:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>strstream::rdbuf</tt> has the same issue with a missing <tt>const_cast</tt> on <tt>&amp;sb</tt>.
<p/>
Somewhat amusingly, <tt>istrstream::rdbuf</tt> and <tt>ostrstream::rdbuf</tt> got this right,
but each with a different style (see issue <a href="252">252</a>).
</p>

<p><i>[2018-07-20 Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.
</p>

<ol>
<li>
<p>
Change D.8.5.3 <a href="https://timsong-cpp.github.io/cppwp/depr.strstream.oper">[depr.strstream.oper]</a> p1 as indicated:
</p>
<blockquote>
<pre>
strstreambuf* rdbuf() const;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt><ins>const_cast&lt;strstreambuf*&gt;(</ins>&amp;sb<ins>)</ins></tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3129" href="3129">3129.</a> <tt>regex_token_iterator</tt> constructor uses wrong pointer arithmetic</h3>
<p><b>Section:</b> 28.12.2.1 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.cnstr">[re.tokiter.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-06-30 <b>Last modified:</b> 2018-07-20 21:06:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.tokiter.cnstr">issues</a> in [re.tokiter.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>regex_token_iterator</tt> for the overload taking a 
<tt>const int (&amp;submatchs)[N]</tt> uses the range <tt>[&amp;submatches, &amp;submatches + N)</tt>.
This is obviously incorrect; we want to perform pointer arithmetic on a pointer to the first element
of that array, not a pointer to the whole array.
</p>

<p><i>[2018-07-20 Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.
</p>

<ol>
<li>
<p>
Change 28.12.2.1 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.cnstr">[re.tokiter.cnstr]</a> p3 as indicated:
</p>
<blockquote>
<pre>
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     int submatch = 0,
                     regex_constants::match_flag_type m = regex_constants::match_default);

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     const vector&lt;int&gt;&amp; submatches,
                     regex_constants::match_flag_type m = regex_constants::match_default);

regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                     const regex_type&amp; re,
                     initializer_list&lt;int&gt; submatches,
                     regex_constants::match_flag_type m = regex_constants::match_default);

template&lt;size_t N&gt;
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
                       const regex_type&amp; re,
                       const int (&amp;submatches)[N],
                       regex_constants::match_flag_type m = regex_constants::match_default);
</pre>
<blockquote>
<p>
-2- <i>Requires:</i> [&hellip;]
<p/>
-3- <i>Effects:</i> The first constructor initializes the member <tt>subs</tt> to hold the single
value <tt>submatch</tt>. <del>The second constructor initializes the member <tt>subs</tt> to hold a
copy of the argument <tt>submatches</tt>.</del> The <ins>second,</ins> third and fourth constructors 
initialize the member <tt>subs</tt> to hold a copy of the sequence of integer values pointed to
by the iterator range <del><tt>[submatches.begin(), submatches.end())</tt> and <tt>[&amp;submatches,
&amp;submatches + N)</tt>, respectively</del><ins><tt>[begin(submatches), end(submatches))</tt></ins>.
<p/>
-4- [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3130" href="3130">3130.</a> &sect;[input.output] needs many <tt>addressof</tt></h3>
<p><b>Section:</b> 27 <a href="https://timsong-cpp.github.io/cppwp/input.output">[input.output]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-06-30 <b>Last modified:</b> 2018-07-20 21:06:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#input.output">active issues</a> in [input.output].</p>
<p><b>View all other</b> <a href="lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are 27 instances of <tt>&amp;sb</tt> and one instance of <tt>&amp;rhs</tt> in 
Clause 27 <a href="https://timsong-cpp.github.io/cppwp/input.output">[input.output]</a>, each of which needs to use <tt>addressof</tt> because
the operand has a user-provided template type parameter as an associated class and so
the use of unary <tt>&amp;</tt> is subject to ADL hijacking.
</p>

<p><i>[2018-07-20 Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.
</p>

<ol>
<li>
<p>
Change 27.5.5.3 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.members">[basic.ios.members]</a> p16 as indicated:
</p>
<blockquote>
<pre>
basic_ios&amp; copyfmt(const basic_ios&amp; rhs);
</pre>
<blockquote>
<p>
-16- <i>Effects:</i> If <tt>(this == <del>&amp;</del><ins>addressof(</ins>rhs<ins>)</ins>)</tt> 
does nothing. [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.8.3.1 <a href="https://timsong-cpp.github.io/cppwp/istringstream.cons">[istringstream.cons]</a> as indicated:
</p>
<blockquote>
<pre>
explicit basic_istringstream(ios_base::openmode which);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Constructs an object of class <tt>basic_istringstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_istream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.4.1 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a>) and initializing <tt>sb</tt> with 
<tt>basic_stringbuf&lt;charT, traits, Allocator&gt;(which | ios_base::in)</tt> (27.8.2.1 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.cons">[stringbuf.cons]</a>).
</p>
</blockquote>
<pre>
explicit basic_istringstream(
  const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
  ios_base::openmode which = ios_base::in);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Constructs an object of class <tt>basic_istringstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_istream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.4.1 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a>) and initializing <tt>sb</tt> with 
<tt>basic_stringbuf&lt;charT, traits, Allocator&gt;(str, which | ios_base::in)</tt> (27.8.2.1 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.cons">[stringbuf.cons]</a>).
</p>
</blockquote>
<pre>
basic_istringstream(basic_istringstream&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. This is accomplished
by move constructing the base class, and the contained <tt>basic_stringbuf</tt>.
Next <tt>basic_istream&lt;charT, traits&gt;::set_rdbuf(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
is called to install the contained <tt>basic_stringbuf</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.8.3.3 <a href="https://timsong-cpp.github.io/cppwp/istringstream.members">[istringstream.members]</a> p1 as indicated:
</p>
<blockquote>
<pre>
basic_stringbuf&lt;charT, traits, Allocator&gt;* rdbuf() const;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>const_cast&lt;basic_stringbuf&lt;charT, traits, Allocator&gt;*&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.8.4.1 <a href="https://timsong-cpp.github.io/cppwp/ostringstream.cons">[ostringstream.cons]</a> as indicated:
</p>
<blockquote>
<pre>
explicit basic_ostringstream(ios_base::openmode which);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Constructs an object of class <tt>basic_ostringstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_ostream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.5.1 <a href="https://timsong-cpp.github.io/cppwp/ostream">[ostream]</a>) and initializing <tt>sb</tt> with 
<tt>basic_stringbuf&lt;charT, traits, Allocator&gt;(which | ios_base::out)</tt> (27.8.2.1 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.cons">[stringbuf.cons]</a>).
</p>
</blockquote>
<pre>
explicit basic_ostringstream(
  const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
  ios_base::openmode which = ios_base::out);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Constructs an object of class <tt>basic_ostringstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_ostream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.5.1 <a href="https://timsong-cpp.github.io/cppwp/ostream">[ostream]</a>) and initializing <tt>sb</tt> with
<tt>basic_stringbuf&lt;charT, traits, Allocator&gt;(str, which | ios_base::out)</tt> (27.8.2.1 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.cons">[stringbuf.cons]</a>).
</p>
</blockquote>
<pre>
basic_ostringstream(basic_ostringstream&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. This is accomplished 
by move constructing the base class, and the contained <tt>basic_stringbuf</tt>. 
Next <tt>basic_ostream&lt;charT, traits&gt;::set_rdbuf(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
is called to install the contained <tt>basic_stringbuf</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.8.4.3 <a href="https://timsong-cpp.github.io/cppwp/ostringstream.members">[ostringstream.members]</a> p1 as indicated:
</p>
<blockquote>
<pre>
basic_stringbuf&lt;charT, traits, Allocator&gt;* rdbuf() const;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>const_cast&lt;basic_stringbuf&lt;charT, traits, Allocator&gt;*&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.8.5.1 <a href="https://timsong-cpp.github.io/cppwp/stringstream.cons">[stringstream.cons]</a> as indicated:
</p>
<blockquote>
<pre>
explicit basic_stringstream(ios_base::openmode which);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Constructs an object of class <tt>basic_stringstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_iostream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/iostream.cons">[iostream.cons]</a>) and initializing <tt>sb</tt> with 
<tt>basic_stringbuf&lt;charT, traits, Allocator&gt;(which)</tt>.
</p>
</blockquote>
<pre>
explicit basic_stringstream(
  const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
  ios_base::openmode which = ios_base::out | ios_base::in);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Constructs an object of class <tt>basic_stringstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_iostream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/iostream.cons">[iostream.cons]</a>) and initializing <tt>sb</tt> with 
<tt>basic_stringbuf&lt;charT, traits, Allocator&gt;(str, which)</tt>.
</p>
</blockquote>
<pre>
basic_stringstream(basic_stringstream&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. This is accomplished 
by move constructing the base class, and the contained <tt>basic_stringbuf</tt>. 
Next <tt>basic_istream&lt;charT, traits&gt;::set_rdbuf(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
is called to install the contained <tt>basic_stringbuf</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.8.5.3 <a href="https://timsong-cpp.github.io/cppwp/stringstream.members">[stringstream.members]</a> p1 as indicated:
</p>
<blockquote>
<pre>
basic_stringbuf&lt;charT, traits, Allocator&gt;* rdbuf() const;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>const_cast&lt;basic_stringbuf&lt;charT, traits, Allocator&gt;*&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt><ins>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.9.3.1 <a href="https://timsong-cpp.github.io/cppwp/ifstream.cons">[ifstream.cons]</a> as indicated:
</p>
<blockquote>
<pre>
basic_ifstream();
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Constructs an object of class <tt>basic_ifstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_istream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.4.1.1 <a href="https://timsong-cpp.github.io/cppwp/istream.cons">[istream.cons]</a>) and initializing <tt>sb</tt> with 
<tt>basic_filebuf&lt;charT, traits&gt;()</tt> (27.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/filebuf.cons">[filebuf.cons]</a>).
</p>
</blockquote>
<pre>
explicit basic_ifstream(const char* s,
                        ios_base::openmode mode = ios_base::in);
explicit basic_ifstream(const filesystem::path::value_type* s,
                        ios_base::openmode mode = ios_base::in);  // wide systems only; see 27.9.1 <a href="https://timsong-cpp.github.io/cppwp/fstream.syn">[fstream.syn]</a>
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Constructs an object of class <tt>basic_ifstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_istream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.4.1.1 <a href="https://timsong-cpp.github.io/cppwp/istream.cons">[istream.cons]</a>) and initializing <tt>sb</tt> with 
<tt>basic_filebuf&lt;charT, traits&gt;()</tt> (27.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/filebuf.cons">[filebuf.cons]</a>), then calls 
<tt>rdbuf()-&gt;open(s, mode | ios_base::in)</tt>. If that function returns a null pointer, calls <tt>setstate(failbit)</tt>.
</p>
</blockquote>
<p>[&hellip;]</p>
<pre>
basic_ifstream(basic_ifstream&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. This is accomplished 
by move constructing the base class, and the contained <tt>basic_filebuf</tt>. 
Next <tt>basic_istream&lt;charT, traits&gt;::set_rdbuf(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
is called to install the contained <tt>basic_filebuf</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.9.3.3 <a href="https://timsong-cpp.github.io/cppwp/ifstream.members">[ifstream.members]</a> p1 as indicated:
</p>
<blockquote>
<pre>
basic_filebuf&lt;charT, traits&gt;* rdbuf() const;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>const_cast&lt;basic_filebuf&lt;charT, traits&gt;*&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.9.4.1 <a href="https://timsong-cpp.github.io/cppwp/ofstream.cons">[ofstream.cons]</a> as indicated:
</p>
<blockquote>
<pre>
basic_ofstream();
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Constructs an object of class <tt>basic_ofstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_ostream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.cons">[ostream.cons]</a>) and initializing <tt>sb</tt> with 
<tt>basic_filebuf&lt;charT, traits&gt;()</tt> (27.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/filebuf.cons">[filebuf.cons]</a>).
</p>
</blockquote>
<pre>
explicit basic_ofstream(const char* s,
                        ios_base::openmode mode = ios_base::out);
explicit basic_ofstream(const filesystem::path::value_type* s,
                        ios_base::openmode mode = ios_base::out);  // wide systems only; see 27.9.1 <a href="https://timsong-cpp.github.io/cppwp/fstream.syn">[fstream.syn]</a>
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Constructs an object of class <tt>basic_ofstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_ostream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.cons">[ostream.cons]</a>) and initializing <tt>sb</tt> with 
<tt>basic_filebuf&lt;charT, traits&gt;()</tt> (27.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/filebuf.cons">[filebuf.cons]</a>), then calls 
<tt>rdbuf()-&gt;open(s, mode | ios_base::out)</tt>. If that function returns a null pointer, calls <tt>setstate(failbit)</tt>.
</p>
</blockquote>
<p>[&hellip;]</p>
<pre>
basic_ofstream(basic_ofstream&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. This is accomplished 
by move constructing the base class, and the contained <tt>basic_filebuf</tt>. 
Next <tt>basic_ostream&lt;charT, traits&gt;::set_rdbuf(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
is called to install the contained <tt>basic_filebuf</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.9.4.3 <a href="https://timsong-cpp.github.io/cppwp/ofstream.members">[ofstream.members]</a> p1 as indicated:
</p>
<blockquote>
<pre>
basic_filebuf&lt;charT, traits&gt;* rdbuf() const;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>const_cast&lt;basic_filebuf&lt;charT, traits&gt;*&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.9.5.1 <a href="https://timsong-cpp.github.io/cppwp/fstream.cons">[fstream.cons]</a> as indicated:
</p>
<blockquote>
<pre>
basic_fstream();
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Constructs an object of class <tt>basic_fstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_iostream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/iostream.cons">[iostream.cons]</a>) and initializing <tt>sb</tt> with 
<tt>basic_filebuf&lt;charT, traits&gt;()</tt>.
</p>
</blockquote>
<pre>
explicit basic_fstream(
  const char* s,
  ios_base::openmode mode = ios_base::in | ios_base::out);
explicit basic_fstream(
  const filesystem::path::value_type* s,
  ios_base::openmode mode = ios_base::in | ios_base::out);  // wide systems only; see 27.9.1 <a href="https://timsong-cpp.github.io/cppwp/fstream.syn">[fstream.syn]</a>
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Constructs an object of class <tt>basic_fstream&lt;charT, traits&gt;</tt>,
initializing the base class with <tt>basic_iostream&lt;charT, traits&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
(27.7.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/iostream.cons">[iostream.cons]</a>) and initializing <tt>sb</tt> with 
<tt>basic_filebuf&lt;charT, traits&gt;()</tt>, then calls <tt>rdbuf()-&gt;open(s, mode)</tt>.
If that function returns a null pointer, calls <tt>setstate(failbit)</tt>.
</p>
</blockquote>
<p>[&hellip;]</p>
<pre>
basic_fstream(basic_fstream&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. This is accomplished 
by move constructing the base class, and the contained <tt>basic_filebuf</tt>. 
Next <tt>basic_istream&lt;charT, traits&gt;::set_rdbuf(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>
is called to install the contained <tt>basic_filebuf</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.9.5.3 <a href="https://timsong-cpp.github.io/cppwp/fstream.members">[fstream.members]</a> p1 as indicated:
</p>
<blockquote>
<pre>
basic_filebuf&lt;charT, traits&gt;* rdbuf() const;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>const_cast&lt;basic_filebuf&lt;charT, traits&gt;*&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 27.10.3.1 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.overview">[syncstream.osyncstream.overview]</a>, class template <tt>basic_osyncstream</tt> synopsis, as indicated:
</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The text shown below assumes the application of the proposed resolution of issue <a href="3127">3127</a>.]
</p>
</blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits, class Allocator&gt;
  class basic_osyncstream : public basic_ostream&lt;charT, traits&gt; {
  public:
    [&hellip;]

    // 27.10.3.4 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.members">[syncstream.osyncstream.members]</a>, member functions
    void emit();
    streambuf_type* get_wrapped() const noexcept;
    syncbuf_type* rdbuf() const noexcept { return const_cast&lt;syncbuf_type*&gt;(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>); }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li>
<p>
Change 27.10.3.2 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.cons">[syncstream.osyncstream.cons]</a> p1 and p4 as indicated:
</p>
<blockquote>
<pre>
basic_osyncstream(streambuf_type* buf, const Allocator&amp; allocator);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Initializes <tt>sb</tt> from <tt>buf</tt> and <tt>allocator</tt>. 
Initializes the base class with <tt>basic_ostream<ins>&lt;charT, traits&gt;</ins>(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>.
<p/>
-2- [&hellip;]
<p/>
-3- [&hellip;]
</p>
</blockquote>
<pre>
basic_osyncstream(basic_osyncstream&amp;&amp; other) noexcept;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Move constructs the base class and <tt>sb</tt> from the corresponding subobjects of <tt>other</tt>,
and calls <tt>basic_ostream&lt;charT, traits&gt;::set_rdbuf(<del>&amp;</del><ins>addressof(</ins>sb<ins>)</ins>)</tt>.
<p/>
-5- [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3131" href="3131">3131.</a> <tt>addressof</tt> all the things</h3>
<p><b>Section:</b> 25.12 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a>, 20.3.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/string.accessors">[string.accessors]</a>, 20.4.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a>, 21.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, 22.2.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>, 22.2.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a>, 28.7 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>, 28.12.1 <a href="https://timsong-cpp.github.io/cppwp/re.regiter">[re.regiter]</a>, 30.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-06-30 <b>Last modified:</b> 2018-07-20 21:06:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Some additional instances where the library specification applies unary
operator <tt>&amp;</tt> when it should use <tt>addressof</tt>.
</p>

<p><i>[2018-07-20 Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.
</p>
<blockquote class="note">
<p>
[<i>Drafting note:</i> Two uses of <tt>&amp;</tt> in 22.5.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a> are not included in 
the wording below because the entire sentence is slated to be removed by a revision of <a href="http://wg21.link/p0896">P0896</a>,
the One Ranges Proposal.]
</p>
</blockquote>
<ol>
<li>
<p>
Change 25.12 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> p4-5 as indicated:
</p>
<blockquote>
<pre>
template&lt;class charT, class traits, class Alloc, class Parsable&gt;
  <i>unspecified</i>
    parse(const basic_string&lt;charT, traits, Alloc&gt;&amp; fmt, Parsable&amp; tp,
          basic_string&lt;charT, traits, Alloc&gt;&amp; abbrev);
</pre>
<blockquote>
<p>
-4- <i>Remarks:</i> This function shall not participate in overload resolution unless
</p>
<blockquote>
<pre>
from_stream(declval&lt;basic_istream&lt;charT, traits&gt;&amp;&gt;(), fmt.c_str(), tp, <del>&amp;</del><ins>addressof(</ins>abbrev<ins>)</ins>)
</pre>
</blockquote>
<p>
is a valid expression.
<p/>
-5- <i>Returns:</i> A manipulator that, when extracted from a <tt>basic_istream&lt;charT, traits&gt; is</tt>,
calls <tt>from_stream(is, fmt.c_str(), tp, <del>&amp;</del><ins>addressof(</ins>abbrev<ins>)</ins>)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 25.12 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> p8-9 as indicated:
</p>
<blockquote>
<pre>
template&lt;class charT, class traits, class Alloc, class Parsable&gt;
  <i>unspecified</i>
    parse(const basic_string&lt;charT, traits, Alloc&gt;&amp; fmt, Parsable&amp; tp,
          basic_string&lt;charT, traits, Alloc&gt;&amp; abbrev, minutes&amp; offset);
</pre>
<blockquote>
<p>
-8- <i>Remarks:</i> This function shall not participate in overload resolution unless
</p>
<blockquote>
<pre>
from_stream(declval&lt;basic_istream&lt;charT, traits&gt;&amp;&gt;(), fmt.c_str(), tp, <del>&amp;</del><ins>addressof(</ins>abbrev<ins>)</ins>, &amp;offset)
</pre>
</blockquote>
<p>
is a valid expression.
<p/>
-9- <i>Returns:</i> A manipulator that, when extracted from a <tt>basic_istream&lt;charT, traits&gt; is</tt>,
calls <tt>from_stream(is, fmt.c_str(), tp, <del>&amp;</del><ins>addressof(</ins>abbrev<ins>)</ins>, &amp;offset)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.3.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/string.accessors">[string.accessors]</a> p1 and p4 as indicated:
</p>
<blockquote>
<pre>
const charT* c_str() const noexcept;
const charT* data() const noexcept;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> A pointer <tt>p</tt> such that <tt>p + i == <del>&amp;</del><ins>addressof(</ins>operator[](i)<ins>)</ins></tt>
for each <tt>i</tt> in <tt>[0, size()]</tt>.
<p/>
-2- <i>Complexity:</i> Constant time.
<p/>
-3- <i>Requires:</i> The program shall not alter any of the values stored in the character array.
</p>
</blockquote>
<pre>
charT* data() noexcept;
</pre>
<blockquote>
<p>
-4- <i>Returns:</i> A pointer <tt>p</tt> such that <tt>p + i == <del>&amp;</del><ins>addressof(</ins>operator[](i)<ins>)</ins></tt>
for each <tt>i</tt> in <tt>[0, size()]</tt>.
<p/>
-5- <i>Complexity:</i> Constant time.
<p/>
-6- <i>Requires:</i> The program shall not alter the value stored at <tt>p + size()</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.iterators">[string.view.iterators]</a> p4 as indicated:
</p>
<blockquote>
<pre>
constexpr const_iterator begin() const noexcept;
constexpr const_iterator cbegin() const noexcept;
</pre>
<blockquote>
<p>
-4- <i>Returns:</i> An iterator such that
<p/>
(4.1) &mdash; if <tt>!empty()</tt>, <tt><del>&amp;</del><ins>addressof(</ins>*begin()<ins>)</ins> == data_</tt>,
<p/>
(4.2) &mdash; otherwise, an unspecified value such that <tt>[begin(), end())</tt> is a valid range.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> p21 and p24 as indicated:
</p>
<blockquote>
<pre>
constexpr bool starts_with(charT x) const noexcept;
</pre>
<blockquote>
<p>
-21- <i>Effects:</i> Equivalent to: <tt>return starts_with(basic_string_view(<del>&amp;</del><ins>addressof(</ins>x<ins>)</ins>, 1));</tt>
</p>
</blockquote>
<p>[&hellip;]</p>
<pre>
constexpr bool ends_with(charT x) const noexcept;
</pre>
<blockquote>
<p>
-24- <i>Effects:</i> Equivalent to: <tt>return ends_with(basic_string_view(<del>&amp;</del><ins>addressof(</ins>x<ins>)</ins>, 1));</tt>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.7 <a href="https://timsong-cpp.github.io/cppwp/string.view.find">[string.view.find]</a> p5 as indicated:
</p>
<blockquote>
<p>
-5- Each member function of the form
</p>
<blockquote>
<pre>
constexpr <i>return-type</i> <i>F</i>(charT c, size_type pos);
</pre>
</blockquote>
<p>
is equivalent to <tt>return <i>F</i>(basic_string_view(<del>&amp;</del><ins>addressof(</ins>c<ins>)</ins>, 1), pos);</tt>
</p>
</blockquote>
</li>

<li>
<p>
Edit 21.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, Table 77 &mdash; "Container requirements", as indicated:
</p>
<blockquote>
<table border="1">
<caption>Table 77 &mdash; Container requirements</caption>
<tr style="text-align:center">
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion/note<br/>pre/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td colspan="5" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt><del>(&amp;a)-&gt;</del><ins>a.</ins>~X()</tt>
</td>
<td>
<tt>void</tt>
</td>
<td></td>
<td>
the destructor is applied to every element of <tt>a</tt>; any memory obtained is deallocated.
</td>
<td>
linear
</td>
</tr>
<tr>
<td colspan="5" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
</table>
</blockquote>
</li>

<li>
<p>
Edit 22.2.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>, Table 90 &mdash; "Output iterator requirements (in addition to Iterator)", as indicated:
</p>
<blockquote>
<table border="1">
<caption>Table 90 &mdash; Output iterator requirements (in addition to Iterator)</caption>
<tr style="text-align:center">
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion/note<br/>pre/post-condition</th>
</tr>
<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>++r</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td></td>
<td>
<tt><del>&amp;</del><ins>addressof(</ins>r<ins>)</ins> == <del>&amp;</del><ins>addressof(</ins>++r<ins>)</ins></tt>.
<br/>[&hellip;]
</td>
</tr>
<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
</table>
</blockquote>
</li>

<li>
<p>
Edit 22.2.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a>, Table 92 &mdash; "Bidirectional iterator requirements (in addition to forward iterator)", as indicated:
</p>
<blockquote>
<table border="1">
<caption>Table 92 &mdash; Bidirectional iterator requirements (in addition to forward iterator)</caption>
<tr style="text-align:center">
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion/note<br/>pre/post-condition</th>
</tr>
<tr>
<td>
<tt>--r</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td></td>
<td>
[&hellip;]
<br/>
<tt><del>&amp;</del><ins>addressof(</ins>r<ins>)</ins> == <del>&amp;</del><ins>addressof(</ins>--r<ins>)</ins></tt>.
</td>
</tr>
<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
</table>
</blockquote>
</li>
<li>
<p>
Change 28.7 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a> p6 as indicated:
</p>
<blockquote>
<pre>
template&lt;class ForwardIterator&gt;
  string_type transform(ForwardIterator first, ForwardIterator last) const;
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> As if by:
</p>
<blockquote>
<pre>
string_type str(first, last);
return use_facet&lt;collate&lt;charT&gt;&gt;(
  getloc()).transform(<del>&amp;*</del>str.<del>begin</del><ins>data</ins>(), <del>&amp;*</del>str.<del>begin</del><ins>data</ins>() + str.length());
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 28.12.1.1 <a href="https://timsong-cpp.github.io/cppwp/re.regiter.cnstr">[re.regiter.cnstr]</a> p2 as indicated:
</p>
<blockquote>
<pre>
regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
               const regex_type&amp; re,
               regex_constants::match_flag_type m = regex_constants::match_default);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Initializes <tt>begin</tt> and <tt>end</tt> to <tt>a</tt> and <tt>b</tt>, respectively,
sets <tt>pregex</tt> to <tt><del>&amp;</del><ins>addressof(</ins>re<ins>)</ins></tt>, sets <tt>flags</tt> to <tt>m</tt>,
then calls <tt>regex_search(begin, end, match, *pregex, flags)</tt>. If this call returns <tt>false</tt>
the constructor sets <tt>*this</tt> to the end-of-sequence iterator.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 28.12.1.3 <a href="https://timsong-cpp.github.io/cppwp/re.regiter.deref">[re.regiter.deref]</a> p2 as indicated:
</p>
<blockquote>
<pre>
const value_type* operator-&gt;() const;
</pre>
<blockquote>
<p>
-2- <i>Returns:</i> <tt><del>&amp;</del><ins>addressof(</ins>match<ins>)</ins></tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 30.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a> p2-7 as indicated:
</p>
<blockquote>
<pre>
explicit lock_guard(mutex_type&amp; m);
</pre>
<blockquote>
<p>
-2- <i>Requires:</i> If <tt>mutex_type</tt> is not a recursive mutex, the calling thread does not own the mutex <tt>m</tt>.
<p/>
-3- <i>Effects:</i> <del>As if by</del><ins>Initializes <tt>pm</tt> with <tt>m</tt>. Calls</ins> <tt>m.lock()</tt>.
<p/>
<del>-4- <i>Postconditions:</i> <tt>&amp;pm == &amp;m</tt></del>
</p>
</blockquote>
<pre>
lock_guard(mutex_type&amp; m, adopt_lock_t);
</pre>
<blockquote>
<p>
-5- <i>Requires:</i> The calling thread owns the mutex <tt>m</tt>.
<p/>
-6- <del><i>Postconditions:</i> <tt>&amp;pm == &amp;m</tt></del><ins><i>Effects:</i> Initializes <tt>pm</tt> with <tt>m</tt>.</ins>
<p/>
-7- <i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3132" href="3132">3132.</a> Library needs to ban macros named <tt>expects</tt> or <tt>ensures</tt></h3>
<p><b>Section:</b> 15.5.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-06-30 <b>Last modified:</b> 2018-08-04 14:48:40 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#macro.names">active issues</a> in [macro.names].</p>
<p><b>View all other</b> <a href="lwg-index.html#macro.names">issues</a> in [macro.names].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>expects</tt> and <tt>ensures</tt> are not technically described as <i>attribute-tokens</i> when used 
in a <i>contract-attribute-specifier</i>, so the existing prohibition in 15.5.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a>
doesn't apply to them.
<p/>
The remaining special identifiers used by the contract attributes are all already covered by existing wording:
<tt>assert</tt> is also a library name so falls under p1, <tt>default</tt> is a keyword, and both <tt>axiom</tt>
and <tt>audit</tt> were added to Table 4.
</p>

<p><i>[2018-07-20 Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4762">N4762</a>.
</p>

<ol>
<li>
<p>
Change 15.5.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> p2 as indicated:
</p>
<blockquote>
<p>
-2- A translation unit shall not <tt>#define</tt> or <tt>#undef</tt> names lexically identical to keywords,
to the identifiers listed in Table 4, <del>or</del> to the <i>attribute-token</i>s described in 9.11 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr">[dcl.attr]</a><ins>,
or to the identifiers <tt>expects</tt> or <tt>ensures</tt></ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3134" href="3134">3134.</a> [fund.ts.v3] LFTSv3 contains extraneous [meta] variable templates that should have been deleted by P09961</h3>
<p><b>Section:</b> 3.3.1 [fund.ts.v3::meta.type.synop] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2018-07-02 <b>Last modified:</b> 2018-07-20 21:06:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v3::meta.type.synop">active issues</a> in [fund.ts.v3::meta.type.synop].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v3::meta.type.synop">issues</a> in [fund.ts.v3::meta.type.synop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
The LFTSv3 prospective-working-paper <a href="http://wg21.link/n4758">N4758</a> lists a large number of type trait 
variable templates in [meta.type.synop] that are duplicates of corresponding ones in C++17. The paper 
<a href="http://wg21.link/P0996R1">P0996R1</a> that was meant to rebase the LFTS on C++17 appears to have missed them.
</p>

<p><i>[2018-07-20 Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4758">N4758</a>.
</p>

<ol>
<li>
<p>
Delete from 3.3.1 [fund.ts.v3::meta.type.synop] all variable templates starting at <tt>is_void_v</tt> up to and including 
<tt>is_convertible_v</tt> as indicated:
</p>
<blockquote>
<pre>
#include &lt;type_traits&gt;

namespace std::experimental {
inline namespace fundamentals_v3 {

  <del><i>// See C++17 &sect;23.15.4.1, primary type categories</i>
  template &lt;class T&gt; constexpr bool is_void_v
    = is_void&lt;T&gt;::value;
  [&hellip;]
  template &lt;class From, class To&gt; constexpr bool is_convertible_v
    = is_convertible&lt;From, To&gt;::value;</del>

  // 3.3.2, Other type transformations
  template &lt;class&gt; class invocation_type; // not defined
  [&hellip;]
} // inline namespace fundamentals_v3
} // namespace std::experimental
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3137" href="3137">3137.</a> Header for <tt>__cpp_lib_to_chars</tt></h3>
<p><b>Section:</b> 16.3.1 <a href="https://timsong-cpp.github.io/cppwp/support.limits.general">[support.limits.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> S. B.Tam <b>Opened:</b> 2018-07-03 <b>Last modified:</b> 2018-07-20 21:06:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.limits.general">active issues</a> in [support.limits.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.limits.general">issues</a> in [support.limits.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After acceptance of <a href="http://wg21.link/P0941R2">P0941R2</a> into the working draft, in [support.limits.general], 
<tt>__cpp_lib_to_chars</tt> is required to be in <tt>&lt;utility&gt;</tt>. Since the relevant feature 
(<tt>std::to_chars</tt> and <tt>std::from_chars</tt>) is now in the header <tt>&lt;charconv&gt;</tt>, 
should the macro be defined in <tt>&lt;charconv&gt;</tt> instead of <tt>&lt;utility&gt;</tt>?
</p>
<p><i>[Marshall provides P/R and context]</i></p>

<p><tt>std::to_chars</tt>, etc were originally proposed for the header <tt>&lt;utility&gt;</tt>
and SD-6 reflected that. Somewhere along the way, they was put into their own header 
<tt>&lt;charconv&gt;</tt>, but the document was never updated to reflect that.</p>
<p>When these macros were added to the standard, the (now incorrect) value was copied as well.</p>

<p><i>[2018-07-20 Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to (the Rapperswil post-mailing standard).</p>

<p>Change 16.3.1 <a href="https://timsong-cpp.github.io/cppwp/support.limits.general">[support.limits.general]</a> (Table 35) as indicated:</p>

<table border="1">
<tr><th>Macro name</th><th>Value</th><th>Header(s)</th></tr>
<tr><td><tt>__cpp_lib_to_chars</tt></td><td><tt>201611L</tt></td><td><tt>&lt;<ins>charconv</ins><del>utility</del>&gt;</tt></td></tr>
</table>






<hr>
<h3><a name="3145" href="3145">3145.</a> <tt>file_clock</tt> breaks ABI for C++17 implementations</h3>
<p><b>Section:</b> 25.7.5 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file">[time.clock.file]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2018-07-26 <b>Last modified:</b> 2018-08-24 13:31:33 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It was pointed out in one of Eric's changes to libc++ <a href="https://reviews.llvm.org/D49774">here</a> that 
<a href="http://wg21.link/p0355">P0355</a> adds <tt>file_clock</tt>, which is intended to be the clock used for 
<tt>std::filesystem::file_time_type</tt>'s clock.
<p/>
Unfortunately, this is an ABI break for implementations that are already shipping C++17 filesystem that did not 
call their clock type <tt>std::file_clock</tt>. For example, MSVC++'s is called <tt>std::filesystem::_File_time_clock</tt>.
<p/>
We can keep much the same interface of <a href="http://wg21.link/p0355">P0355</a> by making <tt>file_clock</tt> 
a typedef for an unspecified type. This technically changes the associated namespaces for expressions using that 
clock for the sake of ADL, but I can't imagine a user who cares, as clocks aren't generally called in ADL-able 
expressions, <tt>duration</tt>s and <tt>time_point</tt>s are.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.
</p>

<ol>
<li>
<p>Change 25.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>, header <tt>&lt;chrono&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 25.7.5 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file">[time.clock.file]</a>, <del>class</del><ins>type</ins> file_clock</i>
<del>class</del><ins>using</ins> file_clock <ins>= <i>unspecified</i></ins>;
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>Change 25.7.5 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file">[time.clock.file]</a> as indicated:</p>

<blockquote>
<p>
<b>23.17.7.5 <del>Class</del><ins>Type</ins> <tt>file_clock</tt> [time.clock.file]</b>
</p>
</blockquote>
</li>

<li>
<p>Change 25.7.5.1 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file.overview">[time.clock.file.overview]</a>, class <tt>file_clock</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::chrono {
  <ins>using file_clock = <i>see below</i>;</ins>
  <del>class file_clock {
  public:
    using rep = <i>a signed arithmetic type</i>;
    using period = ratio&lt;<i>unspecified</i>, <i>unspecified</i>&gt;;
    using duration = chrono::duration&lt;rep, period&gt;;
    using time_point = chrono::time_point&lt;file_clock&gt;;
    static constexpr bool is_steady = <i>unspecified</i>;
    
    static time_point now() noexcept;
    
    <i>// Conversion functions, see below</i>
  };</del>
}
</pre>
<p>
-1- <del>The clock</del> <tt>file_clock</tt> <ins>is an alias for a type meeting the <tt>TrivialClock</tt> requirements 
(25.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a>), uses a signed arithmetic type for <tt>file_clock::rep</tt>, and</ins> is used to create the 
<tt>time_point</tt> system used for <tt>file_time_type</tt> (27.11 <a href="https://timsong-cpp.github.io/cppwp/filesystems">[filesystems]</a>). Its epoch is unspecified.
<ins>[<i>Note:</i> The type <tt>file_clock</tt> denotes may be in a different namespace than <tt>std::chrono</tt>, 
such as <tt>std::filesystem</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li>
<p>Change 25.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file.members">[time.clock.file.members]</a> as indicated:</p>

<blockquote>
<pre>
<del>static time_point now();</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Returns:</i> A <tt>file_clock::time_point</tt> indicating the current time.</del>
<p/>
-2- The class <del><tt>file_clock</tt> shall</del><ins>type denoted by <tt>file_clock</tt></ins> provide<ins>s</ins> 
precisely one of the following two sets of static member functions: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-07-30 Priority set to 1 after reflector discussion; wording updates based on several discussion contributions.]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4762">N4762</a>.
</p>

<ol>
<li>
<p>Change 25.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>, header <tt>&lt;chrono&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 25.7.5 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file">[time.clock.file]</a>, <del>class</del><ins>type</ins> file_clock</i>
<del>class</del><ins>using</ins> file_clock <ins>= <i>see below</i></ins>;
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>Change 25.7.5 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file">[time.clock.file]</a> as indicated:</p>

<blockquote>
<p>
<b>23.17.7.5 <del>Class</del><ins>Type</ins> <tt>file_clock</tt> [time.clock.file]</b>
</p>
</blockquote>
</li>

<li>
<p>Change 25.7.5.1 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file.overview">[time.clock.file.overview]</a>, class <tt>file_clock</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::chrono {
  <ins>using file_clock = <i>see below</i>;</ins>
  <del>class file_clock {
  public:
    using rep = <i>a signed arithmetic type</i>;
    using period = ratio&lt;<i>unspecified</i>, <i>unspecified</i>&gt;;
    using duration = chrono::duration&lt;rep, period&gt;;
    using time_point = chrono::time_point&lt;file_clock&gt;;
    static constexpr bool is_steady = <i>unspecified</i>;
    
    static time_point now() noexcept;
    
    <i>// Conversion functions, see below</i>
  };</del>
}
</pre>
<p>
-1- <del>The clock</del> <tt>file_clock</tt> <ins>is an alias for a type meeting the <tt>TrivialClock</tt> requirements 
(25.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a>), which uses a signed arithmetic type for <tt>file_clock::rep</tt>. 
<tt>file_clock</tt></ins> is used to create the <tt>time_point</tt> system used for <tt>file_time_type</tt> 
(27.11 <a href="https://timsong-cpp.github.io/cppwp/filesystems">[filesystems]</a>). Its epoch is unspecified<ins>, and <tt>noexcept(file_clock::now())</tt> is 
<tt>true</tt></ins>. <ins>[<i>Note:</i> The type <tt>file_clock</tt> denotes may be in a different namespace 
than <tt>std::chrono</tt>, such as <tt>std::filesystem</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li>
<p>Change 25.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file.members">[time.clock.file.members]</a> as indicated:</p>

<blockquote>
<pre>
<del>static time_point now();</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Returns:</i> A <tt>file_clock::time_point</tt> indicating the current time.</del>
<p/>
-2- The class <del><tt>file_clock</tt> shall</del><ins>type denoted by <tt>file_clock</tt></ins> provide<ins>s</ins> 
precisely one of the following two sets of static member functions: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-08-23 Batavia Issues processing: Minor wording changes, and status to "Tentatively Ready".]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4762">N4762</a>.
</p>

<ol>
<li>
<p>Change 25.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>, header <tt>&lt;chrono&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 25.7.5 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file">[time.clock.file]</a>, <del>class</del><ins>type</ins> file_clock</i>
<del>class</del><ins>using</ins> file_clock <ins>= <i>see below</i></ins>;
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>Change 25.7.5 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file">[time.clock.file]</a> as indicated:</p>

<blockquote>
<p>
<b>23.17.7.5 <del>Class</del><ins>Type</ins> <tt>file_clock</tt> [time.clock.file]</b>
</p>
</blockquote>
</li>

<li>
<p>Change 25.7.5.1 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file.overview">[time.clock.file.overview]</a>, class <tt>file_clock</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::chrono {
  <ins>using file_clock = <i>see below</i>;</ins>
  <del>class file_clock {
  public:
    using rep = <i>a signed arithmetic type</i>;
    using period = ratio&lt;<i>unspecified</i>, <i>unspecified</i>&gt;;
    using duration = chrono::duration&lt;rep, period&gt;;
    using time_point = chrono::time_point&lt;file_clock&gt;;
    static constexpr bool is_steady = <i>unspecified</i>;
    
    static time_point now() noexcept;
    
    <i>// Conversion functions, see below</i>
  };</del>
}
</pre>
<p>
-1- <del>The clock</del> <tt>file_clock</tt> <ins>is an alias for a type meeting the <tt>Cpp17TrivialClock</tt> requirements 
(25.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a>), and using a signed arithmetic type for <tt>file_clock::rep</tt>. 
<tt>file_clock</tt></ins> is used to create the <tt>time_point</tt> system used for <tt>file_time_type</tt> 
(27.11 <a href="https://timsong-cpp.github.io/cppwp/filesystems">[filesystems]</a>). Its epoch is unspecified<ins>, and <tt>noexcept(file_clock::now())</tt> is 
<tt>true</tt></ins>. <ins>[<i>Note:</i> The type that <tt>file_clock</tt> denotes may be in a different namespace 
than <tt>std::chrono</tt>, such as <tt>std::filesystem</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li>
<p>Change 25.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.file.members">[time.clock.file.members]</a> as indicated:</p>

<blockquote>
<pre>
<del>static time_point now();</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Returns:</i> A <tt>file_clock::time_point</tt> indicating the current time.</del>
<p/>
-2- The type <del><tt>file_clock</tt> shall</del><ins>type denoted by <tt>file_clock</tt></ins> provide<ins>s</ins> 
precisely one of the following two sets of static member functions: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3147" href="3147">3147.</a> Definitions of "likely" and "unlikely" are likely to cause problems</h3>
<p><b>Section:</b> 15.5.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-08-01 <b>Last modified:</b> 2018-08-20 12:41:52 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#macro.names">active issues</a> in [macro.names].</p>
<p><b>View all other</b> <a href="lwg-index.html#macro.names">issues</a> in [macro.names].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
15.5.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a>/2 forbids a translation unit to define names "lexically identical to [&hellip;] the 
<i>attribute-token</i>s described in 9.11 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr">[dcl.attr]</a>." We recently added the attribute-tokens <tt>likely</tt> 
and <tt>unlikely</tt> (9.11.7 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr.likelihood">[dcl.attr.likelihood]</a>). These names are in extremely wide use as function-like 
macros in the open source community, forbidding users to define them breaks large amounts of code. (Reportedly 
Chromium contains 19 definitions each of "likely" and "unlikely" as function-like macros.)
<p/>
Indeed, this issue came up during EWG discussion of <a href="http://wg21.link/p0479R1">P0479R1</a> "Attributes 
for Likely and Unlikely Statements" in Kona, and EWG decided to keep the names "likely" and "unlikely" for the attribute 
tokens since the usage wouldn't conflict with defining them as function-like macros. 15.5.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a>/2 should 
not break large amounts of existing code that doesn't actually conflict with the use of the <tt>[[likely]]</tt> and 
<tt>[[unlikely]]</tt> attributes.
</p>

<p><i>[2018-08-20 Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4762">N4762</a>.
</p>

<ol>
<li>
<p>Change 15.5.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> If both this proposed resolution and the proposed resolution of LWG <a href="3132">3132</a> are accepted, 
the text inserted by LWG <a href="3132">3132</a> should precede the text added here.]
</p>
</blockquote>

<blockquote>
<p>
-2- A translation unit shall not <tt>#define</tt> or <tt>#undef</tt> names lexically identical to keywords, to 
the identifiers listed in Table 4, or to the <i>attribute-token</i>s described in 9.11 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr">[dcl.attr]</a><ins>, 
except that the names <tt>likely</tt> and <tt>unlikely</tt> may be defined as function-like macros 
(14.3 <a href="https://timsong-cpp.github.io/cppwp/cpp.replace">[cpp.replace]</a>)</ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3148" href="3148">3148.</a> <tt>&lt;concepts&gt;</tt> should be freestanding</h3>
<p><b>Section:</b> 15.5.1.3 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-08-09 <b>Last modified:</b> 2018-08-22 12:55:05 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The design intent of the <tt>&lt;concepts&gt;</tt> header is that it contains
only fundamental concept definitions and implementations of customization points
that are used by those concept definitions. There should never be components in
the header that require operating system support. Consequently, freestanding
implementations can and should provide it. It is an oversight on the
part of LWG - and in particular the author of <a href="https://wg21.link/p0898r3">
P0898R3 "Standard Libary Concepts"</a> - that the <tt>&lt;concepts&gt;</tt>
header is not required to be provided by freestanding implementations.
</p>

<p><i>[2018-08 Batavia Monday issue prioritization]</i></p>

<p>Priority set to 0, status to 'Tentatively Ready'</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ol>
<li><p>In 15.5.1.3 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a>, add a new row to
<a href="https://wg21.link/tab:cpp.headers.freestanding">Table 21</a>:</p>

<blockquote>
<table style="border: 1px solid black">
<caption>Table 21 &mdash; C++ headers for freestanding implementations</caption>
<thead>
<tr style="border: 1px solid black">
<th colspan="2" style="text-align: center">Subclause</th><th style="text-align: center">Header(s)</th>
</tr>
</thead>
<tbody>
<tr style="border: 1px solid black">
<td style="padding: 0ex 1ex 0ex 1ex">[&hellip;]</td>
<td style="padding: 0ex 1ex 0ex 1ex">[&hellip;]</td>
<td style="padding: 0ex 1ex 0ex 1ex">[&hellip;]</td>
</tr>
<tr style="border: 1px solid black">
<td style="padding: 0ex 1ex 0ex 1ex">16.12 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a></td>
<td style="padding: 0ex 1ex 0ex 1ex">Other runtime support</td>
<td style="padding: 0ex 1ex 0ex 1ex"><tt>&lt;cstdarg&gt;</tt></td>
</tr>
<tr style="border: 1px solid black">
<td style="padding: 0ex 1ex 0ex 1ex"><ins>17 <a href="https://timsong-cpp.github.io/cppwp/concepts">[concepts]</a></ins></td>
<td style="padding: 0ex 1ex 0ex 1ex"><ins>Concepts library</ins></td>
<td style="padding: 0ex 1ex 0ex 1ex"><ins><tt>&lt;concepts&gt;</tt></ins></td>
</tr>
<tr style="border: 1px solid black">
<td style="padding: 0ex 1ex 0ex 1ex">19.15 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a></td>
<td style="padding: 0ex 1ex 0ex 1ex">Type traits</td>
<td style="padding: 0ex 1ex 0ex 1ex"><tt>&lt;type_traits&gt;</tt></td>
</tr>
<tr style="border: 1px solid black">
<td style="padding: 0ex 1ex 0ex 1ex">[&hellip;]</td>
<td style="padding: 0ex 1ex 0ex 1ex">[&hellip;]</td>
<td style="padding: 0ex 1ex 0ex 1ex">[&hellip;]</td>
</tr>
</tbody>
</table>

</blockquote>
</li>
</ol>





<hr>
<h3><a name="3153" href="3153">3153.</a> <tt>Common</tt> and <tt>common_type</tt> have too little in common</h3>
<p><b>Section:</b> 17.4.6 <a href="https://timsong-cpp.github.io/cppwp/concept.common">[concept.common]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-08-10 <b>Last modified:</b> 2018-08-22 12:55:05 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concept.common">active issues</a> in [concept.common].</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.common">issues</a> in [concept.common].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>Common</tt> concept when applied to types <tt>T</tt> and <tt>U</tt>
requires that <tt>T</tt> and <tt>U</tt> are each <tt>ConvertibleTo</tt>
(17.4.4 <a href="https://timsong-cpp.github.io/cppwp/concept.convertibleto">[concept.convertibleto]</a>) their common type
<tt>common_type_t&lt;T, U&gt;</tt>. <tt>ConvertibleTo</tt> requires both
implicit and explicit conversions with equivalent results. The requirement for
implicit conversion is notably not a requirement for specializing
<tt>common_type</tt> as detailed in 19.15.7.6 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a>:
</p>
<blockquote>
-5- Such a specialization need not have a member named <tt>type</tt>, but if it
does, that member shall be a <i>typedef-name</i> for an accessible and
unambiguous cv-unqualified non-reference type <tt>C</tt> to which each of the
types <tt>T1</tt> and <tt>T2</tt> is explicitly convertible.
</blockquote>
<p>
which only requires <em>explicit</em> conversion to be valid. While it's not
inconsistent that the <tt>Common</tt> concept's requirements are a refinement of
the requirements for <tt>common_type</tt>, there's no good reason for this
additional requirement. The stated design intent is to enable writing monomorphic
predicates that can compare <tt>T</tt>s with <tt>U</tt>s (and vice versa) by
accepting two arguments of type <tt>common_type_t&lt;T, U&gt;</tt>, but this
role has been superseded by the addition of <tt>CommonReference</tt> and
<tt>common_reference_t</tt> to the ranges design. The existence of pairs of
types that are only explicitly convertible to their common type suggests that
using <tt>Common</tt> in this way would never be a fully generic solution in any
case.
</p>
<p>
The only existing use of the <tt>Common</tt> concept in
either the working draft or the Ranges proposal is as a soundness check on the
<a href="https://timsong-cpp.github.io/cppwp/ranges-ts/counted.iter.op.comp">comparison</a>
and
<a href="https://timsong-cpp.github.io/cppwp/ranges-ts/counted.iter.nonmember">difference</a>
operators of <tt>counted_iterator</tt>, none of which actually convert any
argument to the common type in their normal operation. It would seem that we
could strike the additional requirement without impacting the Ranges design,
which would allow for future uses of the <tt>Common</tt> concept with types
like <tt>chrono::duration</tt> (25.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a>) which sometimes
provide only explicit conversion to a common type.
</p>
<p>
Notably, removing the requirement for implicit conversion will also make the
<tt>Common</tt> concept consistent with the description in
17.4.6 <a href="https://timsong-cpp.github.io/cppwp/concept.common">[concept.common]</a> p1: "If <tt>T</tt> and <tt>U</tt> can both be
explicitly converted to some third type, <tt>C</tt>, then <tt>T</tt> and
<tt>U</tt> share a common type, <tt>C</tt>."
</p>
<p><i>[2018-08 Batavia Monday issue prioritization]</i></p>

<p>P0; Status to 'Tentatively Ready' after adding two semicolons to the P/R.</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ul>
<li><p>Modify the definition of <tt>Common</tt> in 17.4.6 <a href="https://timsong-cpp.github.io/cppwp/concept.common">[concept.common]</a>
as follows:</p>
<blockquote>
<pre>
template&lt;class T, class U&gt;
  concept Common =
    Same&lt;common_type_t&lt;T, U&gt;, common_type_t&lt;U, T&gt;&gt; &amp;&amp;
    <del>ConvertibleTo&lt;T, common_type_t&lt;T, U&gt;&gt; &amp;&amp;</del>
    <del>ConvertibleTo&lt;U, common_type_t&lt;T, U&gt;&gt; &amp;&amp;</del>
    <ins>requires {</ins>
      <ins>static_cast&lt;common_type_t&lt;T, U&gt;&gt;(declval&lt;T&gt;());</ins>
      <ins>static_cast&lt;common_type_t&lt;T, U&gt;&gt;(declval&lt;U&gt;());</ins>
    <ins>} &amp;&amp;</ins>
    CommonReference&lt;
      add_lvalue_reference_t&lt;const T&gt;,
      add_lvalue_reference_t&lt;const U&gt;&gt; &amp;&amp;
    CommonReference&lt;
      add_lvalue_reference_t&lt;common_type_t&lt;T, U&gt;&gt;,
      common_reference_t&lt;
        add_lvalue_reference_t&lt;const T&gt;,
        add_lvalue_reference_t&lt;const U&gt;&gt;&gt;;
</pre>
</blockquote>
</li>
</ul>





<hr>
<h3><a name="3154" href="3154">3154.</a> <tt>Common</tt> and <tt>CommonReference</tt> have a common defect</h3>
<p><b>Section:</b> 17.4.6 <a href="https://timsong-cpp.github.io/cppwp/concept.common">[concept.common]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-08-10 <b>Last modified:</b> 2018-08-22 12:55:05 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concept.common">active issues</a> in [concept.common].</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.common">issues</a> in [concept.common].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The semantic requirements of both <tt>Common</tt>
(17.4.6 <a href="https://timsong-cpp.github.io/cppwp/concept.common">[concept.common]</a>):
</p>
<blockquote>
<p>
-2- Let <tt>C</tt> be <tt>common_­type_­t&lt;T, U&gt;</tt>. Let <tt>t</tt> be a
function whose return type is <tt>T</tt>, and let <tt>u</tt> be a function whose
return type is <tt>U</tt>. <tt>Common&lt;T, U&gt;</tt> is satisfied only if:
</p><p>
(2.1) &mdash; <tt>C(t())</tt> equals <tt>C(t())</tt> if and only if <tt>t()</tt>
is an equality-preserving expression (17.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>).
</p><p>
(2.2) &mdash; <tt>C(u())</tt> equals <tt>C(u())</tt> if and only if <tt>u()</tt>
is an equality-preserving expression (17.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>).
</p>
</blockquote>
<p>
and similarly <tt>CommonReference</tt> ( [concept.commonreference]):
</p>
<blockquote>
<p>
-2- Let <tt>C</tt> be <tt>common_­reference_­t&lt;T, U&gt;</tt>. Let <tt>t</tt> be
a function whose return type is <tt>T</tt>, and let <tt>u</tt> be a function
whose return type is <tt>U</tt>. <tt>CommonReference&lt;T, U&gt;</tt> is
satisfied only if:
</p><p>
(2.1) &mdash; <tt>C(t())</tt> equals <tt>C(t())</tt> if and only if <tt>t()</tt>
is an equality-preserving expression (17.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>).
</p><p>
(2.2) &mdash; <tt>C(u())</tt> equals <tt>C(u())</tt> if and only if <tt>u()</tt>
is an equality-preserving expression.
</p>
</blockquote>
<p>
don't properly reflect the intended design that conversions to the common type /
common reference type are identity-preserving: in other words, that converting
two values to the common type produces equal results if and only if the values
were initially equal. The phrasing "<tt>C(E)</tt> equals <tt>C(E)</tt> if and only if <tt>E</tt> is an equality-preserving expression" is also clearly
defective regardless of the intended design: the assertion "<tt>E</tt> is not
equality-preserving" does not imply that every evaluation of <tt>E</tt> produces
different results.
</p>
<p><i>[2018-08 Batavia Monday issue prioritization]</i></p>

<p>Priority set to 0, status to 'Tentatively Ready'</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ul>
<li><p>Modify 17.4.5 <a href="https://timsong-cpp.github.io/cppwp/concept.commonref">[concept.commonref]</a> p2 as follows:</p>
<blockquote>
<p>
-2- Let <tt>C</tt> be <tt>common_­reference_­t&lt;T, U&gt;</tt>. Let <del><tt>t</tt>
be a function whose return type is</del> <ins><tt>t1</tt> and <tt>t2</tt> be
equality-preserving expressions (17.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>) such that
<tt>decltype((t1))</tt> and <tt>decltype((t2))</tt> are each</ins> <tt>T</tt>,
and let <del><tt>u</tt> be a function whose return type is</del> <ins><tt>u1</tt>
and <tt>u2</tt> be equality-preserving expressions such that
<tt>decltype((u1))</tt> and <tt>decltype((u2))</tt> are each</ins> <tt>U</tt>.
<ins><tt>T</tt> and <tt>U</tt> model</ins> <tt>CommonReference&lt;T, U&gt;</tt> <del>is satisfied</del> only if:
</p><p>
(2.1) &mdash; <tt>C(t<ins>1</ins><del>()</del>)</tt> equals
<tt>C(t<ins>2</ins><del>()</del>)</tt> if and only if
<tt>t<ins>1</ins><del>()</del></tt> <ins>equals <tt>t2</tt>, and</ins>
<del>is an equality-preserving expression (17.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>).</del>
</p><p>
(2.2) &mdash; <tt>C(u<ins>1</ins><del>()</del>)</tt> equals
<tt>C(u<ins>2</ins><del>()</del>)</tt> if and only if
<tt>u<ins>1</ins><del>()</del></tt> <ins>equals <tt>u2</tt></ins>
<del>is an equality-preserving expression</del>.
</p>
</blockquote>
</li>
<li><p>Modify 17.4.6 <a href="https://timsong-cpp.github.io/cppwp/concept.common">[concept.common]</a> p2 similarly:</p>
<blockquote>
<p>
-2- Let <tt>C</tt> be <tt>common_­type_­t&lt;T, U&gt;</tt>. Let <del><tt>t</tt> be
a function whose return type is</del> <ins><tt>t1</tt> and <tt>t2</tt> be
equality-preserving expressions (17.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>) such that
<tt>decltype((t1))</tt> and <tt>decltype((t2))</tt> are each</ins> <tt>T</tt>,
and let <del><tt>u</tt> be a function whose return type is</del> <ins><tt>u1</tt>
and <tt>u2</tt> be equality-preserving expressions such that
<tt>decltype((u1))</tt> and <tt>decltype((u2))</tt> are each</ins> <tt>U</tt>.
<ins><tt>T</tt> and <tt>U</tt> model</ins> <tt>Common&lt;T, U&gt;</tt> <del>is
satisfied</del> only if:
</p><p>
(2.1) &mdash; <tt>C(t<ins>1</ins><del>()</del>)</tt> equals
<tt>C(t<ins>2</ins><del>()</del>)</tt> if and only if
<tt>t<ins>1</ins><del>()</del></tt> <ins>equals <tt>t2</tt>, and</ins>
<del>is an equality-preserving expression (17.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>).</del>
</p><p>
(2.2) &mdash; <tt>C(u<ins>1</ins><del>()</del>)</tt> equals
<tt>C(u<ins>2</ins><del>()</del>)</tt> if and only if
<tt>u<ins>1</ins><del>()</del></tt> <ins>equals <tt>u2</tt></ins>
<del>is an equality-preserving expression (17.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>)</del>.
</p>
</blockquote>
</li>
</ul>





<hr>
<h3><a name="3155" href="3155">3155.</a> <tt>tuple&lt;any, any&gt;{allocator_arg_t, an_allocator}</tt></h3>
<p><b>Section:</b> 19.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-08-18 <b>Last modified:</b> 2018-08-22 12:55:05 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For a 2-element <tt>std::tuple</tt>, attempting to call the "allocator-extended default constructor" might actually 
pass the <tt>allocator_arg</tt> tag and the allocator to the tuple element constructors:
</p>
<blockquote>
<pre>
tuple&lt;any, any&gt; t{allocator_arg, allocator&lt;int&gt;{}};
assert(std::get&lt;0&gt;(t).has_value());
</pre>
</blockquote>
<p>
This assertion should pass according to the standard, but users might expect the elements to be default constructed. 
If you really wanted to construct the elements with the tag and the allocator, you could do:
</p>
<blockquote>
<pre>
tuple&lt;any, any&gt; t{{allocator_arg}, {allocator&lt;int&gt;{}}};
</pre>
</blockquote>
<p>
or
</p>
<blockquote>
<pre>
tuple&lt;any, any&gt; t{tuple&lt;allocator_arg_t, allocator&lt;int&gt;&gt;{allocator_arg, allocator&lt;int&gt;{}}};
</pre>
</blockquote>
<p>
The deduction guides for <tt>std::tuple</tt> always treat <tt>{allocator_arg_t, <i>an_allocator</i>}</tt> as the 
allocator-extended default constructor, so this creates an empty tuple:
</p>
<blockquote>
<pre>
tuple t{allocator_arg, allocator&lt;int&gt;{}};
</pre>
</blockquote>
<p>
And this is needed to create <tt>tuple&lt;any, any&gt;</tt>:
</p>
<blockquote>
<pre>
tuple t{allocator_arg, allocator&lt;int&gt;{}, any{}, any{}};
</pre>
</blockquote>
<p>
The proposed resolution seems consistent with that, always calling an allocator-extended constructor for 
<tt>{allocator_arg_t, <i>a</i>}</tt>, instead of the <tt>tuple(UTypes&amp;&amp;...)</tt> constructor.
<p/>
Ville Voutilainen:
<p/>
This was discussed in <a href="http://lists.isocpp.org/lib-ext/2016/10/3154.php">this reflector thread</a>, 
where Andrzej convinced me to change libstdc++ tuple.
</p>

<p><i>[2018-08-20, Daniel comments]</i></p>

<p>
The wording changes by this issue are very near to those suggested for LWG <a href="3121">3121</a>.
</p>

<p><i>[2018-08 Batavia Monday issue prioritization]</i></p>

<p>Priority set to 0, status to 'Tentatively Ready'. Alisdair to write a paper about 
SFINAE constraints on the Allocator-aware tuple constructors.</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ul>
<li><p>Modify 19.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class... UTypes&gt; explicit(<i>see below</i>) constexpr tuple(UTypes&amp;&amp;... u);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> Initializes the elements in the tuple with the corresponding value in 
<tt>std::forward&lt;UTypes&gt;(u)</tt>.
<p/>
-10- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>sizeof...(Types) == sizeof...(UTypes)</tt> and <tt>sizeof...(Types) &gt;= 1</tt> and 
<tt>is_constructible_v&lt;T<sub><i>i</i></sub>, U<sub><i>i</i></sub>&amp;&amp;&gt;</tt> is <tt>true</tt> 
for all <tt><i>i</i></tt> <ins>and <tt>(sizeof...(Types) != 2 || !is_same_v&lt;remove_cvref_t&lt;U<sub>0</sub>&gt;, 
allocator_arg_t&gt;)</tt></ins>. The expression inside <tt>explicit</tt> is equivalent to:
<p/>
<tt>!conjunction_v&lt;is_convertible&lt;UTypes, Types&gt;...&gt;</tt>
</p>
</blockquote>
</blockquote>
</li>
</ul>





</body>
</html>
