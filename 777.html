<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 777: Atomics Library Issue</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p> Generated: <p>Revised 2016-11-15 at 21:11:23 UTC</p>
</p><hr>
<h3><a name="777" href="#777">777.</a> Atomics Library Issue</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-01-21 <b>Last modified:</b> 2016-11-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The load functions are defined as
</p>

<blockquote><pre>
C atomic_load(volatile A* object);
C atomic_load_explicit(volatile A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) volatile;
</pre></blockquote>

<p>
which prevents their use in <tt>const</tt> contexts.
</p>

<p><i>[
post Bellevue Peter adds:
]</i></p>


<blockquote>
<p>
Issue <a href="lwg-defects.html#777">777</a> suggests making <tt>atomic_load</tt> operate on <tt>const</tt> objects. There is a
subtle point here. Atomic loads do not generally write to the object, except
potentially for the <tt>memory_order_seq_cst</tt> constraint. Depending on the
architecture, a dummy write with the same value may be required to be issued
by the atomic load to maintain sequential consistency. This, in turn, may
make the following code:
</p>

<blockquote><pre>
const atomic_int x{};

int main()
{
  x.load();
}
</pre></blockquote>

<p>
dump core under a straightforward implementation that puts const objects in
a read-only section.
</p>
<p>
There are ways to sidestep the problem, but it needs to be considered.
</p>
<p>
The tradeoff is between making the data member of the atomic types
mutable and requiring the user to explicitly mark atomic members as
mutable, as is already the case with mutexes.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the <tt>const</tt> qualifier to <tt>*object</tt> and <tt>*this</tt>.
</p>

<blockquote><pre>
C atomic_load(<ins>const</ins> volatile A* object);
C atomic_load_explicit(<ins>const</ins> volatile A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) <ins>const</ins> volatile;
</pre></blockquote>






</body>
</html>
