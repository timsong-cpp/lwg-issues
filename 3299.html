<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3299: Pointers don't need customized iterator behavior</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3><a name="3299" href="lwg-defects.html#3299">3299.</a> Pointers don't need customized iterator behavior</h3>
<p><b>Section:</b> 25.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.move">[iterator.cust.move]</a>, 25.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.swap">[iterator.cust.swap]</a> <b>Status:</b> <a href="lwg-active.html#C++20">C++20</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2019-10-07 <b>Last modified:</b> 2021-02-25 10:48:01 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.cust.move">issues</a> in [iterator.cust.move].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++20">C++20</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not intentional design that users may customize the behavior of
<tt>ranges::iter_move</tt> (25.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.move">[iterator.cust.move]</a>) and
<tt>ranges::iter_swap</tt> (25.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.swap">[iterator.cust.swap]</a>)  for pointers to program-defined
type by defining e.g. <tt>iter_move(my_type*)</tt> or <tt>iter_swap(my_type*, my_type*)</tt> in a
namespace associated with <tt>my_type</tt>. The intent of customization points is that users may
define behavior for types they define, not that users may mess with the well-defined semantics for
existing types like pointers.
</p><p>
We should forbid such silliness by constraining the "finds an overload via ADL" cases for
customization points to only trigger with argument expressions of class or enumeration type. Note
that WG21 made a similar change to <tt>ranges::swap</tt> shortly before merging it into the working
draft to forbid users customizing behavior for pointers to program-defined types or arrays of
program-defined types.
</p>

<p><i>[2019-11-16 Issue Prioritization]</i></p>

<p>Status to Tentatively Ready and priority to 0 after seven positive votes on the reflector.</p>


<p id="res-3299"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<blockquote class="note"><p>
[<i>Drafting note:</i> <a href="3247">3247</a> touches the same wording in
25.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.move">[iterator.cust.move]</a>; if both are resolved simultaneously the changes should be
reconciled before passing them on to the Editor.]
</p></blockquote>

<ol>
<li><p>Modify 25.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.move">[iterator.cust.move]</a> as follows:</p>

<blockquote><p>
(1.1) &mdash; <tt>iter_move(E)</tt>, if <del>that expression is valid,</del> <ins><tt>E</tt> has
class or enumeration type and <tt>iter_move(E)</tt> is a well-formed expression</ins> with overload
resolution performed in a context that does not include a declaration of <tt>ranges::iter_move</tt>.
</p></blockquote>
</li>

<li><p>Modify 25.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.swap">[iterator.cust.swap]</a> as follows:</p>

<blockquote><p>
(4.1) &mdash; <tt>(void)iter_swap(E1, E2)</tt>, if <del>that expression is valid,</del> <ins>either
<tt>E1</tt> or <tt>E2</tt> has class or enumeration type and <tt>iter_swap(E1, E2)</tt> is a
well-formed expression</ins> with overload resolution performed in a context that includes the
declaration
<blockquote><pre>
template&lt;class I1, class I2&gt;
void iter_swap(I1, I2) = delete;
</pre></blockquote>
and does not include a declaration of <tt>ranges::iter_swap</tt>. If the function selected by
overload resolution does not exchange the values denoted by <tt>E1</tt> and <tt>E2</tt>, the program
is ill-formed with no diagnostic required.
</p></blockquote>
</li>
</ol>





</body>
</html>
