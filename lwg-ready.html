<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2016-11-28 at 17:11:30 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="2260" href="2260">2260.</a> Missing requirement for <tt>Allocator::pointer</tt></h3>
<p><b>Section:</b> 17.5.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-05-14 <b>Last modified:</b> 2016-11-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For an allocator <tt>A&lt;T&gt;</tt> which defines <tt>A&lt;T&gt;::pointer</tt> to a class type,
i.e. not <tt>T*</tt>, I see no requirement that <tt>A&lt;T&gt;::pointer</tt> is convertible to
<tt>A&lt;U&gt;::pointer</tt>, even if <tt>T*</tt> is convertible to <tt>U*</tt>.  Such conversions are
needed in containers to convert from e.g. <tt>ListNodeBase*</tt> to <tt>ListNode&lt;T&gt;*</tt>.
</p>

<p>The obvious way to do such conversions appears to be
<tt>pointer_traits::pointer_to()</tt>, but that's ill-formed if the static
member function <tt>A&lt;T&gt;::pointer::pointer_to()</tt> doesn't exist and the
allocator requirements don't mention that function, so you need to
cast <tt>A&lt;T&gt;::pointer</tt> to <tt>A&lt;T&gt;::void_pointer</tt> then cast that to
<tt>A&lt;U&gt;::pointer</tt>.
</p>

<p>
Is converting via <tt>void_pointer</tt> really intended, or are we missing a requirement that 
<tt>pointer_traits&lt;A&lt;T&gt;::pointer&gt;::pointer_to()</tt> be well-formed?
</p>

<p>Proposed resolution:</p>

<p>Add to the Allocator requirements table the following requirement:</p>

<blockquote>
<p>
The expression <tt>pointer_traits&lt;XX::pointer&gt;::pointer_to(r)</tt> is well-defined.
</p>
</blockquote>

<p><i>[2013-09 Chicago]</i></p>

<p>
Pablo to come back with proposed wording
</p>

<p><i>[2015-07 Telecom]</i></p>

<p>
Marshall to ping Pablo for proposed wording and disable current wording.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class = "note">
<ol>
<li><p>
Edit Table 28 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z)</tt>
</td>
<td>
<tt>X::const_pointer</tt>
</td>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z) == q</tt>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<ins><tt>pointer_traits&lt;X::pointer&gt;::pointer_to(r)</tt></ins>
</td>
<td>
<ins><tt>X::pointer</tt></ins>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>


</li>
</ol>
</blockquote>


<p><i>[2016-11-12, Issaquah]</i></p>

<p>This is related to <a href="1521">1521</a>.</p>
<p>Sat PM: Restore original P/R and move to tentatively ready.</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>
Edit Table 28 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z)</tt>
</td>
<td>
<tt>X::const_pointer</tt>
</td>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z) == q</tt>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<ins><tt>pointer_traits&lt;X::pointer&gt;::pointer_to(r)</tt></ins>
</td>
<td>
<ins><tt>X::pointer</tt></ins>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>


</li>
</ol>





<hr>
<h3><a name="2781" href="2781">2781.</a> Contradictory requirements for <tt>std::function</tt> and <tt>std::reference_wrapper</tt></h3>
<p><b>Section:</b> 20.14.12.2.1 [func.wrap.func.con] <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-10-13 <b>Last modified:</b> 2016-11-21</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func.con">active issues</a> in [func.wrap.func.con].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>template&lt;class F&gt; function(F f)</tt> says that the effects are "<tt>*this</tt>
targets a copy of <tt>f</tt>" which seems pretty clear that if <tt>F</tt> is
<tt>reference_wrapper&lt;CallableType&gt;</tt> then the target is a
<tt>reference_wrapper&lt;CallableType&gt;</tt>.
<p/>
But the function copy and move constructors say "shall not throw
exceptions if <tt>f</tt>'s target is a callable object passed via
<tt>reference_wrapper</tt> or a function pointer." From the requirement above
it's impossible for the target to be "a callable object passed via
<tt>reference_wrapper</tt>" because if the function was constructed with such a
type then the target is the <tt>reference_wrapper</tt> not the callable object
it wraps.
<p/>
This matters because it affects the result of <tt>function::target_type()</tt>,
and we have implementation divergence. VC++ and libc++ store the
<tt>reference_wrapper</tt> as the target, but libstdc++ and Boost.Function
(both written by Doug Gregor) unwrap it, so the following fails:
</p>
<blockquote><pre>
#include &lt;functional&gt;
#include &lt;cassert&gt;

int main()
{
 auto f = []{};
 std::function&lt;void()&gt; fn(std::ref(f));
 assert(fn.target&lt;std::reference_wrapper&lt;decltype(f)&gt;&gt;() != nullptr);
}
</pre></blockquote>
<p>
If <tt>std::function</tt> is intended to deviate from <tt>boost::function</tt> this way
then the <i>Throws</i> element for the copy and move constructors is
misleading, and should be clarified.
</p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat AM: Priority 0; move to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Modify 20.14.12.2.1 [func.wrap.func.con] p4 and p6 the same way, as shown:</p>

<blockquote>
<pre>
function(const function&amp; f);
</pre>
<blockquote>
<p>
-3- <i>Postconditions:</i> <tt>!*this</tt> if <tt>!f</tt>; otherwise, <tt>*this</tt> targets a copy of 
<tt>f.target()</tt>.
<p/>
-4- <i>Throws:</i> shall not throw exceptions if <tt>f</tt>'s target is a <del>callable object passed 
via</del><ins>specialization of</ins> <tt>reference_wrapper</tt> or a function pointer. Otherwise, may throw 
<tt>bad_alloc</tt> or any exception thrown by the copy constructor of the stored callable object. 
[<i>Note:</i> Implementations are encouraged to avoid the use of dynamically allocated memory for small 
callable objects, for example, where <tt>f</tt>'s target is an object holding only a pointer or reference to 
an object and a member function pointer. &mdash; <i>end note</i>]
</p>
</blockquote>
<pre>
function(function&amp;&amp; f);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, move constructs the target of 
<tt>f</tt> into the target of <tt>*this</tt>, leaving <tt>f</tt> in a valid state with an unspecified value.
<p/>
-6- <i>Throws:</i> shall not throw exceptions if <tt>f</tt>'s target is a <del>callable object passed 
via</del><ins>specialization of</ins> <tt>reference_wrapper</tt> or a function pointer. Otherwise, may throw 
<tt>bad_alloc</tt> or any exception thrown by the copy or move constructor of the stored callable object. 
[<i>Note:</i> Implementations are encouraged to avoid the use of dynamically allocated memory for small callable 
objects, for example, where <tt>f</tt>'s target is an object holding only a pointer or reference to an object 
and a member function pointer. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2782" href="2782">2782.</a> <tt>scoped_allocator_adaptor</tt> constructors must be constrained</h3>
<p><b>Section:</b> 20.13.3 [allocator.adaptor.cnstr] <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-10-14 <b>Last modified:</b> 2016-11-21</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The templated constructors of <tt>scoped_allocator_adaptor</tt> need to be constrained, otherwise uses-allocator 
construction gives the wrong answer and causes errors for code that should compile.
<p/>
Consider two incompatible allocator types:
</p>
<blockquote><pre>
template&lt;class T&gt; struct Alloc1 { ... };
template&lt;class T&gt; struct Alloc2 { ... };
static_assert(!is_convertible_v&lt;Alloc1&lt;int&gt;, Alloc2&lt;int&gt;&gt;);
</pre></blockquote>
<p>
The unconstrained constructors give this bogus answer:
</p>
<blockquote><pre>
template&lt;class T&gt; using scoped = scoped_allocator_adaptor&lt;T&gt;;
static_assert(is_convertible_v&lt;scoped&lt;Alloc1&lt;int&gt;&gt;, scoped&lt;Alloc2&lt;int&gt;&gt;&gt;);
</pre></blockquote>
<p>
This causes <tt>uses_allocator</tt> to give the wrong answer for any specialization involving incompatible 
<tt>scoped_allocator_adaptors</tt>, which makes <tt>scoped_allocator_adaptor::construct()</tt> take an ill-formed 
branch e.g.
</p>
<blockquote><pre>
struct X 
{
  using allocator_type = scoped&lt;Alloc2&lt;int&gt;&gt;;
  X(const allocator_type&amp;);
  X();
};
scoped&lt;Alloc1&lt;int&gt;&gt;{}.construct((X*)0);
</pre></blockquote>
<p>
This fails to compile, because <tt>uses_allocator&lt;X, scoped_allocator_adaptor&lt;Alloc2&lt;int&gt;&gt;&gt;</tt> is 
<tt>true</tt>, so the allocator is passed to the <tt>X</tt> constructor, but the conversion fails. The error is outside 
the immediate context, and so is a hard error.
</p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat AM: Priority 0; move to Ready</p>
<p>Billy to open another issue about the confusion with the ctor</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Modify 20.13.3 [allocator.adaptor.cnstr] by converting "Requires" elements to "Remarks: shall not participate ..." constraints as shown:</p>

<blockquote>
<pre>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(OuterA2&amp;&amp; outerAlloc,
                           const InnerAllocs&amp;... innerAllocs) noexcept;
</pre>
<blockquote>
<p>
<del>-2- <i>Requires:</i> <tt>OuterAlloc</tt> shall be constructible from <tt>OuterA2</tt>.</del>
<p/>
-3- <i>Effects:</i> Initializes the <tt>OuterAlloc</tt> base class with <tt>std::forward&lt;OuterA2&gt;(outerAlloc)</tt> and 
inner with <tt>innerAllocs...</tt> (hence recursively initializing each allocator within the adaptor with the
corresponding allocator from the argument list).
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;OuterAlloc, OuterA2&gt;</tt> is <tt>true</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(const scoped_allocator_adaptor&lt;OuterA2,
                           InnerAllocs...&gt;&amp; other) noexcept;
</pre>
<blockquote>
<p>
<del>-6- <i>Requires:</i> <tt>OuterAlloc</tt> shall be constructible from <tt>OuterA2</tt>.</del>
<p/>
-7- <i>Effects:</i> Initializes each allocator within the adaptor with the corresponding allocator from <tt>other</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;OuterAlloc, const OuterA2&amp;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(scoped_allocator_adaptor&lt;OuterA2,
                           InnerAllocs...&gt;&amp;&amp; other) noexcept;
</pre>
<blockquote>
<p>
<del>-8- <i>Requires:</i> <tt>OuterAlloc</tt> shall be constructible from <tt>OuterA2</tt>.</del>
<p/>
-9- <i>Effects:</i> Initializes each allocator within the adaptor with the corresponding allocator rvalue from <tt>other</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;OuterAlloc, OuterA2&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2784" href="2784">2784.</a> Resolution to LWG 2484 is missing "otherwise, no effects" and is hard to parse</h3>
<p><b>Section:</b> 18.8.7 [except.nested] <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-10-15 <b>Last modified:</b> 2016-11-21</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The discussion notes for LWG <a href="2484">2484</a> point out there should be an "else, no effects" at the end, 
which didn't make it into the resolution. Without this it's unclear whether it should do nothing, or be ill-formed, 
or undefined.
<p/>
Additionally, the precise effects of the <i>Effects</i> are hard to determine, because the conditions on the 
static type and dynamic type are intermingled, but must actually be checked separately (the static checks must 
be done statically and the dynamic checks must be done dynamically!) Furthermore, the obvious way to know if 
"the dynamic type of <tt>e</tt> is <tt>nested_exception</tt> or is publicly and unambiguously derived from 
<tt>nested_exception</tt>" is to use <tt>dynamic_cast</tt>, so we have to use <tt>dynamic_cast</tt> to find out 
whether to perform the <tt>dynamic_cast</tt> expression specified in the <i>Effects</i>. It would make more sense 
to specify it in terms of a <tt>dynamic_cast</tt> to a pointer type, and only call <tt>rethrow_nested()</tt> if 
the result is not null.
<p/>
The entire spec can be expressed in C++17 as:
</p>
<blockquote><pre>
if constexpr(is_polymorphic_v&lt;E&gt; &amp;&amp; (!is_base_of_v&lt;nested_exception, E&gt; || is_convertible_v&lt;E*, nested_exception*&gt;))
  if (auto p = dynamic_cast&lt;const nested_exception*&gt;(addressof(e)))
    p->rethrow_nested();
</pre></blockquote>
<p>
This uses traits to perform checks on the static type, then uses <tt>dynamic_cast</tt> to perform the checks on the 
dynamic type. I think the spec would be clearer if it had the same structure.
</p>
<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat AM: Priority 0; move to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Modify 18.8.7 [except.nested] p9:</p>

<blockquote>
<pre>
template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> If <tt>E</tt> is not a polymorphic class type, <ins>or if <tt>nested_exception</tt> is an inaccessible 
or ambiguous base class of <tt>E</tt>,</ins> there is no effect. Otherwise, <del>if the static type or 
the dynamic type of <tt>e</tt> is <tt>nested_exception</tt> or is publicly and unambiguously derived from 
<tt>nested_exception</tt>, calls</del><ins>performs</ins>:
</p>
<blockquote>
<pre>
<del>dynamic_cast&lt;const nested_exception&amp;&gt;(e).rethrow_nested();</del>
<ins>if (auto p = dynamic_cast&lt;const nested_exception*&gt;(addressof(e)))
  p-&gt;rethrow_nested();</ins>
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2785" href="2785">2785.</a> <tt>quoted</tt> should work with <tt>basic_string_view</tt></h3>
<p><b>Section:</b> 27.7.6 [quoted.manip] <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-10-27 <b>Last modified:</b> 2016-11-21</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#quoted.manip">issues</a> in [quoted.manip].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>Quoted output for strings was added for C++14. But when we merged <tt>string_view</tt>
from the Library Fundamentals TS, we did not add support for quoted output of
<tt>basic_string_view</tt></p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat AM: Priority 0; move to Ready</p>
<p>13 -> 13 in paragraph modification; and T14 -> T15</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<p>Add to the end of the &lt;iomanip&gt; synopsis in [iostream.format.overview]</p>
<pre><ins>
template &lt;class charT, class traits&gt;
  T15 quoted(basic_string_view&lt;charT, traits&gt; s,
             charT delim = charT(’"’), charT escape = charT(’\\’));
</ins></pre>

<p>Add to [quoted.manip] at the end of p2:</p>
<pre><ins>
template &lt;class charT, class traits&gt;
  <i>unspecified</i> quoted(basic_string_view&lt;charT, traits&gt; s,
                            charT delim = charT(’"’), charT escape = charT(’\\’));
</ins></pre>

<p>Modify [quoted.manip]/3 as follows:</p>

<p>Returns: An object of unspecified type such that if out is an instance of
<tt>basic_ostream</tt> with member type <tt>char_type</tt> the same as <tt>charT</tt>
and with member type <tt>traits_type</tt> which in the second <ins>and third</ins> form<ins>s</ins>
is the same as <tt>traits</tt>, then the expression <tt>out &lt;&lt; quoted(s, delim, escape)</tt>
behaves as a formatted output function (27.7.3.6.1) of <tt>out</tt>. This forms a character
sequence <tt>seq</tt>, initially consisting of the following elements:</p>





<hr>
<h3><a name="2786" href="2786">2786.</a> Annex C should mention <tt>shared_ptr</tt> changes for array support</h3>
<p><b>Section:</b> C.4.9 [diff.cpp14.utilities] <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-10-18 <b>Last modified:</b> 2016-11-21</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>This is valid in C++11 and C++14:</p>
<blockquote><pre>
shared_ptr&lt;int&gt; s{unique_ptr&lt;int[]&gt;{new int[1]}};
</pre></blockquote>
<p>
The <tt>shared_ptr</tt> copies the <tt>default_delete&lt;int[]&gt;</tt> deleter from the <tt>unique_ptr</tt>, 
which does the right thing on destruction.
<p/>
In C++17 it won't compile, because <tt>!is_convertible_v&lt;int(*)[], int*&gt;</tt>.
<p/>
The solution is to use <tt>shared_ptr&lt;int[]&gt;</tt>, which doesn't work well in C++14, so there's no transition path. 
This should be called out in Annex C.
</p>
<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat AM: Priority 0; move to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Add to C.4.9 [diff.cpp14.utilities]:</p>
<blockquote>
<p>
<ins>20.11.2.2 [util.smartptr.shared]</ins>
<p/>
<ins><i>Change:</i> Different constraint on conversions from <tt>unique_ptr</tt>.</ins>
<p/>
<ins><i>Rationale:</i> Adding array support to <tt>shared_ptr</tt>, via the syntax <tt>shared_ptr&lt;T[]&gt;</tt> and 
<tt>shared_ptr&lt;T[N]&gt;</tt>.</ins>
<p/>
<ins><i>Effect on original feature:</i> Valid code may fail to compile or change meaning in this International Standard. 
For example:</ins>
</p>
<blockquote><pre>
<ins>#include &lt;memory&gt;
std::unique_ptr&lt;int[]&gt; arr(new int[1]);
std::shared_ptr&lt;int&gt; ptr(std::move(arr)); // error: int(*)[] is not compatible with int*</ins>
</pre></blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2787" href="2787">2787.</a> &sect;[file_status.cons] doesn't match class definition</h3>
<p><b>Section:</b> 27.10.11 [class.file_status], 27.10.11.1 [file_status.cons] <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-10-21 <b>Last modified:</b> 2016-11-21</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.10.11 [class.file_status] depicts:</p>
<blockquote><pre>
explicit file_status(file_type ft = file_type::none, perms prms = perms::unknown) noexcept;
</pre></blockquote>
<p>
while 27.10.11.1 [file_status.cons] describes two constructors:
</p>
<blockquote><pre>
explicit file_status() noexcept;
explicit file_status(file_type ft, perms prms = perms::unknown) noexcept;
</pre></blockquote>
<p>
It's also not clear why the default constructor needs to be explicit. Unlike tag types, there doesn't seem to be 
a compelling reason to disallow constructing a <tt>file_status</tt> without naming the type.
</p>
<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat AM: Priority 0; move to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Edit 27.10.11 [class.file_status] as indicated:</p>

<blockquote><pre>
class file_status {
public:
  // 27.10.11.1, constructors and destructor:
  <ins>file_status() noexcept : file_status(file_type::none) {}</ins>
  explicit file_status(file_type ft <del>= file_type::none</del>,
                       perms prms = perms::unknown) noexcept;
  [&hellip;]
};
</pre></blockquote>
</li>

<li><p>Edit 27.10.11.1 [file_status.cons] as indicated:</p>

<blockquote>
<pre>
<del>explicit file_status() noexcept;</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Postconditions:</i> <tt>type() == file_type::none</tt> and <tt>permissions() == perms::unknown</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2794" href="2794">2794.</a> Missing requirements for allocator pointers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2016-11-09 <b>Last modified:</b> 2016-11-21</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses US 146</b>
<p/>
An allocator-aware contiguous container must require 
an allocator whose pointer type is a contiguous 
iterator. Otherwise, functions like data for <tt>basic_string</tt>
and <tt>vector</tt> do not work correctly, along with many 
other expectations of the contiguous guarantee.
<p/>
Suggested resolution:
<p/>
Add a second sentence to 23.2.1 [container.requirements.general] p13:
</p>
<blockquote><p>
An allocator-aware contiguous container requires <tt>allocator_traits&lt;Allocator&gt;::pointer</tt> is a 
contiguous iterator.
</p></blockquote>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: Move to 'Tentatively Ready'</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 17.5.3.5 [allocator.requirements]/5, edit as follows:</p>
<blockquote>
<p>
-5- An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these pointer types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access 
iterator (<del>24.2 [iterator.requirements]</del><ins>24.2.7 [random.access.iterators]</ins>)
<ins>and of a contiguous iterator (24.2.1 [iterator.requirements.general])</ins>.
</p>
</blockquote>
</li>
</ol>





</body>
</html>
