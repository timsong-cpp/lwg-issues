<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2017-11-20 at 18:37:27 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="2843" href="2843">2843.</a> Unclear behavior of <tt>std::pmr::memory_resource::do_allocate()</tt></h3>
<p><b>Section:</b> 23.12.2.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.private">[mem.res.private]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-12-13 <b>Last modified:</b> 2017-11-10 03:05:33 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.res.private">issues</a> in [mem.res.private].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>do_allocate()</tt> (23.12.2.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.private">[mem.res.private]</a> p2+p3) says:
</p>
<blockquote>
<p>
<i>Returns:</i> A derived class shall implement this function to return a
pointer to allocated storage (3.7.4.2) with a size of at least <tt>bytes</tt>.
The returned storage is aligned to the specified alignment, if such
alignment is supported (3.11); otherwise it is aligned to <tt>max_align</tt>.
<p/>
<i>Throws:</i> A derived class implementation shall throw an appropriate
exception if it is unable to allocate memory with the requested size
and alignment.
</p>
</blockquote>
<p>
It is unclear whether a request for an unsupported alignment
(e.g. larger than <tt>max_align</tt>) yields an exception or the returned
storage is silently aligned to <tt>max_align</tt>.
<p/>
This is <a href="https://github.com/cplusplus/draft/issues/966">editorial issue #966</a>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; Marshall to ping Pablo for intent and provide wording.</p>

<p><i>[2017-02-12 Pablo responds and provides wording]</i></p>

<p>The original intent was:</p>
<ul>
  <li>If the alignment is supported by the implementation (see below), then it must use that alignment or else throw.</li>
  <li>If the alignment is not supported it must use max_align else throw.</li>
</ul>
<p>However, the description of do_allocate might have gone stale as the
aligned-allocation proposal made its way into the standard.</p>

<p>The understanding I take from the definition of extended alignment in
(the current text of) 3.11/3 [basic.align] and "assembling an argument
list" in 5.3.4/14 [expr.new] is that it is intended that, when
allocating space for an object with extended alignment in a well-formed
program, the alignment <i>will</i> be honored and <i>will not be</i>
truncated to max_align. I think this is a change from earlier drafts of
the extended-alignment proposal, where silent truncation to <tt>max_align</tt>
was permitted (I could be wrong). Anyway, it seems wrong to ever ignore
the alignment parameter in <tt>do_allocate()</tt>.</p>

<p><i>[2017-11 Albuquerque Wednesday issue processing]</i></p>

<p>Move to Ready.</p>


<p><b>Proposed resolution:</b></p>
<p>Change the specification of <tt>do_allocate()</tt> (23.12.2.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.private">[mem.res.private]</a> p2+p3) as follows:</p>

<blockquote>
  <p><i>Returns</i>: A derived class shall implement this function to
  return a pointer to allocated storage (3.7.4.2) with a size of at
  least <tt>bytes</tt><ins>, aligned to the specified
  <tt>alignment</tt></ins>. <del>The returned storage is aligned to the
  specified alignment, if such alignment is supported; otherwise it is
  aligned to <tt>max_align</tt>.</del></p>

<p><i>Throws:</i> A derived class implementation shall throw an
appropriate exception if it is unable to allocate memory with the
requested size and alignment.</p>
</blockquote>





<hr>
<h3><a name="2969" href="2969">2969.</a> <tt>polymorphic_allocator::construct()</tt> shouldn't pass <tt>resource()</tt></h3>
<p><b>Section:</b> 23.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2017-05-30 <b>Last modified:</b> 2017-11-10 03:05:33 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#mem.poly.allocator.mem">active issues</a> in [mem.poly.allocator.mem].</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.poly.allocator.mem">issues</a> in [mem.poly.allocator.mem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 23.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> defines the effect of <tt>polymorphic_allocator&lt;T&gt;::construct</tt> as:
</p>
<blockquote>
<p>
<i>Effects:</i> Construct a <tt>T</tt> object in the storage whose address is represented by <tt>p</tt> by uses-allocator
construction with allocator <tt>resource()</tt> and constructor arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</p>
</blockquote>
<p>
The use of <tt>resource()</tt> is a hold-over from the LFTS, which contains a modified definition of uses-allocator construction. This revised definition was not carried over into the C++17 WP when allocator_resource and polymorphic_allocator were moved over.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4659">N4659</a>.</p>

<ol>
<li>
<p>Edit 23.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-5- <i>Requires:</i> Uses-allocator construction of <tt>T</tt> with allocator <tt><del>resource()</del><ins>*this</ins></tt> (see 
23.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>) and constructor arguments <tt>std::forward&lt;Args&gt;(args)...</tt> 
is well-formed. [<i>Note:</i> Uses-allocator construction is always well formed for types that do not use 
allocators. &mdash; <i>end note</i>]
<p/>
-6- <i>Effects:</i> Construct a <tt>T</tt> object in the storage whose address is represented by <tt>p</tt> by 
uses-allocator construction with allocator <tt><del>resource()</del><ins>*this</ins></tt> and constructor arguments 
<tt>std::forward&lt;Args&gt;(args)...</tt>.
<p/>
-7- <i>Throws:</i> Nothing unless the constructor for <tt>T</tt> throws.
</p>
</blockquote>
<pre>
template &lt;class T1, class T2, class... Args1, class... Args2&gt;
  void construct(pair&lt;T1,T2&gt;* p, piecewise_construct_t,
                 tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);
</pre>
<blockquote>
<p>
-8- [<i>Note:</i> This method and the <tt>construct</tt> methods that follow are overloads for piecewise construction
of pairs (23.4.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a>). &mdash; <i>end note</i>]
<p/>
-9- <i>Effects:</i> Let <tt>xprime</tt> be a <tt>tuple</tt> constructed from <tt>x</tt> according to the appropriate rule 
from the following list. [<i>Note:</i> The following description can be summarized as constructing a 
<tt>pair&lt;T1, T2&gt;</tt> object in the storage whose address is represented by <tt>p</tt>, as if by separate 
uses-allocator construction with allocator <tt><del>resource()</del><ins>*this</ins></tt> 
(23.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>) of <tt>p-&gt;first</tt> using the elements of <tt>x</tt> and 
<tt>p-&gt;second</tt> using the elements of <tt>y</tt>. &mdash; <i>end note</i>]
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-06-12, Pablo comments]</i></p>

<p>
The current description is correct and does not depend on changes to uses-allocator construction. It relies on the fact 
that <tt>memory_resource*</tt> is convertible to <tt>polymorphic_allocator</tt>.
</p>

<p><i>[2017-06-13, Tim Song reopens]</i></p>

<p>
While it is true that <tt>memory_resource*</tt> is convertible to <tt>polymorphic_allocator</tt>,
uses-allocator construction still requires allocators, and a
<tt>memory_resource*</tt> isn't an allocator.
<p/>
To take a concrete example from the current WP, a <tt>pmr::vector&lt;std::promise&lt;int&gt;&gt;</tt>, as specified, 
will be attempting to uses-allocator construct a <tt>promise&lt;int&gt;</tt> with a <tt>memory_resource*</tt>, but
<tt>std::promise</tt>'s allocator-taking constructor expects something that satisfies the allocator requirements, 
rather than a <tt>memory_resource*</tt>.
</p>

<p><i>[2017-06-13, Daniel and Tim restore and improve the previously proposed wording]</i></p>

<p>
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Priority 2; Dietmar to check the P/R before Albuquerque.</p>

<p><i>[2017-11 Albuquerque Wednesday issue processing]</i></p>

<p>Move to Ready.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4659">N4659</a>.</p>

<ol>
<li>
<p>Edit 23.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-5- <i>Requires:</i> Uses-allocator construction of <tt>T</tt> with allocator <tt><del>resource()</del><ins>*this</ins></tt> (see 
23.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>) and constructor arguments <tt>std::forward&lt;Args&gt;(args)...</tt> 
is well-formed. [<i>Note:</i> Uses-allocator construction is always well formed for types that do not use 
allocators. &mdash; <i>end note</i>]
<p/>
-6- <i>Effects:</i> Construct a <tt>T</tt> object in the storage whose address is represented by <tt>p</tt> by 
uses-allocator construction with allocator <tt><del>resource()</del><ins>*this</ins></tt> and constructor arguments 
<tt>std::forward&lt;Args&gt;(args)...</tt>.
<p/>
-7- <i>Throws:</i> Nothing unless the constructor for <tt>T</tt> throws.
</p>
</blockquote>
<pre>
template &lt;class T1, class T2, class... Args1, class... Args2&gt;
  void construct(pair&lt;T1,T2&gt;* p, piecewise_construct_t,
                 tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);
</pre>
<blockquote>
<p>
-8- [<i>Note:</i> This method and the <tt>construct</tt> methods that follow are overloads for piecewise construction
of pairs (23.4.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a>). &mdash; <i>end note</i>]
<p/>
-9- <i>Effects:</i> Let <tt>xprime</tt> be a <tt>tuple</tt> constructed from <tt>x</tt> according to the appropriate rule 
from the following list. [<i>Note:</i> The following description can be summarized as constructing a 
<tt>pair&lt;T1, T2&gt;</tt> object in the storage whose address is represented by <tt>p</tt>, as if by separate 
uses-allocator construction with allocator <tt><del>resource()</del><ins>*this</ins></tt> 
(23.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>) of <tt>p-&gt;first</tt> using the elements of <tt>x</tt> and 
<tt>p-&gt;second</tt> using the elements of <tt>y</tt>. &mdash; <i>end note</i>]
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If <tt>uses_allocator_v&lt;T1,<del>memory_resource*</del><ins>polymorphic_allocator</ins>&gt;</tt> is <tt>false</tt>
and <tt>is_constructible_v&lt;T1,Args1...&gt;</tt> is <tt>true</tt>, then <tt>xprime</tt> is <tt>x</tt>.</p></li>
<li><p>(9.2) &mdash; Otherwise, if <tt>uses_allocator_v&lt;T1,<del>memory_resource*</del><ins>polymorphic_allocator</ins>&gt;</tt> is <tt>true</tt>
and <tt>is_constructible_v&lt;T1,allocator_arg_t,<del>memory_resource*</del><ins>polymorphic_allocator</ins>,Args1...&gt;</tt> is <tt>true</tt>, then 
<tt>xprime</tt> is <tt>tuple_cat(make_tuple(allocator_arg, <del>resource()</del><ins>*this</ins>), 
std::move(x))</tt>.</p></li>
<li><p>(9.3) &mdash; Otherwise, if <tt>uses_allocator_v&lt;T1,<del>memory_resource*</del><ins>polymorphic_allocator</ins>&gt;</tt> is <tt>true</tt> and 
<tt>is_constructible_v&lt;T1,Args1...,<del>memory_resource*</del><ins>polymorphic_allocator</ins>&gt;</tt> is <tt>true</tt>, then <tt>xprime</tt> is 
<tt>tuple_cat(std::move(x), make_tuple(<del>resource()</del><ins>*this</ins>))</tt>.</p></li>
<li><p>(9.4) &mdash; Otherwise the program is ill formed.</p></li>
</ol>
<p>
Let <tt>yprime</tt> be a tuple constructed from <tt>y</tt> according to the appropriate rule from the following list:
</p>
<ol style="list-style-type: none">
<li><p>(9.5) &mdash; If <tt>uses_allocator_v&lt;T2,<del>memory_resource*</del><ins>polymorphic_allocator</ins>&gt;</tt> is <tt>false</tt>
and <tt>is_constructible_v&lt;T2,Args2...&gt;</tt> is <tt>true</tt>, then <tt>yprime</tt> is <tt>y</tt>.</p></li>
<li><p>(9.6) &mdash; Otherwise, if <tt>uses_allocator_v&lt;T2,<del>memory_resource*</del><ins>polymorphic_allocator</ins>&gt;</tt> is <tt>true</tt> and 
<tt>is_constructible_v&lt;T2,allocator_arg_t,<del>memory_resource*</del><ins>polymorphic_allocator</ins>,Args2...&gt;</tt> is <tt>true</tt>, then <tt>yprime</tt> 
is <tt>tuple_cat(make_tuple(allocator_arg, <del>resource()</del><ins>*this</ins>), std::move(y))</tt>.</p></li>
<li><p>(9.7) &mdash; Otherwise, if <tt>uses_allocator_v&lt;T2,<del>memory_resource*</del><ins>polymorphic_allocator</ins>&gt;</tt> is <tt>true</tt> and 
<tt>is_constructible_v&lt;T2,Args2...,<del>memory_resource*</del><ins>polymorphic_allocator</ins>&gt;</tt> is <tt>true</tt>,
then <tt>yprime</tt> is <tt>tuple_cat(std::move(y), make_tuple(<del>resource()</del><ins>*this</ins>))</tt>.</p></li>
<li><p>(9.8) &mdash; Otherwise the program is ill formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2975" href="2975">2975.</a> Missing case for <tt>pair</tt> construction in scoped and polymorphic allocators</h3>
<p><b>Section:</b> 23.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a>, 23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2017-06-13 <b>Last modified:</b> 2017-11-10 03:05:33 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#mem.poly.allocator.mem">active issues</a> in [mem.poly.allocator.mem].</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.poly.allocator.mem">issues</a> in [mem.poly.allocator.mem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> ([allocator.adaptor.syn]) and <tt>polymorphic_allocator</tt> ([mem.poly.allocator.class]) 
have identical families of members named <tt>construct</tt>:
</p>
<blockquote>
<pre>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);

template &lt;class T1, class T2, class... Args1, class... Args2&gt;
  void construct(pair&lt;T1,T2&gt;* p, piecewise_construct_t,
                 tuple&lt;Args1...&gt; x, tuple&lt;Args2...&gt; y);
template &lt;class T1, class T2&gt;
  void construct(pair&lt;T1,T2&gt;* p);
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1,T2&gt;* p, U&amp;&amp; x, V&amp;&amp; y);
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1,T2&gt;* p, const pair&lt;U, V&gt;&amp; pr);
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1,T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; pr);
</pre>
</blockquote>
<p>
Both allocators perform <tt>uses_allocator</tt> construction, and therefore need special handling for <tt>pair</tt> 
constructions since <tt>pair</tt> doesn't specialize <tt>uses_allocator</tt> (<tt>tuple</tt> gets all of that magic 
and <tt>pair</tt> is left out in the cold). Presumably, the intent is that the <tt>construct</tt> overloads whose first 
argument is a pointer to <tt>pair</tt> capture all <tt>pair</tt> constructions. This is not the case: invoking 
<tt>construct</tt> with a <tt>pair</tt> pointer and a non-constant lvalue <tt>pair</tt> resolves to the <em>first</em> 
overload when it is viable: it's a better match than the <tt>pair</tt>-pointer-and-<tt>const</tt>-lvalue-<tt>pair</tt> 
overload. The first overload notably does not properly perform piecewise <tt>uses_allocator</tt> construction for 
<tt>pair</tt>s as intended.
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Priority 2; Marshall to work with Casey to reduce the negations in the wording.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<ol>
<li>
<p>Modify 23.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-5- <i>Requires:</i> Uses-allocator construction of <tt>T</tt> with allocator <tt>resource()</tt> (see 
23.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>) and constructor arguments <tt>std::forward&lt;Args&gt;(args)...</tt> 
is well-formed. [<i>Note:</i> Uses-allocator construction is always well formed for types that do not use allocators.
&mdash; <i>end note</i>]
<p/>
-6- <i>Effects:</i> Construct a <tt>T</tt> object in the storage whose address is represented by <tt>p</tt> by 
uses-allocator construction with allocator <tt>resource()</tt> and constructor arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
<p/>
-7- <i>Throws:</i> Nothing unless the constructor for <tt>T</tt> throws.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless <tt>T</tt> is not a specialization 
of <tt>pair</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless <tt>T</tt> is not a specialization 
of <tt>pair</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2017-11-02 Marshall and Casey provide updated wording]</i></p>


<p><i>[2017-11 Albuquerque Wednesday issue processing]</i></p>

<p>Move to Ready.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4659">N4659</a>.</p>

<ol>
<li>
<p>Modify 23.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-5- <i>Requires:</i> Uses-allocator construction of <tt>T</tt> with allocator <tt>resource()</tt> (see 
23.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>) and constructor arguments <tt>std::forward&lt;Args&gt;(args)...</tt> 
is well-formed. [<i>Note:</i> Uses-allocator construction is always well formed for types that do not use allocators.
&mdash; <i>end note</i>]
<p/>
-6- <i>Effects:</i> Construct a <tt>T</tt> object in the storage whose address is represented by <tt>p</tt> by 
uses-allocator construction with allocator <tt>resource()</tt> and constructor arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
<p/>
-7- <i>Throws:</i> Nothing unless the constructor for <tt>T</tt> throws.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution if <tt>T</tt> is a specialization 
of <tt>pair</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 23.13.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution if <tt>T</tt> is a specialization 
of <tt>pair</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3000" href="3000">3000.</a> <tt>monotonic_memory_resource::do_is_equal</tt> uses <tt>dynamic_cast</tt> unnecessarily</h3>
<p><b>Section:</b> 23.12.6.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.monotonic.buffer.mem">[mem.res.monotonic.buffer.mem]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2017-07-14 <b>Last modified:</b> 2017-11-01 18:57:15 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section [mem.res.monotonic.buffer.mem], paragraph 11 says
</p>
<blockquote>
<pre>
bool do_is_equal(const memory_resource&amp; other) const noexcept override;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>this == dynamic_cast&lt;const monotonic_buffer_resource*&gt;(&amp;other)</tt>.
</p>
</blockquote>
</blockquote>
<p>
The <tt>dynamic_cast</tt> adds nothing of value. It is an incorrect cut-and-paste from an example <tt>do_is_equal</tt>
for a more complex resource.
</p>

<p><i>[2017-07-16, Tim Song comments]</i></p>

<p>
The pool resource classes appear to also have this issue.
</p>

<p><i>[2017-09-18, Casey Carter expands PR to cover the pool resources.]</i></p>


<strong>Previous resolution: [SUPERSEDED]</strong>

<blockquote class="note">
<ol>
<li><p>Edit 23.12.6.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.monotonic.buffer.mem">[mem.res.monotonic.buffer.mem]</a> as indicated:</p>

<blockquote><pre>
bool do_is_equal(const memory_resource&amp; other) const noexcept override;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>this == <del>dynamic_cast&lt;const monotonic_buffer_resource*&gt;(</del>&amp;other<del>)</del></tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[
2017-11-01 Moved to Tentatively Ready after 7 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 23.12.5.4 <a href="https://timsong-cpp.github.io/cppwp/mem.res.pool.mem">[mem.res.pool.mem]</a> as indicated:</p>

<blockquote><pre>
bool <del>synchronized_pool_resource::</del>do_is_equal(<ins>const memory_resource&amp; other) const noexcept override;</ins>
    <del>const memory_resource&amp; other) const noexcept override;</del>
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>this == <del>dynamic_cast&lt;const synchronized_pool_resource*&gt;(</del>&amp;other<del>)</del></tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Strike 23.12.5.4 <a href="https://timsong-cpp.github.io/cppwp/mem.res.pool.mem">[mem.res.pool.mem]</a> paragraph 10, and the immediately preceding declaration of <tt>unsynchronized_pool_resource::do_is_equal</tt>.</p>
</li>

<li><p>Edit 23.12.6.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.monotonic.buffer.mem">[mem.res.monotonic.buffer.mem]</a> as indicated:</p>

<blockquote><pre>
bool do_is_equal(const memory_resource&amp; other) const noexcept override;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>this == <del>dynamic_cast&lt;const monotonic_buffer_resource*&gt;(</del>&amp;other<del>)</del></tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3002" href="3002">3002.</a> [networking.ts] <tt>basic_socket_acceptor::is_open()</tt> isn't <tt>noexcept</tt></h3>
<p><b>Section:</b> 99 [networking.ts::socket.acceptor.ops] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-07-14 <b>Last modified:</b> 2017-11-01 17:51:08 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: networking.ts</b></p>
<p>
<tt>basic_socket::is_open()</tt> is <tt>noexcept</tt>, but the corresponding function on
<tt>basic_socket_acceptor</tt> is not. This is a simple observer with a wide contract and cannot fail.</p>

<p><i>[
2017-11-01 Moved to Tentatively Ready after 7 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4656">N4656</a>.</p>

<ol>
<li><p>Edit  [networking.ts::socket.acceptor], class template <tt>basic_socket_acceptor</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template&lt;class AcceptableProtocol&gt; 
class basic_socket_acceptor {
public:
  [&hellip;]
  bool is_open() const <ins>noexcept</ins>;
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Edit 99 [networking.ts::socket.acceptor.ops] as indicated:</p>

<blockquote>
<pre>
bool is_open() const <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-10- <i>Returns:</i> A <tt>bool</tt> indicating whether this acceptor was opened by a previous call to <tt>open</tt> or <tt>assign</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3004" href="3004">3004.</a> &sect;[string.capacity] and &sect;[vector.capacity] should specify time complexity for <tt>capacity()</tt></h3>
<p><b>Section:</b> 24.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a>, 26.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Andy Giese <b>Opened:</b> 2017-07-24 <b>Last modified:</b> 2017-11-01 18:09:14 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.capacity">active issues</a> in [string.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.capacity">issues</a> in [string.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>basic_string</tt> and <tt>vector</tt> both have a <tt>capacity</tt> function that returns the size of the internally 
allocated buffer. This function does not specify a time complexity nor does it have an implied time complexity. However, 
given the complexities for <tt>data()</tt> to be <tt>&#x1d4aa;(1)</tt> and <tt>size()</tt> to be <tt>&#x1d4aa;(1)</tt>, 
we can imagine that it's reasonable to also require <tt>capacity()</tt> to be <tt>&#x1d4aa;(1)</tt>, since the 
implementation will most likely be caching the size of the allocated buffer so as to check for the need to reallocate 
on insertion.
</p>

<p><i>[
2017-11-01 Moved to Tentatively Ready after 10 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4659">N4659</a>.</p>

<ol>
<li><p>Edit 24.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a> as indicated:</p>

<blockquote>
<pre>
size_type capacity() const noexcept;
</pre>
<blockquote>
<p>
-9- <i>Returns:</i> The size of the allocated storage in the string.
<p/>
<ins>-?- <i>Complexity:</i> Constant time.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 26.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> as indicated:</p>

<blockquote>
<pre>
size_type capacity() const noexcept;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> The total number of elements that the vector can hold without requiring reallocation.
<p/>
<ins>-?- <i>Complexity:</i> Constant time.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3005" href="3005">3005.</a> Destruction order of arrays by <tt>make_shared/allocate_shared</tt> only recommended?</h3>
<p><b>Section:</b> 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2017-08-01 <b>Last modified:</b> 2017-11-02 16:34:45 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.create">active issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [util.smartptr.shared.create]/7.9 we find this:
</p>
<blockquote><p>
"When the lifetime of the object managed by the return value ends, or when the initialization of an 
array element throws an exception, the initialized elements should be destroyed in the reverse order 
of their construction."
</p></blockquote>
<p>
Why is this only a "should be" and not a "shall be" (or, following usual conventions for how we write 
requirements on the implementation, "are")? Is there some problem that means we can't require an 
implementation to destroy in reverse construction order in all cases?
</p>

<strong>Previous resolution: [SUPERSEDED]</strong>

<blockquote class="note">
<p>This resolution is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, ...&gt;
shared_ptr&lt;T&gt; make_shared(<i>args</i>);
template&lt;class T, class A, ...&gt;
shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, <i>args</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Remarks:</i>
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(7.9) &mdash; When the lifetime of the object managed by the return value ends, or when the initialization of
an array element throws an exception, the initialized elements <ins>are</ins><del>should be</del> destroyed in 
<ins>decreasing index order</ins><del>the reverse order of their construction</del>.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2017-11-01, Alisdair comments and suggests wording improvement]</i></p>

<p>
I dislike the change of how we specify the order of destruction, which is clear (but
non-normative) from the preceding paragraph making the order of construction
explicit.  We are replacing that with a different specification, so now I need to match
up ""decreasing index order" to "ascending order of address" to infer the behavior that
is worded more directly today.
<p/>
P0 to change "should be" to "are" though.
</p>

<strong>Previous resolution: [SUPERSEDED]</strong>

<blockquote class="note">
<p>This resolution is relative to <a href="http://wg21.link/n4700">N4700</a>.</p>

<ol>
<li><p>Edit 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, ...&gt;
shared_ptr&lt;T&gt; make_shared(<i>args</i>);
template&lt;class T, class A, ...&gt;
shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, <i>args</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Remarks:</i>
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(7.9) &mdash; When the lifetime of the object managed by the return value ends, or when the initialization of
an array element throws an exception, the initialized elements <ins>are</ins><del>should be</del> destroyed in 
the reverse order of their construction.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2017-11-01]</i></p>

<p>
The rationale for the "decreasing index order" change in the original P/R suggested by Richard Smith had been presented 
as that user code may destroy one or more array elements and construct new ones in their place. In those cases 
<tt>shared_ptr</tt> has no way of knowing the construction order, so it cannot ensure that the destruction order reverses 
it.<br/>
Richard: Perhaps something like:
</p>
<blockquote><p>
the initialized elements <ins>are</ins> <del>should be</del> destroyed in the reverse order of their <ins>original</ins> construction.
</p></blockquote>
<p>
would work?
</p>

<p><i>[
2017-11-02 Moved to Tentatively Ready after 10 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4700">N4700</a>.</p>

<ol>
<li><p>Edit 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, ...&gt;
shared_ptr&lt;T&gt; make_shared(<i>args</i>);
template&lt;class T, class A, ...&gt;
shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, <i>args</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Remarks:</i>
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(7.9) &mdash; When the lifetime of the object managed by the return value ends, or when the initialization of
an array element throws an exception, the initialized elements <ins>are</ins><del>should be</del> destroyed in 
the reverse order of their <ins>original</ins> construction.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3007" href="3007">3007.</a> <tt>allocate_shared</tt> should rebind allocator to <i>cv</i>-unqualified <tt>value_type</tt> for construction</h3>
<p><b>Section:</b> 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Glen Joseph Fernandes <b>Opened:</b> 2017-08-06 <b>Last modified:</b> 2017-11-01 19:02:49 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.create">active issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The remarks for the <tt>allocate_shared</tt> family of functions
specify that when constructing a (sub)object of type <tt>U</tt>, it uses a
rebound copy of the allocator <tt>a</tt> passed to
<tt>allocate_shared</tt> such that its <tt>value_type</tt> is
<tt>U</tt>. However <tt>U</tt> can be a <tt>const</tt> or
<tt>volatile</tt> qualified type, and [allocator.requirements] specify
that the <tt>value_type</tt> must be <i>cv</i>-unqualified.
</p>

<p><i>[
2017-11-01 Moved to Tentatively Ready after 6 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 23.11.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, ...&gt;
shared_ptr&lt;T&gt; make_shared(<i>args</i>);
template&lt;class T, class A, ...&gt;
shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, <i>args</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Remarks:</i>
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(7.5) &mdash; When a (sub)object of a non-array type <tt>U</tt> is specified to have an initial value of <tt>v</tt>, 
or <tt>U(l...)</tt>, where <tt>l...</tt> is a list of constructor arguments, <tt>allocate_shared</tt> shall initialize this 
(sub)object via the expression</p>
<ol style="list-style-type: none">
<li><p>(7.5.1) &mdash; <tt>allocator_traits&lt;A2&gt;::construct(a2, pv, v)</tt> or</p></li>
<li><p>(7.5.2) &mdash; <tt>allocator_traits&lt;A2&gt;::construct(a2, pv, l...)</tt></p></li>
</ol>
<p>
respectively, where <tt>pv</tt> points to storage suitable to hold an object of type <tt>U</tt> and <tt>a2</tt> of 
type <tt>A2</tt> is a rebound copy of the allocator a passed to <tt>allocate_shared</tt> such that its 
<tt>value_type</tt> is <tt><ins>remove_cv_t&lt;</ins>U<ins>&gt;</ins></tt>.
</p>
</li>
<li><p>(7.6) &mdash; When a (sub)object of non-array type <tt>U</tt> is specified to have a default initial value, 
<tt>make_shared</tt> shall initialize this (sub)object via the expression <tt>::new(pv) U()</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>U</tt>.</p></li>
<li><p>(7.7) &mdash; When a (sub)object of non-array type <tt>U</tt> is specified to have a default initial value, 
<tt>allocate_shared</tt> shall initialize this (sub)object via the expression <tt>allocator_traits&lt;A2&gt;::construct(a2, pv)</tt>,
where <tt>pv</tt> points to storage suitable to hold an object of type <tt>U</tt> and <tt>a2</tt> of type <tt>A2</tt> 
is a rebound copy of the allocator a passed to <tt>allocate_shared</tt> such that its <tt>value_type</tt> is 
<tt><ins>remove_cv_t&lt;</ins>U<ins>&gt;</ins></tt>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3009" href="3009">3009.</a> Including <tt>&lt;string_view&gt;</tt> doesn't provide <tt>std::size/empty/data</tt></h3>
<p><b>Section:</b> 27.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.container">[iterator.container]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-08-11 <b>Last modified:</b> 2017-11-01 18:31:36 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>basic_string_view</tt> has <tt>size()</tt>, <tt>empty()</tt>, and <tt>data()</tt> members, but
including <tt>&lt;string_view&gt;</tt> isn't guaranteed to give you access to the
corresponding free function templates. This seems surprising.
</p>

<p><i>[
2017-11-01 Moved to Tentatively Ready after 7 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 27.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.container">[iterator.container]</a> as indicated:</p>

<blockquote>
<p>
-1- In addition to being available via inclusion of the <tt>&lt;iterator&gt;</tt> header, the function templates in 
27.8 are available when any of the following headers are included: <tt>&lt;array&gt;</tt>, 
<tt>&lt;deque&gt;</tt>, <tt>&lt;forward_list&gt;</tt>, <tt>&lt;list&gt;</tt>, <tt>&lt;map&gt;</tt>, 
<tt>&lt;regex&gt;</tt>, <tt>&lt;set&gt;</tt>, <tt>&lt;string&gt;</tt>, <ins><tt>&lt;string_view&gt;</tt>,</ins>
<tt>&lt;unordered_map&gt;</tt>, <tt>&lt;unordered_set&gt;</tt>, and <tt>&lt;vector&gt;</tt>.
</p>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3010" href="3010">3010.</a> [networking.ts] <tt>uses_executor</tt> says "if a type <tt>T::executor_type</tt> exists"</h3>
<p><b>Section:</b> 99 [networking.ts::async.uses.excecutor.trait] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-08-17 <b>Last modified:</b> 2017-11-01 18:09:14 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: networking.ts</b></p>
<p>
[async.uses.executor.trait] p1 says "if a type <tt>T::executor_type</tt> exists" but we don't want it to be required 
to detect private or ambiguous types.
</p>

<p><i>[
2017-11-01 Moved to Tentatively Ready after 7 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4656">N4656</a>.</p>

<ol>
<li><p>Edit  [networking.ts::async.uses.executor.trait] as indicated:</p>

<blockquote>
<p>
-1- Remark: Detects whether <tt>T</tt> has a nested <tt>executor_type</tt> that is convertible from
<tt>Executor</tt>. Meets the <tt>BinaryTypeTrait</tt> requirements (C++Std [meta.rqmts]). The implementation 
provides a definition that is derived from <tt>true_type</tt> if <del>a type</del><ins>the <em>qualified-id</em></ins> 
<tt>T::executor_type</tt> <del>exists</del><ins>is valid and denotes a type</ins> and 
<tt>is_convertible&lt;Executor, T::executor_type&gt;::value != false</tt>, otherwise it is derived from
<tt>false_type</tt>. A program may specialize this template [&hellip;].
</p>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3013" href="3013">3013.</a> <tt>(recursive_)directory_iterator</tt> construction and traversal should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 30.10.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a>, 30.10.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a>, 30.10.14.3 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a>, 30.10.14.19 <a href="https://timsong-cpp.github.io/cppwp/fs.op.is_empty">[fs.op.is_empty]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-08-23 <b>Last modified:</b> 2017-11-03 17:13:13 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fs.dir.itr.members">active issues</a> in [fs.dir.itr.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.dir.itr.members">issues</a> in [fs.dir.itr.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Constructing a <tt>(recursive_)directory_iterator</tt> from a <tt>path</tt> requires, at a minimum, initializing its 
underlying <tt>directory_entry</tt> object with the <tt>path</tt> formed from the supplied <tt>path</tt> and the name of the 
first entry, which requires a potentially throwing memory allocation; every implementation I've looked at also allocates 
memory to store additional data as well.
<p/>
Similarly, <tt>increment()</tt> needs to update the <tt>path</tt> stored in <tt>directory_entry</tt> object to refer 
to the name of the next entry, which may require a memory allocation. While it might conceivably be possible to 
postpone the update in this case until the iterator is dereferenced (the dereference operation is not <tt>noexcept</tt> 
due to its narrow contract), it seems highly unlikely that such an implementation is intended (not to mention that it 
would require additional synchronization as the dereference operations are const).
<p/>
This further calls into question whether the <tt>error_code</tt> overloads of <tt>copy</tt> and <tt>is_empty</tt>, 
whose specification uses <tt>directory_iterator</tt>, should be <tt>noexcept</tt>. There might be a case for keeping 
the <tt>noexcept</tt> for <tt>is_empty</tt>, although that would require changes in all implementations I checked 
(libstdc++, libc++, and Boost). <tt>copy</tt> appears to be relentlessly hostile to <tt>noexcept</tt>, since its 
specification forms a <tt>path</tt> via <tt>operator/</tt> in two places (bullets 4.7.4 and 4.8.2) in addition to the 
<tt>directory_iterator</tt> usage. The proposed resolution below removes both.
</p>

<p><i>[
2017-11-03 Moved to Tentatively Ready after 7 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4700">N4700</a>.</p>

<ol>
<li><p>Edit 30.10.12 <a href="https://timsong-cpp.github.io/cppwp/fs.class.directory_iterator">[fs.class.directory_iterator]</a>, class <tt>directory_iterator</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
explicit directory_iterator(const path&amp; p);
directory_iterator(const path&amp; p, directory_options options);
directory_iterator(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
directory_iterator(const path&amp; p, directory_options options,
                   error_code&amp; ec) <del>noexcept</del>;
[&hellip;]

directory_iterator&amp; operator++();
directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
</blockquote>
</li>

<li><p>Edit 30.10.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a> before p2 as indicated:</p>
<blockquote>
<pre>
explicit directory_iterator(const path&amp; p);
directory_iterator(const path&amp; p, directory_options options);
directory_iterator(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> [&hellip;]
<p/>
-3- <i>Throws:</i> As specified in 30.10.6 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.
<p/>
-4- [<i>Note:</i> [&hellip;] &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 30.10.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a> before p10 as indicated:</p>
<blockquote>
<pre>
directory_iterator&amp; operator++();
directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-10- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3).
<p/>
-11- <i>Returns:</i> <tt>*this</tt>.
<p/>
-12- <i>Throws:</i> As specified in 30.10.6 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 30.10.13 <a href="https://timsong-cpp.github.io/cppwp/fs.class.rec.dir.itr">[fs.class.rec.dir.itr]</a>, class <tt>recursive_directory_iterator</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options,
                             error_code&amp; ec) <del>noexcept</del>;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
[&hellip;]

recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
</blockquote>
</li>

<li><p>Edit 30.10.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> before p2 as indicated:</p>
<blockquote>
<pre>
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) <del>noexcept</del>;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> [&hellip;]
<p/>
-3- <i>Postconditions:</i> [&hellip;]
<p/>
-4- <i>Throws:</i> As specified in 30.10.6 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.
<p/>
-5- [<i>Note:</i> [&hellip;] &mdash; <i>end note</i>]
<p/>
-6- [<i>Note:</i> [&hellip;] &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 30.10.13.1 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> before p23 as indicated:</p>
<blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-23- <i>Effects:</i> As specified for the prefix increment operation of Input iterators (24.2.3), except that: [&hellip;]
<p/>
-24- <i>Returns:</i> <tt>*this</tt>.
<p/>
-25- <i>Throws:</i> As specified 30.10.6 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 30.10.5 <a href="https://timsong-cpp.github.io/cppwp/fs.filesystem.syn">[fs.filesystem.syn]</a>, header <tt>&lt;filesystem&gt;</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std::filesystem {

  [&hellip;]

  void copy(const path&amp; from, const path&amp; to);
  void copy(const path&amp; from, const path&amp; to, error_code&amp; ec) <del>noexcept</del>;
  void copy(const path&amp; from, const path&amp; to, copy_options options);
  void copy(const path&amp; from, const path&amp; to, copy_options options,
            error_code&amp; ec) <del>noexcept</del>;

  [&hellip;]

  bool is_empty(const path&amp; p);
  bool is_empty(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
  
  [&hellip;]

}
</pre>
</blockquote>
</li>

<li><p>Edit 30.10.14.3 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a> as indicated:</p>
<blockquote>
<pre>
void copy(const path&amp; from, const path&amp; to, error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Equivalent to <tt>copy(from, to, copy_options::none, ec)</tt>.
</p>
</blockquote>
<pre>
void copy(const path&amp; from, const path&amp; to, copy_options options);
void copy(const path&amp; from, const path&amp; to, copy_options options,
          error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-3- <i>Requires:</i> [&hellip;]
<p/>
-4- <i>Effects:</i> [&hellip;]
<p/>
-5- <i>Throws:</i> [&hellip;]
<p/>
-6- <i>Remarks:</i> [&hellip;]
<p/>
-7- [<i>Example:</i> [&hellip;] &mdash; <i>end example</i>]
</p>
</blockquote>
</blockquote>
</li>


<li><p>Edit 30.10.14.19 <a href="https://timsong-cpp.github.io/cppwp/fs.op.is_empty">[fs.op.is_empty]</a> as indicated:</p>
<blockquote>
<pre>
bool is_empty(const path&amp; p);
bool is_empty(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> [&hellip;]
<p/>
-2- <i>Throws:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3014" href="3014">3014.</a> More <tt>noexcept</tt> issues with filesystem operations</h3>
<p><b>Section:</b> 30.10.14.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy_file">[fs.op.copy_file]</a>, 30.10.14.6 <a href="https://timsong-cpp.github.io/cppwp/fs.op.create_directories">[fs.op.create_directories]</a>, 30.10.14.31 <a href="https://timsong-cpp.github.io/cppwp/fs.op.remove_all">[fs.op.remove_all]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-08-23 <b>Last modified:</b> 2017-11-09 15:13:04 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fs.op.copy_file">active issues</a> in [fs.op.copy_file].</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.copy_file">issues</a> in [fs.op.copy_file].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>create_directories</tt> may need to create temporary <tt>path</tt>s, and <tt>remove_all</tt> may need to create temporary 
<tt>path</tt>s and/or <tt>directory_iterator</tt>s. These operations may require a potentially throwing memory allocation.
<p/>
Implementations of <tt>copy_file</tt> may wish to dynamically allocate the buffer used for copying when the underlying OS 
doesn't supply a copy API directly. This can happen indirectly, e.g., by using <tt>&lt;fstream&gt;</tt> facilities to 
perform the copying without supplying a custom buffer. Unless LWG wishes to prohibit using a dynamically allocated buffer 
in this manner, the <tt>noexcept</tt> should be removed.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Moved to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 30.10.5 <a href="https://timsong-cpp.github.io/cppwp/fs.filesystem.syn">[fs.filesystem.syn]</a>, header <tt>&lt;filesystem&gt;</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std::filesystem {

  [&hellip;]
  
  bool copy_file(const path&amp; from, const path&amp; to);
  bool copy_file(const path&amp; from, const path&amp; to, error_code&amp; ec) <del>noexcept</del>;
  bool copy_file(const path&amp; from, const path&amp; to, copy_options option);
  bool copy_file(const path&amp; from, const path&amp; to, copy_options option,
                 error_code&amp; ec) <del>noexcept</del>;

  [&hellip;]

  bool create_directories(const path&amp; p);
  bool create_directories(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
  
  [&hellip;]
  
  uintmax_t remove_all(const path&amp; p);
  uintmax_t remove_all(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
  
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Edit 30.10.14.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy_file">[fs.op.copy_file]</a> as indicated:</p>
<blockquote>
<pre>
bool copy_file(const path&amp; from, const path&amp; to);
bool copy_file(const path&amp; from, const path&amp; to, error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> [&hellip;]
<p/>
-2- <i>Throws:</i> [&hellip;]
</p>
</blockquote>
<pre>
bool copy_file(const path&amp; from, const path&amp; to, copy_options options);
bool copy_file(const path&amp; from, const path&amp; to, copy_options options,
               error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-3- <i>Requires:</i> [&hellip;]
<p/>
-4- <i>Effects:</i> [&hellip;]
<p/>
-5- <i>Returns:</i> [&hellip;]
<p/>
-6- <i>Throws:</i> [&hellip;]
<p/>
-7- <i>Complexity:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 30.10.14.6 <a href="https://timsong-cpp.github.io/cppwp/fs.op.create_directories">[fs.op.create_directories]</a> as indicated:</p>
<blockquote>
<pre>
bool create_directories(const path&amp; p);
bool create_directories(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> [&hellip;]
<p/>
-2- <i>Postconditions:</i> [&hellip;]
<p/>
-3- <i>Returns:</i> [&hellip;]
<p/>
-4- <i>Throws:</i> [&hellip;]
<p/>
-5- <i>Complexity:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
<li><p>Edit 30.10.14.31 <a href="https://timsong-cpp.github.io/cppwp/fs.op.remove_all">[fs.op.remove_all]</a> as indicated:</p>
<blockquote>
<pre>
uintmax_t remove_all(const path&amp; p);
uintmax_t remove_all(const path&amp; p, error_code&amp; ec) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> [&hellip;]
<p/>
-2- <i>Postconditions:</i> [&hellip;]
<p/>
-3- <i>Returns:</i> [&hellip;]
<p/>
-4- <i>Throws:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3017" href="3017">3017.</a> <tt>list splice</tt> functions should use <tt>addressof</tt></h3>
<p><b>Section:</b> 26.3.9.6 <a href="https://timsong-cpp.github.io/cppwp/forwardlist.ops">[forwardlist.ops]</a>, 26.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-09-05 <b>Last modified:</b> 2017-11-03 17:20:12 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.3.9.6 <a href="https://timsong-cpp.github.io/cppwp/forwardlist.ops">[forwardlist.ops]</a> p1 and 26.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p3 say <tt>&amp;x != this</tt>, but should use
<tt>addressof</tt>. We really need front matter saying that when the library says <tt>&amp;x</tt> it means 
<tt>std::addressof(x)</tt>.
</p>

<p><i>[
2017-11-03 Moved to Tentatively Ready after 9 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 26.3.9.6 <a href="https://timsong-cpp.github.io/cppwp/forwardlist.ops">[forwardlist.ops]</a> p1 as indicated:</p>
<blockquote>
<pre>
void splice_after(const_iterator position, forward_list&amp; x);
void splice_after(const_iterator position, forward_list&amp;&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>position</tt> is <tt>before_begin()</tt> or is a dereferenceable iterator in the range <tt>[begin(), 
end())</tt>. <tt>get_allocator() == x.get_allocator()</tt>. <tt><del>&amp;</del><ins>addressof(</ins>x<ins>)</ins> != this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 26.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p3 as indicated:</p>
<blockquote>
<pre>
void splice(const_iterator position, list&amp; x);
void splice(const_iterator position, list&amp;&amp; x);
</pre>
<blockquote>
<p>
-3- <i>Requires:</i> <tt><del>&amp;</del><ins>addressof(</ins>x<ins>)</ins> != this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 26.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p3 as indicated:</p>
<blockquote>
<pre>
template &lt;class Compare&gt; void merge(list&amp; x, Compare comp);
template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>
-22- <i>Requires:</i> <tt>comp</tt> shall define a strict weak ordering (28.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a>), and both the list 
and the argument list shall be sorted according to this ordering.
<p/>
-23- <i>Effects:</i> If <tt>(<del>&amp;</del><ins>addressof(</ins>x<ins>)</ins> == this)</tt> does nothing; 
otherwise, merges the two sorted ranges <tt>[begin(), end())</tt> and <tt>[x.begin(), x.end())</tt>. The result 
is a range in which the elements will be sorted in non-decreasing order according to the ordering defined by 
<tt>comp</tt>; that is, for every iterator <tt>i</tt>, in the range other than the first, the condition 
<tt>comp(*i, *(i - 1))</tt> will be <tt>false</tt>. Pointers and references to the moved elements of <tt>x</tt> 
now refer to those same elements but as members of <tt>*this</tt>. Iterators referring to the moved elements 
will continue to refer to their elements, but they now behave as iterators into <tt>*this</tt>, not into <tt>x</tt>.
<p/>
-24- <i>Remarks:</i> Stable (20.5.5.7 <a href="https://timsong-cpp.github.io/cppwp/algorithm.stable">[algorithm.stable]</a>). If 
<tt>(<del>&amp;</del><ins>addressof(</ins>x<ins>)</ins> != this)</tt> the range <tt>[x.begin(), x.end())</tt> is 
empty after the merge. No elements are copied by this operation. The behavior is undefined if <tt>get_allocator() !=
x.get_allocator()</tt>.
<p/>
-25- <i>Complexity:</i> At most <tt>size() + x.size() - 1</tt> applications of <tt>comp</tt> if 
<tt>(<del>&amp;</del><ins>addressof(</ins>x<ins>)</ins> != this)</tt>; otherwise, no applications of <tt>comp</tt> are 
performed. If an exception is thrown other than by a comparison there are no effects.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3020" href="3020">3020.</a> [networking.ts] Remove spurious nested <tt>value_type</tt> buffer sequence requirement</h3>
<p><b>Section:</b> 99 [networking.ts::buffer.reqmts] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Vinnie Falco <b>Opened:</b> 2017-09-20 <b>Last modified:</b> 2017-10-22 15:16:55 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: networking.ts</b></p>
<p>
The post-condition requirements for <tt>ConstBufferSequence</tt> and <tt>MutableBufferSequence</tt> refer to <tt>X::value_type</tt>, 
but no such nested type is required. The lambda expression passed to <tt>equal</tt> can use <tt>auto const&amp;</tt> parameter types 
instead. 
</p>

<strong>Previous resolution: [SUPERSEDED]</strong>

<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4588">N4588</a>.
</p>

<ol>
<li>
<p>
Modify 99 [networking.ts::buffer.reqmts.mutablebuffersequence] Table 12 "<tt>MutableBufferSequence</tt> requirements" as indicated:
</p>
<blockquote>
<table border="1">
<caption>Table 12 &mdash; <tt>MutableBufferSequence</tt> requirements</caption>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>X u(x);</tt>
</td>
<td>
</td>
<td>
post:<br/>
<pre>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const <del>typename X::value_type</del><ins>auto</ins>&amp; v1,
     const <del>typename X::value_type</del><ins>auto</ins>&amp; v2)
    {
      mutable_buffer b1(v1);
      mutable_buffer b2(v2);
      return b1.data() == b2.data()
          &amp;&amp; b1.size() == b2.size();
    })
</pre>
</td>
</tr>
</table>
</blockquote>
</li>

<li>
<p>
Modify 99 [networking.ts::buffer.reqmts.constbuffersequence] Table 13 "<tt>ConstBufferSequence</tt> requirements" as indicated:
</p>
<blockquote>
<table border="1">
<caption>Table 13 &mdash; <tt>ConstBufferSequence</tt> requirements</caption>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>X u(x);</tt>
</td>
<td>
</td>
<td>
post:<br/>
<pre>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const <del>typename X::value_type</del><ins>auto</ins>&amp; v1,
     const <del>typename X::value_type</del><ins>auto</ins>&amp; v2)
    {
      const_buffer b1(v1);
      const_buffer b2(v2);
      return b1.data() == b2.data()
          &amp;&amp; b1.size() == b2.size();
    })
</pre>
</td>
</tr>
</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-10-19, Peter Dimov provides improved wording]</i></p>

<p>
The alternative wording prevents the need for <tt>auto</tt> parameters because it takes advantage of the "convertible to" 
requirement.
</p>

<p><i>[
2017-10-20 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4588">N4588</a>.
</p>

<ol>
<li>
<p>
Modify 99 [networking.ts::buffer.reqmts.mutablebuffersequence] Table 12 "<tt>MutableBufferSequence</tt> requirements" as indicated:
</p>
<blockquote>
<table border="1">
<caption>Table 12 &mdash; <tt>MutableBufferSequence</tt> requirements</caption>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>X u(x);</tt>
</td>
<td>
</td>
<td>
post:<br/>
<pre>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const <del>typename X::value_type&amp; v1</del><ins>mutable_buffer&amp; b1</ins>,
     const <del>typename X::value_type&amp; v2</del><ins>mutable_buffer&amp; b2</ins>)
    {
      <del>mutable_buffer b1(v1);
      mutable_buffer b2(v2);</del>
      return b1.data() == b2.data()
          &amp;&amp; b1.size() == b2.size();
    })
</pre>
</td>
</tr>
</table>
</blockquote>
</li>

<li>
<p>
Modify 99 [networking.ts::buffer.reqmts.constbuffersequence] Table 13 "<tt>ConstBufferSequence</tt> requirements" as indicated:
</p>
<blockquote>
<table border="1">
<caption>Table 13 &mdash; <tt>ConstBufferSequence</tt> requirements</caption>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>X u(x);</tt>
</td>
<td>
</td>
<td>
post:<br/>
<pre>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const <del>typename X::value_type&amp; v1</del><ins>const_buffer&amp; b1</ins>,
     const <del>typename X::value_type&amp; v2</del><ins>const_buffer&amp; v2</ins>)
    {
      <del>const_buffer b1(v1);
      const_buffer b2(v2);</del>
      return b1.data() == b2.data()
          &amp;&amp; b1.size() == b2.size();
    })
</pre>
</td>
</tr>
</table>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3026" href="3026">3026.</a> <tt>filesystem::weakly_canonical</tt> still defined in terms of <tt>canonical(p, base)</tt></h3>
<p><b>Section:</b> 30.10.14.39 <a href="https://timsong-cpp.github.io/cppwp/fs.op.weakly_canonical">[fs.op.weakly_canonical]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-10-14 <b>Last modified:</b> 2017-10-16 19:44:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2956">2956</a> fixed <tt>canonical</tt> to no longer use a base path, but <tt>weakly_canonical</tt> should have been
changed too:
</p>
<blockquote><p>
<i>Effects:</i> Using <tt>status(p)</tt> or <tt>status(p, ec)</tt>, respectively, to determine
existence, return a path composed by <tt>operator/=</tt> from the result of calling <tt>canonical()</tt> without
a <tt>base</tt> argument and with a [&hellip;]
</p></blockquote>
<p>
Since <tt>canonical</tt> doesn't accept a <tt>base</tt> argument, it doesn't make sense
to talk about calling it without one.
</p>

<p><i>[
2017-10-16 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Change 30.10.14.39 <a href="https://timsong-cpp.github.io/cppwp/fs.op.weakly_canonical">[fs.op.weakly_canonical]</a> as indicated:</p>

<blockquote>
<pre>
path weakly_canonical(const path&amp; p);
path weakly_canonical(const path&amp; p, error_code&amp; ec);
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> [&hellip;]
<p/>
-2- <i>Effects:</i> Using <tt>status(p)</tt> or <tt>status(p, ec)</tt>, respectively, to determine existence, return a path
composed by <tt>operator/=</tt> from the result of calling <tt>canonical()</tt> <del>without a <tt>base</tt> argument and</del> 
with a path argument composed of the leading elements of <tt>p</tt> that exist, if any, followed by the elements of <tt>p</tt>
that do not exist, if any. For the first form, <tt>canonical()</tt> is called without an <tt>error_code</tt> argument.
For the second form, <tt>canonical()</tt> is called with ec as an <tt>error_code</tt> argument, and <tt>path()</tt> is returned
at the first error occurrence, if any.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3030" href="3030">3030.</a> Who shall meet the requirements of <tt>try_lock</tt>?</h3>
<p><b>Section:</b> 33.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.algorithm">[thread.lock.algorithm]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-11-07 <b>Last modified:</b> 2017-11-09 15:13:04 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.lock.algorithm">issues</a> in [thread.lock.algorithm].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
33.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.algorithm">[thread.lock.algorithm]</a> says:
</p>
<blockquote><p>
"If a call to <tt>try_lock()</tt> fails, <tt>unlock()</tt> shall be called for all prior
arguments and there shall be no further calls to <tt>try_lock()</tt>."
</p></blockquote>
<p>
We try to use "shall" for requirements on the user (e.g. as in the
previous paragraph) which is absolutely not what is meant here.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Moved to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4700">N4700</a>.</p>

<ol>
<li><p>Change 33.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.algorithm">[thread.lock.algorithm]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class L1, class L2, class... L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> [&hellip;]
<p/>
-2- <i>Effects:</i> Calls <tt>try_lock()</tt> for each argument in order beginning with the first until all arguments have
been processed or a call to <tt>try_lock()</tt> fails, either by returning <tt>false</tt> or by throwing an exception.
If a call to <tt>try_lock()</tt> fails, <tt>unlock()</tt> <del>shall be</del><ins>is</ins> called for all prior arguments 
<del>and there shall be</del><ins>with</ins> no further calls to <tt>try_lock()</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class L1, class L2, class... L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
<p>
-4- <i>Requires:</i> [&hellip;]
<p/>
-5- <i>Effects:</i> All arguments are locked via a sequence of calls to <tt>lock()</tt>, <tt>try_lock()</tt>, 
or <tt>unlock()</tt> on each argument. The sequence of calls <del>shall</del><ins>does</ins> not result in deadlock, 
but is otherwise unspecified. [<i>Note:</i> A deadlock avoidance algorithm such as try-and-back-off must be used, but the 
specific algorithm is not specified to avoid over-constraining implementations. &mdash; <i>end note</i>] If a 
call to <tt>lock()</tt> or <tt>try_lock()</tt> throws an exception, <tt>unlock()</tt> <del>shall be</del><ins>is</ins> 
called for any argument that had been locked by a call to <tt>lock()</tt> or <tt>try_lock()</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3034" href="3034">3034.</a> P0767R1 breaks previously-standard-layout types</h3>
<p><b>Section:</b> 23.15.7.6 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2017-11-12 <b>Last modified:</b> 2017-11-17 21:23:09 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://wg21.link/p0767r1">P0767R1 "Expunge POD"</a> changed the
requirement for several library types from "POD" to "trivial." Since these types
no longer provide/require the standard-layout portion of "POD," the change breaks:
<ul>
<li>user classes with a member of such a type that were standard-layout in C++17</li>
<li>implementations of <tt>basic_string</tt> and <tt>basic_string_view</tt> that
expect character types to be both trivial and standard layout.</li>
</ul>
It appears this breakage was not intentional and not discussed in LWG.
</p>
<p>
The fix is straight-forward: apply an additional standard-layout requirement to
the affected types:
<ul>
<li><tt>max_align_t</tt></li>
<li>the <tt>type</tt> member of specializations of <tt>aligned_storage</tt></li>
<li>the <tt>type</tt> member of specializations of <tt>aligned_union</tt></li>
<li>the char-like objects used by <tt>basic_string</tt> and <tt>basic_string_view</tt>.</li>
</ul>
(Albeit the potential for breakage with <tt>max_align_t</tt> is admittedly small.)
</p>

<p><i>[
2017-11-14 Moved to Tentatively Ready after 8 positive votes for P0 on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4700">N4700</a> +
<a href="http://wg21.link/p0767r1">P0767R1</a>.
</p>
<ol>
<li><p>Change in 21.2.4 <a href="https://timsong-cpp.github.io/cppwp/support.types.layout">[support.types.layout]</a> paragraph 5:</p>
<p>
The type <tt>max_align_t</tt> is a trivial <ins>standard-layout</ins> type whose
alignment requirement is at least as great as that of every scalar type, and whose
alignment requirement is supported in every context (6.11 <a href="https://timsong-cpp.github.io/cppwp/basic.align">[basic.align]</a>).
</p>
</li>
<li><p>Change the table in 23.15.7.6 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a> as indicated:</p>
<p>
<tt>aligned_storage</tt><br/>
The member typedef <tt>type</tt> shall be a trivial <ins>standard-layout</ins>
type suitable for use as uninitialized storage for any object whose size is at
most <tt>Len</tt> and whose alignment is a divisor of <tt>Align</tt>.
</p>
<p>
<tt>aligned_union</tt><br/>
The member typedef <tt>type</tt> shall be a trivial <ins>standard-layout</ins>
type suitable for use as uninitialized storage for any object whose type is listed
in <tt>Types</tt>; its size shall be at least <tt>Len</tt>.
</p>
</li>
<li><p>Change 24.1 <a href="https://timsong-cpp.github.io/cppwp/strings.general">[strings.general]</a> paragraph 1 as indicated:</p>
<p>
This Clause describes components for manipulating sequences of any non-array
trivial <ins>standard-layout</ins> (6.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>) type. Such types
are called char-like types, and objects of char-like types are called char-like
objects or simply characters.
</p>
</li>
</ol>





</body>
</html>
