<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2020-04-06 at 18:09:50 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Jonathan Wakely &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="2820" href="2820">2820.</a> Clarify <tt>&lt;cstdint&gt;</tt> macros</h3>
<p><b>Section:</b> 17.4 <a href="https://timsong-cpp.github.io/cppwp/cstdint">[cstdint]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2016-11-12 <b>Last modified:</b> 2020-02-22 11:45:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint">issues</a> in [cstdint].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I would like clarification from LWG regarding the various limit macros like <tt>INT_8_MIN</tt> in <tt>&lt;cstdint&gt;</tt>, 
in pursuit of editorial cleanup of this header's synopsis. I have two questions:
</p>
<ol>
<li><p>At present, macros like <tt>INT_8_MIN</tt> that correspond to the optional type <tt>int8_t</tt> are required 
(unconditionally), whereas the underlying type to which they appertain is only optional. Is this deliberate? 
Should the macros also be optional?</p></li>
<li><p>Is it deliberate that C++ only specifies sized aliases for the sizes 8, 16, 32 and 64, whereas the corresponding 
C header allows type aliases and macros for arbitrary sizes for implementations that choose to provide extended integer 
types? Is the C++ wording more restrictive by accident?</p></li>
</ol>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>C11 ties the macro names to the existence of the types. Marshall to research the second question.</p>
<p>Close <a href="2764">2764</a> as a duplicate of this issue.</p>

<p><i>[2017-03-18, Thomas comments and provides wording]</i></p>

<p>
This is as close as I can get to the C wording without resolving part (a) of the issue (whether we deliberately don't 
allow sized type aliases for sizes other than 8, 16, 32, 64, a departure from C). Once we resolve part (a), we need 
to revisit <tt>&lt;cinttypes&gt;</tt> and fix up the synopsis (perhaps to get rid of <tt>N</tt>) and add similar 
wording as the one below to make the formatting macros for the fixed-width types optional. For historical interest,
this issue is related to LWG <a href="553">553</a> and LWG <a href="841">841</a>.
</p>

<p><i>[2016-07, Toronto Saturday afternoon issues processing]</i></p>

<p>Status to Open</p>

<strong>Previous resolution: [SUPERSEDED]</strong>

<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Append the following content to 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a> p2:</p>

<blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<ins>In particular, for each of the fixed-width types (<tt>int8_t</tt>, <tt>int16_t</tt>, <tt>int32_t</tt>, 
<tt>int64_t</tt>, <tt>uint8_t</tt>, <tt>uint16_t</tt>, <tt>uint32_t</tt>, <tt>uint64_t</tt>) the type alias and 
the corresponding limit macros are defined if and only if the implementation provides the corresponding type.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-10-21, Thomas K&ouml;ppe provides improved wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
<p>This wording is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>
</p>

<ol>
<li><p>Change 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, header <tt>&lt;cstdint&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
using int64_t = <i>signed integer type</i>; <i>// optional</i>
<ins>using int<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_fast64_t = <i>signed integer type</i>;
<ins>using int_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_least64_t = <i>signed integer type</i>;
<ins>using int_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint64_t = <i>unsigned integer type</i>; <i>// optional</i>
<ins>using uint<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_fast64_t = <i>unsigned integer type</i>;
<ins>using uint_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_least64_t = <i>unsigned integer type</i>;
<ins>using uint_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>

using uintmax_t = <i>unsigned integer type</i>;
using uintptr_t = <i>unsigned integer type</i>; <i>// optional</i>

<ins>#define INT_<i>N</i>_MIN  <i>see below</i>;
#define INT_<i>N</i>_MAX  <i>see below</i>;
#define UINT_<i>N</i>_MAX  <i>see below</i>;

#define INT_FAST<i>N</i>_MIN  <i>see below</i>;
#define INT_FAST<i>N</i>_MAX  <i>see below</i>;
#define UINT_FAST<i>N</i>_MAX  <i>see below</i>;

#define INT_LEAST<i>N</i>_MIN  <i>see below</i>;
#define INT_LEAST<i>N</i>_MAX  <i>see below</i>;
#define UINT_LEAST<i>N</i>_MAX  <i>see below</i>;

#define INTMAX_MIN  <i>see below</i>;
#define INTMAX_MAX  <i>see below</i>;
#define UINTMAX_MAX  <i>see below</i>;

#define INTPTR_MIN  <i>see below</i>;
#define INTPTR_MAX  <i>see below</i>;
#define UINTPTR_MAX  <i>see below</i>;

#define PTRDIFF_MIN  <i>see below</i>;
#define PTRDIFF_MAX  <i>see below</i>;
#define SIZE_MAX  <i>see below</i>;

#define SIGATOMIC_MIN  <i>see below</i>;
#define SIGATOMIC_MAX  <i>see below</i>;

#define WCHAR_MIN  <i>see below</i>;
#define WCHAR_MAX  <i>see below</i>;

#define WINT_MIN  <i>see below</i>;
#define WINT_MAX  <i>see below</i>;

#define INT<i>N</i>_C(value)  <i>see below</i>;
#define UINT<i>N</i>_C(value)  <i>see below</i>;
#define INTMAX_C(value)  <i>see below</i>;
#define UINTMAX_C(value)  <i>see below</i>;</ins>
</pre>
<p>
<del>-1- The header also defines numerous macros of the form:</del>
</p>
<blockquote><pre>
<del>INT_[FAST LEAST]{8 16 32 64}_MIN
[U]INT_[FAST LEAST]{8 16 32 64}_MAX
INT{MAX PTR}_MIN
[U]INT{MAX PTR}_MAX
{PTRDIFF SIG_ATOMIC WCHAR WINT}{_MAX _MIN}
SIZE_MAX</del>
</pre></blockquote>
<p>
<del>plus function macros of the form:</del>
</p>
<blockquote><pre>
<del>[U]INT{8 16 32 64 MAX}_C</del>
</pre></blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<span style="font-variant: small-caps;">See also</span>: ISO C 7.20
<p/>
<ins>-?- In particular, all types that use the placeholder <tt><i>N</i></tt> are optional when <tt><i>N</i></tt> is not 8, 
16, 32 or 64. The exact-width types <tt>int<i>N</i>_t</tt> and <tt>uint<i>N</i>_t</tt> for <tt><i>N</i></tt> = 8, 16, 32, 64 
are also optional; however, if an implementation provides integer types with the corresponding width, no padding bits, and 
(for the signed types) that have a two's complement representation, it defines the corresponding typedef names. Only 
those macros are defined that correspond to typedef names that the implementation actually provides. [<i>Note:</i> The macros 
<tt>INT<i>N</i>_C</tt> and <tt>UINT<i>N</i>_C</tt> correspond to the typedef names <tt>int_least<i>N</i>_t</tt> and 
<tt>uint_least<i>N</i>_t</tt>, respectively. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li><p>Change 29.12.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a> as indicated:</p>

<blockquote><pre>
#define PRId<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIX<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNd<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
[&hellip;]
</pre>
<p>
-1- The contents and meaning of the header <tt>&lt;cinttypes&gt;</tt> [&hellip;]
<p/>
<ins>-?- In particular, macros that use the placeholder <tt><i>N</i></tt> are defined if and only if the implementation 
actually provides the corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, and moreover, the <tt>fscanf</tt> macros 
are provided unless the implementation does not have a suitable <tt>fscanf</tt> length modifier for the type.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-04-03; Geoffrey Romer suggests improved wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li><p>Change 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, header <tt>&lt;cstdint&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
using int64_t = <i>signed integer type</i>; <i>// optional</i>
<ins>using int<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_fast64_t = <i>signed integer type</i>;
<ins>using int_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_least64_t = <i>signed integer type</i>;
<ins>using int_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint64_t = <i>unsigned integer type</i>; <i>// optional</i>
<ins>using uint<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_fast64_t = <i>unsigned integer type</i>;
<ins>using uint_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_least64_t = <i>unsigned integer type</i>;
<ins>using uint_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>

using uintmax_t = <i>unsigned integer type</i>;
using uintptr_t = <i>unsigned integer type</i>; <i>// optional</i>

<ins>#define INT_<i>N</i>_MIN  <i>see below</i>;
#define INT_<i>N</i>_MAX  <i>see below</i>;
#define UINT_<i>N</i>_MAX  <i>see below</i>;

#define INT_FAST<i>N</i>_MIN  <i>see below</i>;
#define INT_FAST<i>N</i>_MAX  <i>see below</i>;
#define UINT_FAST<i>N</i>_MAX  <i>see below</i>;

#define INT_LEAST<i>N</i>_MIN  <i>see below</i>;
#define INT_LEAST<i>N</i>_MAX  <i>see below</i>;
#define UINT_LEAST<i>N</i>_MAX  <i>see below</i>;

#define INTMAX_MIN  <i>see below</i>;
#define INTMAX_MAX  <i>see below</i>;
#define UINTMAX_MAX  <i>see below</i>;

#define INTPTR_MIN  <i>see below</i>;
#define INTPTR_MAX  <i>see below</i>;
#define UINTPTR_MAX  <i>see below</i>;

#define PTRDIFF_MIN  <i>see below</i>;
#define PTRDIFF_MAX  <i>see below</i>;
#define SIZE_MAX  <i>see below</i>;

#define SIGATOMIC_MIN  <i>see below</i>;
#define SIGATOMIC_MAX  <i>see below</i>;

#define WCHAR_MIN  <i>see below</i>;
#define WCHAR_MAX  <i>see below</i>;

#define WINT_MIN  <i>see below</i>;
#define WINT_MAX  <i>see below</i>;

#define INT<i>N</i>_C(value)  <i>see below</i>;
#define UINT<i>N</i>_C(value)  <i>see below</i>;
#define INTMAX_C(value)  <i>see below</i>;
#define UINTMAX_C(value)  <i>see below</i>;</ins>
</pre>
<p>
<del>-1- The header also defines numerous macros of the form:</del>
</p>
<blockquote><pre>
<del>INT_[FAST LEAST]{8 16 32 64}_MIN
[U]INT_[FAST LEAST]{8 16 32 64}_MAX
INT{MAX PTR}_MIN
[U]INT{MAX PTR}_MAX
{PTRDIFF SIG_ATOMIC WCHAR WINT}{_MAX _MIN}
SIZE_MAX</del>
</pre></blockquote>
<p>
<del>plus function macros of the form:</del>
</p>
<blockquote><pre>
<del>[U]INT{8 16 32 64 MAX}_C</del>
</pre></blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<span style="font-variant: small-caps;">See also</span>: ISO C 7.20
<p/>
<ins>-?- In particular, all types that use the placeholder <tt><i>N</i></tt> are optional when <tt><i>N</i></tt> is not 8, 
16, 32 or 64. The exact-width types <tt>int<i>N</i>_t</tt> and <tt>uint<i>N</i>_t</tt> for <tt><i>N</i></tt> = 8, 16, 32, 64 
are also optional; however, if an implementation provides integer types with the corresponding width, no padding bits, and 
(for the signed types) that have a two's complement representation, it defines the corresponding typedef names. Only 
those macros are defined that correspond to typedef names that the implementation actually provides. [<i>Note:</i> The macros 
<tt>INT<i>N</i>_C</tt> and <tt>UINT<i>N</i>_C</tt> correspond to the typedef names <tt>int_least<i>N</i>_t</tt> and 
<tt>uint_least<i>N</i>_t</tt>, respectively. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li><p>Change 29.12.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a> as indicated:</p>

<blockquote><pre>
#define PRId<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIX<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNd<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
[&hellip;]
</pre>
<p>
-1- The contents and meaning of the header <tt>&lt;cinttypes&gt;</tt> [&hellip;]
<p/>
<ins>-?- <tt>PRI</tt> macros that use the placeholder <tt><i>N</i></tt> are defined if and only if the implementation actually 
provides the corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>. <tt>SCN</tt> macros that use the placeholder 
<tt><i>N</i></tt> are defined if and only if the implementation actually provides the corresponding typedef name 
and the implementation has a suitable <tt>fscanf</tt> length modifier for the type.</ins>
</p>
</blockquote>
</li>
</ol></blockquote>

<p><i>[2019-03-11; Reflector review and improved wording]</i></p>

<p>
Wording simplifications due to new general two's complement requirements of integer types; removal of wording
redundancies and applying some typo fixes in macro names.
</p>

<p><i>[2019-03-16; Daniel comments and updates wording]</i></p>

<p>
Hubert Tong pointed out that we do not have a statement about <tt>[U]INTPTR_{MIN|MAX}</tt> being optional.
Interestingly, the C11 Standard does not say directly that the <tt>[U]INTPTR_{MIN|MAX}</tt> macros are optional,
but this follows indirectly from the fact that <tt>intptr_t</tt> and <tt>uintptr_t</tt> are indeed optional. 
The updated wording therefore realizes Hubert's suggestion.
<p/>
In addition, the reference document has been rebased to <a href="http://wg21.link/n4810">N4810</a>, because
that draft version contains an <a href="https://github.com/cplusplus/draft/pull/2638">editorial change</a>, 
which renames the term "range exponent" of integer types to "width", which is the vocabulary used below and
also matches C's use.
<p/>
Finally, Hubert Tong suggested the following rewording replacements of
</p>
<blockquote><p>
If and only if the implementation defines such a typedef name, it also defines the corresponding macros.
</p></blockquote>
<p>
to:
</p>
<blockquote><p>
Each of the macros listed in this subclause is defined if and only if the implementation defines the corresponding typedef name.
</p></blockquote>
<p>
and of
</p>
<blockquote><p>
<tt>PRI</tt> macros that use the placeholder N are defined if and only if the implementation actually defines the 
corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>. <tt>SCN</tt> macros that use the placeholder <tt><i>N</i></tt> 
are defined if and only if the implementation actually defines the corresponding typedef name and the implementation 
has a suitable <tt>fscanf</tt> length modifier for the type.
</p></blockquote>
<p>
to:
</p>
<blockquote><p>
Each of the macros listed in this subclause is defined if and only if the implementation actually defines the corresponding 
typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>.
</p></blockquote>
<p>
Those changes have been applied as well.
</p>

<p><i>[2019-03-26; Reflector discussion and minor wording update]</i></p>

<p>
Geoffrey pointed out that the revised wording has the effect that it requires an implementation to define <tt>SCN</tt>
macros for all mentioned typedefs, but the C11 standard says "the corresponding <tt>fscanf</tt> macros shall be
defined unless the implementation does not have a suitable <tt>fscanf</tt> length modifier for the type.". An additional 
wording update repairs this problem below.
</p>

<p><i>[2020-02-22; Reflector discussion]</i></p>

<p>
Status set to Tentatively Ready after seven positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.
</p>

<ol>
<li><p>Change 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, header <tt>&lt;cstdint&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
using int64_t = <i>signed integer type</i>; <i>// optional</i>
<ins>using int<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_fast64_t = <i>signed integer type</i>;
<ins>using int_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_least64_t = <i>signed integer type</i>;
<ins>using int_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint64_t = <i>unsigned integer type</i>; <i>// optional</i>
<ins>using uint<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_fast64_t = <i>unsigned integer type</i>;
<ins>using uint_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_least64_t = <i>unsigned integer type</i>;
<ins>using uint_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>

using uintmax_t = <i>unsigned integer type</i>;
using uintptr_t = <i>unsigned integer type</i>; <i>// optional</i>

<ins>#define INT<i>N</i>_MIN  <i>see below</i>
#define INT<i>N</i>_MAX  <i>see below</i>
#define UINT<i>N</i>_MAX  <i>see below</i>

#define INT_FAST<i>N</i>_MIN  <i>see below</i>
#define INT_FAST<i>N</i>_MAX  <i>see below</i>
#define UINT_FAST<i>N</i>_MAX  <i>see below</i>

#define INT_LEAST<i>N</i>_MIN  <i>see below</i>
#define INT_LEAST<i>N</i>_MAX  <i>see below</i>
#define UINT_LEAST<i>N</i>_MAX  <i>see below</i>

#define INTMAX_MIN  <i>see below</i>
#define INTMAX_MAX  <i>see below</i>
#define UINTMAX_MAX  <i>see below</i>

#define INTPTR_MIN  <i>optional, see below</i>
#define INTPTR_MAX  <i>optional, see below</i>
#define UINTPTR_MAX  <i>optional, see below</i>

#define PTRDIFF_MIN  <i>see below</i>
#define PTRDIFF_MAX  <i>see below</i>
#define SIZE_MAX  <i>see below</i>

#define SIG_ATOMIC_MIN  <i>see below</i>
#define SIG_ATOMIC_MAX  <i>see below</i>

#define WCHAR_MIN  <i>see below</i>
#define WCHAR_MAX  <i>see below</i>

#define WINT_MIN  <i>see below</i>
#define WINT_MAX  <i>see below</i>

#define INT<i>N</i>_C(value)  <i>see below</i>
#define UINT<i>N</i>_C(value)  <i>see below</i>
#define INTMAX_C(value)  <i>see below</i>
#define UINTMAX_C(value)  <i>see below</i></ins>
</pre>
<p>
<del>-1- The header also defines numerous macros of the form:</del>
</p>
<blockquote><pre>
<del>INT_[FAST LEAST]{8 16 32 64}_MIN
[U]INT_[FAST LEAST]{8 16 32 64}_MAX
INT{MAX PTR}_MIN
[U]INT{MAX PTR}_MAX
{PTRDIFF SIG_ATOMIC WCHAR WINT}{_MAX _MIN}
SIZE_MAX</del>
</pre></blockquote>
<p>
<del>plus function macros of the form:</del>
</p>
<blockquote><pre>
<del>[U]INT{8 16 32 64 MAX}_C</del>
</pre></blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<span style="font-variant: small-caps;">See also</span>: ISO C 7.20
<p/>
<ins>-?- All types that use the placeholder <tt><i>N</i></tt> are optional when <tt><i>N</i></tt> is not 8, 
16, 32 or 64. The exact-width types <tt>int<i>N</i>_t</tt> and <tt>uint<i>N</i>_t</tt> for <tt><i>N</i></tt> = 8, 16, 32, 64 
are also optional; however, if an implementation defines integer types with the corresponding width and no padding bits, 
it defines the corresponding typedef names. Each of the macros listed in this subclause is defined if and only if 
the implementation defines the corresponding typedef name. [<i>Note:</i> The macros <tt>INT<i>N</i>_C</tt> and 
<tt>UINT<i>N</i>_C</tt> correspond to the typedef names <tt>int_least<i>N</i>_t</tt> and <tt>uint_least<i>N</i>_t</tt>, 
respectively. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li><p>Change 29.12.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a> as indicated:</p>

<blockquote><pre>
#define PRId<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIX<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNd<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
[&hellip;]
</pre>
<p>
-1- The contents and meaning of the header <tt>&lt;cinttypes&gt;</tt> [&hellip;]
<p/>
<ins>-?- Each of the <tt>PRI</tt> macros listed in this subclause is defined if and only if the implementation defines the 
corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>. Each of the <tt>SCN</tt> macros listed in this subclause is 
defined if and only if the implementation defines the corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a> and
has a suitable <tt>fscanf</tt> length modifier for the type.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3117" href="3117">3117.</a> Missing <tt>packaged_task</tt> deduction guides</h3>
<p><b>Section:</b> 32.9.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Marc Mutz <b>Opened:</b> 2018-06-08 <b>Last modified:</b> 2020-02-14 15:01:42 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task">issues</a> in [futures.task].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::function</tt> has deduction guides, but <tt>std::packaged_task</tt>, which is otherwise very
similar, does not. This is surprising to users and I can think of no reason for the former
to be treated differently from the latter. I therefore propose to add deduction guides for
packaged task with the same semantics as the existing ones for function.
</p>

<p><i>[2018-06-23 after reflector discussion]</i></p>

<p>Priority set to 3</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.</p>

<ol>
<li><p>Modify 32.9.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a>, class template <tt>packaged_task</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
    [&hellip;]
  };
  
  <ins>template&lt;class R, class... ArgTypes&gt;
  packaged_task(R (*)( ArgTypes ...)) -&gt; packaged_task&lt;R( ArgTypes...)&gt;;

  template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;</ins>
  
  template&lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y) noexcept;
}
</pre>
</blockquote>
</li>

<li><p>Modify 32.9.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class F&gt;
  packaged_task(F&amp;&amp; f);
</pre>
[&hellip;]
<pre>
<ins>template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> This deduction guide participates in overload resolution only if <tt>&amp;F::operator()</tt> 
is well-formed when treated as an unevaluated operand. In that case, if <tt>decltype(&amp;F::operator())</tt> is of the 
form <tt>R(G::*)(A...) <i>cv</i> &amp;<sub><i>opt</i></sub> noexcept<sub><i>opt</i></sub></tt> for a class type <tt>G</tt>, 
then the deduced type is <tt>packaged_task&lt;R(A...)&gt;</tt>.</ins>
</p>
</blockquote>
[&hellip;]
<pre>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-02-13; Prague]</i></p>

<p>
LWG improves wording matching Marshall's Mandating paper.
</p>

<p><i>[2020-02-14; Prague]</i></p>

<p>
Do we want a feature test macro for this new feature?
</p>
<blockquote><pre>
F N A
1 7 6
</pre></blockquote>

<p><i>[Status to Ready on Friday in Prague.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 32.9.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a>, class template <tt>packaged_task</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
    [&hellip;]
  };
  
  <ins>template&lt;class R, class... ArgTypes&gt;
  packaged_task(R (*)(ArgTypes...)) -&gt; packaged_task&lt;R(ArgTypes...)&gt;;

  template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;</ins>
  
  template&lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y) noexcept;
}
</pre>
</blockquote>
</li>

<li><p>Modify 32.9.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class F&gt;
  packaged_task(F&amp;&amp; f);
</pre>
[&hellip;]
<pre>
<ins>template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>&amp;F::operator()</tt> is well-formed when treated as an unevaluated operand 
and <tt>decltype(&amp;F::operator())</tt> is of the form <tt>R(G::*)(A...) <i>cv</i> &amp;<sub><i>opt</i></sub> 
noexcept<sub><i>opt</i></sub></tt> for a class type <tt>G</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> The deduced type is <tt>packaged_task&lt;R(A...)&gt;</tt>.</ins>
</p>
</blockquote>
[&hellip;]
<pre>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3211" href="3211">3211.</a> <tt>std::tuple&lt;&gt;</tt> should be trivially constructible</h3>
<p><b>Section:</b> 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Louis Dionne <b>Opened:</b> 2019-05-29 <b>Last modified:</b> 2020-02-13 12:51:34 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
That requirement is really easy to enforce, and it has been requested by users (e.g. 
<a href="https://bugs.llvm.org/show_bug.cgi?id=41714">libc++ bug 41714</a>).
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<p>
-4- If <tt>is_trivially_destructible_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all 
<tt>T<sub><i>i</i></sub></tt>, then the destructor of <tt>tuple</tt> is trivial. 
<ins>The default constructor of <tt>tuple&lt;&gt;</tt> is trivial.</ins>
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2020-02-13, Prague]</i></p>

<p>
LWG discussion revealed that all where happy that we want this, except that the new wording should become 
a separate paragraph.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<p>
-4- If <tt>is_trivially_destructible_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all 
<tt>T<sub><i>i</i></sub></tt>, then the destructor of <tt>tuple</tt> is trivial. 
<p/>
<ins>-?- The default constructor of <tt>tuple&lt;&gt;</tt> is trivial.</ins>
</p>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3236" href="3236">3236.</a> Random access iterator requirements lack limiting relational operators domain to comparing 
those from the same range</h3>
<p><b>Section:</b> 23.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2019-07-15 <b>Last modified:</b> 2020-02-13 12:32:11 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For forward iterators we have very clear wording regarding the restricted domain of <tt>operator==</tt>
in 23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> p2:
</p>
<blockquote><p>
The domain of <tt>==</tt> for forward iterators is that of iterators over the same underlying sequence. 
However, value-initialized iterators may be compared and shall compare equal to other value-initialized 
iterators of the same type. [<i>Note:</i> Value-initialized iterators behave as if they refer past the 
end of the same empty sequence. &mdash; <i>end note</i>]
</p></blockquote>
<p>
But for the relational operators of random access iterators specified in 
23.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>, Table  [tab:randomaccessiterator],
no such domain constraints are clearly defined, except that we can infer that they are
similarly constrained as the difference of the compared iterators by means of the
operational semantics of <tt>operator&lt;</tt>.
</p>

<p><i>[2019-07-29; Casey comments and provides wording]</i></p>

<p>
Change the "Operational Semantics" column of the "<tt>a &lt; b</tt>" row of [tab:randomaccessiterator] to 
"<ins><i>Effects:</i> Equivalent to: <tt>return</tt></ins> <tt>b - a &gt; 0</tt><ins>;</ins>
<p/>
It then follows that <tt>a &lt; b</tt> is required to be well-defined over the domain for which 
<tt>b - a</tt> is required to be well-defined, which is the set of pairs <tt>(x, y)</tt> such that 
there exists a value <tt>n</tt> of type difference_type such that <tt>x + n == b</tt>.
</p>

<p><i>[2020-02-13, Prague]</i></p>

<p>
P3, but some hesitation to make it Immediate, therefore moving to Ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 23.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a> as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 87: <i>Cpp17RandomAccessIterator</i> requirements (in addition to 
<i>Cpp17BidirectionalIterator</i>) [tab:randomaccessiterator]</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
contextually convertible to <tt>bool</tt>
</td>
<td>
<ins><i>Effects:</i> Equivalent to: <tt>return</tt></ins> <tt>b - a &gt; 0<ins>;</ins></tt>
</td>
<td>
<tt>&lt;</tt> is a total ordering relation
</td>
</tr>

</table>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3249" href="3249">3249.</a> There are no 'pointers' in &sect;[atomics.lockfree]</h3>
<p><b>Section:</b> 31.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2019-08-03 <b>Last modified:</b> 2020-02-13 12:32:11 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.lockfree">issues</a> in [atomics.lockfree].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to SG1 experts, the requirement in [atomics.lockfree]/2 is intended to require that 
the answer for <tt>is_lock_free()</tt> be the same for a given <tt>T</tt> for a given run of 
the program. The wording does not achieve that because it's described in terms of 'pointers', 
but there are no pointers in an <tt>atomic&lt;int&gt;</tt>.
</p>

<p><i>[2020-02 Status to Ready on Thursday morning in Prague.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 31.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> as indicated:</p>

<blockquote>
<p>
-2- The function<ins>s <tt>atomic&lt;T&gt;::is_lock_free</tt>, and</ins> <tt>atomic_is_lock_free</tt> 
(31.8.1 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a>) indicate<del>s</del> whether the object is lock-free. In any given program execution, the result of the lock-free query <ins>is the same for all atomic objects</ins> <del>shall 
be consistent for all pointers</del> of the same type.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3368" href="3368">3368.</a> Exactly when does <tt>size</tt> return <tt>end - begin</tt>?</h3>
<p><b>Section:</b> 24.3.9 <a href="https://timsong-cpp.github.io/cppwp/range.prim.size">[range.prim.size]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-01-07 <b>Last modified:</b> 2020-01-25 12:29:23 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>ranges::size</tt> in 24.3.9 <a href="https://timsong-cpp.github.io/cppwp/range.prim.size">[range.prim.size]</a> suggests that bullet 1.3 
("Otherwise, <tt><i>make-unsigned-like</i>(ranges::end(E) - ranges::begin(E)) ...")</tt> only applies 
when <tt>disable_sized_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> is <tt>true</tt>. This is not the 
design intent, but the result of an erroneous attempt to factor out the common 
"<tt>disable_sized_range</tt> is <tt>false</tt>" requirement from the member and non-member <tt>size</tt> 
cases in bullets 1.2.1 and 1.2.2 that occurred between <a href="http://wg21.link/p0896r3">P0896R3</a> and 
<a href="http://wg21.link/p0896r4">P0896R4</a>. The intended design has always been that a range with 
member or non-member <tt>size</tt> with the same syntax but different semantics may opt-out of being 
sized by specializing <tt>disable_sized_range</tt>. It has never been intended that arrays or ranges 
whose iterator and sentinel model <tt>sized_sentinel_for</tt> be able to opt out of being sized via 
<tt>disable_sized_range</tt>. <tt>disable_sized_sentinel_for</tt> can/must be used to opt out in the 
latter case so that library functions oblivious to the range type that operate on the iterator and 
sentinel of such a range will avoid subtraction.
</p>

<p><i>[2020-01-25 Status set to Tentatively Ready after six positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4842">N4842</a>.</p>

<ol>
<li><p>Modify 24.3.9 <a href="https://timsong-cpp.github.io/cppwp/range.prim.size">[range.prim.size]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> There are drive-by changes here to (1) avoid introducing unused type placeholders, 
(2) avoid reusing "<tt>T</tt>" as both the type of the subexpression and the template parameter of the 
poison pill, and (3) fix the cross-reference for <tt><i>make-unsigned-like</i></tt> which is defined in 
[ranges.syn]/1, not in [range.subrange].]
</p>
</blockquote>

<blockquote>
<p>
-1- The name <tt>size</tt> denotes a customization point object (16.4.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a>). 
The expression <tt>ranges::size(E)</tt> for some subexpression <tt>E</tt> with type <tt>T</tt> is 
expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <tt><i>decay-copy</i>(extent_v&lt;T&gt;)</tt> if <tt>T</tt> is an array type 
(6.8.2 <a href="https://timsong-cpp.github.io/cppwp/basic.compound">[basic.compound]</a>).</p></li>
<li><p><del>(1.2) &mdash; Otherwise, if <tt>disable_sized_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> 
(24.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>) is <tt>false</tt>:</del></p>
<li><p>(1.<ins>?</ins><del>2.1</del>) &mdash; <ins>Otherwise, if 
<tt>disable_sized_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> (24.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>) is <tt>false</tt> 
and</ins> <tt><i>decay-copy</i>(E.size())</tt> <del>if it</del> is a valid expression <del>and its 
type <tt>I</tt> is</del><ins>of</ins> integer-like <ins>type</ins> 
(23.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>)<ins>, <tt><i>decay-copy</i>(E.size())</tt></ins>.</p></li>
<li><p>(1.<ins>?</ins><del>2.2</del>) &mdash; Otherwise, <ins>if 
<tt>disable_sized_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> is <tt>false</tt> and</ins>
<tt><i>decay-copy</i>(size(E))</tt> <del>if it</del> is a valid expression <del>and its type 
<tt>I</tt> is</del><ins>of</ins> integer-like <ins>type</ins> with overload resolution performed in a 
context that includes the declaration:
<blockquote><pre>
<del>template&lt;class T&gt;</del> void size(<del>T</del><ins>auto</ins>&amp;&amp;) = delete;
</pre></blockquote>
and does not include a declaration of <tt>ranges::size</tt><ins>, <tt><i>decay-copy</i>(size(E))</tt></ins>.</p></li>
</li>
<li><p>(1.3) &mdash; Otherwise, <tt><i>make-unsigned-like</i>(ranges::end(E) - ranges::begin(E))</tt> 
(<del>24.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a></del><ins>24.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a></ins>) if it is a valid 
expression and the types <tt>I</tt> and <tt>S</tt> of 
<tt>ranges::begin(E)</tt> and <tt>ranges::end(E)</tt> (respectively) model both
<tt>sized_sentinel_for&lt;S, I&gt;</tt> (23.3.4.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.sizedsentinel">[iterator.concept.sizedsentinel]</a>) and 
<tt>forward_iterator&lt;I&gt;</tt>. However, <tt>E</tt> is evaluated only once.
</p></li>
<li><p>(1.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="3404" href="3404">3404.</a> Finish removing <tt>subrange</tt>'s conversions from <tt><i>pair-like</i></tt></h3>
<p><b>Section:</b> 24.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-02-20 <b>Last modified:</b> 2020-03-11 18:44:26 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.subrange">issues</a> in [range.subrange].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both LWG <a href="3281">3281</a> "Conversion from <tt><i>pair-like</i></tt> types to <tt>subrange</tt> is a 
silent semantic promotion" and LWG <a href="3282">3282</a> "<tt>subrange</tt> converting constructor should 
disallow derived to base conversions" removed <tt>subrange</tt>'s hated implicit conversions from 
<tt><i>pair-like</i></tt> types. Notably, neither issue removed the two "<tt><i>iterator-sentinel-pair</i></tt>" 
deduction guides which target the removed constructors nor the exposition-only <tt><i>iterator-sentinel-pair</i></tt> 
concept itself, all of which are now useless.
</p>

<p><i>[2020-03-11 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after seven positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.
</p>

<ol>
<li><p>Modify 24.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a> as indicated:</p>

<blockquote><pre>
[&hellip;]
template&lt;class T, class U, class V&gt;
  concept <i>pair-like-convertible-from</i> = <i>// exposition only</i>
    !range&lt;T&gt; &amp;&amp; <i>pair-like</i>&lt;T&gt; &amp;&amp; constructible_from&lt;T, U, V&gt;;

<del>template&lt;class T&gt;
  concept <i>iterator-sentinel-pair</i> = <i>// exposition only</i>
    !range&lt;T&gt; &amp;&amp; <i>pair-like</i>&lt;T&gt; &amp;&amp;
    sentinel_for&lt;tuple_element_t&lt;1, T&gt;, tuple_element_t&lt;0, T&gt;&gt;;</del>
    
[&hellip;]

<del>template&lt;<i>iterator-sentinel-pair</i> P&gt;
  subrange(P) -&gt; subrange&lt;tuple_element_t&lt;0, P&gt;, tuple_element_t&lt;1, P&gt;&gt;;</del>

<del>template&lt;<i>iterator-sentinel-pair</i> P&gt;
  subrange(P, <i>make-unsigned-like-t</i>(iter_difference_t&lt;tuple_element_t&lt;0, P&gt;&gt;)) -&gt;
    subrange&lt;uple_element_t&lt;0, P&gt;, tuple_element_t&lt;1, P&gt;, subrange_kind::sized&gt;;</del>
[&hellip;]
</pre></blockquote>
</li>
</ol>




<hr>
<h3><a name="3405" href="3405">3405.</a> <tt>common_view</tt>'s converting constructor is bad, too</h3>
<p><b>Section:</b> 24.7.13.2 <a href="https://timsong-cpp.github.io/cppwp/range.common.view">[range.common.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-02-20 <b>Last modified:</b> 2020-03-11 18:50:30 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3280">3280</a> struck the problematic/extraneous converting constructor templates from the 
<tt><i>meow</i>_view</tt> range adaptor types in the standard library with the exception of <tt>common_view</tt>. 
The omission of <tt>common_view</tt> seems to have been simply an oversight: its converting constructor 
template is no less problematic or extraneous. We should remove <tt>common_view</tt>'s converting 
constructor template as well to finish the task. Both <tt>cmcstl2</tt> and <tt>range-v3</tt> removed 
the converting constructor template from <tt>common_view</tt> when removing the other converting 
constructor templates, so we have implementation experience that this change is good as well as 
consistent with the general thrust of LWG <a href="3280">3280</a>.
</p>

<p><i>[2020-03-11 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after seven positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.
</p>

<ol>
<li><p>Modify 24.7.13.2 <a href="https://timsong-cpp.github.io/cppwp/range.common.view">[range.common.view]</a>, class template <tt>common_view</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
  
  [&hellip;]
  constexpr explicit common_view(V r);
  
  <del>template&lt;viewable_range R&gt;
    requires (!common_range&lt;R&gt; &amp;&amp; constructible_from&lt;V, all_view&lt;R&gt;&gt;)
  constexpr explicit common_view(R&amp;&amp; r);</del>
  
  constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
  [&hellip;]
  
</pre>
[&hellip;]
<pre>
<del>template&lt;viewable_range R&gt;
  requires (!common_range&lt;R&gt; &amp;&amp; constructible_from&lt;V, all_view&lt;R&gt;&gt;)
constexpr explicit common_view(R&amp;&amp; r);</del>
</pre>
<blockquote>
<p>
<del>-2- <i>Effects:</i> Initializes <tt>base_</tt> with <tt>views::all(std::forward&lt;R&gt;(r))</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3419" href="3419">3419.</a> &sect;[algorithms.requirements]/15 doesn't reserve as many rights as it intends to</h3>
<p><b>Section:</b> 25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2020-03-24 <b>Last modified:</b> 2020-04-04 18:49:27 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms.requirements">active issues</a> in [algorithms.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms.requirements">issues</a> in [algorithms.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>/15 says:
</p>
<blockquote><p>
"The number and order of deducible template parameters for algorithm declarations are unspecified, except 
where explicitly stated otherwise. [<i>Note:</i> Consequently, the algorithms may not be called with 
explicitly-specified template argument lists. &mdash; <i>end note</i>]"
</p></blockquote>
<p>
But the note doesn't follow from the normative rule. For example, we felt the need to explicitly allow 
deduction for <tt>min</tt>'s template parameter:
</p>
<blockquote><pre>
template&lt;typename T&gt; const T&amp; min(const T&amp;, const T&amp;);
</pre></blockquote>
<p>
&hellip; but if only the order and number of <em>deducible</em> template parameters is permitted to vary, 
then because of the required deduction behavior of this function template, there are only three possible 
valid declarations:
</p>
<blockquote><pre>
template&lt;typename T&gt; ??? min(const T&amp;, const T&amp;);
template&lt;typename T, typename U&gt; ??? min(const T&amp;, const U&amp;);
template&lt;typename T, typename U&gt; ??? min(const U&amp;, const T&amp;);
</pre></blockquote>
<p>
(up to minor differences in the parameter type). This doesn't prohibit calls with an explicitly-specified 
template argument list, contrary to the claim in the note. (Indeed, because a call such as <tt>min(1, {})</tt> 
is valid, either the first of the above three overloads must be present or there must be a default template 
argument <tt>typename U = T</tt>, which further adds to the fact that there may be valid calls with an 
explicitly-specified template argument list.)
<p/>
Also, the "explicitly stated otherwise" cases use phrasing such as: "An invocation may explicitly specify 
an argument for the template parameter <tt>T</tt> of the overloads in namespace <tt>std</tt>." which 
doesn't "specify otherwise" the normative rule, but does "specify otherwise" the claim in the note.
<p/>
All this leads me to believe that [algorithms.requirements]/15 is backwards: the normative rule should be a 
note and the note should be the normative rule.
</p>

<p><i>[2020-04-04 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after six positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wiki.edg.com/pub/Wg21summer2020/Documents/post-prague-wd.pdf">the 
post-Prague working draft preview</a>.
</p>

<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> as indicated:</p>

<blockquote>
<p>
-15- The <ins>well-formedness and behavior of a call to an algorithm with an explicitly-specified template 
argument list is</ins><del>number and order of deducible template parameters for algorithm declarations are</del> 
unspecified, except where explicitly stated otherwise. [<i>Note:</i> Consequently, <ins>an implementation can 
declare an algorithm with different template parameters than those presented</ins><del>the algorithms may not be 
called with explicitly-specified template argument lists</del>. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3420" href="3420">3420.</a> <tt><i>cpp17-iterator</i></tt> should check that the type looks like an iterator first</h3>
<p><b>Section:</b> 23.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2020-02-29 <b>Last modified:</b> 2020-04-04 18:43:37 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.traits">active issues</a> in [iterator.traits].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.traits">issues</a> in [iterator.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is common in pre-C++20 code to rely on SFINAE-friendly <tt>iterator_traits</tt> 
to rule out non-iterators in template constraints (<tt>std::filesystem::path</tt> 
is one example in the standard library).
<p/>
C++20 changed <tt>iterator_traits</tt> to automatically detect its members in
some cases, and this detection can cause constraint recursion. LWG <a href="3244">3244</a> 
tries to fix this for <tt>path</tt> by short-circuiting the check when the source type is 
<tt>path</tt> itself, but this isn't sufficient:
</p>
<blockquote><pre>
struct Foo 
{
  Foo(const std::filesystem::path&amp;);
};

static_assert(std::copyable&lt;Foo&gt;);
</pre></blockquote>
<p>
Here the copyability determination will ask whether a <tt>path</tt> can be
constructed from a <tt>Foo</tt>, which asks whether <tt>Foo</tt> is an iterator, which
checks whether <tt>Foo</tt> is <tt>copyable</tt> [&hellip;].
<p/>
To reduce the risk of constraint recursion, we should change <tt><i>cpp17-iterator</i></tt> 
so that it does not ask about copyability until the type is known to resemble an iterator.
</p>

<p><i>[2020-04-04 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after six positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wiki.edg.com/pub/Wg21summer2020/Documents/post-prague-wd.pdf">the 
post-Prague working draft preview</a>.
</p>

<ol>
<li><p>Modify 23.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> as indicated:</p>

<blockquote>
<p>
-2- The definitions in this subclause make use of the following exposition-only concepts:
</p>
<blockquote>
<pre>
template&lt;class I&gt;
concept <i>cpp17-iterator</i> =
  <del>copyable&lt;I&gt; &amp;&amp;</del> requires(I i) {
    { *i } -&gt; <i>can-reference</i>;
    { ++i } -&gt; same_as&lt;I&amp;&gt;;
    { *i++ } -&gt; <i>can-reference</i>;
  } <ins>&amp;&amp; copyable&lt;I&gt;</ins>;
  
[&hellip;]
</pre>
</blockquote>
</blockquote>
</li>
</ol>




</body>
</html>
