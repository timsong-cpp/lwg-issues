<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2022-09-27 at 14:59:18 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Jonathan Wakely &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="3028" href="3028">3028.</a> Container requirements tables should distinguish <tt>const</tt> and non-<tt>const</tt> variables</h3>
<p><b>Section:</b> 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-10-17 <b>Last modified:</b> 2022-09-05 13:01:24 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[container.requirements.general] p4 says:
</p>
<blockquote>
<p>
In Tables 83, 84, and 85 <tt>X</tt> denotes a container class containing
objects of type <tt>T</tt>, <tt>a</tt> and <tt>b</tt> denote values of type <tt>X</tt>, <tt>u</tt> denotes an
identifier, <tt>r</tt> denotes a non-<tt>const</tt> value of type <tt>X</tt>, and <tt>rv</tt> denotes a
non-<tt>const</tt> rvalue of type <tt>X</tt>.
</p>
</blockquote>
<p>
This doesn't say anything about whether <tt>a</tt> and <tt>b</tt> are allowed to be
<tt>const</tt>, or must be non-<tt>const</tt>. In fact Table 83 uses them
inconsistently, e.g. the rows for "<tt>a = rv</tt>" and "<tt>a.swap(b)</tt>" most
certainly require them to be non-<tt>const</tt>, but all other uses are valid
for either <tt>const</tt> or non-<tt>const X</tt>.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 3; Jonathan to provide updated wording.</p>
<p>Wording needs adjustment - could use "possibly const values of type X"</p>
<p>Will distinguish between lvalue/rvalue </p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Change 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p4 as indicated:</p>

<blockquote>
<p>
-4- In Tables 83, 84, and 85 <tt>X</tt> denotes a container class containing objects of type <tt>T</tt>, 
<tt>a</tt> and <tt>b</tt> denote values of type <tt>X</tt>, <tt>u</tt> denotes an identifier, <tt>r</tt> 
<ins>and s</ins> denote<del>s a</del> non-<tt>const</tt> value<ins>s</ins> of type <tt>X</tt>, and 
<tt>rv</tt> denotes a non-<tt>const</tt> rvalue of type <tt>X</tt>.
</p>
</blockquote>
</li>

<li><p>Change 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, Table 83 "Container requirements", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 83 &mdash; Container requirements</caption>
<tr style="text-align:center">
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion/note<br/>pre/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td colspan="5" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>r</ins> = rv</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
All existing elements<br/>
of <tt><del>a</del><ins>r</ins></tt> are either move<br/>
assigned to or<br/>
destroyed
</td>
<td>
<tt><del>a</del><ins>r</ins></tt> shall be equal to<br/>
the value that <tt>rv</tt> had<br/>
before this<br/>
assignment
</td>
<td>
linear
</td>
</tr>
<tr>
<td colspan="5" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>r</ins>.swap(<del>b</del><ins>s</ins>)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
</td>
<td>
exchanges the<br/>
contents of <tt><del>a</del><ins>r</ins></tt> and <tt><del>b</del><ins>s</ins></tt>
</td>
<td>
(Note A)
</td>
</tr>
<tr>
<td colspan="5" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>swap(<del>a</del><ins>r</ins>, <del>b</del><ins>s</ins>)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt><del>a</del><ins>r</ins>.swap(<del>b</del><ins>s</ins>)</tt>
</td>
<td>
</td>
<td>
(Note A)
</td>
</tr>
</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-05-03; Daniel provides alternative wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li><p>Change 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> as indicated:</p>

<blockquote class="note"><p>
[<i>Drafting note:</i>
</p>
<ul>
<li><p>The following presentation also transforms the current list 
into a bullet list as we already have in 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p11</p></li>
<li><p>It has been decided to replace the symbol <tt>r</tt> by <tt>s</tt>, because it is
easy to confuse with <tt>rv</tt> but means an lvalue instead, and the other container
tables use it rarely and for something completely different (iterator value)</p></li>
<li><p>A separate symbol <tt>v</tt> is introduced to unambigiously distinguish the
counterpart of a non-<tt>const</tt> rvalue (See 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a>)</p></li>
<li><p>Two separate symbols <tt>b</tt> and <tt>c</tt> represent now "(possibly <tt>const</tt>)
values, while the existing symbol <tt>a</tt> represents an unspecified value, whose
meaning becomes defined when context is provided, e.g. for overloads like <tt>begin()</tt>
and <tt>end</tt></p></li>
</ul>
</blockquote>

<blockquote>
<p>
-4- In Tables 73, 74, and 75<ins>:</ins> 
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <tt>X</tt> denotes a container class containing objects of type <tt>T</tt>,</p></li>
<li><p>(4.2) &mdash; <tt>a</tt> <del>and <tt>b</tt></del> denote<ins>s a</ins> value<del>s</del> of type <tt>X</tt>,</p></li>
<li><p><ins>(4.2) &mdash; <tt>b</tt> and <tt>c</tt> denote (possibly <tt>const</tt>) values of type <tt>X</tt>,</ins></p></li>
<li><p>(4.3) &mdash; <tt>i</tt> and <tt>j</tt> denote values of type (possibly <tt>const</tt>) <tt>X::iterator</tt>,</p></li>
<li><p>(4.4) &mdash; <tt>u</tt> denotes an identifier,</p></li>
<li><p><ins>(?.?) &mdash; <tt>v</tt> denotes an lvalue of type (possibly <tt>const</tt>) <tt>X</tt> or an
rvalue of type <tt>const X</tt>,</ins></p></li>
<li><p>(4.5) &mdash; <del><tt>r</tt></del><ins><tt>s</tt> and <tt>t</tt></ins> denote<del>s a</del> non-<tt>const</tt> 
<del>value</del><ins>lvalues</ins> of type <tt>X</tt>, and</p></li>
<li><p>(4.6) &mdash; <tt>rv</tt> denotes a non-<tt>const</tt> rvalue of type <tt>X</tt>.</p></li>
</ol>
</blockquote>
</li>

<li><p>Change 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, Table 73 "Container requirements" [tab:container.req], 
as indicated:</p>

<blockquote class="note"><p>
[<i>Drafting note:</i> The following presentation also moves the copy-assignment expression just before
the move-assignment expression]
</p></blockquote>

<blockquote>
<table border="1">
<caption>Table 73: &mdash; Container requirements [tab:container.req]</caption>
<tr style="text-align:center">
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion/note<br/>pre/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td colspan="5" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>X(<del>a</del><ins>v</ins>)</tt>
</td>
<td>
</td>
<td>
</td>
<td>
<i>Preconditions:</i> <tt>T</tt> is <i>Cpp17CopyInsertable</i><br/>
into <tt>X</tt> (see below).<br/>
<i>Postconditions:</i> <tt><del>a</del><ins>v</ins> == X(<del>a</del><ins>v</ins>)</tt>.
</td>
<td>
linear
</td>
</tr>
<tr>
<td>
<tt>X u(<del>a</del><ins>v</ins>);<br/>
X u = <del>a</del><ins>v</ins>;</tt>
</td>
<td>
</td>
<td>
</td>
<td>
<i>Preconditions:</i> <tt>T</tt> is <i>Cpp17CopyInsertable</i><br/>
into <tt>X</tt> (see below).<br/>
<i>Postconditions:</i> <tt>u == <del>a</del><ins>v</ins></tt>.
</td>
<td>
linear
</td>
</tr>
<tr>
<td>
<tt>X u(rv);<br/>
X u = rv;</tt>
</td>
<td>
</td>
<td>
</td>
<td>
<i>Postconditions:</i> <tt>u</tt> is equal to the value<br/>
that <tt>rv</tt> had before this construction
</td>
<td>
(Note B)
</td>
</tr>
<tr>
<td>
<ins><tt>t = v</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
</td>
<td>
<ins><i>Postconditions:</i> <tt>t == v</tt>.</ins>
</td>
<td>
<ins>linear</ins>
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>t</ins> = rv</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
All existing elements<br/>
of <tt><del>a</del><ins>t</ins></tt> are either move<br/>
assigned to or<br/>
destroyed
</td>
<td>
<tt><del>a</del><ins>t</ins></tt> shall be equal to<br/>
the value that <tt>rv</tt> had<br/>
before this<br/>
assignment
</td>
<td>
linear
</td>
</tr>
<tr>
<td colspan="5" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>c</ins> == b</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
<tt>==</tt> is an equivalence relation.<br/>
<tt>equal(<del>a</del><ins>c</ins>.begin(),<br/>
<del>a</del><ins>c</ins>.end(),<br/>
b.begin(),<br/>
b.end())</tt>
</td>
<td>
<i>Preconditions:</i> <tt>T</tt> meets the<br/> 
<i>Cpp17EqualityComparable</i> requirements
</td>
<td>
Constant if <tt><del>a</del><ins>c</ins>.size() != b.size()</tt>,<br/>
linear otherwise
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>c</ins> != b</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
Equivalent to <tt>!(<del>a</del><ins>c</ins> == b)</tt>
</td>
<td>
</td>
<td>
linear
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>t</ins>.swap(<del>b</del><ins>s</ins>)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
</td>
<td>
exchanges the<br/>
contents of <tt><del>a</del><ins>t</ins></tt> and <tt><del>b</del><ins>s</ins></tt>
</td>
<td>
(Note A)
</td>
</tr>
<tr>
<td>
<tt>swap(<del>a</del><ins>t</ins>, <del>b</del><ins>s</ins>)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt><del>a</del><ins>t</ins>.swap(<del>b</del><ins>s</ins>)</tt>
</td>
<td>
</td>
<td>
(Note A)
</td>
</tr>
<tr>
<td>
<del><tt>r = a</tt></del>
</td>
<td>
<del><tt>X&amp;</tt></del>
</td>
<td>
</td>
<td>
<del><i>Postconditions:</i> <tt>r == a</tt>.</del>
</td>
<td>
<del>linear</del>
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>c</ins>.size()</tt>
</td>
<td>
<tt>size_type</tt>
</td>
<td>
<tt>distance(<del>a</del><ins>c</ins>.begin(), <del>a</del><ins>c</ins>.end())</tt>
</td>
<td>
</td>
<td>
constant
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>c</ins>.max_size()</tt>
</td>
<td>
<tt>size_type</tt>
</td>
<td>
<tt>distance(begin(), end())</tt> for the largest<br/>
possible container
</td>
<td>
</td>
<td>
constant
</td>
</tr>
<tr>
<td>
<tt><del>a</del><ins>c</ins>.empty()</tt>
</td>
<td>
convertible to <tt>bool</tt>
</td>
<td>
<tt><del>a</del><ins>c</ins>.begin() == <del>a</del><ins>c</ins>.end()</tt>
</td>
<td>
</td>
<td>
constant
</td>
</tr>
</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-04-20; Jonathan rebases the wording on the latest draft]</i></p>



<p><i>[2022-09-05; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll in April 2022.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4910">N4910</a>.</p>

<ol>
<li><p>Change 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> as indicated:</p>

<blockquote class="note"><p>
[<i>Drafting note:</i>
</p>
<ul>
<li><p>It has been decided to replace the symbol <tt>r</tt> by <tt>s</tt>, because it is
easy to confuse with <tt>rv</tt> but means an lvalue instead, and the other container
tables use it rarely and for something completely different (iterator value)</p></li>
<li><p>A separate symbol <tt>v</tt> is introduced to unambigiously distinguish the
counterpart of a non-<tt>const</tt> rvalue (See 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a>)</p></li>
<li><p>Two separate symbols <tt>b</tt> and <tt>c</tt> represent now "(possibly <tt>const</tt>)
values, while the existing symbol <tt>a</tt> represents an unspecified value, whose
meaning becomes defined when context is provided, e.g. for overloads like <tt>begin()</tt>
and <tt>end</tt></p></li>
</ul>
</blockquote>

<blockquote>
<p>
-1- In subclause 24.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.gen.reqmts">[container.gen.reqmts]</a>,
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <tt>X</tt> denotes a container class containing objects of type <tt>T</tt>,</p></li>
<li><p>(1.2) &mdash; <tt>a</tt> <del>and <tt>b</tt> denote values</del> <ins>denotes a value</ins> of type <tt>X</tt>,</p></li>
<li><p><ins>(?.?) &mdash; <tt>b</tt> and <tt>c</tt> denote values of type (possibly <tt>const</tt>) <tt>X</tt>,</ins></p></li>
<li><p>(1.3) &mdash; <tt>i</tt> and <tt>j</tt> denote values of type (possibly <tt>const</tt>) <tt>X::iterator</tt>,</p></li>
<li><p>(1.4) &mdash; <tt>u</tt> denotes an identifier,</p></li>
<li><p><ins>(?.?) &mdash; <tt>v</tt> denotes an lvalue of type (possibly <tt>const</tt>) <tt>X</tt> or an
rvalue of type <tt>const X</tt>,</ins></p></li>
<li><p>(1.5) &mdash; <del><tt>r</tt> denotes a</del><ins><tt>s</tt> and <tt>t</tt> denote</ins> non-<tt>const</tt> 
<del>value</del><ins>lvalues</ins> of type <tt>X</tt>, and</p></li>
<li><p>(1.6) &mdash; <tt>rv</tt> denotes a non-<tt>const</tt> rvalue of type <tt>X</tt>.</p></li>
</ol>
</blockquote>
</li>

<li><p>Change 24.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a> as indicated:</p>

<blockquote class="note"><p>
[<i>Drafting note:</i> The following presentation also moves the copy-assignment expression just before
the move-assignment expression]
</p></blockquote>

<blockquote>
<pre>
  X u(<del>a</del><ins>v</ins>);
  X u = <del>a</del><ins>v</ins>;
</pre>
<p>-12- <i>Preconditions:</i>
<tt>T</tt> is <i>Cpp17CopyInsertable</i> into <tt>X</tt> (see below).
</p>
<p>-13- <i>Postconditions:</i>
<tt>u == <del>a</del><ins>v</ins></tt>.
</p>
<p>-14- <i>Complexity:</i> Linear.  </p>


<pre>
  X u(rv);
  X u = rv;
</pre>
<p>-15- <i>Postconditions:</i>
<tt>u</tt> is equal to the value
that <tt>rv</tt> had before this construction.
</p>
<p>-14- <i>Complexity:</i>
Linear for <tt>array</tt> and constant for all other standard containers.
</p>

<pre>
  <ins>t = v</ins>
</pre>
<p><ins>-?- <i>Result:</i> <tt>X&amp;</tt>.</ins> </p>
<p><ins>-?- <i>Postconditions:</i> <tt>t == v</tt>.</ins> </p>
<p><ins>-?- <i>Complexity:</i> Linear.</ins>  </p>

<pre>
  <del>a</del><ins>t</ins> = rv
</pre>
<p>-17- <i>Result:</i> <tt>X&amp;</tt>. </p>
<p>-18- <i>Effects:</i>
All existing elements of
<tt><del>a</del><ins>t</ins></tt>
are either move assigned to or destroyed.
</p>
<p>-19- <i>Postconditions:</i>
<tt><del>a</del><ins>t</ins></tt>
shall be equal to the value that <tt>rv</tt> had
before this assignment.
</p>
<p>-20- <i>Complexity:</i> Linear.  </p>

<p>[&hellip;]</p>

<pre>
  <del>a</del><ins>b</ins>.begin()
</pre>
<p>-24- <i>Result:</i> <tt>iterator</tt>; <tt>const_iterator</tt> for constant <del>a</del><ins>b</ins>. </p>
<p>-25- <i>Returns:</i>
An iterator referring to the first element in the container.
</p>
<p>-26- <i>Complexity:</i> Constant. </p>

<pre>
  <del>a</del><ins>b</ins>.end()
</pre>
<p>-27- <i>Result:</i> <tt>iterator</tt>; <tt>const_iterator</tt> for constant <del>a</del><ins>b</ins>. </p>
<p>-28- <i>Returns:</i>
An iterator which is the past-the-end value for the container.
</p>
<p>-29- <i>Complexity:</i> Constant. </p>

<pre>
  <del>a</del><ins>b</ins>.cbegin()
</pre>
<p>-30- <i>Result:</i> <tt>const_iterator</tt>. </p>
<p>-31- <i>Returns:</i>
<tt>const_cast&lt;X const&amp;>(<del>a</del><ins>b</ins>).begin()</tt>
</p>
<p>-32- <i>Complexity:</i> Constant. </p>

<pre>
  <del>a</del><ins>b</ins>.cend()
</pre>
<p>-33- <i>Result:</i> <tt>const_iterator</tt>. </p>
<p>-34- <i>Returns:</i>
<tt>const_cast&lt;X const&amp;>(<del>a</del><ins>b</ins>).end()</tt>
</p>
<p>-35- <i>Complexity:</i> Constant. </p>



<p>[&hellip;]</p>

<pre>
  <del>a</del><ins>c</ins> == b
</pre>
<p>-39- <i>Preconditions:</i>
<tt>T</tt> meets the <i>Cpp17EqualityComparable</i> requirements.
</p>
<p>-40- <i>Result:</i> Convertible to <tt>bool</tt>. </p>
<p>-41- <i>Returns:</i>
<tt>equal(<del>a</del><ins>c</ins>.begin(),
<del>a</del><ins>c</ins>.end(),
b.begin(),
b.end())</tt>.
</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; [<i>Note 1:</i>
The algorithm <tt>equal</tt> is defined in 27.6.13 <a href="https://timsong-cpp.github.io/cppwp/alg.equal">[alg.equal]</a>.
<i>&mdash; end note</i>] </p>
<p>-42- <i>Complexity:</i>
Constant if <tt><del>a</del><ins>c</ins>.size() != b.size()</tt>,
linear otherwise.
</p>
<p>-43- <i>Remarks:</i>
<tt>==</tt> is an equivalence relation.</p>

<pre>
  <del>a</del><ins>c</ins> != b
</pre>
<p>-44- <i>Effects:</i> Equivalent to <tt>!(<del>a</del><ins>c</ins> == b)</tt>. </p>

<pre>
  <del>a</del><ins>t</ins>.swap(<del>b</del><ins>s</ins>)
</pre>
<p>-45- <i>Result:</i> <tt>void</tt>. </p>
<p>-46- <i>Effects:</i>
Exchanges the contents of
<tt><del>a</del><ins>t</ins></tt> and <tt><del>b</del><ins>s</ins></tt>.
</p>
<p>-47- <i>Complexity:</i>
Linear for <tt>array</tt> and constant for all other standard containers.
</p>

<pre>
  swap(<del>a</del><ins>t</ins>, <del>b</del><ins>s</ins>)
</pre>
<p>-48- <i>Effects:</i> Equivalent to
<tt><del>a</del><ins>t</ins>.swap(<del>b</del><ins>s</ins>)</tt>
</p>

<pre>
  <del>r = a</del>
</pre>
<p><del>-49- <i>Result:</i> <tt>X&amp;</tt>.</del> </p>
<p><del>-50- <i>Postconditions:</i> <tt>r == a</tt>.</del> </p>
<p><del>-51- <i>Complexity:</i> Linear.</del> </p>

<pre>
  <del>a</del><ins>c</ins>.size()
</pre>
<p>-52- <i>Result:</i> <tt>size_type</tt>. </p>
<p>-53- <i>Returns:</i>
<tt>distance(<del>a</del><ins>c</ins>.begin(), <del>a</del><ins>c</ins>.end())</tt>,
i.e. the number of elements in the container.
</p>
<p>-54- <i>Complexity:</i> Constant. </p>
<p>-55- <i>Remarks:</i>
The number of elements is defined by the rules of constructors, inserts, and erases.
</p>

<pre>
  <del>a</del><ins>c</ins>.max_size()
</pre>
<p>-56- <i>Result:</i> <tt>size_type</tt>. </p>
<p>-57- <i>Returns:</i>
<tt>distance(begin(), end())</tt> for the largest possible container.
</p>
<p>-58- <i>Complexity:</i> Constant. </p>

<pre>
  <del>a</del><ins>c</ins>.empty()
</pre>
<p>-59- <i>Result:</i> Convertible to <tt>bool</tt>. </p>
<p>-60- <i>Returns:</i>
<tt><del>a</del><ins>c</ins>.begin() == <del>a</del><ins>c</ins>.end())</tt>
</p>
<p>-61- <i>Complexity:</i> Constant. </p>
<p>-62- <i>Remarks:</i>
If the container is empty, then
<tt><del>a</del><ins>c</ins>.empty()</tt>
is <tt>true</tt>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3594" href="3594">3594.</a> <tt>inout_ptr</tt> &mdash; inconsistent <tt>release()</tt> in destructor</h3>
<p><b>Section:</b> 20.3.4.3 <a href="https://timsong-cpp.github.io/cppwp/inout.ptr.t">[inout.ptr.t]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> JeanHeyd Meneide <b>Opened:</b> 2021-09-16 <b>Last modified:</b> 2022-08-24 18:51:03 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
More succinctly, the model for <tt>std::out_ptr_t</tt> and <tt>std::inout_ptr_t</tt>
both have a conditional release in their destructors as part of their
specification (20.3.4.1 <a href="https://timsong-cpp.github.io/cppwp/out.ptr.t">[out.ptr.t]</a> p8) (Option #2 below).
But, if the wording is followed, they have an unconditional release in
their constructor (Option #1 below). This is not exactly correct and
can cause issues with double-free in <tt>inout_ptr</tt> in particular.
<p/>
Consider a function <tt>MyFunc</tt> that sets <tt>rawPtr</tt> to <tt>nullptr</tt> when freeing
an old value and deciding not to produce a new value, as shown below:
</p>
<blockquote><pre>
// Option #1:
auto uptr = std::make_unique&lt;BYTE[]&gt;(25);
auto rawPtr = uptr.get();
uptr.release(); // UNCONDITIONAL
MyFunc(&amp;rawPtr);
If (rawPtr)
{
  uptr.reset(rawPtr);
}

// Option #2:
auto uptr = std::make_unique&lt;BYTE[]&gt;(25);
auto rawPtr = uptr.get();
MyFunc(&amp;rawPtr);
If (rawPtr)
{
  uptr.release(); // CONDITIONAL
  uptr.reset(rawPtr);
}
</pre></blockquote>
<p>
This is no problem if the implementation selected Option #1 (release
in the constructor), but results in double-free if the implementation
selected option #2 (release in the destructor).
<p/>
As the paper author and after conferring with others, the intent was
that the behavior was identical and whether a choice between the
constructor or destructor is made. The reset should be unconditional,
at least for <tt>inout_ptr_t</tt>. Suggested change for the <tt>~inout_ptr_t</tt>
destructor text is to remove the "<tt>if (p) { ... }</tt>" wrapper from around
the code in 20.3.4.3 <a href="https://timsong-cpp.github.io/cppwp/inout.ptr.t">[inout.ptr.t]</a> p11.
</p>

<p><i>[2021-09-24; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 20.3.4.3 <a href="https://timsong-cpp.github.io/cppwp/inout.ptr.t">[inout.ptr.t]</a> as indicated:</p>

<blockquote>
<pre>
~inout_ptr_t();
</pre>
<blockquote>
<p>
-9- Let <tt>SP</tt> be <tt><i>POINTER_OF_OR</i>(Smart, Pointer)</tt> (20.2.1 <a href="https://timsong-cpp.github.io/cppwp/memory.general">[memory.general]</a>).
<p/>
-10- Let <tt><i>release-statement</i></tt> be <tt>s.release()</tt>; if an implementation does not call <tt>s.release()</tt> in the
constructor. Otherwise, it is empty.
<p/>
-11- <i>Effects:</i> Equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(11.1) &mdash; </p>
<blockquote><pre>
<del>if (p) {</del>
  apply([&amp;](auto&amp;&amp;... args) {
  s = Smart( static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...); }, std::move(a));
<del>}</del>
</pre></blockquote>
<p>
if <tt>is_pointer_v&lt;Smart&gt;</tt> is <tt>true</tt>;
</p></li>
<li><p>(11.2) &mdash; otherwise,</p>
<blockquote><pre>
<del>if (p) {</del>
  apply([&amp;](auto&amp;&amp;... args) {
  <i>release-statement</i>;
  s.reset(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...); }, std::move(a));
<del>}</del>
</pre></blockquote>
<p>
if the expression <tt>s.reset(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...)</tt> is well-formed;
</p>
</li>
<li><p>(11.3) &mdash; otherwise,</p>
<blockquote><pre>
<del>if (p) {</del>
  apply([&amp;](auto&amp;&amp;... args) {
  <i>release-statement</i>;
  s = Smart(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...); }, std::move(a));
<del>}</del>
</pre></blockquote>
<p>
if <tt>is_constructible_v&lt;Smart, SP, Args...&gt;</tt> is <tt>true</tt>;
</p>
</li>
<li><p>(11.4) &mdash; otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2021-10-28; JeanHeyd Meneide provides improved wording]</i></p>


<p><i>[2022-08-24 Approved unanimously in LWG telecon.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 20.3.4.3 <a href="https://timsong-cpp.github.io/cppwp/inout.ptr.t">[inout.ptr.t]</a> as indicated:</p>

<blockquote>
<pre>
~inout_ptr_t();
</pre>
<blockquote>
<p>
-9- Let <tt>SP</tt> be <tt><i>POINTER_OF_OR</i>(Smart, Pointer)</tt> (20.2.1 <a href="https://timsong-cpp.github.io/cppwp/memory.general">[memory.general]</a>).
<p/>
-10- Let <tt><i>release-statement</i></tt> be <tt>s.release()</tt>; if an implementation does not call <tt>s.release()</tt> in the
constructor. Otherwise, it is empty.
<p/>
-11- <i>Effects:</i> Equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(11.1) &mdash; </p>
<blockquote><pre>
if (p) {
  apply([&amp;](auto&amp;&amp;... args) {
  s = Smart( static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...); }, std::move(a));
}
</pre></blockquote>
<p>
if <tt>is_pointer_v&lt;Smart&gt;</tt> is <tt>true</tt>;
</p></li>
<li><p>(11.2) &mdash; otherwise,</p>
<blockquote><pre>
<ins><i>release-statement</i>;</ins>
if (p) {
  apply([&amp;](auto&amp;&amp;... args) {
  <del><i>release-statement</i>;</del>
  s.reset(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...); }, std::move(a));
}
</pre></blockquote>
<p>
if the expression <tt>s.reset(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...)</tt> is well-formed;
</p>
</li>
<li><p>(11.3) &mdash; otherwise,</p>
<blockquote><pre>
<ins><i>release-statement</i>;</ins>
if (p) {
  apply([&amp;](auto&amp;&amp;... args) {
  <del><i>release-statement</i>;</del>
  s = Smart(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...); }, std::move(a));
}
</pre></blockquote>
<p>
if <tt>is_constructible_v&lt;Smart, SP, Args...&gt;</tt> is <tt>true</tt>;
</p>
</li>
<li><p>(11.4) &mdash; otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3629" href="3629">3629.</a> <code>make_error_code</code> and <code>make_error_condition</code> are customization points</h3>
<p><b>Section:</b> 19.5 <a href="https://timsong-cpp.github.io/cppwp/syserr">[syserr]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-10-31 <b>Last modified:</b> 2022-09-23 15:42:06 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The rule in 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a> means that the calls to
<code>make_error_code</code> in 19.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.constructors">[syserr.errcode.constructors]</a>
and 19.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.modifiers">[syserr.errcode.modifiers]</a> are required to call
<code>std::make_error_code</code>,
which means program-defined error codes do not work.
The same applies to the <code>make_error_condition</code> calls in
19.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition.constructors">[syserr.errcondition.constructors]</a> and
19.5.5.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition.modifiers">[syserr.errcondition.modifiers]</a>.
</p>

<p>
They need to use ADL.
This is what all known implementations (including Boost.System) do.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4901">N4901</a>.
</p>

<ol>
<li><p>Modify 19.5.2 <a href="https://timsong-cpp.github.io/cppwp/system.error.syn">[system.error.syn]</a> as indicated:</p>

<blockquote>
<p>
-1-
The value of each <code>enum errc</code> constant shall be the same as the
value of the <code>&lt;cerrno&gt;</code> macro shown in the above synopsis.
Whether or not the <code>&lt;system_error&gt;</code> implementation exposes
the <code>&lt;cerrno&gt;</code> macros is unspecified.
</p>

<p>
<ins>
-?-
Invocations of <code>make_error_code</code> and
<code>make_error_condition</code> shown in subclause 19.5 <a href="https://timsong-cpp.github.io/cppwp/syserr">[syserr]</a>
select a function to call via overload resolution (12.2 <a href="https://timsong-cpp.github.io/cppwp/over.match">[over.match]</a>)
on a candidate set that includes the lookup set found by
argument dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>).
</ins>
</p>

<p>
-2-
The <code>is_error_code_enum</code> and <code>is_error_condition_enum</code>
templates may be specialized for program-defined types to indicate that such
types are eligible for <code>class error_code</code> and
<code>class error_condition</code> implicit conversions, respectively.
</p>

<p>
<ins>
<em>[Note 1:</em>
Conversions from such types are done by program-defined overloads of
<code>make_error_code</code> and <code>make_error_condition</code>,
found by ADL. <em>&mdash;end note]</em>
</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-08-25; Jonathan Wakely provides improved wording]</i></p>

<p>
Discussed in LWG telecon and decided on new direction:
<ul>
<li>Add <code>make_error_code</code> and <code>make_error_condition</code>
to 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a> as done for <code>swap</code>.
Describe form of lookup used for them.</li>
<li>Respecify <code>error_code</code> and <code>error_condition</code>
constructors in terms of "<i>Effects</i>: Equivalent to" so that the
requirements on program-defined overloads found by ADL are implied by those
effects.</li>
</ul>
</p>

<p><i>[2022-09-07; Jonathan Wakely revises wording]</i></p>


<p>
Discussed in LWG telecon. Decided to change "established as-if by performing
unqualified name lookup and argument-dependent lookup"
to simply "established as-if by performing argument-dependent lookup".
</p>
<p>
This resolves the question of whether <tt>std::make_error_code(errc)</tt>,
<tt>std::make_error_code(io_errc)</tt>, etc. should be visible to the
unqualified name lookup. This affects whether a program-defined type that
specializes <tt>is_error_code_enum</tt> but doesn't provide an overload of
<tt>make_error_code</tt> should find the overloads in namespace <tt>std</tt>
and consider them for overload resolution, via implicit conversion to
<tt>std::errc</tt>, <tt>std::io_errc</tt>, etc.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ul>
<li><p>Modify 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a> as indicated:</p>

<blockquote>
<p>-3-
Whenever an unqualified name other than <code>swap</code><ins>,
<code>make_error_code</code>, or <code>make_error_condition</code></ins>
is used in the specification of a declaration <code>D</code> in
17 <a href="https://timsong-cpp.github.io/cppwp/support">[support]</a> through 33 <a href="https://timsong-cpp.github.io/cppwp/thread">[thread]</a> or D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a>,
its meaning is established as-if by performing unqualified name lookup
(6.5.3 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.unqual">[basic.lookup.unqual]</a>) in the context of <code>D</code>.
</p>

<p>
[<i>Note 1</i>:
Argument-dependent lookup is not performed.
&mdash; <i>end note</i>]
</p>

<p>
Similarly, the meaning of a <i>qualified-id</i> is established as-if by
performing qualified name lookup (6.5.5 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.qual">[basic.lookup.qual]</a>)
in the context of <code>D</code>.
</p>

<p>
[<i>Example 1</i>:
The reference to <code>is_array_v</code> in the specification of
<code>std::to_array</code> (24.3.7.6 <a href="https://timsong-cpp.github.io/cppwp/array.creation">[array.creation]</a>)
refers to <code>::std::is_array_v</code>.
&mdash; <i>end example</i>]
</p>

<p>
[<i>Note 2</i>:
Operators in expressions (12.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/over.match.oper">[over.match.oper]</a>)
are not so constrained; see 16.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a>.
&mdash; <i>end note</i>]
</p>

<p>
The meaning of the unqualified name <code>swap</code> is established
in an overload resolution context for swappable values
(16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>).
<ins>
The meanings of the unqualified names
<code>make_error_code</code> and <code>make_error_condition</code>
are established as-if by performing
argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>).
</ins>
</p>

</blockquote>
</li>

<li><p>Modify 19.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.constructors">[syserr.errcode.constructors]</a> as indicated:</p>

<blockquote>
<pre>error_code() noexcept;</pre>
<p>
<del>
-1- <i>Postconditions</i>:
<code>val_ == 0</code> and <code>cat_ == &amp;system_category()</code>.
</del>
<br/>
<ins>
-1- <i>Effects</i>:
Initializes <code>val_</code> with <code>0</code>
and <code>cat_</code> with <code>&amp;system_category()</code>.
</ins>
</p>

<pre>error_code(int val, const error_category&amp; cat) noexcept;</pre>
<p>
<del>
-2- <i>Postconditions</i>:
<code>val_ == val</code> and <code>cat_ == &amp;cat</code>.
</del>
<br/>
<ins>
-2- <i>Effects</i>:
Initializes <code>val_</code> with <code>val</code>
and <code>cat_</code> with <code>&amp;cat</code>.
</ins>
</p>

<pre>template&lt;class ErrorCodeEnum&gt;
  error_code(ErrorCodeEnum e) noexcept;</pre>
<p>-3- <i>Constraints</i>:
<code>is_error_code_enum_v&lt;ErrorCodeEnum&gt;</code> is <code>true</code>.
</p>
<p>
<del>
-4- <i>Postconditions</i>:
<code>*this == make_error_code(e)</code>.
</del>
<br/>
<ins>
-4- <i>Effects</i>: Equivalent to:
</ins>
<blockquote><pre><ins>error_code ec = make_error_code(e);
assign(ec.value(), ec.category());
</ins></pre></blockquote>
</p>
</blockquote>
</li>

<li><p>Modify 19.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.modifiers">[syserr.errcode.modifiers]</a> as indicated:</p>

<blockquote>
<pre>template&lt;class ErrorCodeEnum&gt;
  error_code&amp; operator=(ErrorCodeEnum e) noexcept;</pre>
<p>-2- <i>Constraints</i>:
<code>is_error_code_enum_v&lt;ErrorCodeEnum&gt;</code> is <code>true</code>.
</p>
<p>
<del>
-3- <i>Postconditions</i>:
<code>*this == make_error_code(e)</code>.
</del>
<br/>
<ins>
-3- <i>Effects</i>: Equivalent to:
</ins>
<blockquote><pre><ins>error_code ec = make_error_code(e);
assign(ec.value(), ec.category());
</ins></pre></blockquote>
</p>
<p>
-4- <i>Returns</i>: <code>*this</code>.
</p>
</blockquote>

</li>

<li><p>Modify 19.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition.constructors">[syserr.errcondition.constructors]</a> as indicated:</p>

<blockquote>
<pre>error_condition() noexcept;</pre>
<p>
<del>
-1- <i>Postconditions</i>:
<code>val_ == 0</code> and <code>cat_ == &amp;generic_category()</code>.
</del>
<br/>
<ins>
-1- <i>Effects</i>:
Initializes <code>val_</code> with <code>0</code>
and <code>cat_</code> with <code>&amp;generic_category()</code>.
</ins>
</p>

<pre>error_condition(int val, const error_category&amp; cat) noexcept;</pre>
<p>
<del>
-2- <i>Postconditions</i>:
<code>val_ == val</code> and <code>cat_ == &amp;cat</code>.
</del>
<br/>
<ins>
-2- <i>Effects</i>:
Initializes <code>val_</code> with <code>val</code>
and <code>cat_</code> with <code>&amp;cat</code>.
</ins>
</p>

<pre>template&lt;class ErrorConditionEnum&gt;
  error_condition(ErrorConditionEnum e) noexcept;</pre>
<p>-3- <i>Constraints</i>:
<code>is_error_condition_enum_v&lt;ErrorConditionEnum&gt;</code> is <code>true</code>.
</p>
<p>
<del>
-4- <i>Postconditions</i>:
<code>*this == make_error_condition(e)</code>.
</del>
<br/>
<ins>
-4- <i>Effects</i>: Equivalent to:
</ins>
<blockquote><pre><ins>error_condition ec = make_error_condition(e);
assign(ec.value(), ec.category());
</ins></pre></blockquote>
</p>
</blockquote>
</li>

<li><p>Modify 19.5.5.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition.modifiers">[syserr.errcondition.modifiers]</a> as indicated:</p>

<blockquote>
<pre>template&lt;class ErrorConditionEnum&gt;
  error_condition&amp; operator=(ErrorConditionEnum e) noexcept;</pre>
<p>-2- <i>Constraints</i>:
<code>is_error_condition_enum_v&lt;ErrorConditionEnum&gt;</code> is <code>true</code>.
</p>
<p>
<del>
-3- <i>Postconditions</i>:
<code>*this == make_error_condition(e)</code>.
</del>
<br/>
<ins>
-3- <i>Effects</i>: Equivalent to:
</ins>
<blockquote><pre><ins>error_condition ec = make_error_condition(e);
assign(ec.value(), ec.category());
</ins></pre></blockquote>
</p>
<p>
-4- <i>Returns</i>: <code>*this</code>.
</p>
</blockquote>

</li>

</ul>






<hr>
<h3><a name="3636" href="3636">3636.</a> <tt>formatter&lt;T&gt;::format</tt> should be <tt>const</tt>-qualified</h3>
<p><b>Section:</b> 22.14.6.1 <a href="https://timsong-cpp.github.io/cppwp/formatter.requirements">[formatter.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2021-11-11 <b>Last modified:</b> 2022-08-24 18:56:41 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#formatter.requirements">active issues</a> in [formatter.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#formatter.requirements">issues</a> in [formatter.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="https://reviews.llvm.org/D112017">libc++ review</a>, we've noticed that we don't understand 
the implications of 22.14.6.1 <a href="https://timsong-cpp.github.io/cppwp/formatter.requirements">[formatter.requirements]</a> bullet 3.1 and Table [tab:formatter.basic]: 
(emphasize mine):
</p>
<blockquote>
<p>
(3.1) &mdash; <tt>f</tt> is a <b>value</b> of type <tt>F</tt>,
<p/>
[&hellip;]
<p/>
Table 70: <i>BasicFormatter</i> requirements [tab:formatter.basic]
<p/>
[&hellip;]
<p/>
<tt>f.parse(pc)</tt> [<em>must compile</em>] [&hellip;]
<p/>
<tt>f.format(u, fc)</tt> [<em>must compile</em>] [&hellip;]
</p>
</blockquote>
<p>
According to Victor Zverovich, his intent was that <tt>f.parse(pc)</tt> should modify the 
state of <tt>f</tt>, but <tt>f.format(u, fc)</tt> should merely read <tt>f</tt>'s state to 
support format string compilation where formatter objects are immutable and therefore the 
<tt>format</tt> function must be <tt>const</tt>-qualified. 
<p/>
That is, a typical formatter should look something like this (modulo errors introduced by me):
</p>
<blockquote>
<pre>
struct WidgetFormatter {
  auto parse(std::format_parse_context&amp;) -&gt; std::format_parse_context::iterator;
  auto format(const Widget&amp;, std::format_context&amp;) const -&gt; std::format_context::iterator;
};
</pre>
</blockquote>
<p>
However, this is not reflected in the wording, which treats <tt>parse</tt> and <tt>format</tt> symmetrically.
Also, there is at least one example that shows a non-const <tt>format</tt> method:
</p>
<blockquote>
<pre>
template&lt;&gt; struct std::formatter&lt;color&gt; : std::formatter&lt;const char*&gt; {
  auto format(color c, format_context&amp; ctx) {
    return formatter&lt;const char*&gt;::format(color_names[c], ctx);
  }
};
</pre>
</blockquote>
<p>
Victor writes:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Maybe we should [&hellip;] open an LWG issue clarifying that all standard formatters have a 
<tt>const</tt> format function.
</p>
</blockquote>
<p>
I'd like to be even more assertive: Let's open an LWG issue clarifying that all formatters must have a 
<tt>const</tt> format function!
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>

<p><i>[2022-08-24 Approved unanimously in LWG telecon.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>

<li><p>Modify 22.14.6.1 <a href="https://timsong-cpp.github.io/cppwp/formatter.requirements">[formatter.requirements]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> It might also be reasonable to do a drive-by clarification that when the Table 70 says 
"Stores the parsed format specifiers in <tt>*this</tt>," what it actually means is "Stores the parsed format 
specifiers in <tt>g</tt>." (But I don't think anyone's seriously confused by that wording.)
</p>
</blockquote>

<blockquote>
<p>
-3- Given character type <tt>charT</tt>, output iterator type <tt>Out</tt>, and formatting argument type <tt>T</tt>, 
in Table 70 and Table 71:
</p>
<ol style="list-style-type:none">
<li><p>(3.1) &mdash; <tt>f</tt> is a value of type <ins>(possibly <tt>const</tt>)</ins> <tt>F</tt>,</p></li>
<li><p><ins>(3.?) &mdash; <tt>g</tt> is an lvalue of type <tt>F</tt>,</ins></p></li>
<li><p>(3.2) &mdash; <tt>u</tt> is an lvalue of type <tt>T</tt>,</p></li>
<li><p>(3.3) &mdash; <tt>t</tt> is a value of a type convertible to (possibly <tt>const</tt>) <tt>T</tt>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 70: <i>Formatter</i> requirements [tab:formatter]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<tt><del>f</del><ins>g</ins>.parse(pc)</tt>
</td>
<td>
<tt>PC::iterator</tt>
</td>
<td>
[&hellip;]<br/>
Stores the parsed format specifiers in <tt>*this</tt> and
returns an iterator past the end of the parsed range.
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>
</table>
</blockquote>
</blockquote>

</li>

<li><p>Modify 22.14.6.3 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> as indicated:</p>

<blockquote>
<p>
-6- An enabled specialization <tt>formatter&lt;T, charT&gt;</tt> meets the <i>BasicFormatter</i> requirements 
(22.14.6.1 <a href="https://timsong-cpp.github.io/cppwp/formatter.requirements">[formatter.requirements]</a>).
<p/>
[<i>Example 1</i>:
</p>
<blockquote>
<pre>
#include &lt;format&gt;

enum color { red, green, blue };
const char* color_names[] = { "red", "green", "blue" };

template&lt;&gt; struct std::formatter&lt;color&gt; : std::formatter&lt;const char*&gt; {
  auto format(color c, format_context&amp; ctx) <ins>const</ins> {
    return formatter&lt;const char*&gt;::format(color_names[c], ctx);
  }
};

[&hellip;]
</pre>
</blockquote>
<p>
&mdash; <i>end example</i>]
</p>
</blockquote>
</li>

<li><p>Modify 22.14.6.6 <a href="https://timsong-cpp.github.io/cppwp/format.context">[format.context]</a> as indicated:</p>

<blockquote>
<pre>
void advance_to(iterator it);
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to: <tt>out_ = std::move(it);</tt>
<p/>
[<i>Example 1</i>:
</p>
<blockquote>
<pre>
struct S { int value; };

template&lt;&gt; struct std::formatter&lt;S&gt; {
  size_t width_arg_id = 0;
  
  <i>// Parses a width argument id in the format { digit }.</i>
  constexpr auto parse(format_parse_context&amp; ctx) {
    [&hellip;]
  }
  
  <i>// Formats an S with width given by the argument width_arg_id.</i>
  auto format(S s, format_context&amp; ctx) <ins>const</ins> {
    int width = visit_format_arg([](auto value) -&gt; int {
      if constexpr (!is_integral_v&lt;decltype(value)&gt;)
        throw format_error("width is not integral");
      else if (value &lt; 0 || value &gt; numeric_limits&lt;int&gt;::max())
        throw format_error("invalid width");
      else
        return value;
      }, ctx.arg(width_arg_id));
    return format_to(ctx.out(), "{0:x&lt;{1}}", s.value, width);
  }
};

[&hellip;]
</pre>
</blockquote>
<p>
&mdash; <i>end example</i>]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 29.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Duration, class charT&gt;
struct formatter&lt;chrono::<i>local-time-format-t</i>&lt;Duration&gt;, charT&gt;;
</pre>
<blockquote>
<p>
-15- Let <tt>f</tt> be [&hellip;]
<p/>
-16- <i>Remarks:</i> [&hellip;]
</p>
</blockquote>
<blockquote>
<pre>
template&lt;class Duration, class TimeZonePtr, class charT&gt;
struct formatter&lt;chrono::zoned_time&lt;Duration, TimeZonePtr&gt;, charT&gt;
  : formatter&lt;chrono::<i>local-time-format-t</i>&lt;Duration&gt;, charT&gt; {
  template&lt;class FormatContext&gt;
    typename FormatContext::iterator
      format(const chrono::zoned_time&lt;Duration, TimeZonePtr&gt;&amp; tp, FormatContext&amp; ctx) <ins>const</ins>;
};
</pre>
</blockquote>
<pre>
template&lt;class FormatContext&gt;
  typename FormatContext::iterator
    format(const chrono::zoned_time&lt;Duration, TimeZonePtr&gt;&amp; tp, FormatContext&amp; ctx) <ins>const</ins>;
</pre>
<blockquote>
<p>
-17- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
sys_info info = tp.get_info();
return formatter&lt;chrono::<i>local-time-format-t</i>&lt;Duration&gt;, charT&gt;::
         format({tp.get_local_time(), &amp;info.abbrev, &amp;info.offset}, ctx);
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3646" href="3646">3646.</a> <tt>std::ranges::view_interface::size</tt> returns a signed type</h3>
<p><b>Section:</b> 26.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/view.interface.general">[view.interface.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-11-29 <b>Last modified:</b> 2022-09-23 14:31:54 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#view.interface.general">active issues</a> in [view.interface.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#view.interface.general">issues</a> in [view.interface.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 26.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/view.interface.general">[view.interface.general]</a>, <tt>view_interface::size</tt> returns 
the difference between the sentinel and the beginning iterator, which always has a 
signed-integer-like type. However, IIUC the decision that a <tt>size</tt> member function 
should return an unsigned type by default was made when adopting <a href="https://wg21.link/P1227R2">P1227R2</a>, 
and the relative changes of the ranges library were done in <a href="https://wg21.link/P1523R1">P1523R1</a>. 
I don't know why <tt>view_interface::size</tt> was unchanged, while <tt>ranges::size</tt> 
returns an unsigned type in similar situations (26.3.10 <a href="https://timsong-cpp.github.io/cppwp/range.prim.size">[range.prim.size]</a> (2.5)).
<p/>
If we want to change <tt>views_interface::size</tt> to return an unsigned type, the both 
overloads should be changed as below:
</p>
<blockquote><pre>
constexpr auto size() requires forward_range&lt;D&gt; &amp;&amp;
  sized_sentinel_for&lt;sentinel_t&lt;D&gt;, iterator_t&lt;D&gt;&gt; {
    return <i>to-unsigned-like</i>(ranges::end(<i>derived</i>()) - ranges::begin(<i>derived</i>()));
  }
constexpr auto size() const requires forward_range&lt;const D&gt; &amp;&amp;
  sized_sentinel_for&lt;sentinel_t&lt;const D&gt;, iterator_t&lt;const D&gt;&gt; {
    return <i>to-unsigned-like</i>(ranges::end(<i>derived</i>()) - ranges::begin(<i>derived</i>()));
  }
</pre></blockquote>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2022-06-22; Reflector poll]</i></p>

<p>
LEWG poll approved the proposed resolution
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll in July 2022.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>

<li><p>Modify 26.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/view.interface.general">[view.interface.general]</a>, class template <tt>view_interface</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
constexpr auto size() requires forward_range&lt;D&gt; &amp;&amp;
  sized_sentinel_for&lt;sentinel_t&lt;D&gt;, iterator_t&lt;D&gt;&gt; {
    return <ins><i>to-unsigned-like</i>(</ins>ranges::end(<i>derived</i>()) - ranges::begin(<i>derived</i>())<ins>)</ins>;
  }
constexpr auto size() const requires forward_range&lt;const D&gt; &amp;&amp;
  sized_sentinel_for&lt;sentinel_t&lt;const D&gt;, iterator_t&lt;const D&gt;&gt; {
    return <ins><i>to-unsigned-like</i>(</ins>ranges::end(<i>derived</i>()) - ranges::begin(<i>derived</i>())<ins>)</ins>;
  }
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3732" href="3732">3732.</a> <tt>prepend_range</tt> and <tt>append_range</tt> can't be amortized constant time</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2022-07-06 <b>Last modified:</b> 2022-08-31 18:05:14 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>/69 says "An implementation shall implement them so as to take amortized constant time." 
followed by a list of operations that includes the newly added <tt>append_range</tt> and <tt>prepend_range</tt>. 
Obviously these operations cannot be implemented in amortized constant time.
<p/>
Because the actual complexity of these operations are already specified in the concrete container specification, 
we can just exclude them here.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>

<li><p>Modify 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote>
<p>
-69- The following operations are provided for some types of sequence containers but not others. <del>An implementation
shall implement them</del><ins>Operations other than <tt>prepend_range</tt> and <tt>append_range</tt> are implemented</ins> 
so as to take amortized constant time.
</p>
</blockquote>
</li>


</ol>





<hr>
<h3><a name="3736" href="3736">3736.</a> <tt>move_iterator</tt> missing <tt>disable_sized_sentinel_for</tt> specialization</h3>
<p><b>Section:</b> 25.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-07-14 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.synopsis">active issues</a> in [iterator.synopsis].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in [iterator.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since <tt>reverse_iterator::operator-</tt> is not constrained, the standard adds a 
<tt>disable_sized_sentinel_for</tt> specialization for it to avoid situations where the 
underlying iterator can be subtracted making <tt>reverse_iterator</tt> accidentally model 
<tt>sized_sentinel_for</tt>.
<p/>
However, given that <tt>move_iterator::operator-</tt> is also unconstrained and the standard 
does not have the <tt>disable_sized_sentinel_for</tt> specialization for it, this makes 
<tt>subrange&lt;move_iterator&lt;I&gt;, move_iterator&lt;I&gt;&gt;</tt> unexpectedly satisfy 
<tt>sized_range</tt> and incorrectly use <tt>I::operator-</tt> to get size when <tt>I</tt> 
can be subtracted but not modeled <tt>sized_sentinel_for&lt;I&gt;</tt>.
<p/>
In addition, since <a href="https://wg21.link/P2520">P2520</a> makes <tt>move_iterator</tt> no longer just <tt>input_iterator</tt>, 
<tt>ranges::size</tt> can get the size of the range by subtracting two <tt>move_iterator</tt> pairs,
this also makes <tt>r | views::as_rvalue</tt> may satisfy <tt>sized_range</tt> when neither <tt>r</tt> nor 
<tt>r | views::reverse</tt> is <tt>sized_range</tt>.
<p/>
We should add a <tt>move_iterator</tt> version of the <tt>disable_sized_sentinel_for</tt> 
specialization to the standard to avoid the above situation.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>
<p>
"but I don't think the issue text is quite right - both
<code>move_iterator</code> and <code>reverse_iterator</code>'s
<code>operator-</code> are constrained on <code>x.base() - y.base()</code>
being valid."
</p>
<p>
Does anyone remember why we did this for <code>reverse_iterator</code>
and not <code>move_iterator</code>?
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>

<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header <tt>&lt;iterator&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;class Iterator&gt;
    constexpr move_iterator&lt;Iterator&gt; make_move_iterator(Iterator i);

  <ins>template&lt;class Iterator1, class Iterator2&gt;
      requires (!sized_sentinel_for&lt;Iterator1, Iterator2&gt;)
    inline constexpr bool disable_sized_sentinel_for&lt;move_iterator&lt;Iterator1&gt;,
                                                     move_iterator&lt;Iterator2&gt;&gt; = true;</ins>

  [&hellip;]
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3738" href="3738">3738.</a> Missing preconditions for <tt>take_view</tt> constructor</h3>
<p><b>Section:</b> 26.7.10.2 <a href="https://timsong-cpp.github.io/cppwp/range.take.view">[range.take.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-07-15 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.take.view">issues</a> in [range.take.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <tt>V</tt> does not model <tt>sized_range</tt>, <tt>take_view::begin</tt> returns 
<tt>counted_iterator(ranges::begin(<i>base_</i>), <i>count_</i>)</tt>. Since the 
<tt>counted_iterator</tt> constructor (25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/counted.iter.const">[counted.iter.const]</a>) already has 
a precondition that <tt>n &gt;= 0</tt>, we should add this to <tt>take_view</tt> as well,
which is consistent with <tt>drop_view</tt>.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>

<li><p>Modify 26.7.10.2 <a href="https://timsong-cpp.github.io/cppwp/range.take.view">[range.take.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr take_view(V base, range_difference_t&lt;V&gt; count);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <tt>count &gt;= 0</tt> is <tt>true</tt>.</ins>
</p>
<p>
-1- <i>Effects</i>: Initializes <tt><i>base_</i></tt> with <tt>std::move(base)</tt> and 
<tt><i>count_</i></tt> with <tt>count</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3742" href="3742">3742.</a> <tt>deque::prepend_range</tt> needs to permute</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2022-07-16 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the range to be inserted is neither bidirectional nor sized, it's simpler to prepend 
elements one at a time, and then reverse the prepended elements. When the range to be 
inserted is neither forward nor sized, I believe this approach is necessary to implement 
<tt>prepend_range</tt> at all &mdash; there is no way to determine the length of the range 
modulo the block size of the <tt>deque</tt> ahead of time so as to insert the new elements 
in the proper position.
<p/>
The container requirements do not allow <tt>prepend_range</tt> to permute elements in a 
<tt>deque</tt>. I believe we <em>must</em> allow permutation when the range is neither 
forward nor sized, and we <em>should</em> allow permutation when the range is not bidirectional 
to allow implementations the freedom to make a single pass through the range.
</p>

<p><i>[2022-07-17; Daniel comments]</i></p>

<p>
The below suggested wording follows the existing style used in the specification of <tt>insert</tt>
and <tt>insert_range</tt>, for example. Unfortunately, this existing practice violates the usual
wording style that a <i>Cpp17XXX</i> requirement shall be <em>met</em> and that we should better
say that "lvalues of type <tt>T</tt> are swappable (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>)" to 
be clearer about the specific swappable context. A separate editorial issue will be reported to take
care of this problem.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote>
<pre>
a.prepend_range(rg)
</pre>
<blockquote>
<p>
-94- <i>Result:</i> <tt>void</tt>
<p/>
-95- <i>Preconditions:</i> <tt>T</tt> is <i>Cpp17EmplaceConstructible</i> into <tt>X</tt> 
from <tt>*ranges::begin(rg)</tt>. <ins>For <tt>deque</tt>, <tt>T</tt> is also 
<tt>Cpp17MoveInsertable</tt> into <tt>X</tt>, <i>Cpp17MoveConstructible</i>, 
<i>Cpp17MoveAssignable</i>, and swappable (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>).</ins>
<p/>
-96- <i>Effects:</i> Inserts copies of elements in <tt>rg</tt> before <tt>begin()</tt>. 
Each iterator in the range <tt>rg</tt> is dereferenced exactly once.
<p/>
[<i>Note 3</i>: The order of elements in <tt>rg</tt> is not reversed. &mdash; <i>end note</i>]
<p/>
-97- <i>Remarks:</i> Required for <tt>deque</tt>, <tt>forward_list</tt>, and <tt>list</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3743" href="3743">3743.</a> <tt>ranges::to</tt>'s <tt>reserve</tt> may be ill-formed</h3>
<p><b>Section:</b> 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-07-21 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the "reserve" branch is satisfied, <tt>ranges::to</tt> directly passes the 
result of <tt>ranges::size(r)</tt> into the <tt>reserve</tt> call. However, given 
that the standard only guarantees that integer-class type can be explicitly converted 
to any integer-like type (25.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a> p6), this makes 
the call potentially ill-formed, since <tt>ranges::size(r)</tt> may return an 
integer-class type:
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() {
  auto r = std::ranges::subrange(std::views::iota(0ULL) | std::views::take(5), 5);
  auto v = r | std::ranges::to&lt;std::vector&lt;std::size_t&gt;&gt;(0); // <span style="color:red;font-weight:bolder">cannot implicitly convert _Unsigned128 to size_t in MSVC-STL</span>
}
</pre></blockquote>
<p>
We should do an explicit cast before calling <tt>reserve</tt>.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>
<p>
Are we all happy that the result of conversion to the container's size type
may be less than the length of the source range, so the reservation is too small
but we don't realize until pushing the max_size() + 1st element fails?
I think it's acceptable that converting pathologically large ranges to
containers fails kind of messily, but I could imagine throwing
if the range length is greater than container's max_size().
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Returns</i>: An object of type <tt>C</tt> constructed from the elements of <tt>r</tt> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If <tt>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</tt> is <tt>true</tt>:</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.1) &mdash; If <tt>constructible_from&lt;C, R, Args...&gt;</tt> is <tt>true</tt>:</p></li>
<blockquote><tt>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote>
<li><p>(1.1.2) &mdash; Otherwise, if <tt>constructible_from&lt;C, from_range_t, R, Args...&gt;</tt> is <tt>true</tt>:</p></li>
<blockquote><tt>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote>
<li><p>(1.1.3) &mdash; Otherwise, if</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.3.1) &mdash; <tt>common_range&lt;R&gt;</tt> is <tt>true</tt>,</p></li>
<li><p>(1.1.3.2) &mdash; <tt><i>cpp17-input-iterator</i>&lt;iterator_t&lt;R&gt;&gt;</tt> is <tt>true</tt>, and</p></li>
<li><p>(1.1.3.3) &mdash; <tt>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</tt> is <tt>true</tt>:</p></li>
<blockquote><tt>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</tt></blockquote>
</ol>
<li><p>(1.1.4) &mdash; Otherwise, if</p></li>
<ol style="list-style-type: none">
<li><p>(1.1.4.1) &mdash; <tt>constructible_from&lt;C, Args...&gt;</tt> is <tt>true</tt>, and</p></li>
<li><p>(1.1.4.2) &mdash; <tt><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:</p>
<blockquote><pre>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R&gt; &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
  c.reserve(<ins>static_cast&lt;range_size_t&lt;C&gt;&gt;(</ins>ranges::size(r)<ins>)</ins>);
ranges::copy(r, <i>container-inserter</i>&lt;range_reference_t&lt;R&gt;&gt;(c));
</pre></blockquote></li>
</ol>
</ol>
<li><p>(1.2) &mdash; Otherwise, if <tt>input_range&lt;range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(1.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3745" href="3745">3745.</a> <tt>std::atomic_wait</tt> and its friends lack <tt>noexcept</tt></h3>
<p><b>Section:</b> 33.5.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-07-25 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.syn">active issues</a> in [atomics.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.syn">issues</a> in [atomics.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently function templates <tt>std::atomic_wait</tt>, <tt>std::atomic_wait_explicit</tt>, 
<tt>std::atomic_notify_one</tt>, and <tt>std::atomic_notify_all</tt> are not <tt>noexcept</tt> 
in the Working Draft, but the equivalent member functions are all <tt>noexcept</tt>. I think 
these function templates should be specified as <tt>noexcept</tt>, in order to be consistent 
with the <tt>std::atomic_flag_*</tt> free functions, the corresponding member functions, and 
other <tt>std::atomic_*</tt> function templates.
<p/>
Mainstream implementations (libc++, libstdc++, and MSVC STL) have already added <tt>noexcept</tt> 
to them.
</p>

<p><i>[2022-07-30; Daniel provides wording]</i></p>


<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>
<p>
"Technically there's a difference between these and the member functions -
the pointer can be null - but we don't seem to have let that stop us
from adding noexcept to the rest of these functions."
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 33.5.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>, header <tt>&lt;atomic&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class T&gt;
  void atomic_wait(const volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) <ins>noexcept</ins>;
template&lt;class T&gt;
  void atomic_wait(const atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) <ins>noexcept</ins>;
template&lt;class T&gt;
  void atomic_wait_explicit(const volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                            memory_order) <ins>noexcept</ins>;
template&lt;class T&gt;
  void atomic_wait_explicit(const atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                            memory_order) <ins>noexcept</ins>;
template&lt;class T&gt;
  void atomic_notify_one(volatile atomic&lt;T&gt;*) <ins>noexcept</ins>;
template&lt;class T&gt;
  void atomic_notify_one(atomic&lt;T&gt;*) <ins>noexcept</ins>;
template&lt;class T&gt;
  void atomic_notify_all(volatile atomic&lt;T&gt;*) <ins>noexcept</ins>;
template&lt;class T&gt;
  void atomic_notify_all(atomic&lt;T&gt;*) <ins>noexcept</ins>;
[&hellip;]
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3746" href="3746">3746.</a> <tt>optional</tt>'s spaceship with <tt>U</tt> with a type derived from <tt>optional</tt> 
causes infinite constraint meta-recursion</h3>
<p><b>Section:</b> 22.5.8 <a href="https://timsong-cpp.github.io/cppwp/optional.comp.with.t">[optional.comp.with.t]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2022-07-25 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.comp.with.t">issues</a> in [optional.comp.with.t].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What ends up happening is that the constraints of 
<tt>operator&lt;=&gt;(const optional&lt;T&gt;&amp;, const U&amp;)</tt> end up 
in <tt>three_way_comparable_with</tt>, and then in <tt><i>partially-ordered-with</i></tt>, 
and the expressions there end up performing a conversion from <tt>U</tt> to an 
<tt>optional</tt>, and we end up instantiating the same <tt>operator&lt;=&gt;</tt>
again, evaluating its constraints again, until the compiler bails out.
<p/>
See an <a href="https://godbolt.org/z/T7f4sr8jv">online example here</a>.
<p/>
All implementations end up with infinite meta-recursion.
<p/>
The solution to the problem is to stop the meta-recursion by constraining
the spaceship with <tt>U</tt> so that <tt>U</tt> is not publicly and unambiguously derived
from a specialization of optional, SFINAEing that candidate out, and letting 
22.5.6 <a href="https://timsong-cpp.github.io/cppwp/optional.relops">[optional.relops]</a>/20 perform the comparison instead.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after five votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> This proposed wording removes the only use of <tt><i>is-optional</i></tt>. ]
</p>
</blockquote>

<ol>
<li><p>Modify 22.5.2 <a href="https://timsong-cpp.github.io/cppwp/optional.syn">[optional.syn]</a>, header <tt>&lt;optional&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std {
  <i>// 22.5.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a>, class template optional</i>
  template&lt;class T&gt;
    class optional;

  <del>template&lt;class T&gt;
    constexpr bool <i>is-optional</i> = false; <i>// exposition only</i>
  template&lt;class T&gt;
    constexpr bool <i>is-optional</i>&lt;optional&lt;T&gt;&gt; = true; <i>// exposition only</i></del>
  <ins>template&lt;class T&gt;
    concept <i>is-derived-from-optional</i> = requires(const T&amp; t) { <i>// exposition only</i>
      []&lt;class U&gt;(const optional&lt;U&gt;&amp;){ }(t);
    };</ins>
  [&hellip;]
  <i>// 22.5.8 <a href="https://timsong-cpp.github.io/cppwp/optional.comp.with.t">[optional.comp.with.t]</a>, comparison with T</i>
  [&hellip;]
  template&lt;class T, class U&gt; constexpr bool operator&gt;=(const T&amp;, const optional&lt;U&gt;&amp;);
  template&lt;class T, class U&gt; requires (!<i>is-<ins>derived-from-</ins>optional</i>&lt;U&gt;) &amp;&amp; three_way_comparable_with&lt;T, U&gt;
    constexpr compare_three_way_result_t&lt;T, U&gt;
      operator&lt;=&gt;(const optional&lt;T&gt;&amp;, const U&amp;);
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.8 <a href="https://timsong-cpp.github.io/cppwp/optional.comp.with.t">[optional.comp.with.t]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt; requires (!<i>is-<ins>derived-from-</ins>optional</i>&lt;U&gt;) &amp;&amp; three_way_comparable_with&lt;T, U&gt;
  constexpr compare_three_way_result_t&lt;T, U&gt;
    operator&lt;=&gt;(const optional&lt;T&gt;&amp;, const U&amp;);
</pre>
<blockquote>
<p>
-25- <i>Effects:</i> Equivalent to: <tt>return x.has_value() ? *x &lt;=&gt; v : strong_ordering::less;</tt>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3747" href="3747">3747.</a> <tt>ranges::uninitialized_copy_n</tt>, <tt>ranges::uninitialized_move_n</tt>, and 
<tt>ranges::destroy_n</tt> should use <tt>std::move</tt></h3>
<p><b>Section:</b> 27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a>, 27.11.6 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.move">[uninitialized.move]</a>, 27.11.9 <a href="https://timsong-cpp.github.io/cppwp/specialized.destroy">[specialized.destroy]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-07-28 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <tt>ranges::uninitialized_copy_n</tt> has the following equivalent <i>Effects</i>:
</p>
<blockquote><pre>
auto t = uninitialized_copy(counted_iterator(ifirst, n),
                            default_sentinel, ofirst, olast);
return {std::move(t.in).base(), t.out};
</pre></blockquote>
<p>
Given that <tt>ifirst</tt> is just an <tt>input_iterator</tt> which is not guaranteed to be <tt>copyable</tt>, 
we should move it into <tt>counted_iterator</tt>. The same goes for <tt>ranges::uninitialized_move_n</tt> 
and <tt>ranges::destroy_n</tt>.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a> as indicated:</p>

<blockquote>
<pre>
namespace ranges {
  template&lt;input_iterator I, <i>nothrow-forward-iterator</i> O, <i>nothrow-sentinel-for</i>&lt;O&gt; S&gt;
    requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_reference_t&lt;I&gt;&gt;
    uninitialized_copy_n_result&lt;I, O&gt;
      uninitialized_copy_n(I ifirst, iter_difference_t&lt;I&gt; n, O ofirst, S olast);
}
</pre>
<blockquote>
<p>
-9- <i>Preconditions</i>: [<tt>ofirst, olast</tt>) does not overlap with <tt>ifirst +</tt> [<tt>0, n</tt>) .
</p>
<p>
-10- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto t = uninitialized_copy(counted_iterator(<ins>std::move(</ins>ifirst<ins>)</ins>, n),
                            default_sentinel, ofirst, olast);
return {std::move(t.in).base(), t.out};
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.11.6 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.move">[uninitialized.move]</a> as indicated:</p>

<blockquote>
<pre>
namespace ranges {
  template&lt;input_iterator I, <i>nothrow-forward-iterator</i> O, <i>nothrow-sentinel-for</i>&lt;O&gt; S&gt;
    requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_rvalue_reference_t&lt;I&gt;&gt;
    uninitialized_move_n_result&lt;I, O&gt;
      uninitialized_move_n(I ifirst, iter_difference_t&lt;I&gt; n, O ofirst, S olast);
}
</pre>
<blockquote>
<p>
-8- <i>Preconditions</i>: [<tt>ofirst, olast</tt>) does not overlap with <tt>ifirst +</tt> [<tt>0, n</tt>) .
</p>
<p>
-9- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto t = uninitialized_move(counted_iterator(<ins>std::move(</ins>ifirst<ins>)</ins>, n),
                            default_sentinel, ofirst, olast);
return {std::move(t.in).base(), t.out};
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.11.9 <a href="https://timsong-cpp.github.io/cppwp/specialized.destroy">[specialized.destroy]</a> as indicated:</p>

<blockquote>
<pre>
namespace ranges {
  template&lt;<i>nothrow-input-iterator</i> I&gt;
    requires destructible&lt;iter_value_t&lt;I&gt;&gt;
    constexpr I destroy_n(I first, iter_difference_t&lt;I&gt; n) noexcept;
}
</pre>
<blockquote>
<p>
-5- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return destroy(counted_iterator(<ins>std::move(</ins>first<ins>)</ins>, n), default_sentinel).base();
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3750" href="3750">3750.</a> Too many papers bump <tt>__cpp_lib_format</tt></h3>
<p><b>Section:</b> 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2022-08-04 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As pointed out by <a href="https://lists.isocpp.org/sg10/2022/07/0829.php">Casey Carter</a>, 
four papers approved at the recent July 2022 plenary:
</p>
<ul>
<li><p><a href="https://wg21.link/P2419R2">P2419R2</a> "Clarify handling of encodings in localized formatting of chrono
types"</p></li>
<li><p><a href="https://wg21.link/P2508R1">P2508R1</a> "Expose <tt>std::basic-format-string&lt;charT, Args...&gt;</tt>"</p></li>
<li><p><a href="https://wg21.link/P2286R8">P2286R8</a> "Formatting Ranges"</p></li>
<li><p><a href="https://wg21.link/P2585R1">P2585R1</a> "Improve container default formatting"</p></li>
</ul>
<p>
all bump the value of <tt>__cpp_lib_format</tt>. We never accounted for all of these papers 
being moved at the same time, and these papers have fairly different implementation complexities. 
<p/>
<a href="https://lists.isocpp.org/sg10/2022/07/0832.php">Victor Zverovich</a> suggests that we 
instead add <tt>__cpp_lib_format_ranges</tt> (with value <tt>202207L</tt>) for the two formatting 
ranges papers (<a href="https://wg21.link/P2286">P2286</a> and <a href="https://wg21.link/P2585">P2585</a>, which should probably be implemented 
concurrently anyway, since the latter modifies the former) and <tt>bump __cpp_lib_format</tt> for 
the other two, which are both minor changes.
<p/>
We should do that.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after 12 votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<ol>

<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
#define __cpp_lib_format          202207L <i>// also in &lt;format&gt;</i>
<ins>#define __cpp_lib_format_ranges   202207L <i>// also in &lt;format&gt;</i></ins>

</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3751" href="3751">3751.</a> Missing feature macro for <tt>flat_set</tt></h3>
<p><b>Section:</b> 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2022-08-04 <b>Last modified:</b> 2022-08-23 15:24:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As pointed out by <a href="https://lists.isocpp.org/sg10/2022/07/0834.php">Casey Carter</a>, 
while there is a feature macro for <tt>flat_map</tt> in <a href="https://wg21.link/P0429">P0429</a>, there is 
no corresponding macro for flat_set in <a href="https://wg21.link/P1222">P1222</a>. We should add one.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after 10 votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<ol>

<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
#define __cpp_lib_flat_map  202207L <i>// also in &lt;flat_map&gt;</i>
<ins>#define __cpp_lib_flat_set  202207L <i>// also in &lt;flat_set&gt;</i></ins>
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3754" href="3754">3754.</a> Class template <code>expected</code> synopsis contains declarations that do not match the detailed description</h3>
<p><b>Section:</b> 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2022-08-23 <b>Last modified:</b> 2022-09-07 17:14:22 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a> declares the following constructors:
</p>

<blockquote><pre>
template&lt;class G&gt;
  constexpr expected(const unexpected&lt;G&gt;&amp;);
template&lt;class G&gt;
  constexpr expected(unexpected&lt;G&gt;&amp;&amp;);
</pre></blockquote>

<p>
But in 22.8.6.2 <a href="https://timsong-cpp.github.io/cppwp/expected.object.ctor">[expected.object.ctor]</a>, these constructors are declared as:
</p>

<blockquote><pre>
template&lt;class G&gt;
  constexpr explicit(!is_convertible_v&lt;const G&amp;, E&gt;) expected(const unexpected&lt;G&gt;&amp; e);
template&lt;class G&gt;
  constexpr explicit(!is_convertible_v&lt;G, E&gt;) expected(unexpected&lt;G&gt;&amp;&amp; e);
</pre></blockquote>

<p>
Note that they have no explicit-specifiers in 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a>,
but are conditionally explicit in 22.8.6.2 <a href="https://timsong-cpp.github.io/cppwp/expected.object.ctor">[expected.object.ctor]</a>.
</p>

<p>
I presume that 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a>
is missing a few <code>explicit(<i>see below</i>)</code>.
</p>

<p>
The same inconsistency exists in 22.8.7 <a href="https://timsong-cpp.github.io/cppwp/expected.void">[expected.void]</a>.
</p>

<p><i>[2022-09-05; Jonathan Wakely provides wording]</i></p>


<p>
In <a href="https://wg21.link/N4910">N4910</a> the <tt>expected</tt> synopses had
<tt>explicit(<i>see below</i>)</tt> on the copy and move constructors.
That was fixed editorially, but this other inconsistency was not noticed.
</p>

<p><i>[2022-09-07; Moved to "Ready" at LWG telecon]</i></p>




<p><b>Proposed resolution:</b></p>

<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Change 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a> as indicated:</p>

<blockquote><pre>
<i>// 22.8.6.2, constructors</i>
constexpr expected();
constexpr expected(const expected&amp;);
constexpr expected(expected&amp;&amp;) noexcept(<i>see below</i>);
template&lt;class U, class G&gt;
  constexpr explicit(<i>see below</i>) expected(const expected&lt;U, G&gt;&amp;);
template&lt;class U, class G&gt;
  constexpr explicit(<i>see below</i>) expected(expected&lt;U, G&gt;&amp;&amp;);

template&lt;class U = T&gt;
  constexpr explicit(<i>see below</i>) expected(U&amp;&amp; v);

template&lt;class G&gt;
  constexpr <ins>explicit(<i>see below</i>)</ins> expected(const unexpected&lt;G&gt;&amp;);
template&lt;class G&gt;
  constexpr <ins>explicit(<i>see below</i>)</ins> expected(unexpected&lt;G&gt;&amp;&amp;);

template&lt;class... Args&gt;
  constexpr explicit expected(in_place_t, Args&amp;&amp;...);
</pre> </blockquote>
</li>

<li><p>Change 22.8.7.1 <a href="https://timsong-cpp.github.io/cppwp/expected.void.general">[expected.void.general]</a> as indicated:</p>

<blockquote><pre>
<i>// 22.8.7.2, constructors</i>
constexpr expected() noexcept;
constexpr expected(const expected&);
constexpr expected(expected&amp;&amp;) noexcept(<i>see below</i>);
template&lt;class U, class G&gt;
  constexpr explicit(<i>see below</i>) expected(const expected&lt;U, G&gt;&amp;&amp;);

template&lt;class G&gt;
  constexpr <ins>explicit(<i>see below</i>)</ins> expected(const unexpected&lt;G&gt;&amp;);
template&lt;class G&gt;
  constexpr <ins>explicit(<i>see below</i>)</ins> expected(unexpected&lt;G&gt;&amp;&amp;);

constexpr explicit expected(in_place_t) noexcept;
</pre> </blockquote>

</li>

</ol>






<hr>
<h3><a name="3755" href="3755">3755.</a> <tt><i>tuple-for-each</i></tt> can call user-defined <tt>operator,</tt></h3>
<p><b>Section:</b> 26.7.23.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.view">[range.zip.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nicole Mazzuca  <b>Opened:</b> 2022-08-26 <b>Last modified:</b> 2022-09-25 06:15:22 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.zip.view">active issues</a> in [range.zip.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.zip.view">issues</a> in [range.zip.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification for <tt><i>tuple-for-each</i></tt> is:
</p>

<blockquote><pre>
template&lt;class F, class Tuple&gt;
constexpr auto <i>tuple-for-each</i>(F&amp;&amp; f, Tuple&amp;&amp; t) { <i>// exposition only</i>
  apply([&amp;]&lt;class... Ts&gt;(Ts&amp;&amp;... elements) {
    (invoke(f, std::forward&lt;Ts&gt;(elements)), ...);
  }, std::forward&lt;Tuple&gt;(t));
}
</pre></blockquote>

<p>Given</p>

<blockquote><pre>
struct Evil {
  void operator,(Evil) {
        abort();
    }
};
</pre></blockquote>

<p>
and <tt>tuple&lt;int, int&gt; t</tt>, then
<tt><i>tuple-for-each</i>([](int) { return Evil{}; }, t)</tt>,
the program will (unintentionally) abort.
</p>

<p>
It seems likely that our <tt>Evil</tt>'s <tt>operator,</tt>
should not be called.
</p>


<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after nine votes in favour during reflector poll.
</p>
<p>
Feedback from one reviewer:
</p>
<blockquote>
<p>
"NAD. This exposition-only facility is only used with things that return <tt>void</tt>. 
As far as I know, users can't define <tt>operator,</tt> for <tt>void</tt>.
If I see the <tt>void</tt> cast, I don't need to audit the uses or be concerned that 
we'll add a broken use in the future."
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p> This wording is relative to the forthcoming C++23 CD. </p>

<ul>
<li>
<p>
Modify 26.7.5 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.tuple">[range.adaptor.tuple]</a> as indicated:
</p>

<blockquote><pre>
template&lt;class F, class Tuple&gt;
constexpr auto <i>tuple-for-each</i>(F&amp;&amp; f, Tuple&amp;&amp; t) { <i>// exposition only</i>
  apply([&amp;]&lt;class... Ts&gt;(Ts&amp;&amp;... elements) {
    (<ins>static_cast&lt;void&gt;(</ins>invoke(f, std::forward&lt;Ts&gt;(elements))<ins>)</ins>, ...);
  }, std::forward&lt;Tuple&gt;(t));
}
</pre></blockquote>

</li>
</ul>






<hr>
<h3><a name="3757" href="3757">3757.</a> What's the effect of <tt>std::forward_like&lt;void&gt;(x)</tt>?</h3>
<p><b>Section:</b> 22.2.4 <a href="https://timsong-cpp.github.io/cppwp/forward">[forward]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-08-24 <b>Last modified:</b> 2022-09-23 15:12:25 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#forward">issues</a> in [forward].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the return type of <tt>std::forward_like</tt> is specified by the following bullet:
</p>
<blockquote>
<p>
&mdash; Let <tt>V</tt> be
</p>
<blockquote><pre>
<i>OVERRIDE_REF</i>(T&amp;&amp;, <i>COPY_CONST</i>(remove_reference_t&lt;T&gt;, remove_reference_t&lt;U&gt;))
</pre></blockquote>
</blockquote>
<p>
where <tt>T&amp;&amp;</tt> is not always valid, e.g. it's invalid when <tt>T</tt> is <tt>void</tt>.
<p/>
A strait forward reading may suggest that there is a hard error when <tt>T</tt> is not referenceable 
(which is currently implemented in MSVC STL), but this seems not clarified. It is unclear to me whether 
the intent is that hard error, substitution failure, or no error is caused when <tt>T&amp;&amp;</tt> is invalid.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 22.2.4 <a href="https://timsong-cpp.github.io/cppwp/forward">[forward]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt;
  [[nodiscard]] constexpr auto forward_like(U&amp;&amp; x) noexcept -> <i>see below</i>;
</pre>
<blockquote>
<p>
<ins><i>Mandates</i>: <tt>T</tt> is a referenceable type (3.46 <a href="https://timsong-cpp.github.io/cppwp/defns.referenceable">[defns.referenceable]</a>).</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3759" href="3759">3759.</a> <tt>ranges::rotate_copy</tt> should use <tt>std::move</tt></h3>
<p><b>Section:</b> 27.7.11 <a href="https://timsong-cpp.github.io/cppwp/alg.rotate">[alg.rotate]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-08-25 <b>Last modified:</b> 2022-09-23 15:09:30 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.rotate">issues</a> in [alg.rotate].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The range version of <tt>ranges::rotate_copy</tt> directly passes the <tt>result</tt> to the 
iterator-pair version. Since the type of <tt>result</tt> only models <tt>weakly_incrementable</tt> 
and may not be copied, we should use <tt>std::move</tt> here.
</p>


<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li><p>Modify 27.7.11 <a href="https://timsong-cpp.github.io/cppwp/alg.rotate">[alg.rotate]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;forward_range R, weakly_incrementable O&gt;
  requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
  constexpr ranges::rotate_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
    ranges::rotate_copy(R&amp;&amp; r, iterator_t&lt;R&gt; middle, O result);
</pre>
<blockquote>
<p>
-11- <i>Effects</i>: Equivalent to:
<blockquote><pre>
return ranges::rotate_copy(ranges::begin(r), middle, ranges::end(r), <ins>std::move(</ins>result<ins>)</ins>);
</pre></blockquote>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3760" href="3760">3760.</a> <tt>cartesian_product_view::<i>iterator</i></tt>'s <tt><i>parent_</i></tt> is never valid</h3>
<p><b>Section:</b> 26.7.31 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian">[range.cartesian]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-08-27 <b>Last modified:</b> 2022-09-23 15:00:17 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>cartesian_product_view::<i>iterator</i></tt> has a pointer member <tt><i>parent_</i></tt> that points 
to <tt>cartesian_product_view</tt>, but its constructor only accepts a <tt>tuple</tt> of iterators, which 
makes <tt><i>parent_</i></tt> always default-initialized to <tt>nullptr</tt>.
<p/>
The proposed resolution is to add an aliased <tt><i>Parent</i></tt> parameter to the constructor and 
initialize <tt><i>parent_</i></tt> with <tt>addressof</tt>, as we usually do.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>
<li><p>Modify 26.7.31.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>iterator</i>&lt;false&gt; begin()
  requires (!<i>simple-view</i>&lt;First&gt; || ... || !<i>simple-view</i>&lt;Vs&gt;);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to: <tt>return <i>iterator</i>&lt;false&gt;(<ins>*this,</ins> <i>tuple-transform</i>(ranges::begin, 
<i>bases_</i>));</tt>
</p>
</blockquote>  
<pre>
constexpr <i>iterator</i>&lt;true&gt; begin() const
  requires (range&lt;const First&gt; &amp;&amp; ... &amp;&amp; range&lt;const Vs&gt;);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Equivalent to: <tt>return <i>iterator</i>&lt;true&gt;(<ins>*this,</ins> <i>tuple-transform</i>(ranges::begin, 
<i>bases_</i>));</tt>
</p>
</blockquote>
<pre>
constexpr <i>iterator</i>&lt;false&gt; end()
  requires ((!<i>simple-view</i>&lt;First&gt; || ... || !<i>simple-view</i>&lt;Vs&gt;)
    &amp;&amp; <i>cartesian-product-is-common</i>&lt;First, Vs...&gt;);
constexpr <i>iterator</i>&lt;true&gt; end() const
  requires <i>cartesian-product-is-common</i>&lt;const First, const Vs...&gt;;
</pre>
<blockquote>
<p>
-4- Let:
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <tt><i>is-const</i></tt> be <tt>true</tt> for the const-qualified overload, and <tt>false</tt> otherwise;</p></li>
<li><p>(4.2) &mdash; <tt><i>is-empty</i></tt> be <tt>true</tt> if the expression <tt>ranges::empty(rng)</tt> is <tt>true</tt> 
for any <tt>rng</tt> among the underlying ranges except the first one and <tt>false</tt> otherwise; and</p></li>
<li><p>(4.3) &mdash; <tt><i>begin-or-first-end</i>(rng)</tt> be expression-equivalent to 
<tt><i>is-empty</i> ? ranges::begin(rng) : <i>cartesian-common-arg-end</i>(rng)</tt> if <tt>rng</tt> is the first underlying range 
and <tt>ranges::begin(rng)</tt> otherwise.</p></li>
</ol>
<p>
-5- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<i>iterator</i>&lt;<i>is-const</i>&gt; it(<ins>*this,</ins> <i>tuple-transform</i>(
  [](auto&amp; rng){ return <i>begin-or-first-end</i>(rng); }, <i>bases_</i>));
return it;
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.31.3 <a href="https://timsong-cpp.github.io/cppwp/ranges.cartesian.iterator">[ranges.cartesian.iterator]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;)
  template&lt;bool Const&gt;
  class cartesian_product_view&lt;First, Vs...&gt;::<i>iterator</i> {
  public:
    [&hellip;]

  private:
    <ins>using <i>Parent</i> = <i>maybe-const</i>&lt;Const, cartesian_product_view&gt;;           <i>// exposition only</i></ins>
    <ins><i>Parent</i></ins><del><i>maybe-const</i>&lt;Const, cartesian_product_view&gt;</del>* <i>parent_</i> = nullptr; <i>// exposition only</i>
    tuple&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt;,
      iterator_t&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;...&gt; <i>current_</i>;                   <i>// exposition only</i>
    
    template&lt;size_t N = sizeof...(Vs)&gt;
      constexpr void <i>next</i>();                                             <i>// exposition only</i>
    
    template&lt;size_t N = sizeof...(Vs)&gt;
      constexpr void <i>prev</i>();                                             <i>// exposition only</i>
    
    template&lt;class Tuple>
      constexpr difference_type <i>distance-from</i>(Tuple t);                  <i>// exposition only</i>
    
    constexpr <del>explicit</del> <i>iterator</i>(<ins><i>Parent</i>&amp; parent,</ins> tuple&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt;,
      iterator_t&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;...&gt; current);                   <i>// exposition only</i>
  };
}
</pre>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
constexpr <del>explicit</del> <i>iterator</i>(<ins><i>Parent</i>&amp; parent,</ins> tuple&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt;,
  iterator_t&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;...&gt; current);
</pre>
<blockquote>
<p>
-10- <i>Effects</i>:  Initializes <ins><tt><i>parent_</i></tt> with <tt>addressof(parent)</tt> and</ins> 
<tt><i>current_</i></tt> with <tt>std::move(current)</tt>.
</p>
</blockquote>
<pre>
constexpr <i>iterator</i>(<i>iterator</i>&lt;!Const&gt; i) requires Const &amp;&amp;
  (convertible_to&lt;iterator_t&lt;First&gt;, iterator_t&lt;const First&gt;&gt; &amp;&amp;
    ... &amp;&amp; convertible_to&lt;iterator_t&lt;Vs&gt;, iterator_t&lt;const Vs&gt;&gt;);
</pre>
<blockquote>
<p>
-11- <i>Effects</i>: Initializes <ins><tt><i>parent_</i></tt> with <tt>i.<i>parent_</i></tt> and</ins> 
<tt><i>current_</i></tt> with <tt>std::move(i.<i>current_</i>)</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3761" href="3761">3761.</a> <tt>cartesian_product_view::<i>iterator</i>::operator-</tt> should pass by reference</h3>
<p><b>Section:</b> 26.7.31.3 <a href="https://timsong-cpp.github.io/cppwp/ranges.cartesian.iterator">[ranges.cartesian.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-08-27 <b>Last modified:</b> 2022-09-23 15:18:19 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two problems with <tt>cartesian_product_view::<i>iterator</i>::operator-</tt>.
<p/>
First, <tt><i>distance-from</i></tt> is not <tt>const</tt>-qualified, which would cause 
the common version of <tt>operator-</tt> to produce a hard error inside the function body 
since it invokes <tt><i>distance-from</i></tt> on a const <tt><i>iterator</i></tt> object.
<p/>
Second, the non-common version of <tt>operator-</tt> passes <tt><i>iterator</i></tt> by value,
which unnecessarily prohibits subtracting <tt>default_sentinel</tt> from an lvalue 
<tt><i>iterator</i></tt> whose first underlying iterator is non-<tt>copyable</tt>.
Even if we <tt>std::move</tt> it into <tt>operator-</tt>, the other overload will still be ill-formed
since it returns <tt>-(i - s)</tt> which will calls <tt>i</tt>'s deleted copy constructor.
<p/>
The proposed resolution is to add <tt>const</tt> qualification to <tt><i>distance-from</i></tt> 
and make the non-common version of <tt><i>iterator</i>::operator-</tt> pass by const reference. 
Although the <tt>Tuple</tt> parameter of <tt><i>distance-from</i></tt> is guaranteed to be 
<tt>copyable</tt>, I think it would be more appropriate to pass it by reference.
</p>

<p><i>[2022-09-08]</i></p>

<p>
As suggested by Tim Song, the originally submitted proposed wording has been refined to use
<tt>const Tuple&amp;</tt> instead of <tt>Tuple&amp;</tt>.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>

<li><p>Modify 26.7.31.3 <a href="https://timsong-cpp.github.io/cppwp/ranges.cartesian.iterator">[ranges.cartesian.iterator]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;)
  template&lt;bool Const&gt;
  class cartesian_product_view&lt;First, Vs...&gt;::<i>iterator</i> {
  public:
    [&hellip;]

    friend constexpr difference_type operator-(<ins>const</ins> <i>iterator</i><ins>&amp;</ins> i, default_sentinel_t)
      requires <i>cartesian-is-sized-sentinel</i>&lt;Const, sentinel_t, First, Vs...&gt;;
    friend constexpr difference_type operator-(default_sentinel_t, <ins>const</ins> <i>iterator</i><ins>&amp;</ins> i)
      requires <i>cartesian-is-sized-sentinel</i>&lt;Const, sentinel_t, First, Vs...&gt;;

    [&hellip;]
  private:
    [&hellip;]
    
    template&lt;class Tuple&gt;
      constexpr difference_type <i>distance-from</i>(<ins>const</ins> Tuple<ins>&amp;</ins> t) <ins>const</ins>;            <i>// exposition only</i>
      
    [&hellip;]
  };
}
</pre>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template&lt;class Tuple&gt;
  constexpr difference_type <i>distance-from</i>(<ins>const</ins> Tuple<ins>&amp;</ins> t) <ins>const</ins>;
</pre>
<blockquote>
<p>
-7- Let:
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; <tt><i>scaled-size</i>(<i>N</i>)</tt> be the product of 
<tt>static_cast&lt;difference_type&gt;(ranges::size(std::get&lt;<i>N</i>&gt;(<i>parent_</i>-&gt;<i>bases_</i>)))</tt> and 
<tt><i>scaled-size</i>(<i>N</i> + 1)</tt> if <tt><i>N</i> &lt; sizeof...(Vs)</tt>, otherwise 
<tt>static_cast&lt;difference_type&gt;(1)</tt>;</p></li>
<li><p>(7.2) &mdash; <tt><i>scaled-distance</i>(<i>N</i>)</tt> be the product of 
<tt>static_cast&lt;difference_type&gt;(std::get&lt;<i>N</i>&gt;(<i>current_</i>) - std::get&lt;<i>N</i>&gt;(t))</tt> and 
<tt><i>scaled-size</i>(<i>N</i> + 1)</tt>; and</p></li>
<li><p>(7.3) &mdash; <tt><i>scaled-sum</i></tt> be the sum of <tt><i>scaled-distance</i>(<i>N</i>)</tt> for every integer 
<tt>0 &le; <i>N</i> &le; sizeof...(Vs)</tt>.</p></li>
</ol>
<p>
-8- <i>Preconditions</i>: <tt><i>scaled-sum</i></tt> can be represented by <tt>difference_type</tt>.
</p>
<p>
-9- <i>Returns</i>: <tt><i>scaled-sum</i></tt>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
friend constexpr difference_type operator-(<ins>const</ins> <i>iterator</i><ins>&amp;</ins> i, default_sentinel_t)
  requires <i>cartesian-is-sized-sentinel</i>&lt;Const, sentinel_t, First, Vs...&gt;;
</pre>
<blockquote>
<p>
-32- Let <tt><i>end-tuple</i></tt> be an object of a type that is a specialization of <tt>tuple</tt>, such that:
</p>
<ol style="list-style-type: none">
<li><p>(32.1) &mdash; <tt>std::get&lt;0&gt;(<i>end-tuple</i>)</tt> has the same value as 
<tt>ranges::end(std::get&lt;0&gt;(i.<i>parent_</i>-&gt;<i>bases_</i>))</tt>;</p></li>
<li><p>(32.2) &mdash; <tt>std::get&lt;<i>N</i>&gt;(<i>end-tuple</i>)</tt> has the 
same value as <tt>ranges::begin(std::get&lt;<i>N</i>&gt;(i.<i>parent_</i>-&gt;<i>bases_</i>))</tt> 
for every integer <tt>1 &le; <i>N</i> &le; sizeof...(Vs)</tt>.</p></li>
</ol>
<p>
-33- <i>Effects</i>: Equivalent to: <tt>return i.<i>distance-from</i>(<i>end-tuple</i>);</tt>
</p>
</blockquote>
<pre>
friend constexpr difference_type operator-(default_sentinel_t, <ins>const</ins> <i>iterator</i><ins>&amp;</ins> i)
  requires <i>cartesian-is-sized-sentinel</i>&lt;Const, sentinel_t, First, Vs...&gt;;
</pre>
<blockquote>
<p>
-34- <i>Effects</i>: Equivalent to: <tt>return -(i - s);</tt>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3762" href="3762">3762.</a> <tt>generator::<i>iterator</i>::operator==</tt> should pass by reference</h3>
<p><b>Section:</b> 26.8.6 <a href="https://timsong-cpp.github.io/cppwp/coro.generator.iterator">[coro.generator.iterator]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-08-27 <b>Last modified:</b> 2022-09-23 15:10:34 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <tt>generator::<i>iterator</i>::operator==</tt> passes <tt><i>iterator</i></tt> by value.
Given that <tt><i>iterator</i></tt> is a move-only type, this makes it impossible for 
<tt>generator</tt> to model <tt>range</tt>, since <tt>default_sentinel</tt> cannot be compared 
to the <tt><i>iterator</i></tt> of <tt>const</tt> lvalue and is not eligible to be its sentinel.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>

<li><p>Modify 26.8.6 <a href="https://timsong-cpp.github.io/cppwp/coro.generator.iterator">[coro.generator.iterator]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class Ref, class V, class Allocator&gt;
  class generator&lt;Ref, V, Allocator&gt;::<i>iterator</i> {
  public:
    using value_type = <i>value</i>;
    using difference_type = ptrdiff_t;

    <i>iterator</i>(<i>iterator</i>&amp;&amp; other) noexcept;
    <i>iterator</i>&amp; operator=(<i>iterator</i>&amp;&amp; other) noexcept;
    
    <i>reference</i> operator*() const noexcept(is_nothrow_copy_constructible_v&lt;<i>reference</i>&gt;);
    <i>iterator</i>&amp; operator++();
    void operator++(int);

    friend bool operator==(<ins>const</ins> <i>iterator</i><ins>&amp;</ins> i, default_sentinel_t);

  private:
    coroutine_handle&lt;promise_type&gt; <i>coroutine_</i>; <i>// exposition only</i>
  };
}
</pre>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
friend bool operator==(<ins>const</ins> <i>iterator</i><ins>&amp;</ins> i, default_sentinel_t);
</pre>
<blockquote>
<p>
-10- <i>Effects</i>: Equivalent to: <tt>return i.<i>coroutine_</i>.done();</tt>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3764" href="3764">3764.</a> <tt>reference_wrapper::operator()</tt> should propagate <tt>noexcept</tt></h3>
<p><b>Section:</b> 22.10.6.5 <a href="https://timsong-cpp.github.io/cppwp/refwrap.invoke">[refwrap.invoke]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2022-08-31 <b>Last modified:</b> 2022-09-25 06:07:46 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#refwrap.invoke">issues</a> in [refwrap.invoke].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following assertion does not hold, making
the type less capable than the function pointers.
</p>
<blockquote><pre>
void f() noexcept;

std::reference_wrapper fn = f;
static_assert(std::is_nothrow_invocable_v&lt;decltype(fn)&gt;);
</pre></blockquote>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>
<p>
Already implemented in MSVC and libstdc++.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>

<li><p>Modify 22.10.6.1 <a href="https://timsong-cpp.github.io/cppwp/refwrap.general">[refwrap.general]</a>, class template <tt>reference_wrapper</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
<i>// 22.10.6.5 <a href="https://timsong-cpp.github.io/cppwp/refwrap.invoke">[refwrap.invoke]</a>, invocation</i>
template&lt;class... ArgTypes&gt;
  constexpr invoke_result_t&lt;T&amp;, ArgTypes...&gt; operator()(ArgTypes&amp;&amp;...) const 
    <ins>noexcept(is_nothrow_invocable_v&lt;T&amp;, ArgTypes...&gt;)</ins>;
</pre>
</blockquote>
</li>

<li><p>Modify 22.10.6.5 <a href="https://timsong-cpp.github.io/cppwp/refwrap.invoke">[refwrap.invoke]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... ArgTypes&gt;
  constexpr invoke_result_t&lt;T&amp;, ArgTypes...&gt;
    operator()(ArgTypes&amp;&amp;... args) const <ins>noexcept(is_nothrow_invocable_v&lt;T&amp;, ArgTypes...&gt;)</ins>;
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <tt>T</tt> is a complete type.
<p/>
-2- <i>Returns</i>: <tt><i>INVOKE</i>(get(), std::forward&lt;ArgTypes&gt;(args)...)</tt>. (22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>)
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3765" href="3765">3765.</a> <tt>const_sentinel</tt> should be constrained</h3>
<p><b>Section:</b> 25.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, 25.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.alias">[const.iterators.alias]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-09-03 <b>Last modified:</b> 2022-09-23 15:10:05 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.synopsis">active issues</a> in [iterator.synopsis].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in [iterator.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current standard does not have any constraints on <tt>const_sentinel</tt> template parameters, 
which makes it possible to pass almost any type of object to <tt>make_const_sentinel</tt>.
It would be more appropriate to constrain the type to meet the minimum requirements of the 
sentinel type such as <tt>semiregular</tt> as <tt>move_sentinel</tt> does.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>

<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header <tt>&lt;iterator&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;compare&gt;              <i>// see 17.12.1 <a href="https://timsong-cpp.github.io/cppwp/compare.syn">[compare.syn]</a></i>
#include &lt;concepts&gt;             <i>// see 18.3 <a href="https://timsong-cpp.github.io/cppwp/concepts.syn">[concepts.syn]</a></i>

namespace std {
  [&hellip;]
  
  <i>// 25.5.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators">[const.iterators]</a>, constant iterators and sentinels</i>
  <i>// 25.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.alias">[const.iterators.alias]</a>, alias templates</i>
  [&hellip;]
  template&lt;input_iterator I&gt;
    using const_iterator = <i>see below</i>;                                               // <i>freestanding</i>
  template&lt;<ins>semiregular</ins><del>class</del> S&gt;
    using const_sentinel = <i>see below</i>;                                               // <i>freestanding</i>

  [&hellip;]
  template&lt;input_iterator I&gt;
    constexpr const_iterator&lt;I&gt; make_const_iterator(I it) { return it; }            // <i>freestanding</i>

  template&lt;<ins>semiregular</ins><del>class</del> S&gt;
    constexpr const_sentinel&lt;S&gt; make_const_sentinel(S s) { return s; }              // <i>freestanding</i>
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.alias">[const.iterators.alias]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<ins>semiregular</ins><del>class</del> S&gt;
  using const_sentinel = <i>see below</i>;
</pre>
<blockquote>
<p>
-2- <i>Result</i>: If <tt>S</tt> models <tt>input_iterator</tt>, <tt>const_iterator&lt;S&gt;</tt>. Otherwise, <tt>S</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3771" href="3771">3771.</a> [fund.ts.v3] remove binders typedefs from <code>function</code></h3>
<p><b>Section:</b> 99 [fund.ts.v3::func.wrap.func.overview] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2022-09-12 <b>Last modified:</b> 2022-09-23 15:29:02 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
The LFTSv3 bases its specification for <code>experimental::function</code>
on <code>std::function</code> in the C++20 standard.
However, the wording was largely copied over from LFTSv2 which based its
wording on the C++14 standard.
</p>
<p>
For C++17, we removed the conditionally defined typedefs for the legacy binders
API, but this removal was not reflected in the TS.  We are now left with a
specification referring to unknown types, <tt>T1</tt> and <tt>T2</tt>.
</p>
<p>
 These typedefs should be excised to match the referenced standard.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after ten votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4920">N4920</a>.
</p>

<ol>
<li>
<p>Modify the synopsis in 99 [fund.ts.v3::func.wrap.func.overview]
as indicated:</p>

<blockquote><pre>
namespace std {
  namespace experimental::inline fundamentals_v3 {

    template&lt;class&gt; class function; <i>// undefined</i>

    template&lt;class R, class... ArgTypes&gt;
    class function&lt;R(ArgTypes...)&gt; {
    public:
      using result_type = R;
      <del>using argument_type = T1;</del>
      <del>using first_argument_type T1;</del>
      <del>using second_argument_type = T2;</del>

      using allocator_type = erased_type;

      // ...
  }
}
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="3773" href="3773">3773.</a> <tt>views::zip_transform</tt> still requires <tt>F</tt> to be <tt>copy_constructible</tt> when empty pack</h3>
<p><b>Section:</b> 26.7.24.1 <a href="https://timsong-cpp.github.io/cppwp/range.zip.transform.overview">[range.zip.transform.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-09-12 <b>Last modified:</b> 2022-09-23 15:27:47 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After <a href="https://wg21.link/P2494R2">P2494R2</a>, range adaptors only require callable to be
<tt>move_constructible</tt>, however, for <tt>views::zip_transform</tt>,
when empty pack, it still requires callable to be <tt>copy_constructible</tt>.
We should relax this requirement, too.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after seven votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910">N4910</a>.
</p>

<ol>
<li>
<p>Modify 26.7.24.1 <a href="https://timsong-cpp.github.io/cppwp/range.zip.transform.overview">[range.zip.transform.overview]</a> as indicated:</p>
<blockquote>
<p>
-2- The name <tt>views::zip_transform</tt> denotes a customization point object
(16.3.3.3.6 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a>). 
Let <tt>F</tt> be a subexpression,
and let <tt>Es...</tt> be a pack of subexpressions.
</p>
<ol style="list-style-type:none">
<li><p>(2.1)  If <tt>Es</tt> is an empty pack, let <tt>FD</tt> be <tt>decay_t&lt;decltype((F))&gt;</tt>.</p></li>
<ol style="list-style-type:none">
<li><p>(2.1.1)  If <tt><ins>move_constructible</ins><del>copy_constructible</del>&lt;FD&gt; &amp;&amp; regular_invocable&lt;FD&amp;&gt;</tt> is <tt>false</tt>, or if <tt>decay_t&lt;invoke_result_t&lt;FD&amp;&gt;&gt;</tt> is not an object type, <tt>views::zip_transform(F, Es...)</tt> is ill-formed.</p></li>
<li><p>(2.1.2)  Otherwise, the expression <tt>views::zip_transform(F, Es...)</tt> is expression-equivalent to</p>
<pre>
      ((void)F, auto(views::empty&lt;decay_t&lt;invoke_result_t&lt;FD&amp;&gt;&gt;&gt;))</pre>
</li>
</ol>
<li><p>(2.2)  Otherwise, the expression <tt>views::zip_transform(F, Es...)</tt> is expression-equivalent to <tt>zip_transform_view(F, Es...)</tt>.</p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3774" href="3774">3774.</a> <tt>&lt;flat_set&gt;</tt> should include <tt>&lt;compare&gt;</tt></h3>
<p><b>Section:</b> 24.6.5 <a href="https://timsong-cpp.github.io/cppwp/flat.set.syn">[flat.set.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-09-12 <b>Last modified:</b> 2022-09-23 15:28:19 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This was originally
<a href="https://github.com/cplusplus/draft/pull/5789">editorial PR #5789</a>
which is considered not-editorial.
</p>
 
<p>
<code>std::flat_set</code> and <code>std::flat_multiset</code>
have <code>operator&lt;=&gt;</code>
so <code>&lt;compare&gt;</code> should be included in the corresponding header,
in the spirit of LWG <a href="3330">3330</a>.
<code>#include &lt;compare&gt;</code> is also missing in the adopted paper
<a href="https://wg21.link/P1222R4">P1222R4</a>.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set status to Tentatively Ready after eight votes in favour during reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.</p>

<ol>
<li>
<p>Modify the synopsis in 24.6.5 <a href="https://timsong-cpp.github.io/cppwp/flat.set.syn">[flat.set.syn]</a> as indicated:</p>

<blockquote><pre>
<ins>#include &lt;compare&gt;              <i>// see 17.12.1 <a href="https://timsong-cpp.github.io/cppwp/compare.syn">[compare.syn]</a></i></ins>
#include &lt;initializer_list&gt;     <i>// see 17.11.2 <a href="https://timsong-cpp.github.io/cppwp/initializer.list.syn">[initializer.list.syn]</a></i>
</pre></blockquote>
</li>
</ol>





</body>
</html>
