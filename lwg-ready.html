<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2019-06-08 at 18:02:31 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="2899" href="2899">2899.</a> <tt>is_(nothrow_)move_constructible</tt> and <tt>tuple</tt>, <tt>optional</tt> and <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.5 <a href="https://timsong-cpp.github.io/cppwp/tuple">[tuple]</a>, 20.6 <a href="https://timsong-cpp.github.io/cppwp/optional">[optional]</a>, 20.11.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2019-02-21 17:23:36 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple">issues</a> in [tuple].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 110</b>

<p>The move constructors for <tt>tuple</tt>, <tt>optional</tt>, and <tt>unique_ptr</tt> should return false for 
<tt>is_(nothrow_)move_constructible_v&lt;<i>TYPE</i>&gt;</tt> when their corresponding <i>Requires</i> clauses are not 
satisfied, as there are now several library clauses that are defined in terms of these traits. The same concern 
applies to the move-assignment operator. Note that <tt>pair</tt> and <tt>variant</tt> already satisfy this constraint.
</p>

<p><i>[2017-02-26, Scott Schurr provides wording]</i></p>


<p><i>[
2017-06-27 P2 after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[2016-07, Toronto Thursday night issues processing]</i></p>

<p>The description doesn't match the resolution; Alisdair to investigate. Status to Open</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>
<ol>
<li><p>Modify 20.5.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a> as indicated:</p>

<blockquote>
<pre>
<i>// 20.5.3.1, tuple construction</i>
<i>EXPLICIT</i> constexpr tuple();
<i>EXPLICIT</i> constexpr tuple(const Types&amp;...); <i>// only if sizeof...(Types) &gt;= 1</i>
template &lt;class... UTypes&gt;
<i>EXPLICIT</i> constexpr tuple(UTypes&amp;&amp;...) <ins>noexcept(<i>see below</i>)</ins>; <i>// only if sizeof...(Types) &gt;= 1</i>

tuple(const tuple&amp;) = default;
tuple(tuple&amp;&amp;) = default;

template &lt;class... UTypes&gt;
<i>EXPLICIT</i> constexpr tuple(const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... UTypes&gt;
<i>EXPLICIT</i> constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp;) <ins>noexcept(<i>see below</i>)</ins>;

template &lt;class U1, class U2&gt;
<i>EXPLICIT</i> constexpr tuple(const pair&lt;U1, U2&gt;&amp;); <i>// only if sizeof...(Types) == 2</i>
template &lt;class U1, class U2&gt;
<i>EXPLICIT</i> constexpr tuple(pair&lt;U1, U2&gt;&amp;&amp;) <ins>noexcept(<i>see below</i>)</ins>; <i>// only if sizeof...(Types) == 2</i>

[&hellip;]

<i>// 20.5.3.2, tuple assignment</i>
tuple&amp; operator=(const tuple&amp;);
tuple&amp; operator=(tuple&amp;&amp;) noexcept(<i>see below</i>);

template &lt;class... UTypes&gt;
tuple&amp; operator=(const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... UTypes>
tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp;) <ins>noexcept(<i>see below</i>)</ins>;

template &lt;class U1, class U2&gt;
tuple&amp; operator=(const pair&lt;U1, U2&gt;&amp;); <i>// only if sizeof...(Types) == 2</i>
template &lt;class U1, class U2&gt;
tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp;) <ins>noexcept(<i>see below</i>)</ins>; <i>// only if sizeof...(Types) == 2</i>
</pre>
</blockquote>
</li>

<li><p>Modify 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class... UTypes&gt; <i>EXPLICIT</i> constexpr tuple(UTypes&amp;&amp;... u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Initializes the elements in the tuple with the corresponding value in <tt>std::forward&lt;UTypes&gt;(u)</tt>.
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution unless <tt>sizeof...(Types) ==
sizeof...(UTypes)</tt> and <tt>sizeof...(Types) >= 1</tt> and <tt>is_constructible_v&lt;T<sub><i>i</i></sub>, 
U<sub><i>i</i></sub>&amp;&amp;&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>. The constructor is explicit if and only if 
<tt>is_convertible_v&lt;U<sub><i>i</i></sub>&amp;&amp;, T<sub><i>i</i></sub>&gt;</tt> is <tt>false</tt> for at least one 
<tt><i>i</i></tt>. <ins>The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_constructible_v&lt;T<sub><i>i</i></sub>, U<sub><i>i</i></sub>&amp;&amp;&gt;</ins>
</pre></blockquote>
<p>
<ins>where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>Types</tt>, and
<tt>U<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>UTypes</tt>.</ins>
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template &lt;class... UTypes&gt; <i>EXPLICIT</i> constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp; u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-16- <i>Effects:</i> For all <tt><i>i</i></tt>, initializes the <tt><i>i</i></tt><sup>th</sup> element of <tt>*this</tt> with 
<tt>std::forward&lt;U<sub><i>i</i></sub>&gt;(get&lt;<i>i</i>&gt;(u))</tt>.
<p/>
-17- <i>Remarks:</i> This constructor shall not participate in overload resolution unless
<p/>
[&hellip;]
<p/>
The constructor is explicit if and only if <tt>is_convertible_v&lt;U<sub><i>i</i></sub>&amp;&amp;, T<sub><i>i</i></sub>&gt;</tt> 
is <tt>false</tt> for at least one <tt><i>i</i></tt>. <ins>The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_constructible_v&lt;T<sub><i>i</i></sub>, U<sub><i>i</i></sub>&amp;&amp;&gt;</ins>
</pre></blockquote>
<p>
<ins>where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>Types</tt>, and
<tt>U<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>UTypes</tt>.</ins>
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template &lt;class U1, class U2&gt; <i>EXPLICIT</i> constexpr tuple(pair&lt;U1, U2&gt;&amp;&amp; u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-21- <i>Effects:</i> Initializes the first element with <tt>std::forward&lt;U1&gt;(u.first)</tt> and the second element with
<tt>std::forward&lt;U2&gt;(u.second)</tt>.
<p/>
-22- <i>Remarks:</i> This constructor shall not participate in overload resolution unless <tt>sizeof...(Types) == 2</tt>,
<tt>is_constructible_v&lt;T0, U1&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt>is_constructible_v&lt;T1, U2&amp;&amp;&gt;</tt> is <tt>true</tt>.
<p/>
-23- The constructor is explicit if and only if <tt>is_convertible_v&lt;U1&amp;&amp;, T0&gt;</tt> is <tt>false</tt> or 
<tt>is_convertible_v&lt;U2&amp;&amp;, T1&gt;</tt> is <tt>false</tt>. <ins>The expression inside <tt>noexcept</tt> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_constructible_v&lt;T0, U1&amp;&amp;&gt; &amp;&amp; is_nothrow_constructible_v&lt;T1, U2&amp;&amp;&gt;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.assign">[tuple.assign]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class... UTypes&gt; tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp; u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-12- <i>Effects:</i> For all <tt><i>i</i></tt>, assigns <tt>std::forward&lt;U<sub><i>i</i></sub>&gt;(get&lt;<i>i</i>&gt;(u))</tt> 
to <tt>get&lt;<i>i</i>&gt;(*this)</tt>.
<p/>
-13- <i>Remarks:</i> This operator shall not participate in overload resolution unless <tt>is_assignable_v&lt;T<sub><i>i</i></sub>&amp;, 
U<sub><i>i</i></sub>&amp;&amp;&gt; == true</tt> for all <tt><i>i</i></tt> and <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
<ins>The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_assignable_v&lt;T<sub><i>i</i></sub>&amp;, U<sub><i>i</i></sub>&amp;&amp;&gt;</ins>
</pre></blockquote>
<p>
<ins>where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>Types</tt>, and
<tt>U<sub><i>i</i></sub></tt> is the <tt><i>i</i></tt><sup>th</sup> type in <tt>UTypes</tt>.</ins>
</p>
<p>
-14- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template &lt;class U1, class U2&gt; tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp; u) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
-18- <i>Effects:</i> Assigns <tt>std::forward&lt;U1&gt;(u.first)</tt> to the first element of <tt>*this</tt> and
<tt>std::forward&lt;U2&gt;(u.second)</tt> to the second element of <tt>*this</tt>.
<p/>
-19- <i>Remarks:</i> This operator shall not participate in overload resolution unless <tt>sizeof...(Types) == 2</tt>
and <tt>is_assignable_v&lt;T0&amp;, U1&amp;&amp;&gt;</tt> is <tt>true</tt> for the first type <tt>T0</tt> in <tt>Types</tt> 
and <tt>is_assignable_v&lt;T1&amp;, U2&amp;&amp;&gt;</tt> is <tt>true</tt> for the second type <tt>T1</tt> in <tt>Types</tt>.
<ins>The expression inside <tt>noexcept</tt> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>is_nothrow_assignable_v&lt;T0&amp;, U1&amp;&amp;&gt; &amp;&amp; is_nothrow_assignable_v&lt;T1&amp;, U2&amp;&amp;&gt;</ins>
</pre></blockquote>
<p>
-20- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-02-14; Jonathan comments and provides revised wording]</i></p>

<p>
The suggested change was already made to <tt>std::optional</tt> by LWG <a href="2756">2756</a>. The current P/R for 2899 
doesn't resolve the issue for <tt>std::tuple</tt> or <tt>std::unique_ptr</tt>. I hope the following alternative does.
</p>

<p><i>[2019-02; Kona Wednesday night issue processing]</i></p>

<p>Status to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4800">N4800</a>.
</p>
<ol>
<li><p>Modify 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
tuple(tuple&amp;&amp; u) = default;
</pre>
<blockquote>
<p>
-13- <i><del>Requires</del><ins>Constraints</ins>:</i> <tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>.
<p/>
-14- <i>Effects:</i> For all <tt><i>i</i></tt>, initializes the <tt><i>i</i></tt><sup>th</sup> element of 
<tt>*this</tt> with <tt>std::forward&lt;T<sub><i>i</i></sub>&gt;(get&lt;<i>i</i>&gt;(u))</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.11.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a> as indicated:</p>

<blockquote>
<pre>
unique_ptr(unique_ptr&amp;&amp; u) noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>is_move_constructible_v&lt;D&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-15- <i>Requires:</i> If <tt>D</tt> is not a reference type, <tt>D</tt> shall satisfy the 
<i>Cpp17MoveConstructible</i> requirements (Table 26). Construction of the deleter from an 
rvalue of type <tt>D</tt> shall not throw an exception.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.11.1.2.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.asgn">[unique.ptr.single.asgn]</a> as indicated:</p>

<blockquote>
<pre>
unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>is_move_assignable_v&lt;D&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-1- <i>Requires:</i> If <tt>D</tt> is not a reference type, <tt>D</tt> shall satisfy the 
<i>Cpp17MoveAssignable</i> requirements (Table 28) and assignment of the deleter from an 
rvalue of type <tt>D</tt> shall not throw an exception. Otherwise, <tt>D</tt> is a reference 
type; <tt>remove_reference_t&lt;D&gt;</tt> shall satisfy the <i>Cpp17CopyAssignable</i> 
requirements and assignment of the deleter from an lvalue of type <tt>D</tt> shall not throw an exception.
<p/>
-2- <i>Effects:</i> Calls <tt>reset(u.release())</tt> followed by <tt>get_deleter() = std::forward&lt;D&gt;(u.get_deleter())</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3055" href="3055">3055.</a> <tt>path::operator+=(<i>single-character</i>)</tt> misspecified</h3>
<p><b>Section:</b> 29.11.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/fs.path.concat">[fs.path.concat]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-01-24 <b>Last modified:</b> 2019-02-21 17:23:36 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.path.concat">issues</a> in [fs.path.concat].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.11.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/fs.path.concat">[fs.path.concat]</a> uses the expression <tt>path(x).native()</tt> to specify the effects of
concatenating a single character <tt>x</tt>. However, there is no <tt>path</tt> constructor taking a single character.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>

<p><i>[2018-10-12 Tim updates PR to avoid suggesting the creation of a temporary <tt>path</tt>.]</i></p>

  
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4713">N4713</a>.</p>
<ol>
<li><p>Modify 29.11.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/fs.path.concat">[fs.path.concat]</a> as indicated:</p>

<blockquote>
<pre>
path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(basic_string_view&lt;value_type&gt; x);
path&amp; operator+=(const value_type* x);
<del>path&amp; operator+=(value_type x);</del>
template&lt;class Source&gt;
  path&amp; operator+=(const Source&amp; x);
<del>template&lt;class EcharT&gt;
  path&amp; operator+=(EcharT x);</del>
template&lt;class Source&gt;
  path&amp; concat(const Source&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> [&hellip;]
<p/>
-2- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
<pre>
<ins>path&amp; operator+=(value_type x);
template&lt;class EcharT&gt;
  path&amp; operator+=(EcharT x);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Equivalent to: <tt>return *this += path(&amp;x, &amp;x + 1);</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-02; Kona Wednesday night issue processing]</i></p>

<p>Status to Ready</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4762">N4762</a>.</p>
<ol>
<li><p>Modify 29.11.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/fs.path.concat">[fs.path.concat]</a> as indicated:</p>

<blockquote>
<pre>
path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(basic_string_view&lt;value_type&gt; x);
path&amp; operator+=(const value_type* x);
<del>path&amp; operator+=(value_type x);</del>
template&lt;class Source&gt;
  path&amp; operator+=(const Source&amp; x);
<del>template&lt;class EcharT&gt;
  path&amp; operator+=(EcharT x);</del>
template&lt;class Source&gt;
  path&amp; concat(const Source&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> [&hellip;]
<p/>
-2- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
<pre>
<ins>path&amp; operator+=(value_type x);
template&lt;class EcharT&gt;
  path&amp; operator+=(EcharT x);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Equivalent to: <tt>return *this += basic_string_view(&amp;x, 1);</tt></ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3158" href="3158">3158.</a> <tt>tuple(allocator_arg_t, const Alloc&amp;)</tt> should be conditionally explicit</h3>
<p><b>Section:</b> 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-08-21 <b>Last modified:</b> 2019-02-21 17:23:36 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::tuple</tt>'s allocator-extended constructors say "<i>Effects:</i> Equivalent to the preceding constructors except 
that each element is constructed with uses-allocator construction". That's not true for the first one, as shown by:
</p>
<blockquote><pre>
#include &lt;tuple&gt;

struct X { explicit X() { } };

std::tuple&lt;X&gt; f() { return {}; }
std::tuple&lt;X&gt; g() { return { std::allocator_arg, std::allocator&lt;int&gt;{} }; }
</pre></blockquote>
<p>
The function <tt>f()</tt> doesn't compile because of the explicit constructor, but <tt>g()</tt> does, despite using the 
same constructor for <tt>X</tt>. The conditional explicit-ness is not equivalent.
<p/>
Also, the editor requested that we change "implicitly default-constructible" to use words that mean something. He suggested "copy-list-initializable from an empty list".
</p>

<p><i>[2018-09 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>
<p><i>[2019-02; Kona Wednesday night issue processing]</i></p>

<p>Status to Ready</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ol>
<li><p>Modify 20.5.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, class template <tt>tuple</tt> synopsis, as indicated:</p>
<blockquote><pre>
[&hellip;]
<i>// allocator-extended constructors</i>
template&lt;class Alloc&gt;
  <ins>explicit(<i>see below</i>)</ins> tuple(allocator_arg_t, const Alloc&amp; a);
template&lt;class Alloc&gt;
  explicit(<i>see below</i>) tuple(allocator_arg_t, const Alloc&amp; a, const Types&amp;...);
[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>, as indicated:</p>

<blockquote>
<pre>
explicit(<i>see below</i>) constexpr tuple();
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Value-initializes each element.
<p/>
-6- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_default_constructible_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all 
<tt><i>i</i></tt>. [<i>Note:</i> This behavior can be implemented by a constructor template with default template 
arguments. &mdash; <i>end note</i>] The expression inside <tt>explicit</tt> evaluates to <tt>true</tt> if
and only if <tt>T<sub><i>i</i></sub></tt> is not <del>implicitly default-constructible</del>
<ins>copy-list-initializable from an empty list</ins> for at least one <tt><i>i</i></tt>. 
[<i>Note:</i> This behavior can be implemented with a trait that checks whether a 
<tt>const T<sub><i>i</i></sub>&amp;</tt> can be initialized with <tt>{}</tt>. &mdash; <i>end note</i>]
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template&lt;class Alloc&gt;
  <ins>explicit(<i>see below</i>)</ins> tuple(allocator_arg_t, const Alloc&amp; a);
template&lt;class Alloc&gt;
  explicit(<i>see below</i>) tuple(allocator_arg_t, const Alloc&amp; a, const Types&amp;...);
[&hellip;]
template&lt;class Alloc, class U1, class U2&gt;
  explicit(<i>see below</i>) tuple(allocator_arg_t, const Alloc&amp; a, pair&lt;U1, U2&gt;&amp;&amp;);
</pre>
<blockquote>
<p>
-25- <i>Requires:</i> <tt>Alloc</tt> shall satisfy the <tt><i>Cpp17Allocator</i></tt> requirements (Table 33).
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3169" href="3169">3169.</a> <tt>ranges</tt> permutation generators discard useful information</h3>
<p><b>Section:</b> 25.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.permutation.generators">[alg.permutation.generators]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-11-26 <b>Last modified:</b> 2019-02-21 17:23:36 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the Ranges design, algorithms that necessarily traverse an entire range -
consequently discovering the end iterator value - return that iterator value
unless the algorithm's sole purpose is to return a derived value,
for example, <tt>ranges::count</tt>.
<tt>ranges::next_permutation</tt> and <tt>ranges::prev_permutation</tt>
necessarily traverse the entirety of their range argument, but are currently
specified to discard the end iterator value and return only a <tt>bool</tt>
indicating whether they found a next (respectively previous) permutation or
"reset" the range to the first (respectively last) permutation.
They should instead return an aggregate composed of both
that <tt>bool</tt> and the end iterator value to be consistent with the other
<tt>range</tt> algorithms.
</p>

<p><i>[2019-01-22; Daniel comments and updates wording]</i></p>

<p>
During the reflector discussion it had been noticed that an additional update of
25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> p.16 is necessary for the new type
<tt>next_permutation_result</tt> and two missing occurrences of <tt>iterator_t&lt;&gt;</tt> where
added. The proposed wording has been updated.
</p>

<p><i>[2019-02-02 Priority to 0 and Status to Tentatively Ready after five positive votes on the reflector.]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> as follows:</p>

<blockquote>
<p>
-16- The class templates <tt>binary_transform_result</tt>, <tt>for_each_result</tt>,
<tt>minmax_result</tt>, <tt>mismatch_result</tt><ins>, <tt>next_permutation_result</tt></ins>,
<tt>copy_result</tt>, and <tt>partition_copy_result</tt> have the template parameters, data members,
and special members specified above. They have no base classes or members other than those specified.
</p>
</blockquote>
</li>

<li><p>Modify 25.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a> as follows:</p>

<blockquote>
<pre>
  // 25.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.permutation.generators">[alg.permutation.generators]</a>, permutations
  template&lt;class BidirectionalIterator&gt;
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    <ins>template&lt;class I&gt;</ins>
    <ins>struct next_permutation_result {</ins>
      <ins>bool found;</ins>
      <ins>I in;</ins>
    <ins>};</ins>

    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr <del>bool</del><ins>next_permutation_result&lt;I&gt;</ins>
        next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr <del>bool</del><ins>next_permutation_result&lt;iterator_t&lt;R&gt;&gt;</ins>
        next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }

  template&lt;class BidirectionalIterator&gt;
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    <ins>template&lt;class I&gt;</ins>
    <ins>using prev_permutation_result = next_permutation_result&lt;I&gt;;</ins>

    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr <del>bool</del><ins>prev_permutation_result&lt;I&gt;</ins>
        prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr <del>bool</del><ins>prev_permutation_result&lt;iterator_t&lt;R&gt;&gt;</ins>
        prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.permutation.generators">[alg.permutation.generators]</a> as follows:</p>

<blockquote>
<blockquote>
<pre>
template&lt;class BidirectionalIterator>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);
template&lt;class BidirectionalIterator, class Compare>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);

namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I> S, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    constexpr <del>bool</del><ins>next_permutation_result&lt;I&gt;</ins>
      next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
  template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr <del>bool</del><ins>next_permutation_result&lt;iterator_t&lt;R&gt;&gt;</ins>
      next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
}
</pre>
</blockquote>
[&hellip;]
<p>-4- <i>Returns:</i> <ins>Let <tt>B</tt> be</ins> <tt>true</tt>
  if <del>and only if</del> a next permutation was found
  <ins>and otherwise <tt>false</tt></ins>. <ins>Returns:</ins></p>
<ul>
<li><p><ins><tt>B</tt> for the overloads in namespace <tt>std</tt>,
  or</ins></p></li>
<li><p><ins><tt>{ B, last }</tt> for the overloads
  in namespace <tt>ranges</tt>.</ins></p></li>
</ul>
<p>-5- <i>Complexity:</i> [&hellip;]</p>
<blockquote>
<pre>
template&lt;class BidirectionalIterator&gt;
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);
template&lt;class BidirectionalIterator, class Compare&gt;
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);

namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    constexpr <del>bool</del><ins>prev_permutation_result&lt;I&gt;</ins>
      prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
  template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr <del>bool</del><ins>prev_permutation_result&lt;iterator_t&lt;R&gt;&gt;</ins>
      prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
}
</pre>
</blockquote>
[&hellip;]
<p>-9- <i>Returns:</i> <ins>Let <tt>B</tt> be</ins> <tt>true</tt>
  if <del>and only if</del> a previous permutation was found
  <ins>and otherwise <tt>false</tt></ins>. Returns:</p>
<ul>
<li><p><ins><tt>B</tt> for the overloads in namespace <tt>std</tt>, or</ins></p></li>
<li><p><ins><tt>{ B, last }</tt> for the overloads in namespace <tt>ranges</tt>.</ins></p></li>
</ul>
<p>-10- <i>Complexity:</i> [&hellip;]</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-02-10 Tomasz comments; Casey updates the P/R and resets status to "Review."]</i></p>

Shouldn't the range overloads for an algorithms return
<tt>safe_iterator_t&lt;R&gt;</tt> instead of <tt>iterator_t&lt;R&gt;</tt>?
Other algorithms are consistently returning the
<tt>safe_iterator_t</tt>/<tt>safe_subrange_t</tt> in situation, when range
argument is an rvalue (temporary) and returned iterator may  be dangling.

<p><i>[2019-02; Kona Wednesday night issue processing]</i></p>

<p>Status to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4800">N4800</a>.</p>

<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> as follows:</p>

<blockquote>
<p>
-16- The class templates <tt>binary_transform_result</tt>, <tt>for_each_result</tt>,
<tt>minmax_result</tt>, <tt>mismatch_result</tt><ins>, <tt>next_permutation_result</tt></ins>,
<tt>copy_result</tt>, and <tt>partition_copy_result</tt> have the template parameters, data members,
and special members specified above. They have no base classes or members other than those specified.
</p>
</blockquote>
</li>

<li><p>Modify 25.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a> as follows:</p>

<blockquote>
<pre>
  // 25.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.permutation.generators">[alg.permutation.generators]</a>, permutations
  template&lt;class BidirectionalIterator&gt;
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    <ins>template&lt;class I&gt;</ins>
    <ins>struct next_permutation_result {</ins>
      <ins>bool found;</ins>
      <ins>I in;</ins>
    <ins>};</ins>

    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr <del>bool</del><ins>next_permutation_result&lt;I&gt;</ins>
        next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr <del>bool</del><ins>next_permutation_result&lt;safe_iterator_t&lt;R&gt;&gt;</ins>
        next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }

  template&lt;class BidirectionalIterator&gt;
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    <ins>template&lt;class I&gt;</ins>
    <ins>using prev_permutation_result = next_permutation_result&lt;I&gt;;</ins>

    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr <del>bool</del><ins>prev_permutation_result&lt;I&gt;</ins>
        prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr <del>bool</del><ins>prev_permutation_result&lt;safe_iterator_t&lt;R&gt;&gt;</ins>
        prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.permutation.generators">[alg.permutation.generators]</a> as follows:</p>

<blockquote>
<blockquote>
<pre>
template&lt;class BidirectionalIterator>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);
template&lt;class BidirectionalIterator, class Compare>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);

namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I> S, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    constexpr <del>bool</del><ins>next_permutation_result&lt;I&gt;</ins>
      next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
  template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr <del>bool</del><ins>next_permutation_result&lt;safe_iterator_t&lt;R&gt;&gt;</ins>
      next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
}
</pre>
</blockquote>
[&hellip;]
<p>-4- <i>Returns:</i> <ins>Let <tt>B</tt> be</ins> <tt>true</tt>
  if <del>and only if</del> a next permutation was found
  <ins>and otherwise <tt>false</tt></ins>. <ins>Returns:</ins></p>
<ul>
<li><p><ins><tt>B</tt> for the overloads in namespace <tt>std</tt>,
  or</ins></p></li>
<li><p><ins><tt>{ B, last }</tt> for the overloads
  in namespace <tt>ranges</tt>.</ins></p></li>
</ul>
<p>-5- <i>Complexity:</i> [&hellip;]</p>
<blockquote>
<pre>
template&lt;class BidirectionalIterator&gt;
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);
template&lt;class BidirectionalIterator, class Compare&gt;
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);

namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    constexpr <del>bool</del><ins>prev_permutation_result&lt;I&gt;</ins>
      prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
  template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr <del>bool</del><ins>prev_permutation_result&lt;safe_iterator_t&lt;R&gt;&gt;</ins>
      prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
}
</pre>
</blockquote>
[&hellip;]
<p>-9- <i>Returns:</i> <ins>Let <tt>B</tt> be</ins> <tt>true</tt>
  if <del>and only if</del> a previous permutation was found
  <ins>and otherwise <tt>false</tt></ins>. Returns:</p>
<ul>
<li><p><ins><tt>B</tt> for the overloads in namespace <tt>std</tt>, or</ins></p></li>
<li><p><ins><tt>{ B, last }</tt> for the overloads in namespace <tt>ranges</tt>.</ins></p></li>
</ul>
<p>-10- <i>Complexity:</i> [&hellip;]</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3183" href="3183">3183.</a> Normative permission to specialize Ranges variable templates</h3>
<p><b>Section:</b> 23.3.4.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.sizedsentinel">[iterator.concept.sizedsentinel]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2019-01-14 <b>Last modified:</b> 2019-02-03 12:20:33 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/p0896r4">P0896R4 "The One Ranges Proposal"</a> added
boolean variable templates <tt>std::disable_sized_sentinel</tt> and
<tt>std::ranges::disable_sized_range</tt> which users are intended to specialize
to <tt>false</tt> for program-defined <tt>Iterator</tt>-<tt>Sentinel</tt> pairs
/ <tt>Range</tt> types which meet the syntax but do not model
the semantics of the <tt>SizedSentinel</tt> / <tt>SizedRange</tt> concepts,
respectively. Specializing these traits allows the use of such types with the
library which would otherwise treat them as if they model <tt>SizedSentinel</tt>
/ <tt>SizedRange</tt>. The wording in P0896R4 failed, however, to provide
normative permission to specialize these variable templates as is required by
16.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> after the application of
<a href="https://wg21.link/p0551r3">P0551R3</a>.
</p><p>
Furthermore, 16.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> notably does not require that
program-defined specializations of standard library variable templates meet the
requirements on the primary template (as is the case for class templates) or
indeed any requirements. P0896R4 also added the <tt>enable_view</tt> variable
template which is used to explicitly opt in or out of the <tt>View</tt> concept
24.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.view">[range.view]</a> when the default chosen by the heuristic is
incorrect. P0896R4 did include normative permission to specialize
<tt>enable_view</tt>, but the wording does not place sufficient requirements on
such user specializations so as to make them usable by the <tt>View</tt> concept
definition. Specializations must be required to be usable as constant
expressions of type <tt>bool</tt> to avoid hard errors in the concept.
</p>

<p><i>[2019-02-03 Priority to 0 and Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> This wording uses the recently-defined core language term
"usable in constant expressions" from 7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a> paragraph 3
which may be unfamiliar to reviewers.]
</p>
</blockquote>

<ol>
<li><p>Change 23.3.4.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.sizedsentinel">[iterator.concept.sizedsentinel]</a> as follows:</p>
<blockquote>
<p>
[&hellip;]
</p><p>
(2.2) &mdash; If <tt>−N</tt> is representable by
<tt>iter_difference_t&lt;I&gt;</tt>, then <tt>i - s</tt> is well-defined and
equals <tt>−N</tt>.
</p><p>
<ins>-?- Pursuant to 16.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>, users may specialize
<tt>disable_sized_sentinel</tt> for cv-unqualified non-array object types
<tt>S</tt> and <tt>I</tt> at least one of which is a program-defined type.
Such specializations shall be usable in constant expressions
(7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) and have type <tt>const bool</tt>.</ins>
</p><p>
3 [<i>Note:</i> <tt>disable_sized_sentinel</tt> allows use of sentinels and
iterators with the library that satisfy but do not in fact model
<tt>SizedSentinel</tt>.&mdash;<i>end note</i>]
</p><p>
[&hellip;]
</p>
</blockquote>
</li>
<li><p>Add an index entry for <tt>disable_sized_sentinel</tt> that points to
 [iterator.concepts.sizedsentinel].</p>
</li>
<li><p>Change 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a> as follows:</p>
<blockquote>
<p>
[&hellip;]
</p><p>
3 [<i>Note:</i> The complexity requirement for the evaluation of
<tt>ranges::size</tt> is non-amortized, unlike the case for the complexity of
the evaluations of <tt>ranges::begin</tt> and <tt>ranges::end</tt> in the
<tt>Range</tt> concept.&mdash;<i>end note</i>]
</p><p>
<ins>-?- Pursuant to 16.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>, users may specialize
<tt>disable_sized_range</tt> for cv-unqualified program-defined types.
Such specializations shall be usable in constant expressions
(7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) and have type <tt>const bool</tt>.</ins>
</p><p>
4 [<i>Note:</i> <tt>disable_sized_range</tt> allows use of range types with the
library that satisfy but do not in fact model <tt>SizedRange</tt>.&mdash;<i>end
note</i>]
</p>
</blockquote>
</li>
<li><p>Add an index entry for <tt>disable_sized_range</tt> that points to
24.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>.</p>
</li>
<li><p>Change 24.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.view">[range.view]</a> as follows:</p>
<blockquote>
<p>
[&hellip;]
</p><p>
5 Pursuant to 16.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>, users may specialize
<tt>enable_view</tt> to <tt>true</tt> for <ins>cv-unqualified
program-defined</ins> types which model <tt>View</tt>, and <tt>false</tt> for
types which do not. <ins>Such specializations shall be usable in constant
expressions (7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) and have type <tt>const bool</tt>.</ins>
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3184" href="3184">3184.</a> Inconsistencies in <tt>bind_front</tt> wording</h3>
<p><b>Section:</b> 99 [func.bind_front] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2019-01-16 <b>Last modified:</b> 2019-01-26 14:09:17 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the merge of the <a href="https://wg21.link/p0356r5">P0356R5</a>, following "oddities" of the new wording was pointed 
out by Jens Maurer:
<ol>
<li><p>The initialization of the state entities of the <tt>bind_front/not_fn</tt> is specified using formulation "<tt>xx</tt> 
initialized with the <i>initializer</i> <tt>(yyy)</tt>". Per author knowledge this specification is correct, however 
inconsistent with the other parts of the of the standard, that direct-non-list-initialization term in such context.</p></li>
<li><p>The specification of the <i>Mandates</i> element for <tt>bind_front</tt> uses <tt>conjunction_v</tt> to specify 
conjunction of the requirements, while corresponding element of the <tt>not_fn</tt> specifies it using <tt>&amp;&amp;</tt>. 
As <tt>conjuction_v</tt> implies order of evaluation that is not necessary in this case (for every valid program, all 
provided traits must evaluate to true), it may be replaced with usage of fold expression with operator <tt>&amp;&amp;</tt>.</p></li>
</ol>
</p>

<p><i>[2019-01-26 Priority to 0 and Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<ol>
<li><p>Change 99 [func.not_fn] as indicated:</p>
<blockquote>
<pre>
template&lt;class F&gt; <i>unspecified</i> not_fn(F&amp;&amp; f);
</pre>
<blockquote>
<p>
-1- In the text that follows:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; [&hellip;]</p></li>
<li><p>(1.2) &mdash; [&hellip;]</p></li>
<li><p>(1.3) &mdash; <tt>fd</tt> is the target object of <tt>g</tt> (20.14.2 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a>) of type 
<tt>FD</tt> <ins>direct-non-list-initialized with</ins><del>initialized with the <i>initializer</i></del> 
<tt><del>(</del>std::forward&lt;F&gt;(f)<del>)</del></tt><del> (9.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>)</del>,</p></li>
<li><p>(1.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>
</li>

<li><p>Change 99 [func.bind_front] as indicated:</p>
<blockquote>
<pre>
template &lt;class F, class... Args&gt;
<i>unspecified</i> bind_front(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- In the text that follows:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; [&hellip;]</p></li>
<li><p>(1.2) &mdash; [&hellip;]</p></li>
<li><p>(1.3) &mdash; <tt>fd</tt> is the target object of <tt>g</tt> (20.14.2 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a>) of type 
<tt>FD</tt> <ins>direct-non-list-initialized with</ins><del>initialized with the <i>initializer</i></del> 
<tt><del>(</del>std::forward&lt;F&gt;(f)<del>)</del></tt><del> (9.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>)</del>,</p></li>
<li><p>(1.4) &mdash; [&hellip;]</p></li>
<li><p>(1.5) &mdash; <tt>bound_args</tt> is a pack of bound argument entities of <tt>g</tt> (20.14.2 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a>) 
of types <tt>BoundArgs...</tt>, <ins>direct-non-list-initialized with</ins><del>initialized with 
<i>initializer</i>s </del><tt><del>(</del>std::forward&lt;Args&gt;(args)<del>)</del>...</tt>, 
respectively, and</p></li>
<li><p>(1.6) &mdash; [&hellip;]</p></li>
</ol>
<p>
-2- <i>Mandates:</i>
</p>
<blockquote><pre>
<ins>is_constructible_v&lt;FD, F&gt; &amp;&amp; is_move_constructible_v&lt;FD&gt; &amp;&amp; 
(is_constructible_v&lt;BoundArgs, Args&gt; &amp;&amp; ...) &amp;&amp; (is_move_constructible_v&lt;BoundArgs&gt; &amp;&amp; ...)</ins><del>conjunction_v&lt;is_constructible&lt;FD, F&gt;, is_move_constructible&lt;FD&gt;,
is_constructible&lt;BoundArgs, Args&gt;..., is_move_constructible&lt;BoundArgs&gt;...&gt;</del>
</pre></blockquote>
<p>
shall be true.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3185" href="3185">3185.</a> Uses-allocator construction functions missing <tt>constexpr</tt> and <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.10.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2019-01-29 <b>Last modified:</b> 2019-02-12 17:21:44 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.uses.construction">active issues</a> in [allocator.uses.construction].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.uses.construction">issues</a> in [allocator.uses.construction].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The uses-allocator construction functions introduced into WP when <a href="https://wg21.link/p0591r4">P0591r4</a> 
was accepted (Nov 2018, San Diego) should all be <tt>constexpr</tt>. All but two should also be <tt>noexcept</tt>. 
Getting this right is an important part of correctly adding <tt>constexpr</tt> memory allocation into the WP.
<p/>
The minimal change is to add the <tt>constexpr</tt> to all of the new functions except 
<tt>uninitialized_construct_using_allocator</tt> and <tt>noexcept</tt> to all 
of the overloads of <tt>uses_allocator_construction_args</tt>. Optionally, we could consider adding conditional 
<tt>noexcept</tt> to the remaining two functions. If <a href="https://wg21.link/p0784">p0784</a> is accepted, 
then also add <tt>constexpr</tt> to <tt>uninitialized_construct_using_allocator</tt>.
</p>

<p><i>[2019-02-12 Priority to 0 and Status to Tentatively Ready after six positive votes on the reflector.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4800">N4800</a>.</p>

<ol>
<li><p>Change header <tt>&lt;memory&gt;</tt> synopsis, 20.10.2 <a href="https://timsong-cpp.github.io/cppwp/memory.syn">[memory.syn]</a>, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
<i>// 20.10.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>, uses-allocator construction</i>
template &lt;class T, class Alloc, class... Args&gt;
<ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, Args&amp;&amp;... args) <ins>noexcept</ins> -&gt; <i>see below</i>;
template &lt;class T, class Alloc, class Tuple1, class Tuple2&gt;
<ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, piecewise_construct_t,
                                      Tuple1&amp;&amp; x, Tuple2&amp;&amp; y) <ins>noexcept</ins> -&gt; <i>see below</i>;
template &lt;class T, class Alloc&gt;
<ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc) <ins>noexcept</ins> -&gt; <i>see below</i>;
template &lt;class T, class Alloc, class U, class V&gt;
<ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, U&amp;&amp; u, V&amp;&amp; v) <ins>noexcept</ins> -&gt; <i>see below</i>;
template &lt;class T, class Alloc, class U, class V&gt;
<ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, const pair&lt;U,V&gt;&amp; pr) <ins>noexcept</ins> -&gt; <i>see below</i>;
template &lt;class T, class Alloc, class U, class V&gt;
<ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, pair&lt;U,V&gt;&amp;&amp; pr) <ins>noexcept</ins> -&gt; <i>see below</i>;
template &lt;class T, class Alloc, class... Args&gt;
<ins>constexpr</ins> T make_obj_using_allocator(const Alloc&amp; alloc, Args&amp;&amp;... args);
template &lt;class T, class Alloc, class... Args&gt;
T* uninitialized_construct_using_allocator(T* p, const Alloc&amp; alloc, Args&amp;&amp;... args);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 20.10.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Alloc, class... Args&gt;
  <ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, Args&amp;&amp;... args) <ins>noexcept</ins> -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T, class Alloc, class Tuple1, class Tuple2&gt;
  <ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, piecewise_construct_t,
                                        Tuple1&amp;&amp; x, Tuple2&amp;&amp; y) <ins>noexcept</ins> -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T, class Alloc&gt;
  <ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc) <ins>noexcept</ins> -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T, class Alloc, class U, class V&gt;
  <ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, U&amp;&amp; u, V&amp;&amp; v) <ins>noexcept</ins> -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T, class Alloc, class U, class V&gt;
  <ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, const pair&lt;U,V&gt;&amp; pr) <ins>noexcept</ins> -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T, class Alloc, class U, class V&gt;
  <ins>constexpr</ins> auto uses_allocator_construction_args(const Alloc&amp; alloc, pair&lt;U,V&gt;&amp;&amp; pr) <ins>noexcept</ins> -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T, class Alloc, class... Args&gt;
  <ins>constexpr</ins> T make_obj_using_allocator(const Alloc&amp; alloc, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T, class Alloc, class... Args&gt;
  T* uninitialized_construct_using_allocator(T* p, const Alloc&amp; alloc, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3186" href="3186">3186.</a> <tt>ranges</tt> removal, partition, and <tt>partial_sort_copy</tt> algorithms discard useful information</h3>
<p><b>Section:</b> 25.6.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>, 25.6.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a>, 25.7.1.4 <a href="https://timsong-cpp.github.io/cppwp/partial.sort.copy">[partial.sort.copy]</a>, 25.7.4 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2019-02-05 <b>Last modified:</b> 2019-02-21 17:23:36 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is direct follow-up on the LWG issue <a href="3169">3169</a>, that proposed to change additional algorithms that drop the 
iterator value equal to sentinel, that needs to be always computed. These set include removal (<code>remove</code>, 
<code>remove_if</code>, and <code>unique</code>), partition (<code>partition</code>, <code>stable_partition</code>), 
and <code>partial_sort_copy</code>.
<p/>
For removal algorithms, the end of "not-erased" objects, and the "end-of-range" iterator forms a valid range of objects 
with unspecified value (that can be overwritten), thus we propose to return <code>subrange</code>.
<p/>
For partition algorithms, the end of "true" object, and the "end-of-range" iterator forms a valid range of objects for 
which predicate returns "false", thus we propose to return <code>subrange</code>.
<p/>
For <tt>partial_sort_copy</tt> we propose to return <code>partial_sort_copy_result</code> as an alias to 
<code>copy_result</code> to match other copy algorithms.
</p>

<p><i>[2019-02-12; Tomasz comments and improves proposed wording]</i></p>

<p>
Proposed wording is updated to incorporate wording comments from Casey Carter:
</p>
<ul>
<li><p>We don't need to repeat the definition of <tt>partial_sort_copy_result</tt> in 25.7.1.4 <a href="https://timsong-cpp.github.io/cppwp/partial.sort.copy">[partial.sort.copy]</a>; 
the single definition in the synopsis is sufficient.</p></li>
<li><p><tt><i>e</i></tt> is a potentially confusing choice of placeholder name for the end of the output range, given that 
we use a placeholder <tt><i>E</i></tt> for predicates in the algorithm specifications.</p></li>
</ul>
<p>
The placeholder <tt><i>e</i></tt> is replaced with <tt><i>j</i></tt> that seems not to be used in the specification of 
above algorithms.
</p>

<p><i>[2019-02 Priority set to 1 after reflector discussion]</i></p>

<p><i>[2019-02; Kona Wednesday night issue processing]</i></p>

<p>Status to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4800">N4800</a>.</p>

<ol>
<li><p>Change header <tt>&lt;algorithm&gt;</tt> synopsis, 25.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a>, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
<i>//25.6.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>, remove</i>
[&hellip;]
namespace ranges {
template&lt;Permutable I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;ranges::equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> remove(I first, S last, const T&amp; value, Proj proj = {});
template&lt;ForwardRange R, class T, class Proj = identity&gt;
  requires Permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
           IndirectRelation&lt;ranges::equal_to&lt;&gt;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
  constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
    remove(R&amp;&amp; r, const T&amp; value, Proj proj = {});
template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> remove_if(I first, S last, Pred pred, Proj proj = {});
template&lt;ForwardRange R, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;R&gt;&gt;
  constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
    remove_if(R&amp;&amp; r, Pred pred, Proj proj = {});
}
[&hellip;]
<i>// 25.6.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a>, unique</i>
[&hellip;]
namespace ranges {
  template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&lt;&gt;&gt;
    constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> unique(I first, S last, C comp = {}, Proj proj = {});
  template&lt;ForwardRange R, class Proj = identity,
           IndirectRelation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&lt;&gt;&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
    constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
      unique(R&amp;&amp; r, C comp = {}, Proj proj = {});
}
[&hellip;]
<i>// 25.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.sort">[alg.sort]</a>, sorting</i>
[&hellip;]
namespace ranges {
  <ins>template&lt;class I, class O&gt; using partial_sort_copy_result = copy_result&lt;I, O&gt;;</ins>

  template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, RandomAccessIterator I2, Sentinel&lt;I2&gt; S2,
           class Comp = ranges::less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;I1, I2&gt; &amp;&amp; Sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
             IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
    constexpr <ins>partial_sort_copy_result&lt;I1, </ins>I2<ins>&gt;</ins>
      partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template&lt;InputRange R1, RandomAccessRange R2, class Comp = ranges::less&lt;&gt;,
           class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt; &amp;&amp;
             Sortable&lt;iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;
             IndirectStrictWeakOrder&lt;Comp, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                     projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;
    constexpr <ins>partial_sort_copy_result&lt;safe_iterator_t&lt;R1&gt;, </ins>safe_iterator_t&lt;R2&gt;<ins>&gt;</ins>
      partial_sort_copy(R1&amp;&amp; r, R2&amp;&amp; result_r, Comp comp = {},
                        Proj1 proj1 = {}, Proj2 proj2 = {});
}
[&hellip;]
<i>// 25.7.4 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a>, partitions</i>
[&hellip;]
namespace ranges {
  template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins>
      partition(I first, S last, Pred pred, Proj proj = {});
  template&lt;ForwardRange R, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
    constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
      partition(R&amp;&amp; r, Pred pred, Proj proj = {});
}
[&hellip;]
namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;I&gt;
      <ins>subrange&lt;</ins>I<ins>&gt;</ins> stable_partition(I first, S last, Pred pred, Proj proj = {});
  template&lt;BidirectionalRange R, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt; stable_partition(R&amp;&amp; r, Pred pred, Proj proj = {});
}
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 25.6.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
namespace ranges {
template&lt;Permutable I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;ranges::equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> remove(I first, S last, const T&amp; value, Proj proj = {});
template&lt;ForwardRange R, class T, class Proj = identity&gt;
  requires Permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
           IndirectRelation&lt;ranges::equal_to&lt;&gt;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
  constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
    remove(R&amp;&amp; r, const T&amp; value, Proj proj = {});
template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> remove_if(I first, S last, Pred pred, Proj proj = {});
template&lt;ForwardRange R, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;R&gt;&gt;
  constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
    remove_if(R&amp;&amp; r, Pred pred, Proj proj = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Returns:</i> <ins>Let <code><i>j</i></code> be t</ins><del>T</del>he end of the resulting range. <ins>Returns:</ins>
<ol style="list-style-type: none">
<li><p><ins>(4.?) &mdash; <code><i>j</i></code> for the overloads in namespace <tt>std</tt>, or</ins></p></li>
<li><p><ins>(4.?) &mdash; <tt>{<i>j</i>, last}</tt> for the overloads in namespace <tt>ranges</tt>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 25.6.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&lt;&gt;&gt;
    constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins> unique(I first, S last, C comp = {}, Proj proj = {});
  template&lt;ForwardRange R, class Proj = identity,
           IndirectRelation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&lt;&gt;&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
    constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
      unique(R&amp;&amp; r, C comp = {}, Proj proj = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Returns:</i> <ins>Let <code><i>j</i></code> be t</ins><del>T</del>he end of the resulting range. <ins>Returns:</ins>
<ol style="list-style-type: none">
<li><p><ins>(4.?) &mdash; <code><i>j</i></code> for the overloads in namespace <tt>std</tt>, or</ins></p></li>
<li><p><ins>(4.?) &mdash; <tt>{<i>j</i>, last}</tt> for the overloads in namespace <tt>ranges</tt>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 25.7.1.4 <a href="https://timsong-cpp.github.io/cppwp/partial.sort.copy">[partial.sort.copy]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, RandomAccessIterator I2, Sentinel&lt;I2&gt; S2,
           class Comp = ranges::less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;I1, I2&gt; &amp;&amp; Sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
             IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
    constexpr <ins>partial_sort_copy_result&lt;I1, </ins>I2<ins>&gt;</ins>
      partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  template&lt;InputRange R1, RandomAccessRange R2, class Comp = ranges::less&lt;&gt;,
           class Proj1 = identity, class Proj2 = identity&gt;
    requires IndirectlyCopyable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt; &amp;&amp;
             Sortable&lt;iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;
             IndirectStrictWeakOrder&lt;Comp, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                     projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;
    constexpr <ins>partial_sort_copy_result&lt;safe_iterator_t&lt;R1&gt;, </ins>safe_iterator_t&lt;R2&gt;<ins>&gt;</ins>
      partial_sort_copy(R1&amp;&amp; r, R2&amp;&amp; result_r, Comp comp = {},
                        Proj1 proj1 = {}, Proj2 proj2 = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Returns:</i> 
<ol style="list-style-type: none">
<li><p><ins>(4.?) &mdash;</ins> <tt>result_first + <i>N</i></tt> <ins>for the overloads in namespace <tt>std</tt>, or</ins></p></li>
<li><p><ins>(4.?) &mdash; <tt>{last, result_first + <i>N</i>}</tt> for the overloads in namespace <tt>ranges</tt>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 25.7.4 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr <ins>subrange&lt;</ins>I<ins>&gt;</ins>
      partition(I first, S last, Pred pred, Proj proj = {});
  template&lt;ForwardRange R, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
    constexpr safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt;
      partition(R&amp;&amp; r, Pred pred, Proj proj = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Returns:</i> <ins>Let <code>i</code> be a</ins><del>A</del>n iterator <del><tt>i</tt></del> such that <tt><i>E</i>(*j)</tt> is 
<tt>true</tt> for every iterator <tt>j</tt> in <tt>[first, i)</tt> and <tt>false</tt> for every iterator <tt>j</tt> in 
<tt>[i, last)</tt>. <ins>Returns:</ins>
<ol style="list-style-type: none">
<li><p><ins>(7.?) &mdash; <code>i</code> for the overloads in namespace <tt>std</tt>, or</ins></p></li>
<li><p><ins>(7.?) &mdash; <tt>{i, last}</tt> for the overloads in namespace <tt>ranges</tt>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;I&gt;
      <ins>subrange&lt;</ins>I<ins>&gt;</ins> stable_partition(I first, S last, Pred pred, Proj proj = {});
  template&lt;BidirectionalRange R, class Proj = identity,
           IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      safe_<ins>subrange</ins><del>iterator</del>_t&lt;R&gt; stable_partition(R&amp;&amp; r, Pred pred, Proj proj = {});
}
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-11- <i>Returns:</i> <ins>Let <code>i</code> be a</ins><del>A</del>n iterator <del><tt>i</tt></del> such that for every iterator 
<tt>j</tt> in <tt>[first, i)</tt>, <tt><i>E</i>(*j)</tt> is <tt>true</tt>, and for every iterator <tt>j</tt> in the range 
<tt>[i, last)</tt>, <tt><i>E</i>(*j)</tt> is <tt>false</tt><del>,</del><ins>. Returns:</ins>
<ol style="list-style-type: none">
<li><p><ins>(11.?) &mdash; <code>i</code> for the overloads in namespace <tt>std</tt>, or</ins></p></li>
<li><p><ins>(11.?) &mdash; <tt>{i, last}</tt> for the overloads in namespace <tt>ranges</tt>.</ins></p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3187" href="3187">3187.</a> <a href="https://wg21.link/p0591r4">P0591R4</a> reverted DR 2586 fixes to <tt>scoped_allocator_adaptor::construct()</tt></h3>
<p><b>Section:</b> 20.10.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2019-02-14 <b>Last modified:</b> 2019-02-21 17:23:36 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.uses.construction">active issues</a> in [allocator.uses.construction].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.uses.construction">issues</a> in [allocator.uses.construction].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="2586">2586</a> fixed the value category in the uses-allocator checks done by <tt>scoped_allocator_adaptor</tt>. 
When we made that use <tt>uses_allocator_construction_args</tt> we reintroduced the problem, because that 
function has the same bug.
</p>
<blockquote><pre>
#include &lt;memory&gt;

struct X {
  using allocator_type = std::allocator&lt;X&gt;;
  X(std::allocator_arg_t, allocator_type&amp;&amp;) { }
  X(const allocator_type&amp;) { }
};

int main() {
  std::allocator&lt;X&gt; a;
  std::make_obj_using_allocator&lt;X&gt;(a);
}
</pre></blockquote>
<p>
This will fail to compile, because <tt>uses_allocator_construction_args</tt> will check <tt>is_constructible</tt> 
using an rvalue allocator, but then return <tt>tuple&lt;allocator_arg_t, const allocator&lt;X&gt;&amp;&gt;</tt> 
containing an lvalue allocator. Those args cannot be used to construct an <tt>X</tt>.
</p>

<p><i>[2019-02; Kona Wednesday night issue processing]</i></p>

<p>Status to Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4800">N4800</a>.</p>

<ol>
<li><p>Change 20.10.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Arguably the <tt>uses_allocator</tt> specialization should also use <tt>const Alloc&amp;</tt> 
but in practice that doesn't matter, except for even more contrived cases than the very contrived example above.]
</p>
</blockquote>

<blockquote>
<pre>
template &lt;class T, class Alloc, class... Args&gt;
  auto uses_allocator_construction_args(const Alloc&amp; alloc, Args&amp;&amp;... args) -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-5- <i>Returns:</i> A <tt>tuple</tt> value determined as follows:
<ol>
<li><p>(5.1) &mdash; If <tt>uses_allocator_v&lt;T, Alloc&gt;</tt> is <tt>false</tt> and 
<tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>, return 
<tt>forward_as_tuple(std::forward&lt;Args&gt;(args)...)</tt>.</p></li>
<li><p>(5.2) &mdash; Otherwise, if <tt>uses_allocator_v&lt;T, Alloc&gt;</tt> is <tt>true</tt> and <tt>is_constructible_v&lt;T, 
allocator_arg_t, <ins>const</ins> Alloc<ins>&amp;</ins>, Args...&gt;</tt> is <tt>true</tt>, return
<blockquote><pre>
tuple&lt;allocator_arg_t, const Alloc&amp;, Args&amp;&amp;...&gt;(
  allocator_arg, alloc, std::forward&lt;Args&gt;(args)...)
</pre></blockquote>
</p></li>
<li><p>(5.3) &mdash; Otherwise, if <tt>uses_allocator_v&lt;T, Alloc&gt;</tt> is <tt>true</tt> and <tt>is_constructible_v&lt;T, 
Args..., <ins>const</ins> Alloc<ins>&amp;</ins>&gt;</tt> is <tt>true</tt>, return 
<tt>forward_as_tuple(std::forward&lt;Args&gt;(args)..., alloc)</tt>.</p></li>
<li><p>(5.4) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3202" href="3202">3202.</a> P0318R1 was supposed to be revised</h3>
<p><b>Section:</b> 20.14.1 <a href="https://timsong-cpp.github.io/cppwp/functional.syn">[functional.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2019-04-23 <b>Last modified:</b> 2019-05-01 09:53:21 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://wg21.link/p0318r1">P0318R1</a> was discussed in Batavia and the requested changes were made in D0318R2. 
In San Diego the R1 paper was voted into the WP, despite not having the requested changes. There were also changes to 
D0318R2 suggested on the reflector, which are incorporated below.
</p>

<p><i>[2019-04-30 Priority to 0 and Status to Tentatively Ready after six positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 20.14.1 <a href="https://timsong-cpp.github.io/cppwp/functional.syn">[functional.syn]</a>, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt; struct unwrap_reference;
<ins>template&lt;class T&gt; using unwrap_reference_t = typename unwrap_reference&lt;T&gt;::type;</ins>
template&lt;class T&gt; struct unwrap_ref_decay<del> : unwrap_reference&lt;decay_t&lt;T&gt;&gt; {}</del>;
template&lt;class T&gt; using unwrap_ref_decay_t = typename unwrap_ref_decay&lt;T&gt;::type;
</pre>
</blockquote>
</li>

<li><p>Modify 20.14.5.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap.unwrapref">[refwrap.unwrapref]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  struct unwrap_reference;
</pre>
<blockquote>
<p>
-1- If <tt>T</tt> is a specialization [&hellip;]
</p>
</blockquote>
<pre>
<ins>template&lt;class T&gt;
  struct unwrap_ref_decay;</ins>
</pre>
<blockquote>
<p>
<ins>-?- The member typedef <tt>type</tt> of <tt>unwrap_ref_decay&lt;T&gt;</tt> denotes the type 
<tt>unwrap_reference_t&lt;decay_t&lt;T&gt;&gt;</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3206" href="3206">3206.</a> <tt>year_month_day</tt> conversion to <tt>sys_days</tt> uses not-existing member function</h3>
<p><b>Section:</b> 27.8.14.2 <a href="https://timsong-cpp.github.io/cppwp/time.cal.ymd.members">[time.cal.ymd.members]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2019-05-19 <b>Last modified:</b> 2019-06-08 14:29:37 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of the <code>year_month_day</code> conversion function to <code>sys_days</code>,
uses the <code>day</code> member function on the <code>sys_days</code> (a.k.a. 
<code>time_point&lt;system_clock, days&gt;</code>), that does not exist.
<p/>
In 27.8.14.2 <a href="https://timsong-cpp.github.io/cppwp/time.cal.ymd.members">[time.cal.ymd.members]</a> p18, the expression <code>sys_days{y_/m_/last}.day()</code> is 
ill-formed:
</p>
<blockquote><p>
[&hellip;] Otherwise, if <code>y_.ok() &amp;&amp; m_.ok()</code> is <tt>true</tt>, returns a
<tt>sys_days</tt> which is offset from <code>sys_days{y_/m_/last}</code>
by the number of days <code>d_</code> is offset from <code>sys_days{y_/m_/last}.day()</code>.
Otherwise the value returned is unspecified.
</p></blockquote>

<p><i>[2019-06-08; Priority to 0 and Status to Tentatively Ready after six positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 27.8.14.2 <a href="https://timsong-cpp.github.io/cppwp/time.cal.ymd.members">[time.cal.ymd.members]</a> as indicated:</p>

<blockquote>
<pre>
constexpr operator sys_days() const noexcept;
</pre>
<blockquote>
<p>
-18- <i>Returns:</i> If <tt>ok()</tt>, returns a <tt>sys_days</tt> holding a count of days from 
the <tt>sys_days</tt> epoch to <tt>*this</tt> (a negative value if <tt>*this</tt> represents a date 
prior to the <tt>sys_days</tt> epoch). Otherwise, if <tt>y_.ok() &amp;&amp; m_.ok()</tt> is <tt>true</tt>, 
returns <ins><tt>sys_days{y_/m_/1d} + (d_ - 1d)</tt></ins><del>a <tt>sys_days</tt> which is offset from 
<tt>sys_days{y_/m_/last}</tt> by the number of days <tt>d_</tt> is offset from 
<tt>sys_days{y_/m_/last}.day()</tt></del>. Otherwise the value returned is unspecified.
</p>
</blockquote>
</blockquote>
</li>

</ol>




</body>
</html>
