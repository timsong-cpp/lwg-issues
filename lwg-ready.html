<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2023-11-10 at 22:10:49 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Jonathan Wakely &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="3767" href="3767">3767.</a> <tt>codecvt&lt;char<i>N</i>_t, char8_t, mbstate_t&gt;</tt> incorrectly added to locale</h3>
<p><b>Section:</b> 30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a>, 30.4.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.general">[locale.codecvt.general]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Victor Zverovich <b>Opened:</b> 2022-09-05 <b>Last modified:</b> 2023-11-07 22:39:32 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table [tab:locale.category.facets] includes the following two facets:
</p>
<ul>
<li><p><tt>codecvt&lt;char16_t, char8_t, mbstate_t&gt;</tt></p></li>
<li><p><tt>codecvt&lt;char32_t, char8_t, mbstate_t&gt;</tt></p></li>
</ul>
<p>
However, neither of those actually has anything to do with a locale and therefore 
it doesn't make sense to dynamically register them with <tt>std::locale</tt>. 
Instead they provide conversions between fixed encodings (UTF-8, UTF-16, UTF-32) 
that are unrelated to locale encodings other than they may happen to coincide with 
encodings of some locales by accident.
<p/>
The issue was introduced when adding <tt>codecvt&lt;char[16|32]_t, char, mbstate_t&gt;</tt> in 
<a href="https://wg21.link/N2035">N2035</a> which gave no design rationale for using <tt>codecvt</tt> in the first 
place. Likely it was trying to do a minimal amount of changes and copied the wording for 
<tt>codecvt&lt;wchar_t, char, mbstate_t&gt;</tt> but unfortunately didn't consider encoding implications.
<p/>
<a href="https://wg21.link/P0482">P0482</a> changed <tt>char</tt> to <tt>char8_t</tt> in these facets which 
made the issue more glaring but unfortunately, despite the breaking change, it failed to address it.
<p/>
Apart from an obvious design mistake this also adds a small overhead for every locale 
construction because the implementation has to copy these pseudo-facets for no good 
reason violating "don't pay for what you don't use" principle.
<p/>
A simple fix is to remove the two facets from table [tab:locale.category.facets] and make them 
directly constructible.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Send to SG16 (then maybe LEWG).
</p>

<p><i>[2022-09-28; SG16 responds]</i></p>

<p>
SG16 agrees that the codecvt facets mentioned in LWG3767
"<tt>codecvt&lt;char<i>N</i>_t, char8_t, mbstate_t&gt;</tt>
incorrectly added to locale" are intended to be invariant
with respect to locale. Unanimously in favor.
</p>

<p><i>[Issaquah 2023-02-10; LWG issue processing]</i></p>

<p>
Removing these breaks most code using them today, because the most obvious
way to use them is via <tt>use_facet</tt> on a locale, which would throw
if they're removed (and because they were guaranteed to be present, code
using them might have not bothered to check for them using <tt>has_facet</tt>).
Instead of removing them, deprecate the guarantee that they're always present
(so move them to D.28 <a href="https://timsong-cpp.github.io/cppwp/depr.locale.category">[depr.locale.category]</a>).
Don't bother changing the destructor.
Victor to update wording.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4917">N4917</a>.
</p>

<ol>

<li><p>Modify 30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a>, Table 105 ([tab:locale.category.facets]) &mdash; 
"Locale category facets" &mdash; as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 105: Locale category facets [tab:locale.category.facets]</caption>
<tr>
<th align="center">Category</th>
<th align="center">Includes facets</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
ctype
</td>

<td>
<tt>ctype&lt;char&gt;, ctype&lt;wchar_t&gt;<br/>
codecvt&lt;char, char, mbstate_t&gt;<br/>
<del>codecvt&lt;char16_t, char8_t, mbstate_t&gt;</del><br/>
<del>codecvt&lt;char32_t, char8_t, mbstate_t&gt;</del><br/>
codecvt&lt;wchar_t, char, mbstate_t&gt;</tt>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 30.4.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.general">[locale.codecvt.general]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  template&lt;class internT, class externT, class stateT&gt;
    class codecvt : public locale::facet, public codecvt_base {
    public:
      using intern_type = internT;
      using extern_type = externT;
      using state_type = stateT;

      explicit codecvt(size_t refs = 0);
      <ins>~codecvt();</ins>

      [&hellip;]
    protected:
      <del>~codecvt();</del>
      [&hellip;]
    };
}
</pre>
</blockquote>
<p>
[&hellip;]
<p/>
-3- The specializations required in Table <del>105 [tab:locale.category.facets]</del><ins>106 [tab:locale.spec]</ins>
(30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a>) convert the implementation-defined native character set. 
<tt>codecvt&lt;char, char, mbstate_t&gt;</tt> implements a degenerate conversion; it does not 
convert at all. The specialization <tt>codecvt&lt;char16_t, char8_t, mbstate_t&gt;</tt> converts 
between the UTF-16 and UTF-8 encoding forms, and the specialization 
<tt>codecvt&lt;char32_t, char8_t, mbstate_t&gt;</tt> converts between the UTF-32 and UTF-8 encoding forms. 
<tt>codecvt&lt;wchar_t, char, mbstate_t&gt;</tt> converts between the native character sets for ordinary 
and wide characters. Specializations on <tt>mbstate_t</tt> perform conversion between encodings known to 
the library implementer. Other encodings can be converted by specializing on a program-defined 
<tt>stateT</tt> type. Objects of type <tt>stateT</tt> can contain any state that is useful to communicate 
to or from the specialized <tt>do_in</tt> or <tt>do_out</tt> members.
</p>
</blockquote>
</li>

</ol>
</blockquote>


<p><i>[2023-02-10; Victor Zverovich comments and provides improved wording]</i></p>

<p>
Per today's LWG discussion the following changes have been implemented in revised wording:
</p>
<ul>
<li><p>Deprecated the facets instead of removing them (also <tt>_byname</tt> variants which were previously missed).</p></li>
<li><p>Removed the changes to facet dtor since with deprecation it's no longer critical to provide other ways to access them.</p></li>
</ul>
<p><i>[Kona 2023-11-07; move to Ready]</i></p>




<p id="res-3767"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>

<li><p>Modify 30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a>, Table 105 ([tab:locale.category.facets]) &mdash; 
"Locale category facets" &mdash; and Table 106 ([tab:locale.spec]) "Required specializations" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 105: Locale category facets [tab:locale.category.facets]</caption>
<tr>
<th align="center">Category</th>
<th align="center">Includes facets</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
ctype
</td>

<td>
<tt>ctype&lt;char&gt;, ctype&lt;wchar_t&gt;<br/>
codecvt&lt;char, char, mbstate_t&gt;<br/>
<del>codecvt&lt;char16_t, char8_t, mbstate_t&gt;</del><br/>
<del>codecvt&lt;char32_t, char8_t, mbstate_t&gt;</del><br/>
codecvt&lt;wchar_t, char, mbstate_t&gt;</tt>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
[&hellip;]
<table border="1">
<caption>Table 106: Required specializations [tab:locale.spec]</caption>
<tr>
<th align="center">Category</th>
<th align="center">Includes facets</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
ctype
</td>

<td>
<tt>ctype_byname&lt;char&gt;, ctype_byname&lt;wchar_t&gt;<br/>
codecvt_byname&lt;char, char, mbstate_t&gt;<br/>
<del>codecvt_byname&lt;char16_t, char8_t, mbstate_t&gt;</del><br/>
<del>codecvt_byname&lt;char32_t, char8_t, mbstate_t&gt;</del><br/>
codecvt_byname&lt;wchar_t, char, mbstate_t&gt;</tt>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 30.4.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.general">[locale.codecvt.general]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-3- The specializations required in Table 105 (30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a>) 
convert the implementation-defined native character set. 
<tt>codecvt&lt;char, char, mbstate_t&gt;</tt> implements a degenerate conversion; it does not 
convert at all. <del>The specialization <tt>codecvt&lt;char16_t, char8_t, mbstate_t&gt;</tt> converts 
between the UTF-16 and UTF-8 encoding forms, and the specialization 
<tt>codecvt&lt;char32_t, char8_t, mbstate_t&gt;</tt> converts between the UTF-32 and UTF-8 encoding forms.</del> 
<tt>codecvt&lt;wchar_t, char, mbstate_t&gt;</tt> converts between the native character sets for ordinary 
and wide characters. Specializations on <tt>mbstate_t</tt> perform conversion between encodings known to 
the library implementer. Other encodings can be converted by specializing on a program-defined 
<tt>stateT</tt> type. Objects of type <tt>stateT</tt> can contain any state that is useful to communicate 
to or from the specialized <tt>do_in</tt> or <tt>do_out</tt> members.
</p>
</blockquote>
</li>


<li><p>Modify D.28 <a href="https://timsong-cpp.github.io/cppwp/depr.locale.category">[depr.locale.category]</a> (Deprecated locale category facets) in Annex D as indicated:</p>

<blockquote>
<p>
-1- The <tt>ctype</tt> locale category includes the following facets as if they were specified in table Table 105
[tab:locale.category.facets] of 30.4.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.general">[locale.codecvt.general]</a>.
</p>
<blockquote><pre>
codecvt&lt;char16_t, char, mbstate_t&gt;
codecvt&lt;char32_t, char, mbstate_t&gt;
<ins>codecvt&lt;char16_t, char8_t, mbstate_t&gt;
codecvt&lt;char32_t, char8_t, mbstate_t&gt;</ins>
</pre></blockquote>
<p>
-1- The <tt>ctype</tt> locale category includes the following facets as if they were specified in table Table 106
[tab:locale.spec] of 30.4.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.general">[locale.codecvt.general]</a>.
</p>
<blockquote><pre>
codecvt_byname&lt;char16_t, char, mbstate_t&gt;
codecvt_byname&lt;char32_t, char, mbstate_t&gt;
<ins>codecvt_byname&lt;char16_t, char8_t, mbstate_t&gt;
codecvt_byname&lt;char32_t, char8_t, mbstate_t&gt;</ins>
</pre></blockquote>
<p>
-3- The following class template specializations are required in addition to those specified in 30.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a>. 
The specialization<ins>s</ins> <tt>codecvt&lt;char16_t, char, mbstate_t&gt;</tt> <ins>and <tt>codecvt&lt;char16_t, char8_t, mbstate_t&gt;</tt></ins> 
convert<del>s</del> between the UTF-16 and UTF-8 encoding forms, and the specialization<ins>s</ins> 
<tt>codecvt&lt;char32_t, char, mbstate_t&gt;</tt> <ins>and <tt>codecvt&lt;char32_t, char8_t, mbstate_t&gt;</tt></ins> 
convert<del>s</del> between the UTF-32 and UTF-8 encoding forms.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3919" href="3919">3919.</a> <tt>enumerate_view</tt> may invoke UB for sized common non-forward underlying ranges</h3>
<p><b>Section:</b> 26.7.23 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate">[range.enumerate]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Patrick Palka <b>Opened:</b> 2023-04-07 <b>Last modified:</b> 2023-11-10 19:41:53 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For a sized common range, <tt>enumerate_view::end()</tt> is specified to call
<tt>ranges::distance</tt>. But <tt>ranges::distance</tt> is not necessarily well-defined
for a sized non-forward range after calling <tt>ranges::begin</tt> (according to
26.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>).
<p/>
So for a sized common non-forward underlying range, it seems calling
<tt>enumerate_view::begin()</tt> followed by <tt>enumerate_view::end()</tt> may invoke UB
and thus make <tt>enumerate_view</tt> potentially unusable for such ranges.
<p/>
I suppose we might need to instead call and cache the result of
<tt>ranges::distance</tt> from <tt>enumerate_view::begin()</tt> for such ranges.
</p>

<p><i>[2022-04-12; Patrick Palka provides wording]</i></p>

<p>
The proposed wording follows the suggestion provided by Tim Song, to simply make <tt>enumerate</tt> non-common for this case.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[Kona 2023-11-10; move to Ready]</i></p>




<p id="res-3919"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944">N4944</a>.
</p>

<ol>
<li>
<p>Modify 26.7.23.2 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.view">[range.enumerate.view]</a>, class template class <tt>enumerate_view</tt> synopsis, as indicated:</p>

<blockquote>
<blockquote><pre>
[&hellip;]
constexpr auto end() requires (!<i>simple-view</i>&lt;V&gt;) {
  if constexpr (<ins>forward_range&lt;V&gt; &amp;&amp;</ins> common_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;)
    return <i>iterator</i>&lt;false&gt;(ranges::end(<i>base_</i>), ranges::distance(<i>base_</i>));
  else
    return <i>sentinel</i>&lt;false&gt;(ranges::end(<i>base_</i>));
}
constexpr auto end() const requires <i>range-with-movable-references</i>&lt;const V&gt; {
  if constexpr (<ins>forward_range&lt;const V&gt; &amp;&amp;</ins> common_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;)
    return <i>iterator</i>&lt;true&gt;(ranges::end(<i>base_</i>), ranges::distance(<i>base_</i>));
  else
    return <i>sentinel</i>&lt;true&gt;(ranges::end(<i>base_</i>));
}
[&hellip;]
</pre></blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="3950" href="3950">3950.</a> <tt>std::basic_string_view</tt> comparison operators are overspecified</h3>
<p><b>Section:</b> 23.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.synop">[string.view.synop]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Giuseppe D'Angelo <b>Opened:</b> 2023-06-21 <b>Last modified:</b> 2023-11-10 22:10:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;string_view&gt;</tt> synopsis in 23.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.synop">[string.view.synop]</a> has these signatures
for <tt>operator==</tt> and <tt>operator&lt;=&gt;</tt>:
</p>
<blockquote><pre>
// <i>23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a>, non-member comparison functions</i>
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; x,
                            basic_string_view&lt;charT, traits&gt; y) noexcept;
template&lt;class charT, class traits&gt;
  constexpr see below operator&lt;=&gt;(basic_string_view&lt;charT, traits&gt; x,
                                  basic_string_view&lt;charT, traits&gt; y) noexcept;

// <i>see 23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a>, sufficient additional overloads of comparison functions</i>
</pre></blockquote>
<p>
In 23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a>, paragraph 1 states that "Implementations
shall provide sufficient additional overloads" so that all comparisons
between a <tt>basic_string_view&lt;C, T&gt;</tt> object and an object of a type
convertible to <tt>basic_string_view&lt;C, T&gt;</tt> work (with the reasonable
semantics).
<p/>
The associated Example 1 proposes this implementation strategy for
<tt>operator==</tt>:
</p>
<blockquote><pre>
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept {
    return lhs.compare(rhs) == 0;
  }
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            type_identity_t&lt;basic_string_view&lt;charT, traits&gt;&gt; rhs) noexcept {
    return lhs.compare(rhs) == 0;
  }
</pre></blockquote>
<p>
With the current semantics of rewritten candidates for the comparison
operators, it is however superfluous to actually specify both overloads
(the same applies for <tt>operator&lt;=&gt;</tt>).
<p/>
The second overload (using <tt>type_identity_t</tt>) is indeed necessary to
implement the "sufficient additional overloads" part of 23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a>, 
but it is also sufficient, as all the following cases
</p>
<ul>
<li><p><tt>sv == sv</tt></p></li>
<li><p><tt>sv == <i>convertible_to_sv</i></tt></p></li>
<li><p><tt><i>convertible_to_sv</i> == sv</tt></p></li>
</ul>
<p>
can in fact use it (directly, or after being rewritten e.g. with the
arguments swapped).
<p/>
The reason why we still do have both operators seems to be historical;
there is an explanation offered <a href="https://stackoverflow.com/a/70851101">here</a> by Barry Revzin.
<p/>
Basically, there were three overloads before a bunch of papers regarding
<tt>operator&lt;=&gt;</tt> and <tt>operator==</tt> were merged:
</p>
<ol>
<li><p><tt>operator==(<i>bsv</i>, <i>bsv</i>)</tt> to deal with <tt>sv == sv</tt>;</p></li>
<li><p><tt>operator==(<i>bsv</i>, type_identity_t&lt;<i>bsv</i>&gt;)</tt> and</p></li>
<li><p><tt>operator==(type_identity_t&lt;<i>bsv</i>&gt;, <i>bsv</i>)</tt> to deal with 
<tt>sv == <i>convertible_to_sv</i></tt> and vice versa.</p></li>
</ol>
<p>
Overload (1) was necessary because with only (2) and (3) a call like 
<tt>sv == sv</tt> would otherwise be ambiguous. With the adoption of the rewriting
rules, overload (3) has been dropped, without realizing that overload
(1) would then become redundant.
<p/>
The specification of these overloads can be greatly simplified by
adjusting the signatures to explicitly use <tt>type_identity_t</tt>.
</p>

<p><i>[Kona 2023-11-10; move to Ready]</i></p>

<p>
Editorial issue <a href="https://github.com/cplusplus/draft/pull/6324">6324</a>
provides the changes as a pull request to the draft.
</p>


<p id="res-3950"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950">N4950</a>.
</p>

<ol>
<li><p>Modify 23.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.synop">[string.view.synop]</a>, header <tt>&lt;string_view&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
// <i>23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a>, non-member comparison functions</i>
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; x,
                            <ins>type_identity_t&lt;</ins>basic_string_view&lt;charT, traits&gt;<ins>&gt;</ins> y) noexcept;

template&lt;class charT, class traits&gt;
  constexpr <i>see below</i> operator&lt;=&gt;(basic_string_view&lt;charT, traits&gt; x,
                                  <ins>type_identity_t&lt;</ins>basic_string_view&lt;charT, traits&gt;<ins>&gt;</ins> y) noexcept;

<del>// <i>see 23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a>, sufficient additional overloads of comparison functions</i></del>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a> as indicated:</p>

<blockquote>
<p>
<del>-1- Let <tt>S</tt> be <tt>basic_string_view&lt;charT, traits&gt;</tt>, and <tt>sv</tt> be an instance of <tt>S</tt>. 
Implementations shall provide sufficient additional overloads marked <tt>constexpr</tt> and <tt>noexcept</tt> so that an 
object <tt>t</tt> with an implicit conversion to <tt>S</tt> can be compared according to Table 81 
[tab:string.view.comparison.overloads].</del>
</p>

<table border="1">
<caption><del>Table 81: Additional <tt>basic_string_view</tt> comparison overloads [tab:string.view.comparison.overloads]</del></caption>
<tr>
<th align="center"><del>Expression</del></th>
<th align="center"><del>Equivalent to</del></th>
</tr>

<tr>
<td><del>
<tt>t == sv</tt>
</del></td>
<td><del>
<tt>S(t) == sv</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>sv == t</tt>
</del></td>
<td><del>
<tt>sv == S(t)</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>t != sv</tt>
</del></td>
<td><del>
<tt>S(t) != sv</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>sv != t</tt>
</del></td>
<td><del>
<tt>sv != S(t)</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>t &lt; sv</tt>
</del></td>
<td><del>
<tt>S(t) &lt; sv</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>sv &lt; t</tt>
</del></td>
<td><del>
<tt>sv &lt; S(t)</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>t &gt; sv</tt>
</del></td>
<td><del>
<tt>S(t) &gt; sv</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>sv &gt; t</tt>
</del></td>
<td><del>
<tt>sv &gt; S(t)</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>t &lt;= sv</tt>
</del></td>
<td><del>
<tt>S(t) &lt;= sv</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>sv &lt;= t</tt>
</del></td>
<td><del>
<tt>sv &lt;= S(t)</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>t &gt;= sv</tt>
</del></td>
<td><del>
<tt>S(t) &gt;= sv</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>sv &gt;= t</tt>
</del></td>
<td><del>
<tt>sv &gt;= S(t)</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>t &lt;=&gt; sv</tt>
</del></td>
<td><del>
<tt>S(t) &lt;=&gt; sv</tt>
</del></td>
</tr>

<tr>
<td><del>
<tt>sv &lt;=&gt; t</tt>
</del></td>
<td><del>
<tt>sv &lt;=&gt; S(t)</tt>
</del></td>
</tr>

</table>
<p>
<del>[<i>Example 1</i>: A sample conforming implementation for <tt>operator==</tt> would be:</del>
</p>
<blockquote><pre>
<del>template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept {
    return lhs.compare(rhs) == 0;
  }
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            type_identity_t&lt;basic_string_view&lt;charT, traits&gt;&gt; rhs) noexcept {
    return lhs.compare(rhs) == 0;
  }</del>
</pre></blockquote>
<p>
<del>&mdash; <i>end example</i>]</del>
</p>
<pre>
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            <ins>type_identity_t&lt;</ins>basic_string_view&lt;charT, traits&gt;<ins>&gt;</ins> rhs) noexcept;

</pre>
<blockquote>
<p>
-2- <i>Returns:</i> <tt>lhs.compare(rhs) == 0</tt>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  constexpr <i>see below</i> operator&lt;=&gt;(basic_string_view&lt;charT, traits&gt; lhs,
                                  <ins>type_identity_t&lt;</ins>basic_string_view&lt;charT, traits&gt;<ins>&gt;</ins> rhs) noexcept;
</pre>
<blockquote>
<p>
-3- Let <tt>R</tt> denote the type <tt>traits::comparison_category</tt> if that <i>qualified-id</i> is valid and denotes a
type (13.10.3 <a href="https://timsong-cpp.github.io/cppwp/temp.deduct">[temp.deduct]</a>), otherwise <tt>R</tt> is <tt>weak_ordering</tt>.
<p/>
-4- <i>Mandates</i>: <tt>R</tt> denotes a comparison category type (17.11.2 <a href="https://timsong-cpp.github.io/cppwp/cmp.categories">[cmp.categories]</a>).
<p/>
-5- <i>Returns</i>: <tt>static_cast&lt;R&gt;(lhs.compare(rhs) &lt;=&gt; 0)</tt>.
<p/>
<ins> [<i>Note</i>: The usage of <tt>type_identity_t</tt> as parameter ensures that an object of type 
<tt>basic_string_view&lt;charT, traits&gt;</tt> can always be compared with an object of a type <tt>T</tt> 
with an implicit conversion to <tt>basic_string_view&lt;charT, traits&gt;</tt>, and vice versa, as per 
12.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/over.match.oper">[over.match.oper]</a>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3975" href="3975">3975.</a> Specializations of <tt>basic_format_context</tt> should not be permitted</h3>
<p><b>Section:</b> 22.14.6.6 <a href="https://timsong-cpp.github.io/cppwp/format.context">[format.context]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Brian Bi <b>Opened:</b> 2023-08-13 <b>Last modified:</b> 2023-11-07 22:39:32 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#format.context">issues</a> in [format.context].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current wording allows users to specialize <tt>std::basic_format_context</tt>. However, an implementation is not 
likely to accept a program that uses the library in a way that would instantiate such a specialization, because 
22.14.6.6 <a href="https://timsong-cpp.github.io/cppwp/format.context">[format.context]</a> does not provide a complete description of the interface that such a specialization 
would need to have (e.g., it does not provide a means to initialize the exposition-only <tt>args_</tt> member). Since the 
library was not designed to be able to work with user specializations of <tt>std::basic_format_context</tt>, declaring 
such specializations should be explicitly disallowed.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify the 22.14.6.6 <a href="https://timsong-cpp.github.io/cppwp/format.context">[format.context]</a> as indicated:</p>

<blockquote>
<p>
-1- An instance of <tt>basic_format_context</tt> holds formatting state consisting of the formatting arguments and
the output iterator.
<p/>
<ins>-?- The behavior of a program that adds specializations of <tt>basic_format_context</tt> is undefined.</ins>
<p/>
-2- <tt>Out</tt> shall model <tt>output_iterator&lt;const charT&amp;&gt;</tt>.
</p>
</blockquote>

</li>
</ol>
</blockquote>


<p><i>[2023-09-23; Daniel comments and provides improved wording]</i></p>

<p>
During the reflector discussion, Dietmar pointed out that the constraint can in principle be checked statically (e.g. when the 
Library creates or refers to an instantiation of <tt>basic_format_context</tt>), so we can reduce the rather draconian consequence of
"undefined behaviour" to "ill-formed, no diagnostics required". Furthermore, the new wording also adds the same constraint to
<tt>basic_format_parse_context</tt> as suggested by Tim. This is needed, since only one public constructor is specified, but
that specification does not allow to construct an object a non-zero <tt>num_args_</tt> or with the type information necessary 
for the <tt>check_dynamic_spec*</tt> functions, so the library has an unspecified way to realize this.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[Kona 2023-11-07; move to Ready]</i></p>




<p id="res-3975"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The suggested wording form is borrowed from exactly the same wording form used for <tt>allocator_traits</tt>.]
</p>
</blockquote>

<ol>

<li><p>Modify 22.14.6.6 <a href="https://timsong-cpp.github.io/cppwp/format.context">[format.context]</a> as indicated:</p>

<blockquote>
<p>
-1- An instance of <tt>basic_format_context</tt> holds formatting state consisting of the formatting arguments and
the output iterator.
<p/>
<ins>-?- If a program declares an explicit or partial specialization of <tt>basic_format_context</tt>, the program is ill-formed,
no diagnostic required.</ins>
<p/>
-2- <tt>Out</tt> shall model <tt>output_iterator&lt;const charT&amp;&gt;</tt>.
</p>
</blockquote>

</li>

<li><p>Modify 22.14.6.5 <a href="https://timsong-cpp.github.io/cppwp/format.parse.ctx">[format.parse.ctx]</a> as indicated:</p>

<blockquote>
<p>
-1- An instance of <tt>basic_format_parse_context</tt> holds the format string parsing state consisting of the format
string range being parsed and the argument counter for automatic indexing.
<p/>
<ins>-?- If a program declares an explicit or partial specialization of <tt>basic_format_parse_context</tt>, the program is ill-formed,
no diagnostic required.</ins>
</p>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="3984" href="3984">3984.</a> <tt>ranges::to</tt>'s recursion branch may be ill-formed</h3>
<p><b>Section:</b> 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-23 <b>Last modified:</b> 2023-11-07 22:39:32 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <tt>r</tt> is a nested range, <tt>ranges::to</tt> constructs the object recursively through <tt>r | views::transform(...)</tt>.
<p/>
However, the expression is ill-formed when the type of lvalue <tt>r</tt> does not model <tt>viewable_range</tt> 
(<a href="https://godbolt.org/z/98rxGz73Y">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;vector&gt;
#include &lt;list&gt;

int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; v;
  auto r = std::views::all(std::move(v));
  auto l = std::ranges::to&lt;std::list&lt;std::list&lt;int&gt;&gt;&gt;(r); // <span style="color:red;font-weight:bolder">hard error in MSVC-STL and libc++</span>
}
</pre></blockquote>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Should be <code>std::forward&lt;R&gt;(r)</code> instead?"
</p>

<p><i>[Kona 2023-11-07; move to Ready]</i></p>




<p id="res-3984"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 26.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <tt>C</tt> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <tt>C</tt> constructed from the elements of <tt>r</tt> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <tt>C</tt> does not satisfy <tt>input_range</tt> or 
<tt>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</tt> is <tt>true</tt>:</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
</ol></li>
<li><p>(2.2) &mdash; Otherwise, if <tt>input_range&lt;range_reference_t&lt;R&gt;&gt;</tt> is <tt>true</tt>:
</p>
<blockquote>
<pre>
to&lt;C&gt;(<ins>ref_view(</ins>r<ins>)</ins> | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre>
</blockquote>
</li>
<li><p>(2.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3><a name="3988" href="3988">3988.</a> Should <tt>as_const_view</tt> and <tt>basic_const_iterator</tt> provide <tt>base()</tt>?</h3>
<p><b>Section:</b> 25.5.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators">[const.iterators]</a>, 26.7.21.2 <a href="https://timsong-cpp.github.io/cppwp/range.as.const.view">[range.as.const.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-28 <b>Last modified:</b> 2023-11-07 22:39:32 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#const.iterators">active issues</a> in [const.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#const.iterators">issues</a> in [const.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, both <tt>as_const_view</tt> and <tt>basic_const_iterator</tt> provide <tt>base()</tt> members to 
return the underlying range and iterator, which seems to expose vulnerabilities in modifying them:
</p>
<blockquote><pre>
#include &lt;vector&gt;
#include &lt;ranges&gt;

int main() {
  std::vector v{1, 2, 3};
  
  auto f = [](std::span&lt;int&gt;::const_iterator i) {
    *i.base() = 4;
  };
  f(std::span{v}.cbegin());

  auto g = [](const std::ranges::constant_range auto&amp; r) {
    r.begin().base()[1] = 5;
    r.base()[2] = 6;
  };
  g(std::ranges::as_const_view(v));

  // v now becomes [4, 5, 6]
}
</pre></blockquote>
<p>
I don't think such a shortcut should be provided as it doesn't seem to be the intention and could be harmful.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Send to SG9.
</p>

<p><i>[Kona 2023-11-07; move to Ready]</i></p>




<p id="res-3988"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958">N4958</a>.
</p>

<ol>

<li><p>Modify 25.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.iterator">[const.iterators.iterator]</a>, class template <tt>basic_const_iterator</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]

  template&lt;input_iterator Iterator&gt;
  class basic_const_iterator {
    [&hellip;]
    <del>constexpr const Iterator&amp; base() const &amp; noexcept;</del>
    <del>constexpr Iterator base() &amp;&amp;;</del>
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.ops">[const.iterators.ops]</a> as indicated:</p>

<blockquote>
<pre>
<del>constexpr const Iterator&amp; base() const &amp; noexcept;</del>
</pre>
<blockquote>
<p>
<del>-4- <i>Effects</i>: Equivalent to: <tt>return <i>current_</i>;</tt></del>
</p>
</blockquote>
<pre>
<del>constexpr Iterator base() &amp;&amp;;</del>
</pre>
<blockquote>
<p>
<del>-5- <i>Effects</i>: Equivalent to: <tt>return std::move(<i>current_</i>);</tt></del>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 26.7.21.2 <a href="https://timsong-cpp.github.io/cppwp/range.as.const.view">[range.as.const.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class as_const_view : public view_interface&lt;as_const_view&lt;V&gt;&gt; {
    [&hellip;]
    <del>constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return <i>base_</i>; }</del>
    <del>constexpr V base() &amp;&amp; { return std::move(<i>base_</i>); }</del>
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

</ol>





</body>
</html>
