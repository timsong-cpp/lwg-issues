<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2019-02-03 at 12:20:33 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="3169" href="3169">3169.</a> <tt>ranges</tt> permutation generators discard useful information</h3>
<p><b>Section:</b> 24.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.permutation.generators">[alg.permutation.generators]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-11-26 <b>Last modified:</b> 2019-02-02 20:30:17 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the Ranges design, algorithms that necessarily traverse an entire range -
consequently discovering the end iterator value - return that iterator value
unless the algorithm's sole purpose is to return a derived value,
for example, <tt>ranges::count</tt>.
<tt>ranges::next_permutation</tt> and <tt>ranges::prev_permutation</tt>
necessarily traverse the entirety of their range argument, but are currently
specified to discard the end iterator value and return only a <tt>bool</tt>
indicating whether they found a next (respectively previous) permutation or
"reset" the range to the first (respectively last) permutation.
They should instead return an aggregate composed of both
that <tt>bool</tt> and the end iterator value to be consistent with the other
<tt>range</tt> algorithms.
</p>

<p><i>[2019-01-22; Daniel comments and updates wording]</i></p>

<p>
During the reflector discussion it had been noticed that an additional update of
24.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> p.16 is necessary for the new type
<tt>next_permutation_result</tt> and two missing occurrences of <tt>iterator_t&lt;&gt;</tt> where
added. The proposed wording has been updated.
</p>

<p><i>[2019-02-02 Priority to 0 and Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<ol>
<li><p>Modify 24.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> as follows:</p>

<blockquote>
<p>
-16- The class templates <tt>binary_transform_result</tt>, <tt>for_each_result</tt>, 
<tt>minmax_result</tt>, <tt>mismatch_result</tt><ins>, <tt>next_permutation_result</tt></ins>, 
<tt>copy_result</tt>, and <tt>partition_copy_result</tt> have the template parameters, data members, 
and special members specified above. They have no base classes or members other than those specified.
</p>
</blockquote>
</li>

<li><p>Modify 24.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a> as follows:</p>

<blockquote>
<pre>
  // 24.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.permutation.generators">[alg.permutation.generators]</a>, permutations
  template&lt;class BidirectionalIterator&gt;
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    <ins>template&lt;class I&gt;</ins>
    <ins>struct next_permutation_result {</ins>
      <ins>bool found;</ins>
      <ins>I in;</ins>
    <ins>};</ins>

    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr <del>bool</del><ins>next_permutation_result&lt;I&gt;</ins>
        next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr <del>bool</del><ins>next_permutation_result&lt;iterator_t&lt;R&gt;&gt;</ins>
        next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }

  template&lt;class BidirectionalIterator&gt;
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template&lt;class BidirectionalIterator, class Compare&gt;
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    <ins>template&lt;class I&gt;</ins>
    <ins>using prev_permutation_result = next_permutation_result&lt;I&gt;;</ins>

    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr <del>bool</del><ins>prev_permutation_result&lt;I&gt;</ins>
        prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
             class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr <del>bool</del><ins>prev_permutation_result&lt;iterator_t&lt;R&gt;&gt;</ins>
        prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
}
</pre>
</blockquote>
</li>

<li><p>Modify 24.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.permutation.generators">[alg.permutation.generators]</a> as follows:</p>

<blockquote>
<blockquote>
<pre>
template&lt;class BidirectionalIterator>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);
template&lt;class BidirectionalIterator, class Compare>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);

namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I> S, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    constexpr <del>bool</del><ins>next_permutation_result&lt;I&gt;</ins>
      next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
  template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr <del>bool</del><ins>next_permutation_result&lt;iterator_t&lt;R&gt;&gt;</ins>
      next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
}
</pre>
</blockquote>
[&hellip;]
<p>-4- <i>Returns:</i> <ins>Let <tt>B</tt> be</ins> <tt>true</tt>
  if <del>and only if</del> a next permutation was found
  <ins>and otherwise <tt>false</tt></ins>. <ins>Returns:</ins></p>
<ul>
<li><p><ins><tt>B</tt> for the overloads in namespace <tt>std</tt>,
  or</ins></p></li>
<li><p><ins><tt>{ B, last }</tt> for the overloads
  in namespace <tt>ranges</tt>.</ins></p></li>
</ul>
<p>-5- <i>Complexity:</i> [&hellip;]</p>
<blockquote>
<pre>
template&lt;class BidirectionalIterator&gt;
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);
template&lt;class BidirectionalIterator, class Compare&gt;
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);

namespace ranges {
  template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;I, Comp, Proj&gt;
    constexpr <del>bool</del><ins>prev_permutation_result&lt;I&gt;</ins>
      prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
  template&lt;BidirectionalRange R, class Comp = ranges::less&lt;&gt;,
           class Proj = identity&gt;
    requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr <del>bool</del><ins>prev_permutation_result&lt;iterator_t&lt;R&gt;&gt;</ins>
      prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
}
</pre>
</blockquote>
[&hellip;]
<p>-9- <i>Returns:</i> <ins>Let <tt>B</tt> be</ins> <tt>true</tt>
  if <del>and only if</del> a previous permutation was found
  <ins>and otherwise <tt>false</tt></ins>. Returns:</p>
<ul>
<li><p><ins><tt>B</tt> for the overloads in namespace <tt>std</tt>, or</ins></p></li>
<li><p><ins><tt>{ B, last }</tt> for the overloads in namespace <tt>ranges</tt>.</ins></p></li>
</ul>
<p>-10- <i>Complexity:</i> [&hellip;]</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3178" href="3178">3178.</a> <tt>std::mismatch</tt> is missing an upper bound</h3>
<p><b>Section:</b> 24.5.10 <a href="https://timsong-cpp.github.io/cppwp/mismatch">[mismatch]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2018-12-20 <b>Last modified:</b> 2019-01-26 14:10:54 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#mismatch">issues</a> in [mismatch].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following code:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v1 = {1, 2, 3, 4};
std::vector&lt;int&gt; v2 = {1, 2, 3, 5};
auto result = std::mismatch(v1.begin(), v1.begin() + 2, v2.begin(), v2.begin() + 2);
</pre></blockquote>
<p>
The current wording of [mismatch] seems to require <tt>result</tt> to be <tt>{v1.begin() + 3, v2.begin() + 3}</tt>, because 3
is the smallest integer <tt>n</tt> such that <tt>*(v1.begin() + n) != *(v2.begin + n)</tt>. In other words, if there's a
mismatch that's reachable from <tt>first1</tt> and <tt>first2</tt>, then <tt>std::mismatch</tt> must find and return it,
even if it's beyond the end iterators passed by the user.
<p/>
This is doubly unimplementable: the library has no way of knowing that it's safe to keep going past the end of the user-supplied
range, and even if it could, doing so would violate the complexity requirements. More importantly, it would violate the
fundamental convention that STL algorithms operate on user-supplied ranges, not on the underlying containers.
</p>

<p><i>[2019-01-26 Priority to 0 and Status to Tentatively Ready after discussions on the reflector]</i></p>

<p>
During that reflector discussion several contributers argued in favour for changing the current wording in
24.5.10 <a href="https://timsong-cpp.github.io/cppwp/mismatch">[mismatch]</a> p3 from "smallest integer" to "smallest <ins>nonnegative</ins> integer". This minor 
wording delta has also been added to the original proposed wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<ol>
<li><p>Change 24.5.10 <a href="https://timsong-cpp.github.io/cppwp/mismatch">[mismatch]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class InputIterator1, class InputIterator2&gt;
  constexpr pair&lt;InputIterator1, InputIterator2&gt;
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2);
[&hellip;]
namespace ranges {
  template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
           class Proj1 = identity, class Proj2 = identity,
           IndirectRelation&lt;projected&lt;I1, Proj1&gt;,
           projected&lt;I2, Proj2&gt;&gt; Pred = ranges::equal_to&lt;&gt;&gt;
    constexpr mismatch_result&lt;I1, I2>
      mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
  template&lt;InputRange R1, InputRange R2,
           class Proj1 = identity, class Proj2 = identity,
           IndirectRelation&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
           projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt; Pred = ranges::equal_to&lt;&gt;&gt;
    constexpr mismatch_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;&gt;
      mismatch(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
}
</pre>
<blockquote>
<p>
-1- Let <tt>last2</tt> be <tt>first2 + (last1 - first1)</tt> for the overloads with no parameter <tt>last2</tt> or <tt>r2</tt>.
<p/>
-2- Let <tt><i>E</i></tt> be:
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <tt>!(*(first1 + n) == *(first2 + n))</tt> for the overloads with no parameter <tt>pred</tt>,</p></li>
<li><p>(2.2) &mdash; <tt>pred(*(first1 + n), *(first2 + n)) == false</tt> for the overloads with a parameter <tt>pred</tt> and
no parameter <tt>proj1</tt>,</p></li>
<li><p>(2.3) &mdash; <tt>!invoke(pred, invoke(proj1, *(first1 + n)), invoke(proj2, *(first2 + n)))</tt> for the overloads with
both parameters <tt>pred</tt> and <tt>proj1</tt>.</p></li>
</ol>
<ins>-?- Let <tt><i>N</i></tt> be <tt>min(last1 - first1, last2 - first2)</tt>.</ins>
<p/>
-3- <i>Returns:</i> <tt>{ first1 + n, first2 + n }</tt>, where <tt>n</tt> is the smallest <ins>nonnegative</ins> integer such 
that <tt><i>E</i></tt> holds, or <tt><del>min(last1 - first1, last2 - first2)</del><ins><i>N</i></ins></tt> if no such integer 
<ins>less than <tt><i>N</i></tt></ins> exists.
<p/>
-4- <i>Complexity:</i> At most <tt><del>min(last1 - first1, last2 - first2)</del><ins><i>N</i></ins></tt> applications of the
corresponding predicate and any projections.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3183" href="3183">3183.</a> Normative permission to specialize Ranges variable templates</h3>
<p><b>Section:</b> 22.3.4.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.sizedsentinel">[iterator.concept.sizedsentinel]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2019-01-14 <b>Last modified:</b> 2019-02-03 12:20:33 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/p0896r4">P0896R4 "The One Ranges Proposal"</a> added
boolean variable templates <tt>std::disable_sized_sentinel</tt> and
<tt>std::ranges::disable_sized_range</tt> which users are intended to specialize
to <tt>false</tt> for program-defined <tt>Iterator</tt>-<tt>Sentinel</tt> pairs
/ <tt>Range</tt> types which meet the syntax but do not model
the semantics of the <tt>SizedSentinel</tt> / <tt>SizedRange</tt> concepts,
respectively. Specializing these traits allows the use of such types with the
library which would otherwise treat them as if they model <tt>SizedSentinel</tt>
/ <tt>SizedRange</tt>. The wording in P0896R4 failed, however, to provide
normative permission to specialize these variable templates as is required by
15.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> after the application of
<a href="https://wg21.link/p0551r3">P0551R3</a>.
</p><p>
Furthermore, 15.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> notably does not require that
program-defined specializations of standard library variable templates meet the
requirements on the primary template (as is the case for class templates) or
indeed any requirements. P0896R4 also added the <tt>enable_view</tt> variable
template which is used to explicitly opt in or out of the <tt>View</tt> concept
23.5.4 <a href="https://timsong-cpp.github.io/cppwp/range.view">[range.view]</a> when the default chosen by the heuristic is
incorrect. P0896R4 did include normative permission to specialize
<tt>enable_view</tt>, but the wording does not place sufficient requirements on
such user specializations so as to make them usable by the <tt>View</tt> concept
definition. Specializations must be required to be usable as constant
expressions of type <tt>bool</tt> to avoid hard errors in the concept.
</p>

<p><i>[2019-02-03 Priority to 0 and Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> This wording uses the recently-defined core language term
"usable in constant expressions" from 7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a> paragraph 3
which may be unfamiliar to reviewers.]
</p>
</blockquote>

<ol>
<li><p>Change 22.3.4.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.sizedsentinel">[iterator.concept.sizedsentinel]</a> as follows:</p>
<blockquote>
<p>
[&hellip;]
</p><p>
(2.2) &mdash; If <tt>−N</tt> is representable by
<tt>iter_difference_t&lt;I&gt;</tt>, then <tt>i - s</tt> is well-defined and
equals <tt>−N</tt>.
</p><p>
<ins>-?- Pursuant to 15.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>, users may specialize
<tt>disable_sized_sentinel</tt> for cv-unqualified non-array object types
<tt>S</tt> and <tt>I</tt> at least one of which is a program-defined type.
Such specializations shall be usable in constant expressions
(7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) and have type <tt>const bool</tt>.</ins>
</p><p>
3 [<i>Note:</i> <tt>disable_sized_sentinel</tt> allows use of sentinels and
iterators with the library that satisfy but do not in fact model
<tt>SizedSentinel</tt>.&mdash;<i>end note</i>]
</p><p>
[&hellip;]
</p>
</blockquote>
</li>
<li><p>Add an index entry for <tt>disable_sized_sentinel</tt> that points to
 [iterator.concepts.sizedsentinel].</p>
</li>
<li><p>Change 23.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a> as follows:</p>
<blockquote>
<p>
[&hellip;]
</p><p>
3 [<i>Note:</i> The complexity requirement for the evaluation of
<tt>ranges::size</tt> is non-amortized, unlike the case for the complexity of
the evaluations of <tt>ranges::begin</tt> and <tt>ranges::end</tt> in the
<tt>Range</tt> concept.&mdash;<i>end note</i>]
</p><p>
<ins>-?- Pursuant to 15.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>, users may specialize
<tt>disable_sized_range</tt> for cv-unqualified program-defined types.
Such specializations shall be usable in constant expressions
(7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) and have type <tt>const bool</tt>.</ins>
</p><p>
4 [<i>Note:</i> <tt>disable_sized_range</tt> allows use of range types with the
library that satisfy but do not in fact model <tt>SizedRange</tt>.&mdash;<i>end
note</i>]
</p>
</blockquote>
</li>
<li><p>Add an index entry for <tt>disable_sized_range</tt> that points to
23.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>.</p>
</li>
<li><p>Change 23.5.4 <a href="https://timsong-cpp.github.io/cppwp/range.view">[range.view]</a> as follows:</p>
<blockquote>
<p>
[&hellip;]
</p><p>
5 Pursuant to 15.5.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>, users may specialize
<tt>enable_view</tt> to <tt>true</tt> for <ins>cv-unqualified
program-defined</ins> types which model <tt>View</tt>, and <tt>false</tt> for
types which do not. <ins>Such specializations shall be usable in constant
expressions (7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) and have type <tt>const bool</tt>.</ins>
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3184" href="3184">3184.</a> Inconsistencies in <tt>bind_front</tt> wording</h3>
<p><b>Section:</b> 19.14.13 <a href="https://timsong-cpp.github.io/cppwp/func.bind_front">[func.bind_front]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2019-01-16 <b>Last modified:</b> 2019-01-26 14:09:17 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the merge of the <a href="https://wg21.link/p0356r5">P0356R5</a>, following "oddities" of the new wording was pointed 
out by Jens Maurer:
<ol>
<li><p>The initialization of the state entities of the <tt>bind_front/not_fn</tt> is specified using formulation "<tt>xx</tt> 
initialized with the <i>initializer</i> <tt>(yyy)</tt>". Per author knowledge this specification is correct, however 
inconsistent with the other parts of the of the standard, that direct-non-list-initialization term in such context.</p></li>
<li><p>The specification of the <i>Mandates</i> element for <tt>bind_front</tt> uses <tt>conjunction_v</tt> to specify 
conjunction of the requirements, while corresponding element of the <tt>not_fn</tt> specifies it using <tt>&amp;&amp;</tt>. 
As <tt>conjuction_v</tt> implies order of evaluation that is not necessary in this case (for every valid program, all 
provided traits must evaluate to true), it may be replaced with usage of fold expression with operator <tt>&amp;&amp;</tt>.</p></li>
</ol>
</p>

<p><i>[2019-01-26 Priority to 0 and Status to Tentatively Ready after five positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<ol>
<li><p>Change 19.14.12 <a href="https://timsong-cpp.github.io/cppwp/func.not_fn">[func.not_fn]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class F&gt; <i>unspecified</i> not_fn(F&amp;&amp; f);
</pre>
<blockquote>
<p>
-1- In the text that follows:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; [&hellip;]</p></li>
<li><p>(1.2) &mdash; [&hellip;]</p></li>
<li><p>(1.3) &mdash; <tt>fd</tt> is the target object of <tt>g</tt> (19.14.2 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a>) of type 
<tt>FD</tt> <ins>direct-non-list-initialized with</ins><del>initialized with the <i>initializer</i></del> 
<tt><del>(</del>std::forward&lt;F&gt;(f)<del>)</del></tt><del> (9.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>)</del>,</p></li>
<li><p>(1.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>
</li>

<li><p>Change 19.14.13 <a href="https://timsong-cpp.github.io/cppwp/func.bind_front">[func.bind_front]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class F, class... Args&gt;
<i>unspecified</i> bind_front(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- In the text that follows:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; [&hellip;]</p></li>
<li><p>(1.2) &mdash; [&hellip;]</p></li>
<li><p>(1.3) &mdash; <tt>fd</tt> is the target object of <tt>g</tt> (19.14.2 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a>) of type 
<tt>FD</tt> <ins>direct-non-list-initialized with</ins><del>initialized with the <i>initializer</i></del> 
<tt><del>(</del>std::forward&lt;F&gt;(f)<del>)</del></tt><del> (9.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>)</del>,</p></li>
<li><p>(1.4) &mdash; [&hellip;]</p></li>
<li><p>(1.5) &mdash; <tt>bound_args</tt> is a pack of bound argument entities of <tt>g</tt> (19.14.2 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a>) 
of types <tt>BoundArgs...</tt>, <ins>direct-non-list-initialized with</ins><del>initialized with 
<i>initializer</i>s </del><tt><del>(</del>std::forward&lt;Args&gt;(args)<del>)</del>...</tt>, 
respectively, and</p></li>
<li><p>(1.6) &mdash; [&hellip;]</p></li>
</ol>
<p>
-2- <i>Mandates:</i>
</p>
<blockquote><pre>
<ins>is_constructible_v&lt;FD, F&gt; &amp;&amp; is_move_constructible_v&lt;FD&gt; &amp;&amp; 
(is_constructible_v&lt;BoundArgs, Args&gt; &amp;&amp; ...) &amp;&amp; (is_move_constructible_v&lt;BoundArgs&gt; &amp;&amp; ...)</ins><del>conjunction_v&lt;is_constructible&lt;FD, F&gt;, is_move_constructible&lt;FD&gt;,
is_constructible&lt;BoundArgs, Args&gt;..., is_move_constructible&lt;BoundArgs&gt;...&gt;</del>
</pre></blockquote>
<p>
shall be true.
</p>
</blockquote>
</blockquote>
</li>
</ol>




</body>
</html>
