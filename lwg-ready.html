<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2020-06-16 at 22:38:11 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Jonathan Wakely &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="2731" href="2731">2731.</a> Existence of <tt>lock_guard&lt;MutexTypes...&gt;::mutex_type</tt> typedef unclear</h3>
<p><b>Section:</b> 32.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-06-13 <b>Last modified:</b> 2020-05-16 17:05:14 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.lock.guard">issues</a> in [thread.lock.guard].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis of 32.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.scoped">[thread.lock.scoped]</a> the <tt>mutex_type</tt> typedef is specified as follows:
</p>
<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class scoped_lock {
public:
  typedef Mutex mutex_type; <i>// If</i> MutexTypes... <i>consists of the single type</i> Mutex
  [&hellip;]
};
</pre>
</blockquote>
<p>
The comment seems ambiguous as it could mean either:
</p>
<ol>
<li><tt>sizeof...(MutexTypes) == 1</tt>.</li>
<li><tt>sizeof...(MutexTypes) &gt;= 1</tt> and every type in <tt>MutexTypes...</tt> is the same type.</li>
</ol>
<p>
I originally took the language to mean (2), but upon further review it seems that (1) is the intended interpretation, 
as suggested in the LEWG discussion in <a href="http://wiki.edg.com/bin/view/Wg21lenexa/N4470">Lenexa</a>.
<p/>
I think the language should be clarified to prevent implementation divergence.
</p>

<p><i>[2016-07, Toronto Saturday afternoon issues processing]</i></p>

<p>General feeling that <tt>sizeof(MutexTypes...) == 1</tt> is a better way to state the requirement.</p>
<p>Reworked the text to refer to <tt>scoped_lock</tt> instead of <tt>lock_guard</tt></p>
<p>Marshall and Eric to reword and discuss on reflector. Status to Open</p>

<p><i>[2018-3-14 Wednesday evening issues processing; general agreement to adopt once the wording is updated.]</i></p>

<p>2018-03-18 Marshall provides updated wording.</p>

<strong>Previous resolution: [SUPERSEDED]</strong>
<blockquote class="note">
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Edit 32.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a>/1, class template <tt>lock_guard</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class lock_guard {
public:
  typedef Mutex mutex_type; <i>// <ins>Only i</ins><del>I</del>f</i> MutexTypes... <i><del>consists of the</del><ins>expands to a</ins> single type</i> <tt>Mutex</tt>
  [&hellip;]
};
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<strong>Previous resolution: [SUPERSEDED]</strong>
<blockquote class="note">
<p>This wording is relative to N4727.</p>
<ol>
<li><p>Edit 32.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.guard">[thread.lock.guard]</a>/1, class template <tt>lock_guard</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class scoped_lock {
public:
  using mutex_type = Mutex; <i>// <ins>Only i</ins><del>I</del>f</i> <ins><tt>sizeof(MutexTypes...) == 1</tt></ins> <del><tt>MutexTypes...</tt> <i>consists of the single type</i> <tt>Mutex</tt></del>
  [&hellip;]
};
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-05-11; Daniel provides improved wording]</i></p>


<p><i>[2020-05-16 Reflector discussions]</i></p>

<p>Status to Tentatively Ready after five positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li><p>Edit 32.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.scoped">[thread.lock.scoped]</a>, class template <tt>scoped_lock</tt> synopsis, as indicated:</p>

<blockquote>
<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class scoped_lock {
public:
  <del>using mutex_type = Mutex; <i>// If</i> MutexTypes... <i>consists of the single type</i> Mutex</del>
  <ins>using mutex_type = <i>see below</i>; <i>// Only if </i> sizeof...(MutexTypes) == 1</ins>
  [&hellip;]
};
</pre>
</blockquote>
<p>
-1- An object of type <tt>scoped_lock</tt> controls the ownership of lockable objects within a scope. A 
<tt>scoped_lock</tt> object maintains ownership of lockable objects throughout the <tt>scoped_lock</tt> 
object's lifetime (6.7.3 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>). The behavior of a program is undefined if the lockable 
objects referenced by <tt>pm</tt> do not exist for the entire lifetime of the <tt>scoped_lock</tt> object.
</p>
<ul>
<li><p><del>When</del><ins>If</ins> <tt>sizeof...(MutexTypes)</tt> is <del><tt>1</tt></del><ins>one, let <tt>Mutex</tt> 
denote the sole type constituting the pack <tt>MutexTypes</tt>.</ins><del>, the supplied</del> <tt>Mutex</tt> 
<del>type</del> shall meet the <i>Cpp17BasicLockable</i> requirements (32.2.5.2 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.basic">[thread.req.lockable.basic]</a>).
<ins>The member <i>typedef-name</i> <tt>mutex_type</tt> denotes the same type as <tt>Mutex</tt>.</ins></p></li>
<li><p>Otherwise, <del>each of the mutex types</del><ins>all types in the template parameter pack <tt>MutexTypes</tt></ins> 
shall meet the <i>Cpp17Lockable</i> requirements (32.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.req">[thread.req.lockable.req]</a>) <ins>and there is 
no member <tt>mutex_type</tt></ins>.</p></li>
</ul> 
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2743" href="2743">2743.</a> p0083r3 <tt>node_handle</tt> private members missing "exposition only" comment</h3>
<p><b>Section:</b> 22.2.4.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-08 <b>Last modified:</b> 2020-05-16 16:34:59 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.node.overview">active issues</a> in [container.node.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.node.overview">issues</a> in [container.node.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The private members of <tt>node_handle</tt> are missing the usual "exposition only" comment. As a consequence, 
<tt>ptr_</tt> and <tt>alloc_</tt> now appear to be names defined by the library (so programs defining these names 
as macros before including a library header have undefined behavior).
<p/>
Presumably this is unintentional and these members should be considered to be for exposition only.
<p/>
It's also not clear whether the name <tt>node_handle</tt> is reserved for library usage or not; 
22.2.4.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a>/3 says the implementation need not provide a type with this name, but 
doesn't seem to rule out the possibility that an implementation will choose to do so regardless.
</p>
<p>
<b>Daniel:</b>
<p/>
A similar problem seems to exist for the exposition-only type <tt><i>call_wrapper</i></tt> from 
<a href="https://wg21.link/p0358r1">p0358r1</a>, which exposes a private data member named <tt>fd</tt> and 
a typedef <tt>FD</tt>.
</p>

<p><i>[2016-07 Chicago]</i></p>

<p>Jonathan says that we need to make clear that the name <tt>node_handle</tt> is not reserved</p>

<p><i>[2019-03-17; Daniel comments and provides wording]</i></p>

<p>
Due to an editorial step, the previous name <tt>node_handle</tt>/<tt><i>node_handle</i></tt> has been replaced 
by the artificial <tt><i>node-handle</i></tt> name, so I see no longer any reason to talk about a
name <tt>node_handle</tt> reservation. The provided wording therefore only takes care of the private
members.
</p>

<p><i>[2020-05-16 Reflector discussions]</i></p>

<p>Status to Tentatively Ready after five positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Change 22.2.4.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a>, exposition-only class template 
<tt><i>node-handle</i></tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template&lt;<i>unspecified</i>&gt;
class <i>node-handle</i> {
public:
  [&hellip;]
private:
  using container_node_type = <i>unspecified</i>; <ins><i>// exposition only</i></ins>
  using ator_traits = allocator_traits&lt;allocator_type&gt;; <ins><i>// exposition only</i></ins>
  typename ator_traits::template rebind_traits&lt;container_node_type&gt;::pointer ptr_; <ins><i>// exposition only</i></ins>
  optional&lt;allocator_type&gt; alloc_; <ins><i>// exposition only</i></ins>

public:
  [&hellip;]
};
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2820" href="2820">2820.</a> Clarify <tt>&lt;cstdint&gt;</tt> macros</h3>
<p><b>Section:</b> 17.4 <a href="https://timsong-cpp.github.io/cppwp/cstdint">[cstdint]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2016-11-12 <b>Last modified:</b> 2020-02-22 11:45:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint">issues</a> in [cstdint].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I would like clarification from LWG regarding the various limit macros like <tt>INT_8_MIN</tt> in <tt>&lt;cstdint&gt;</tt>, 
in pursuit of editorial cleanup of this header's synopsis. I have two questions:
</p>
<ol>
<li><p>At present, macros like <tt>INT_8_MIN</tt> that correspond to the optional type <tt>int8_t</tt> are required 
(unconditionally), whereas the underlying type to which they appertain is only optional. Is this deliberate? 
Should the macros also be optional?</p></li>
<li><p>Is it deliberate that C++ only specifies sized aliases for the sizes 8, 16, 32 and 64, whereas the corresponding 
C header allows type aliases and macros for arbitrary sizes for implementations that choose to provide extended integer 
types? Is the C++ wording more restrictive by accident?</p></li>
</ol>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>C11 ties the macro names to the existence of the types. Marshall to research the second question.</p>
<p>Close <a href="2764">2764</a> as a duplicate of this issue.</p>

<p><i>[2017-03-18, Thomas comments and provides wording]</i></p>

<p>
This is as close as I can get to the C wording without resolving part (a) of the issue (whether we deliberately don't 
allow sized type aliases for sizes other than 8, 16, 32, 64, a departure from C). Once we resolve part (a), we need 
to revisit <tt>&lt;cinttypes&gt;</tt> and fix up the synopsis (perhaps to get rid of <tt>N</tt>) and add similar 
wording as the one below to make the formatting macros for the fixed-width types optional. For historical interest,
this issue is related to LWG <a href="553">553</a> and LWG <a href="841">841</a>.
</p>

<p><i>[2016-07, Toronto Saturday afternoon issues processing]</i></p>

<p>Status to Open</p>

<strong>Previous resolution: [SUPERSEDED]</strong>

<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Append the following content to 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a> p2:</p>

<blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<ins>In particular, for each of the fixed-width types (<tt>int8_t</tt>, <tt>int16_t</tt>, <tt>int32_t</tt>, 
<tt>int64_t</tt>, <tt>uint8_t</tt>, <tt>uint16_t</tt>, <tt>uint32_t</tt>, <tt>uint64_t</tt>) the type alias and 
the corresponding limit macros are defined if and only if the implementation provides the corresponding type.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-10-21, Thomas K&ouml;ppe provides improved wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
<p>This wording is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>
</p>

<ol>
<li><p>Change 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, header <tt>&lt;cstdint&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
using int64_t = <i>signed integer type</i>; <i>// optional</i>
<ins>using int<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_fast64_t = <i>signed integer type</i>;
<ins>using int_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_least64_t = <i>signed integer type</i>;
<ins>using int_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint64_t = <i>unsigned integer type</i>; <i>// optional</i>
<ins>using uint<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_fast64_t = <i>unsigned integer type</i>;
<ins>using uint_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_least64_t = <i>unsigned integer type</i>;
<ins>using uint_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>

using uintmax_t = <i>unsigned integer type</i>;
using uintptr_t = <i>unsigned integer type</i>; <i>// optional</i>

<ins>#define INT_<i>N</i>_MIN  <i>see below</i>;
#define INT_<i>N</i>_MAX  <i>see below</i>;
#define UINT_<i>N</i>_MAX  <i>see below</i>;

#define INT_FAST<i>N</i>_MIN  <i>see below</i>;
#define INT_FAST<i>N</i>_MAX  <i>see below</i>;
#define UINT_FAST<i>N</i>_MAX  <i>see below</i>;

#define INT_LEAST<i>N</i>_MIN  <i>see below</i>;
#define INT_LEAST<i>N</i>_MAX  <i>see below</i>;
#define UINT_LEAST<i>N</i>_MAX  <i>see below</i>;

#define INTMAX_MIN  <i>see below</i>;
#define INTMAX_MAX  <i>see below</i>;
#define UINTMAX_MAX  <i>see below</i>;

#define INTPTR_MIN  <i>see below</i>;
#define INTPTR_MAX  <i>see below</i>;
#define UINTPTR_MAX  <i>see below</i>;

#define PTRDIFF_MIN  <i>see below</i>;
#define PTRDIFF_MAX  <i>see below</i>;
#define SIZE_MAX  <i>see below</i>;

#define SIGATOMIC_MIN  <i>see below</i>;
#define SIGATOMIC_MAX  <i>see below</i>;

#define WCHAR_MIN  <i>see below</i>;
#define WCHAR_MAX  <i>see below</i>;

#define WINT_MIN  <i>see below</i>;
#define WINT_MAX  <i>see below</i>;

#define INT<i>N</i>_C(value)  <i>see below</i>;
#define UINT<i>N</i>_C(value)  <i>see below</i>;
#define INTMAX_C(value)  <i>see below</i>;
#define UINTMAX_C(value)  <i>see below</i>;</ins>
</pre>
<p>
<del>-1- The header also defines numerous macros of the form:</del>
</p>
<blockquote><pre>
<del>INT_[FAST LEAST]{8 16 32 64}_MIN
[U]INT_[FAST LEAST]{8 16 32 64}_MAX
INT{MAX PTR}_MIN
[U]INT{MAX PTR}_MAX
{PTRDIFF SIG_ATOMIC WCHAR WINT}{_MAX _MIN}
SIZE_MAX</del>
</pre></blockquote>
<p>
<del>plus function macros of the form:</del>
</p>
<blockquote><pre>
<del>[U]INT{8 16 32 64 MAX}_C</del>
</pre></blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<span style="font-variant: small-caps;">See also</span>: ISO C 7.20
<p/>
<ins>-?- In particular, all types that use the placeholder <tt><i>N</i></tt> are optional when <tt><i>N</i></tt> is not 8, 
16, 32 or 64. The exact-width types <tt>int<i>N</i>_t</tt> and <tt>uint<i>N</i>_t</tt> for <tt><i>N</i></tt> = 8, 16, 32, 64 
are also optional; however, if an implementation provides integer types with the corresponding width, no padding bits, and 
(for the signed types) that have a two's complement representation, it defines the corresponding typedef names. Only 
those macros are defined that correspond to typedef names that the implementation actually provides. [<i>Note:</i> The macros 
<tt>INT<i>N</i>_C</tt> and <tt>UINT<i>N</i>_C</tt> correspond to the typedef names <tt>int_least<i>N</i>_t</tt> and 
<tt>uint_least<i>N</i>_t</tt>, respectively. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li><p>Change 29.12.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a> as indicated:</p>

<blockquote><pre>
#define PRId<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIX<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNd<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
[&hellip;]
</pre>
<p>
-1- The contents and meaning of the header <tt>&lt;cinttypes&gt;</tt> [&hellip;]
<p/>
<ins>-?- In particular, macros that use the placeholder <tt><i>N</i></tt> are defined if and only if the implementation 
actually provides the corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, and moreover, the <tt>fscanf</tt> macros 
are provided unless the implementation does not have a suitable <tt>fscanf</tt> length modifier for the type.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-04-03; Geoffrey Romer suggests improved wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li><p>Change 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, header <tt>&lt;cstdint&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
using int64_t = <i>signed integer type</i>; <i>// optional</i>
<ins>using int<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_fast64_t = <i>signed integer type</i>;
<ins>using int_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_least64_t = <i>signed integer type</i>;
<ins>using int_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint64_t = <i>unsigned integer type</i>; <i>// optional</i>
<ins>using uint<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_fast64_t = <i>unsigned integer type</i>;
<ins>using uint_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_least64_t = <i>unsigned integer type</i>;
<ins>using uint_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>

using uintmax_t = <i>unsigned integer type</i>;
using uintptr_t = <i>unsigned integer type</i>; <i>// optional</i>

<ins>#define INT_<i>N</i>_MIN  <i>see below</i>;
#define INT_<i>N</i>_MAX  <i>see below</i>;
#define UINT_<i>N</i>_MAX  <i>see below</i>;

#define INT_FAST<i>N</i>_MIN  <i>see below</i>;
#define INT_FAST<i>N</i>_MAX  <i>see below</i>;
#define UINT_FAST<i>N</i>_MAX  <i>see below</i>;

#define INT_LEAST<i>N</i>_MIN  <i>see below</i>;
#define INT_LEAST<i>N</i>_MAX  <i>see below</i>;
#define UINT_LEAST<i>N</i>_MAX  <i>see below</i>;

#define INTMAX_MIN  <i>see below</i>;
#define INTMAX_MAX  <i>see below</i>;
#define UINTMAX_MAX  <i>see below</i>;

#define INTPTR_MIN  <i>see below</i>;
#define INTPTR_MAX  <i>see below</i>;
#define UINTPTR_MAX  <i>see below</i>;

#define PTRDIFF_MIN  <i>see below</i>;
#define PTRDIFF_MAX  <i>see below</i>;
#define SIZE_MAX  <i>see below</i>;

#define SIGATOMIC_MIN  <i>see below</i>;
#define SIGATOMIC_MAX  <i>see below</i>;

#define WCHAR_MIN  <i>see below</i>;
#define WCHAR_MAX  <i>see below</i>;

#define WINT_MIN  <i>see below</i>;
#define WINT_MAX  <i>see below</i>;

#define INT<i>N</i>_C(value)  <i>see below</i>;
#define UINT<i>N</i>_C(value)  <i>see below</i>;
#define INTMAX_C(value)  <i>see below</i>;
#define UINTMAX_C(value)  <i>see below</i>;</ins>
</pre>
<p>
<del>-1- The header also defines numerous macros of the form:</del>
</p>
<blockquote><pre>
<del>INT_[FAST LEAST]{8 16 32 64}_MIN
[U]INT_[FAST LEAST]{8 16 32 64}_MAX
INT{MAX PTR}_MIN
[U]INT{MAX PTR}_MAX
{PTRDIFF SIG_ATOMIC WCHAR WINT}{_MAX _MIN}
SIZE_MAX</del>
</pre></blockquote>
<p>
<del>plus function macros of the form:</del>
</p>
<blockquote><pre>
<del>[U]INT{8 16 32 64 MAX}_C</del>
</pre></blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<span style="font-variant: small-caps;">See also</span>: ISO C 7.20
<p/>
<ins>-?- In particular, all types that use the placeholder <tt><i>N</i></tt> are optional when <tt><i>N</i></tt> is not 8, 
16, 32 or 64. The exact-width types <tt>int<i>N</i>_t</tt> and <tt>uint<i>N</i>_t</tt> for <tt><i>N</i></tt> = 8, 16, 32, 64 
are also optional; however, if an implementation provides integer types with the corresponding width, no padding bits, and 
(for the signed types) that have a two's complement representation, it defines the corresponding typedef names. Only 
those macros are defined that correspond to typedef names that the implementation actually provides. [<i>Note:</i> The macros 
<tt>INT<i>N</i>_C</tt> and <tt>UINT<i>N</i>_C</tt> correspond to the typedef names <tt>int_least<i>N</i>_t</tt> and 
<tt>uint_least<i>N</i>_t</tt>, respectively. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li><p>Change 29.12.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a> as indicated:</p>

<blockquote><pre>
#define PRId<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIX<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNd<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
[&hellip;]
</pre>
<p>
-1- The contents and meaning of the header <tt>&lt;cinttypes&gt;</tt> [&hellip;]
<p/>
<ins>-?- <tt>PRI</tt> macros that use the placeholder <tt><i>N</i></tt> are defined if and only if the implementation actually 
provides the corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>. <tt>SCN</tt> macros that use the placeholder 
<tt><i>N</i></tt> are defined if and only if the implementation actually provides the corresponding typedef name 
and the implementation has a suitable <tt>fscanf</tt> length modifier for the type.</ins>
</p>
</blockquote>
</li>
</ol></blockquote>

<p><i>[2019-03-11; Reflector review and improved wording]</i></p>

<p>
Wording simplifications due to new general two's complement requirements of integer types; removal of wording
redundancies and applying some typo fixes in macro names.
</p>

<p><i>[2019-03-16; Daniel comments and updates wording]</i></p>

<p>
Hubert Tong pointed out that we do not have a statement about <tt>[U]INTPTR_{MIN|MAX}</tt> being optional.
Interestingly, the C11 Standard does not say directly that the <tt>[U]INTPTR_{MIN|MAX}</tt> macros are optional,
but this follows indirectly from the fact that <tt>intptr_t</tt> and <tt>uintptr_t</tt> are indeed optional. 
The updated wording therefore realizes Hubert's suggestion.
<p/>
In addition, the reference document has been rebased to <a href="http://wg21.link/n4810">N4810</a>, because
that draft version contains an <a href="https://github.com/cplusplus/draft/pull/2638">editorial change</a>, 
which renames the term "range exponent" of integer types to "width", which is the vocabulary used below and
also matches C's use.
<p/>
Finally, Hubert Tong suggested the following rewording replacements of
</p>
<blockquote><p>
If and only if the implementation defines such a typedef name, it also defines the corresponding macros.
</p></blockquote>
<p>
to:
</p>
<blockquote><p>
Each of the macros listed in this subclause is defined if and only if the implementation defines the corresponding typedef name.
</p></blockquote>
<p>
and of
</p>
<blockquote><p>
<tt>PRI</tt> macros that use the placeholder N are defined if and only if the implementation actually defines the 
corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>. <tt>SCN</tt> macros that use the placeholder <tt><i>N</i></tt> 
are defined if and only if the implementation actually defines the corresponding typedef name and the implementation 
has a suitable <tt>fscanf</tt> length modifier for the type.
</p></blockquote>
<p>
to:
</p>
<blockquote><p>
Each of the macros listed in this subclause is defined if and only if the implementation actually defines the corresponding 
typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>.
</p></blockquote>
<p>
Those changes have been applied as well.
</p>

<p><i>[2019-03-26; Reflector discussion and minor wording update]</i></p>

<p>
Geoffrey pointed out that the revised wording has the effect that it requires an implementation to define <tt>SCN</tt>
macros for all mentioned typedefs, but the C11 standard says "the corresponding <tt>fscanf</tt> macros shall be
defined unless the implementation does not have a suitable <tt>fscanf</tt> length modifier for the type.". An additional 
wording update repairs this problem below.
</p>

<p><i>[2020-02-22; Reflector discussion]</i></p>

<p>
Status set to Tentatively Ready after seven positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.
</p>

<ol>
<li><p>Change 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, header <tt>&lt;cstdint&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
using int64_t = <i>signed integer type</i>; <i>// optional</i>
<ins>using int<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_fast64_t = <i>signed integer type</i>;
<ins>using int_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using int_least64_t = <i>signed integer type</i>;
<ins>using int_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint64_t = <i>unsigned integer type</i>; <i>// optional</i>
<ins>using uint<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_fast64_t = <i>unsigned integer type</i>;
<ins>using uint_fast<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>
[&hellip;]
using uint_least64_t = <i>unsigned integer type</i>;
<ins>using uint_least<i>N</i>_t = <i>see below</i>; <i>// optional, see below</i></ins>

using uintmax_t = <i>unsigned integer type</i>;
using uintptr_t = <i>unsigned integer type</i>; <i>// optional</i>

<ins>#define INT<i>N</i>_MIN  <i>see below</i>
#define INT<i>N</i>_MAX  <i>see below</i>
#define UINT<i>N</i>_MAX  <i>see below</i>

#define INT_FAST<i>N</i>_MIN  <i>see below</i>
#define INT_FAST<i>N</i>_MAX  <i>see below</i>
#define UINT_FAST<i>N</i>_MAX  <i>see below</i>

#define INT_LEAST<i>N</i>_MIN  <i>see below</i>
#define INT_LEAST<i>N</i>_MAX  <i>see below</i>
#define UINT_LEAST<i>N</i>_MAX  <i>see below</i>

#define INTMAX_MIN  <i>see below</i>
#define INTMAX_MAX  <i>see below</i>
#define UINTMAX_MAX  <i>see below</i>

#define INTPTR_MIN  <i>optional, see below</i>
#define INTPTR_MAX  <i>optional, see below</i>
#define UINTPTR_MAX  <i>optional, see below</i>

#define PTRDIFF_MIN  <i>see below</i>
#define PTRDIFF_MAX  <i>see below</i>
#define SIZE_MAX  <i>see below</i>

#define SIG_ATOMIC_MIN  <i>see below</i>
#define SIG_ATOMIC_MAX  <i>see below</i>

#define WCHAR_MIN  <i>see below</i>
#define WCHAR_MAX  <i>see below</i>

#define WINT_MIN  <i>see below</i>
#define WINT_MAX  <i>see below</i>

#define INT<i>N</i>_C(value)  <i>see below</i>
#define UINT<i>N</i>_C(value)  <i>see below</i>
#define INTMAX_C(value)  <i>see below</i>
#define UINTMAX_C(value)  <i>see below</i></ins>
</pre>
<p>
<del>-1- The header also defines numerous macros of the form:</del>
</p>
<blockquote><pre>
<del>INT_[FAST LEAST]{8 16 32 64}_MIN
[U]INT_[FAST LEAST]{8 16 32 64}_MAX
INT{MAX PTR}_MIN
[U]INT{MAX PTR}_MAX
{PTRDIFF SIG_ATOMIC WCHAR WINT}{_MAX _MIN}
SIZE_MAX</del>
</pre></blockquote>
<p>
<del>plus function macros of the form:</del>
</p>
<blockquote><pre>
<del>[U]INT{8 16 32 64 MAX}_C</del>
</pre></blockquote>
<p>
-2- The header defines all types and macros the same as the C standard library header <tt>&lt;stdint.h&gt;</tt>.
<span style="font-variant: small-caps;">See also</span>: ISO C 7.20
<p/>
<ins>-?- All types that use the placeholder <tt><i>N</i></tt> are optional when <tt><i>N</i></tt> is not 8, 
16, 32 or 64. The exact-width types <tt>int<i>N</i>_t</tt> and <tt>uint<i>N</i>_t</tt> for <tt><i>N</i></tt> = 8, 16, 32, 64 
are also optional; however, if an implementation defines integer types with the corresponding width and no padding bits, 
it defines the corresponding typedef names. Each of the macros listed in this subclause is defined if and only if 
the implementation defines the corresponding typedef name. [<i>Note:</i> The macros <tt>INT<i>N</i>_C</tt> and 
<tt>UINT<i>N</i>_C</tt> correspond to the typedef names <tt>int_least<i>N</i>_t</tt> and <tt>uint_least<i>N</i>_t</tt>, 
respectively. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

<li><p>Change 29.12.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a> as indicated:</p>

<blockquote><pre>
#define PRId<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIX<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNd<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNi<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNo<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNu<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNx<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxLEAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define PRIXFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNdFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNiFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNoFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNuFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
#define SCNxFAST<del>N</del><ins><i>N</i></ins> <i>see below</i>
[&hellip;]
</pre>
<p>
-1- The contents and meaning of the header <tt>&lt;cinttypes&gt;</tt> [&hellip;]
<p/>
<ins>-?- Each of the <tt>PRI</tt> macros listed in this subclause is defined if and only if the implementation defines the 
corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>. Each of the <tt>SCN</tt> macros listed in this subclause is 
defined if and only if the implementation defines the corresponding typedef name in 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a> and
has a suitable <tt>fscanf</tt> length modifier for the type.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3117" href="3117">3117.</a> Missing <tt>packaged_task</tt> deduction guides</h3>
<p><b>Section:</b> 32.9.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Marc Mutz <b>Opened:</b> 2018-06-08 <b>Last modified:</b> 2020-02-14 15:01:42 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task">issues</a> in [futures.task].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::function</tt> has deduction guides, but <tt>std::packaged_task</tt>, which is otherwise very
similar, does not. This is surprising to users and I can think of no reason for the former
to be treated differently from the latter. I therefore propose to add deduction guides for
packaged task with the same semantics as the existing ones for function.
</p>

<p><i>[2018-06-23 after reflector discussion]</i></p>

<p>Priority set to 3</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4750">N4750</a>.</p>

<ol>
<li><p>Modify 32.9.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a>, class template <tt>packaged_task</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
    [&hellip;]
  };
  
  <ins>template&lt;class R, class... ArgTypes&gt;
  packaged_task(R (*)( ArgTypes ...)) -&gt; packaged_task&lt;R( ArgTypes...)&gt;;

  template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;</ins>
  
  template&lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y) noexcept;
}
</pre>
</blockquote>
</li>

<li><p>Modify 32.9.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class F&gt;
  packaged_task(F&amp;&amp; f);
</pre>
[&hellip;]
<pre>
<ins>template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> This deduction guide participates in overload resolution only if <tt>&amp;F::operator()</tt> 
is well-formed when treated as an unevaluated operand. In that case, if <tt>decltype(&amp;F::operator())</tt> is of the 
form <tt>R(G::*)(A...) <i>cv</i> &amp;<sub><i>opt</i></sub> noexcept<sub><i>opt</i></sub></tt> for a class type <tt>G</tt>, 
then the deduced type is <tt>packaged_task&lt;R(A...)&gt;</tt>.</ins>
</p>
</blockquote>
[&hellip;]
<pre>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-02-13; Prague]</i></p>

<p>
LWG improves wording matching Marshall's Mandating paper.
</p>

<p><i>[2020-02-14; Prague]</i></p>

<p>
Do we want a feature test macro for this new feature?
</p>
<blockquote><pre>
F N A
1 7 6
</pre></blockquote>

<p><i>[Status to Ready on Friday in Prague.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 32.9.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a>, class template <tt>packaged_task</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
    [&hellip;]
  };
  
  <ins>template&lt;class R, class... ArgTypes&gt;
  packaged_task(R (*)(ArgTypes...)) -&gt; packaged_task&lt;R(ArgTypes...)&gt;;

  template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;</ins>
  
  template&lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y) noexcept;
}
</pre>
</blockquote>
</li>

<li><p>Modify 32.9.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class F&gt;
  packaged_task(F&amp;&amp; f);
</pre>
[&hellip;]
<pre>
<ins>template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>&amp;F::operator()</tt> is well-formed when treated as an unevaluated operand 
and <tt>decltype(&amp;F::operator())</tt> is of the form <tt>R(G::*)(A...) <i>cv</i> &amp;<sub><i>opt</i></sub> 
noexcept<sub><i>opt</i></sub></tt> for a class type <tt>G</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> The deduced type is <tt>packaged_task&lt;R(A...)&gt;</tt>.</ins>
</p>
</blockquote>
[&hellip;]
<pre>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3211" href="3211">3211.</a> <tt>std::tuple&lt;&gt;</tt> should be trivially constructible</h3>
<p><b>Section:</b> 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Louis Dionne <b>Opened:</b> 2019-05-29 <b>Last modified:</b> 2020-02-13 12:51:34 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
That requirement is really easy to enforce, and it has been requested by users (e.g. 
<a href="https://bugs.llvm.org/show_bug.cgi?id=41714">libc++ bug 41714</a>).
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<p>
-4- If <tt>is_trivially_destructible_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all 
<tt>T<sub><i>i</i></sub></tt>, then the destructor of <tt>tuple</tt> is trivial. 
<ins>The default constructor of <tt>tuple&lt;&gt;</tt> is trivial.</ins>
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2020-02-13, Prague]</i></p>

<p>
LWG discussion revealed that all where happy that we want this, except that the new wording should become 
a separate paragraph.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<p>
-4- If <tt>is_trivially_destructible_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all 
<tt>T<sub><i>i</i></sub></tt>, then the destructor of <tt>tuple</tt> is trivial. 
<p/>
<ins>-?- The default constructor of <tt>tuple&lt;&gt;</tt> is trivial.</ins>
</p>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3236" href="3236">3236.</a> Random access iterator requirements lack limiting relational operators domain to comparing 
those from the same range</h3>
<p><b>Section:</b> 23.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2019-07-15 <b>Last modified:</b> 2020-02-13 12:32:11 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For forward iterators we have very clear wording regarding the restricted domain of <tt>operator==</tt>
in 23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> p2:
</p>
<blockquote><p>
The domain of <tt>==</tt> for forward iterators is that of iterators over the same underlying sequence. 
However, value-initialized iterators may be compared and shall compare equal to other value-initialized 
iterators of the same type. [<i>Note:</i> Value-initialized iterators behave as if they refer past the 
end of the same empty sequence. &mdash; <i>end note</i>]
</p></blockquote>
<p>
But for the relational operators of random access iterators specified in 
23.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>, Table  [tab:randomaccessiterator],
no such domain constraints are clearly defined, except that we can infer that they are
similarly constrained as the difference of the compared iterators by means of the
operational semantics of <tt>operator&lt;</tt>.
</p>

<p><i>[2019-07-29; Casey comments and provides wording]</i></p>

<p>
Change the "Operational Semantics" column of the "<tt>a &lt; b</tt>" row of [tab:randomaccessiterator] to 
"<ins><i>Effects:</i> Equivalent to: <tt>return</tt></ins> <tt>b - a &gt; 0</tt><ins>;</ins>
<p/>
It then follows that <tt>a &lt; b</tt> is required to be well-defined over the domain for which 
<tt>b - a</tt> is required to be well-defined, which is the set of pairs <tt>(x, y)</tt> such that 
there exists a value <tt>n</tt> of type difference_type such that <tt>x + n == b</tt>.
</p>

<p><i>[2020-02-13, Prague]</i></p>

<p>
P3, but some hesitation to make it Immediate, therefore moving to Ready.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 23.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a> as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 87: <i>Cpp17RandomAccessIterator</i> requirements (in addition to 
<i>Cpp17BidirectionalIterator</i>) [tab:randomaccessiterator]</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
contextually convertible to <tt>bool</tt>
</td>
<td>
<ins><i>Effects:</i> Equivalent to: <tt>return</tt></ins> <tt>b - a &gt; 0<ins>;</ins></tt>
</td>
<td>
<tt>&lt;</tt> is a total ordering relation
</td>
</tr>

</table>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3249" href="3249">3249.</a> There are no 'pointers' in &sect;[atomics.lockfree]</h3>
<p><b>Section:</b> 31.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2019-08-03 <b>Last modified:</b> 2020-02-13 12:32:11 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.lockfree">issues</a> in [atomics.lockfree].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to SG1 experts, the requirement in [atomics.lockfree]/2 is intended to require that 
the answer for <tt>is_lock_free()</tt> be the same for a given <tt>T</tt> for a given run of 
the program. The wording does not achieve that because it's described in terms of 'pointers', 
but there are no pointers in an <tt>atomic&lt;int&gt;</tt>.
</p>

<p><i>[2020-02 Status to Ready on Thursday morning in Prague.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 31.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> as indicated:</p>

<blockquote>
<p>
-2- The function<ins>s <tt>atomic&lt;T&gt;::is_lock_free</tt>, and</ins> <tt>atomic_is_lock_free</tt> 
(31.8.1 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a>) indicate<del>s</del> whether the object is lock-free. In any given program execution, the result of the lock-free query <ins>is the same for all atomic objects</ins> <del>shall 
be consistent for all pointers</del> of the same type.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3368" href="3368">3368.</a> Exactly when does <tt>size</tt> return <tt>end - begin</tt>?</h3>
<p><b>Section:</b> 24.3.9 <a href="https://timsong-cpp.github.io/cppwp/range.prim.size">[range.prim.size]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-01-07 <b>Last modified:</b> 2020-01-25 12:29:23 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>ranges::size</tt> in 24.3.9 <a href="https://timsong-cpp.github.io/cppwp/range.prim.size">[range.prim.size]</a> suggests that bullet 1.3 
("Otherwise, <tt><i>make-unsigned-like</i>(ranges::end(E) - ranges::begin(E)) ...")</tt> only applies 
when <tt>disable_sized_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> is <tt>true</tt>. This is not the 
design intent, but the result of an erroneous attempt to factor out the common 
"<tt>disable_sized_range</tt> is <tt>false</tt>" requirement from the member and non-member <tt>size</tt> 
cases in bullets 1.2.1 and 1.2.2 that occurred between <a href="http://wg21.link/p0896r3">P0896R3</a> and 
<a href="http://wg21.link/p0896r4">P0896R4</a>. The intended design has always been that a range with 
member or non-member <tt>size</tt> with the same syntax but different semantics may opt-out of being 
sized by specializing <tt>disable_sized_range</tt>. It has never been intended that arrays or ranges 
whose iterator and sentinel model <tt>sized_sentinel_for</tt> be able to opt out of being sized via 
<tt>disable_sized_range</tt>. <tt>disable_sized_sentinel_for</tt> can/must be used to opt out in the 
latter case so that library functions oblivious to the range type that operate on the iterator and 
sentinel of such a range will avoid subtraction.
</p>

<p><i>[2020-01-25 Status set to Tentatively Ready after six positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4842">N4842</a>.</p>

<ol>
<li><p>Modify 24.3.9 <a href="https://timsong-cpp.github.io/cppwp/range.prim.size">[range.prim.size]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> There are drive-by changes here to (1) avoid introducing unused type placeholders, 
(2) avoid reusing "<tt>T</tt>" as both the type of the subexpression and the template parameter of the 
poison pill, and (3) fix the cross-reference for <tt><i>make-unsigned-like</i></tt> which is defined in 
[ranges.syn]/1, not in [range.subrange].]
</p>
</blockquote>

<blockquote>
<p>
-1- The name <tt>size</tt> denotes a customization point object (16.4.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a>). 
The expression <tt>ranges::size(E)</tt> for some subexpression <tt>E</tt> with type <tt>T</tt> is 
expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <tt><i>decay-copy</i>(extent_v&lt;T&gt;)</tt> if <tt>T</tt> is an array type 
(6.8.2 <a href="https://timsong-cpp.github.io/cppwp/basic.compound">[basic.compound]</a>).</p></li>
<li><p><del>(1.2) &mdash; Otherwise, if <tt>disable_sized_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> 
(24.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>) is <tt>false</tt>:</del></p>
<li><p>(1.<ins>?</ins><del>2.1</del>) &mdash; <ins>Otherwise, if 
<tt>disable_sized_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> (24.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>) is <tt>false</tt> 
and</ins> <tt><i>decay-copy</i>(E.size())</tt> <del>if it</del> is a valid expression <del>and its 
type <tt>I</tt> is</del><ins>of</ins> integer-like <ins>type</ins> 
(23.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>)<ins>, <tt><i>decay-copy</i>(E.size())</tt></ins>.</p></li>
<li><p>(1.<ins>?</ins><del>2.2</del>) &mdash; Otherwise, <ins>if 
<tt>disable_sized_range&lt;remove_cv_t&lt;T&gt;&gt;</tt> is <tt>false</tt> and</ins>
<tt><i>decay-copy</i>(size(E))</tt> <del>if it</del> is a valid expression <del>and its type 
<tt>I</tt> is</del><ins>of</ins> integer-like <ins>type</ins> with overload resolution performed in a 
context that includes the declaration:
<blockquote><pre>
<del>template&lt;class T&gt;</del> void size(<del>T</del><ins>auto</ins>&amp;&amp;) = delete;
</pre></blockquote>
and does not include a declaration of <tt>ranges::size</tt><ins>, <tt><i>decay-copy</i>(size(E))</tt></ins>.</p></li>
</li>
<li><p>(1.3) &mdash; Otherwise, <tt><i>make-unsigned-like</i>(ranges::end(E) - ranges::begin(E))</tt> 
(<del>24.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a></del><ins>24.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a></ins>) if it is a valid 
expression and the types <tt>I</tt> and <tt>S</tt> of 
<tt>ranges::begin(E)</tt> and <tt>ranges::end(E)</tt> (respectively) model both
<tt>sized_sentinel_for&lt;S, I&gt;</tt> (23.3.4.8 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.sizedsentinel">[iterator.concept.sizedsentinel]</a>) and 
<tt>forward_iterator&lt;I&gt;</tt>. However, <tt>E</tt> is evaluated only once.
</p></li>
<li><p>(1.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="3404" href="3404">3404.</a> Finish removing <tt>subrange</tt>'s conversions from <tt><i>pair-like</i></tt></h3>
<p><b>Section:</b> 24.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-02-20 <b>Last modified:</b> 2020-03-11 18:44:26 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.subrange">issues</a> in [range.subrange].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both LWG <a href="3281">3281</a> "Conversion from <tt><i>pair-like</i></tt> types to <tt>subrange</tt> is a 
silent semantic promotion" and LWG <a href="3282">3282</a> "<tt>subrange</tt> converting constructor should 
disallow derived to base conversions" removed <tt>subrange</tt>'s hated implicit conversions from 
<tt><i>pair-like</i></tt> types. Notably, neither issue removed the two "<tt><i>iterator-sentinel-pair</i></tt>" 
deduction guides which target the removed constructors nor the exposition-only <tt><i>iterator-sentinel-pair</i></tt> 
concept itself, all of which are now useless.
</p>

<p><i>[2020-03-11 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after seven positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.
</p>

<ol>
<li><p>Modify 24.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a> as indicated:</p>

<blockquote><pre>
[&hellip;]
template&lt;class T, class U, class V&gt;
  concept <i>pair-like-convertible-from</i> = <i>// exposition only</i>
    !range&lt;T&gt; &amp;&amp; <i>pair-like</i>&lt;T&gt; &amp;&amp; constructible_from&lt;T, U, V&gt;;

<del>template&lt;class T&gt;
  concept <i>iterator-sentinel-pair</i> = <i>// exposition only</i>
    !range&lt;T&gt; &amp;&amp; <i>pair-like</i>&lt;T&gt; &amp;&amp;
    sentinel_for&lt;tuple_element_t&lt;1, T&gt;, tuple_element_t&lt;0, T&gt;&gt;;</del>
    
[&hellip;]

<del>template&lt;<i>iterator-sentinel-pair</i> P&gt;
  subrange(P) -&gt; subrange&lt;tuple_element_t&lt;0, P&gt;, tuple_element_t&lt;1, P&gt;&gt;;</del>

<del>template&lt;<i>iterator-sentinel-pair</i> P&gt;
  subrange(P, <i>make-unsigned-like-t</i>(iter_difference_t&lt;tuple_element_t&lt;0, P&gt;&gt;)) -&gt;
    subrange&lt;uple_element_t&lt;0, P&gt;, tuple_element_t&lt;1, P&gt;, subrange_kind::sized&gt;;</del>
[&hellip;]
</pre></blockquote>
</li>
</ol>




<hr>
<h3><a name="3405" href="3405">3405.</a> <tt>common_view</tt>'s converting constructor is bad, too</h3>
<p><b>Section:</b> 24.7.13.2 <a href="https://timsong-cpp.github.io/cppwp/range.common.view">[range.common.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-02-20 <b>Last modified:</b> 2020-03-11 18:50:30 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3280">3280</a> struck the problematic/extraneous converting constructor templates from the 
<tt><i>meow</i>_view</tt> range adaptor types in the standard library with the exception of <tt>common_view</tt>. 
The omission of <tt>common_view</tt> seems to have been simply an oversight: its converting constructor 
template is no less problematic or extraneous. We should remove <tt>common_view</tt>'s converting 
constructor template as well to finish the task. Both <tt>cmcstl2</tt> and <tt>range-v3</tt> removed 
the converting constructor template from <tt>common_view</tt> when removing the other converting 
constructor templates, so we have implementation experience that this change is good as well as 
consistent with the general thrust of LWG <a href="3280">3280</a>.
</p>

<p><i>[2020-03-11 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after seven positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4849">N4849</a>.
</p>

<ol>
<li><p>Modify 24.7.13.2 <a href="https://timsong-cpp.github.io/cppwp/range.common.view">[range.common.view]</a>, class template <tt>common_view</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
  
  [&hellip;]
  constexpr explicit common_view(V r);
  
  <del>template&lt;viewable_range R&gt;
    requires (!common_range&lt;R&gt; &amp;&amp; constructible_from&lt;V, all_view&lt;R&gt;&gt;)
  constexpr explicit common_view(R&amp;&amp; r);</del>
  
  constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
  [&hellip;]
  
</pre>
[&hellip;]
<pre>
<del>template&lt;viewable_range R&gt;
  requires (!common_range&lt;R&gt; &amp;&amp; constructible_from&lt;V, all_view&lt;R&gt;&gt;)
constexpr explicit common_view(R&amp;&amp; r);</del>
</pre>
<blockquote>
<p>
<del>-2- <i>Effects:</i> Initializes <tt>base_</tt> with <tt>views::all(std::forward&lt;R&gt;(r))</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3413" href="3413">3413.</a> [fund.ts.v3] <tt>propagate_const</tt>'s <tt>swap</tt>'s <tt>noexcept</tt> specification needs to 
be constrained and use a trait</h3>
<p><b>Section:</b> 3.2.2.7 [fund.ts.v3::propagate_const.modifiers], 3.2.2.9 [fund.ts.v3::propagate_const.algorithms] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2020-02-29 <b>Last modified:</b> 2020-05-03 10:15:28 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
In the Fundamentals TS, the <tt>noexcept</tt> specifications of both the member and non-member <tt>swap</tt> 
functions for <tt>propagate_const</tt> are using the old, ill-formed pattern of attempting to use 
"<tt>noexcept(swap(...))</tt>" as the boolean predicate. According to LWG <a href="2456">2456</a>, this is 
ill-formed, and a resolution such as in <a href="http://wg21.link/p0185r1">P0185R1</a> is required.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4840">N4840</a>.
</p>

<ol>
<li><p>Modify  [fund.ts.v3::propagate_const.syn], header <tt>&lt;experimental/propagate_const&gt;</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
<i>// 3.2.2.9 [fund.ts.v3::propagate_const.algorithms], propagate_const specialized algorithms</i>
template &lt;class T&gt;
  constexpr void swap(propagate_const&lt;T&gt;&amp; pt, propagate_const&lt;T&gt;&amp; pt2) noexcept(<del><i>see below</i></del><ins>is_nothrow_swappable_v&lt;T&gt;</ins>);
</pre>
</blockquote>
</li>

<li><p>Modify 3.2.2.1 [fund.ts.v3::propagate_const.overview], class template <tt>propagate_const</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
<i>// 3.2.2.7 [fund.ts.v3::propagate_const.modifiers], propagate_const modifiers</i>
constexpr void swap(propagate_const&amp; pt) noexcept(<del><i>see below</i></del><ins>is_nothrow_swappable_v&lt;T&gt;</ins>);
</pre>
</blockquote>
</li>

<li><p>Modify 3.2.2.7 [fund.ts.v3::propagate_const.modifiers] as indicated:</p>

<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<del><i>see below</i></del><ins>is_nothrow_swappable_v&lt;T&gt;</ins>);
</pre>
<blockquote>
<p>
<del>-2- The constant-expression in the exception-specification is <tt>noexcept(swap(t_, pt.t_))</tt>.</del>
<p/>
-3- <i>Effects:</i> <tt>swap(t_, pt.t_)</tt>. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 3.2.2.9 [fund.ts.v3::propagate_const.algorithms] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt;
  constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<del><i>see below</i></del><ins>is_nothrow_swappable_v&lt;T&gt;</ins>);
</pre>
<blockquote>
<p>
<del>-2- The constant-expression in the exception-specification is <tt>noexcept(pt1.swap(pt2))</tt>.</del>
<p/>
-3- <i>Effects:</i> <tt>pt1.swap(pt2)</tt>. 
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-03-30; Reflector discussion]</i></p>

<p>
This issue has very much overlap with LWG <a href="2561">2561</a>, especially now that the library fundamentals has been rebased
to C++20 the there reported problem for the corresponding <tt>swap</tt> problem for <tt>optional</tt> is now moot. During the
reflector discussion of this issue here it was also observed that the free <tt>swap</tt> template for <tt>propagate_const</tt>
needs to be constrained. This has been done below in the revised wording which also attempts to use a similar style as
the IS.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4840">N4840</a>.
</p>

<ol>

<li><p>Modify 3.2.2.1 [fund.ts.v3::propagate_const.overview], class template <tt>propagate_const</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
<i>// 3.2.2.7 [fund.ts.v3::propagate_const.modifiers], propagate_const modifiers</i>
constexpr void swap(propagate_const&amp; pt) noexcept(<del><i>see below</i></del><ins>is_nothrow_swappable_v&lt;T&gt;</ins>);
</pre>
</blockquote>
</li>

<li><p>Modify 3.2.2.7 [fund.ts.v3::propagate_const.modifiers] as indicated:</p>

<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<del><i>see below</i></del><ins>is_nothrow_swappable_v&lt;T&gt;</ins>);
</pre>
<blockquote>
<p>
<del>-2- The constant-expression in the exception-specification is <tt>noexcept(swap(t_, pt.t_))</tt>.</del>
<p/>
-3- <i>Effects:</i> <tt>swap(t_, pt.t_)</tt>. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 3.2.2.9 [fund.ts.v3::propagate_const.algorithms] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt;
  constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
<p/>
<del>-2- The constant-expression in the exception-specification is <tt>noexcept(pt1.swap(pt2))</tt>.</del>
<p/>
-3- <i>Effects:</i> <tt>pt1.swap(pt2)</tt>. 
<p/>
<ins>-?- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:</ins>
<blockquote><pre>
<ins>noexcept(pt1.swap(pt2))</ins>
</pre></blockquote>
</p>
</blockquote>
</blockquote>
</li>
</ol></blockquote>

<p><i>[2020-04-06; Wording update upon reflector discussions]</i></p>


<p><i>[2020-05-03 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after five positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4840">N4840</a>.
</p>

<ol>

<li><p>Modify 3.2.2.1 [fund.ts.v3::propagate_const.overview], class template <tt>propagate_const</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
<i>// 3.2.2.7 [fund.ts.v3::propagate_const.modifiers], propagate_const modifiers</i>
constexpr void swap(propagate_const&amp; pt) noexcept(<del><i>see below</i></del><ins>is_nothrow_swappable_v&lt;T&gt;</ins>);
</pre>
</blockquote>
</li>

<li><p>Modify 3.2.2.7 [fund.ts.v3::propagate_const.modifiers] as indicated:</p>

<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<del><i>see below</i></del><ins>is_nothrow_swappable_v&lt;T&gt;</ins>);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> Lvalues of type <tt>T</tt> are swappable (C++17 &sect;20.5.3.2).</ins>
<p/>
<del>-2- The constant-expression in the exception-specification is <tt>noexcept(swap(t_, pt.t_))</tt>.</del>
<p/>
-3- <i>Effects:</i> <tt>swap(t_, pt.t_)</tt>. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 3.2.2.9 [fund.ts.v3::propagate_const.algorithms] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt;
  constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
<p/>
<del>-2- The constant-expression in the exception-specification is <tt>noexcept(pt1.swap(pt2))</tt>.</del>
<p/>
-3- <i>Effects:</i> <ins>Equivalent to:</ins> <tt>pt1.swap(pt2)</tt>. 
<p/>
<ins>-?- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:</ins>
<blockquote><pre>
<ins>noexcept(pt1.swap(pt2))</ins>
</pre></blockquote>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3414" href="3414">3414.</a> [networking.ts] <tt>service_already_exists</tt> has no usable constructors</h3>
<p><b>Section:</b> 13.7 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/async.exec.ctx">[networking.ts::async.exec.ctx]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-03-17 <b>Last modified:</b> 2020-04-18 12:14:05 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: networking.ts</b></p>
<p>
In the Networking TS, the <tt>service_already_exists</tt> exception type
has no constructors declared. The <tt>logic_error</tt> base class is not
default constructible, so <tt>service_already_exists</tt>'s implicit default
constructor is defined as deleted.
</p>
<p>
Implementations can add one or more private constructors that can be used
by <tt>make_service</tt>, but there seems to be little benefit to that.
The Boost.Asio type of the same name has a public default constructor.
</p>

<p><i>[2020-04-18 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after six positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4734">N4734</a>.
</p>

<ol>
<li><p>Modify 13.7 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/async.exec.ctx">[networking.ts::async.exec.ctx]</a> p1, as indicated:</p>

<blockquote>
<pre>
<i>// service access</i>
template&lt;class Service> typename Service::key_type&amp;
use_service(execution_context&amp; ctx);
template&lt;class Service, class... Args&gt; Service&amp;
make_service(execution_context&amp; ctx, Args&amp;&amp;... args);
template&lt;class Service&gt; bool has_service(const execution_context&amp; ctx) noexcept;
class service_already_exists : public logic_error <del>{ };</del>
<ins>{
public:
  service_already_exists();
};</ins>
</pre>
</blockquote>
</li>

<li>
<p>Add a new subclause after [async.exec.ctx.globals]:</p>

<blockquote>
<p>
<b>13.7.6 Class <tt>service_already_exists</tt> [async.exec.ctx.except]</b>
</p>

<p>
-1- The class <tt>service_already_exists</tt> defines the type of objects
thrown as exceptions to report an attempt to add an existing service
to an <tt>execution_context</tt>.
</p>
<pre>
service_already_exists();
</pre>
<blockquote>
<p>-2- <i>Postconditions:</i> <tt>what()</tt> returns an implementation-defined NTBS.</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3419" href="3419">3419.</a> &sect;[algorithms.requirements]/15 doesn't reserve as many rights as it intends to</h3>
<p><b>Section:</b> 25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2020-03-24 <b>Last modified:</b> 2020-04-24 18:46:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms.requirements">active issues</a> in [algorithms.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms.requirements">issues</a> in [algorithms.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>/15 says:
</p>
<blockquote><p>
"The number and order of deducible template parameters for algorithm declarations are unspecified, except 
where explicitly stated otherwise. [<i>Note:</i> Consequently, the algorithms may not be called with 
explicitly-specified template argument lists. &mdash; <i>end note</i>]"
</p></blockquote>
<p>
But the note doesn't follow from the normative rule. For example, we felt the need to explicitly allow 
deduction for <tt>min</tt>'s template parameter:
</p>
<blockquote><pre>
template&lt;typename T&gt; const T&amp; min(const T&amp;, const T&amp;);
</pre></blockquote>
<p>
&hellip; but if only the order and number of <em>deducible</em> template parameters is permitted to vary, 
then because of the required deduction behavior of this function template, there are only three possible 
valid declarations:
</p>
<blockquote><pre>
template&lt;typename T&gt; ??? min(const T&amp;, const T&amp;);
template&lt;typename T, typename U&gt; ??? min(const T&amp;, const U&amp;);
template&lt;typename T, typename U&gt; ??? min(const U&amp;, const T&amp;);
</pre></blockquote>
<p>
(up to minor differences in the parameter type). This doesn't prohibit calls with an explicitly-specified 
template argument list, contrary to the claim in the note. (Indeed, because a call such as <tt>min(1, {})</tt> 
is valid, either the first of the above three overloads must be present or there must be a default template 
argument <tt>typename U = T</tt>, which further adds to the fact that there may be valid calls with an 
explicitly-specified template argument list.)
<p/>
Also, the "explicitly stated otherwise" cases use phrasing such as: "An invocation may explicitly specify 
an argument for the template parameter <tt>T</tt> of the overloads in namespace <tt>std</tt>." which 
doesn't "specify otherwise" the normative rule, but does "specify otherwise" the claim in the note.
<p/>
All this leads me to believe that [algorithms.requirements]/15 is backwards: the normative rule should be a 
note and the note should be the normative rule.
</p>

<p><i>[2020-04-04 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after six positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> as indicated:</p>

<blockquote>
<p>
-15- The <ins>well-formedness and behavior of a call to an algorithm with an explicitly-specified template 
argument list is</ins><del>number and order of deducible template parameters for algorithm declarations are</del> 
unspecified, except where explicitly stated otherwise. [<i>Note:</i> Consequently, <ins>an implementation can 
declare an algorithm with different template parameters than those presented</ins><del>the algorithms may not be 
called with explicitly-specified template argument lists</del>. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3420" href="3420">3420.</a> <tt><i>cpp17-iterator</i></tt> should check that the type looks like an iterator first</h3>
<p><b>Section:</b> 23.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2020-02-29 <b>Last modified:</b> 2020-04-24 18:46:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.traits">active issues</a> in [iterator.traits].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.traits">issues</a> in [iterator.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is common in pre-C++20 code to rely on SFINAE-friendly <tt>iterator_traits</tt> 
to rule out non-iterators in template constraints (<tt>std::filesystem::path</tt> 
is one example in the standard library).
<p/>
C++20 changed <tt>iterator_traits</tt> to automatically detect its members in
some cases, and this detection can cause constraint recursion. LWG <a href="3244">3244</a> 
tries to fix this for <tt>path</tt> by short-circuiting the check when the source type is 
<tt>path</tt> itself, but this isn't sufficient:
</p>
<blockquote><pre>
struct Foo 
{
  Foo(const std::filesystem::path&amp;);
};

static_assert(std::copyable&lt;Foo&gt;);
</pre></blockquote>
<p>
Here the copyability determination will ask whether a <tt>path</tt> can be
constructed from a <tt>Foo</tt>, which asks whether <tt>Foo</tt> is an iterator, which
checks whether <tt>Foo</tt> is <tt>copyable</tt> [&hellip;].
<p/>
To reduce the risk of constraint recursion, we should change <tt><i>cpp17-iterator</i></tt> 
so that it does not ask about copyability until the type is known to resemble an iterator.
</p>

<p><i>[2020-04-04 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after six positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 23.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> as indicated:</p>

<blockquote>
<p>
-2- The definitions in this subclause make use of the following exposition-only concepts:
</p>
<blockquote>
<pre>
template&lt;class I&gt;
concept <i>cpp17-iterator</i> =
  <del>copyable&lt;I&gt; &amp;&amp;</del> requires(I i) {
    { *i } -&gt; <i>can-reference</i>;
    { ++i } -&gt; same_as&lt;I&amp;&gt;;
    { *i++ } -&gt; <i>can-reference</i>;
  } <ins>&amp;&amp; copyable&lt;I&gt;</ins>;
  
[&hellip;]
</pre>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3421" href="3421">3421.</a> Imperfect ADL emulation for <tt><i>boolean-testable</i></tt></h3>
<p><b>Section:</b> 18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Davis Herring <b>Opened:</b> 2020-03-24 <b>Last modified:</b> 2020-04-24 18:46:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>/4 checks for "a specialization of a class template that is a member of 
the same namespace as <tt>D</tt>", which ignores the possibility of inline namespaces.
</p>

<p><i>[2020-04-18 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after six positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a> as indicated:</p>

<blockquote>
<p>
-4- A <i>key parameter</i> of a function template <tt>D</tt> is a function parameter of type <i>cv</i> <tt>X</tt> 
or reference thereto, where <tt>X</tt> names a specialization of a class template that <ins>has the same innermost 
enclosing non-inline</ins><del>is a member of the same</del> namespace as <tt>D</tt>, and <tt>X</tt> contains at 
least one template parameter that participates in template argument deduction. [&hellip;]
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3425" href="3425">3425.</a> <tt>condition_variable_any</tt> fails to constrain its <tt>Lock</tt> parameters</h3>
<p><b>Section:</b> 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-04-04 <b>Last modified:</b> 2020-04-24 18:46:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a>/1 says "A <tt>Lock</tt> type shall meet the <i>Cpp17BasicLockable</i> 
requirements (32.2.5.2 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.basic">[thread.req.lockable.basic]</a>).", which is fine, but it notably doesn't require anything 
to be a <tt>Lock</tt> type or meet the requirements of a <tt>Lock</tt> type. Given that every member template of 
<tt>condition_variable_any</tt> has a template parameter named <tt>Lock</tt>, the intent is clearly to impose a 
requirement on the template arguments supplied for those parameters but the use of code font for "<tt>Lock</tt>" 
in the definition of "<tt>Lock</tt> type" is a bit subtle to establish that connection. We should specify this 
more clearly.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a> as indicated:</p>

<blockquote>
<p>
-1- <del>A <tt>Lock</tt> type</del><ins>Template arguments for template parameters of member templates of 
<tt>conditional_variable_any</tt> named <tt>Lock</tt></ins> shall meet the <i>Cpp17BasicLockable</i> 
requirements (32.2.5.2 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.basic">[thread.req.lockable.basic]</a>). 
[<i>Note:</i> All of the standard mutex types meet this requirement. If a <del><tt>Lock</tt></del> type other 
than one of the standard mutex types or a <tt>unique_lock</tt> wrapper for a standard mutex type is used with 
<tt>condition_variable_any</tt>, the user should ensure that any necessary synchronization is in place with 
respect to the predicate associated with the <tt>condition_variable_any</tt> instance. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-04-06; Tim improves wording]</i></p>


<p><i>[2020-04-11 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after seven positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a> as indicated:</p>

<blockquote>
<p>
-1- <del>A <tt>Lock</tt> type</del><ins>In this subclause 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a>, template 
arguments for template parameters named <tt>Lock</tt></ins> shall meet the <i>Cpp17BasicLockable</i> 
requirements (32.2.5.2 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.basic">[thread.req.lockable.basic]</a>). 
[<i>Note:</i> All of the standard mutex types meet this requirement. If a <del><tt>Lock</tt></del> type other 
than one of the standard mutex types or a <tt>unique_lock</tt> wrapper for a standard mutex type is used with 
<tt>condition_variable_any</tt>, the user should ensure that any necessary synchronization is in place with 
respect to the predicate associated with the <tt>condition_variable_any</tt> instance. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3426" href="3426">3426.</a> <tt>operator&lt;=&gt;(const unique_ptr&lt;T, D&gt;&amp;, nullptr_t)</tt> can't get no satisfaction</h3>
<p><b>Section:</b> 20.11.1.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-04-09 <b>Last modified:</b> 2020-04-24 18:46:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.special">issues</a> in [unique.ptr.special].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The constraint for <tt>operator&lt;=&gt;(const unique_ptr&lt;T, D&gt;&amp;, nullptr_t)</tt>
cannot be satisfied, because <tt>std::three_way_comparable&lt;nullptr_t&gt;</tt> is <tt>false</tt>,
because <tt>nullptr &lt;=&gt; nullptr</tt> is ill-formed.
<p/>
We can make it work as intended by comparing <tt>x.get()</tt> to <tt>pointer(nullptr)</tt>
instead of to <tt>nullptr</tt> directly.
</p>

<p><i>[2020-04-14; Replacing the functional cast by a <tt>static_cast</tt> as result of reflector discussion]</i></p>


<p><i>[2020-04-18 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after seven positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 20.10.2 <a href="https://timsong-cpp.github.io/cppwp/memory.syn">[memory.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class T, class D&gt;
  bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
template&lt;class T, class D&gt;
  requires three_way_comparable<del>_with</del>&lt;typename unique_ptr&lt;T, D&gt;::pointer<del>, nullptr_t</del>&gt;
  compare_three_way_result_t&lt;typename unique_ptr&lt;T, D&gt;::pointer<del>, nullptr_t</del>&gt;
    operator&lt;=&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.11.1.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class D&gt;
  requires three_way_comparable<del>_with</del>&lt;typename unique_ptr&lt;T, D&gt;::pointer<del>, nullptr_t</del>&gt;
  compare_three_way_result_t&lt;typename unique_ptr&lt;T, D&gt;::pointer<del>, nullptr_t</del>&gt;
    operator&lt;=&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
</pre>

<blockquote>
<p>
-18- <i>Returns:</i> <tt>compare_three_way()(x.get(), <ins>static_cast&lt;typename unique_ptr&lt;T, D&gt;::pointer&gt;(</ins>nullptr<ins>)</ins>)</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3427" href="3427">3427.</a> <tt>operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp;, nullptr_t)</tt> definition ill-formed</h3>
<p><b>Section:</b> 20.11.3.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cmp">[util.smartptr.shared.cmp]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2020-04-11 <b>Last modified:</b> 2020-05-16 17:05:38 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.cmp">issues</a> in [util.smartptr.shared.cmp].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is similar to LWG <a href="3426">3426</a>: This time the definition of 
<tt>operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp;, nullptr_t)</tt> is ill-formed, whose effects are essentially 
specified as calling:
</p>
<blockquote><pre>
compare_three_way()(a.get(), nullptr)
</pre></blockquote>
<p>
This call will be ill-formed by constraint-violation, because both <tt>nullptr &lt;=&gt; nullptr</tt> as well as 
<tt>((T*) 0) &lt;=&gt; nullptr</tt> are ill-formed.
<p/>
As a short-term solution we can make it work as intended &mdash; equivalent to LWG <a href="3426">3426</a> &mdash; by 
comparing <tt>a.get()</tt> to <tt>(element_type*) nullptr</tt> instead of to <tt>nullptr</tt> directly.
<p/>
As a long-term solution we should at least consider to deprecate the mixed relational operators as well as the 
mixed three-way comparison operator of all our smart-pointers with <tt>std::nullptr_t</tt> since the core language 
has eliminated relational comparisons of pointers with <tt>std::nullptr_t</tt> with 
<a href="http://wg21.link/n3624">N3624</a> four years after they had been originally accepted by 
<a href="http://wg21.link/cwg879">CWG 879</a>. Consequently, for C++20, the mixed three-way comparison between 
pointers and <tt>nullptr</tt> is not supported either. For this long-term solution I'm suggesting to handle this
via a proposal.
</p>

<p><i>[2020-05-16 Reflector discussions]</i></p>

<p>Status to Tentatively Ready and priority to 0 after five positive votes on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 20.11.3.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cmp">[util.smartptr.shared.cmp]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  strong_ordering operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
</pre>

<blockquote>
<p>
-5- <i>Returns:</i> <tt>compare_three_way()(a.get(), <ins>static_cast&lt;typename shared_ptr&lt;T&gt;::element_type*&gt;(</ins>nullptr<ins>)</ins>)</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3428" href="3428">3428.</a> <tt>single_view</tt>'s in place constructor should be explicit</h3>
<p><b>Section:</b> 24.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.single.view">[range.single.view]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2020-04-07 <b>Last modified:</b> 2020-04-24 18:46:57 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>in_place_t</tt> constructor template of <tt>single_view</tt> is not explicit:
</p>
<blockquote><pre>
template&lt;class... Args&gt;
  requires constructible_from&lt;T, Args...&gt;
constexpr single_view(in_place_t, Args&amp;&amp;... args);
</pre></blockquote>
<p>
so it defines an implicit conversion from <tt>std::in_place_t</tt> to
<tt>single_view&lt;T&gt;</tt> whenever <tt>constructible_from&lt;T&gt;</tt> is modeled, 
which seems unlikely to be the intent.
</p>

<p><i>[2020-04-18 Issue Prioritization]</i></p>
 
<p>
Status set to Tentatively Ready after six positive votes on the reflector.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 24.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.single.view">[range.single.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;copy_constructible T&gt;
    requires is_object_v&lt;T&gt;
  class single_view : public view_interface&lt;single_view&lt;T&gt;&gt; {
    [&hellip;]
  public:
    [&hellip;]
    template&lt;class... Args&gt;
      requires constructible_from&lt;T, Args...&gt;
    constexpr <ins>explicit</ins> single_view(in_place_t, Args&amp;&amp;... args);

    [&hellip;]
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
template&lt;class... Args&gt;
constexpr <ins>explicit</ins> single_view(in_place_t, Args&amp;&amp;... args);
</pre>

<blockquote>
<p>
-3- <i>Effects:</i> Initializes <tt>value_</tt> as if by <tt>value_{in_place, std::forward&lt;Args&gt;(args)...}</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3437" href="3437">3437.</a> <tt>__cpp_lib_polymorphic_allocator</tt> is in the wrong header</h3>
<p><b>Section:</b> 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-04-29 <b>Last modified:</b> 2020-05-09 19:32:16 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> says that <tt>__cpp_lib_polymorphic_allocator</tt> is also defined in <tt>&lt;memory&gt;</tt>, 
but <tt>std::polymorphic_allocator</tt> is defined in <tt>&lt;memory_resource&gt;</tt>. This seems like an error in 
<a href="http://wg21.link/p1902r1">P1902R1</a>. The macro should be in the same header as the feature it relates to.
</p>

<p><i>[2020-05-09; Reflector prioritization]</i></p>

<p>
Set status to Tentatively Ready after six votes in favour during reflector discussions.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_parallel_algorithm    201603L <i>// also in &lt;algorithm&gt;, &lt;numeric&gt;</i>
#define __cpp_lib_polymorphic_allocator 201902L <i>// also in &lt;<del>memory</del><ins>memory_resource</ins>&gt;</i>
#define __cpp_lib_quoted_string_io      201304L <i>// also in &lt;iomanip&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>




</body>
</html>
