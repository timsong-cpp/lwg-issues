<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues to be moved in [INSERT CURRENT MEETING HERE]</h1>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">R0165???</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left"><p>Revised 2018-12-03 at 20:40:45 UTC</p>
</td>
</tr>
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h2>Ready Issues</h2>
<hr>
<h3><a name="3012" href="3012">3012.</a> <tt>atomic&lt;T&gt;</tt> is unimplementable for non-<tt>is_trivially_copy_constructible T</tt></h3>
<p><b>Section:</b> 30.7 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2017-08-16 <b>Last modified:</b> 2018-11-12 05:21:03 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.7 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a> requires that <tt>T</tt> for <tt>std::atomic</tt> is trivially copyable. 
Unfortunately, that's not sufficient to implement <tt>atomic</tt>. Consider <tt>atomic&lt;T&gt;::load</tt>, which 
wants to look something like this:
</p>
<blockquote><pre>
template&lt;class T&gt;
struct atomic {
  __compiler_magic_storage_for_t storage;

  T load(memory_order = memory_order_seq_cst) const {
    return __magic_intrinsic(storage);
  }

};
</pre></blockquote>
<p>
Forming this return statement, though, requires that <tt>T</tt> is copy constructible &mdash; trivially copyable things 
aren't necessarily copyable! For example, the following is trivially copyable but breaks libc++, libstdc++, and msvc++:
</p>
<blockquote><pre>
struct NonAssignable {
  int i;
  NonAssignable() = delete;
  NonAssignable(int) : i(0) {}
  NonAssignable(const NonAssignable&amp;) = delete;
  NonAssignable(NonAssignable&amp;&amp;) = default;
  NonAssignable&amp; operator=(const NonAssignable&amp;) = delete;
  NonAssignable&amp; operator=(NonAssignable&amp;&amp;) = delete;
  ~NonAssignable() = default;
};
</pre></blockquote>
<p>
All three standard libraries are happy as long as <tt>T</tt> is trivially copy constructible, assignability is not required. 
Casey Carter says that we might want to still require trivially copy assignable though, since what happens when you do an 
<tt>atomic&lt;T&gt;::store</tt> is morally an "assignment" even if it doesn't use the user's assignment operator.
</p>

<p><i>[2017-11 Albuquerque Wednesday issue processing]</i></p>

<p>Status to Open; Casey and STL to work with Billy for better wording.</p>
<p>Should this include trivially copyable as well as trivially copy assignable?</p>

<p>2017-11-09, Billy O'Neal provides updated wording.</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This resolution is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 30.7 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a> as indicated:</p>

<blockquote>
<p>
-1- <ins>If <tt>is_trivially_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed</ins><del>The
template argument for <tt>T</tt> shall be trivially copyable (6.7 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>)</del>. [<i>Note:</i> Type
arguments that are not also statically initializable may be difficult to use. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This resolution is relative to <a href="http://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 30.7 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a> as indicated:</p>

<blockquote>
<p>
-1- <ins>If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt> or if
<tt>is_trivially_copyable_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed</ins><del>The
template argument for <tt>T</tt> shall be trivially copyable (6.7 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>)</del>. [<i>Note:</i> Type
arguments that are not also statically initializable may be difficult to use. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-11-12, Tomasz comments and suggests alternative wording]</i></p>

<p>
According to my understanding during Albuquerque Saturday issue processing we agreed that we want the type used 
with the atomics to have non-deleted and trivial copy/move construction and assignment.
<p/>
Wording note: <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> include semantic requirements that are not 
checkable at compile time, so these are requirements imposed on the user and cannot be validated by an
implementation without heroic efforts.
</p>

<p><i>[2018-11 San Diego Thursday night issue processing]</i></p>

<p>Status to Ready.</p>


<p><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="http://wg21.link/n4700">N4700</a>.</p>

<ol>
<li><p>Edit 30.7 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a> as indicated:</p>

<blockquote>
<p>
-1- The template argument for <tt>T</tt> shall <ins>meet the <tt>CopyConstructible</tt> and <tt>CopyAssignable</tt>
requirements. If <tt>is_trivially_copyable_v&lt;T&gt; &amp;&amp; is_copy_constructible_v&lt;T&gt; &amp;&amp; 
is_move_constructible_v&lt;T&gt; &amp;&amp; is_copy_assignable_v&lt;T&gt; &amp;&amp; is_move_assignable_v&lt;T&gt;</tt> 
is <tt>false</tt>, the program is ill-formed</ins><del>be trivially copyable (6.7 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>)</del>. 
[<i>Note:</i> Type arguments that are not also statically initializable may be difficult to use. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3040" href="3040">3040.</a> <tt>basic_string_view::starts_with</tt> <i>Effects</i> are incorrect</h3>
<p><b>Section:</b> 20.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2017-11-29 <b>Last modified:</b> 2018-10-29 17:30:42 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view.ops">issues</a> in [string.view.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects of <tt>starts_with</tt> are described as equivalent to <tt>return compare(0, npos, x) == 0</tt>.
<p/>
This is incorrect, because it returns <tt>false</tt> when you check to see if any sequence begins with the empty sequence. 
(There are other failure cases, but that one's easy)
<p/>
As a drive-by fix, we can make the <i>Effects:</i> for <tt>starts_with</tt> and <tt>ends_with</tt> clearer.
<p/>
Those are the second and proposed third changes, and they are not required.
</p>

<p><i>[
2017-12-13 Moved to Tentatively Ready after 8 positive votes for P0 on c++std-lib.
]</i></p>


<strong>Previous resolution: [SUPERSEDED]</strong>

<blockquote class="note">
<p>This wording is relative to <a href="http://wg21.link/n4713">N4713</a>.</p>

<ol>
<li><p>Change 20.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> p20 as indicated:</p>

<blockquote>
<pre>constexpr bool starts_with(basic_string_view x) const noexcept;</pre>
<blockquote>
<p>
-20- <i>Effects:</i> Equivalent to: <tt>return <ins>size() &gt;= x.size() &amp;&amp;</ins> 
compare(0, <del>npos</del><ins>x.size()</ins>, x) == 0;</tt>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> p21 as indicated:</p>
<blockquote>
<pre>constexpr bool starts_with(charT x) const noexcept;</pre>
<blockquote>
<p>
-21- <i>Effects:</i> Equivalent to: <tt>return <ins>!empty() &amp;&amp; 
traits::eq(front(), x)</ins><del>starts_with(basic_string_view(&amp;x, 1))</del>;</tt>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> p24 as indicated:</p>

<blockquote>
<pre>constexpr bool ends_with(charT x) const noexcept;</pre>
<blockquote>
<p>
-24- <i>Effects:</i> Equivalent to: <tt>return <ins>!empty() &amp;&amp; traits::eq(back(), 
x)</ins><del>ends_with(basic_string_view(&amp;x, 1))</del>;</tt>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-01-23, Reopening due to a comment of Billy Robert O'Neal III requesting a change of the proposed 
wording]</i></p>

<p>
The currently suggested wording has:
</p>
<blockquote><p>
<i>Effects:</i> Equivalent to: <tt>return size() &gt;= x.size() &amp;&amp; compare(0, x.size(), x) == 0;</tt>
</p></blockquote>
<p>
but <tt>compare()</tt> already does the <tt>size() &gt;= x.size()</tt> check.
<p/>
It seems like it should say:
</p>
<blockquote><p>
<i>Effects:</i> Equivalent to: <tt>return substr(0, x.size()) == x;</tt>
</p></blockquote>

<p><i>[
2018-10-29 Moved to Tentatively Ready after 5 positive votes for P0 on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4713">N4713</a>.</p>

<ol>
<li><p>Change 20.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> p20 as indicated:</p>

<blockquote>
<pre>constexpr bool starts_with(basic_string_view x) const noexcept;</pre>
<blockquote>
<p>
-20- <i>Effects:</i> Equivalent to: <tt>return <ins>substr(0, x.size()) == x</ins><del>compare(0, 
npos, x) == 0</del>;</tt>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> p21 as indicated:</p>
<blockquote>
<pre>constexpr bool starts_with(charT x) const noexcept;</pre>
<blockquote>
<p>
-21- <i>Effects:</i> Equivalent to: <tt>return <ins>!empty() &amp;&amp; 
traits::eq(front(), x)</ins><del>starts_with(basic_string_view(&amp;x, 1))</del>;</tt>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> p24 as indicated:</p>

<blockquote>
<pre>constexpr bool ends_with(charT x) const noexcept;</pre>
<blockquote>
<p>
-24- <i>Effects:</i> Equivalent to: <tt>return <ins>!empty() &amp;&amp; traits::eq(back(), 
x)</ins><del>ends_with(basic_string_view(&amp;x, 1))</del>;</tt>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3077" href="3077">3077.</a> <tt>(push|emplace)_back</tt> should invalidate the <tt>end</tt> iterator</h3>
<p><b>Section:</b> 21.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-03-10 <b>Last modified:</b> 2018-12-01 15:00:55 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> paragraph 1 specifies that <tt>emplace_back</tt>
and <tt>push_back</tt> do not invalidate iterators before the insertion point when
reallocation is unnecessary:
<blockquote>
<i>Remarks:</i> Causes reallocation if the new size is greater than the old capacity.
Reallocation invalidates all the references, pointers, and iterators referring to
the elements in the sequence. If no reallocation happens, all the iterators and
references before the insertion point remain valid. [&hellip;]
</blockquote>
This statement is redundant, given the blanket wording in
21.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> paragraph 12:
<blockquote>
Unless otherwise specified (either explicitly or by defining a function in terms
of other functions), invoking a container member function or passing a container
as an argument to a library function shall not invalidate iterators to, or change
the values of, objects within that container.
</blockquote>
It seems that this second sentence (1) should be a note that reminds us that the
blanket wording applies here when no reallocation occurs, and/or (2) actually
intends to specify that iterators at and after the insertion point are invalidated.
</p>
<p>
Also, it seems intended that reallocation should invalidate the <tt>end</tt>
iterator as well.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<ol>
<li>
<p>Edit 21.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> as indicated:</p>
<blockquote>
<p>
-1- <i>Remarks:</i> <ins>Invalidates the past-the-end iterator.</ins> Causes
reallocation if the new size is greater than the old capacity. Reallocation
invalidates all the references, pointers, and iterators referring to the elements
in the sequence. <ins>[<i>Note:</i></ins> If no reallocation happens, all the
iterators and references before the insertion point remain
valid.<ins>&mdash;<i>end note</i>]</ins> If an exception is thrown [&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-11-28 Casey provides an updated P/R]</i></p>

Per discussion in the prioritization thread on the reflector.

<p><i>[2018-12-01 Status to Tentatively Ready after seven positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to the post-San Diego working draft.
</p>

<ol>
<li>
<p>Change 20.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
</blockquote>
<p>
-11- <i>Effects:</i> <tt>shrink_­to_­fit</tt> is a non-binding request to reduce
<tt>capacity()</tt> to <tt>size()</tt>. [ <i>Note:</i> The request is
non-binding to allow latitude for implementation-specific optimizations.
&mdash; <i>end note</i> ] It does not increase <tt>capacity()</tt>, but may
reduce <tt>capacity()</tt> by causing reallocation.
</p><p>
-12- <i>Complexity:</i> <ins>If the size is not equal to the old capacity,</ins>
linear in the size of the sequence<ins>; otherwise constant</ins>.
</p><p>
-13- <i>Remarks:</i> Reallocation invalidates all the references, pointers, and
iterators referring to the elements in the sequence<ins>,</ins> as well as the
past-the-end iterator. <ins>[ <i>Note:</i></ins> If no reallocation happens,
they remain valid. <ins>&mdash; <i>end note</i> ]</ins>
</p>
</blockquote>
</li>
<li>
<p>Change 21.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
</blockquote>
<p>
-5- <i>Requires:</i> <tt>T</tt> shall be <i><tt>Cpp17MoveInsertable</tt></i>
into <tt>*this</tt>.
</p><p>
-6- <i>Effects:</i> <tt>shrink_­to_­fit</tt> is a non-binding request to reduce
memory use but does not change the size of the sequence. [ <i>Note:</i> The
request is non-binding to allow latitude for implementation-specific
optimizations. &mdash;<i>end note</i> ] If <ins>the size is equal to
the old capacity, or if</ins> an exception is thrown other than by
the move constructor of a non-<i><tt>Cpp17CopyInsertable</tt></i>
<tt>T</tt><ins>, then</ins> there are no effects.
</p><p>
-7- <i>Complexity:</i> <ins>If the size is not equal to the old capacity,</ins>
linear in the size of the sequence<ins>; otherwise constant</ins>.
</p><p>
-8- <i>Remarks:</i> <del><tt>shrink_to_fit</tt></del> <ins>If the size is not
equal to the old capacity, then</ins> invalidates all the references, pointers,
and iterators referring to the elements in the sequence<ins>,</ins> as well as
the past-the-end iterator.
</p>
</blockquote>
</li>
<li>
<p>Change 21.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
void reserve(size_type n);
</pre>
</blockquote>
<p>[&hellip;]</p>
<p>
-7- <i>Remarks:</i> Reallocation invalidates all the references, pointers, and
iterators referring to the elements in the sequence<ins>, as well as the
past-the-end iterator</ins>. <ins>[ <i>Note:</i> If no reallocation happens,
they remain valid. &mdash; <i>end note</i> ]</ins> No reallocation shall take place
during insertions that happen after a call to <tt>reserve()</tt> until <del>the
time when</del> an insertion would make the size of the vector greater than the
value of <tt>capacity()</tt>.
</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
</blockquote>
<p>[&hellip;]</p>
<p>
-10- <i>Complexity:</i> <ins>If reallocation happens,</ins> linear in the size
of the sequence.
</p><p>
-11- <i>Remarks:</i> Reallocation invalidates all the references, pointers, and
iterators referring to the elements in the sequence<ins>,</ins> as well as the
past-the-end iterator. <ins>[ <i>Note:</i></ins> If no reallocation happens,
they remain valid. <ins>&mdash; <i>end
note</i> ]</ins>
</p>
</blockquote>
</li>
<li>
<p>Change 21.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> as indicated:</p>
<blockquote>
<p>
-1- <i>Remarks:</i> Causes reallocation if the new size is greater than the old
capacity. Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence <ins>as well as the past-the-end
iterator</ins>. If no reallocation happens, <del>all the iterators and
references</del> <ins>then references, pointers, and iterators</ins> before the
insertion point remain valid <ins>but those at or after the insertion point,
including the past-the-end iterator, are invalidated</ins>.
If an exception is thrown [&hellip;]
</p><p>
-2- <i>Complexity:</i> <del>The complexity is</del> <ins>If reallocation
happens, linear in the number of elements of the resulting vector;
otherwise</ins> linear in the number of elements inserted plus the distance to
the end of the vector.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3087" href="3087">3087.</a> One final <tt>&amp;x</tt> in &sect;[list.ops]</h3>
<p><b>Section:</b> 21.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-03-19 <b>Last modified:</b> 2018-10-15 17:07:29 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#list.ops">active issues</a> in [list.ops].</p>
<p><b>View all other</b> <a href="lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3017">3017</a> missed an instance of <tt>&amp;x</tt> in 21.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p14.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>

<p><i>[2018-10-15 Status to Tentatively Ready after seven positive votes on the reflector.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4727">N4727</a>.</p>

<ol>
<li><p>Edit 21.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> as indicated:</p>
<blockquote>
<pre>
void splice(const_iterator position, list&amp; x, const_iterator first,
            const_iterator last);
void splice(const_iterator position, list&amp;&amp; x, const_iterator first,
            const_iterator last);
</pre>
<blockquote>
<p>
-11- <i>Requires:</i> [&hellip;]
<p/>
-12- <i>Effects:</i> [&hellip;]
<p/>
-13- <i>Throws:</i> Nothing.
<p/>
-14- <i>Complexity:</i> Constant time if <tt><del>&amp;</del><ins>addressof(</ins>x<ins>)</ins> == this</tt>; otherwise, linear time.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3101" href="3101">3101.</a> <tt>span</tt>'s <tt>Container</tt> constructors need another constraint</h3>
<p><b>Section:</b> 21.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/span.cons">[span.cons]</a> <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2018-04-12 <b>Last modified:</b> 2018-11-12 05:21:03 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#span.cons">issues</a> in [span.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I overhauled <tt>span</tt>'s constructor constraints, I was careful about the built-in array, <tt>std::array</tt>, 
and converting <tt>span</tt> constructors. These types contain bounds information, so we can achieve safety at 
compile-time by permitting implicit conversions if and only if the destination extent is dynamic (this accepts 
anything by recording the size at runtime) or the source and destination extents are identical. However, I missed 
the fact that the <tt>Container</tt> constructors are the opposite case. A <tt>Container</tt> (e.g. a <tt>vector</tt>) 
has a size that's known only at runtime. It's safe to convert this to a <tt>span</tt> with <tt>dynamic_extent</tt>, 
but for consistency and safety, this shouldn't implicitly convert to a <tt>span</tt> with fixed extent. (The more 
verbose <tt>(ptr, count)</tt> and <tt>(first, last)</tt> constructors are available to construct fixed extent spans 
from runtime-length ranges. Note that debug precondition checks are equally possible with the <tt>Container</tt> and 
<tt>(ptr, count)</tt>/<tt>(first, last)</tt> constructors. The issue is that implicit conversions are notoriously 
problematic, so they should be permitted only when they are absolutely known to be safe.)
</p>

<p><i>[2018-04-24 Priority set to 1 after discussion on the reflector.]</i></p>


<p><i>[2018-06 Rapperswil Thursday issues processing]</i></p>

<p>Status to LEWG. Should this be ill-formed, or fail at runtime if the container is too small?
Discussion on the reflector <a href="http://lists.isocpp.org/lib/2018/04/6719.php">here</a>.</p>

<p><i>[2018-11 San Diego Saturday]</i></p>

<p>LEWG said that they're fine with the proposed resolution. Status to Tentatively Ready.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4741">N4741</a>.</p>

<blockquote>
<ol>
<li>
<p>Edit 21.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/span.cons">[span.cons]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class Container&gt; constexpr span(Container&amp; cont);
template&lt;class Container&gt; constexpr span(const Container&amp; cont);
</pre>
<blockquote>
<p>
-14- <i>Requires:</i> <tt>[data(cont), data(cont) + size(cont))</tt> shall be a valid range. <del>If <tt>extent</tt> is 
not equal to <tt>dynamic_extent</tt>, then <tt>size(cont)</tt> shall be equal to <tt>extent</tt>.</del>
<p/>
-15- <i>Effects:</i> Constructs a <tt>span</tt> that is a view over the range <tt>[data(cont), data(cont) + size(cont))</tt>.
<p/>
-16- <i>Postconditions:</i> <tt>size() == size(cont) &amp;&amp; data() == data(cont)</tt>.
<p/>
-17- <i>Throws:</i> What and when <tt>data(cont)</tt> and <tt>size(cont)</tt> throw.
<p/>
-18- <i>Remarks:</i> These constructors shall not participate in overload resolution unless:
</p>
<ol style="list-style-type: none">
<li><p><ins>(18.?) &mdash; <tt>extent == dynamic_extent</tt>,</ins></p></li>
<li><p>(18.1) &mdash; <tt>Container</tt> is not a specialization of <tt>span</tt>,</p></li>
<li><p>(18.2) &mdash; <tt>Container</tt> is not a specialization of <tt>array</tt>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>





<hr>
<h3><a name="3119" href="3119">3119.</a> Program-definedness of closure types</h3>
<p><b>Section:</b> 99 [defns.program.defined.spec] <b>Status:</b> <a href="lwg-active.html#Ready">Ready</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2018-06-09 <b>Last modified:</b> 2018-11-12 05:21:03 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Ready">Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The description of closure types in 7.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/expr.prim.lambda.closure">[expr.prim.lambda.closure]</a> says:
</p>
<blockquote>
<p>
An implementation may define the closure type differently [&hellip;]
</p>
</blockquote>
<p>
The proposed resolution to LWG <a href="2139">2139</a> defines a "program-defined type" to be a
</p>
<blockquote>
<p>
class type or enumeration type that is not part of the C++ standard library and not defined by the implementation,
or an instantiation of a program-defined specialization
</p>
</blockquote>
<p>
I am not sure that the intent of whether closure types are or are not program-defined types is clearly
conveyed by the wording.
</p>

<p><i>[2018-06-23 after reflector discussion]</i></p>

<p>Priority set to 2</p>

<p><i>[2018-08-14 Casey provides additional discussion and a Proposed Resolution]</i></p>

<p>
We use the term "program-defined" in the library specification to ensure that
two users cannot create conflicts in a component in namespace <tt>std</tt> by
specifying different behaviors for the same type. For example, we allow users to
specialize <tt>common_type</tt> when at least one of the parameters is a
program-defined type. Since two users cannot define the same program-defined
type, this rule prevents two users (or libraries) defining the same
specialization of <tt>std::common_type</tt>.
</p><p>
Since it's guaranteed that even distinct utterances of identical lambda
expressions produce closures with distinct types
(7.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/expr.prim.lambda.closure">[expr.prim.lambda.closure]</a>), adding closure types to our term
"program-defined type" is consistent with the intended use despite that such
types are technically defined by the implementation.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ul>
<li><p>Modify 15.3.20 <a href="https://timsong-cpp.github.io/cppwp/defns.prog.def.type">[defns.prog.def.type]</a> as follows:</p>
<blockquote>
<b>program-defined type</b><br/>
class type or enumeration type that is not part of the C++ standard library and
not defined by the implementation <ins>(except for closure types
(7.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/expr.prim.lambda.closure">[expr.prim.lambda.closure]</a>) for program-defined lambda
expressions)</ins>, or an instantiation of a program-defined specialization
</blockquote>
</li>
</ul>
</blockquote>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Updated wording</p>

<p><i>[2018-11 San Diego Thursday night issue processing]</i></p>

<p>Status to Ready.</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ul>
<li><p>Modify 15.3.20 <a href="https://timsong-cpp.github.io/cppwp/defns.prog.def.type">[defns.prog.def.type]</a> as follows:</p>
<blockquote>
<b>program-defined type</b><br/>
<ins>non-closure </ins>class type or enumeration type that is not part of the 
C++ standard library and not defined by the implementation, 
<ins>or a closure type of a non-implementation-provided lambda expression, </ins>
or an instantiation of a program-defined specialization
</blockquote>
</li>
</ul>






</body>
</html>
