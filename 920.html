<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 920: Ref-qualification support in the library</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="920" href="920">920.</a> Ref-qualification support in the library</h3>
<p><b>Section:</b> 23.14.12 <a href="https://timsong-cpp.github.io/cppwp/func.memfn">[func.memfn]</a> <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Bronek Kozicki <b>Opened:</b> 2008-10-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.memfn">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/func.memfn">[func.memfn]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Duplicate of:</b> <a href="1230">1230</a></p>
<p><b>Discussion:</b></p>
<p>
Daniel Kr&uuml;gler wrote:
</p>

<blockquote>
<p>
Shouldn't above list be completed for &amp;- and &amp;&amp;-qualified
member functions This would cause to add:
</p>
<blockquote><pre>
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const volatile &amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);
template&lt;Returnable R, class T, CopyConstructible... Args&gt;
unspecified mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);
</pre></blockquote>

</blockquote>

<p>
yes, absolutely. Thanks for spotting this. Without this change <tt>mem_fn</tt>
cannot be initialized from pointer to ref-qualified member function. I
believe semantics of such function pointer is well defined.
</p>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We need to think about whether we really want to go down the proposed path
of combinatorial explosion.
Perhaps a Note would suffice.
</p>
<p>
We would really like to have an implementation before proceeding.
</p>
<p>
Move to Open, and recommend this be deferred until after the next
Committee Draft has been issued.
</p>
</blockquote>

<p><i>[
2009-10-10 Daniel updated wording to post-concepts.
]</i></p>


<blockquote><p>
<a href="1230">1230</a> has a similar proposed resolution
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Move to Ready.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>/2, header
<tt>&lt;functional&gt;</tt> synopsis as follows:
</p>

<blockquote><pre>
// 20.7.14, member function adaptors:
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</ins>
</pre></blockquote>
</li>

<li>
<p>
Change the prototype list of 23.14.12 <a href="https://timsong-cpp.github.io/cppwp/func.memfn">[func.memfn]</a> as follows [NB: The
following text, most notably p.2 and p.3 which
discuss influence of the cv-qualification on the definition of the
base class's first template parameter remains
unchanged. ]:
</p>

<blockquote><pre>
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm);

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile &amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile &amp;&amp;);</ins>
</pre></blockquote>
</li>

<li>
<p>
Remove 23.14.12 <a href="https://timsong-cpp.github.io/cppwp/func.memfn">[func.memfn]</a>/5:
</p>

<blockquote><p>
<del><i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set of
overloaded function templates.</del>
</p></blockquote>
</li>
</ol>






</body>
</html>
