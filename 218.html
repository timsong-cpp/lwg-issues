<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 218: Algorithms do not use binary predicate objects for default comparisons</title>
<meta property="og:title" content="Issue 218: Algorithms do not use binary predicate objects for default comparisons">
<meta property="og:description" content="C++ library issue. Status: NAD">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/218.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="218"><a href="lwg-closed.html#218">218</a>. Algorithms do not use binary predicate objects for default comparisons</h3>
<p><b>Section:</b> 26.8 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2000-03-06 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Many of the algorithms take an argument, pred, of template parameter type
BinaryPredicate or an argument comp of template parameter type Compare. These
algorithms usually have an overloaded version that does not take the predicate
argument. In these cases pred is usually replaced by the use of operator== and
comp is replaced by the use of operator&lt;.</p>
<p>This use of hard-coded operators is inconsistent with other parts of the
library, particularly the containers library, where equality is established
using equal_to&lt;&gt; and ordering is established using less&lt;&gt;. Worse,
the use of operator&lt;, would cause the following innocent-looking code to have
undefined behavior:</p>
<blockquote>
  <pre>vector&lt;string*&gt; vec;
sort(vec.begin(), vec.end());</pre>
</blockquote>
<p>The use of operator&lt; is not defined for pointers to unrelated objects. If
std::sort used less&lt;&gt; to compare elements, then the above code would be
well-defined, since less&lt;&gt; is explicitly specialized to produce a total
ordering of pointers.</p>


<p><b>Rationale:</b></p>
<p>This use of operator== and operator&lt; was a very deliberate, conscious, and
explicitly made design decision; these operators are often more efficient. The
predicate forms are available for users who don't want to rely on operator== and
operator&lt;.</p>




</body>
</html>
