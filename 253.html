<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 253: valarray helper functions are almost entirely useless</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-22 at 01:11:47 UTC</p>
<hr>
<h3><a name="253" href="253">253.</a> valarray helper functions are almost entirely useless</h3>
<p><b>Section:</b> 26.7.2.2 [valarray.cons], 26.7.2.3 [valarray.assign] <b>Status:</b> <a href="lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2000-07-31 <b>Last modified:</b> 2016-11-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>This discussion is adapted from message c++std-lib-7056 posted
November 11, 1999.  I don't think that anyone can reasonably claim
that the problem described below is NAD.</p>

<p>These valarray constructors can never be called:</p>

<pre>
   template &lt;class T&gt;
         valarray&lt;T&gt;::valarray(const slice_array&lt;T&gt; &amp;);
   template &lt;class T&gt;
         valarray&lt;T&gt;::valarray(const gslice_array&lt;T&gt; &amp;);
   template &lt;class T&gt;
         valarray&lt;T&gt;::valarray(const mask_array&lt;T&gt; &amp;);
   template &lt;class T&gt;
         valarray&lt;T&gt;::valarray(const indirect_array&lt;T&gt; &amp;);
</pre>

<p>Similarly, these valarray assignment operators cannot be
called:</p>

<pre>
     template &lt;class T&gt;
     valarray&lt;T&gt; valarray&lt;T&gt;::operator=(const slice_array&lt;T&gt; &amp;);
     template &lt;class T&gt;
     valarray&lt;T&gt; valarray&lt;T&gt;::operator=(const gslice_array&lt;T&gt; &amp;);
     template &lt;class T&gt;
     valarray&lt;T&gt; valarray&lt;T&gt;::operator=(const mask_array&lt;T&gt; &amp;);
     template &lt;class T&gt;
     valarray&lt;T&gt; valarray&lt;T&gt;::operator=(const indirect_array&lt;T&gt; &amp;);
</pre>

<p>Please consider the following example:</p>

<pre>
   #include &lt;valarray&gt;
   using namespace std;

   int main()
   {
       valarray&lt;double&gt; va1(12);
       valarray&lt;double&gt; va2(va1[slice(1,4,3)]); // line 1
   }
</pre>


<p>Since the valarray va1 is non-const, the result of the sub-expression
va1[slice(1,4,3)] at line 1 is an rvalue of type const
std::slice_array&lt;double&gt;.  This slice_array rvalue is then used to
construct va2.  The constructor that is used to construct va2 is
declared like this:</p>

<pre>
     template &lt;class T&gt;
     valarray&lt;T&gt;::valarray(const slice_array&lt;T&gt; &amp;);
</pre>

<p>Notice the constructor's const reference parameter.  When the
constructor is called, a slice_array must be bound to this reference.
The rules for binding an rvalue to a const reference are in 8.5.3,
paragraph 5 (see also 13.3.3.1.4).  Specifically, paragraph 5
indicates that a second slice_array rvalue is constructed (in this
case copy-constructed) from the first one; it is this second rvalue
that is bound to the reference parameter.  Paragraph 5 also requires
that the constructor that is used for this purpose be callable,
regardless of whether the second rvalue is elided.  The
copy-constructor in this case is not callable, however, because it is
private.  Therefore, the compiler should report an error.</p>

<p>Since slice_arrays are always rvalues, the valarray constructor that has a
parameter of type const slice_array&lt;T&gt; &amp; can never be called.  The
same reasoning applies to the three other constructors and the four
assignment operators that are listed at the beginning of this post.
Furthermore, since these functions cannot be called, the valarray helper
classes are almost entirely useless.</p>


<p><b>Proposed resolution:</b></p>
<p>slice_array:</p>
<ul>
<li> Make the copy constructor and copy-assignment operator declarations
     public in the slice_array class template definition in 26.7.5 [template.slice.array] </li>
<li> remove paragraph 3 of 26.7.5 [template.slice.array]</li>
<li> remove the copy constructor declaration from  [cons.slice.arr]</li>
<li> change paragraph 1 of  [cons.slice.arr] to read "This constructor is declared
    to be private.  This constructor need not be defined."</li>
<li> remove the first sentence of paragraph 1 of 26.7.5.2 [slice.arr.assign]</li>
<li> Change the first three words of the second sentence of paragraph 1 of
    26.7.5.2 [slice.arr.assign] to "These assignment operators have"</li>
</ul>

<p>gslice_array:</p>
<ul>
<li> Make the copy constructor and copy-assignment operator declarations
    public in the gslice_array class template definition in 26.7.7 [template.gslice.array] </li>
<li> remove the note in paragraph 3 of 26.7.7 [template.gslice.array]</li>
<li> remove the copy constructor declaration from  [gslice.array.cons]</li>
<li> change paragraph 1 of  [gslice.array.cons] to read "This constructor is declared
    to be private.  This constructor need not be defined."</li>
<li> remove the first sentence of paragraph 1 of 26.7.7.2 [gslice.array.assign]</li>
<li> Change the first three words of the second sentence of paragraph 1 of
    26.7.7.2 [gslice.array.assign] to "These assignment operators have"</li>
</ul>

<p>mask_array:</p>
<ul>
<li> Make the copy constructor and copy-assignment operator declarations
    public in the mask_array class template definition in 26.7.8 [template.mask.array] </li>
<li> remove the note in paragraph 2 of 26.7.8 [template.mask.array]</li>
<li> remove the copy constructor declaration from  [mask.array.cons]</li>
<li> change paragraph 1 of  [mask.array.cons] to read "This constructor is declared
    to be private.  This constructor need not be defined."</li>
<li> remove the first sentence of paragraph 1 of 26.7.8.2 [mask.array.assign]</li>
<li> Change the first three words of the second sentence of paragraph 1 of
    26.7.8.2 [mask.array.assign] to "These assignment operators have"</li>
</ul>

<p>indirect_array:</p>
<ul>
<li>Make the copy constructor and copy-assignment operator declarations
    public in the indirect_array class definition in 26.7.9 [template.indirect.array]</li>
<li> remove the note in paragraph 2 of 26.7.9 [template.indirect.array]</li>
<li> remove the copy constructor declaration from  [indirect.array.cons]</li>
<li> change the descriptive text in  [indirect.array.cons] to read "This constructor is
    declared to be private.  This constructor need not be defined."</li>
<li> remove the first sentence of paragraph 1 of 26.7.9.2 [indirect.array.assign]</li>
<li> Change the first three words of the second sentence of paragraph 1 of
    26.7.9.2 [indirect.array.assign] to "These assignment operators have"</li>
</ul>
<p><i>[Proposed resolution was modified in Santa Cruz: explicitly make
copy constructor and copy assignment operators public, instead of
removing them.]</i></p>



<p><b>Rationale:</b></p>
<p>Keeping the valarray constructors private is untenable.  Merely
making valarray a friend of the helper classes isn't good enough,
because access to the copy constructor is checked in the user's
environment.</p>

<p>Making the assignment operator public is not strictly necessary to
solve this problem.  A majority of the LWG <i>(straw poll: 13-4)</i>
believed we should make the assignment operators public, in addition
to the copy constructors, for reasons of symmetry and user
expectation.</p>





</body>
</html>
