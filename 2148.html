<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2148: Hashing enums should be supported directly by std::hash</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="2148" href="2148">2148.</a> Hashing enums should be supported directly by <tt>std::hash</tt></h3>
<p><b>Section:</b> 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#C++14">C++14</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2012-04-10 <b>Last modified:</b> 2016-08-03 19:08:00 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>.</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++14">C++14</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">paper</a> 
proposes various hashing improvements. What it doesn't mention is hashing of
enums; enums are integral types, and users expect them to have built-in hashing
support, rather than having to convert enums to ints for uses with
unordered containers and other uses of hashes. Daniel Kr&uuml;gler explains in c++std-lib-32412
that this is not achievable with a SFINAEd hash specialization because it would require
a partial specialization with a type parameter and a non-type parameter with a
default argument, which is currently not allowed, and hence the fixes in N3333 should be
adopted instead.
</p>

<p><i>[2012-10 Portland: Move to Open]</i></p>

<p>
We agree this is a real issue that should be resolved, by specifying such a hash.
</p>

<p>
It is not clear that we should specify this as calling hash on the <tt>underlying_type</tt>,
or whether that is overspecification and we merely require that the hash be supplied.
</p>

<p>
STL already has shipped an implementation, and is keen to provide wording.
</p>

<p><i>[
2013-04-14 STL provides rationale and improved wording
]</i></p>


<p>Rationale:</p>
<p>This can be achieved by inserting a very small tweak to the Standardese. We merely have to require that <tt>hash&lt;Key&gt;</tt> 
be valid when <tt>Key</tt> is an "enumeration type" (which includes both scoped and unscoped enums). This permits, but does 
not require, <tt>hash&lt;Enum&gt;</tt> to behave identically to <tt>hash&lt;underlying_type&lt;Enum&gt;::type&gt;</tt>, following 
existing precedent &mdash; note that when <tt>unsigned int</tt> and <tt>unsigned long</tt> are the same size, 
<tt>hash&lt;unsigned int&gt;</tt> is permitted-but-not-required to behave identically to <tt>hash&lt;unsigned long&gt;</tt>.
<p/>
This proposed resolution doesn't specify anything else about the primary template, allowing implementations to do 
whatever they want for non-enums: <tt>static_assert</tt> nicely, explode horribly at compiletime or runtime, etc.
<p/>
While we're in the neighborhood, this proposed resolution contains an editorial fix. The 23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>
synopsis says "base template", which doesn't appear anywhere else in the Standard, and could confuse users into 
thinking that they need to derive from it. The proper phrase is "primary template".
</p>

<p><i>[2013-04-18, Bristol]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf">N3485</a>.</p>

<ol>
<li><p>In 23.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>, header functional synopsis, edit as indicated:</p>

<blockquote><pre>
namespace std {
  [&hellip;]
  <i>// 20.8.12, hash function <del>base</del><ins>primary</ins> template:</i>
  template &lt;class T&gt; struct hash;
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>In 23.14.15 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>/1 edit as indicated:</p>

<blockquote><p>
-1- The unordered associative containers defined in 26.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> use specializations of the class template 
<tt>hash</tt> as the default <tt>hash</tt> function. For all object types <tt>Key</tt> for which there exists a 
specialization <tt>hash&lt;Key&gt;</tt><ins>, and for all enumeration types (10.2 <a href="https://timsong-cpp.github.io/cppwp/dcl.enum">[dcl.enum]</a>) Key</ins>, 
the instantiation <tt>hash&lt;Key&gt;</tt> shall: [&hellip;]
</p></blockquote>
</li>
</ol>





</body>
</html>
