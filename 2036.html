<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2036: istream &gt;&gt; char and eofbit</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3><a name="2036" href="lwg-closed.html#2036">2036.</a> <tt>istream &gt;&gt; char</tt> and <tt>eofbit</tt></h3>
<p><b>Section:</b> 29.7.4.2 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream">issues</a> in [istream].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The question is:  When a single character is extracted from an <tt>istream</tt> using <tt>operator&gt;&gt;</tt>, 
does <tt>eofbit</tt> get set if this is the last character extracted from the stream?  The current standard is at 
best ambiguous on the subject. 29.7.4.2 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a>/p3 describes all extraction operations with:</p>

<blockquote><p>
3 If <tt>rdbuf()-&gt;sbumpc()</tt> or <tt>rdbuf()-&gt;sgetc()</tt> returns <tt>traits::eof()</tt>, then the input 
function, except as explicitly noted otherwise, completes its actions and does <tt>setstate(eofbit)</tt>, which may 
throw <tt>ios_base::failure</tt> (29.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a>), before returning.
</p></blockquote>

<p>And  [istream::extractors]/p12 in describing <tt>operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp; in, charT&amp; c);</tt> 
offers no further clarification:
</p>

<blockquote><p>
12 <i>Effects</i>: Behaves like a formatted input member (as described in [istream.formatted.reqmts]) of <tt>in</tt>. 
After a <tt>sentry</tt> object is constructed a character is extracted from <tt>in</tt>, if one is available, and 
stored in <tt>c</tt>. Otherwise, the function calls <tt>in.setstate(failbit)</tt>.
</p></blockquote>

<p>I coded it one way in libc++, and g++ coded it another way.  Chris Jefferson noted that some boost code was 
sensitive to the difference and fails for libc++.  Therefore I believe that it is very important that we specify 
this extraction operator in enough detail that both vendors and clients know what behavior is required and expected.
</p>

<p>Here is a brief code example demonstrating the issue:</p>

<blockquote><pre>
#include &lt;sstream&gt;
#include &lt;cassert&gt;

int main()
{
  std::istringstream ss("1");
  char t;
  ss &gt;&gt; t;
  assert(!ss.eof());
};
</pre></blockquote>

<p>For every type capable of reading this istringstream but <tt>char</tt>, <tt>ss.eof()</tt> will be true after the 
extraction (<tt>bool</tt>, <tt>int</tt>, <tt>double</tt>, etc.).  So for consistency's sake we might want to have 
<tt>char</tt> behave the same way as other built-in types.</p>

<p>However Jean-Marc Bourguet offers this counter example code using an interactive stream.  He argues that 
setting <tt>eof</tt> inhibits reading the next line:</p>

<blockquote><pre>
#include &lt;iostream&gt;

int main()
{
 char c;
 std::cin &gt;&gt; std::noskipws;
 std::cout &lt;&lt; "First line: ";
 while (std::cin &gt;&gt; c) {
    if (c == '\n') {
       std::cout &lt;&lt; "Next line: ";
    }
 }
}
</pre></blockquote>

<p>As these two code examples demonstrate, whether or not <tt>eofbit</tt> gets set is an observable difference and it 
is impacting real-world code.  I feel it is critical that we clearly and unambiguously choose one behavior or the other.  
I am proposing wording for both behaviors and ask the LWG to choose one (and only one!).</p>

<p>Wording for setting <tt>eof</tt> bit:</p>

<p>Modify  [istream::extractors]/p12 as follows:</p>

<blockquote><p>
12 <i>Effects</i>: Behaves like a formatted input member (as described in [istream.formatted.reqmts]) of <tt>in</tt>. 
After a <tt>sentry</tt> object is constructed a character is extracted from <tt>in</tt>, if one is available, and 
stored in <tt>c</tt>. <del>Otherwise, the function calls <tt>in.setstate(failbit)</tt>.</del>  <ins>If a character is 
extracted and it is the last character in the pending sequence, the function calls <tt>in.setstate(eofbit)</tt>.  
If a character is not extracted the function calls <tt>in.setstate(failbit | eofbit)</tt>.</ins>
</p></blockquote>

<p>Wording for not setting <tt>eof</tt> bit:</p>

<blockquote><p>
12 <i>Effects</i>: Behaves like a formatted input member (as described in [istream.formatted.reqmts]) of <tt>in</tt>. 
After a <tt>sentry</tt> object is constructed a character is extracted from <tt>in</tt><del>, if one is available, 
and stored in <tt>c</tt>. Otherwise, the function calls <tt>in.setstate(failbit)</tt>.</del> <ins>with 
<tt>in.rdbuf()-&gt;sbumpc()</tt>.  If <tt>traits::eof()</tt> is returned, the function calls 
<tt>in.setstate(failbit | eofbit)</tt>.  Otherwise the return value is converted to type <tt>charT</tt> and stored
in <tt>c</tt>.</ins>
</p></blockquote>

<p><i>[2011-02-27: Jean-Marc Bourguet comments]</i></p>


<p>Just for completeness: it [the counter example] doesn't inhibit to read the next line, it inhibits the prompt 
to be put at the appropriate time.</p>

<p>More information to take into account when deciding:</p>

<ul>
<li><p>if I'm reading correctly the section to get boolean values when <tt>boolalpha</tt> is set, there we mandate 
that <tt>eof</tt> isn't set if trying to read past the end of the pending sequence wasn't needed to determine the result.
</p></li>

<li><p>
see also the behaviour of <tt>getline</tt> (which isn't a formatted input function but won't set <tt>eof</tt> 
if it occurs just after the delimiter)
</p></li>

<li><p>
if I'm reading the C standard correctly <tt>scanf("%c")</tt> wouldn't set <tt>feof</tt> either in that situation.
</p></li>
</ul>

<p><i>[2011-02-28: Martin Sebor comments]</i></p>


<p>[Responds to bullet 1 of Jean-Marc's list]</p>

<p>
Yes, this matches the stdcxx test suite for <tt>num_get</tt> and <tt>time_get</tt>
but not <tt>money_get</tt> when the currency symbol is last. I don't see
where in the locale.money.get.virtuals section we specify whether
<tt>eofbit</tt> is or isn't set and when.
<p/>
IMO, if we try to fix the <tt>char</tt> extractor to be consistent we
should also fix all the others extractors and manipulators that
aren't consistent (including <tt>std::get_money</tt> and <tt>std::get_time</tt>).
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Dietmar convinced Howard, that the standard does already say the right words</p>



<p><b>Rationale:</b></p><p>Reading the last character does not set eofbit and the standard says so already</p>

<p><b>Proposed resolution:</b></p>
<p></p>





</body>
</html>
