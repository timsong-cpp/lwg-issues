<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 634: allocator.address() doesn't work for types overloading operator&amp;</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="634" href="lwg-defects.html#634">634.</a> <tt>allocator.address()</tt> doesn't work for types overloading <tt>operator&amp;</tt></h3>
<p><b>Section:</b> 20.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a> <b>Status:</b> <a href="lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-02-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Duplicate of:</b> <a href="350">350</a></p>
<p><b>Discussion:</b></p>

<p>
20.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a> says:
</p>
<blockquote>
<pre>pointer address(reference <i>x</i>) const;</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>&amp;<i>x</i></tt>.
</p>
</blockquote>
</blockquote>

<p>
20.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a> defines <tt>CopyConstructible</tt> which currently not
only defines the semantics of copy construction, but also restricts what an overloaded
<tt>operator&amp;</tt> may do.  I believe proposals are in the works (such as concepts
and rvalue reference) to decouple these two requirements.  Indeed it is not evident
that we should disallow overloading <tt>operator&amp;</tt> to return something other
than the address of <tt>*this</tt>.
</p>

<p>
An example of when you want to overload <tt>operator&amp;</tt> to return something
other than the object's address is proxy references such as <tt>vector&lt;bool&gt;</tt>
(or its replacement, currently code-named <tt>bit_vector</tt>).  Taking the address of
such a proxy reference should logically yield a proxy pointer, which when dereferenced,
yields a copy of the original proxy reference again.
</p>

<p>
On the other hand, some code truly needs the address of an object, and not a proxy
(typically for determining the identity of an object compared to a reference object).
<a href="http://www.boost.org">boost</a> has long recognized this dilemma and solved it with 
<a href="http://www.boost.org/libs/utility/utility.htm#addressof"><tt>boost::addressof</tt></a>.
It appears to me that this would be useful functionality for the default allocator.  Adopting
this definition for <tt>allocator::address</tt> would free the standard of requiring
anything special from types which overload <tt>operator&amp;</tt>.  Issue <a href="580">580</a>
is expected to make use of <tt>allocator::address</tt> mandatory for containers.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a>:
</p>

<blockquote>
<pre>pointer address(reference <i>x</i>) const;</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <del><tt>&amp;<i>x</i></tt>.</del> <ins>The actual address of object referenced by <i>x</i>,
even in the presence of an overloaded <tt>operator&amp;</tt>.</ins>
</p>
</blockquote>

<pre>const_pointer address(address(const_reference <i>x</i>) const;</pre>
<blockquote>
<p>
-2- <i>Returns:</i> <del><tt>&amp;<i>x</i></tt>.</del> <ins>The actual address of object referenced by <i>x</i>,
even in the presence of an overloaded <tt>operator&amp;</tt>.</ins>
</p>
</blockquote>
</blockquote>

<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>


<p><i>[
Kona (2007): The LWG adopted the proposed resolution of N2387 for this issue which
was subsequently split out into a separate paper N2436 for the purposes of voting.
The resolution in N2436 addresses this issue.  The LWG voted to accelerate this
issue to Ready status to be voted into the WP at Kona.
]</i></p>







</body>
</html>
