<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 454: basic_filebuf::open should accept wchar_t names</title>
<meta property="og:title" content="Issue 454: basic_filebuf::open should accept wchar_t names">
<meta property="og:description" content="C++ library issue. Status: NAD">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/454.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="454"><a href="lwg-closed.html#454">454</a>. <code>basic_filebuf::open</code> should accept <code>wchar_t</code> names</h3>
<p><b>Section:</b> 31.10.3.4 <a href="https://timsong-cpp.github.io/cppwp/filebuf.members">[filebuf.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="105" title="fstream ctors argument types desired (Status: Dup)">105</a></p>
<p><b>Discussion:</b></p>
<pre>
    basic_filebuf *basic_filebuf::open(const char *, ios_base::open_mode);
</pre>

<p>should be supplemented with the overload:</p>

<pre>
    basic_filebuf *basic_filebuf::open(const wchar_t *, ios_base::open_mode);
</pre>

<p>
Depending on the operating system, one of these forms is fundamental and
the other requires an implementation-defined mapping to determine the
actual filename.
</p>

<p><i>[Sydney: Yes, we want to allow <code>wchar_t</code> filenames.  Bill will
  provide wording.]</i></p>


<p><i>[
In Toronto we noted that this is issue 5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1569.htm">N1569</a>.
]</i></p>

<p>
How does this interact with the newly-defined character types, and how
do we avoid interface explosion considering <code>std::string</code> overloads that
were added? Propose another solution that is different than the
suggestion proposed by PJP.
</p>
<p>
Suggestion is to make a member template function for <code>basic_string</code> (for
<code>char</code>, <code>wchar_t</code>, <code>u16char</code>, <code>u32char</code> instantiations), and then just keep a
<code>const char*</code> member.
</p>
<p>
Goal is to do implicit conversion between character string literals to
appropriate <code>basic_string</code> type. Not quite sure if this is possible.
</p>
<p>
Implementors are free to add specific overloads for non-char character
types.
</p>

<p><i>[
Martin adds pre-Sophia Antipolis:
]</i></p>


<blockquote><p>
Please see <a href="http://wiki.dinkumware.com/twiki/pub/Wg21sophiaAntipolis/LibraryWorkingGroup/issue-454.html">issue 454: problems and solutions</a>.
</p></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Beman is concerned that making these changes to <code>basic_filebuf</code> is not
usefully changed unless <code>fstream</code> is also changed; this also only handles
<code>wchar_t</code> and not other character types.
</p>
<p>
The TR2 filesystem library is a more complete solution, but is not available soon.
</p>
</blockquote>

<p><i>[
Martin adds:  please reference
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2683.html">N2683</a> for
problems and solutions.
]</i></p>




<p id="res-454"><b>Proposed resolution:</b></p>

<p>Change from:</p>
<blockquote>
<pre>
basic_filebuf&lt;charT,traits>* open(
    const char* s,
    ios_base::openmode mode );
</pre>

<p>
Effects: If is_open() != false, returns a null pointer.
Otherwise, initializes the filebuf as required. It then
opens a file, if possible, whose name is the NTBS s ("as if"
by calling std::fopen(s,modstr)).</p>
</blockquote>

<p>to:</p>

<blockquote>
<pre>
basic_filebuf&lt;charT,traits>* open(
    const char* s,
    ios_base::openmode mode );

basic_filebuf&lt;charT,traits>* open(
    const wchar_t* ws,
    ios_base::openmode mode );
</pre>

<p>
<i>Effects</i>: If <code>is_open() != false</code>, returns a null pointer.
Otherwise, initializes the <code>filebuf</code> as required. It then
opens a file, if possible, whose name is the NTBS <code>s</code> ("as if"
by calling <code>std::fopen(s,modstr)</code>).
For the second signature, the NTBS <code>s</code> is determined from the
WCBS <code>ws</code> in an implementation-defined manner.
</p>

<p>
(NOTE: For a system that "naturally" represents a filename
as a WCBS, the NTBS s in the first signature may instead
be mapped to a WCBS; if so, it follows the same mapping
rules as the first argument to open.)
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Slightly controversial, but by a 7-1 straw poll the LWG agreed to move
this to Ready.  The controversy was because the mapping between wide
names and files in a filesystem is implementation defined.  The
counterargument, which most but not all LWG members accepted, is that
the mapping between narrow files names and files is also
implemenation defined.</p>

<p><i>[Lillehammer: Moved back to "open" status, at Beman's urging.
(1) Why just basic_filebuf, instead of also basic_fstream (and
possibly other things too). (2) Why not also constructors that take
std::basic_string? (3) We might want to wait until we see Beman's
filesystem library; we might decide that it obviates this.]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
Move again to Ready.
</p>
<p>
There is a timing issue here. Since the filesystem library will not be
in C++0x, this should be brought forward. This solution would remain
valid in the context of the proposed filesystem.
</p>
<p>
This issue has been kicking around for a while, and the wchar_t addition
alone would help many users. Thus, we suggest putting this on the
reflector list with an invitation for someone to produce proposed
wording that covers basic_fstream. In the meantime, we suggest that the
proposed wording be adopted as-is.
</p>
<p>
If more of the Lillehammer questions come back, they should be
introduced as separate issues.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Some existing implementations provide overload already. Expected
filesystem "path" object overloads neatly, without surprises; implying
NAD.
</p></blockquote>







</body>
</html>
