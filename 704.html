<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 704: MoveAssignable requirement for container value type overly strict</title>
<meta property="og:title" content="Issue 704: MoveAssignable requirement for container value type overly strict">
<meta property="og:description" content="C++ library issue. Status: C++11">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/704.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="704"><a href="lwg-defects.html#704">704</a>. <code>MoveAssignable</code> requirement for container value type overly strict</h3>
<p><b>Section:</b> 23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2007-05-20 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The move-related changes inadvertently overwrote the intent of <a href="276" title="Assignable requirement for container value type overly strict (Status: CD1)">276</a>.
Issue <a href="276" title="Assignable requirement for container value type overly strict (Status: CD1)">276</a> removed the requirement of <code>CopyAssignable</code> from
most of the member functions of node-based containers.  But the move-related changes
unnecessarily introduced the <code>MoveAssignable</code> requirement for those members which used to
require <code>CopyAssignable</code>.
</p>

<p>
We also discussed (c++std-lib-18722) the possibility of dropping <code>MoveAssignable</code>
from some of the sequence requirements.  Additionally the <i>in-place</i> construction
work may further reduce requirements.  For purposes of an easy reference, here are the
minimum sequence requirements as I currently understand them.  Those items in requirements
table in the working draft which do not appear below have been purposefully omitted for
brevity as they do not have any requirements of this nature.  Some items which do not
have any requirements of this nature are included below just to confirm that they were
not omitted by mistake.
</p>

<table border="1">
<caption>Container Requirements</caption>
<tr><td><code>X u(a)</code></td><td><code>value_type</code> must be <code>CopyConstructible</code></td></tr>
<tr><td><code>X u(rv)</code></td><td><code>array</code> requires <code>value_type</code> to be <code>CopyConstructible</code></td></tr>
<tr><td><code>a = u</code></td><td>Sequences require <code>value_type</code> to be <code>CopyConstructible</code> and <code>CopyAssignable</code>.
                               Associative containers require <code>value_type</code> to be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a = rv</code></td><td><code>array</code> requires <code>value_type</code> to be <code>CopyAssignable</code>.
                                Sequences containers with <code>propagate_on_container_move_assignment == false</code> allocators require <code>value_type</code> to be <code>MoveConstructible</code> and <code>MoveAssignable</code>.
                                Associative containers with <code>propagate_on_container_move_assignment == false</code> allocators require <code>value_type</code> to be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>swap(a,u)</code></td><td><code>array</code> requires <code>value_type</code> to be <code>Swappable</code>.</td></tr>
</table>

<p>
</p>

<table border="1">
<caption>Sequence Requirements</caption>
<tr><td><code>X(n)</code></td><td><code>value_type</code> must be <code>DefaultConstructible</code></td></tr>
<tr><td><code>X(n, t)</code></td><td><code>value_type</code> must be <code>CopyConstructible</code></td></tr>
<tr><td><code>X(i, j)</code></td><td>Sequences require <code>value_type</code> to be constructible from <code>*i</code>.  Additionally if input_iterators
                                 are used, <code>vector</code> and <code>deque</code> require <code>MoveContructible</code> and <code>MoveAssignable</code>.</td></tr>
<tr><td><code>a.insert(p, t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.
                                        The sequences <code>vector</code> and <code>deque</code> also require the <code>value_type</code> to be <code>CopyAssignable</code>.</td></tr>
<tr><td><code>a.insert(p, rv)</code></td><td>The <code>value_type</code> must be <code>MoveConstructible</code>.
                                        The sequences <code>vector</code> and <code>deque</code> also require the <code>value_type</code> to be <code>MoveAssignable</code>.</td></tr>
<tr><td><code>a.insert(p, n, t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.
                                        The sequences <code>vector</code> and <code>deque</code> also require the <code>value_type</code> to be <code>CopyAssignable</code>.</td></tr>
<tr><td><code>a.insert(p, i, j)</code></td><td>If the iterators return an lvalue the <code>value_type</code> must be <code>CopyConstructible</code>.
                                        The sequences <code>vector</code> and <code>deque</code> also require the <code>value_type</code> to be <code>CopyAssignable</code> when the iterators return an lvalue.
                                        If the iterators return an rvalue the <code>value_type</code> must be <code>MoveConstructible</code>.
                                        The sequences <code>vector</code> and <code>deque</code> also require the <code>value_type</code> to be <code>MoveAssignable</code> when the iterators return an rvalue.</td></tr>
<tr><td><code>a.erase(p)</code></td><td>The sequences <code>vector</code> and <code>deque</code> require the <code>value_type</code> to be <code>MoveAssignable</code>.</td></tr>
<tr><td><code>a.erase(q1, q2)</code></td><td>The sequences <code>vector</code> and <code>deque</code> require the <code>value_type</code> to be <code>MoveAssignable</code>.</td></tr>
<tr><td><code>a.clear()</code></td><td></td></tr>
<tr><td><code>a.assign(i, j)</code></td><td>If the iterators return an lvalue the <code>value_type</code> must be <code>CopyConstructible</code> and <code>CopyAssignable</code>.
                                        If the iterators return an rvalue the <code>value_type</code> must be <code>MoveConstructible</code> and <code>MoveAssignable</code>.</td></tr>
<tr><td><code>a.assign(n, t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code> and <code>CopyAssignable</code>.</td></tr>
<tr><td><code>a.resize(n)</code></td><td>The <code>value_type</code> must be <code>DefaultConstructible</code>.
                                     The sequence <code>vector</code> also requires the <code>value_type</code> to be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a.resize(n, t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
</table>

<p>
</p>

<table border="1">
<caption>Optional Sequence Requirements</caption>
<tr><td><code>a.front()</code></td><td></td></tr>
<tr><td><code>a.back()</code></td><td></td></tr>
<tr><td><code>a.push_front(t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a.push_front(rv)</code></td><td>The <code>value_type</code> must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a.push_back(t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a.push_back(rv)</code></td><td>The <code>value_type</code> must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a.pop_front()</code></td><td></td></tr>
<tr><td><code>a.pop_back()</code></td><td></td></tr>
<tr><td><code>a[n]</code></td><td></td></tr>
<tr><td><code>a.at[n]</code></td><td></td></tr>
</table>

<p>
</p>

<table border="1">
<caption>Associative Container Requirements</caption>
<tr><td><code>X(i, j)</code></td><td>If the iterators return an lvalue the <code>value_type</code> must be <code>CopyConstructible</code>.
                                 If the iterators return an rvalue the <code>value_type</code> must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a_uniq.insert(t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a_uniq.insert(rv)</code></td><td>The <code>key_type</code> and the <code>mapped_type</code> (if it exists) must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a_eq.insert(t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a_eq.insert(rv)</code></td><td>The <code>key_type</code> and the <code>mapped_type</code> (if it exists) must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a.insert(p, t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a.insert(p, rv)</code></td><td>The <code>key_type</code> and the <code>mapped_type</code> (if it exists) must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a.insert(i, j)</code></td><td>If the iterators return an lvalue the <code>value_type</code> must be <code>CopyConstructible</code>.
                                        If the iterators return an rvalue the <code>key_type</code> and the <code>mapped_type</code> (if it exists) must be <code>MoveConstructible</code>..</td></tr>
</table>

<p>
</p>

<table border="1">
<caption>Unordered Associative Container Requirements</caption>
<tr><td><code>X(i, j, n, hf, eq)</code></td><td>If the iterators return an lvalue the <code>value_type</code> must be <code>CopyConstructible</code>.
                                 If the iterators return an rvalue the <code>value_type</code> must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a_uniq.insert(t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a_uniq.insert(rv)</code></td><td>The <code>key_type</code> and the <code>mapped_type</code> (if it exists) must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a_eq.insert(t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a_eq.insert(rv)</code></td><td>The <code>key_type</code> and the <code>mapped_type</code> (if it exists) must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a.insert(p, t)</code></td><td>The <code>value_type</code> must be <code>CopyConstructible</code>.</td></tr>
<tr><td><code>a.insert(p, rv)</code></td><td>The <code>key_type</code> and the <code>mapped_type</code> (if it exists) must be <code>MoveConstructible</code>.</td></tr>
<tr><td><code>a.insert(i, j)</code></td><td>If the iterators return an lvalue the <code>value_type</code> must be <code>CopyConstructible</code>.
                                        If the iterators return an rvalue the <code>key_type</code> and the <code>mapped_type</code> (if it exists) must be <code>MoveConstructible</code>..</td></tr>
</table>

<p>
</p>

<table border="1">
<caption>Miscellaneous Requirements</caption>
<tr><td><code>map[lvalue-key]</code></td><td>The <code>key_type</code> must be <code>CopyConstructible</code>.
                                         The <code>mapped_type</code> must be <code>DefaultConstructible</code> and <code>MoveConstructible</code>.</td></tr>
<tr><td><code>map[rvalue-key]</code></td><td>The <code>key_type</code> must be <code>MoveConstructible</code>.
                                         The <code>mapped_type</code> must be <code>DefaultConstructible</code> and <code>MoveConstructible</code>.</td></tr>
</table>

<p><i>[
Kona (2007): Howard and Alan to update requirements table in issue with emplace signatures.
]</i></p>


<p><i>[
Bellevue: This should be handled as part of the concepts work.
]</i></p>


<p><i>[
2009-07-20 Reopened by Howard:
]</i></p>


<blockquote>
<p>
This is one of the issues that was "solved by concepts" and is now no longer solved.
</p>

<p>
In a nutshell, concepts adopted the "minimum requirements" philosophy outlined
in the discussion of this issue, and enforced it.  My strong suggestion is that
we translate the concepts specification into documentation for the containers.
</p>

<p>
What this means for vendors is that they will have to implement container members
being careful to only use those characteristics of a type that the concepts specification
formally allowed.  Note that I <em>am not</em> talking about <code>enable_if</code>'ing
everything.  I am simply suggesting that (for example) we tell the vendor he can't call <code>T's</code>
copy constructor or move constructor within the <code>emplace</code> member function, etc.
</p>

<p>
What this means for customers is that they will be able to use types within C++03
containers which are sometimes not CopyConstructible, and sometimes not even
MoveConstructible, etc.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave open. Howard to provide wording.
</p></blockquote>

<p><i>[
2010-02-06 Howard provides wording.
]</i></p>


<p><i>[
2010-02-08 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-10 Howard opened.  I neglected to reduce the requirements on value_type
for the insert function of the ordered and unordered associative containers when
the argument is an rvalue.  Fixed it.
]</i></p>


<p><i>[
2010-02-11 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-03-08 Nico opens:
]</i></p>


<blockquote>
<p>
I took the task to see whether <a href="868" title="Default construction and value-initialization (Status: C++11)">868</a> is covered by 704
already.
However, by doing that I have the impression that
704 is a big mistake.
</p>

<p>
Take e.g. the second change of <a href="868" title="Default construction and value-initialization (Status: C++11)">868</a>:
</p>

<blockquote>
<p>
Change 23.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/deque.cons">[deque.cons]</a> para 5:
</p>
<blockquote><p>
<i>Effects:</i> Constructs a <code>deque</code> with <code>n</code> default constructed
elements.
</p></blockquote>
<p>
where "default constructed" should be replaced by "value-initialized".
This is the constructor out of a number of elements:
</p>
<blockquote><pre>
ContType c(num)
</pre></blockquote>

<p>
704 says:
</p>

<blockquote>
<p>
Remove the entire section 23.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/deque.cons">[deque.cons]</a>.
</p>
<blockquote><p>
[ This section is already specified by the requirements tables. ]
</p></blockquote>
</blockquote>

<p>
BUT, there is no requirement table that lists this constructor at all,
which means that we would lose the entire specification of this function
!!!
</p>

<p>
In fact, I found with further investigation, if we follow
704 to remove 23.3.2.1 we
</p>
<ul>
<li>
have no semantics for
  <code>ContType c(num)</code>
</li>
<li>
have no complexity and no allocator specification for
  <code>ContType c(num,val)</code>
</li>
<li>
have no semantics for
  <code>ContType c(num,val,alloc)</code>
</li>
<li>
- have no complexity and no allocator specification for
  <code>ContType c(beg,end)</code>
</li>
<li>
- have no semantics for
  <code>ContType c(beg,end,alloc)</code>
</li>
<li>
- have different wording (which might or might not give
 the same guarantees) for the <code>assign</code> functions
</li>
</ul>

<p>
because all these guarantees are given in the removed
section but nowhere else (as far as I saw).
</p>
<p>
Looks to me that 704 need a significant review before we
take that change, because chances are high that there
are similar flaws in other proposed changes there
(provided I am not missing anything).
</p>
</blockquote>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
Removed the parts from the proposed wording that removed existing sections,
and set to Ready for Pittsburgh.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
post San Francisco:
]</i></p>


<blockquote><p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2776.pdf">N2776</a>.
</p></blockquote>

<p>
This rationale is obsolete. 
</p>



<p id="res-704"><b>Proposed resolution:</b></p>


 
<p>
Change 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/4:
</p>

<blockquote><p>
4 In Tables 91 and 92, <code>X</code> denotes a container class containing objects
of type <code>T</code>, <code>a</code> and <code>b</code> denote values of type <code>X</code>,
<code>u</code> denotes an identifier, <code>r</code> denotes <del>an lvalue or a const
rvalue</del> <ins>a non-const value</ins> of type <code>X</code>, and <code>rv</code>
denotes a non-const rvalue of type <code>X</code>.
</p></blockquote>

<p>
Change the following rows in Table 91 &mdash; Container requirements
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 91 &mdash; Container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><code>X::value_type</code></td>
<td><code>T</code></td>
<td><ins><i>Requires:</i> <code>T</code> is <code>Destructible</code>.</ins></td>
<td>compile time</td>
</tr>

</table>

</blockquote>

<p>
Change 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/10:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.2.3, and 23.3.6.4) all
container types defined in this Clause meet the following additional
requirements:
</p>

<ul>
<li>
<p>&hellip;</p>
</li>

<li><p>
no <code>erase()</code>, <ins><code>clear()</code>,</ins> <code>pop_back()</code> or
<code>pop_front()</code> function throws an exception.
</p></li>

<li>
<p>&hellip;</p>
</li>
</ul>

</blockquote>

<p>
Insert a new paragraph prior to 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/14:
</p>

<blockquote>
<p><ins>
The descriptions of the requirements of the type <code>T</code> in this section
use the terms <code>CopyConstructible</code>, <code>MoveConstructible</code>, <i>constructible
from <code>*i</code></i>, and <i>constructible from <code>args</code></i>.  These terms
are equivalent to the following expression using the appropriate arguments:
</ins></p>

<blockquote><pre><ins>
allocator_traits&lt;allocator_type&gt;::construct(x.get_allocator(), q, args...);
</ins></pre></blockquote>

<p><ins>
where <code>x</code> is a non-const lvalue of some container type <code>X</code> and
<code>q</code> has type <code>X::value_type*</code>.
</ins></p>

<p><ins>
[<i>Example:</i> The container is going to move construct a <code>T</code>, so will
call:
</ins></p>

<blockquote><pre><ins>
allocator_traits&lt;allocator_type&gt;::construct(get_allocator(), q, std::move(t));
</ins></pre></blockquote>

<p><ins>
The default implementation of construct will call:
</ins></p>

<blockquote><pre><ins>
::new (q) T(std::forward&lt;T&gt;(t)); // where forward is the same as move here, cast to rvalue
</ins></pre></blockquote>

<p><ins>
But the allocator author may override the above definition of <code>construct</code>
and do the construction of <code>T</code> by some other means. &mdash; <i>end
example</i>]
</ins></p>

<p>
14 ...
</p>
</blockquote>

<p>
Add to 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/14:
</p>

<blockquote><p>
14 In Table 93, <code>X</code> denotes an allocator-aware container class with a
<code>value_type</code> of <code>T</code> using allocator of type <code>A</code>, <code>u</code>
denotes a variable, <ins><code>a</code> and <code>b</code> denote non-const lvalues of
type <code>X</code>,</ins> <code>t</code> denotes an lvalue or a const rvalue of type
<code>X</code>, <code>rv</code> denotes a non-const rvalue of type <code>X</code>,
<code>m</code> is a value of type <code>A</code>, and <code>Q</code> is an allocator type.
</p></blockquote>

<p>
Change or add the following rows in Table 93 &mdash; Allocator-aware container
requirements in 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 93 &mdash; Allocator-aware container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><code>X(t, m)<br/>X u(t, m);</code></td>
<td></td>
<td><ins><i>Requires:</i> <code>T</code> is <code>CopyConstructible</code>.</ins><br/>
post: <code>u == t</code>,<br/>
<code>get_allocator() == m</code></td>
<td>linear</td>
</tr>

<tr>
<td><code>X(rv, m)<br/>X u(rv, m);</code></td>
<td></td>
<td><ins><i>Requires:</i> <code>T</code> is <code>MoveConstructible</code>.</ins><br/>
post: <code>u</code> shall have the same elements, or copies of the elements, that
<code>rv</code> had before this construction,<br/>
<code>get_allocator() == m</code></td>
<td>constant if <code>m == rv.get_allocator()</code>, otherwise linear</td>
</tr>

<tr>
<td><ins><code>a = t</code></ins></td>
<td><ins><code>X&amp;</code></ins></td>
<td><ins><i>Requires:</i> <code>T</code> is <code>CopyConstructible</code> and
<code>CopyAssignable</code><br/>
post: <code>a == t</code>.</ins></td>
<td><ins>linear</ins></td>
</tr>

<tr>
<td><ins><code>a = rv</code></ins></td>
<td><ins><code>X&amp;</code></ins></td>
<td><ins><i>Requires:</i> If <code>allocator_traits&lt; allocator_type &gt;
::propagate_on_container_move_assignment ::value</code> is <code>false</code>,
<code>T</code> is <code>MoveConstructible</code> and <code>MoveAssignable</code>.<br/>
All existing elements of <code>a</code> are either move assigned
<ins>to</ins> or destroyed.<br/>
<code>a</code> shall be equal to the value that <code>rv</code> had before this
assignment</ins></td>
<td><ins>linear</ins></td>
</tr>

<tr>
<td><ins><code>a.swap(b);</code></ins></td>
<td><ins><code>void</code></ins></td>
<td><ins>exchanges the contents of <code>a</code> and <code>b</code></ins></td>
<td><ins>constant</ins></td>
</tr>

</table>

</blockquote>

<p>
Change the following rows in Table 94 &mdash; Sequence container requirements
(in addition to container) in 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 94 &mdash; Sequence container requirements (in addition to
container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
</tr>

<tr>
<td><code>X(i, j)<br/>X a(i, j)</code></td>
<td></td>
<td><i>Requires:</i> <del>If the iterator's dereference operation returns an
lvalue or a const rvalue, <code>T</code> shall be <code>CopyConstructible</code>.</del>
<ins><code>T</code> shall be constructible from <code>*i</code>.</ins><br/>
<ins>If the iterator does not meet the forward iterator requirements (24.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a>), then <code>vector</code> also requires <code>T</code> to
be <code>MoveConstructible</code>.</ins><br/>
Each iterator in the range <code>[i,j)</code> shall be dereferenced exactly
once.<br/>
post: <code>size() ==</code> distance between <code>i</code> and <code>j</code><br/>
Constructs a sequence container equal to the range <code>[i, j)</code></td>
</tr>

<tr>
<td><code>a = il;</code></td>
<td><code>X&amp;</code></td>
<td><ins><i>Requires:</i> <code>T</code> is <code>CopyConstructible</code> and
<code>CopyAssignable</code>.</ins><br/>
<del><code>a = X(il);</code></del><br/>
<ins>Assigns the range <code>[il.begin(), il.end())</code> into <code>a</code>.  All
existing elements of <code>a</code> are either assigned or destroyed.</ins><br/>
<del>r</del><ins>R</ins>eturn<ins>s</ins> <code>*this;</code></td>
</tr>

<tr>
<td><code>a.emplace(p, args);</code></td>
<td><code>iterator</code></td>
<td><i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T,
Args&gt;</code>.</del> <ins><code>T</code> is constructible from <code>args</code>. 
<code>vector</code> and <code>deque</code> also require <code>T</code> to be
<code>MoveConstructible</code> and <code>MoveAssignable</code>.</ins> Inserts an object
of type <code>T</code> constructed with
<code>std::forward&lt;Args&gt;(args)...</code> <ins>before <code>p</code></ins>.</td>
</tr>

<tr>
<td><code>a.insert(p, t);</code></td>
<td><code>iterator</code></td>
<td><i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T, Args&gt;</code> and
<code>T</code> shall be <code>CopyAssignable</code>.</del> <ins><code>T</code> shall be
<code>CopyConstructible</code>. <code>vector</code> and <code>deque</code> also require
<code>T</code> to be <code>CopyAssignable</code>.</ins> Inserts a copy <code>t</code> before
<code>p</code>.</td>
</tr>

<tr>
<td><code>a.insert(p, rv);</code></td>
<td><code>iterator</code></td>
<td><i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T,
T&amp;&amp;&gt;</code> and <code>T</code> shall be <code>MoveAssignable</code>.</del>
<ins><code>T</code> shall be <code>MoveConstructible</code>. <code>vector</code> and
<code>deque</code> also require <code>T</code> to be <code>MoveAssignable</code>.</ins>
Inserts a copy <code>rv</code> before <code>p</code>.</td>
</tr>

<tr>
<td><code>a.insert(p, i, j)</code></td>
<td><code>iterator</code></td>
<td><i>Requires:</i> <del>If the iterator's dereference operation returns an
lvalue or a const rvalue, <code>T</code> shall be <code>CopyConstructible</code>.</del>
<ins><code>T</code> shall be constructible from <code>*i</code>.</ins><br/> <ins>If the
iterator does not meet the forward iterator requirements (24.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a>), then <code>vector</code> also requires <code>T</code> to
be <code>MoveConstructible</code> and  <code>MoveAssignable</code>.</ins><br/> Each
iterator in the range <code>[i,j)</code> shall be dereferenced exactly once.<br/>
pre: <code>i</code> and <code>j</code> are not iterators into <code>a</code>.<br/> Inserts
copies of elements in <code>[i, j)</code> before <code>p</code></td>
</tr>

<tr>
<td><code>a.erase(q);</code></td>
<td><code>iterator</code></td>
<td><i>Requires:</i> <del><code>T</code> and <code>T</code> shall be
<code>MoveAssignable</code>.</del> <ins><code>vector</code> and <code>deque</code> require
<code>T</code> to be <code>MoveAssignable</code>.</ins> Erases the element pointed to by
<code>q</code>.</td>
</tr>

<tr>
<td><code>a.erase(q1, q2);</code></td>
<td><code>iterator</code></td>
<td><i>Requires:</i> <del><code>T</code> and <code>T</code> shall be
<code>MoveAssignable</code>.</del> <ins><code>vector</code> and <code>deque</code> require
<code>T</code> to be <code>MoveAssignable</code>.</ins> Erases the elements in the range
<code>[q1, q2)</code>.</td>
</tr>

<tr>
<td><code>a.clear();</code></td>
<td><code>void</code></td>
<td><del><code>erase(begin(), end())</code></del><br/>
<ins>Destroys all elements in <code>a</code>. <ins>Invalidates all references,
pointers, and iterators referring to the elements of <code>a</code> and may
invalidate the past-the-end iterator.</ins><br/></ins>
post: <code><del>size() == 0</del> <ins>a.empty() == true</ins></code></td>
</tr>

<tr>
<td><code>a.assign(i, j)</code></td>
<td><code>void</code></td>
<td><i>Requires:</i> <del>If the iterator's dereference operation returns an
lvalue or a const rvalue, <code>T</code> shall be <code>CopyConstructible</code> and
<code>CopyAssignable</code>.</del>
<ins><code>T</code> shall be constructible and assignable from <code>*i</code>.  If the
iterator does not meet the forward iterator requirements (24.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a>), then <code>vector</code> also requires <code>T</code> to
be <code>MoveConstructible</code>.</ins><br/>
Each iterator in the range <code>[i,j)</code> shall be dereferenced exactly
once.<br/>
pre: <code>i</code>, <code>j</code> are not iterators into <code>a</code>.<br/>
Replaces elements in <code>a</code> with a copy of <code>[i, j)</code>.</td>
</tr>

</table>

</blockquote>

<p>
Change the following rows in Table 95 &mdash; Optional sequence container operations
in 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 95 &mdash; Optional sequence container operations</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Container</th>
</tr>

<tr>
<td><code>a.emplace_front(args)</code></td>
<td><code>void</code></td>
<td><del><code>a.emplace(a.begin(), std::forward&lt;Args&gt;(args)...)</code></del><br/>
<ins>Prepends an object of type <code>T</code> constructed with
<code>std::forward&lt;Args&gt;(args)...</code>.</ins><br/>
<i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T, Args&gt;</code></del>
<ins><code>T</code> shall be constructible from <code>args</code>.</ins></td>
<td><code>list</code>, <code>deque</code>, <code>forward_list</code></td>
</tr>

<tr>
<td><code>a.emplace_back(args)</code></td>
<td><code>void</code></td>
<td><del><code>a.emplace(a.end(), std::forward&lt;Args&gt;(args)...)</code></del><br/>
<ins>Appends an object of type <code>T</code> constructed with
<code>std::forward&lt;Args&gt;(args)...</code>.</ins><br/>
<i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T, Args&gt;</code></del>
<ins><code>T</code> shall be constructible from <code>args</code>. <code>vector</code> also
requires <code>T</code> to be <code>MoveConstructible</code>.</ins></td>
<td><code>list</code>, <code>deque</code>, <code>vector</code></td>
</tr>

<tr>
<td><code>a.push_front(t)</code></td>
<td><code>void</code></td>
<td><del><code>a.insert(a.begin(), t)</code></del><br/>
<ins>Prepends a copy of <code>t</code>.</ins><br/>
<i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T, T&gt;</code> and
<code>T</code> shall be <code>CopyAssignable</code>.</del>
<ins><code>T</code> shall be <code>CopyConstructible</code>.</ins></td>
<td><code>list</code>, <code>deque</code>, <code>forward_list</code></td>
</tr>

<tr>
<td><code>a.push_front(rv)</code></td>
<td><code>void</code></td>
<td><del><code>a.insert(a.begin(), t)</code></del><br/>
<ins>Prepends a copy of <code>rv</code>.</ins><br/>
<i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T, T&amp;&amp;&gt;</code> and
<code>T</code> shall be <code>MoveAssignable</code>.</del>
<ins><code>T</code> shall be <code>MoveConstructible</code>.</ins></td>
<td><code>list</code>, <code>deque</code>, <code>forward_list</code></td>
</tr>

<tr>
<td><code>a.push_back(t)</code></td>
<td><code>void</code></td>
<td><del><code>a.insert(a.end(), t)</code></del><br/>
<ins>Appends a copy of <code>t</code>.</ins><br/>
<i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T, T&gt;</code> and
<code>T</code> shall be <code>CopyAssignable</code>.</del>
<ins><code>T</code> shall be <code>CopyConstructible</code>.</ins></td>
<td><code>vector</code>, <code>list</code>, <code>deque</code>, <code>basic_string</code></td>
</tr>

<tr>
<td><code>a.push_back(rv)</code></td>
<td><code>void</code></td>
<td><del><code>a.insert(a.end(), t)</code></del><br/>
<ins>Appends a copy of <code>rv</code>.</ins><br/>
<i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, T, T&amp;&amp;&gt;</code> and
<code>T</code> shall be <code>MoveAssignable</code>.</del>
<ins><code>T</code> shall be <code>MoveConstructible</code>.</ins></td>
<td><code>vector</code>, <code>list</code>, <code>deque</code>, <code>basic_string</code></td>
</tr>

<tr>
<td><code>a.pop_front()</code></td>
<td><code>void</code></td>
<td><del><code>a.erase(a.begin())</code></del><br/>
<ins>Destroys the first element.</ins><br/>
<ins><i>Requires:</i> <code>a.empty()</code> shall be <code>false</code>.</ins></td>
<td><code>list</code>, <code>deque</code>, <code>forward_list</code></td>
</tr>

<tr>
<td><code>a.pop_back()</code></td>
<td><code>void</code></td>
<td><del><code>{ iterator tmp = a.end();<br/>--tmp;<br/>a.erase(tmp); }</code></del><br/>
<ins>Destroys the last element.</ins><br/>
<ins><i>Requires:</i> <code>a.empty()</code> shall be <code>false</code>.</ins></td>
<td><code>vector</code>, <code>list</code>, <code>deque</code>, <code>basic_string</code></td>
</tr>

</table>

</blockquote>

<p>
Insert a new paragraph prior to 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>/7, and
edit paragraph 7:
</p>

<blockquote>
<p><ins>
The associative containers meet all of the requirements of Allocator-aware
containers (23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>), except for the
containers <code>map</code> and <code>multimap</code>, the requirements placed on
<code>value_type</code> in Table 93 apply instead directly to <code>key_type</code> and
<code>mapped_type</code>. [<i>Note:</i> For example <code>key_type</code> and
<code>mapped_type</code> are sometimes required to be <code>CopyAssignable</code> even
though the <code>value_type</code> (<code>pair&lt;const key_type,
mapped_type&gt;</code>) is not <code>CopyAssignable</code>. &mdash; <i>end note</i>]
</ins></p>

<p>
7 In Table 96, <code>X</code> denotes an associative container class, a denotes a
value of <code>X</code>, <code>a_uniq</code> denotes a value of <code>X</code> when
<code>X</code> supports unique keys, <code>a_eq</code> denotes a value of <code>X</code>
when <code>X</code> supports multiple keys, <code>u</code> denotes an identifier,
<del><code>r</code> denotes an lvalue or a const rvalue of type <code>X</code>,
<code>rv</code> denotes a non-const rvalue of type <code>X</code>,</del> <code>i</code> and
<code>j</code> satisfy input iterator requirements and refer to elements implicitly
convertible to <code>value_type</code>, <code>[i,j)</code> denotes a valid range,
<code>p</code> denotes a valid const iterator to <code>a</code>, <code>q</code> denotes a
valid dereferenceable const iterator to <code>a</code>, <code>[q1, q2)</code> denotes a
valid range of const iterators in <code>a</code>, <code>il</code> designates an object
of type <code>initializer_list&lt;value_type&gt;</code>, <code>t</code> denotes a value
of <code>X::value_type</code>, <code>k</code> denotes a value of <code>X::key_type</code>
and <code>c</code> denotes a value of type <code>X::key_compare</code>. <code>A</code>
denotes the storage allocator used by <code>X</code>, if any, or
<code>std::allocator&lt;X::value_type&gt;</code> otherwise, and <code>m</code> denotes
an allocator of a type convertible to <code>A</code>. </p>
</blockquote>

<p>
Change or add the following rows in Table 96 &mdash; Associative container
requirements (in addition to container) in 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 96 &mdash; Associative container requirements (in addition to
container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><code>X::key_type</code></td>
<td><code>Key</code></td>
<td><ins><i>Requires:</i></ins> <code>Key</code> is <del><code>CopyConstructible</code> and
<code>CopyAssignable</code></del> <ins><code>Destructible</code></ins></td>
<td>compile time</td>
</tr>

<tr>
<td><ins><code>X::mapped_type</code> (<code>map</code> and <code>multimap</code> only)</ins></td>
<td><ins><code>T</code></ins></td>
<td><ins><i>Requires:</i> <code>T</code> is <code>Destructible</code></ins></td>
<td><ins>compile time</ins></td>
</tr>

<tr>
<td><code>X(c)<br/>X a(c);</code></td>
<td></td>
<td><i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, key_compare,
key_compare&gt;</code></del>.<br/>
<ins><code>key_compare</code> is <code>CopyConstructible</code>.</ins><br/>
Constructs an empty container.<br/>
Uses a copy of <code>c</code> as a comparison object.</td>
<td>constant</td>
</tr>

<tr>
<td><code>X()<br/>X a;</code></td>
<td></td>
<td><i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, key_compare,
key_compare&gt;</code></del>.<br/>
<ins><code>key_compare</code> is <code>DefaultConstructible</code>.</ins><br/>
Constructs an empty container.<br/>
Uses <code>Compare()</code> as a comparison object.</td>
<td>constant</td>
</tr>

<tr>
<td><code>X(i, j, c)<br/>X a(i, j, c);</code></td>
<td></td>
<td><i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, key_compare,
key_compare&gt;</code></del>.<br/>
<ins><code>key_compare</code> is <code>CopyConstructible</code>. <code>value_type</code>
shall be constructible from <code>*i</code>.</ins><br/>
Constructs an empty container ans inserts elements from the range <code>[i,
j)</code> into it; uses <code>c</code> as a comparison object.</td>
<td><code>N</code> log <code>N</code> in general (<code>N</code> is the distance from
<code>i</code> to <code>j</code>); linear if <code>[i, j)</code> is sorted with
<code>value_comp()</code></td>
</tr>

<tr>
<td><code>X(i, j)<br/>X a(i, j);</code></td>
<td></td>
<td><i>Requires:</i> <del><code>ConstructibleAsElement&lt;A, key_compare,
key_compare&gt;</code></del>.<br/> <ins><code>value_type</code> shall be constructible
from <code>*i</code>. <code>key_compare</code> is
<code>DefaultConstructible</code>.</ins><br/> Same as above, but uses
<code>Compare()</code> as a comparison object.</td>
<td>same as above</td>
</tr>

<tr>
<td><code>a = il</code></td>
<td><code>X&amp;</code></td>
<td><del><code>a = X(il);<br/>
return *this;</code></del><br/>
<ins><i>Requires:</i> <code>T</code> is <code>CopyConstructible</code> and
<code>CopyAssignable</code>.</ins><br/>
<ins>Assigns the range <code>[il.begin(), il.end())</code> into <code>a</code>.  All
existing elements of <code>a</code> are either assigned or destroyed.</ins></td>
<td><del>Same as <code><code>a = X(il)</code></code>.</del>
<ins><code>N</code> log <code>N</code> in general (<code>N</code> is 
<code>il.size()</code> added to the existing size of <code>a</code>); linear if
<code>[il.begin(), il.end())</code> is sorted with <code>value_comp()</code></ins></td>
</tr>

<tr>
<td><code>a_uniq.emplace(args)</code></td>
<td><code>pair&lt;iterator, bool&gt;</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be constructible from
<code>args</code></ins><br/>
inserts a <code>T</code> object <code>t</code> constructed with
<code>std::forward&lt;Args&gt;(args)...</code> if and only if there is no element in
the container with key equivalent to the key of <code>t</code>. The <code>bool</code>
component of the returned pair is true if and only if the insertion takes place,
and the iterator component of the pair points to the element with key equivalent
to the key of <code>t</code>.</td>
<td>logarithmic</td>
</tr>

<tr>
<td><code>a_eq.emplace(args)</code></td>
<td><code>iterator</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be constructible from
<code>args</code></ins><br/>
inserts a <code>T</code> object <code>t</code> constructed with
<code>std::forward&lt;Args&gt;(args)...</code> and returns the iterator pointing to
the newly inserted element.</td>
<td>logarithmic</td>
</tr>

<tr>
<td><code>a_uniq.insert(t)</code></td>
<td><code>pair&lt;iterator, bool&gt;</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be <code>MoveConstructible</code> if
<code>t</code> is a non-const rvalue expression, else <code>T</code> shall be
<code>CopyConstructible</code>.</ins><br/>
inserts <code>t</code> if and only if there is no element in the container with key
equivalent to the key of <code>t</code>. The <code>bool</code> component of the returned
pair is true if and only if the insertion takes place, and the iterator
component of the pair points to the element with key equivalent to the key of
<code>t</code>.</td>
<td>logarithmic</td>
</tr>

<tr>
<td><code>a_eq.insert(t)</code></td>
<td><code>iterator</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be <code>MoveConstructible</code> if
<code>t</code> is a non-const rvalue expression, else <code>T</code> shall be
<code>CopyConstructible</code>.</ins><br/>
inserts <code>t</code> and returns the iterator pointing to the newly inserted
element. If a range containing elements equivalent to <code>t</code> exists in
<code>a_eq</code>, <code>t</code> is inserted at the end of that range.</td>
<td>logarithmic</td>
</tr>

<tr>
<td><code>a.insert(p, t)</code></td>
<td><code>iterator</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be <code>MoveConstructible</code> if
<code>t</code> is a non-const rvalue expression, else <code>T</code> shall be
<code>CopyConstructible</code>.</ins><br/>
inserts <code>t</code> if and only if there is no element with key equivalent to the
key of <code>t</code> in containers with unique keys; always inserts <code>t</code> in
containers with equivalent keys; always returns the iterator pointing to the
element with key equivalent to the key of <code>t</code>. <code>t</code> is inserted as
close as possible to the position just prior to <code>p</code>.</td>
<td>logarithmic in general, but amortized constant if <code>t</code> is inserted
right before <code>p</code>.</td>
</tr>

<tr>
<td><code>a.insert(i, j)</code></td>
<td><code>void</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be
constructible from <code>*i</code>.</ins><br/>
pre: <code>i</code>, <code>j</code> are not iterators into <code>a</code>. inserts each
element from the range <code>[i,j)</code> if and only if there is no element with
key equivalent to the key of that element in containers with unique keys; always
inserts that element in containers with equivalent keys.</td>
<td>N log(size() + N ) (N is the distance from i to j)</td>
</tr>

</table>

</blockquote>

<p>
Insert a new paragraph prior to 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>/9:
</p>

<blockquote>
<p><ins>
The unordered associative containers meet all of the requirements of
Allocator-aware containers (23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>),
except for the containers <code>unordered_map</code> and <code>unordered_multimap</code>,
the requirements placed on <code>value_type</code> in Table 93 apply instead
directly to <code>key_type</code> and <code>mapped_type</code>. [<i>Note:</i> For
example <code>key_type</code> and <code>mapped_type</code> are sometimes required to be
<code>CopyAssignable</code> even though the <code>value_type</code> (<code>pair&lt;const
key_type, mapped_type&gt;</code>) is not <code>CopyAssignable</code>. &mdash; <i>end
note</i>]
</ins></p>

<p>
9 ...
</p>
</blockquote>

<p>
Change or add the following rows in Table 98 &mdash; Unordered associative
container requirements (in addition to container) in 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 98 &mdash; Unordered associative
container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><code>X::key_type</code></td>
<td><code>Key</code></td>
<td><ins><i>Requires:</i></ins> <code>Key</code> shall be <del><code>CopyAssignable</code> and
<code>CopyConstructible</code></del> <ins><code>Destructible</code></ins></td>
<td>compile time</td>
</tr>

<tr>
<td><ins><code>X::mapped_type</code> (<code>unordered_map</code> and
<code>unordered_multimap</code> only)</ins></td>
<td><ins><code>T</code></ins></td>
<td><ins><i>Requires:</i><code>T</code> is <code>Destructible</code></ins></td>
<td><ins>compile time</ins></td>
</tr>

<tr>
<td><code>X(n, hf, eq)<br/>X a(n, hf, eq)</code></td>
<td><code>X</code></td>
<td><ins><i>Requires:</i> <code>hasher</code>  and <code>key_equal</code> are
<code>CopyConstructible</code>.</ins> Constructs an empty container with at least
<code>n</code> buckets, using <code>hf</code> as the hash function and <code>eq</code> as
the key equality predicate. </td>
<td><code>O(N)</code></td>
</tr>

<tr>
<td><code>X(n, hf)<br/>X a(n, hf)</code></td>
<td><code>X</code></td>
<td><ins><i>Requires:</i> <code>hasher</code> is <code>CopyConstructible</code> and 
<code>key_equal</code> is <code>DefaultConstructible</code>.</ins> Constructs an empty
container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function and <code>key_equal()</code> as the key equality predicate.</td>
<td><code>O(N)</code></td>
</tr>

<tr>
<td><code>X(n)<br/>X a(n)</code></td>
<td><code>X</code></td>
<td><ins><i>Requires:</i> <code>hasher</code>  and <code>key_equal</code> are
<code>DefaultConstructible</code>.</ins> Constructs an empty container with at least
<code>n</code> buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as
the key equality predicate. </td>
<td><code>O(N)</code></td>
</tr>

<tr>
<td><code>X()<br/>X a</code></td>
<td><code>X</code></td>
<td><ins><i>Requires:</i> <code>hasher</code>  and <code>key_equal</code> are
<code>DefaultConstructible</code>.</ins> Constructs an empty container an unspecified number of buckets,
using <code>hasher()</code> as the hash function and <code>key_equal()</code> as
the key equality predicate. </td>
<td>constant</td>
</tr>

<tr>
<td><code>X(i, j, n, hf, eq)<br/>X a(i, j, n, hf, eq)</code></td>
<td><code>X</code></td>
<td><ins><i>Requires:</i> <code>value_type</code> is constructible from
<code>*i</code>. <code>hasher</code>  and <code>key_equal</code> are
<code>CopyConstructible</code>.</ins><br/>
Constructs an empty container with at least <code>n</code> buckets, using
<code>hf</code> as the hash function and <code>eq</code> as the key equality predicate,
and inserts elements from <code>[i, j)</code> into it.</td>
<td>Average case <code>O(N)</code> (<code>N</code> is <code>distance(i, j)</code>), worst
case <code>O(N<sup>2</sup>)</code></td>
</tr>

<tr>
<td><code>X(i, j, n, hf)<br/>X a(i, j, n, hf)</code></td>
<td><code>X</code></td>
<td><ins><i>Requires:</i> <code>value_type</code> is constructible from <code>*i</code>.
<code>hasher</code> is <code>CopyConstructible</code> and <code>key_equal</code> is
<code>DefaultConstructible</code>.</ins><br/> Constructs an empty container with at
least <code>n</code> buckets, using <code>hf</code> as the hash function and
<code>key_equal()</code> as the key equality predicate, and inserts elements from
<code>[i, j)</code> into it.</td>
<td>Average case <code>O(N)</code> (<code>N</code> is <code>distance(i, j)</code>), worst
case <code>O(N<sup>2</sup>)</code></td>
</tr>

<tr>
<td><code>X(i, j, n)<br/>X a(i, j, n)</code></td>
<td><code>X</code></td>
<td><ins><i>Requires:</i> <code>value_type</code> is constructible from <code>*i</code>.
<code>hasher</code> and <code>key_equal</code> are
<code>DefaultConstructible</code>.</ins><br/> Constructs an empty container with at
least <code>n</code> buckets, using <code>hasher()</code> as the hash function and
<code>key_equal()</code> as the key equality predicate, and inserts elements from
<code>[i, j)</code> into it.</td>
<td>Average case <code>O(N)</code> (<code>N</code> is <code>distance(i, j)</code>), worst
case <code>O(N<sup>2</sup>)</code></td>
</tr>

<tr>
<td><code>X(i, j)<br/>X a(i, j)</code></td>
<td><code>X</code></td>
<td><ins><i>Requires:</i> <code>value_type</code> is constructible from <code>*i</code>.
<code>hasher</code> and <code>key_equal</code> are
<code>DefaultConstructible</code>.</ins><br/> Constructs an empty container with an
unspecified number of buckets, using <code>hasher()</code> as the hash function and
<code>key_equal()</code> as the key equality predicate, and inserts elements from
<code>[i, j)</code> into it.</td>
<td>Average case <code>O(N)</code> (<code>N</code> is <code>distance(i, j)</code>), worst
case <code>O(N<sup>2</sup>)</code></td>
</tr>

<tr>
<td><code>X(b)<br/>X a(b)</code></td>
<td><code>X</code></td>
<td>Copy constructor. In addition to the <del>contained elements</del>
<ins>requirements of Table 93 (23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>)</ins>, copies the hash function,
predicate, and maximum load factor.</td>
<td>Average case linear in <code>b.size()</code>, worst case quadratic.</td>
</tr>

<tr>
<td><code>a = b</code></td>
<td><code>X&amp;</code></td>
<td>Copy assignment operator. In addition to the <del>contained elements</del>
<ins>requirements of Table 93 (23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>)</ins>, copies the hash function,
predicate, and maximum load factor.</td>
<td>Average case linear in <code>b.size()</code>, worst case quadratic.</td>
</tr>

<tr>
<td><code>a = il</code></td>
<td><code>X&amp;</code></td>
<td><del><code>a = X(il); return *this;</code></del><br/>
<ins><i>Requires:</i> <code>T</code> is <code>CopyConstructible</code> and
<code>CopyAssignable</code>.</ins><br/>
<ins>Assigns the range <code>[il.begin(), il.end())</code> into <code>a</code>.  All
existing elements of <code>a</code> are either assigned or destroyed.</ins></td>
<td>Average case linear in <code>il.size()</code>, worst case quadratic.</td>
</tr>

<tr>
<td><code>a_uniq.emplace(args)</code></td>
<td><code>pair&lt;iterator, bool&gt;</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be constructible from
<code>args</code></ins><br/>
inserts a <code>T</code> object <code>t</code> constructed with
<code>std::forward&lt;Args&gt;(args)...</code> if and only if there is no element in
the container with key equivalent to the key of <code>t</code>. The <code>bool</code>
component of the returned pair is true if and only if the insertion takes place,
and the iterator component of the pair points to the element with key equivalent
to the key of <code>t</code>.</td>
<td>Average case O(1), worst case O(<code>a_uniq.size()</code>).</td>
</tr>

<tr>
<td><code>a_eq.emplace(args)</code></td>
<td><code>iterator</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be constructible from
<code>args</code></ins><br/>
inserts a <code>T</code> object <code>t</code> constructed with
<code>std::forward&lt;Args&gt;(args)...</code> and returns the iterator pointing to
the newly inserted element.</td>
<td>Average case O(1), worst case O(<code>a_eq.size()</code>).</td>
</tr>

<tr>
<td><code>a.emplace_hint(p, args)</code></td>
<td><code>iterator</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be constructible from
<code>args</code></ins><br/>
equivalent to <code>a.emplace( std::forward&lt;Args&gt;(args)...)</code>. Return
value is an iterator pointing to the element with the key equivalent to the
newly inserted element. The <code>const_iterator p</code> is a hint pointing to
where the search should start. Implementations are permitted to ignore the
hint.</td>
<td>Average case O(1), worst case O(<code>a.size()</code>).</td>
</tr>

<tr>
<td><code>a_uniq.insert(t)</code></td>
<td><code>pair&lt;iterator, bool&gt;</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be <code>MoveConstructible</code> if
<code>t</code> is a non-const rvalue expression, else <code>T</code> shall be
<code>CopyConstructible</code>.</ins><br/>
Inserts <code>t</code> if and only if there is no element in the container with key
equivalent to the key of <code>t</code>. The <code>bool</code> component of the returned
pair indicates whether the insertion takes place, and the iterator component
points to the element with key equivalent to the key of <code>t</code>.</td>
<td>Average case O(1), worst case O(<code>a_uniq.size()</code>).</td>
</tr>

<tr>
<td><code>a_eq.insert(t)</code></td>
<td><code>iterator</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be <code>MoveConstructible</code> if
<code>t</code> is a non-const rvalue expression, else <code>T</code> shall be
<code>CopyConstructible</code>.</ins><br/>
Inserts <code>t</code>, and returns an iterator pointing to the newly inserted
element.</td>
<td>Average case O(1), worst case O(<code>a_uniq.size()</code>).</td>
</tr>

<tr>
<td><code>a.insert(q, t)</code></td>
<td><code>iterator</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be <code>MoveConstructible</code> if
<code>t</code> is a non-const rvalue expression, else <code>T</code> shall be
<code>CopyConstructible</code>.</ins><br/>
Equivalent to <code>a.insert(t)</code>. Return value is an iterator pointing to the
element with the key equivalent to that of <code>t</code>. The iterator <code>q</code>
is a hint pointing to where the search should start. Implementations are
permitted to ignore the hint.</td>
<td>Average case O(1), worst case O(<code>a_uniq.size()</code>).</td>
</tr>

<tr>
<td><code>a.insert(i, j)</code></td>
<td><code>void</code></td>
<td><ins><i>Requires:</i> <code>T</code> shall be
constructible from <code>*i</code>.</ins><br/>
Pre: <code>i</code> and <code>j</code> are not iterators in <code>a</code>. Equivalent to
<code>a.insert(t)</code> for each element in <code>[i,j)</code>.</td>
<td>Average case O(<code>N</code>), where <code>N</code> is <code>distance(i, j)</code>.
Worst case O(<code>N * a.size()</code>).</td>
</tr>

</table>

</blockquote>

<p>
Change  [forwardlist]/2:
</p>

<blockquote><p>
2 A <code>forward_list</code> satisfies all of the requirements of a container
(table 91), except that the <code>size()</code> member function is not provided.
<ins>A <code>forward_list</code> also satisfies all of the requirements of an
allocator-aware container (table 93).  And <code>forward_list</code> provides the
<code>assign</code> member functions as specified in Table 94, Sequence container
requirements, and several of the optional sequence container requirements (Table
95).</ins>
Descriptions are provided here only for operations on <code>forward_list</code> that
are not described in that table or for operations where there is additional
semantic information.
</p></blockquote>

<p>
Add a new paragraph after  [forwardlist.modifiers]/23:
</p>

<blockquote><pre>
void clear();
</pre>

<blockquote>
<p>
23 <i>Effects:</i> Erases all elements in the range <code>[begin(),end())</code>.
</p>
<p><ins>
<i>Remarks:</i> Does not invalidate past-the-end iterators.
</ins></p>
</blockquote>
</blockquote>

<p>
Change 23.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>/13:
</p>

<blockquote><pre>
void resize(size_type sz, const T&amp; c);
</pre>
<blockquote><p>
13 <i>Requires:</i> <ins><code>T</code> shall be <code>CopyConstructible</code>.</ins>
If <code>value_type</code> has a move constructor, that constructor shall not throw
any exceptions.
</p></blockquote>
</blockquote>

<p>
In 23.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a> and 23.5.7 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset">[unord.multiset]</a> substitute
"<code>Key</code>" for "<code>Value</code>".
</p>

<blockquote>
<p><i>[
The above substitution is normative as it ties into the requirements table.
]</i></p>

</blockquote>






</body>
</html>
