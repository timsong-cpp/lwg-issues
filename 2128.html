<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2128: Absence of global functions cbegin&#47;cend</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="2128" href="lwg-defects.html#2128">2128.</a> Absence of global functions <tt>cbegin&#47;cend</tt></h3>
<p><b>Section:</b> 27.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, 27.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#C++14">C++14</a>
 <b>Submitter:</b> Dmitry Polukhin <b>Opened:</b> 2012-01-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>.</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++14">C++14</a> status.</p>
<p><b>Discussion:</b></p>

<p>
All standard containers support <tt>cbegin&#47;cend</tt> member functions but corresponding global functions are 
missing. Proposed resolution it to add global <tt>cbegin&#47;cend</tt> functions by analogy with global <tt>begin&#47;end</tt> 
functions. This addition will unify things for users.
</p>

<p><i>[2012, Kona]</i></p>


<p>STL: Range-based for loops do not use global <tt>begin</tt>/<tt>end</tt> (anymore).</p>
<p>Alisdair: We will have to make sure these will be available through many headers.</p>
<p>STL: Do this, including <tt>r</tt> and <tt>cr</tt>. This won't add any additional work.</p>
<p>Matt: Users will find it strange if these are not all available.</p>
<p>Alisdair: Should we have these available everywhere begin/end are available?</p>
<p>Marshall: Yes. Not any extra work.</p>
<p>Howard: Adding all of these means we need all of <tt>&lt;iterator></tt>.</p>
<p>STL: We already need it all.</p>
<p>Matt: We have to be careful what we are requiring if we include the <tt>r</tt> versions.</p>
<p>Jeffrey: If we include <tt>r</tt>, should they adapt if the container does not define reverse iteration?</p>
<p>STL: No. No special behavior. Should fail to compile. Up to user to add the reverse code--it's easy.</p>
<p>Howard: Anyway it will SFINAE out.</p>
<p>Alisdair: Error messages due to SFINAE are harder to understand than simple failure to compile.</p>
<p>STL: Agrees that SFINAE makes error messages much worse.</p>

<p>
Action: STL to provide additional wording for the <tt>r</tt> variants.
Move to Review once that wording is availalbe.
</p>

<p><i>[
2013-04-14 STL provides rationale and improved wording
]</i></p>


<p>Step 1: Implement <tt>std::cbegin/cend()</tt> by calling <tt>std::begin/end()</tt>. This has numerous advantages:</p>
<ul>
<li>It automatically works with arrays, which is the whole point of these non-member functions.</li>
<li>It works with C++98/03-era user containers, written before <tt>cbegin/cend()</tt> members were invented.</li>
<li>It works with <tt>initializer_list</tt>, which is extremely minimal and lacks <tt>cbegin/cend()</tt> members.</li>
<li>26.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> guarantees that this is equivalent to calling cbegin/cend() members.</li>
</ul>
<p>Step 2: Like <tt>std::begin/end()</tt>, implement <tt>std::rbegin/rend()</tt> by calling <tt>c.rbegin/rend()</tt>.  
Note that C++98/03 had the <tt>Reversible Container Requirements</tt>.</p>
<p>Step 3: Also like <tt>std::begin/end()</tt>, provide overloads of <tt>std::rbegin/rend()</tt> for arrays.</p>
<p>Step 4: Provide overloads of <tt>std::rbegin/rend()</tt> for <tt>initializer_list</tt>, because it lacks 
<tt>rbegin/rend()</tt> members. These overloads follow 21.9.4 <a href="https://timsong-cpp.github.io/cppwp/support.initlist.range">[support.initlist.range]</a>'s signatures. Note that 
because these overloads return <tt>reverse_iterator</tt>, they aren't being specified in <tt>&lt;initializer_list&gt;</tt>.</p>
<p>Step 5: Like Step 1, implement <tt>std::crbegin/crend()</tt> by calling <tt>std::rbegin/rend()</tt>.</p>

<p>Original wording saved here:</p>
<blockquote class="note">
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">N3337</a>.</p>

<ol>
<li><p>In 27.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header iterator synopsis, add the following declarations:</p>

<blockquote><pre>
namespace std {
  [&hellip;]
  <i>// 24.6.5, range access:</i>
  template &lt;class C&gt; auto begin(C&amp; c) -> decltype(c.begin());
  template &lt;class C&gt; auto begin(const C&amp; c) -> decltype(c.begin());
  template &lt;class C&gt; auto end(C&amp; c) -> decltype(c.end());
  template &lt;class C&gt; auto end(const C&amp; c) -> decltype(c.end());
  <ins>template &lt;class C&gt; auto cbegin(const C&amp; c) -> decltype(c.cbegin());</ins>
  <ins>template &lt;class C&gt; auto cend(const C&amp; c) -> decltype(c.cend());</ins>
  template &lt;class T, size_t N&gt; T* begin(T (&amp;array)[N]);
  template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);
  <ins>template &lt;class T, size_t N&gt; const T* cbegin(T (&amp;array)[N]);</ins>
  <ins>template &lt;class T, size_t N&gt; const T* cend(T (&amp;array)[N]);</ins>
}
</pre></blockquote>
</li>

<li><p>In 27.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> after p5 add the following series of paragraphs:</p>

<blockquote>
<pre>
<ins>template &lt;class C&gt; auto cbegin(const C&amp; c) -> decltype(c.cbegin());</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>c.cbegin()</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class C&gt; auto cend(const C&amp; c) -> decltype(c.cend());</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>c.cend()</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class T, size_t N&gt; const T* cbegin(T (&amp;array)[N]);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>array</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class T, size_t N&gt; const T* cend(T (&amp;array)[N]);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>array + N</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2013-04-18, Bristol]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf">N3485</a>.</p>

<ol>
<li><p>In 27.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header iterator synopsis, add the following declarations:</p>

<blockquote><pre>
namespace std {
  [&hellip;]
  <i>// 24.6.5, range access:</i>
  template &lt;class C&gt; auto begin(C&amp; c) -> decltype(c.begin());
  template &lt;class C&gt; auto begin(const C&amp; c) -> decltype(c.begin());
  template &lt;class C&gt; auto end(C&amp; c) -> decltype(c.end());
  template &lt;class C&gt; auto end(const C&amp; c) -> decltype(c.end());
  template &lt;class T, size_t N&gt; T* begin(T (&amp;array)[N]);
  template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);
  <ins>template &lt;class C&gt; auto cbegin(const C&amp; c) -> decltype(std::begin(c));</ins>
  <ins>template &lt;class C&gt; auto cend(const C&amp; c) -> decltype(std::end(c));</ins>
  <ins>template &lt;class C&gt; auto rbegin(C&amp; c) -> decltype(c.rbegin());</ins>
  <ins>template &lt;class C&gt; auto rbegin(const C&amp; c) -> decltype(c.rbegin());</ins>
  <ins>template &lt;class C&gt; auto rend(C&amp; c) -> decltype(c.rend());</ins>
  <ins>template &lt;class C&gt; auto rend(const C&amp; c) -> decltype(c.rend());</ins>
  <ins>template &lt;class T, size_t N&gt; reverse_iterator&lt;T*&gt; rbegin(T (&amp;array)[N]);</ins>
  <ins>template &lt;class T, size_t N&gt; reverse_iterator&lt;T*&gt; rend(T (&amp;array)[N]);</ins>
  <ins>template &lt;class E> reverse_iterator&lt;const E*&gt; rbegin(initializer_list&lt;E&gt; il);</ins>
  <ins>template &lt;class E> reverse_iterator&lt;const E*&gt; rend(initializer_list&lt;E&gt; il);</ins>
  <ins>template &lt;class C&gt; auto crbegin(const C&amp; c) -> decltype(std::rbegin(c));</ins>
  <ins>template &lt;class C&gt; auto crend(const C&amp; c) -> decltype(std::rend(c));</ins>
}
</pre></blockquote>
</li>

<li><p>At the end of 27.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>, add:</p>

<blockquote>
<pre>
<ins>template &lt;class C&gt; auto cbegin(const C&amp; c) -> decltype(std::begin(c));</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>std::begin(c)</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class C&gt; auto cend(const C&amp; c) -> decltype(std::end(c));</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>std::end(c)</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class C&gt; auto rbegin(C&amp; c) -> decltype(c.rbegin());</ins>
<ins>template &lt;class C&gt; auto rbegin(const C&amp; c) -> decltype(c.rbegin());</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>c.rbegin()</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class C&gt; auto rend(C&amp; c) -> decltype(c.rend());</ins>
<ins>template &lt;class C&gt; auto rend(const C&amp; c) -> decltype(c.rend());</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>c.rend()</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class T, size_t N&gt; reverse_iterator&lt;T*&gt; rbegin(T (&amp;array)[N]);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>reverse_iterator&lt;T*&gt;(array + N)</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class T, size_t N&gt; reverse_iterator&lt;T*&gt; rend(T (&amp;array)[N]);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>reverse_iterator&lt;T*&gt;(array)</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class E> reverse_iterator&lt;const E*&gt; rbegin(initializer_list&lt;E&gt; il);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>reverse_iterator&lt;const E*&gt;(il.end())</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class E> reverse_iterator&lt;const E*&gt; rend(initializer_list&lt;E&gt; il);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>reverse_iterator&lt;const E*&gt;(il.begin())</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class C&gt; auto crbegin(const C&amp; c) -> decltype(std::rbegin(c));</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>std::rbegin(c)</tt>.</ins>
</p>
</blockquote>

<pre>
<ins>template &lt;class C&gt; auto crend(const C&amp; c) -> decltype(std::rend(c));</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt>std::rend(c)</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






</body>
</html>
