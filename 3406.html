<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3406: elements_view::begin() and elements_view::end() have incompatible
constraints</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="3406" href="lwg-active.html#3406">3406.</a> <tt>elements_view::begin()</tt> and <tt>elements_view::end()</tt> have incompatible
constraints</h3>
<p><b>Section:</b> 24.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.elements.view">[range.elements.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Patrick Palka <b>Opened:</b> 2020-02-21 <b>Last modified:</b> 2020-02-23 12:04:17 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.elements.view">issues</a> in [range.elements.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://wg21.link/p1994r1">P1994R1</a> (<tt>elements_view</tt> needs its own 
<tt>sentinel</tt>) introduces a distinct <tt><i>sentinel</i></tt> type for <tt>elements_view</tt>.  
In doing so, it replaces the two existing overloads of <tt>elements_view::end()</tt> with four new ones:
</p>
<blockquote><pre>
<del>-    constexpr auto end() requires (!<i>simple-view</i>&lt;V&gt;)
-    { return ranges::end(base_); }
-
-    constexpr auto end() const requires <i>simple-view</i>&lt;V&gt;
-    { return ranges::end(base_); }</del>

<ins>+    constexpr auto end()
+    { return <i>sentinel</i>&lt;false&gt;{ranges::end(base_)}; }
+
+    constexpr auto end() requires common_range&lt;V&gt;
+    { return <i>iterator</i>&lt;false&gt;{ranges::end(base_)}; }
+
+    constexpr auto end() const
+      requires range&lt;const V&gt;
+    { return <i>sentinel</i>&lt;true&gt;{ranges::end(base_)}; }
+
+    constexpr auto end() const
+      requires common_range&lt;const V&gt;
+    { return <i>iterator</i>&lt;true&gt;{ranges::end(base_)}; }</ins>
</pre></blockquote>
<p>
But now these new overloads of <tt>elements_view::end()</tt> have constraints
that are no longer consistent with the constraints of <tt>elements_view::begin()</tt>:
</p>
<blockquote><pre>
     constexpr auto begin() requires (!<i>simple-view</i>&lt;V&gt;)
     { return <i>iterator</i>&lt;false&gt;(ranges::begin(base_)); }
     
     constexpr auto begin() const requires <i>simple-view</i>&lt;V&gt;
     { return <i>iterator</i>&lt;true&gt;(ranges::begin(base_)); }
</pre></blockquote>
<p>
This inconsistency means that we can easily come up with a view <tt>V</tt> for
which <tt>elements_view&lt;V&gt;::begin()</tt> returns an <tt><i>iterator</i>&lt;true&gt;</tt> 
and <tt>elements_view&lt;V&gt;::end()</tt> returns an <tt><i>sentinel</i>&lt;false&gt;</tt>, 
i.e. incomparable things of opposite constness. For example:
</p>
<blockquote><pre>
tuple&lt;int, int&gt; x[] = {{0,0}};
ranges::subrange r = {counted_iterator(x, 1), default_sentinel};
auto v = r | views::elements&lt;0&gt;;
v.begin() == v.end(); <i>// ill-formed</i>
</pre></blockquote>
<p>
Here, overload resolution for <tt>begin()</tt> selects the <tt>const</tt> overload because
the subrange <tt>r</tt> models <tt><i>simple-view</i></tt>. But overload resolution for 
<tt>end()</tt> selects the non-<tt>const</tt> non-<tt>common_range</tt> overload. Hence 
the last line of this snippet is ill-formed because it is comparing an iterator and
sentinel of opposite constness, for which we have no matching <tt>operator==</tt>
overload. So in this example <tt>v</tt> does not even model range because its <tt>begin()</tt> 
and <tt>end()</tt> are incomparable.
<p/>
This issue can be resolved by making sure the constraints on <tt>elements_view::begin()</tt> 
and on <tt>elements_view::end()</tt> are consistent and compatible. The following proposed 
resolution seems to be one way to achieve that and takes inspiration from the design of 
<tt>transform_view</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4849">N4849</a> after application of
<a href="http://wg21.link/p1994r1">P1994R1</a>.
</p>

<ol>
<li><p>Modify 24.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.elements.view">[range.elements.view]</a>, class template <tt>elements_view</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; <i>has-tuple-element</i>&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
      <i>has-tuple-element</i>&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt;
  class elements_view : public view_interface&lt;elements_view&lt;V, N&gt;&gt; {
  public:
    [&hellip;]
    constexpr V base() &amp;&amp; { return std::move(base_); }
    
    constexpr auto begin() <del>requires (!<i>simple-view</i>&lt;V&gt;)</del>
    { return <i>iterator</i>&lt;false&gt;(ranges::begin(base_)); }
    constexpr auto begin() const requires <del><i>simple-view</i>&lt;V&gt;</del><ins>range&lt;const V&gt;</ins>
    { return <i>iterator</i>&lt;true&gt;(ranges::begin(base_)); }    
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>
</ol>




</body>
</html>
