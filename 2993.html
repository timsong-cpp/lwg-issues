<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 2993: reference_wrapper&lt;T&gt; conversion from T&amp;&amp;</title>
<meta property="og:title" content="Issue 2993: reference_wrapper&lt;T&gt; conversion from T&amp;&amp;">
<meta property="og:description" content="C++ library issue. Status: C++20">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/2993.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="2993"><a href="lwg-defects.html#2993">2993</a>. <code>reference_wrapper&lt;T&gt;</code> conversion from <code>T&amp;&amp;</code></h3>
<p><b>Section:</b> 22.10.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap">[refwrap]</a> <b>Status:</b> <a href="lwg-active.html#C++20">C++20</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-06-28 <b>Last modified:</b> 2021-02-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#refwrap">issues</a> in [refwrap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++20">C++20</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>reference_wrapper&lt;T&gt;</code> has a deleted constructor taking <code>T&amp;&amp;</code> in order to
prevent accidentally wrapping an rvalue (which can otherwise happen with the 
<code>reference_wrapper(T&amp;)</code> constructor if <code>T</code> is a non-<code>volatile</code>
<code>const</code>-qualified type). Unfortunately, a deleted constructor can still
be used to form implicit conversion sequences, so the deleted <code>T&amp;&amp;</code>
constructor has the (presumably unintended) effect of creating an implicit conversion sequence from 
a <code>T</code> rvalue to a <code>reference_wrapper&lt;T&gt;</code>, even though such a conversion would be
ill-formed if actually used. This is visible in overload resolution:
</p>
<blockquote><pre>
void meow(std::reference_wrapper&lt;int&gt;); //#1
void meow(convertible_from_int); //#2
meow(0); // <span style="color:#C80000;font-weight:bold">error, ambiguous</span>; would unambiguously call #2 if #1 instead took int&amp;
</pre></blockquote>
<p>
and in conditional expressions (and hence <code>std::common_type</code>) after <a href="https://wg21.link/cwg1895">core issue 1895</a>:
</p>
<blockquote><pre>
std::reference_wrapper&lt;int&gt; purr();

auto x = true? purr() : 0; // <span style="color:#C80000;font-weight:bold">error, ambiguous:</span> ICS exists from int prvalue to 
                           // reference_wrapper&lt;int&gt; and from reference_wrapper&lt;int&gt; to int

using t = std::common_type_t&lt;std::reference_wrapper&lt;int&gt;, int&gt;; // <span style="color:#C80000;font-weight:bold">error:</span> no member 'type' because the conditional 
                                                                // expression is ill-formed
</pre></blockquote>
<p>
The latter in turn interferes with the use of <code>reference_wrapper</code> as a
proxy reference type with proxy iterators.
<p/>
We should ensure that there is no implicit conversion sequence from <code>T</code>
rvalues to <code>reference_wrapper&lt;T&gt;</code>, not just that the conversion will be
ill-formed when used. This can be done by using a suitably constrained
constructor template taking a forwarding reference instead of the
current pair of constructors taking <code>T&amp;</code> and <code>T&amp;&amp;</code>.
</p>
<p><i>[2017-06-29, Tim adds P/R and comments]</i></p>

<p>
The draft P/R below uses a conditional <code>noexcept</code> specification to ensure that converting a <code>T&amp;</code> to
a <code>reference_wrapper&lt;T&gt;</code> remains <code>noexcept</code> and make it not usable when the source type is a 
<code>reference_wrapper</code> of the same type so as to avoid affecting <code>is_trivially_constructible</code>. It adds a deduction
guide as the new constructor template will not support class template argument deduction.
<p/>
The constructor template has the additional effect of making <code>reference_wrapper&lt;T&gt;</code> convertible from everything
that is convertible to <code>T&amp;</code>. This implies, for instance, that <code>reference_wrapper&lt;int&gt;</code> is now
convertible to <code>reference_wrapper&lt;const int&gt;</code> when it wasn't before (the conversion would have required 
two user-defined conversions previously). This more closely emulates the behavior of an actual reference, but does represent
a change to the existing behavior.
<p/>
If perfectly emulating the existing behavior is desired, a conditionally-explicit constructor that is only implicit if 
<code>T</code> is reference-compatible with <code>remove_reference_t&lt;U&gt;</code> (see 9.4.4 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.ref">[dcl.init.ref]</a>) can be used.
</p>

<p><i>[2017-07 Toronto Tuesday PM issue prioritization]</i></p>

<p>Priority 3; what else in the library does this affect? <code>ref</code> or <code>cref</code>?</p>

<p><i>[2016-07, Toronto Saturday afternoon issues processing]</i></p>

<p>Status to Ready.</p>


<p id="res-2993"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>
<ol>
<li><p>Edit 22.10.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap">[refwrap]</a>, class template <code>reference_wrapper</code> synopsis, as indicated:</p>
<blockquote>
<pre>
namespace std {
  template &lt;class T&gt; class reference_wrapper {
    [&hellip;]
    // construct/copy/destroy
<del>    reference_wrapper(T&amp;) noexcept;
    reference_wrapper(T&amp;&amp;) = delete;    // do not bind to temporary objects</del>
<ins>    template &lt;class U&gt;
      reference_wrapper(U&amp;&amp;) noexcept(<i>see below</i>);</ins>
    [&hellip;]
  };
<ins>  template &lt;class T&gt;
  reference_wrapper(T&amp;) -&gt; reference_wrapper&lt;T&gt;;</ins>
  [&hellip;]
}
</pre>
</blockquote>
</li>
<li><p>Edit 22.10.6.2 <a href="https://timsong-cpp.github.io/cppwp/refwrap.const">[refwrap.const]</a>/1 as indicated:</p>
<blockquote>
<pre>
<del>reference_wrapper(T&amp; t) noexcept;</del>
</pre>
<blockquote>
<p><del>-1- <i>Effects:</i> Constructs a <code>reference_wrapper</code> object that stores a reference to <code>t</code>.</del></p>
</blockquote>
<pre>
<ins>template&lt;class U&gt;
  reference_wrapper(U&amp;&amp; u) noexcept(<i>see below</i>);</ins>
</pre>
<blockquote>
<p><ins>
-?- <i>Remarks:</i> Let <code><i>FUN</i></code> denote the exposition-only functions</ins>
<blockquote><pre>
<ins>void <i>FUN</i>(T&amp;) noexcept;
void <i>FUN</i>(T&amp;&amp;) = delete;</ins>
</pre></blockquote>
<ins>This constructor shall not participate in overload resolution unless the expression <code><i>FUN</i>(declval&lt;U&gt;())</code> is well-formed
and <code>is_same_v&lt;decay_t&lt;U&gt;, reference_wrapper&gt;</code> is <code>false</code>.
The expression inside <code>noexcept</code> is equivalent to <code>noexcept(<i>FUN</i>(declval&lt;U&gt;()))</code>.</ins>
<p/>
<ins>-?- <i>Effects:</i> Creates a variable <code>r</code> as if by <code>T&amp; r = std::forward&lt;U&gt;(u)</code>, then constructs a
<code>reference_wrapper</code> object that stores a reference to <code>r</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>




</body>
</html>
