<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3882: tuple relational operators have confused friendships</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3><a name="3882" href="lwg-active.html#3882">3882.</a> <tt>tuple</tt> relational operators have confused friendships</h3>
<p><b>Section:</b> 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Corentin Jabot <b>Opened:</b> 2023-02-08 <b>Last modified:</b> 2023-03-22 22:36:03 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>:
</p>
<blockquote><pre>
template&lt;class... TTypes, <i>tuple-like</i> UTuple>
  constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const UTuple&amp; u);
</pre></blockquote>
<p>
Is defined as a non-member non-friend function that "is to be found via argument-dependent lookup only."
<p/>
The intent is that it should be defined as a hidden friend in <tt>tuple</tt>.
<p/>
The current specification is confusing as to which class should contain that hidden friend, or how to otherwise 
implement that adl only restriction. (An hostile reading may consider it to be a hidden friend of <tt>UTuple</tt>), 
and does not follow the guidance of <a href="https://wg21.link/P1601">P1601</a> "Recommendations for Specifying ``Hidden Friends''".
<p/>
We should consider making these <tt>operator==</tt> and <tt>operator&lt;=&gt;</tt> overloads hidden friends of 
<tt>tuple</tt>, i.e.
</p>
<blockquote><pre>
std::tuple {
  template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
  friend constexpr bool operator==(const tuple&amp; t, const UTuple&amp; u);
  template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
  friend constexpr <i>see below</i> operator&lt;=&gt;(const tuple&amp;, const UTuple&amp;);
};
</pre></blockquote>

<p><i>[2023-02-18; Daniel provides wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>
<li><p>Modify 22.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.syn">[tuple.syn]</a>, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  // <i>22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, relational operators</i>
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  <del>template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const UTuple&amp;);</del>
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
      operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  <del>template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
    constexpr <i>see below</i> operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const UTuple&amp;);</del>
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, class template <tt>tuple</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class... Types&gt;
  class tuple {
  public:
    [&hellip;]

    template&lt;<i>tuple-like</i> UTuple&gt;
      constexpr tuple&amp; operator=(UTuple&amp;&amp;);
    template&lt;<i>tuple-like</i> UTuple&gt;
      constexpr const tuple&amp; operator=(UTuple&amp;&amp;) const;

    <ins>// <i>22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, relational operators</i></ins>
    <ins>template&lt;<i>tuple-like</i> UTuple&gt;
      friend constexpr bool operator==(const tuple&amp;, const UTuple&amp;);</ins>
    <ins>template&lt;<i>tuple-like</i> UTuple&gt;
      friend constexpr <i>see below</i> operator&lt;=&gt;(const tuple&amp;, const UTuple&amp;);</ins>

    // <i>22.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a>, tuple swap</i>
    constexpr void swap(tuple&amp;) noexcept(<i>see below</i>);
    constexpr void swap(const tuple&amp;) const noexcept(<i>see below</i>);
  };
}
</pre>
</blockquote>

</li>


<li><p>Modify 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
template&lt;<del>class... TTypes,</del> <i>tuple-like</i> UTuple&gt;
  <ins>friend</ins> constexpr bool operator==(const tuple<del>&lt;TTypes...&gt;</del>&amp; t, const UTuple&amp; u);
</pre>
<blockquote>
<p>
-1- For the first overload let <tt>UTuple</tt> be <tt>tuple&lt;UTypes...&gt;</tt>. <ins>For the second overload
let <tt>TTypes</tt> denote the pack <tt>Types</tt>.</ins>
<p/>
[&hellip;]
<p/>
-5- <i>Remarks</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; The elementary comparisons are performed in order from the zeroth index upwards. No comparisons
or element accesses are performed after the first equality comparison that evaluates to <tt>false</tt>.</p></li>
<li><p>(5.2) &mdash; The second overload is to be found via argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>) only.</p></li>
</ol>
</blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
    operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
template&lt;<del>class... TTypes,</del> <i>tuple-like</i> UTuple&gt;
  <ins>friend</ins> constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;<del>T</del>Types, Elems&gt;...&gt; 
    operator&lt;=&gt;(const tuple<del>&lt;TTypes...&gt;</del>&amp; t, const UTuple&amp; u);
</pre>
<blockquote>
<p>
-6- For the second overload, <ins>let <tt>TTypes</tt> denote the pack <tt>Types</tt> and</ins> <tt>Elems</tt> denotes the 
pack of types <tt>tuple_element_t&lt;0, UTuple&gt;, tuple_element_t&lt;1, UTuple&gt;, ... , 
tuple_element_t&lt;tuple_size_v&lt;UTuple&gt; - 1, UTuple&gt;</tt>.
<p/>
[&hellip;]
<p/>
-8- <i>Remarks</i>: The second overload is to be found via argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>) only.
</p>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>


<p><i>[2023-03-05; Daniel comments and provides improved wording]</i></p>

<p>
The revised wording ensures that no ambiguity exists between the overload candidates, furthermore the additional wording about
being found via argument-dependent lookup only has been eliminated, because the general conventions of 16.4.6.6 <a href="https://timsong-cpp.github.io/cppwp/hidden.friends">[hidden.friends]</a>
apply. 
<p/>
The reusage of the exposition-only concept <tt><i>different-from</i></tt> is already existing practice in various places of 
22.4 <a href="https://timsong-cpp.github.io/cppwp/tuple">[tuple]</a>. We have also existing wording practice where we have an extra <i>Constraints:</i> element added even though 
a prototype has already a language constraint as part of its signature.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3882"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>
<li><p>Modify 22.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.syn">[tuple.syn]</a>, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  // <i>22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, relational operators</i>
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  <del>template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const UTuple&amp;);</del>
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
      operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  <del>template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
    constexpr <i>see below</i> operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const UTuple&amp;);</del>
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, class template <tt>tuple</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class... Types&gt;
  class tuple {
  public:
    [&hellip;]

    template&lt;<i>tuple-like</i> UTuple&gt;
      constexpr tuple&amp; operator=(UTuple&amp;&amp;);
    template&lt;<i>tuple-like</i> UTuple&gt;
      constexpr const tuple&amp; operator=(UTuple&amp;&amp;) const;

    <ins>// <i>22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, relational operators</i></ins>
    <ins>template&lt;<i>tuple-like</i> UTuple&gt;
      friend constexpr bool operator==(const tuple&amp;, const UTuple&amp;);</ins>
    <ins>template&lt;<i>tuple-like</i> UTuple&gt;
      friend constexpr <i>see below</i> operator&lt;=&gt;(const tuple&amp;, const UTuple&amp;);</ins>

    // <i>22.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a>, tuple swap</i>
    constexpr void swap(tuple&amp;) noexcept(<i>see below</i>);
    constexpr void swap(const tuple&amp;) const noexcept(<i>see below</i>);
  };
}
</pre>
</blockquote>

</li>


<li><p>Modify 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
template&lt;<del>class... TTypes,</del> <i>tuple-like</i> UTuple&gt;
  <ins>friend</ins> constexpr bool operator==(const tuple<del>&lt;TTypes...&gt;</del>&amp; t, const UTuple&amp; u);
</pre>
<blockquote>
<p>
-1- For the first overload let <tt>UTuple</tt> be <tt>tuple&lt;UTypes...&gt;</tt>. <ins>For the second overload
let <tt>TTypes</tt> denote the pack <tt>Types</tt>.</ins>
<p/>
<ins>-?- <i>Constraints</i>: For the second overload, <tt><i>different-from</i>&lt;UTuple, tuple&gt;</tt> 
(26.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>) is <tt>true</tt>.</ins>
<p/>
-2- <i>Mandates</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-5- <i>Remarks</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(5.1) &mdash;</del> The elementary comparisons are performed in order from the zeroth index upwards. No comparisons
or element accesses are performed after the first equality comparison that evaluates to <tt>false</tt>.</p></li>
<li><p><del>(5.2) &mdash; The second overload is to be found via argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>) only.</del></p></li>
</ol>
</blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
    operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
template&lt;<del>class... TTypes,</del> <i>tuple-like</i> UTuple&gt;
  <ins>friend</ins> constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;<del>T</del>Types, Elems&gt;...&gt; 
    operator&lt;=&gt;(const tuple<del>&lt;TTypes...&gt;</del>&amp; t, const UTuple&amp; u);
</pre>
<blockquote>
<p>
-6- For the second overload, <ins>let <tt>TTypes</tt> denote the pack <tt>Types</tt> and</ins> <tt>Elems</tt> denotes the 
pack of types <tt>tuple_element_t&lt;0, UTuple&gt;, tuple_element_t&lt;1, UTuple&gt;, ... , 
tuple_element_t&lt;tuple_size_v&lt;UTuple&gt; - 1, UTuple&gt;</tt>.
<p/>
<ins>-?- <i>Constraints</i>: For the second overload, <tt><i>different-from</i>&lt;UTuple, tuple&gt;</tt> 
(26.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>) is <tt>true</tt>.</ins>
<p/>
-7- <i>Effects</i>: [&hellip;]
<p/>
<del>-8- <i>Remarks</i>: The second overload is to be found via argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>) only.</del>
</p>
</blockquote>
</blockquote>

</li>

</ol>





</body>
</html>
