<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3031: Algorithms and predicates with non-const reference arguments</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="3031" href="lwg-defects.html#3031">3031.</a> Algorithms and predicates with non-const reference arguments</h3>
<p><b>Section:</b> 24.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> <b>Status:</b> <a href="lwg-active.html#WP">WP</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-11-08 <b>Last modified:</b> 2018-11-12 04:39:29 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This doesn't compile with any major implementation:
</p>
<blockquote><pre>
int i[1] = { };
std::stable_sort(i, i, [](int&amp; x, int&amp; y) { return x &lt; y; });
</pre></blockquote>
<p>
The problem is that the <tt>Compare</tt> expects non-const references. We say "It is assumed that
<tt>comp</tt> will not apply any non-constant function through the dereferenced iterator" But that
isn't sufficient to forbid the example.
<p/>
My first thought was to modify [alg.sorting] to make the <tt>Compare</tt> requirements use
<tt>comp(as_const(x), as_const(x))</tt> but that would get very verbose to add to every expression
using <tt>comp</tt>.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 2; Jonathan to improve the statement of the problem.</p>

<p><i>[2018-02 David Jones provided this <a href="https://bugs.llvm.org/show_bug.cgi?id=34536">truly awful example</a>:]</i></p>

<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Base {
    Base(int value) : v(value) {}
    friend bool operator&lt;(const Base&amp; l, const Base&amp; r) { return l.v &lt; r.v; }
    int v;
};

struct Derived : public Base {
    using Base::Base;
    bool operator&lt;(const Derived&amp; o) /* no const here */ { return v &gt; o.v; }
};

int main(void) {
    std::vector&lt;Base&gt; b = {{1}, {5}, {0}, {3}};
    std::vector&lt;Derived&gt; d = {{0}, {1}, {3}, {5}};

    std::cout &lt;&lt; std::lower_bound(d.begin(), d.end(), 4)-&gt;v &lt;&lt; std::endl;

    std::sort(b.begin(), b.end());
    for (const auto &amp;x : b) std::cout &lt;&lt; x.v &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;

    std::sort(d.begin(), d.end());
    for (const auto &amp;x : d) std::cout &lt;&lt; x.v &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;
}

libc++:
=====
$ bin/clang++ -std=c++11 -stdlib=libc++ tmp/ex.cc &amp;&amp; ./a.out
5
0 1 3 5 
0 1 3 5 
=====

libstdc++:
=====
$ bin/clang++ -std=c++11 -stdlib=libstdc++ tmp/ex.cc &amp;&amp; ./a.out
0
0 1 3 5 
5 3 1 0 
=====
</pre></blockquote>

<p><i>[2018-08 Batavia Monday issue discussion]</i></p>

<p>Tim to provide wording; status to 'Open'</p>

<p><i>[ 2018-08-20, Tim adds P/R based on Batavia discussion.]</i></p>

<p>
Similar to the Ranges TS design, the P/R below requires <tt>Predicate</tt>,
<tt>BinaryPredicate</tt>, and <tt>Compare</tt> to accept all mixes of
<tt>const</tt> and non-<tt>const</tt> arguments.
</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively Ready after minor wording nit (corrected in place)</p>
<p><i>[2018-11, Adopted in San Diego]</i></p>



<p><b>Proposed resolution:</b></p>
<p> This wording is relative to <a href="https://wg21.link/N4762">N4762</a>.</p>
<ol>
<li>
<p>Edit 24.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> p6-7 as indicated: </p>
<blockquote>
<p>
-6- The <tt>Predicate</tt> parameter is used whenever an algorithm expects a function object
(19.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>) that, when applied to the result of dereferencing the
corresponding iterator, returns a value testable as <tt>true</tt>. In other words, if an
algorithm takes <tt>Predicate pred</tt> as its argument and <tt>first</tt> as its iterator
argument<ins> with value type <tt>T</tt></ins>, it should work correctly in the construct
<tt>pred(*first)</tt> contextually converted to <tt>bool</tt> (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>). The
function object <tt>pred</tt> shall not apply any non-constant function through the
dereferenced iterator.<ins> Given a glvalue <tt>u</tt> of type (possibly <tt>const</tt>)
<tt>T</tt> that designates the same object as <tt>*first</tt>, <tt>pred(u)</tt> shall be a
valid expression that is equal to <tt>pred(*first)</tt>.</ins>
<p/>
-7- The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a function
object that when applied to the result of dereferencing two corresponding iterators or to
dereferencing an iterator and type <tt>T</tt> when <tt>T</tt> is part of the signature
returns a value testable as <tt>true</tt>. In other words, if an algorithm takes
<tt>BinaryPredicate binary_pred</tt> as its argument and <tt>first1</tt> and <tt>first2</tt>
as its iterator arguments<ins> with respective value types <tt>T1</tt> and <tt>T2</tt></ins>,
it should work correctly in the construct <tt>binary_pred(*first1, *first2)</tt>
contextually converted to <tt>bool</tt> (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>).
<ins>Unless otherwise specified, </ins><tt>BinaryPredicate</tt> always takes the first iterator's
<tt>value_type</tt> as its first argument, that is, in those cases when <tt>T value</tt> is part
of the signature, it should work correctly in the construct <tt>binary_pred(*first1, value)</tt>
contextually converted to <tt>bool</tt> (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>). <tt>binary_pred</tt> shall not
apply any non-constant function through the dereferenced iterators. <ins>Given a glvalue <tt>u</tt>
of type (possibly <tt>const</tt>) <tt>T1</tt> that designates the same object as <tt>*first1</tt>,
and a glvalue <tt>v</tt> of type (possibly <tt>const</tt>) <tt>T2</tt> that designates the
same object as <tt>*first2</tt>, <tt>binary_pred(u, *first2)</tt>, <tt>binary_pred(*first1, v)</tt>,
and <tt>binary_pred(u, v)</tt> shall each be a valid expression that is equal to
<tt>binary_pred(*first1, *first2)</tt>, and <tt>binary_pred(u, value)</tt> shall
be a valid expression that is equal to <tt>binary_pred(*first1, value)</tt>.</ins>
</p>
</blockquote>
</li>
<li>
<p>Edit 24.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> p2 as indicated: </p>
<blockquote>
<p>
<tt>Compare</tt> is a function object type (19.14 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>)<ins> that meets the
requirements for a template parameter named <tt>BinaryPredicate</tt>
(24.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>)</ins>. The return value of the function call operation
applied to an object of type <tt>Compare</tt>, when contextually converted to <tt>bool</tt>
(7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>), yields <tt>true</tt> if the first argument of the call is less than the second,
and <tt>false</tt> otherwise. <tt>Compare comp</tt> is used throughout for algorithms assuming an
ordering relation. <del>It is assumed that <tt>comp</tt> will not apply any non-constant function
through the dereferenced iterator.</del>
</p>
</blockquote>
</li>
</ol>





</body>
</html>
