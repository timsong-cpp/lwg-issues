<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues Resolved Directly In [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues Resolved In [INSERT CURRENT MEETING HERE]</h1>
<hr>
<h3><a name="2872"></a>2872. Add definition for direct-non-list-initialization</h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Add the following to 17.3 <a href="https://timsong-cpp.github.io/cppwp/definitions">[definitions]</a> as indicated:</p>
<blockquote>
<p>
<ins><b>17.3.? direct-non-list-initialization [defns.direct-non-list-init]</b></ins>
<p/>
<ins>A direct-initialization that is not list-initialization.</ins>
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2890"></a>2890. The definition of 'object state' applies only to class types</h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>
<ol>
<li><p>Modify 17.3.16 <a href="https://timsong-cpp.github.io/cppwp/defns.obj.state">[defns.obj.state]</a> as indicated:</p>

<blockquote>
<p>
<del><b>17.3.16 [defns.obj.state]</b></del>
<p/>
<del><b>object state</b></del>
<p/>
<del>the current value of all non-static class members of an object (9.2)
[<i>Note:</i> The state of an object can be obtained by using one or more observer functions. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

<li><p>Modify 17.3.25 <a href="https://timsong-cpp.github.io/cppwp/defns.valid">[defns.valid]</a> as indicated:</p>

<blockquote>
<p>
<b>17.3.25 [defns.valid]</b>
<p/>
<b>valid but unspecified state</b>
<p/>
<del>an object state</del><ins>a value of an object</ins> that is not specified except that the object's invariants are 
met and operations on the object behave as specified for its type
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2260"></a>2260. Missing requirement for <tt>Allocator::pointer</tt></h3>

<ol>
<li><p>
Edit Table 28 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z)</tt>
</td>
<td>
<tt>X::const_pointer</tt>
</td>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z) == q</tt>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<ins><tt>pointer_traits&lt;X::pointer&gt;::pointer_to(r)</tt></ins>
</td>
<td>
<ins><tt>X::pointer</tt></ins>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>


</li>
</ol>


<hr>
<h3><a name="2795"></a>2795. &sect;[global.functions] provides incorrect example of ADL use</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 17.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> p4:</p>
<blockquote>
<p>
Unless otherwise specified, <ins>calls made by functions in the standard library to non-operator,</ins> non-member functions 
 <del>in the standard library</del> <del>shall</del><ins>do</ins> not use functions from another namespace which are found through 
argument-dependent name lookup (3.4.2). [<i>Note:</i> The phrase "unless otherwise specified" <ins>applies to 
cases such as the swappable with requirements (17.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>). 
The exception for overloaded operators allows</ins><del>is intended to allow</del> argument-dependent lookup in cases like that of 
<tt>ostream_iterator::operator=</tt> (24.6.2.2):
</p>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote>
<pre>
*out_stream &lt;&lt; value;
if (delim != 0)
  *out_stream &lt;&lt; delim ;
return *this;
</pre>
</blockquote>
<p>
&mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2866"></a>2866. Incorrect derived classes constraints</h3>

<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>

<li><p>Modify 17.5.5.11 <a href="https://timsong-cpp.github.io/cppwp/derivation">[derivation]</a> paragraph 3.2 as indicated:</p>
<blockquote>
<del>Every base class described as non-<tt>virtual</tt> shall not be virtual;</del>
<ins>Every base class not specified as <tt>virtual</tt> shall not be virtual;</ins>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2784"></a>2784. Resolution to LWG 2484 is missing "otherwise, no effects" and is hard to parse</h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Modify 18.8.7 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> p9:</p>

<blockquote>
<pre>
template &lt;class E&gt; void rethrow_if_nested(const E&amp; e);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> If <tt>E</tt> is not a polymorphic class type, <ins>or if <tt>nested_exception</tt> is an inaccessible 
or ambiguous base class of <tt>E</tt>,</ins> there is no effect. Otherwise, <del>if the static type or 
the dynamic type of <tt>e</tt> is <tt>nested_exception</tt> or is publicly and unambiguously derived from 
<tt>nested_exception</tt>, calls</del><ins>performs</ins>:
</p>
<blockquote>
<pre>
<del>dynamic_cast&lt;const nested_exception&amp;&gt;(e).rethrow_nested();</del>
<ins>if (auto p = dynamic_cast&lt;const nested_exception*&gt;(addressof(e)))
  p-&gt;rethrow_nested();</ins>
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2855"></a>2855. <tt>std::throw_with_nested("string_literal")</tt></h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 18.8.7 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T&gt; [[noreturn]] void throw_with_nested(T&amp;&amp; t);
</pre>
<blockquote>
<p>
-6- Let <tt>U</tt> be <tt><del>remove_reference</del><ins>decay</ins>_t&lt;T&gt;</tt>.
<p/>
-7- <i>Requires:</i> <tt>U</tt> shall be <tt>CopyConstructible</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2796"></a>2796. <tt>tuple</tt> should be a literal type</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Add a new paragraph after 20.4.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> p2:</p>
<blockquote>
<p>
-2- The defaulted move and copy constructor, respectively, of <tt>pair</tt> shall be a <tt>constexpr</tt> function 
if and only if all required element-wise initializations for copy and move, respectively, would satisfy the requirements for a
<tt>constexpr</tt> function. <ins>The destructor of <tt>pair</tt> shall be a trivial destructor if 
<tt>(is_trivially_destructible_v&lt;T1&gt; &amp;&amp; is_trivially_destructible_v&lt;T2&gt;)</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</li>

<li><p>Add a new paragraph after the class synopsis in 20.5.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>:</p>
<blockquote>
<p>
<ins>-?- The destructor of <tt>tuple</tt> shall be a trivial destructor if 
<tt>(is_trivially_destructible_v&lt;Types&gt; &amp;&amp; ...)</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2857"></a>2857. <tt>{variant,optional,any}::emplace</tt> should return the constructed value</h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Update the following signatures in 20.6.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a>, class template <tt>optional</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 20.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a>, assignment</i>
[&hellip;]
template &lt;class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(Args&amp;&amp;...);
template &lt;class U, class... Args&gt;
  <del>void</del><ins>T&amp;</ins> emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-27- <i>Postconditions:</i> <tt>*this</tt> contains a value.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-28- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
</p>
</blockquote>
<pre>
template &lt;class U, class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-31- <i>Postconditions:</i> <tt>*this</tt> contains a value.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-32- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify the following signatures in 20.7.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>, class template <tt>variant</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 20.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a>, modifiers</i>
template &lt;class T, class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(Args&amp;&amp;...);
template &lt;class T, class U, class... Args&gt;
  <del>void</del><ins>T&amp;</ins> emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
template &lt;size_t I, class... Args&gt; <del>void</del><ins>variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;</ins> emplace(Args&amp;&amp;...);
template &lt;size_t I, class U, class... Args&gt;
  <del>void</del><ins>variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;</ins> emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class... Args&gt; <del>void</del><ins>T&amp;</ins> emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <tt><ins>return</ins> emplace&lt;<i>I</i>&gt;(std::forward&lt;Args&gt;(args)...)<ins>;</ins></tt> 
where <tt><i>I</i></tt> is the zero-based index of <tt>T</tt> in <tt>Types...</tt>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class U, class... Args&gt;
  <del>void</del><ins>T&amp;</ins> emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to <tt><ins>return</ins> emplace&lt;<i>I</i>&gt;(il, std::forward&lt;Args&gt;(args)...)<ins>;</ins></tt> 
where <tt><i>I</i></tt> is the zero-based index of <tt>T</tt> in <tt>Types...</tt>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;size_t I, class... Args&gt; <del>void</del><ins>variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;</ins> emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Postconditions:</i> <tt>index()</tt> is <tt>I</tt>.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-8- <i>Throws:</i> Any exception thrown during the initialization of the contained value.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;size_t I, class U, class... Args&gt;
  <del>void</del><ins>variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp;</ins> emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-12- <i>Postconditions:</i> <tt>index()</tt> is <tt>I</tt>.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-13- <i>Throws:</i> Any exception thrown during the initialization of the contained value.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify the following signatures in 20.8.3 <a href="https://timsong-cpp.github.io/cppwp/any.class">[any.class]</a>, class <tt>any</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]
<i>// 20.8.3.3 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a>, modifiers</i>
template &lt;class ValueType, class... Args&gt;
  <del>void</del><ins>decay_t&lt;ValueType&gt;&amp;</ins> emplace(Args&amp;&amp; ...);
template &lt;class ValueType, class U, class... Args&gt;
  <del>void</del><ins>decay_t&lt;ValueType&gt;&amp;</ins> emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.8.3.3 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class ValueType, class... Args&gt;
  <del>void</del><ins>decay_t&lt;ValueType&gt;&amp;</ins> emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Postconditions:</i> <tt>*this</tt> contains a value.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-5- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class ValueType, class U, class... Args&gt;
  <del>void</del><ins>decay_t&lt;ValueType&gt;&amp;</ins> emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Postconditions:</i> <tt>*this</tt> contains a value.
<p/>
<ins>-?- <i>Returns:</i> A reference to the new contained value.</ins>
<p/>
-11- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>


<hr>
<h3><a name="2900"></a>2900. The copy and move constructors of <tt>optional</tt> are not <tt>constexpr</tt></h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Change the synopsis of class template <tt>optional</tt> in 20.6.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> as follows:</p>

<blockquote><pre>
[&hellip;]
// 20.6.3.1, constructors
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
<ins>constexpr</ins> optional(const optional&amp;);
<ins>constexpr</ins> optional(optional&amp;&amp;) noexcept(<i>see below</i>);
[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 20.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:</p>
<blockquote><pre>
<ins>constexpr</ins> optional(const optional&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Remarks:</i> This constructor shall be defined as deleted unless <tt>is_copy_constructible_v&lt;T&gt;</tt> 
is <tt>true</tt>. <ins>If <tt>is_trivially_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>, this constructor 
shall be a <tt>constexpr</tt> constructor.</ins>
</p>
</blockquote>
<pre>
<ins>constexpr</ins> optional(optional&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to <tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>.
This constructor shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is
<tt>true</tt>. <ins>If <tt>is_trivially_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>, this constructor shall 
be a <tt>constexpr</tt> constructor.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2842"></a>2842. <tt>in_place_t</tt> check for <tt>optional::optional(U&amp;&amp;)</tt> should decay <tt>U</tt></h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 20.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class U = T&gt;
  <i>EXPLICIT</i> constexpr optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-22- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor. This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same_v&lt;<ins>decay_t&lt;</ins>U<ins>&gt;</ins>, 
in_place_t&gt;</tt> is <tt>false</tt>, and <tt>is_same_v&lt;optional&lt;T&gt;, decay_t&lt;U&gt;&gt;</tt> is <tt>false</tt>. 
The constructor is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2806"></a>2806. Base class of <tt>bad_optional_access</tt></h3>

<p>Changes are relative to N4604.</p>
<p>In the class synopsis in 20.6.5 [optional.bad_optional_access] change:</p>
<blockquote>
<pre>
    class bad_optional_access : public <ins>exception</ins><del>logic_error</del> {
</pre>
</blockquote>


<hr>
<h3><a name="2934"></a>2934. <tt>optional&lt;const T&gt;</tt> doesn't compare with <tt>T</tt></h3>

<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 20.6.2 <a href="https://timsong-cpp.github.io/cppwp/optional.syn">[optional.syn]</a>, header <tt>&lt;optional&gt;</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
[&hellip;]

<i>// 20.6.6 <a href="https://timsong-cpp.github.io/cppwp/optional.relops">[optional.relops]</a>, relational operators</i>
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator==(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator!=(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt;
constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp;);

[&hellip;]

<i>// 20.6.8 <a href="https://timsong-cpp.github.io/cppwp/optional.comp_with_t">[optional.comp_with_t]</a>, comparison with T</i>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const <del>T</del><ins>U</ins>&amp;);
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const <del>T</del><ins>U</ins>&amp;, const optional&lt;T&gt;&amp;);
</pre>
</blockquote>
</li>

<li><p>Modify 20.6.6 <a href="https://timsong-cpp.github.io/cppwp/optional.relops">[optional.relops]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const optional&lt;<del>T</del><ins>U</ins>&gt;&amp; y);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.6.8 <a href="https://timsong-cpp.github.io/cppwp/optional.comp_with_t">[optional.comp_with_t]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x == v</tt> shall be well-formed and its result shall be convertible to <tt>bool</tt>.
 [<i>Note:</i> <tt>T</tt> need not be <tt>EqualityComparable</tt>. &mdash; <i>end note</i>]</ins>
<p/>
-1- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x == v : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator==(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v == *x</tt> shall be well-formed and its result shall be convertible to <tt>bool</tt>.</ins>
<p/>
-2- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v == *x : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x != v</tt> shall be well-formed and its result shall be convertible to <tt>bool</tt>.</ins>
<p/>
-3- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x != v : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator!=(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v != *x</tt> shall be well-formed and its result shall be convertible to <tt>bool</tt>.</ins>
<p/>
-4- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v != *x : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x &lt; v</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-5- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x &lt; v : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v &lt; *x</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-6- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v &lt; *x : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x &lt;= v</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-7- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x &lt;= v : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&lt;=(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v &lt;= *x</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-8- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v &lt;= *x : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x &gt; v</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-9- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x &gt; v : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v &gt; *x</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-10- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v &gt; *x : true;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const <del>T</del><ins>U</ins>&amp; v);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>*x &gt;= v</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-11- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? *x &gt;= v : false;</tt>
</p>
</blockquote>
<pre>
template &lt;class T<ins>, class U</ins>&gt; constexpr bool operator&gt;=(const <del>T</del><ins>U</ins>&amp; v, const optional&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> The expression <tt>v &gt;= *x</tt> shall be well-formed and its result
 shall be convertible to <tt>bool</tt>.</ins>
<p/>
-12- <i>Effects:</i> Equivalent to: <tt>return bool(x) ? v &gt;= *x : true;</tt>
</p>
</blockquote>
<pre>

</pre>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2903"></a>2903. The form of initialization for the emplace-constructors is not specified</h3>

<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>

<li><p>Modify 20.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> paragraph 19 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value <ins>as if direct-non-list-initializing an object</ins> of type 
<tt>T</tt> with the arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> paragraph 23 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>T</tt> with the arguments <tt>il, std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> paragraph 27 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>TI</tt> with the arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> paragraph 31 as indicated:</p>
<blockquote>
<i>Effects:</i> Initializes the contained value as if <ins>direct-non-list-initializing</ins><del>constructing</del> 
an object of type <tt>TI</tt> with the arguments <tt>il, std::forward(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a> paragraph 6 as indicated:</p>
<blockquote>
<i>Effects:</i> Destroys the currently contained value if <tt>valueless_by_exception()</tt> is false. 
Then <del>direct-</del>initializes the contained value as if 
<ins>direct-non-list-initializing</ins><del>constructing</del> a value of type <tt>TI</tt> with the arguments <tt>std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

<li><p>Modify 20.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a> paragraph 11 as indicated:</p>
<blockquote>
<i>Effects:</i> Destroys the currently contained value if <tt>valueless_by_exception()</tt> is false. 
Then <del>direct-</del>initializes the contained value as if 
<ins>direct-non-list-initializing</ins><del>constructing</del> a value of type <tt>TI</tt> with the arguments <tt>il, std::forward&lt;Args&gt;(args)...</tt>.
</blockquote>
</li>

</ol>


<hr>
<h3><a name="2904"></a>2904. Make <tt>variant</tt> move-assignment more exception safe</h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>
<ol>
<li><p>Modify 20.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/variant.assign">[variant.assign]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Presentation of para 9 immediately below has been split into individual bullets.]
</p>
</blockquote>

<blockquote>
<pre>
variant&amp; operator=(const variant&amp; rhs);
</pre>
<blockquote>
<p>
<ins><ins>Let <tt><i>j</i></tt> be <tt>rhs.index()</tt>.</ins></ins>
<p/>
-1- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If neither <tt>*this</tt> nor <tt>rhs</tt> holds a value, there is no effect. Otherwise,</p></li>
<li><p>(1.2) &mdash; if <tt>*this</tt> holds a value but <tt>rhs</tt> does not, destroys the value contained in 
<tt>*this</tt> and sets <tt>*this</tt> to not hold a value. Otherwise,</p></li>
<li><p>(1.3) &mdash; if <tt>index() == <ins><i>j</i></ins><del>rhs.index()</del></tt>, assigns the value contained in <tt>rhs</tt> to the value contained in 
<tt>*this</tt>. Otherwise,</p></li>
<li><p><ins>(1.?) &mdash; if <tt>is_nothrow_copy_constructible_v&lt;T<sub><i>j</i></sub>&gt; || 
!is_nothrow_move_constructible_v&lt;T<sub><i>j</i></sub>&gt;</tt> is <tt>true</tt>, equivalent to 
<tt>emplace&lt;<i>j</i>&gt;(get&lt;<i>j</i>&gt;(rhs))</tt>. Otherwise,</ins></p></li>
<li><p>(1.4) &mdash; <ins>equivalent to <tt>operator=(variant(rhs))</tt></ins><del>copies the value contained in <tt>rhs</tt> to 
a temporary, then destroys any value contained in 
<tt>*this</tt>. Sets <tt>*this</tt> to hold the same alternative index as <tt>rhs</tt> and initializes the value contained in 
<tt>*this</tt> as if direct-non-list-initializing an object of type <tt>T<sub><i>j</i></sub></tt> with 
<tt>std::forward&lt;T<sub><i>j</i></sub>&gt;(TMP)</tt>, with <tt>TMP</tt> being the temporary and <tt>j</tt> being 
<tt>rhs.index()</tt></del>.</p></li>
</ol>
<p>
-2- <i>Returns:</i> <tt>*this.</tt>
<p/>
-3- <i>Postconditions:</i> <tt>index() == rhs.index()</tt>.
<p/>
-4- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_copy_constructible_v&lt;T<sub><i>i</i></sub>&gt; <del>&amp;&amp; is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt;</del> 
&amp;&amp; is_copy_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.
</p>
<ol style="list-style-type: none">
<li><p><del>(4.1) &mdash; If an exception is thrown during the call [&hellip;]</del></p></li>
<li><p><del>(4.2) &mdash; If an exception is thrown during the call [&hellip;]</del></p></li>
<li><p><del>(4.3) &mdash; If an exception is thrown during the call [&hellip;]</del></p></li>
</ol>

</blockquote>
<pre>
variant&amp; operator=(variant&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<ins><ins>Let <tt><i>j</i></tt> be <tt>rhs.index()</tt>.</ins></ins>
<p/>
-5- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; If neither <tt>*this</tt> nor <tt>rhs</tt> holds a value, there is no effect. Otherwise,</p></li>
<li><p>(5.2) &mdash; if <tt>*this</tt> holds a value but <tt>rhs</tt> does not, destroys the value contained in 
<tt>*this</tt> and sets <tt>*this</tt> to not hold a value. Otherwise,</p></li>
<li><p>(5.3) &mdash; if <tt>index() == <ins><i>j</i></ins><del>rhs.index()</del></tt>, assigns <tt>get&lt;<i>j</i>&gt;(std::move(rhs))</tt> 
to the value contained in <tt>*this</tt><del>, with <tt><i>j</i></tt> being <tt>index()</tt></del>. Otherwise,</p></li>
<li><p>(5.4) &mdash; <ins>equivalent to <tt>emplace&lt;<i>j</i>&gt;(get&lt;<i>j</i>&gt;(std::move(rhs)))</tt></ins><del>destroys any value contained in 
<tt>*this</tt>. Sets <tt>*this</tt> to hold the same alternative index as <tt>rhs</tt> and initializes the value contained 
in <tt>*this</tt> as if direct-non-list-initializing an object of type <tt>T<sub><i>j</i></sub></tt> with
<tt>get&lt;<i>j</i>&gt;(std::move(rhs))</tt> with <tt><i>j</i></tt> being <tt>rhs.index()</tt></del>.</p></li>
</ol>
<p>
[&hellip;]
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template &lt;class T&gt; variant&amp; operator=(T&amp;&amp; t) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-8- [&hellip;]
<p/>
-9- <i>Effects:</i> 
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If *this holds a <tt>T<sub><i>j</i></sub></tt>, assigns <tt>std::forward&lt;T&gt;(t)</tt> to the value 
contained in <tt>*this</tt>. Otherwise,</p></li>
<li><p><ins>(9.?) &mdash; if <tt>is_nothrow_constructible_v&lt;T<sub><i>j</i></sub>, T&gt; || 
!is_nothrow_move_constructible_v&lt;T<sub><i>j</i></sub>&gt;</tt> is <tt>true</tt>, equivalent to 
<tt>emplace&lt;<i>j</i>&gt;(std::forward&lt;T&gt;(t))</tt>. Otherwise,</ins></p></li>
<li><p>(9.3) &mdash; <ins>equivalent to <tt>operator=(variant(std::forward&lt;T&gt;(t)))</tt></ins><del>destroys any value contained in <tt>*this</tt>, sets <tt>*this</tt> to hold the alternative type 
<tt>T<sub><i>j</i></sub></tt> as selected by the imaginary function overload resolution described above, and direct-initializes 
the contained value as if direct-non-list-initializing it with <tt>std::forward&lt;T&gt;(t)</tt></del>.</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2868"></a>2868. Missing specification of <tt>bad_any_cast::what()</tt></h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Insert the following series of paragraphs to 20.8.2 <a href="https://timsong-cpp.github.io/cppwp/any.bad_any_cast">[any.bad_any_cast]</a> as indicated:</p>

<blockquote><pre>
<ins>const char* what() const noexcept override;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns:</i> An implementation-defined NTBS.</ins> 
<p/>
<ins>-?- <i>Remarks:</i> The message may be a null-terminated multibyte string (17.4.2.1.5.2 <a href="https://timsong-cpp.github.io/cppwp/multibyte.strings">[multibyte.strings]</a>), 
suitable for conversion and display as a <tt>wstring</tt> (21.3 <a href="https://timsong-cpp.github.io/cppwp/string.classes">[string.classes]</a>, 
22.4.1.4 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a>).</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>


<hr>
<h3><a name="2789"></a>2789. Equivalence of contained objects</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change [any.cons] p2:</p>
<blockquote>
<pre>
any(const any&amp; other);
</pre>
<blockquote>
<p>
<i>Effects:</i> <del>Constructs an object of type <tt>any</tt> with an equivalent
state as <tt>other</tt>.</del><ins>If <tt>other.has_value()</tt> is <tt>false</tt>, 
constructs an object that has no value. Otherwise, equivalent to 
<tt>any(in_place&lt;T&gt;, any_cast&lt;const T&amp;&gt;(other))</tt> where <tt>T</tt> 
is the type of the contained object.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change [any.cons] p4:</p>

<blockquote>
<pre>
any(any&amp;&amp; other);
</pre>
<blockquote>
<p>
<i>Effects:</i> <del>Constructs an object of type <tt>any</tt> with a state equivalent
to the original state of <tt>other</tt>.</del><ins>If <tt>other.has_value()</tt> is <tt>false</tt>, 
constructs an object that has no value. Otherwise, constructs an object of type <tt>any</tt> that contains
either the contained object of <tt>other</tt>, or contains an object of the same type constructed from 
the contained object of other considering that contained object as an rvalue.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2768"></a>2768. <tt>any_cast</tt> and move semantics</h3>

<p>
Resolved by the wording provided by LWG <a href="2769">2769</a>.
</p>


<hr>
<h3><a name="2769"></a>2769. Redundant <tt>const</tt> in the return type of <tt>any_cast(const any&amp;)</tt></h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.4 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
</blockquote>
<p>
<ins>-?- Let <tt>U</tt> be the type <tt>remove_cv_t&lt;remove_reference_t&lt;ValueType&gt;&gt;</tt>.</ins>
</p>
<p>
-4- <i>Requires:</i> <del><tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or
<tt>is_copy_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt>.</del><ins>For the first
overload, <tt>is_constructible_v&lt;ValueType, const U&amp;&gt;</tt>
is <tt>true</tt>. For the second overload, <tt>is_constructible_v&lt;ValueType,
U&amp;&gt;</tt> is <tt>true</tt>. For the third overload,
<tt>is_constructible_v&lt;ValueType, U&gt;</tt> is
<tt>true</tt>.</ins> Otherwise the program is ill-formed.
<p/>
-5- <i>Returns:</i> <del>For the first form,
<tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. For the second and third
forms, <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>.</del><ins>For the first and second
overload, <tt>static_cast&lt;ValueType&gt;(*any_cast&lt;U&gt;(&amp;operand))</tt>. For the third overload, <tt>static_cast&lt;ValueType&gt;(std::move(*any_cast&lt;U&gt;(&amp;operand)))</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2801"></a>2801. Default-constructibility of <tt>unique_ptr</tt></h3>


<ol>
<li>
<p>
Modify the synopsis in  20.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> as follows:
</p>
<blockquote>
<pre>
[&hellip;]
constexpr unique_ptr(nullptr_t) noexcept<ins>;</ins>
    <del>: unique_ptr() { }</del>
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>
Modify 20.11.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a> as follows:
</p>
<blockquote>

<pre>
constexpr unique_ptr() noexcept;
<ins>constexpr unique_ptr(nullptr_t) noexcept;</ins>
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>D</tt> shall satisfy the requirements of <tt>DefaultConstructible</tt> (Table 22), and that construction
shall not throw an exception.
<p/>
-2- <i>Effects:</i> Constructs a <tt>unique_ptr</tt> object that owns nothing, value-initializing the stored pointer and
the stored deleter.
<p/>
-3- <i>Postconditions:</i> <tt>get() == nullptr</tt>. <tt>get_deleter()</tt> returns a reference to the stored deleter.
<p/>
-4- <i>Remarks:</i> <del>If this constructor is instantiated with a
pointer type or reference type for the template argument <tt>D</tt>,
the program is ill-formed.</del> <ins>If <tt>is_pointer_v&lt;deleter_type&gt;</tt> is <tt>true</tt> or
<tt>is_default_constructible_v&lt;deleter_type&gt;</tt> is
<tt>false</tt>, this constructor shall not participate in overload
resolution.</ins>
</p>
</blockquote>

<pre>
explicit unique_ptr(pointer p) noexcept;
</pre>
<blockquote>
<p>[&hellip;]</p>
<p>
-8- <i>Remarks:</i> <del>If this constructor is instantiated with a
pointer type or reference type for the template argument <tt>D</tt>,
the program is ill-formed.</del> <ins>If <tt>is_pointer_v&lt;deleter_type&gt;</tt> is <tt>true</tt> or
<tt>is_default_constructible_v&lt;deleter_type&gt;</tt> is
<tt>false</tt>, this constructor shall not participate in overload
resolution.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify the synopsis in  20.11.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.runtime">[unique.ptr.runtime]</a> as follows:
</p>
<blockquote>
<pre>
[&hellip;]
constexpr unique_ptr(nullptr_t) noexcept<ins>;</ins><del> : unique_ptr() { }</del>
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>
Modify 20.11.1.3.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.runtime.ctor">[unique.ptr.runtime.ctor]</a> as follows:
</p>
<blockquote>

<pre>
template &lt;class U&gt; explicit unique_ptr(U p) noexcept;
</pre>
<blockquote>
<p><ins>
This constructor behaves the same as the constructor that takes a
pointer parameter in the primary template except that the following
constraints are added for it to participate in overload resolution
</ins></p>
<ul>
<li><p><ins>
<tt>U</tt> is the same type as <tt>pointer</tt>, or
</ins></p></li>
<li><p><ins>
<tt>pointer</tt> is the same type as <tt>element_type*</tt>,
<tt>U</tt> is a pointer type <tt>V*</tt>, and <tt>V(*)[]</tt> is
convertible to <tt>element_type(*)[]</tt>.
</ins></p></li>
</ul>
</blockquote>
<pre>
template &lt;class U&gt; unique_ptr(U p, <i>see below</i> d) noexcept;
template &lt;class U&gt; unique_ptr(U p, <i>see below</i> d) noexcept;
</pre>
<blockquote>
<p>
1 These constructors behave the same as the constructors that take a
pointer parameter in the primary template except that they shall not
participate in overload resolution unless either
</p>
</blockquote>
</blockquote>
</li>

</ol>



<hr>
<h3><a name="2905"></a>2905. <tt>is_constructible_v&lt;unique_ptr&lt;P, D&gt;, P, D const &amp;&gt;</tt> should be false when 
<tt>D</tt> is not copy constructible</h3>


<p>Modify [unique.ptr.single.ctor] paragraphs 9-11 as shown:</p>

<blockquote>
<pre>
unique_ptr(pointer p, <em>see belo</em>w d1) noexcept;
unique_ptr(pointer p, <em>see below</em> d2) noexcept;
</pre>

<p>-9- The signature of these constructors depends upon whether <code>D</code> is a reference type. If <code>D</code> is a non-reference
type <code>A</code>, then the signatures are</p>

<pre><code>  unique_ptr(pointer p, const A&amp; d) <ins>noexcept</ins>;
  unique_ptr(pointer p, A&amp;&amp; d) <ins>noexcept</ins>;
</code></pre>

<p>-10- If <code>D</code> is an lvalue reference type <code>A&amp;</code>, then the signatures are:</p>

<pre><code>  unique_ptr(pointer p, A&amp; d) <ins>noexcept</ins>;
  unique_ptr(pointer p, A&amp;&amp; d) <ins>= delete</ins>;
</code></pre>

<p>-11- If <code>D</code> is an lvalue reference type <code>const A&amp;</code>, then the signatures are:</p>

<pre><code>  unique_ptr(pointer p, const A&amp; d) <ins>noexcept</ins>;
  unique_ptr(pointer p, const A&amp;&amp; d) <ins>= delete</ins>;
</code></pre>
</blockquote>

<p>Remove paragraph 12 entirely:</p>

<blockquote>
<p> <del>-12- <em>Requires:</em></del> </p>
<ul>
<li><del>If <code>D</code> is not an lvalue reference type then</del>
<ul>
<li>
<del>
If <code>d</code> is an lvalue or const rvalue then the first constructor of this pair will be selected. <code>D</code> shall satisfy the requirements of <code>CopyConstructible</code> (Table 24), and the copy constructor of <code>D</code> shall not throw an exception. This <code>unique_ptr</code> will hold a copy of <code>d</code>.
</del>
</li>
<li>
<del>
Otherwise, <code>d</code> is a non-const rvalue and the second constructor of this pair will be selected. <code>D</code> shall satisfy the requirements of <code>MoveConstructible</code> (Table 23), and the move constructor of <code>D</code> shall not throw an exception. This <code>unique_ptr</code> will hold a value move constructed from <code>d</code>.
</del>
</li>
</ul>
</li>
<li>
<del>
Otherwise <code>D</code> is an lvalue reference type. <code>d</code> shall be reference-compatible with one of the constructors.
If <code>d</code> is an rvalue, it will bind to the second constructor of this pair and the program is ill-formed.
[<em>Note:</em> The diagnostic could be implemented using a static_assert which assures that <code>D</code> is not
a reference type. <em>— end note</em>] Else <code>d</code> is an lvalue and will bind to the first constructor of this
pair. The type which <code>D</code> references need not be <code>CopyConstructible</code> nor <code>MoveConstructible</code>. This
<code>unique_ptr</code> will hold a <code>D</code> which refers to the lvalue <code>d</code>. [<em>Note:</em> <code>D</code> may not be an rvalue reference
type. <em>— end note</em>]
</del>
</li>
</ul>
</blockquote>

<p>Modify paragraph 13 as shown:</p>

<blockquote>
<p>-13- <em>Effects:</em>
Constructs a <code>unique_ptr</code> object which owns <code>p</code>, initializing the stored pointer with <code>p</code> and
initializing the deleter <del>as described above</del> <ins>from <code>std::forward&lt;decltype(d)&gt;(d)</code></ins>.</p>
</blockquote>

<p>Add a new paragraph after paragraph 14 (Postconditions):</p>

<blockquote>
<p><ins>-?- <em>Remarks:</em> These constructors shall not participate in overload resolution unless <code>is_constructible_v&lt;D, decltype(d)&gt;</code> is <code>true</code>.</ins></p>
</blockquote>



<hr>
<h3><a name="2873"></a>2873. Add <tt>noexcept</tt> to several <tt>shared_ptr</tt> related functions</h3>

<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>

<li><p>Modify 20.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> as indicated:</p>
<blockquote>
<pre>
  template&lt;class U&gt; bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const<ins> noexcept</ins>;
  template&lt;class U&gt; bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const<ins> noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Modify 20.11.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> as indicated: </p>
<blockquote>
<pre>
template&lt;class U&gt; bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const<ins> noexcept</ins>;
template&lt;class U&gt; bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const<ins> noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Modify 20.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.ownerless">[util.smartptr.ownerless]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt;&gt; {
   bool operator()(const shared_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
   bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
   bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
};

template&lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt;&gt; {
   bool operator()(const weak_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
   bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
   bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const<ins> noexcept</ins>;
};

template&lt;&gt; struct owner_less&lt;void&gt; {
   template&lt;class T, class U&gt;
      bool operator()(const shared_ptr&lt;T&gt;&amp;, const shared_ptr&lt;U&gt;&amp;) const<ins> noexcept</ins>;
   template&lt;class T, class U&gt;
      bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;U&gt;&amp;) const<ins> noexcept</ins>;
   template&lt;class T, class U&gt;
      bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;U&gt;&amp;) const<ins> noexcept</ins>;
   template&lt;class T, class U&gt;
      bool operator()(const weak_ptr&lt;T&gt;&amp;, const weak_ptr&lt;U&gt;&amp;) const<ins> noexcept</ins>;
   using is_transparent = <i>unspecified</i>;
};
</pre>
</blockquote>
</li>

</ol>


<hr>
<h3><a name="2876"></a>2876. <tt>shared_ptr::shared_ptr(const weak_ptr&lt;Y&gt;&amp;)</tt> constructor should be constrained</h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class Y&gt; explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>Y*</tt> shall be compatible with <tt>T*</tt>.</del>
<p/>
[&hellip;]
<p/>
-25- <i>Throws:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>Y*</tt> is compatible with <tt>T*</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2802"></a>2802. <tt>shared_ptr</tt> constructor requirements for a deleter</h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> <tt>D</tt> shall be <tt><del>Copy</del><ins>Move</ins>Constructible</tt> and <del>such</del> 
construction <ins>of <tt>d</tt> and a deleter of type <tt>D</tt> initialized with <tt>std::move(d)</tt></ins> shall 
not throw exceptions. <del>The destructor of <tt>D</tt> shall not throw exceptions.</del> The expression <tt>d(p)</tt> 
shall be well formed, shall have well<del> </del><ins>-</ins>defined behavior, and shall not throw exceptions. <tt>A</tt> 
shall be an allocator (17.5.3.5). <del>The copy constructor and destructor of <tt>A</tt> shall not throw exceptions.</del> 
When <tt>T</tt> is [&hellip;].
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2875"></a>2875. <tt>shared_ptr::shared_ptr(Y*, D, [&hellip;])</tt> constructors should be constrained</h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>
as modified by the proposed resolution of LWG <a href="2802">2802</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> <del><tt>D</tt> shall be <tt>MoveConstructible</tt> and c</del><ins>C</ins>onstruction of 
<tt>d</tt> and a deleter of type 
<tt>D</tt> initialized with <tt>std::move(d)</tt> shall not throw exceptions. The expression <tt>d(p)</tt> 
<del>shall be well formed,</del> shall have well-defined behavior, and shall not throw exceptions. <tt>A</tt> 
shall be an allocator (17.5.3.5). <del>When <tt>T</tt> is <tt>U[N]</tt>, <tt>Y(*)[N]</tt> shall be convertible to <tt>T*</tt>;
when <tt>T</tt> is <tt>U[]</tt>, <tt>Y(*)[]</tt> shall be convertible to <tt>T*</tt>; otherwise, <tt>Y*</tt> shall 
be convertible to <tt>T*</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Add a <i>Remarks</i> paragraph after p11:</p>

<blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template &lt;class D&gt; shared_ptr(nullptr_t p, D d);
template &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-8- <i>Requires:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-11- <i>Throws:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> When <tt>T</tt> is an array type, this constructor shall not
participate in overload resolution unless <tt>is_move_constructible_v&lt;D&gt;</tt>
is <tt>true</tt>, the expression <tt>d(p)</tt> is well-formed, and either <tt>T</tt> 
is <tt>U[N]</tt> and <tt>Y(*)[N]</tt> is convertible to <tt>T*</tt>, or <tt>T</tt> 
is <tt>U[]</tt> and <tt>Y(*)[]</tt> is convertible to <tt>T*</tt>. When <tt>T</tt> is not an array type, this
constructor shall not participate in overload resolution unless
<tt>is_move_constructible_v&lt;D&gt;</tt> is <tt>true</tt>, the
expression <tt>d(p)</tt> is well-formed, and <tt>Y*</tt> is convertible to <tt>T*</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2874"></a>2874. Constructor <tt>shared_ptr::shared_ptr(Y*)</tt> should be constrained</h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Modify 20.11.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note:</i> This also adds a hyphen to "well defined"]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre>
<blockquote>
<p>
-4- <i>Requires:</i> <tt>Y</tt> shall be a complete type. The expression <tt>delete[] p</tt>, when <tt>T</tt> 
is an array type, or <tt>delete p</tt>, when <tt>T</tt> is not an array type, <del>shall be well formed,</del> shall 
have well<del> </del><ins>-</ins>defined behavior, and shall not throw exceptions. <del>When <tt>T</tt> is <tt>U[N]</tt>, 
<tt>Y(*)[N]</tt> shall be convertible to <tt>T*</tt>; when <tt>T</tt> is <tt>U[]</tt>, <tt>Y(*)[]</tt> shall be convertible to 
<tt>T*</tt>; otherwise, <tt>Y*</tt> shall be convertible to <tt>T*</tt>.</del>
<p/>
-5- <i>Effects:</i> [&hellip;]
<p/>
-6- <i>Postconditions:</i> [&hellip;]
<p/>
-7- <i>Throws:</i> [&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> When <tt>T</tt> is an array type, this constructor shall not
participate in overload resolution unless the expression <tt>delete[] p</tt> is
well-formed and either <tt>T</tt> is <tt>U[N]</tt> and <tt>Y(*)[N]</tt> is convertible to <tt>T*</tt>, or
<tt>T</tt> is <tt>U[]</tt> and <tt>Y(*)[]</tt> is convertible to <tt>T*</tt>. When <tt>T</tt> is not an array type, this
constructor shall not participate in overload resolution unless the
expression <tt>delete p</tt> is well-formed and <tt>Y*</tt> is convertible to <tt>T*</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2908"></a>2908. The less-than operator for shared pointers could do more</h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Change 20.11.2.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cmp">[util.smartptr.shared.cmp]</a> as depicted:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt;
bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
</pre>
<blockquote>
<p>
-2- <i>Returns:</i> <tt>less&lt;<del>V</del>&gt;()(a.get(), b.get())</tt><del>, where <tt>V</tt> is the composite pointer type (Clause 5) of 
<tt>shared_ptr&lt;T&gt;::element_type*</tt> and <tt>shared_ptr&lt;U&gt;::element_type*</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2782"></a>2782. <tt>scoped_allocator_adaptor</tt> constructors must be constrained</h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Modify 20.13.3 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.cnstr">[allocator.adaptor.cnstr]</a> by converting "Requires" elements to "Remarks: shall not participate ..." constraints as shown:</p>

<blockquote>
<pre>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(OuterA2&amp;&amp; outerAlloc,
                           const InnerAllocs&amp;... innerAllocs) noexcept;
</pre>
<blockquote>
<p>
<del>-2- <i>Requires:</i> <tt>OuterAlloc</tt> shall be constructible from <tt>OuterA2</tt>.</del>
<p/>
-3- <i>Effects:</i> Initializes the <tt>OuterAlloc</tt> base class with <tt>std::forward&lt;OuterA2&gt;(outerAlloc)</tt> and 
inner with <tt>innerAllocs...</tt> (hence recursively initializing each allocator within the adaptor with the
corresponding allocator from the argument list).
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;OuterAlloc, OuterA2&gt;</tt> is <tt>true</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(const scoped_allocator_adaptor&lt;OuterA2,
                           InnerAllocs...&gt;&amp; other) noexcept;
</pre>
<blockquote>
<p>
<del>-6- <i>Requires:</i> <tt>OuterAlloc</tt> shall be constructible from <tt>OuterA2</tt>.</del>
<p/>
-7- <i>Effects:</i> Initializes each allocator within the adaptor with the corresponding allocator from <tt>other</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;OuterAlloc, const OuterA2&amp;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class OuterA2&gt;
  scoped_allocator_adaptor(scoped_allocator_adaptor&lt;OuterA2,
                           InnerAllocs...&gt;&amp;&amp; other) noexcept;
</pre>
<blockquote>
<p>
<del>-8- <i>Requires:</i> <tt>OuterAlloc</tt> shall be constructible from <tt>OuterA2</tt>.</del>
<p/>
-9- <i>Effects:</i> Initializes each allocator within the adaptor with the corresponding allocator rvalue from <tt>other</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;OuterAlloc, OuterA2&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2807"></a>2807. <tt>std::invoke</tt> should use <tt>std::is_nothrow_callable</tt></h3>

<p>
This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li><p>Change 20.14.1 <a href="https://timsong-cpp.github.io/cppwp/functional.syn">[functional.syn]</a>, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:</p>

<blockquote><pre>
<i>// 20.14.4, invoke</i>
template &lt;class F, class... Args&gt;
  <ins>invoke_result_t&lt;F, Args...&gt;</ins><del>result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt;</del> invoke(F&amp;&amp; f, Args&amp;&amp;... args) <ins>noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;)</ins>;
</pre></blockquote>
</li>

<li><p>Change 20.14.4 <a href="https://timsong-cpp.github.io/cppwp/func.invoke">[func.invoke]</a> as indicated:</p>

<blockquote><pre>
template &lt;class F, class... Args&gt;
  <ins>invoke_result_t&lt;F, Args...&gt;</ins><del>result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt;</del> invoke(F&amp;&amp; f, Args&amp;&amp;... args) <ins>noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;)</ins>;</pre></blockquote>
</li>

</ol>


<hr>
<h3><a name="2781"></a>2781. Contradictory requirements for <tt>std::function</tt> and <tt>std::reference_wrapper</tt></h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Modify 20.14.13.2.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> p4 and p6 the same way, as shown:</p>

<blockquote>
<pre>
function(const function&amp; f);
</pre>
<blockquote>
<p>
-3- <i>Postconditions:</i> <tt>!*this</tt> if <tt>!f</tt>; otherwise, <tt>*this</tt> targets a copy of 
<tt>f.target()</tt>.
<p/>
-4- <i>Throws:</i> shall not throw exceptions if <tt>f</tt>'s target is a <del>callable object passed 
via</del><ins>specialization of</ins> <tt>reference_wrapper</tt> or a function pointer. Otherwise, may throw 
<tt>bad_alloc</tt> or any exception thrown by the copy constructor of the stored callable object. 
[<i>Note:</i> Implementations are encouraged to avoid the use of dynamically allocated memory for small 
callable objects, for example, where <tt>f</tt>'s target is an object holding only a pointer or reference to 
an object and a member function pointer. &mdash; <i>end note</i>]
</p>
</blockquote>
<pre>
function(function&amp;&amp; f);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, move constructs the target of 
<tt>f</tt> into the target of <tt>*this</tt>, leaving <tt>f</tt> in a valid state with an unspecified value.
<p/>
-6- <i>Throws:</i> shall not throw exceptions if <tt>f</tt>'s target is a <del>callable object passed 
via</del><ins>specialization of</ins> <tt>reference_wrapper</tt> or a function pointer. Otherwise, may throw 
<tt>bad_alloc</tt> or any exception thrown by the copy or move constructor of the stored callable object. 
[<i>Note:</i> Implementations are encouraged to avoid the use of dynamically allocated memory for small callable 
objects, for example, where <tt>f</tt>'s target is an object holding only a pointer or reference to an object 
and a member function pointer. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2850"></a>2850. <tt>std::function</tt> move constructor does unnecessary work</h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 20.14.13.2.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>/5 as indicated:</p>

<blockquote class="note">
<p>
<i>Drafting note:</i> The "equivalent to ... before the construction" wording is based on the wording for <tt>MoveConstructible</tt>.
</p>
</blockquote>

<blockquote>
<pre>
function(function&amp;&amp; f);
</pre>
<blockquote>
<p>
-5- <i><del>Effects</del><ins>Postconditions</ins>:</i> If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, <del>move 
constructs the target of <tt>f</tt> into the target of <tt>*this</tt>, leaving <tt>f</tt></del><ins>the target of <tt>*this</tt> 
is equivalent to the target of <tt>f</tt> before the construction, and <tt>f</tt> is</ins> in a valid state with an 
unspecified value.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2911"></a>2911. An <tt>is_aggregate</tt> type trait is needed</h3>

<p>This wording is relative to <a href="http://wg21.link/n4640">N4640</a>.</p>
<ol>
<li><p>Modify 20.15.2 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>, <tt>&lt;type_traits&gt;</tt> header synopsis, as indicated:</p>

<blockquote><pre>
<i>// 20.15.4.3, type properties</i>
[&hellip;]
template &lt;class T&gt; struct is_final;
<ins>template &lt;class T&gt; struct is_aggregate;</ins>

[&hellip;]
<i>// 20.15.4.3, type properties</i>
[&hellip;]
template &lt;class T&gt; constexpr bool is_final_v
  = is_final&lt;T&gt;::value;
<ins>template &lt;class T&gt; inline constexpr bool is_aggregate_v
  = is_aggregate&lt;T&gt;::value;</ins>
[&hellip;]
</pre></blockquote>
</li>

<li><p>Add a new row to Table 42 &mdash; "Type property predicates":</p>
<blockquote><pre>
<ins>template &lt;class T&gt; struct is_aggregate;</ins>
</pre>
<p>
<ins><tt>T</tt> is an aggregate type (8.6.1 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.aggr">[dcl.init.aggr]</a>)</ins>
<p/>
<ins><tt>remove_all_extents_t&lt;T&gt;</tt> shall be a complete type or <i>cv</i> <tt>void</tt>.</ins>
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2861"></a>2861. <tt>basic_string</tt> should require that <tt>charT</tt> match <tt>traits::char_type</tt></h3>

<p>Changes are based off of <a href="http://wg21.link/n4618">N4618</a></p>

<ol>
<li><p>Modify [basic.string] as indicated (in the synopsis):</p>
<blockquote><pre>
class basic_string {
public:
// <i>types:</i>
  using traits_type      = traits;
  using value_type       = <ins>charT</ins><del>typename traits::char_type</del>;
  using allocator_type   = Allocator
</pre></blockquote>
</li>

<li>
<p>Change [string.require]/3 as indicated:</p>
<p>-3- In every specialization <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>, the type <tt>allocator_traits&lt;Allocator&gt;::value_type</tt> shall name the same type as <tt>charT</tt>. Every object of type <tt>basic_string&lt;charT, traits, Allocator&gt;</tt> shall use an object of type <tt>Allocator</tt> to allocate and free storage for the contained <tt>charT</tt> objects as needed. The <tt>Allocator</tt> object used shall be obtained as described in 23.2.1. <del>[ Note: </del>In every specialization <tt>basic_string&lt;charT, traits, Allocator&gt;</tt>, <ins>the type <tt>traits</tt> shall satisfy the character traits requirements (21.2), and </ins> the type <tt>traits::char_type</tt> shall <ins>name</ins><del>be</del> the same type as <tt>charT</tt><del>; see 21.2. — end note ]</del>
</p>
</li>
</ol>


<hr>
<h3><a name="2834"></a>2834. Resolution LWG 2223 is missing wording about end iterators</h3>

<p>
This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.
</p>
<ol>
<li><p>Edit 21.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a> as indicated:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Remarks:</i> Reallocation invalidates all the references, pointers, and iterators referring to the elements in
the sequence <ins>as well as the past-the-end iterator</ins>. If no reallocation happens, they remain valid.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 23.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a> as indicated:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-8- <i>Remarks:</i> <tt>shrink_to_fit</tt> invalidates all the references, pointers, and iterators referring to the elements
in the sequence <ins>as well as the past-the-end iterator</ins>. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 23.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> as indicated:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Remarks:</i> Reallocation invalidates all the references, pointers, and iterators referring to the elements in
the sequence <ins>as well as the past-the-end iterator</ins>. If no reallocation happens, they remain valid. 
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2788"></a>2788. <tt>basic_string</tt> range mutators unintentionally require a default constructible allocator</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.2.6.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a>, add the allocator parameter to the range overload temporary:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  basic_string&amp; append(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-19- <i>Requires:</i> <tt>[first, last)</tt> is a valid range.
<p/>
-20- <i>Effects:</i> Equivalent to <tt>append(basic_string(first, last<ins>, get_allocator()</ins>))</tt>.
<p/>
-21- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.2.6.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a>, add the allocator parameter to the range overload temporary:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  basic_string&amp; assign(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-23- <i>Effects:</i> Equivalent to <tt>assign(basic_string(first, last<ins>, get_allocator()</ins>))</tt>.
<p/>
-24- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.2.6.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a>, add the allocator parameter to the range overload temporary:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  iterator insert(const_iterator p, InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-23- <i>Requires:</i> <tt>p</tt> is a valid iterator on <tt>*this</tt>. <tt>[first, last)</tt> is a valid range.
<p/>
-24- <i>Effects:</i> Equivalent to <tt>insert(p - begin(), basic_string(first, last<ins>, get_allocator()</ins>))</tt>.
<p/>
-25- <i>Returns:</i> An iterator which refers to the copy of the first inserted character, or <tt>p</tt> if <tt>first == last</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.2.6.6 <a href="https://timsong-cpp.github.io/cppwp/string.replace">[string.replace]</a>, add the allocator parameter to the range overload temporary:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  basic_string&amp; replace(const_iterator i1, const_iterator i2,
                        InputIterator j1, InputIterator j2);
</pre>
<blockquote>
<p>
-32- <i>Requires:</i> <tt>[begin(), i1)</tt>, <tt>[i1, i2)</tt> and <tt>[j1, j2)</tt> are valid ranges.
<p/>
-33- <i>Effects:</i> Calls <tt>replace(i1 - begin(), i2 - i1, basic_string(j1, j2<ins>, get_allocator()</ins>))</tt>.
<p/>
-34- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2826"></a>2826. <tt>string_view</tt> iterators use old wording</h3>

<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 21.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.iterators">[string.view.iterators]</a> as indicated:</p>
<blockquote>
<pre>
using const_iterator = <i>implementation-defined</i>;
</pre>
<blockquote>
<p>
-1- A <del>constant random-access iterator type such that, for a <tt>const_iterator it</tt>, if <tt>&amp;*(it + N)</tt> is valid,
then <tt>&amp;*(it + N) == (&amp;*it) + N</tt></del><ins>type that meets the requirements of a constant random access 
iterator (24.2.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>) and of a contiguous iterator (24.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)
whose <tt>value_type</tt> is the template parameter <tt>charT</tt></ins>.
<p/>
-2- For a <tt>basic_string_view str</tt>, any operation that invalidates a pointer in the range <tt>[str.data(),
str.data() + str.size())</tt> invalidates pointers, iterators, and references returned from <tt>str</tt>'s methods.
<p/>
-3- All requirements on container iterators (23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>) apply to 
<tt>basic_string_view::const_iterator</tt> as well.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2794"></a>2794. Missing requirements for allocator pointers</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 17.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>/5, edit as follows:</p>
<blockquote>
<p>
-5- An allocator type <tt>X</tt> shall satisfy the requirements of <tt>CopyConstructible</tt> (17.6.3.1). The 
<tt>X::pointer</tt>, <tt>X::const_pointer</tt>, <tt>X::void_pointer</tt>, and <tt>X::const_void_pointer</tt> 
types shall satisfy the requirements of <tt>NullablePointer</tt> (17.6.3.3). No constructor, comparison operator, 
copy operation, move operation, or swap operation on these pointer types shall exit via an exception. 
<tt>X::pointer</tt> and <tt>X::const_pointer</tt> shall also satisfy the requirements for a random access 
iterator (<del>24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a></del><ins>24.2.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a></ins>)
<ins>and of a contiguous iterator (24.2.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins>.
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2824"></a>2824. <tt>list::sort</tt> should say that the order of elements is unspecified if an exception is thrown</h3>

<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Edit 23.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p29 as indicated:</p>

<blockquote>
<pre>
void sort();
template &lt;class Compare&gt; void sort(Compare comp);
</pre>
<blockquote>
<p>
-28- <i>Requires:</i> <tt>operator&lt;</tt> (for the first version) or <tt>comp</tt> (for the second version) shall define 
a strict weak ordering (25.7 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a>).
<p/>
-29- <i>Effects:</i> Sorts the list according to the <tt>operator&lt;</tt> or a <tt>Compare</tt> function object. <ins>If an 
exception is thrown, the order of the elements in <tt>*this</tt> is unspecified.</ins> Does not affect the validity of 
iterators and references.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2853"></a>2853. Possible inconsistency in specification of <tt>erase</tt> in [vector.modifiers]</h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> p5 as indicated:</p>
<blockquote>
<pre>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_back();
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Invalidates iterators and references at or after the point of the erase.
<p/>
-4- <i>Complexity:</i> The destructor of <tt>T</tt> is called the number of times equal to the number of the elements
erased, but the assignment operator of <tt>T</tt> is called the number of times equal to the number of elements
in the vector after the erased elements.
<p/>
-5- <i>Throws:</i> Nothing unless an exception is thrown by the <del>copy constructor, move constructor,</del> assignment
operator<del>,</del> or move assignment operator of <tt>T</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2804"></a>2804. Unconditional <tt>constexpr</tt> default constructor for <tt>istream_iterator</tt></h3>

<p>In the class synopsis in 24.6.1 [istream.iterator] change the default constructor:</p>
<blockquote>
<pre>
<del><i>see below</i></del><ins>constexpr</ins> istream_iterator();
istream_iterator(istream_type&amp; s);
istream_iterator(const istream_iterator&amp; x) = default;
~istream_iterator() = default;
</pre>
</blockquote>

<p>Change [istream.iterator.cons] before paragraph 1:</p>
<blockquote>
<pre>
<del><i>see below</i></del><ins>constexpr</ins> istream_iterator();

-1- Effects: ...
</pre>
</blockquote>


<hr>
<h3><a name="2878"></a>2878. Missing <tt>DefaultConstructible</tt> requirement for <tt>istream_iterator</tt> default constructor</h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 24.6.1 <a href="https://timsong-cpp.github.io/cppwp/istream.iterator">[istream.iterator]</a> as indicated:</p>
<blockquote>
<p>
-1- 
The class template <code>istream_iterator</code> is an input iterator (24.2.3)
that reads (using <code>operator>></code>) successive elements from the input
stream for which it was constructed. After it is constructed, and every time
<code>++</code> is used, the iterator reads and stores a value of
<code>T</code>. If the iterator fails to read and store a value of
<code>T</code> (<code>fail()</code> on the stream returns <code>true</code>),
the iterator becomes equal to the end-of-stream iterator value. The constructor
with no arguments <code>istream_iterator()</code> always constructs an
end-of-stream input iterator object, which is the only legitimate iterator to
be used for the end condition. The result of <code>operator*</code> on an
end-of-stream iterator is not defined. For any other iterator value a
<code>const T&amp;</code> is returned. The result of <code>operator-&gt;</code>
on an end-of-stream iterator is not defined. For any other iterator value a
<code>const T*</code> is returned. The behavior of a program that applies
<code>operator++()</code> to an end-of-stream iterator is undefined. It is
impossible to store things into istream iterators.
<ins>The type <code>T</code> shall meet the <code>DefaultConstructible</code>,
<code>CopyConstructible</code>, and <code>CopyAssignable</code> requirements.</ins>
</p>
</blockquote>
</li>

</ol>


<hr>
<h3><a name="2790"></a>2790. Missing specification of <tt>istreambuf_iterator::operator-&gt;</tt></h3>

<p>This wording is relative to N4606.</p>

<blockquote class="note">
<p>
This reverts LWG <a href="659">659</a>.
</p>
</blockquote>

<ol>
<li><p>Remove the note in paragraph 1 of 24.6.3 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a>:</p>
<blockquote>
<p>
The class template <tt>istreambuf_iterator</tt> defines an input iterator (24.2.3) that reads successive characters
from the streambuf for which it was constructed. <tt>operator*</tt> provides access to the current input character, if
any. <del>[<i>Note:</i> <tt>operator-&gt;</tt> may return a proxy. &mdash; <i>end note</i>]</del> Each time <tt>operator++</tt> 
is evaluated, the iterator advances to the next input character. [&hellip;]
</p>
</blockquote>
</li>

<li><p>Remove the member from the class synopsis in 24.6.3 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a>:</p>

<blockquote>
<pre>
charT operator*() const;
<del>pointer operator-&gt;() const;</del>
istreambuf_iterator&amp; operator++();
proxy operator++(int);
</pre>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2812"></a>2812. Range access is available with <tt>&lt;string_view&gt;</tt></h3>

<p>This wording is relative to N4606.</p>

<ol>
<li>
<p>Edit 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> p1 as indicated:</p>

<blockquote>
<p>
-1- In addition to being available via inclusion of the <tt>&lt;iterator&gt;</tt> header, the function templates 
in 24.7 are available when any of the following headers are included: <tt>&lt;array&gt;</tt>, <tt>&lt;deque&gt;</tt>, 
<tt>&lt;forward_list&gt;</tt>, <tt>&lt;list&gt;</tt>, <tt>&lt;map&gt;</tt>, <tt>&lt;regex&gt;</tt>, 
<tt>&lt;set&gt;</tt>, <tt>&lt;string&gt;</tt><ins>, <tt>&lt;string_view&gt;</tt></ins>, <tt>&lt;unordered_map&gt;</tt>, 
<tt>&lt;unordered_set&gt;</tt>, and <tt>&lt;vector&gt;</tt>.
</p>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2837"></a>2837. <tt>gcd</tt> and <tt>lcm</tt> should support a wider range of input values</h3>

<p>This wording is relative to <a href="http://wg21.link/n4604">N4604</a>.</p>

<ol>
<li><p>Edit 26.8.13 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.gcd">[numeric.ops.gcd]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; gcd(M m, N n);
</pre>
<blockquote>
<p>
-2- <i>Requires:</i> <del><tt>|m|</tt> shall be representable as a value of type <tt>M</tt> and <tt>|n|</tt> shall 
be representable as a value of type <tt>N</tt></del><ins><tt>|m|</tt> and <tt>|n|</tt> shall be representable as 
a value of <tt>common_type_t&lt;M, N&gt;</tt></ins>. [<i>Note:</i> These requirements ensure, for example, that 
<tt>gcd(m, m) = |m|</tt> is representable as a value of type <tt>M</tt>. &mdash; <i>end note</i>] 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 26.8.14 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.lcm">[numeric.ops.lcm]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; lcm(M m, N n);
</pre>
<blockquote>
<p>
-2- <i>Requires:</i> <del><tt>|m|</tt> shall be representable as a value of type <tt>M</tt> and <tt>|n|</tt> shall 
be representable as a value of type <tt>N</tt></del><ins><tt>|m|</tt> and <tt>|n|</tt> shall be representable as 
a value of <tt>common_type_t&lt;M, N&gt;</tt></ins>. The least common multiple of <tt>|m|</tt> and <tt>|n|</tt> shall 
be representable as a value of type <tt>common_type_t&lt;M, N&gt;</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2835"></a>2835. LWG 2536 seems to misspecify <tt>&lt;tgmath.h&gt;</tt></h3>

<p>
This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.
</p>
<ol>
<li><p>Edit D.4 <a href="https://timsong-cpp.github.io/cppwp/depr.c.headers">[depr.c.headers]</a> as indicated:</p>
<blockquote>
<p>
[&hellip;]
<p/>
-2- The use of any of the C++ headers [&hellip;] is deprecated.
<p/>
-3- The header <tt>&lt;complex.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ccomplex&gt;</tt>.
<ins>The header <tt>&lt;tgmath.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ctgmath&gt;</tt>.</ins>
<p/>
-4- Every other C header, [&hellip;]
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2785"></a>2785. <tt>quoted</tt> should work with <tt>basic_string_view</tt></h3>

<p>This wording is relative to N4606.</p>

<p>Add to the end of the &lt;iomanip&gt; synopsis in [iostream.format.overview]</p>
<pre><ins>
template &lt;class charT, class traits&gt;
  T15 quoted(basic_string_view&lt;charT, traits&gt; s,
             charT delim = charT(’"’), charT escape = charT(’\\’));
</ins></pre>

<p>Add to [quoted.manip] at the end of p2:</p>
<pre><ins>
template &lt;class charT, class traits&gt;
  <i>unspecified</i> quoted(basic_string_view&lt;charT, traits&gt; s,
                            charT delim = charT(’"’), charT escape = charT(’\\’));
</ins></pre>

<p>Modify [quoted.manip]/3 as follows:</p>

<p>Returns: An object of unspecified type such that if out is an instance of
<tt>basic_ostream</tt> with member type <tt>char_type</tt> the same as <tt>charT</tt>
and with member type <tt>traits_type</tt> which in the second <ins>and third</ins> form<ins>s</ins>
is the same as <tt>traits</tt>, then the expression <tt>out &lt;&lt; quoted(s, delim, escape)</tt>
behaves as a formatted output function (27.7.3.6.1) of <tt>out</tt>. This forms a character
sequence <tt>seq</tt>, initially consisting of the following elements:</p>


<hr>
<h3><a name="2676"></a>2676. Provide <code>filesystem::path</code> overloads for <i>File-based streams</i></h3>


<p><i><span style="background-color: #E1E9FD">At the end of 27.9.1 File streams 
[</span><span style="background-color: #E1E9FD">fstreams</span><span style="background-color: #E1E9FD">] 
add a paragraph:</span></i></p>

<p>In this subclause, member functions taking arguments of <code>
const std::filesystem::path::value_type*</code> shall only be provided on systems 
where <code>std::filesystem::path::value_type</code> ([fs.class.path]) is not <code>
char</code>. [<i>Note:</i> These functions enable class <code>path</code> 
support for systems with a wide native path character type, such as <code>
wchar_t</code>. &mdash; <i>end note</i>]</p>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.1 Class template 
basic_filebuf [filebuf] as indicated:</span></i></p>

<pre>basic_filebuf&lt;charT,traits&gt;* open(const char* s,
    ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode);  // wide systems only; see [fstreams]</ins> 
basic_filebuf&lt;charT,traits&gt;* open(const string&amp; s,
   ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const filesystem::path&amp; p,</ins>
   <ins>ios_base::openmode mode);</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.4 Member functions [filebuf.members] 
as indicated:</span></i></p>

<pre>basic_filebuf&lt;charT,traits&gt;* open(const char* s,
   ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const std::filesystem::path::value_type* s,</ins>
   <ins>ios_base::openmode mode);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.4 Member functions [filebuf.members] 
add:</span></i></p>

<pre><ins>basic_filebuf&lt;charT,traits&gt;* open(const filesystem::path&amp; p,</ins>
   <ins>ios_base::openmode mode);</ins></pre>
   
<blockquote>
  <p><i>Returns:</i> <code>open(p.c_str(), mode);</code></p>
</blockquote>

  <p><i><span style="background-color: #E1E9FD">Change 27.9.1.6 Class template 
basic_ifstream [ifstream] as indicated:</span></i></p>

<pre>explicit basic_ifstream(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins>
explicit basic_ifstream(const string&amp; s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.7 basic_ifstream 
constructors [ifstream.cons] as indicated:</span></i></p>

<pre>explicit basic_ifstream(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.7 basic_ifstream 
constructors [ifstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_ifstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_ifstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.9 Member functions [ifstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.9 Member functions [ifstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.10 Class template 
basic_ofstream [ofstream] as indicated:</span></i></p>

<pre>explicit basic_ofstream(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins>
explicit basic_ofstream(const string&amp; s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.11 basic_ofstream 
constructors [ofstream.cons] as indicated:</span></i></p>

<pre>explicit basic_ofstream(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.11 basic_ofstream 
constructors [ofstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_ofstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_ofstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.13 Member functions [ofstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.13 Member functions [ofstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.14 Class template 
basic_fstream [fstream] as indicated:</span></i></p>

<pre>explicit basic_fstream(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins>
explicit basic_fstream(const string&amp; s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.15 basic_fstream 
constructors [fstream.cons] as indicated:</span></i></p>

<pre>explicit basic_fstream(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.15 basic_fstream 
constructors [fstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_fstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_fstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.17 Member functions [fstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.17 Member functions [fstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>



<hr>
<h3><a name="2921"></a>2921. <tt>packaged_task</tt> and type-erased allocators</h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Modify 30.6.10 <a href="https://timsong-cpp.github.io/cppwp/futures.task">[futures.task]</a> as follows:</p>
<p>Strike</p>
<blockquote><pre><del>
template &lt;class F, class Allocator&gt;
packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</del></pre></blockquote>
<p>from the class definition in p2, and from [futures.task.members] p2.</p>
</li>

<li>
<p>Modify 30.6.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a>/3:</p>
<blockquote>
<i>Remarks:</i> <del>These constructors</del><ins>This constructor</ins> shall not participate in overload resolution if 
<tt>decay_t&lt;F&gt;</tt> is the same type as <tt>packaged_task&lt;R(ArgTypes...)&gt;</tt>.
</blockquote>
</li>

<li>
<p>Strike the last sentence of 30.6.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a>/4:</p>
<blockquote><del>
The constructors that take an <tt>Allocator</tt> argument use it to allocate memory needed to store the internal data structures.
</del></blockquote>
</li>


</ol>


<hr>
<h3><a name="2787"></a>2787. &sect;[fs.file_status.cons] doesn't match class definition</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Edit 99 [fs.class.file_status] as indicated:</p>

<blockquote><pre>
class file_status {
public:
  // 27.10.11.1, constructors and destructor:
  <ins>file_status() noexcept : file_status(file_type::none) {}</ins>
  explicit file_status(file_type ft <del>= file_type::none</del>,
                       perms prms = perms::unknown) noexcept;
  [&hellip;]
};
</pre></blockquote>
</li>

<li><p>Edit 99 [fs.file_status.cons] as indicated:</p>

<blockquote>
<pre>
<del>explicit file_status() noexcept;</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Postconditions:</i> <tt>type() == file_type::none</tt> and <tt>permissions() == perms::unknown</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2786"></a>2786. Annex C should mention <tt>shared_ptr</tt> changes for array support</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Add to C.4.9 <a href="https://timsong-cpp.github.io/cppwp/diff.cpp14.utilities">[diff.cpp14.utilities]</a>:</p>
<blockquote>
<p>
<ins>20.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a></ins>
<p/>
<ins><i>Change:</i> Different constraint on conversions from <tt>unique_ptr</tt>.</ins>
<p/>
<ins><i>Rationale:</i> Adding array support to <tt>shared_ptr</tt>, via the syntax <tt>shared_ptr&lt;T[]&gt;</tt> and 
<tt>shared_ptr&lt;T[N]&gt;</tt>.</ins>
<p/>
<ins><i>Effect on original feature:</i> Valid code may fail to compile or change meaning in this International Standard. 
For example:</ins>
</p>
<blockquote><pre>
<ins>#include &lt;memory&gt;
std::unique_ptr&lt;int[]&gt; arr(new int[1]);
std::shared_ptr&lt;int&gt; ptr(std::move(arr)); // error: int(*)[] is not compatible with int*</ins>
</pre></blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2838"></a>2838. <tt>is_literal_type</tt> specification needs a little cleanup</h3>

<p>This wording is relative to <a href="http://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Edit D.11 <a href="https://timsong-cpp.github.io/cppwp/depr.meta.types">[depr.meta.types]</a> as indicated:</p>
<blockquote>
<p>
The header <tt>&lt;type_traits&gt;</tt> has the following addition:
</p>
<blockquote>
<pre>
namespace std {
  template &lt;class T&gt; struct is_literal_type;
  
  template &lt;class T&gt; constexpr bool is_literal_type_v = is_literal_type&lt;T&gt;::value;
}
</pre>
</blockquote>
<p>
-2- <i>Requires:</i> <tt>remove_all_extents_t&lt;T&gt;</tt> shall be a complete type or (possibly <i>cv</i>-qualified) <tt>void</tt>.
<p/>
-3- <del><i>Effects:</i> <tt>is_literal_type</tt> has a base-characteristic of <tt>true_type</tt> if <tt>T</tt> is a literal type (3.9), 
and a basecharacteristic of <tt>false_type</tt> otherwise</del><ins><tt>is_literal_type&lt;T&gt;</tt> is a 
<tt>UnaryTypeTrait</tt> (20.15.1 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) with a <tt>BaseCharacteristic</tt> of <tt>true_type</tt> if <tt>T</tt> 
is a literal type (3.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>), and <tt>false_type</tt> otherwise</ins>.
<p/>
<ins>-?- The behavior of a program that adds specializations for <tt>is_literal_type</tt> or <tt>is_literal_type_v</tt> is 
undefined.</ins>
</p>
</blockquote>
</li>
</ol>



</body>
</html>
