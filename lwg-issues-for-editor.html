<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Issues Resolved Directly In [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<h1>C++ Standard Library Issues Resolved In [INSERT CURRENT MEETING HERE]</h1>
<hr>
<h3><a name="2679"></a>2679. Inconsistent Use of Effects and Equivalent To</h3>

<ol>
<li>
<p>Change [structure.specifications]/4 as indicated:</p>

<blockquote>
<p>
"[&hellip;] if <tt>F</tt> has no <i>Returns</i>: element, a non-<tt>void</tt> return from <tt>F</tt> is specified by the 
<del>Returns: elements</del><ins>return statements</ins> in the code sequence."
</p>
</blockquote>
</li>

<li><p>Add two <tt>return</tt> keywords to [string.access]:</p>

<blockquote>
<pre>
const charT&amp; front() const;
charT&amp; front();
</pre>
<blockquote>
<p>-7- <i>Requires:</i> <code>!empty()</code>.</p>
<p>-8- <i>Effects:</i> Equivalent to <code><ins>return </ins>operator[](0)</code>.</p>
</blockquote>

<pre>
const charT&amp; back() const;
charT&amp; back();
</pre>
<blockquote>
<p>-9- <i>Requires:</i> <code>!empty()</code>.</p>
<p>-10- <i>Effects:</i> Equivalent to <code><ins>return </ins>operator[](size() - 1)</code>.</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2468"></a>2468. Self-move-assignment of library types</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p> In 17.6.3.2 [swappable.requirements], modify Table 23 &mdash; <code>MoveAssignable</code> 
requirements [moveassignable]:</p>

<blockquote>

<table border="1">
<caption>Table 23 &mdash; <tt>MoveAssignable</tt> requirements [moveassignable]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Return value</th>
<th>Post-condition</th>
</tr>

<tr>
<td><tt>t = rv</tt></td>
<td><tt>T&amp;</tt></td>
<td><tt>t</tt></td>
<td><ins>If <code>t</code> and <code>rv</code> do not refer to the same object,</ins> <tt>t</tt> is
equivalent to the value of <tt>rv</tt> before the assignment</td>
</tr>

<tr>
<td colspan="4">
<tt>rv</tt>'s state is unspecified. [<i>Note:</i> <tt>rv</tt> must
still meet the requirements of the library component that is using it<ins>,
whether or not <code>t</code> and <code>rv</code> refer to the same object</ins>. The
operations listed in those requirements must work as specified whether
<tt>rv</tt> has been moved from or not. &mdash; <i>end note</i>] </td>
</tr>

</table>

</blockquote>
</li>
</ol>


<hr>
<h3><a name="2510"></a>2510. Tag types should not be <tt>DefaultConstructible</tt></h3>

<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>In 18.6 [support.dynamic]/1, change the header <tt>&lt;new&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct nothrow_t { <ins>explicit nothrow_t() = default;</ins> };
extern const nothrow_t nothrow;
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.2 [utility]/2, change the header <tt>&lt;utility&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.3.5, pair piecewise construction</i>
struct piecewise_construct_t { <ins>explicit piecewise_construct_t() = default;</ins> };
constexpr piecewise_construct_t piecewise_construct{};
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.4.2 [pairs.pair], change the class template <tt>pair</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
pair(pair&amp;&amp;) = default;
<ins><i>EXPLICIT</i></ins> constexpr pair();
<i>EXPLICIT</i> constexpr pair(const T1&amp; x, const T2&amp; y);
[&hellip;]
</pre></blockquote>
</li>

<li><p>Around 20.4.2 [pairs.pair] p3, apply the following edits:</p>

<blockquote>
<pre>
<ins><i>EXPLICIT</i></ins> constexpr pair();
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Value-initializes <tt>first</tt> and <tt>second</tt>.
<p/>
-4- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_default_constructible&lt;first_type&gt;::value</tt> is <tt>true</tt> and 
<tt>is_default_constructible&lt;second_type&gt;::value</tt> is <tt>true</tt>. 
[<i>Note</i>: This
behaviour can be implemented by a constructor template with default template arguments. &mdash; 
<i>end note</i>]
<ins>The constructor is explicit if and only if either <tt>first_type</tt> or <tt>second_type</tt> 
is not implicitly default-constructible. 
[<i>Note</i>: This behaviour can be implemented with a trait 
that checks whether a <tt>const first_type&amp;</tt> or a <tt>const second_type&amp;</tt> can be 
initialized with <tt>{}</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 20.4.5 [pair.piecewise], apply the following edits:</p>

<blockquote><pre>
struct piecewise_construct_t { <ins>explicit piecewise_construct_t() = default;</ins> };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
</li>

<li><p>In 20.5.2 [tuple.tuple], change the class template <tt>tuple</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
<i>// 20.4.2.1, tuple construction</i>
<ins><i>EXPLICIT</i></ins> constexpr tuple();
<i>EXPLICIT</i> constexpr tuple(const Types&amp;...); <i>// only if sizeof...(Types) &gt;= 1</i>
[&hellip;]
</pre></blockquote>
</li>

<li><p>Around 20.5.2.1 [tuple.cnstr] p4, apply the following edits:</p>

<blockquote>
<pre>
<ins><i>EXPLICIT</i></ins> constexpr tuple();
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: Value initializes each element.
<p/>
-5- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_default_constructible&lt;<i>T<sub>i</sub></i>&gt;::value</tt> is <tt>true</tt> for all <i>i</i>. 
[<i>Note</i>: This
behaviour can be implemented by a constructor template with default template arguments. &mdash; 
<i>end note</i>]
<ins>The constructor is explicit if and only if <tt><i>T<sub>i</sub></i></tt> 
is not implicitly default-constructible for at least one <i>i</i>.
[<i>Note</i>: This behaviour can be implemented with a trait that checks whether
a <tt>const Ti&amp;</tt> can be initialized with <tt>{}</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 20.10.2 [memory.syn]/1, change the header <tt>&lt;memory&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.7.6, allocator argument tag</i>
struct allocator_arg_t { <ins>explicit allocator_arg_t() = default;</ins> };
constexpr allocator_arg_t allocator_arg{};
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.10.6 [allocator.tag], apply the following edits:</p>

<blockquote><pre>
namespace std {
  struct allocator_arg_t { <ins>explicit allocator_arg_t() = default;</ins> };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<blockquote class="note">
<p>
Editorial drive-by: <tt>piecewise_construct_t</tt> is written, in 20.4.5 [pair.piecewise] like
</p>
<blockquote><pre>
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
<p>
whereas other tag types such as <tt>allocator_construct_t</tt> are, in e.g.
20.10.6 [allocator.tag], written like
</p>
<blockquote><pre>
namespace std {
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<p>
We should decide whether or not to write out the <tt>std</tt> namespace in such
paragraphs. I would suggest not to write it out.
</p>
</blockquote>
</li>

<li><p>In 30.4 [thread.mutex]/1, change the header <tt>&lt;mutex&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct defer_lock_t { <ins>explicit defer_lock_t() = default;</ins> };
struct try_to_lock_t { <ins>explicit try_to_lock_t() = default;</ins> };
struct adopt_lock_t { <ins>explicit adopt_lock_t() = default;</ins> };

constexpr defer_lock_t defer_lock { };
constexpr try_to_lock_t try_to_lock { };
constexpr adopt_lock_t adopt_lock { };
[&hellip;]
</pre></blockquote>
</li>

</ol>


<hr>
<h3><a name="2686"></a>2686. Why is <tt>std::hash</tt> specialized for <tt>error_code</tt>, but not <tt>error_condition</tt>?</h3>

<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Edit 19.5.1 [system_error.syn], header <tt>&lt;system_error&gt;</tt> synopsis, as indicated: </p>

<blockquote><pre>
namespace std {
    // ...

    // 19.5.6 Hash support
    template&lt;class T&gt; struct hash;
    template&lt;&gt; struct hash&lt;error_code&gt;;
    <ins>template&lt;&gt; struct hash&lt;error_condition&gt;;</ins>

   // ...
}
</pre></blockquote>
</li>
<li> <p> Edit 19.5.6 [syserr.hash] as indicated: </p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;error_code&gt;;
<ins>template &lt;&gt; struct hash&lt;error_condition&gt;;</ins>
</pre>

<blockquote>
<p>-1- The template specialization<ins>s</ins> shall meet the requirements of class template <tt>hash</tt> (20.12.14).</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2729"></a>2729. Missing SFINAE on <tt>std::pair::operator=</tt></h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.4.2 [pairs.pair] as indicated:</p>

<blockquote>
<pre>
pair&amp; operator=(const pair&amp; p);
</pre>
<blockquote>
<p>
-15- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_copy_assignable_v&lt;first_type&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;second_type&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class V&gt; pair&amp; operator=(const pair&lt;U, V&gt;&amp; p);
</pre>
<blockquote>
<p>
-18- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;first_type&amp;, const U&amp;&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;second_type&amp;, const V&amp;&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
pair&amp; operator=(pair&amp;&amp; p) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-21- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T1&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;T2&gt;
</pre></blockquote>
<p>
-22- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_move_assignable_v&lt;first_type&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;second_type&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class V&gt; pair&amp; operator=(pair&lt;U, V&gt;&amp;&amp; p);
</pre>
<blockquote>
<p>
-25- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;first_type&amp;, U&amp;&amp;&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;second_type&amp;, V&amp;&amp;&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.5.2.2 [tuple.assign] as indicated:</p>

<blockquote>
<pre>
tuple&amp; operator=(const tuple&amp; u);
</pre>
<blockquote>
<p>
-2- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_copy_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
tuple&amp; operator=(tuple&amp;&amp; u) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-5- <i>Remark:</i> The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T<sub><i>i</i></sub>&gt;
</pre></blockquote>
<p>
where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i<sup>th</sup></i></tt> type in <tt>Types</tt>.
<p/>
-6- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins>
<tt>is_move_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class... UTypes&gt;
  tuple&amp; operator=(const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-9- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == sizeof...(UTypes)</tt> and 
<tt>is_assignable_v&lt;T<sub><i>i</i></sub>&amp;, const U<sub><i>i</i></sub>&amp;&gt;</tt> is <tt>true</tt> 
for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class... UTypes&gt;
  tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-12- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;T<sub><i>i</i></sub>&amp;, U<sub><i>i</i></sub>&amp;&amp;&gt; == true</tt> 
for all <tt><i>i</i></tt><del>.</del> <ins>and</ins> <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U1, class U2&gt; tuple&amp; operator=(const pair&lt;U1, U2&gt;&amp; u);
</pre>
<blockquote>
<p>
-15- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == 2</tt><del>.</del> <ins>and</ins> <tt>is_assignable_v&lt;T<sub><i>0</i></sub>&amp;, 
const U<sub><i>1</i></sub>&amp;&gt;</tt> is <tt>true</tt> for the first type <tt>T<sub><i>0</i></sub></tt> in 
<tt>Types</tt> and <tt>is_assignable_v&lt;T<sub><i>1</i></sub>&amp;, const U<sub><i>2</i></sub>&amp;&gt;</tt> 
is <tt>true</tt> for the second type <tt>T<sub><i>1</i></sub></tt> in <tt>Types</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U1, class U2&gt; tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-18- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == 2</tt><del>.</del> <ins>and</ins> <tt>is_assignable_v&lt;T<sub><i>0</i></sub>&amp;, 
U<sub><i>1</i></sub>&amp;&amp;&gt;</tt> is <tt>true</tt> for the first type <tt>T<sub><i>0</i></sub></tt> in 
<tt>Types</tt> and <tt>is_assignable_v&lt;T<sub><i>1</i></sub>&amp;, U<sub><i>2</i></sub>&amp;&amp;&gt;</tt> 
is <tt>true</tt> for the second type <tt>T<sub><i>1</i></sub></tt> in <tt>Types</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>


<hr>
<h3><a name="2773"></a>2773. Making <tt>std::ignore constexpr</tt></h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.5.1 [tuple.general] as indicated:</p>
<blockquote>
<pre>
<i>// 20.5.2.4, tuple creation functions:</i>
<del>const</del><ins>constexpr</ins> <i>unspecified</i> ignore;
</pre>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2756"></a>2756. C++ WP <tt>optional&lt;T&gt;</tt> should 'forward' <tt>T</tt>'s implicit conversions</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; class optional
{
public:
  using value_type = T;
  
  <i>// 20.6.3.1, Constructors</i>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional &amp;);
  optional(optional &amp;&amp;) noexcept(<i>see below</i>);
  <del>constexpr optional(const T &amp;);</del>
  <del>constexpr optional(T &amp;&amp;);</del>
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args &amp;&amp;...);
  <ins>template &lt;class U = T&gt; <em>EXPLICIT</em> constexpr optional(U &amp;&amp;);
  template &lt;class U&gt; <em>EXPLICIT</em> optional(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; <em>EXPLICIT</em> optional(optional&lt;U&gt; &amp;&amp;);</ins>
  
  [&hellip;]
  
  <i>// 20.6.3.3, Assignment</i>
  optional &amp;operator=(nullopt_t) noexcept;
  optional &amp;operator=(const optional &amp;);
  optional &amp;operator=(optional &amp;&amp;) noexcept(<i>see below</i>);
  template &lt;class U <ins>= T</ins>&gt; optional &amp;operator=(U &amp;&amp;);
  <ins>template &lt;class U&gt; optional&amp; operator=(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; optional&amp; operator=(optional&lt;U&gt; &amp;&amp;);</ins>
  template &lt;class... Args&gt; void emplace(Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args &amp;&amp;...);

  [&hellip;]
  
};
</pre>
</blockquote>
</li>

<li><p>Change 20.6.3.1 [optional.object.ctor] as indicated:</p>

<blockquote>
<pre>
optional(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-3- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall be defined as deleted
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
optional(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-7- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to <tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>.
<ins>This constructor shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
<del>constexpr optional(const T&amp; v);</del>
</pre>
<blockquote>
<p>
<del>-12- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
<del>-13- <i>Effects:</i> Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> 
with the expression <code>v</code>.</del>
<p/>
<del>-14- <i>Postcondition:</i> <code>*this</code> contains a value.</del>
<p/>
<del>-15- <i>Throws:</i> Any exception thrown by the selected constructor of <code>T</code>.</del>
<p/>
<del>-16- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor.</del>
</p>
</blockquote>
<pre>
<del>constexpr optional(T&amp;&amp; v);</del>
</pre>
<blockquote>
<p>
<del>-17- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
<del>-18- <i>Effects:</i> Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> 
with the expression <code>std::move(v)</code>.</del>
<p/>
<del>-19- <i>Postcondition:</i> <code>*this</code> contains a value.</del>
<p/>
<del>-20- <i>Throws:</i> Any exception thrown by the selected constructor of <code>T</code>.</del>
<p/>
<del>-21- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor.</del>
</p>
</blockquote>
<pre>
template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-26- <i>Remarks:</i> If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>This constructor shall not participate in overload
resolution unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-27- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is 
<tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-31- <i>Remarks:</i> <del>The function</del><ins>This constructor</ins> shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>. 
If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.
</p>
</blockquote>
<p>
<ins>[<i>Note:</i> The following constructors are conditionally specified
as explicit. This is typically implemented by declaring two such
constructors, of which at most one participates in overload
resolution. &mdash; <i>end note</i>]</ins>
</p>
<pre>
<ins>template &lt;class U = T&gt;
  <em>EXPLICIT</em> constexpr optional(U&amp;&amp; v);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Initializes the contained value as if
direct-non-list-initializing an object of type <tt>T</tt> with the expression
<tt>std::forward&lt;U&gt;(v)</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>*this</tt> contains a value.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt>
constructor, this constructor shall be a <tt>constexpr</tt> constructor. This
constructor shall not participate in overload resolution unless
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same_v&lt;U, 
in_place_t&gt;</tt> is <tt>false</tt>, and <tt>is_same_v&lt;optional&lt;T&gt;, decay_t&lt;U&gt;&gt;</tt> 
is <tt>false</tt>. The constructor is explicit if and only if 
<tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> optional(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> If <tt>rhs</tt> contains a value, initializes the
contained value as if direct-non-list-initializing an object of type <tt>T</tt>
with the expression <tt>*rhs</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in
overload resolution unless <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, 
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
and <tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>. 
The constructor is explicit if and only if <tt>is_convertible_v&lt;const U&amp;, T&gt;</tt> is 
<tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> optional(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> If <tt>rhs</tt> contains a value, initializes the
contained value as if direct-non-list-initializing an object of type <tt>T</tt>
with the expression <tt>std::move(*rhs)</tt>. <tt>bool(rhs)</tt> is unchanged.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in
overload resolution unless <tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
and <tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>. The constructor 
is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>

<li><p>Change 20.6.3.3 [optional.object.assign] as indicated:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-4- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-8- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
If an exception is thrown during the call to <tt>T</tt>'s copy constructor, no effect. If an exception is thrown
during the call to <tt>T</tt>'s copy assignment, the state of its contained value is as defined by the exception
safety guarantee of <tt>T</tt>'s copy assignment. <ins>This operator shall be defined as deleted unless
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_copy_assignable_v&lt;T&gt;</tt> is
<tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-9- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-13- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T&gt; &amp;&amp; is_nothrow_move_constructible_v&lt;T&gt;
</pre></blockquote>
<p>
-14- If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s move constructor, the state of <tt>*rhs.val</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s move constructor. If an exception is 
thrown during the call to <tt>T</tt>'s move assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s move assignment. <ins>This operator 
shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class U <ins>= T</ins>&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> 
remains unchanged. If an exception is thrown during the call to <tt>T</tt>'s constructor, the state 
of <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s constructor. If an 
exception is thrown during the call to <tt>T</tt>'s assignment, the state of <tt>*val</tt> and <tt>v</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s assignment. <del>The</del><ins>This</ins> function
shall not participate in overload resolution unless <del><tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt></del> 
<ins><tt>is_same_v&lt;optional&lt;T&gt;, decay_t&lt;U&gt;&gt;</tt> is <tt>false</tt>,
conjunction_v&lt;is_scalar&lt;T&gt;, is_same&lt;T, decay_t&lt;U&gt;&gt;&gt; is <tt>false</tt>,
<tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt>, and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt></ins> is <tt>true</tt>.
<p/>
<del>-20- <i>Notes:</i> The reason for providing such generic assignment and then constraining it so that effectively 
<tt>T == U</tt> is to guarantee that assignment of the form <tt>o = {}</tt> is unambiguous.</del>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: See Table ?.</ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(const optional&lt;U&gt;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>*rhs</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s assignment, 
the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s assignment. 
This function shall not participate in overload resolution unless <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is 
<tt>true</tt>, <tt>is_assignable_v&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
and <tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: See Table ?. The result of the expression <tt>bool(rhs)</tt> remains unchanged. </ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(optional&lt;U&gt;&amp;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>std::move(*rhs)</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>std::move(*rhs)</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. This function shall not participate in overload resolution unless <tt>is_constructible_v&lt;T, U&gt;</tt> is 
<tt>true</tt>, <tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
and <tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>


<hr>
<h3><a name="2748"></a>2748. <tt>swappable</tt> traits for <tt>optional</tt>s</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3.4 [optional.object.swap] as indicated:</p>

<blockquote>
<pre>
void swap(optional&lt;T&gt;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote>
<pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; <ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</del>
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.6.9 [optional.specalg] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <tt>x.swap(y)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2740"></a>2740. <tt>constexpr optional&lt;T&gt;::operator-&gt;</tt></h3>

<p>This wording is relative to N4594.</p>

<ol>
<li><p>Modify 20.6.3.5 [optional.object.observe] as indicated:</p>

<blockquote>
<pre>
constexpr T const* operator-&gt;() const;
constexpr T* operator-&gt;();
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>*this</tt> contains a value.
<p/>
-2- <i>Returns:</i> <tt>val</tt>.
<p/>
-3- <i>Throws:</i> Nothing.
<p/>
-4- <i>Remarks:</i> <del>Unless <tt>T</tt> is a user-defined type with overloaded unary <tt>operator&amp;</tt>, 
t</del><ins>T</ins>hese functions shall be <tt>constexpr</tt> functions.
</p>
</blockquote>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2736"></a>2736. <tt>nullopt_t</tt> insufficiently constrained</h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Edit 20.6.4 [optional.nullopt]/2 as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: <tt>{}</tt> can do one of three things for a class type:
it may be aggregate initialization, it may call a default constructor,
or it may call an initializer-list constructor (see 8.6.4 [dcl.init.list], 13.3.1.7 [over.match.list]).
The wording below forecloses all three possibilities. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
<blockquote>
<p>
-2- Type <tt>nullopt_t</tt> shall not have a default constructor <ins>or an initializer-list constructor</ins>. 
It <ins>shall not be an aggregate and</ins> shall be a literal type. Constant <tt>nullopt</tt> shall 
be initialized with an argument of literal type.
</p>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2749"></a>2749. <tt>swappable</tt> traits for <tt>variant</tt>s</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.7.2.6 [variant.swap] as indicated:</p>

<blockquote>
<pre>
void swap(variant&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p/>
<ins>-?- <i>Requires:</i> Lvalues of type <tt>T<sub><i>i</i></sub></tt> shall be swappable and 
<tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt;</tt> shall be <tt>true</tt> for all <tt><i>i</i></tt>.</ins>
<p/>
[&hellip;]
<p/>
-2- <i>Throws:</i> <ins>If <tt>index() == rhs.index()</tt>, a</ins><del>A</del>ny exception thrown by
<tt>swap(get&lt;<i>i</i>&gt;(*this), get&lt;<i>i</i>&gt;(rhs))</tt> with <i>i</i> being <tt>index()</tt><del> and
<tt>variant</tt>'s move constructor and assignment operator</del>. <ins>Otherwise, any exception thrown by the move
constructor of <tt>T<sub><i>i</i></sub></tt> or <tt>T<sub><i>j</i></sub></tt> with <tt><i>i</i></tt> being
<tt>index()</tt> and <tt><i>j</i></tt> being <tt>rhs.index()</tt>.</ins>
<p/>
-3- <i>Remarks:</i> <del>This function shall not participate in overload resolution unless <tt>is_swappable_v&lt;Ti&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>.</del> If an exception is thrown during the call to function
<tt>swap(get&lt;<i>i</i>&gt;(*this), get&lt;<i>i</i>&gt;(rhs))</tt>, the states of the contained values of
<tt>*this</tt> and of <tt>rhs</tt> are determined by the exception safety guarantee of swap for lvalues of
<tt>T<sub><i>i</i></sub></tt> with <tt><i>i</i></tt> being <tt>index()</tt>. If an exception is thrown during the 
exchange of the values of <tt>*this</tt> and <tt>rhs</tt>, the states of the values of <tt>*this</tt> and of <tt>rhs</tt> 
are determined by the exception safety guarantee of <tt>variant</tt>'s move constructor <del>and move assignment operator</del>. 
The expression inside <tt>noexcept</tt> is equivalent to the logical AND of 
<tt>is_nothrow_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; 
is_nothrow_swappable_v&lt;T<sub><i>i</i></sub>&gt;</tt> for all <tt><i>i</i></tt>.
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.7.9 [variant.specalg] as indicated:</p>

<blockquote>
<pre>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <tt>v.swap(w)</tt>.
<p/>
-2- <i>Remarks:</i> <ins>This function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; is_swappable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is
<tt>true</tt> for all <tt><i>i</i></tt>.</ins> The expression inside <tt>noexcept</tt> is equivalent to <tt>noexcept(v.swap(w))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2744"></a>2744. <tt>any</tt>'s <tt>in_place</tt> constructors</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.
<p/>
-8- <i>Effects:</i> Constructs an object of type <tt>any</tt> that contains an object of type <tt>T</tt> 
direct-initialized with <tt>std::forward&lt;ValueType&gt;(value)</tt>.
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution if <tt>decay_t&lt;ValueType&gt;</tt> is the
same type as <tt>any</tt> <ins>or if <tt>ValueType</tt> is a specialization of <tt>in_place_type_t</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-11- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</del>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless
<tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></ins>
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> <del>The function</del><ins>This constructor</ins> shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2598"></a>2598. <tt>addressof</tt> works on temporaries</h3>

<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 20.10.2 [memory.syn], header <tt>&lt;memory&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 20.9.12, specialized algorithms:</i>
template &lt;class T&gt; constexpr T* addressof(T&amp; r) noexcept;
<ins>template &lt;class T&gt; const T* addressof(const T&amp;&amp; elem) = delete;</ins>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 20.10.10.1 [specialized.addressof] p1 as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; constexpr T* addressof(T&amp; r) noexcept;
<ins>template &lt;class T&gt; const T* addressof(const T&amp;&amp; elem) = delete;</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns</i>: The actual address of the object or function referenced by <tt>r</tt>, even in the presence of an
overloaded <tt>operator&amp;</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2696"></a>2696. Interaction between <tt>make_shared</tt> and <tt>enable_shared_from_this</tt> is underspecified</h3>

<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Change 20.11.2.2.6 [util.smartptr.shared.create] indicated:</p>

<blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Remarks</i>: <ins>The <tt>shared_ptr</tt> constructor called by this function enables <tt>shared_from_this</tt> 
with the address of the newly constructed object of type <tt>T</tt>.</ins> Implementations should perform no more than 
one memory allocation. [<i>Note</i>: This provides efficiency equivalent to an intrusive smart 
pointer. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2562"></a>2562. Consistent total ordering of pointers by comparison functors</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.14.6 [comparisons] p14 as indicated:</p>
<blockquote><p>
-14- For templates <del><tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and 
<tt>less_equal</tt></del><ins><ins><tt>less</tt>, <tt>greater</tt>, <tt>less_equal</tt>,
and <tt>greater_equal</tt></ins></ins>, 
the specializations for any pointer type yield a <ins>strict</ins> total order<ins>
that is consistent among those specializations and is also consistent with the partial order imposed by</ins>
<del>, even if</del> the built-in operators 
<tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, <tt>&gt;=</tt> <del>do not</del>. <ins>[<i>Note:</i>
When <tt>a &lt; b</tt> is well-defined for pointers <tt>a</tt> and <tt>b</tt> of type <tt>P</tt>,
this implies <tt>(a &lt; b) == less&lt;P&gt;(a, b)</tt>, <tt>(a &gt; b) == greater&lt;P&gt;(a, b)</tt>,
and so forth. &mdash; <i>end note</i>]</ins> For template specializations 
<del><tt>greater&lt;void&gt;</tt>, <tt>less&lt;void&gt;</tt>, <tt>greater_equal&lt;void&gt;</tt>, and 
<tt>less_equal&lt;void&gt;</tt></del><ins><tt>less&lt;void&gt;</tt>, <tt>greater&lt;void&gt;</tt>,
<tt>less_equal&lt;void&gt;</tt>, and <tt>greater_equal&lt;void&gt;</tt></ins>, if the call operator 
calls a built-in operator comparing pointers, the call operator yields a <ins>strict</ins> total 
order <ins>that is consistent among those specializations and is also consistent
with the partial order imposed by those built-in operators</ins>.
</p></blockquote>
</li>
</ol>


<hr>
<h3><a name="2767"></a>2767. <tt>not_fn <i>call_wrapper</i></tt> can form invalid types</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.14.9 [func.not_fn], class <tt><i>call_wrapper</i></tt> synopsis, as indicated:</p>
<blockquote>
<pre>
class <i>call_wrapper</i>
{
  [&hellip;]
  template&lt;class... Args&gt;
    auto operator()(Args&amp;&amp;...) &amp;
      -&gt; decltype(!declval&lt;result_of_t&lt;FD&amp;(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
  template&lt;class... Args&gt;
    auto operator()(Args&amp;&amp;...) const&amp;
      -&gt; decltype(!declval&lt;result_of_t&lt;FD const&amp;(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
  template&lt;class... Args&gt;
    auto operator()(Args&amp;&amp;...) &amp;&amp;
      -&gt; decltype(!declval&lt;result_of_t&lt;FD(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
  template&lt;class... Args&gt;
    auto operator()(Args&amp;&amp;...) const&amp;&amp;
      -&gt; decltype(!declval&lt;result_of_t&lt;FD const(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());  
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Modify the prototype declarations of 20.14.9 [func.not_fn] as indicated:</p>
<blockquote>
<pre>
template&lt;class... Args&gt;
  auto operator()(Args&amp;&amp;... args) &amp;
    -&gt; decltype(!declval&lt;result_of_t&lt;FD&amp;(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
template&lt;class... Args&gt;
  auto operator()(Args&amp;&amp;... args) const&amp;
    -&gt; decltype(!declval&lt;result_of_t&lt;FD const&amp;(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... Args&gt;
  auto operator()(Args&amp;&amp;... args) &amp;&amp;
    -&gt; decltype(!declval&lt;result_of_t&lt;FD(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
template&lt;class... Args&gt;
  auto operator()(Args&amp;&amp;... args) const&amp;&amp;
    -&gt; decltype(!declval&lt;result_of_t&lt;FD const(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
</pre>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2062"></a>2062. Effect contradictions w&#47;o no-throw guarantee of <tt>std::function</tt> swaps</h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Modify the header <tt>&lt;functional&gt;</tt> synopsis in 20.14 [function.objects] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>function</tt> synopsis in 20.14.12.2 [func.wrap.func] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  <i>// [func.wrap.func.alg], specialized algorithms:</i>
  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 20.14.12.2.7 [func.wrap.func.alg] as indicated:</p>
<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2) <ins>noexcept</ins>;
</pre><blockquote><p>
-1- <i>Effects</i>: As if by: <tt>f1.swap(f2);</tt>
</p></blockquote></blockquote>
</li>
</ol>


<hr>
<h3><a name="2591"></a>2591. <tt>std::function</tt>'s member template <tt>target()</tt> should not lead to undefined behaviour</h3>

<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 20.14.12.2.5 [func.wrap.func.targ] p2 as indicated:</p>

<blockquote><pre>
template&lt;class T&gt; T* target() noexcept;
template&lt;class T&gt; const T* target() const noexcept;
</pre>
<blockquote>
<p>
<del>-2- <i>Requires</i>: <tt>T</tt> shall be a type that is <tt>Callable</tt> (20.14.12.2 [func.wrap.func]) for parameter types 
<tt>ArgTypes</tt> and return type <tt>R</tt>.</del>
<p/>
-3- <i>Returns</i>: If <tt>target_type() == typeid(T)</tt> a pointer to the stored function target; otherwise a null
pointer.
</p>
</blockquote>
</blockquote>
</li>

</ol>


<hr>
<h3><a name="2514"></a>2514. Type traits must not be <tt>final</tt></h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Add a new paragraph add the end of 17.6.5.11 [derivation] as indicated:</p>

<blockquote>
<p>
<ins>-?- All types specified in the C++ standard library shall be non-<code>final</code>
types unless otherwise specified.</ins>
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2738"></a>2738. <tt>is_constructible</tt> with <tt>void</tt> types</h3>

<p>This wording is relative to N4594.</p>

<ol>
<li><p>Change 20.15.4.3 [meta.unary.prop], Table 52 &mdash; "Type property predicates", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 52 &mdash; Type property predicates</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T, class... Args&gt;<br/>
struct is_constructible;</tt>
</td>

<td>
For a function type <tt>T</tt><br/> 
<ins>or for a (possibly <i>cv</i>-qualified) <tt>void</tt> type <tt>T</tt></ins>,<br/> 
<tt>is_constructible&lt;T, Args...&gt;::value</tt><br/>
is <tt>false</tt>, otherwise <i>see below</i>
</td>

<td align="center">
<tt>T</tt> and all types in the<br/>
parameter pack <tt>Args</tt> shall<br/>
be complete types,<br/>
(possibly <i>cv</i>-qualified)<br/>
<tt>void</tt>, or arrays of<br/>
unknown bound.
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2460"></a>2460. LWG issue 2408 and value categories</h3>

<p>Change 24.4.1 [iterator.traits] p.2:</p>

<p>[&hellip;] as publicly accessible members <del>and no other members</del>:</p>

<p>[&hellip;]</p>

<p>Otherwise, <tt>iterator_traits&lt;Iterator&gt;</tt> shall have no members <ins>by any of the above names</ins>.</p>


<hr>
<h3><a name="2567"></a>2567. Specification of logical operator traits uses <tt>BaseCharacteristic</tt>, which is defined only for <tt>UnaryTypeTraits</tt> 
and <tt>BinaryTypeTraits</tt></h3>

<p>This wording is relative to N4606.</p>

<ol>
<li>
<p>In 20.15.8 [meta.logical] p3, edit as follows:</p>
<pre>
template&lt;class... B&gt; struct conjunction : <em>see below</em> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>-3- The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins>
<ol style="list-style-type:none">
<li>&mdash; <ins>the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>bool(Bi::value)</tt> is <tt>false</tt>, or</ins></li>
<li>&mdash; <ins>if there is no such <tt>Bi</tt>, the last type in the list.</ins></li>
</ol>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or if every <tt>Bi::value != false</tt>, the
BaseCharacteristic is the last type in the list.</del>[<em>Note: </em>
This means a specialization of <tt>conjunction</tt> does not necessarily <del>have a BaseCharacteristic
of</del> <ins>inherit from</ins> either <tt>true_type</tt> or <tt>false_type</tt>.
&mdash;<em>end note</em>]</p>
<p><ins>-?- The member names of the base class, other than <tt>conjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>conjunction</tt>.</ins></p>
</blockquote>
</li>

<li>
<p>In 20.15.8 [meta.logical] p6, edit as follows:</p>
<pre>
template&lt;class... B&gt; struct disjunction : <em>see below</em> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>-6- The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins>
<ol style="list-style-type:none">
<li>&mdash; <ins>the first type <tt>Bi</tt> in the list <tt>false_type, B1, ..., BN</tt> for
which <tt>bool(Bi::value)</tt> is <tt>true</tt>, or,</ins></li>
<li>&mdash; <ins>if there is no such <tt>Bi</tt>, the last type in the list.</ins></li>
</ol>
<del>is the first type <tt>Bi</tt> in the list <tt>false_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or if every <tt>Bi::value == false</tt>, the
BaseCharacteristic is the last type in the list.</del>[<em>Note: </em>This
means a specialization of <tt>disjunction</tt> does not necessarily <del>have a BaseCharacteristic
of</del> <ins>inherit from</ins> either <tt>true_type</tt> or <tt>false_type</tt>.
&mdash;<em>end note</em>]</p>
<p><ins>-?- The member names of the base class, other than <tt>disjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>disjunction</tt>.</ins></p>
</blockquote>
</li>

<li>
<p>In 20.15.8 [meta.logical] p8, edit as follows</p>
<pre>
template&lt;class B&gt; struct negation : <ins><em>see below</em></ins><del><tt>bool_constant&lt;!B::value&gt;</tt></del> { };
</pre>
<blockquote>
<p>
-8- The class template negation forms the logical negation of its template type argument. The type
<tt>negation&lt;B&gt;</tt> is a UnaryTypeTrait with a BaseCharacteristic of
<tt>bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt;</tt>.
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2739"></a>2739. Issue with <tt>time_point</tt> non-member subtraction with an unsigned duration</h3>

<p>This wording is relative to N4594.</p>

<ol>
<li><p>Change 20.17.6.5 [time.point.nonmember] as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <del><tt>lhs + (-rhs)</tt></del><ins><tt><i>CT</i>(lhs.time_since_epoch() - rhs)</tt>, where 
<tt><i>CT</i></tt> is the type of the return value</ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2760"></a>2760. non-const <tt>basic_string::data</tt> should not invalidate iterators</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 21.3.1.1 [string.require]/4 as indicated:</p>

<blockquote>
<p>
-4- References, pointers, and iterators referring to the elements of a <tt>basic_string</tt> sequence 
may be invalidated by the following uses of that <tt>basic_string</tt> object:
</p>
<ul>
<li><p>as an argument to any standard library function taking a reference to non-const <tt>basic_string</tt> as an
argument.(footnote 230)</p></li>
<li><p>Calling non-const member functions, except <tt>operator[]</tt>, <tt>at</tt>, <ins>data,</ins> <tt>front</tt>, 
<tt>back</tt>, <tt>begin</tt>, <tt>rbegin</tt>, <tt>end</tt>, and <tt>rend</tt>.</p></li>
</ul>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2742"></a>2742. Inconsistent <tt>string</tt> interface taking <tt>string_view</tt></h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 21.3.1 [basic.string] add the following constructor overload:</p>

<blockquote><pre>
[&hellip;]
basic_string(const basic_string&amp; str, size_type pos,
             const Allocator&amp; a = Allocator());
basic_string(const basic_string&amp; str, size_type pos, size_type n,
             const Allocator&amp; a = Allocator());
<ins>template&lt;class T&gt;
basic_string(const T&amp; t, size_type pos, size_type n, const Allocator&amp; a = Allocator());</ins>
explicit basic_string(basic_string_view&lt;charT, traits&gt; sv,
                      const Allocator&amp; a = Allocator());
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 21.3.1.2 [string.cons] add the following ctor definition:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;
basic_string(const T&amp; t, size_type pos, size_type n, const Allocator&amp; a = Allocator());</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then behaves the same as:</ins>
<blockquote>
<pre>
<ins>basic_string(sv.substr(pos, n), a)</ins>
</pre>
</blockquote>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2475"></a>2475. Allow overwriting of <tt>std::basic_string</tt> terminator with <tt>charT()</tt> to allow 
cleaner interoperation with legacy APIs</h3>

<p>This wording is relative to N4296.</p>

<ol>
<li>
<p>Edit 21.3.1.5 [string.access] as indicated:</p>
<blockquote>
<pre>
const_reference operator[](size_type pos) const;
reference operator[](size_type pos);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: [&hellip;]
<p/>
-2- <i>Returns</i>: <tt>*(begin() + pos)</tt> if <tt>pos &lt; size()</tt>. Otherwise, returns a reference to an object of type
<tt>charT</tt> with value <tt>charT()</tt>, where modifying the object <ins>to any value other than <tt>charT()</tt></ins> 
leads to undefined behavior.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2778"></a>2778. <tt>basic_string_view</tt> is missing <tt>constexpr</tt></h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 21.4.2 [string.view.template], add <tt>constexpr</tt> to the assignment operator:</p>

<blockquote>
<pre>
<ins>constexpr </ins>basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;
</pre>
</blockquote>
</li>

<li><p>In 21.4.2 [string.view.template], add <tt>constexpr</tt> to the reverse range functions:</p>

<blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator rend() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crend() const noexcept;
</pre>
</blockquote>
</li>

<li><p>In 21.4.2.2 [string.view.iterators], add <tt>constexpr</tt> to the reverse range functions:</p>

<blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crbegin() const noexcept;
</pre>
<blockquote>
<p>
-6- <em>Returns:</em> <tt>const_reverse_iterator(end())</tt>
</p>
</blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rend() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crend() const noexcept;
</pre>
<blockquote>
<p>
-7- <em>Returns:</em> <tt>const_reverse_iterator(begin())</tt>
</p>
</blockquote>
</blockquote>
</li>

</ol>


<hr>
<h3><a name="2777"></a>2777. <tt>basic_string_view::copy</tt> should use <tt>char_traits::copy</tt></h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 99 [string.copy] as indicated:</p>

<blockquote>
<pre>
size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>

</blockquote>
<p>
<ins>-?- Let <tt>rlen</tt> be the smaller of <tt>n</tt> and <tt>size() - pos</tt>.</ins>
</p>
<p>
-2- <em>Throws: </em><tt>out_of_range</tt> if <tt>pos &gt; size()</tt>.
</p>
<p>
<ins>-?- <em>Requires:</em> <tt>[s, s + rlen)</tt> is a valid range.</ins>
</p>
<p>
-3- <em>Effects:</em> <del>Determines the effective length <tt>rlen</tt> of the string
to copy as the smaller of <tt>n</tt> and <tt>size() - pos</tt>. <tt>s</tt> shall
designate an array of at least <tt>rlen</tt> elements.</del><ins>Equivalent to: <tt>traits::copy(s, data() + pos, rlen)</tt>.
[<em>Note:</em> This does not terminate <tt>s</tt> with a null object. &mdash; <em>end note</em>]</ins>
</p>
<p><del>The function then replaces the string designated by <tt>s</tt> with a string of
length <tt>rlen</tt> whose elements are a copy of the string controlled by
<tt>*this</tt> beginning at position <tt>pos</tt>.</del>
</p>
<p>
<del>The function does not append a null object to the string designated by <tt>s</tt>.</del>
</p>
<p>
-4- <em>Returns: </em><tt>rlen</tt>.
</p>
</li>

<li><p>Change 21.4.2.6 [string.view.ops] as indicated:</p>

<blockquote>
<pre>
size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>

</blockquote>
<p>
-1- Let <tt>rlen</tt> be the smaller of <tt>n</tt> and <tt>size() - pos</tt>.
</p>
<p>
-2- <em>Throws:</em> <tt>out_of_range</tt> if <tt>pos &gt; size()</tt>.
</p>
<p>
-3- <em>Requires:</em> <tt>[s, s + rlen)</tt> is a valid range.
</p>
<p>
-4- <em>Effects:</em> Equivalent to: <del><tt>copy_n(begin() + pos, rlen, s)</tt></del><ins><tt>traits::copy(s, 
data() + pos, rlen)</tt></ins>
</p>
<p>
-5- <em>Returns:</em> <tt>rlen</tt>.
</p>
<p>
-6- <em>Complexity:</em> &#x1d4aa;(<tt>rlen</tt>).
</p>
</li>
</ol>


<hr>
<h3><a name="2755"></a>2755. &sect;[string.view.io] uses non-existent <tt>basic_string_view::to_string</tt> function</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 21.3.2.9 [string.io] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               const basic_string&lt;charT, traits, Allocator&gt;&amp; str);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> <ins>Equivalent to: <tt>return os &lt;&lt; basic_string_view&lt;charT, 
traits&gt;(str);</tt></ins><del>Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) 
of <tt>os</tt>. Forms a character sequence <tt>seq</tt>, initially consisting of the elements defined by the 
range <tt>[str.begin(), str.end())</tt>. Determines padding for <tt>seq</tt> as described in 
27.7.3.6.1 [ostream.formatted.reqmts]. Then inserts <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, 
where <tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.</del>
<p/>
<del>-6- <i>Returns:</i> <tt>os</tt></del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 21.4.4 [string.view.io] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               basic_string_view&lt;charT, traits&gt; str);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> <del>Equivalent to: <tt>return os &lt;&lt; str.to_string();</tt></del><ins>Behaves 
as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) of <tt>os</tt>. Forms a character 
sequence <tt>seq</tt>, initially consisting of the elements defined by the range <tt>[str.begin(), 
str.end())</tt>. Determines padding for <tt>seq</tt> as described in 27.7.3.6.1 [ostream.formatted.reqmts]. Then 
inserts <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of 
<tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.</ins>
<p/>
<ins>-?- <i>Returns:</i> <tt>os</tt></ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2694"></a>2694. Application of LWG 436 accidentally deleted definition of "facet"</h3>

<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Insert the following paragraph before 22.3.1.1.2 [locale.facet]/1:</p>

<blockquote>
<p>
<ins>-?- Class <tt>facet</tt> is the base class for locale feature sets. A class is a <i>facet</i> if it is publicly 
derived from another facet, or if it is a class derived from <tt>locale::facet</tt> and containing a publicly accessible 
declaration as follows: [<i>Footnote</i>: This is a complete list of requirements; there are no other requirements. Thus, a 
facet class need not have a public copy constructor, assignment, default constructor, destructor, etc.]</ins>
</p>
<blockquote><pre>
<ins>static ::std::locale::id id;</ins>
</pre></blockquote>
<p>
-1- Template parameters in this Clause which are required to be facets are those named <tt>Facet</tt> in declarations. A
program that passes a type that is <i>not</i> a facet, or a type that refers to a volatile-qualified facet, as an (explicit
or deduced) template parameter to a locale function expecting a facet, is ill-formed. A const-qualified facet is
a valid template argument to any locale function that expects a Facet template parameter.
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2394"></a>2394. <tt>locale::name</tt> specification unclear &mdash; what is implementation-defined?</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 22.3.1.3 [locale.members] as indicated:</p>

<blockquote>
<pre>
basic_string&lt;char&gt; name() const;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> The name of <tt>*this</tt>, if it has one; otherwise, the string <tt>"*"</tt>. 
<del>If <tt>*this</tt> has a name, then <tt>locale(name().c_str())</tt> is equivalent to <tt>*this</tt>. 
Details of the contents of the resulting string are
otherwise implementation-defined.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2261"></a>2261. Are containers required to use their '<tt>pointer</tt>' type internally?</h3>

<p>This wording is relative to N4606.</p>

<p><i>[Drafting notes: if people prefer this to be normative, strip
the "Note" markups.]</i></p>


<p>Modify 23.2.1 [container.requirements.general]/8 as indicated:</p>

<blockquote><p>
Unless otherwise specified, all containers defined in this clause obtain
memory using an allocator (see 17.6.3.5 [allocator.requirements]).
<ins>[<i>Note:</i> In particular, containers and iterators
do not store references to allocated elements other than through the
allocator's pointer type, i.e., as objects of type <tt><i>P</i></tt> or
<tt>pointer_traits&lt;<i>P</i>&gt;::template rebind&lt;<i>unspecified</i>&gt;</tt>,
where <tt><i>P</i></tt> is
<tt>allocator_traits&lt;allocator_type&gt;::pointer</tt>. &mdash; <i>end note</i>]</ins>
</p></blockquote>


<hr>
<h3><a name="2540"></a>2540. <tt>unordered_multimap::insert</tt> hint iterator</h3>

<p>
Change the insert-with-hint row in Table 102
Unordered associative container requirements like so:
</p>
<blockquote>
<table border="1" cellpadding="4"><tr>
<td><tt>a.insert(<del>q</del><ins>p</ins>, t);</tt><br/></td>
<td><tt>iterator</tt><br/></td>
<td><i>Requires:</i> If <tt>t</tt> is a non-const<br/>...</td>
<td>Average Case<br/>...</td>
</tr></table>
</blockquote>


<hr>
<h3><a name="2223"></a>2223. <tt>shrink_to_fit</tt> effect on iterator validity</h3>

<p>
This wording is relative to N3936.
</p>

<ol>
<li><p>Change 21.3.1.4 [string.capacity] p14 as depicted:</p>

<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-14- <i><del>Remarks</del><ins>Effects</ins></i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce 
<tt>capacity()</tt> to <tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for 
implementation-specific optimizations. &mdash; <i>end note</i>] <ins>It does not increase <tt>capacity()</tt>, 
but may reduce <tt>capacity()</tt> by causing reallocation.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Linear in the size of the sequence.</ins>
<p/>
<ins>-?- <i>Remarks</i>: Reallocation invalidates all the references, pointers, and iterators referring to the 
elements in the sequence. If no reallocation happens, they remain valid.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.8.3 [deque.capacity] p5-p7 as depicted:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-5- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce memory use but does not change 
the size of the sequence. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i>] If an exception is thrown other than by the move constructor of a 
non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins>
<p/>
-6- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-7- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce memory use but does not change the
size of the sequence. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific
optimizations. &mdash; <i>end note</i>]</del><ins><tt>shrink_to_fit</tt> invalidates all the references, pointers, 
and iterators referring to the elements in the sequence.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.11.3 [vector.capacity] p7-p9 as depicted:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-7- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to <tt>size()</tt>. 
[<i>Note</i>: The request is non-binding to allow latitude for implementation-specific optimizations. &mdash; <i>end note</i>] 
It does not increase <tt>capacity()</tt>, but may reduce <tt>capacity()</tt> by causing reallocation. If an exception is 
thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins>
<p/>
-8- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-9- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to <tt>size()</tt>. 
[<i>Note</i>: The request is non-binding to allow latitude for implementation-specific optimizations. &mdash; <i>end 
note</i>] If an exception is thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt> there 
are no effects.</del><ins>Reallocation invalidates all the references, pointers, and iterators referring to the elements 
in the sequence. If no reallocation happens, they remain valid.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.11.5 [vector.modifiers] p1 as depicted:</p>

<blockquote>
<p>
-1- <i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. <ins>Reallocation invalidates all 
the references, pointers, and iterators referring to the elements in the sequence.</ins> If no reallocation happens,
all the iterators and references before the insertion point remain valid. [&hellip;]
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2578"></a>2578. Iterator requirements should reference iterator traits</h3>

After [iterator.requirements.general]/5, insert the following new paragraph:

<blockquote>
<p>
<ins>
-?- In addition to the requirements in this sub-clause, the nested <em>typedef-name</em>s specified
in ([iterator.traits]) shall be provided for the iterator type. [<i>Note:</i>
Either the iterator type must provide the <em>typedef-name</em>s directly (in which
case iterator_traits pick them up automatically), or an iterator_traits
specialization must provide them. <i>-end note</i>]
</ins>
</p>
</blockquote>


<hr>
<h3><a name="2519"></a>2519. Iterator <tt>operator-=</tt> has gratuitous undefined behaviour</h3>

<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Change Table 110 "Random access iterator requirements (in addition to
bidirectional iterator)" as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 110 &mdash; Random access iterator requirements (in addition to
bidirectional iterator)</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational<br/>semantics</th>
<th align="center">Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>r -= n</tt>
</td>

<td>
<tt>X&amp;</tt>
</td>

<td>
<tt>return r += -n;</tt>
</td>

<td>
<ins>pre: the absolute value of <tt>n</tt> is in the range of representable values of <tt>difference_type</tt>.</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2544"></a>2544. <tt>istreambuf_iterator(basic_streambuf&lt;charT, traits&gt;* s)</tt> effects unclear when <tt>s</tt> is <tt>0</tt></h3>

<p>This wording is relative to N4606.</p>

<ol>
<li>
<p>Change 24.6.3.2 [istreambuf.iterator.cons] as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The proposed wording changes also performs some editorial clean-up of the existing mismatches
of the declarations in the class template synopsis and the individual member specifications. The below wording is 
simplified by requiring <tt>sbuf_</tt> to be a null pointer for an end-of-stream iterator value, 
since I have not yet seen any implementation where this requirement does not hold. Even if there <em>were</em> such an 
implementation, this would still be conforming, because concrete exposition-only member values are not part of public 
API. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
<blockquote>
<p>
<ins>For each <tt>istreambuf_iterator</tt> constructor in this section, an end-of-stream iterator is 
constructed if and only if the exposition-only member <tt>sbuf_</tt> is initialized with a null 
pointer value.</ins>
</p>
<pre>
constexpr istreambuf_iterator() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>nullptr</tt></ins><del>Constructs the end-of-stream iterator</del>.
</p>
</blockquote>
<pre>
istreambuf_iterator(<del>basic_istream&lt;charT,traits&gt;</del><ins>istream_type</ins>&amp; s) noexcept;
<del>istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s) noexcept;</del>
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>s.rdbuf()</tt></ins><del>Constructs 
an <tt>istreambuf_iterator&lt;&gt;</tt> that uses the <tt>basic_streambuf&lt;&gt;</tt> object 
<tt>*(s.rdbuf())</tt>, or <tt>*s</tt>, respectively. Constructs 
an end-of-stream iterator if <tt>s.rdbuf()</tt> is null</del>.
</p>
</blockquote>
<pre>
<ins>istreambuf_iterator(streambuf_type* s) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes <tt>sbuf_</tt> with <tt>s</tt>.</ins>
</p>
</blockquote>
<pre>
istreambuf_iterator(const proxy&amp; p) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>p.sbuf_</tt></ins><del>Constructs a <tt>istreambuf_iterator&lt;&gt;</tt> 
that uses the <tt>basic_streambuf&lt;&gt;</tt> object pointed to by the <tt>proxy</tt> object's constructor argument 
<tt>p</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2747"></a>2747. Possibly redundant <tt>std::move</tt> in [alg.foreach]</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 25.3.4 [alg.foreach] as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class Function&gt;
  Function for_each(InputIterator first, InputIterator last, Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Returns:</i> <tt><del>std::move(</del>f<del>)</del></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2166"></a>2166. Heap property underspecified?</h3>

<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 25.5.6 [alg.heap.operations] as indicated:</p>

<blockquote class="note">
<p>
Note to project editor: As a drive-by editorial adjustment, please replace the
current enumerated list format by numbered bullet items.
</p>
</blockquote>

<blockquote>
<p>
-1- A <em>heap</em> is a particular organization of elements in a range between two random access iterators 
<code>[a, b)</code><del>. Its two key properties are</del><ins>such that</ins>:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <del>There is no element greater than <tt>*a</tt> in the range and</del>
<ins>With <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>N</mi><mo>=</mo><mi mathvariant="monospace" mathsize="small">b</mi><mo>-
</mo><mi mathvariant="monospace" mathsize="small">a</mi></math>, 
for all <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math>,
<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>N</mi></math>,
<code>comp(a[</code><math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo rspace="0.3em" lspace="0em" stretchy="true" fence="true" form="prefix">&lfloor;</mo>
  <mrow>
	<mfrac linethickness="1">
		<mrow>
			<mi>i</mi>
			<mo>-</mo>
			<mn>1</mn>
		</mrow>
		<mn>2</mn>
	</mfrac>
  </mrow>
  <mo rspace="0em" lspace="0.3em" stretchy="true" fence="true" form="postfix">&rfloor;</mo>
</math><code>], a[<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math>])</code> is <tt>false</tt>.</ins>
</p>
<blockquote class="note">
<p>
[Note to the project editor: In LaTeX the above insertion should be expressed as follows:
<p/>
With $N = <code>b</code>-<code>a</code>$, for all $i$, $0 &lt; i &lt; N$,
<code>comp(a[$\left \lfloor{\frac{i-1}{2}}\right \rfloor$], a[$i$])</code> is <code>false</code>.]
</p>
</blockquote>
</li>
<li><p>(1.2) &mdash; <tt>*a</tt> may be removed by <tt>pop_heap()</tt>, or a new element added by <tt>push_heap()</tt>, in 
&#x1d4aa;(log(<i>N</i>)) time.
</p>
</li>
</ol>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2699"></a>2699. Missing restriction in [numeric.requirements]</h3>

<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Adjust 26.3 [numeric.requirements]/1 as indicated:</p>

<blockquote>
<p>
-1- The <tt>complex</tt> and <tt>valarray</tt> components are parameterized by the type of information they contain and
manipulate. [&hellip;]
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <tt>T</tt> is not an abstract class (it has no pure virtual member functions);</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(1.8) &mdash; If <tt>T</tt> is a class, its assignment operator, copy and default constructors, and 
destructor shall correspond to each other in the following sense: <ins>Initialization of raw storage using 
the copy constructor on the value of <tt>T()</tt>, however obtained, is semantically equivalent to value 
initialization of the same raw storage.</ins> Initialization of raw storage using the 
default constructor, followed by assignment, is semantically equivalent to initialization of raw storage 
using the copy constructor. Destruction of an object, followed by initialization of its raw storage using 
the copy constructor, is semantically equivalent to assignment to the original object.
[<i>Note</i>: This rule states<ins>, in part,</ins> that there shall not be any subtle differences in the 
semantics of initialization versus assignment. This gives an implementation considerable flexibility in how 
arrays are initialized.
[<i>Example</i>: An implementation is allowed to initialize a <tt>valarray</tt> by allocating storage using the 
<tt>new</tt> operator (which implies a call to the default constructor for each element) and then assigning each
element its value. Or the implementation can allocate raw storage and use the copy constructor to
initialize each element. &mdash; <i>end example</i>]
If the distinction between initialization and assignment is important for a class, or if it fails to satisfy any
of the other conditions listed above, the programmer should use <tt>vector</tt> (23.3.11) instead of <tt>valarray</tt>
for that class; &mdash; <i>end note</i>]</p></li>
</ol>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2759"></a>2759. <tt>gcd</tt> / <tt>lcm</tt> and <tt>bool</tt> for the WP</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Adjust 26.8.13 [numeric.ops.gcd] p2 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; gcd(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Adjust 26.8.14 [numeric.ops.lcm] p2 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; lcm(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2735"></a>2735. <tt>std::abs(short)</tt>, <tt>std::abs(signed char)</tt> and others should return <tt>int</tt> instead of 
<tt>double</tt> in order to be compatible with C++98 and C</h3>

<p>This wording is relative to N4606.</p>
<ol>
<li><p>Modify 26.9.1 [cmath.syn] as indicated:</p>

<blockquote>
<p>
-2- For each set of overloaded functions within <tt>&lt;cmath&gt;</tt>,
 <ins>with the exception of <tt>abs</tt>, </ins> there shall be additional
overloads sufficient to ensure:
</p>
<ol>
<li><p>If any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>long double</tt>, then
all arguments of arithmetic type (3.9.1) corresponding to <tt>double</tt> parameters are effectively cast to
<tt>long double</tt>.</p></li>
<li><p>Otherwise, if any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>double</tt>
or an integer type, then all arguments of arithmetic type corresponding to <tt>double</tt> parameters are
effectively cast to <tt>double</tt>.</p></li>
<li><p>Otherwise, all arguments of arithmetic type corresponding to <tt>double</tt> parameters have type <tt>float</tt>.</p></li>
</ol>
<p><ins>[<i>Note:</i> <tt>abs</tt> is exempted from these rules in order to stay compatible with C. &mdash; <i>end note</i>]</ins></p>
<p>
See also: ISO C 7.5, 7.10.2, 7.10.6.
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2765"></a>2765. Did LWG 1123 go too far?</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 27.5.3.1.6 [ios::Init] p3 as indicated:</p>
<blockquote><p>
-3- The objects are constructed and the associations are established at some time prior to or during the first
time an object of class <tt>ios_base::Init</tt> is constructed, and in any case before the body of <tt>main</tt> begins
execution.(footnote 293) The objects are not destroyed during program execution.(footnote 294) The results of including 
<tt>&lt;iostream&gt;</tt> in a translation unit shall be as if <tt>&lt;iostream&gt;</tt> defined an instance of 
<tt>ios_base::Init</tt> with static storage duration. <del>Similarly, the entire program shall behave as if there were at 
least one instance of <tt>ios_base::Init</tt> with static storage duration.</del>
</p></blockquote>
</li>
</ol>


<hr>
<h3><a name="2221"></a>2221. No formatted output operator for <tt>nullptr</tt></h3>

<p>
This wording is relative to N4606
</p>

<ol>
<li><p>Insert the signature into 27.7.3.1 [ostream], class template <tt>basic_ostream</tt> synopsis, as follows:</p>

<blockquote class="note">
<p>
[<i>Drafting notes:</i> Why member?  Don't want to define a new category of inserters just for this.]
</p>
</blockquote>

<blockquote>
<pre>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_ostream
    : virtual public basic_ios&lt;charT, traits&gt; {
  public:
    [&hellip;]
    basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(const void* p);
    <ins>basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(nullptr_t);</ins>
    basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(
      basic_streambuf&lt;char_type, traits&gt;* sb);
    [&hellip;]
  };
</pre>
</blockquote>
</li>

<li><p>Append the following new paragraphs to 27.7.3.6.3 [ostream.inserters]:</p>

<blockquote>
<pre>
basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;
  (basic_streambuf&lt;charT, traits&gt;* sb);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
<pre>
<ins>basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(nullptr_t);</ins>
</pre>
<blockquote>
<p>
<ins>-??- <i>Effects:</i> Equivalent to <tt>return *this &lt;&lt; s;</tt> where
<tt>s</tt> is an implementation-defined NTCTS.</ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>


<hr>
<h3><a name="2534"></a>2534. Constrain rvalue stream operators</h3>

<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Modify 27.7.3.9 [ostream.rvalue] as indicated:</p>
<blockquote>
<pre>
template &lt;class charT, class traits, class T&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <tt>os &lt;&lt; x</tt>
<p/>
-2- <i>Returns</i>: <tt>os</tt>
<p/>
<ins>-?- <i>Remarks</i>: This function shall not participate in overload resolution unless the expression 
<tt>os &lt;&lt; x</tt> is well-formed.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.7.2.6 [istream.rvalue] as indicated:</p>
<blockquote>
<pre>
template &lt;class charT, class traits, class T&gt;
  basic_istream&lt;charT, traits&gt;&amp;
  operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp;&amp; is, T&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <tt>is &gt;&gt; x</tt>
<p/>
-2- <i>Returns</i>: <tt>is</tt>
<p/>
<ins>-?- <i>Remarks</i>: This function shall not participate in overload resolution unless the expression 
<tt>is &gt;&gt; x</tt> is well-formed.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2680"></a>2680. Add "Equivalent to" to filesystem</h3>

<p>
</p>

<p><i><section>27.10.8.4.5 [path.modifiers]</section></i></p>
<blockquote>
<pre>path&amp; replace_filename(const path&amp; replacement);</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins></p>
<pre>remove_filename();
operator/=(replacement);</pre>
</blockquote>
</blockquote>

<p><i><section>27.10.8.6 [path.non-member]</section></i></p>
<blockquote>
<pre>void swap(path&amp; lhs, path&amp; rhs) noexcept;</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins> <code>lhs.swap(rhs)</code></p>
</blockquote>
</blockquote>

<p><i><section>27.10.8.6.1 [path.io]</section></i></p>
<blockquote>
<pre>template &lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins> <code>os &lt;&lt; quoted(p.string&lt;charT, traits&gt;())</code>.</p>
<pre></pre>
</blockquote>
</blockquote>

<p><i><section>27.10.8.6.1 [path.io]</section></i></p>
<blockquote>
<pre>template &lt;class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins></p>
<pre>basic_string&lt;charT, traits&gt; tmp;
is &gt;&gt; quoted(tmp);
p = tmp;</pre>
</blockquote>
</blockquote>

<p><i><section>27.10.15.3 [fs.op.copy]</section></i></p>
<blockquote>
<pre>void copy(const path&amp; from, const path&amp; to);
void copy(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins> <code>copy(from, to, copy_options::none)</code> or <code>copy(from, to, 
copy_options::none, ec)</code>, respectively.</p>
</blockquote>
</blockquote>

<p><i><section>27.10.15.5 [fs.op.copy_symlink]</section></i></p>
<blockquote>
<pre>void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink);
void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink,
  error_code&amp; ec) noexcept;</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins> <code><i>function</i>(read_symlink(existing_symlink), new_symlink)</code> or
<code><i>function</i>(read_symlink(existing_symlink, ec), new_symlink, ec)</code>, respectively, 
where <code><i>function</i></code>
is <code>create_symlink</code> or <code>create_directory_symlink</code>, as appropriate.</p>
</blockquote>
</blockquote>




<hr>
<h3><a name="2732"></a>2732. Questionable specification of <tt>path::operator/=</tt> and <tt>path::append</tt></h3>

<p>This wording is relative to N4606.</p>
<ol>
<li><p>Edit 27.10.8.4.3 [path.append]/4-5 as indicated:</p>

<blockquote>
<pre>
template &lt;class Source&gt;
  path&amp; operator/=(const Source&amp; source);
template &lt;class Source&gt;
  path&amp; append(const Source&amp; source);
</pre>
<blockquote>
<p><ins>-?- <i>Effects:</i> Equivalent to <tt>return operator/=(path(source));</tt>.</ins></p>
</blockquote>
<pre>
template &lt;class InputIterator&gt;
  path&amp; append(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>-4- <i>Effects:</i> <ins>Equivalent to <tt>return operator/=(path(first, last));</tt>.</ins><del>Appends <tt>path::preferred_separator</tt> to <tt>pathname</tt>,
converting format and encoding if required (27.10.8.2 [path.cvt]), unless:</del></p>
<ol style="list-style-type: none">
<li><del>&mdash; an added <i>directory-separator</i> would be redundant, or</del></li>
<li><del>&mdash; an added <i>directory-separator</i> would change an relative path to an absolute
path, or</del></li>
<li><del>&mdash; <tt>source.empty()</tt> is <tt>true</tt>, or</del></li>
<li><del>&mdash; <tt>*source.native().cbegin()</tt> is a <i>directory-separator</i>.</del></li>
</ol>
<p><del>Then appends the effective range of <tt>source</tt> (27.10.8.3 [path.req]) or the
range <tt>[first, last)</tt> to <tt>pathname</tt>, converting format and encoding if required
(27.10.8.2 [path.cvt]).</del></p>
<p><del>-5- <i>Returns:</i> <tt>*this</tt>.</del></p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2664"></a>2664. <code>operator/</code> (and other append) semantics not useful if argument has root</h3>

<p>This wording is relative to N4606, and assumes that the PR for <a href="2732">2732</a> is applied.</p>
<ol>
<li>Change 27.10.8.4.3 [path.append] as indicated:
<pre>path&amp; operator/=(const path&amp; p);</pre>
<blockquote>
  <p><ins>-?- <i>Requires:</i> <code>!p.has_root_name()</code>.</ins></p>
  <p>-2- <i>Effects:</i> Appends <code>path::preferred_separator</code> to <tt>pathname</tt> unless:</p>
  <ul style="list-style-type: none">
  <li>&mdash; an added <i>directory-separator</i> would be redundant, or</li>
  <li>&mdash; an added <i>directory-separator</i> would change a relative path to an absolute path
  [<i>Note:</i> An empty path is relative. &mdash; <i>end note</i>], or</li>
  <li>&mdash; <code>p.empty()</code> is <tt>true</tt>, or</li>
  <li>&mdash; <code>*p.native().cbegin()</code> is a <i>directory-separator</i>.</li>
  </ul>
  <p>Then appends <code>p.native()</code> to <tt>pathname</tt>.</p>
  <p>-3- <i>Returns:</i> <code>*this</code>.</p>
</blockquote>
</li>
<li>Change 27.10.8.6 [path.non-member] p13 as indicated:
<pre>path operator/(const path&amp; lhs, const path&amp; rhs);</pre>
<blockquote>
<p>-13- <em><del>Returns</del><ins>Effects</ins>:</em> <ins>Equivalent to </ins><code>
<ins>return </ins>path(lhs) /= rhs;</code>.</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2678"></a>2678. <tt>std::filesystem</tt> enum classes overspecified</h3>

<ol>
<li>
<p>
Strike the "Value" column from:
</p>
<ul>
  <li><p>27.10.10.1 [enum.file_type], Table 145 Enum class <code>file_type</code> </p></li>
  <li><p>27.10.10.2 [enum.copy_options], Table 146 Enum class <code>copy_options</code> </p></li>
  <li><p>27.10.10.4 [enum.directory_options], Table 148 Enum class <code>enum.directory_options</code>.</p></li>
</ul>
</li>

<li><p>Change 27.10.10.1 [enum.file_type] Table 145 Enum class <code>file_type</code> as indicated:</p>

<blockquote>
 <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse">
    <tr>
      <td><b>Constant</b></td>
      <td><b>Meaning</b></td>
    </tr>
    <tr>
      <td><code>none</code></td>
      <td>The type of the file has not been determined or an error occurred 
      while trying to determine the type.</td>
    </tr>
    <tr>
      <td><code>not_found</code></td>
      <td>Pseudo-type indicating the file was not found. [ <i>Note:</i>
      The file not being
      found is not considered an error while determining the type of a file. 
      <i>—end note</i> ]</td>
    </tr>
    <tr>
      <td><code>regular</code></td>
      <td>Regular file</td>
    </tr>
    <tr>
      <td><code>directory</code></td>
      <td>Directory file</td>
    </tr>
    <tr>
      <td><code>symlink</code></td>
      <td>Symbolic link file</td>
    </tr>
    <tr>
      <td><code>block</code></td>
      <td>Block special file</td>
    </tr>
    <tr>
      <td><code>character</code></td>
      <td>Character special file</td>
    </tr>
    <tr>
      <td><code>fifo</code></td>
      <td>FIFO or pipe file</td>
    </tr>
    <tr>
      <td><code>socket</code></td>
      <td>Socket file</td>
    </tr>
    <tr>
      <td><ins>implementation-<br/>defined</ins></td>
      <td><ins>Implementations that support file systems having file types
      in addition to the above file_type types shall supply
      implementation-defined <code>file_type</code> 
      constants to separately identify each of those additional
      file types</ins></td>
    </tr>
    <tr>
      <td><code>unknown</code></td>
      <td><del>The file does exist, but is of an operating system dependent type not 
      covered by any of the other cases or the process does not have permission to query
      the file type</del> <ins>The file exists but the type could not be determined</ins></td>
    </tr>
  </table>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2681"></a>2681. <code>filesystem::copy()</code> cannot copy symlinks</h3>

<p>Modify paragraph 3 of 27.10.15.3 [fs.op.copy] as shown:</p>

<blockquote>
<p><i>Effects:</i> Before the first use of <code>f</code> and <code>t</code>:<br/><br/>
 — If <code>(options &amp; copy_options::create_symlinks) != copy_options::none ||
(options &amp; copy_options::skip_symlinks) != copy_options::none</code>
then <code>auto f = symlink_status(from)</code> and if needed <code>auto t = symlink_status(to)</code>.<br/><br/>
<ins>
 — Otherwise, if <code>(options &amp; copy_options::copy_symlinks) != copy_options::none</code>
then <code>auto f = symlink_status(from)</code> and if needed <code>auto t = status(to)</code>.
</ins><br/>
 — Otherwise, <code>auto f = status(from)</code> and if needed <code>auto t = status(to)</code>.
</p>
</blockquote>


<hr>
<h3><a name="2712"></a>2712. <tt>copy_file(from, to, ...)</tt> has a number of unspecified error conditions</h3>

<p>This wording is relative to N4582.</p>
<ol>
<li><p>Modify 27.10.15.4 [fs.op.copy_file] as indicated:</p>

<blockquote>
<pre>
bool copy_file(const path&amp; from, const path&amp; to, copy_options options);
bool copy_file(const path&amp; from, const path&amp; to, copy_options options,
               error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Requires:</i> At most one constant from each <tt>copy_options</tt> option group (27.10.10.2) is present in
<tt>options</tt>.
<p/>
-4- <i>Effects:</i> Report a file already exists error as specified in Error reporting (27.5.6.5) if:
</p>
<ul>
<li><ins><tt>!is_regular_file(from)</tt>, or</ins></li>
<li><ins><tt>exists(to)</tt> and <tt>!is_regular_file(to)</tt>, or</ins></li>
<li><tt>exists(to)</tt> and <tt>equivalent(from, to)</tt>, or</li>
<li><tt>exists(to)</tt> and <tt>(options &amp; (copy_options::skip_existing | copy_options::overwrite_existing | 
copy_options::update_existing)) == copy_options::none</tt>.</li>
</ul>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2722"></a>2722. <tt>equivalent</tt> incorrectly specifies throws clause</h3>

<p>This wording is relative to N4594.</p>
<ol>
<li><p>Modify 27.10.15.13 [fs.op.equivalent] as follows:</p>

<blockquote>
<pre>
bool equivalent(const path&amp; p1, const path&amp; p2);
bool equivalent(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-1- Let <tt>s1</tt> and <tt>s2</tt> be <tt>file_status</tt>s, determined as if by <tt>status(p1)</tt> and <tt>status(p2)</tt>, respectively.
<p/>
-2- <i>Effects:</i> Determines <tt>s1</tt> and <tt>s2</tt>. <ins>If <tt>(!exists(s1) &amp;&amp; !exists(s2)) || 
(is_other(s1) &amp;&amp; is_other(s2))</tt> an error is reported (27.10.7 [fs.err.report]).</ins>
<p/>
-3- <i>Returns:</i> <tt>true</tt>, if <tt>s1 == s2</tt> and 
<tt>p1</tt> and <tt>p2</tt> resolve to the same file system entity, else <tt>false</tt>. The signature with argument 
<tt>ec</tt> returns <tt>false</tt> if an error occurs.
<p/>
-4- Two paths are considered to resolve to the same file system entity if two candidate entities reside on the
same device at the same location. This is determined as if by the values of the POSIX <tt>stat</tt> structure,
obtained as if by <tt>stat()</tt> for the two paths, having equal <tt>st_dev</tt> values and equal <tt>st_ino</tt> values.
<p/>
-5- <i>Throws:</i> <del><tt>filesystem_error</tt> if <tt>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; 
is_other(s2))</tt>, otherwise a</del><ins>A</ins>s specified in <del>E</del><ins>e</ins>rror reporting 
(27.10.7 [fs.err.report]).
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2672"></a>2672. Should is_empty use error_code in its specification?</h3>

<ol>
<li>
  <blockquote>
  <pre>
    bool is_empty(const path&amp; p);
    bool is_empty(const path&amp; p, error_code&amp; ec) noexcept;
  </pre>
  <blockquote>
    <p>
      <i>Effects:</i>
    </p>
    <ul>
      <li>
        Determine <code>file_status s</code>, as if by
        <ins>
          <code>status(p)</code> or
        </ins> <code>status(p, ec)</code><ins>, respectively</ins>.
      </li>
      <li>
        <ins>
          For the signature with argument <code>ec</code>, return <code>false</code> if
          an error occurred.
        </ins>
      </li>
      <li>
        <ins>
          Otherwise, if <code>is_directory(s)</code>:
        </ins>
        <ul>
          <li>
            <ins>
              Create <code>directory_iterator itr</code>, as if by
              <code>directory_iterator(p)</code>
              or <code>directory_iterator(p, ec)</code>, respectively.
            </ins>
          </li>
          <li>
            <ins>
              For the signature with argument <code>ec</code>, return <code>false</code> if
              an error occurred.
            </ins>
          </li>
          <li>
            <ins>
              Otherwise, return <code>itr == directory_iterator()</code>.
            </ins>
          </li>
        </ul>
      </li>
      <li>
        <ins>Otherwise:</ins>
        <ul>
          <li>
            <ins>
              Determine <code>uintmax_t sz</code>, as if by <code>
                file_size(p)
              </code> or<code> file_size(p, ec)</code>, respectively
            </ins>.
          </li>
          <li>
            <ins>
              For the signature with argument <code>ec</code>, return <code>false</code> if
              an error occurred.
            </ins>
          </li>
          <li>
            <ins>
              Otherwise, return <code>sz == 0</code>.
            </ins>
          </li>
        </ul>
      </li>
    </ul>
    <p>
      <del>
      <i>Returns:</i>
        <code>
          is_directory(s) ? directory_iterator(p) == directory_iterator()
          : file_size(p) == 0;
        </code>
      </del>
    </p>
    <blockquote>
      <p>
        <del>
          The signature with argument <code>ec</code> returns <code>false</code> if
          an error occurs.
        </del>
      </p>
    </blockquote>
    <p>
      <i>Throws:</i> As specified in Error reporting (7).
    </p>
  </blockquote>
  </blockquote>
</li>
</ol>


<hr>
<h3><a name="2503"></a>2503. multiline option should be added to <tt>syntax_option_type</tt></h3>

<p>This wording is relative to N4431.</p>

<ol>
<li><p>Change 28.5.1 [re.synopt] as indicated:</p>

<blockquote><pre>
namespace std::regex_constants {
  typedef T1 syntax_option_type;
  constexpr syntax_option_type icase = <i>unspecified</i> ;
  constexpr syntax_option_type nosubs = <i>unspecified</i> ;
  constexpr syntax_option_type optimize = <i>unspecified</i> ;
  constexpr syntax_option_type collate = <i>unspecified</i> ;
  constexpr syntax_option_type ECMAScript = <i>unspecified</i> ;
  constexpr syntax_option_type basic = <i>unspecified</i> ;
  constexpr syntax_option_type extended = <i>unspecified</i> ;
  constexpr syntax_option_type awk = <i>unspecified</i> ;
  constexpr syntax_option_type grep = <i>unspecified</i> ;
  constexpr syntax_option_type egrep = <i>unspecified</i> ;
  <ins>constexpr syntax_option_type multiline = <i>unspecified</i> ;</ins>
}
</pre></blockquote>
</li>

<li><p>Change 28.5.2 [re.matchflag], Table 138 &mdash; "<tt>syntax_option_type</tt> effects" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 138 &mdash; <tt>syntax_option_type</tt> effects</caption>
<tr>
<th align="center">Element</th>
<th align="center">Effect(s) if set</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<ins><tt>multiline</tt></ins>
</td>
<td>
<ins>Specifies that <tt>^</tt> shall match the beginning of a line
and <tt>$</tt> shall match the end of a line, if the ECMAScript engine is
selected.</ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>


<hr>
<h3><a name="2589"></a>2589. <tt>match_results</tt> can't satisfy the requirements of a container</h3>

<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 28.10 [re.results] p2 as indicated:</p>
<blockquote><p>
-2- The class template <tt>match_results</tt> <del>shall satisfy</del><ins>satisfies</ins> the requirements of an allocator-aware container and of a
sequence container, <del>as specified in </del><ins>(</ins>23.2.3<ins>)</ins>, except that only operations defined for const-qualified sequence
containers are supported <ins>and the semantics of comparison functions are different from those required for a 
container</ins>.
</p></blockquote>
</li>
</ol>

<blockquote class="note">
<p>
[<i>Drafting note:</i> (Post-Issaquah) Due to the outdated N4567 wording the project editor accepted the following merge 
suggestion into N4606 wording: &mdash; <i>end drafting note</i>]
</p>
<blockquote>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 28.10 [re.results] p2 as indicated:</p>
<blockquote><p>
-2- The class template <tt>match_results</tt> satisfies the requirements of an
allocator-aware container and of a sequence container, <del>as specified in</del> 
<ins>(</ins>23.2.1 [container.requirements.general]<del> and</del><ins>,</ins> 
23.2.3 [sequence.reqmts]<ins>)</ins><del> respectively</del>, except that only 
operations defined for const-qualified sequence containers are supported <ins>and the 
semantics of comparison functions are different from those required for a container</ins>.
</p></blockquote>
</li>
</ol>

</blockquote>
</blockquote>


<hr>
<h3><a name="2584"></a>2584. <tt>&lt;regex&gt;</tt> ECMAScript <tt>IdentityEscape</tt> is ambiguous</h3>

<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 28.13 [re.grammar]/3 as indicated:</p>

<blockquote>
<p>
-3- The following productions within the ECMAScript grammar are modified as follows:
</p>
<blockquote><pre>
ClassAtom ::
  -
  ClassAtomNoDash
  ClassAtomExClass
  ClassAtomCollatingElement
  ClassAtomEquivalence
  
<ins>IdentityEscape ::
  SourceCharacter <b>but not</b> c</ins>
</pre></blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2556"></a>2556. Wide contract for <tt>future::share()</tt></h3>

<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 30.6.6 [futures.unique_future] as indicated:</p>

<blockquote>
<p>
-3- The effect of calling any member function other than the destructor, the move-assignment operator, <ins><tt>share</tt>,</ins> 
or <tt>valid</tt> on a <tt>future</tt> object for which <tt>valid() == false</tt> is undefined. [<i>Note</i>: Implementations 
are encouraged to detect this case and throw an object of type <tt>future_error</tt> with an error condition of 
<tt>future_errc::no_state</tt>. &mdash; <i>end note</i>]
</p>
<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class future {
  public:
    [&hellip;]
    shared_future&lt;R&gt; share() <ins>noexcept</ins>;
    [&hellip;]
  };
}
</pre></blockquote>
<p>
[&hellip;]
</p>
<pre>
shared_future&lt;R&gt; share() <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-12- <i>Returns</i>: <tt>shared_future&lt;R&gt;(std::move(*this))</tt>.
<p/>
-13- <i>Postcondition</i>: <tt>valid() == false</tt>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2531"></a>2531. <tt>future::get</tt> should explicitly state that the shared state is released</h3>

<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Modify 30.6.6 [futures.unique_future] as indicated:</p>
<blockquote><pre>
R future::get();
R&amp; future&lt;R&amp;&gt;::get();
void future&lt;void&gt;::get();
</pre>
<blockquote>
<p>
-14- <i>Note</i>: as described above, the template and its two required specializations differ only in the return
type and return value of the member function <tt>get</tt>.
<p/>
-15- <i>Effects</i>:
</p>
<ul>
<li><p><tt>wait()</tt>s until the shared state is ready, then retrieves the value stored in the shared state<del>.</del><ins>;</ins></p></li>
<li><p><ins>releases any shared state (30.6.4 [futures.state]).</ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2752"></a>2752. &quot;Throws:&quot; clauses of <tt>async</tt> and <tt>packaged_task</tt> are unimplementable</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 30.6.8 [futures.async] p6 to:</p>

<blockquote>
<p>
<em>Throws:</em> <tt>system_error</tt> if <tt>policy == launch::async</tt> and the implementation is unable to start a
new thread<ins>, or <tt>std::bad_alloc</tt> if memory for the internal data structures could not be allocated</ins>.
</p>
</blockquote>
</li>
<li><p>Change 30.6.9.1 [futures.task.members] p5 to:</p>

<blockquote>
<pre>
template &lt;class F&gt;
  packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre>
<blockquote>
<p>
<em>Throws:</em>
</p>
<ol style="list-style-type: none">
<li>
<ins>(?) &mdash; A</ins><del>a</del>ny exceptions thrown by the copy or move constructor of <tt>f</tt><ins>.</ins><del>, or </del>
</li>
<li>
<ins>(?) &mdash; For the first version,</ins> <tt>std::bad_alloc</tt> if memory for the internal data structures
could not be allocated<ins>.</ins>
</li>
<li>
<ins>(?) &mdash; For the second version, any exceptions thrown by
<tt>std::allocator_traits&lt;Allocator&gt;::template rebind_traits&lt;<em>unspecified</em>&gt;::allocate</tt></ins>.
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2758"></a>2758. <tt>std::string{}.assign("ABCDE", 0, 1)</tt> is ambiguous</h3>

<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.1 [basic.string] modify the synopsis for <tt>basic_string</tt> as follows:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
  public:
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos2, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; replace(size_type pos1, size_type n1,
                          <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                          size_type pos2, size_type n2 = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    int compare(size_type pos1, size_type n1,
                <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                size_type pos2, size_type n2 = npos) const;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>In 99 [string.append], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos, size_type n = npos);
</pre>
<blockquote>
<p>
-7- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos &gt; sv.size()</tt>.
<p/>
-8- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length 
<tt>rlen</tt> of the string to append as the smaller of <tt>n</tt> and <tt>sv.size() - pos</tt> 
and calls <tt>append(sv.data() + pos, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
<p/>
-9- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 99 [string.assign], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos, size_type n = npos);
</pre>
<blockquote>
<p>
-9- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos &gt; sv.size()</tt>.
<p/>
-10- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length 
<tt>rlen</tt> of the string to assign as the smaller of <tt>n</tt> and <tt>sv.size() - pos</tt> 
and calls <tt>assign(sv.data() + pos, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
<p/>
-11- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 99 [string.insert], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos2, size_type n = npos);
</pre>
<blockquote>
<p>
-6- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos1 &gt; size()</tt> or <tt>pos2 &gt; sv.size()</tt>.
<p/>
-7- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length <tt>rlen</tt> 
of the string to assign as the smaller of <tt>n</tt> and <tt>sv.size() - pos2</tt> and calls 
<tt>insert(pos1, sv.data() + pos2, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
<p/>
-8- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 99 [string.replace], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; replace(size_type pos1, size_type n1, 
                     <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos2, size_type n2 = npos);
</pre>
<blockquote>
<p>
-6- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos1 &gt; size()</tt> or <tt>pos2 &gt; sv.size()</tt>.
<p/>
-7- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length <tt>rlen</tt> 
of the string to be inserted as the smaller of <tt>n2</tt> and <tt>sv.size() - pos2</tt> and calls 
<tt>replace(pos1, n1, sv.data() + pos2, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
<p/>
-8- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 99 [string.compare], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording changes below are for the same part of the standard as <a href="2771">2771</a>. 
However, they do not conflict. This one changes the definition of the routine, while the other changes the "Effects".
&mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
int compare(size_type pos1, size_type n1,
            <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
            size_type pos2, size_type n2 = npos) const;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return basic_string_view&lt;charT, traits&gt;(this.data(), pos1, n1).compare(sv, pos2, n2);
<ins>}</ins>
</pre></blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>



<hr>
<h3><a name="2771"></a>2771. Broken <i>Effects</i> of some <tt>basic_string::compare</tt> functions in terms of <tt>basic_string_view</tt></h3>

<p>
This wording is relative to N4606.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording changes below are for the same part of the standard as <a href="2758">2758</a>. 
However, they do not conflict. This one changes the "Effects" of the routine, while the other changes the definition.
&mdash; <i>end drafting note</i>]
</p>
</blockquote>

<ol>
<li><p>Change 99 [string.compare] as indicated:</p>

<blockquote>
<pre>
int compare(size_type pos1, size_type n1,
            basic_string_view&lt;charT, traits&gt; sv) const;
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
return basic_string_view&lt;charT, traits&gt;(<del>this.</del>data(), <ins>size()).substr(</ins>pos1, n1).compare(sv);
</pre>
</blockquote>
</blockquote>
<pre>
int compare(size_type pos1, size_type n1,
            basic_string_view&lt;charT, traits&gt; sv,
            size_type pos2, size_type n2 = npos) const;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
return basic_string_view&lt;charT, traits&gt;(<del>this.</del>data(), <ins>size()).substr(</ins>pos1, n1).compare(sv<del>,</del><ins>.substr(</ins>pos2, n2<ins>)</ins>);
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>


<hr>
<h3><a name="2536"></a>2536. What should <tt>&lt;complex.h&gt;</tt> do?</h3>

<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Add a new paragraph <em>before</em> D.4 [depr.c.headers]/2:</p>
<blockquote><p>
<ins>-?- The header <tt>&lt;complex.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ccomplex&gt;</tt>.</ins>
</p></blockquote>
</li>

<li><p>Change in D.4 [depr.c.headers]/2:</p>
<blockquote><p>
-2- Every <ins>other</ins> C header, each of which has a name of the form <tt>name.h</tt>, behaves as if each name placed 
in the standard library namespace by the corresponding <tt>cname</tt> header is placed within the global namespace scope. 
It is unspecified whether these names are first declared or defined within namespace scope (3.3.6) of the namespace
<tt>std</tt> and are then injected into the global namespace scope by explicit <i>using-declarations</i> (7.3.3).
</p></blockquote>
</li>
</ol>


</body>
</html>
