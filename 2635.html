<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2635: [filesys.ts] [PDTS] directory_options::skip_permission_denied is not used</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-15 at 21:11:18 UTC</p>
<hr>
<h3><a name="2635" href="2635">2635.</a> [filesys.ts] [PDTS] <tt>directory_options::skip_permission_denied</tt> is not used</h3>
<p><b>Section:</b> 99 [filesys.ts::fs.filesystem.synopsis] <b>Status:</b> <a href="lwg-active.html#WP">WP</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2014-01-30 <b>Last modified:</b> 2016-11-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.filesystem.synopsis">issues</a> in [filesys.ts::fs.filesystem.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#WP">WP</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
<tt>directory_options::skip_permission_denied</tt> is not used.
</p>
  <p><i>[2014-04-13 Beman: <tt>skip_permissions_denied</tt> not being used is a
  symptom of a more serious problem; two <tt>directory_itorator</tt> constructors
  are missing <tt>directory_options</tt> arguments and a description of how they
  are used. Proposed wording provided.]</i></p>

  <p><i>[17 Jun 2014 LWG requests two signatures rather than one with default argument. Beman updates wording.]</i></p>



<p><b>Proposed resolution:</b></p>
  <p>
    <i>Change 13  [class.directory_iterator]:</i>
  </p>
  <blockquote>
    <pre>
      directory_iterator() noexcept;
      explicit directory_iterator(const path&amp; p);
      <ins>directory_iterator(const path&amp; p, directory_options options</ins>);
      directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
      <ins>directory_iterator(const path&amp; p,</ins>
      <ins>directory_options options, error_code&amp; ec) noexcept;</ins>
      directory_iterator(const directory_iterator&amp;) = default;
      directory_iterator(directory_iterator&amp;&amp;) = default;
      ~directory_iterator();
    </pre>
  </blockquote>
  <p>
    <i>Change 13.1 directory_iterator members [directory_iterator.members]:</i>
  </p>
  <blockquote>
    <pre>
      explicit directory_iterator(const path&amp; p);
      <ins>directory_iterator(const path&amp; p, directory_options options</ins>);
      directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
      <ins>directory_iterator(const path&amp; p,</ins>
      <ins>directory_options options, error_code&amp; ec) noexcept;</ins>
    </pre>
    <p>
      <i>Effects:</i> For the directory that <code>p</code> resolves to,
      constructs an iterator for the first element in a sequence of <code>
        directory_entry
      </code> elements representing the files in the directory, if
      any; otherwise the end iterator.
    </p>
    <p>
      <ins>
        However, if <code>options &amp; directory_options::skip_permissions_denied != directory_options::none</code>
        and construction encounters an error indicating that permission to access&nbsp;
        <code>p</code> is denied, constructs the end iterator and does not report an
        error.
      </ins>
    </p>
  </blockquote>
  <p>
    <i>
      Change 14  <a name="Class-recursive_directory_iterator">
        Class <code>recursive_directory_iterator</code>
        [class.rec.dir.itr]
      </a>:
    </i>
  </p>
  <blockquote>
    <pre>
      explicit recursive_directory_iterator(const path&amp; p<del>,</del>
      <del>directory_options options = directory_options::none</del>);
      <ins>recursive_directory_iterator(const path&amp; p, directory_options options);</ins>
      recursive_directory_iterator(const path&amp; p,
      directory_options options, error_code&amp; ec) noexcept;
      recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
    </pre>
  </blockquote>
  <p>
    <i>Change 14.1 recursive_directory_iterator members [rec.dir.itr.members]:</i>
  </p>
  <blockquote>
    <pre>
      explicit recursive_directory_iterator(const path&amp; p<del>,</del>
      <del>directory_options options = directory_options::none</del>);
      <ins>recursive_directory_iterator(const path&amp; p, directory_options options);</ins>
      recursive_directory_iterator(const path&amp; p,
      directory_options options, error_code&amp; ec) noexcept;
      recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
    </pre>
    <p>
      <i>Effects:</i>&nbsp; Constructs a iterator representing the first entry in the
      directory <code>p</code> resolves to, if any; otherwise, the end iterator.
    </p>
    <p>
      <ins>
        However, if <code>options &amp; directory_options::skip_permissions_denied != directory_options::none</code>
        and construction encounters an error indicating that permission to access&nbsp;
        <code>p</code> is denied, constructs the end iterator and does not report an
        error.
      </ins>
    </p>
  </blockquote>
  <p>
    <i>Change 14.1 recursive_directory_iterator members [rec.dir.itr.members]:</i>
  </p>
  <blockquote>
    <pre>
      recursive_directory_iterator&amp; operator++();
      recursive_directory_iterator&amp; increment(error_code&amp; ec);
    </pre>
    <p>
      <i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.
    </p>
    <p>
      <i>Effects:</i> As specified by C++11 ยง 24.1.1 Input iterators, except
      that:
    </p>
    <ul>
      <li>
        If there are no more entries at this depth, then if <code>depth()!= 0</code>
        iteration over the parent directory resumes; otherwise <code>
          *this =
          recursive_directory_iterator()
        </code>.
      </li>
      <li>
        Otherwise if <code>
          recursion_pending() &amp;&amp; is_directory(this-&gt;status())
          &amp;&amp; (!is_symlink(this-&gt;symlink_status()) || (options() &amp;
          directory_options::follow_directory_symlink) != <del>0</del> <ins>directory_options::none</ins>)
        </code> then <ins>either</ins> directory
        <code>(*this)-&gt;path()</code> is recursively iterated into
        <ins>
          or, if <code>
            options() &amp; directory_options::skip_permissions_denied != directory_options::none
          </code>
          and an error occurs indicating that permission to access directory
          <code>(*this)-&gt;path()</code> is denied, then directory <code>(*this)-&gt;path()</code> is
          treated as an empty directory and no error is reported
        </ins>.
      </li>
    </ul>
  </blockquote>





</body>
</html>
