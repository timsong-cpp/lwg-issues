<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3622: Misspecified transitivity of equivalence in &sect;[unord.req.general]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3><a name="3622" href="lwg-active.html#3622">3622.</a> Misspecified transitivity of equivalence in &sect;[unord.req.general]</h3>
<p><b>Section:</b> 24.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2021-10-20 <b>Last modified:</b> 2023-02-09 02:40:28 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The paper <a href="https://wg21.link/P2077R3">P2077R3</a> ("Heterogeneous erasure overloads for associative containers") 
adds a new variable <tt>kx</tt> with specific meaning for use in the Table of Unordered Associative 
Container Requirements, 24.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> p11, which is meant to stand for an 
equivalence class of heterogeneous values that can be compared with container keys.
<p/>
One property required of <tt>kx</tt> is transitivity of equality/equivalence, but this is currently specified as:
</p>
<blockquote><p>
"<tt>kx</tt> is a value such that [&hellip;] <tt>(eq(r1, kx) &amp;&amp; eq(r1, r2)) == eq(r2, kx)</tt> [&hellip;], 
where <tt>r1</tt> and <tt>r2</tt> are [any] keys".
</p></blockquote>
<p>
But this doesn't seem right. Transitivity means that <tt>eq(r1, kx) &amp;&amp; eq(r1, r2)</tt> being 
true implies <tt>eq(r2, kx)</tt> being true, but it does <em>not</em> imply that both sides are equal 
in general. In particular, <tt>eq(r2, kx)</tt> can be true even when <tt>eq(r1, kx) &amp;&amp; eq(r1, r2)</tt> 
is false.
<p/>
More abstractly, equality is transitive, but inequality is not.
<p/>
The new wording appears to have been copied from the pre-existing wording for the variable "<tt>ke</tt>", which 
suffers from the same problem, and so we propose to fix both cases.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">


<p>
This wording is relative to <a href="https://wg21.link/n4901">N4901</a>.
</p>

<ol>
<li><p>Modify 24.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> as indicated:</p>

<blockquote>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(11.19) &mdash; <tt>ke</tt> is a value such that</p>
<ol style="list-style-type: none">
<li><p>(11.19.1) &mdash; <tt>eq(r1, ke) == eq(ke, r1)</tt>,</p></li>
<li><p>(11.19.2) &mdash; <tt>hf(r1) == hf(ke)</tt> if <tt>eq(r1, ke)</tt> is <tt>true</tt>, and</p></li>
<li><p>(11.19.3) &mdash; <del><tt>(eq(r1, ke) &amp;&amp; eq(r1, r2)) == eq(r2, ke)</tt></del><ins><tt>eq(ke, r2)</tt> 
is <tt>true</tt> if <tt>eq(ke, r1) &amp;&amp; eq(r1, r2)</tt> is <tt>true</tt></ins>,</p></li>
</ol>
<p>where <tt>r1</tt> and <tt>r2</tt> are keys of elements in <tt>a_tran</tt>,</p>
</li>
<li><p>(11.20) &mdash; <tt>kx</tt> is a value such that</p>
<ol style="list-style-type: none">
<li><p>(11.20.1) &mdash; <tt>eq(r1, kx) == eq(kx, r1)</tt>,</p></li>
<li><p>(11.20.2) &mdash; <tt>hf(r1) == hf(kx)</tt> if <tt>eq(r1, kx)</tt> is <tt>true</tt>,</p></li>
<li><p>(11.20.3) &mdash; <del><tt>(eq(r1, kx) &amp;&amp; eq(r1, r2)) == eq(r2, kx)</tt></del><ins><tt>eq(kx, r2)</tt> 
is <tt>true</tt> if <tt>eq(kx, r1) &amp;&amp; eq(r1, r2)</tt> is <tt>true</tt></ins>, and</p></li>
<li><p>(11.20.4) &mdash; <tt>kx</tt> is not convertible to either <tt>iterator</tt> or <tt>const_iterator</tt>,</p></li>
</ol>
<p>where <tt>r1</tt> and <tt>r2</tt> are keys of elements in <tt>a_tran</tt>,</p>
</li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>


<p><i>[2022-02-07 Tim comments and provides updated wording]</i></p>

<p>
For heterogeneous lookup on unordered containers to work properly, we
need all keys comparing equal to the transparent key to be grouped
together. Since the only keys guaranteed to be so grouped are the ones
that are equal according to <tt>eq</tt>, we cannot allow 
<tt>eq(r1, r2) == false</tt> but <tt>eq(r1, ke) == true &amp;&amp;
eq(r2, ke) == true</tt>. The one-way
transitivity of equality is insufficient.
<p/>
We need both of the following:
</p>
<ul>
<li>
if <tt>eq(r1, ke)</tt> is <tt>true</tt> and <tt>eq(r1, r2)</tt> is <tt>true</tt> 
then <tt>eq(r2, ke)</tt> is <tt>true</tt>.
</li>
<li>
if <tt>eq(r1, ke)</tt> is <tt>true</tt> and <tt>eq(r2, ke)</tt> is <tt>true</tt> 
then <tt>eq(r1, r2)</tt> is <tt>true</tt>
</li>
</ul>

<p>
In a table:
</p>

<table border="1">
    <thead>
        <tr>
            <th>eq(r1, ke)</th>
            <th>eq(r1, r2)</th>
            <th>eq(r2, ke)</th>
            <th>OK?</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>T</td>
            <td>T</td>
            <td>T</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>T</td>
            <td>T</td>
            <td>F</td>
            <td>N</td>
        </tr>
        <tr>
            <td>T</td>
            <td>F</td>
            <td>T</td>
            <td>N</td>
        </tr>
        <tr>
            <td>T</td>
            <td>F</td>
            <td>F</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>F</td>
            <td>T</td>
            <td>T</td>
            <td>N</td>
        </tr>
        <tr>
            <td>F</td>
            <td>T</td>
            <td>F</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>F</td>
            <td>F</td>
            <td>T</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>F</td>
            <td>F</td>
            <td>F</td>
            <td>Y</td>
        </tr>
    </tbody>
</table>

<p><i>[Issaquah 2023-02-08; LWG]</i></p>

<p>Move to Immediate for C++23</p>



<p id="res-3622"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928">N4928</a>.
</p>

<ol>
<li><p>Modify 24.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> as indicated:</p>

<blockquote>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(10.20) &mdash; <tt>ke</tt> is a value such that</p>
<ol style="list-style-type: none">
<li><p>(10.20.1) &mdash; <tt>eq(r1, ke) == eq(ke, r1)</tt>,</p></li>
<li><p>(10.20.2) &mdash; <tt>hf(r1) == hf(ke)</tt> if <tt>eq(r1, ke)</tt> is <tt>true</tt>, and</p></li>
<li><p>(10.20.3) &mdash; <del><tt>(eq(r1, ke) &amp;&amp; eq(r1, r2)) == eq(r2, ke)</tt></del><ins>if any two of
<tt>eq(r1, ke)</tt>, <tt>eq(r2, ke)</tt> and <tt>eq(r1, r2)</tt> are <tt>true</tt>, then all three are <tt>true</tt></ins>,</p></li>
</ol>
<p>where <tt>r1</tt> and <tt>r2</tt> are keys of elements in <tt>a_tran</tt>,</p>
</li>
<li><p>(10.21) &mdash; <tt>kx</tt> is a value such that</p>
<ol style="list-style-type: none">
<li><p>(10.21.1) &mdash; <tt>eq(r1, kx) == eq(kx, r1)</tt>,</p></li>
<li><p>(10.21.2) &mdash; <tt>hf(r1) == hf(kx)</tt> if <tt>eq(r1, kx)</tt> is <tt>true</tt>,</p></li>
<li><p>(10.21.3) &mdash; <del><tt>(eq(r1, kx) &amp;&amp; eq(r1, r2)) == eq(r2, kx)</tt></del><ins>if any two of
<tt>eq(r1, kx)</tt>, <tt>eq(r2, kx)</tt> and <tt>eq(r1, r2)</tt> are <tt>true</tt>, then all three are <tt>true</tt></ins>, and</p></li>
<li><p>(10.21.4) &mdash; <tt>kx</tt> is not convertible to either <tt>iterator</tt> or <tt>const_iterator</tt>,</p></li>
</ol>
<p>where <tt>r1</tt> and <tt>r2</tt> are keys of elements in <tt>a_tran</tt>,</p>
</li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</li>
</ol>





</body>
</html>
