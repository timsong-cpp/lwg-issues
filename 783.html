<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Issue 783: thread::id reuse</title>
<meta property="og:title" content="Issue 783: thread::id reuse">
<meta property="og:description" content="C++ library issue. Status: CD1">
<meta property="og:url" content="https://timsong-cpp.github.io/lwg-issues/783.html">
<meta property="og:type" content="website">
<meta property="og:image" content="http://cplusplus.github.io/LWG/images/cpp_logo.png">
<meta property="og:image:alt" content="C++ logo">
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3 id="783"><a href="lwg-defects.html#783">783</a>. <code>thread::id</code> reuse</h3>
<p><b>Section:</b> 32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a> <b>Status:</b> <a href="lwg-active.html#CD1">CD1</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2008-02-01 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#CD1">CD1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working paper 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2497.html">N2497</a>,
integrated just before Bellevue) is
not completely clear whether a given <code>thread::id</code> value may be reused once
a thread has exited and has been joined or detached.  Posix allows
thread ids (<code>pthread_t</code> values) to be reused in this case.  Although it is
not completely clear whether this originally was the right decision, it
is clearly the established practice, and we believe it was always the
intent of the C++ threads API to follow Posix and allow this.  Howard
Hinnant's example implementation implicitly relies on allowing reuse
of ids, since it uses Posix thread ids directly.
</p>

<p>
It is important to be clear on this point, since it the reuse of thread
ids often requires extra care in client code, which would not be
necessary if thread ids were unique across all time.  For example, a
hash table indexed by thread id may have to be careful not to associate
data values from an old thread with a new one that happens to reuse the
id.  Simply removing the old entry after joining a thread may not be
sufficient, if it creates a visible window between the join and removal
during which a new thread with the same id could have been created and
added to the table.
</p>

<p><i>[
post Bellevue Peter adds:
]</i></p>


<blockquote>
<p>
There is a real issue with <code>thread::id</code> reuse, but I urge the LWG to
reconsider fixing this by disallowing reuse, rather than explicitly allowing
it. Dealing with thread id reuse is an incredibly painful exercise that
would just force the world to reimplement a non-conflicting <code>thread::id</code> over
and over.
</p>
<p>
In addition, it would be nice if a <code>thread::id</code> could be manipulated
atomically in a lock-free manner, as motivated by the recursive lock
example:
</p>

<p>
<a href="http://www.decadent.org.uk/pipermail/cpp-threads/2006-August/001091.html">http://www.decadent.org.uk/pipermail/cpp-threads/2006-August/001091.html</a>
</p>
</blockquote>



<p id="res-783"><b>Proposed resolution:</b></p>
<p>
Add a sentence to 32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a>/p1:
</p>

<blockquote>
<p>
An object of type <code>thread::id</code> provides
a unique identifier for each thread of execution
and a single distinct value for all thread objects
that do not represent a thread of execution ([thread.threads.class]).
Each thread of execution has a <code>thread::id</code>
that is not equal to the <code>thread::id</code>
of other threads of execution
and that is not equal to
the <code>thread::id</code> of <code>std::thread</code> objects
that do not represent threads of execution.
<ins>The library may reuse the value of a <code>thread::id</code> of a
terminated thread that can no longer be joined.</ins>
</p>
</blockquote>





</body>
</html>
