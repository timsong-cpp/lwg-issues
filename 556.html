<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 556: Is Compare a BinaryPredicate?</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-27 at 15:11:00 UTC</p>
<hr>
<h3><a name="556" href="556">556.</a> Is <tt>Compare</tt> a <tt>BinaryPredicate</tt>?</h3>
<p><b>Section:</b> 25.5 [alg.sorting] <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-02-05 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25, p8 we allow BinaryPredicates to return a type that's convertible
to bool but need not actually be bool. That allows predicates to return
things like proxies and requires that implementations be careful about
what kinds of expressions they use the result of the predicate in (e.g.,
the expression in if (!pred(a, b)) need not be well-formed since the
negation operator may be inaccessible or return a type that's not
convertible to bool).
</p>
<p>
Here's the text for reference:
</p>
<blockquote><p>
  ...if an algorithm takes BinaryPredicate binary_pred as its argument
 and first1 and first2 as its iterator arguments, it should work
 correctly in the construct if (binary_pred(*first1, first2)){...}.
</p></blockquote>

<p>
In 25.3, p2 we require that the Compare function object return true
of false, which would seem to preclude such proxies. The relevant text
is here:
</p>
<blockquote><p>
  Compare is used as a function object which returns true if the first
  argument is less than the second, and false otherwise...
</p></blockquote>

<p><i>[
Portland:  Jack to define "convertible to bool" such that short circuiting isn't
destroyed.
]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Move to Review once wording received. Stefanus to send proposed wording.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Move to Review once wording received. Stefanus to send proposed wording.
</p></blockquote>

<p><i>[
2009-10-24 Stefanus supplied wording.
]</i></p>


<blockquote><p>
Move to Review once wording received. Stefanus to send proposed wording.
Old proposed wording here:
</p><blockquote>
<p>
I think we could fix this by rewording 25.3, p2 to read somthing like:
</p>
<blockquote><p>
-2- <tt>Compare</tt> is <del>used as a function object which returns
<tt>true</tt> if the first argument</del> <ins>a <tt>BinaryPredicate</tt>. The
return value of the function call operator applied to an object of type
<tt>Compare</tt>, when converted to type <tt>bool</tt>, yields <tt>true</tt>
if the first argument of the call</ins> is less than the second, and
<tt>false</tt> otherwise. <tt>Compare <i>comp</i></tt> is used throughout for
algorithms assuming an ordering relation. It is assumed that <tt><i>comp</i></tt>
will not apply any non-constant function through the dereferenced iterator.
</p></blockquote>
</blockquote>
</blockquote>

<p><i>[
2010-01-17:
]</i></p>


<blockquote>
<p>
Howard expresses concern that the current direction of the proposed
wording outlaws expressions such as:
</p>

<blockquote><pre>
if (!comp(x, y))
</pre></blockquote>

<p>
Daniel provides wording which addresses that concern.
</p>

<p>
The previous wording is saved here:
</p>

<blockquote>

<p>
Change 25.5 [alg.sorting] p2:
</p>
<blockquote><p>
<tt>Compare</tt> is used as a function object<ins>. The return value of
the function call operator applied to an object of type Compare, when
converted to type bool, yields true if the first argument of the
call</ins> <del>which returns <tt>true</tt> if the first argument</del>
is less than the second, and <tt>false</tt> otherwise. <tt>Compare
comp</tt> is used throughout for algorithms assuming an ordering
relation. It is assumed that <tt>comp</tt> will not apply any
non-constant function through the dereferenced iterator.
</p></blockquote>

</blockquote>

</blockquote>

<p><i>[
2010-01-22 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Change 25.1 [algorithms.general]/7+8 as indicated. <i>[This change is
recommended to bring the return value requirements of <tt>BinaryPredicate</tt>
and <tt>Compare</tt> in sync.]</i>
</p>

<blockquote>
<p>
7 The <tt>Predicate</tt> parameter is used whenever an algorithm expects a
function object that when applied to the result of dereferencing the
corresponding iterator returns a value testable as <tt>true</tt>. In other
words, if an algorithm takes <tt>Predicate pred</tt> as its argument and
<tt>first</tt> as its iterator argument, it should work correctly in the
construct <del>if <tt>(pred(*first)){...}</tt></del> <ins><tt>pred(*first)</tt>
contextually converted to <tt>bool</tt> (4 [conv])</ins>. The
function object <tt>pred</tt> shall not apply any nonconstant function through
the dereferenced iterator. This function object may be a pointer to function, or
an object of a type with an appropriate function call operator.
</p>

<p>
8 The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a
function object that when applied to the result of dereferencing two
corresponding iterators or to dereferencing an iterator and type <tt>T</tt> when
<tt>T</tt> is part of the signature returns a value testable as <tt>true</tt>.
In other words, if an algorithm takes <tt>BinaryPredicate</tt>
<tt>binary_pred</tt> as its argument and <tt>first1</tt> and <tt>first2</tt> as
its iterator arguments, it should work correctly in the construct <del><tt>if
(binary_pred(*first1, *first2)){...}</tt></del> <ins><tt>binary_pred(*first1,
*first2)</tt> contextually converted to <tt>bool</tt> (4 [conv])</ins>. <tt>BinaryPredicate</tt> always takes the first iterator
type as its first argument, that is, in those cases when <tt>T value</tt> is
part of the signature, it should work correctly in the <del>context of <tt>if
(binary_pred(*first1, value)){...}</tt></del> <ins>construct
<tt>binary_pred(*first1, value)</tt> contextually converted to <tt>bool</tt>
(4 [conv])</ins>. <tt>binary_pred</tt> shall not apply any
non-constant function through the dereferenced iterators.
</p>
</blockquote>
</li>

<li>
<p>
Change 25.5 [alg.sorting]/2 as indicated:
</p>

<blockquote><p>
2 <tt>Compare</tt> is <del>used as</del> a function object <ins>type (20.14 [function.objects]). The return value of the function call operation
applied to an object of type <tt>Compare</tt>, when contextually converted to
type <tt>bool</tt> (4 [conv]), yields <tt>true</tt> if the first
argument of the call</ins><del> which returns <tt>true</tt> if the first
argument</del> is less than the second, and <tt>false</tt> otherwise.
<tt>Compare comp</tt> is used throughout for algorithms assuming an ordering
relation. It is assumed that <tt>comp</tt> will not apply any non-constant
function through the dereferenced iterator.
</p></blockquote>
</li>

</ol>






</body>
</html>
