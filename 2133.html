<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2133: Attitude to overloaded comma for iterators</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<hr>
<h3><a name="2133" href="lwg-defects.html#2133">2133.</a> Attitude to overloaded comma for iterators</h3>
<p><b>Section:</b> 16.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> <b>Status:</b> <a href="lwg-active.html#C++17">C++17</a>
 <b>Submitter:</b> Yakov Galka <b>Opened:</b> 2012-01-25 <b>Last modified:</b> 2017-07-30 20:15:43 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#global.functions">issues</a> in [global.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++17">C++17</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> says
</p>
<blockquote><p>
Unless otherwise specified, global and non-member functions in the standard library 
shall not use functions from another namespace which are found through argument-dependent 
name lookup (3.4.2).
</p></blockquote>
<p>
This sounds clear enough. There are just two problems:
</p>
<ol>
<li><p>
Both implementations I tested (VS2005 and GCC 3.4.3) do unqualified
calls to the comma operator in some parts of the library with operands
of user-defined types.
</p></li>
<li>
<p>
The standard itself does this in the description of some algorithms. E.g. <tt>uninitialized_copy</tt> 
is defined as:
</p>
<blockquote><p>
<i>Effects</i>:
</p><blockquote>
<pre>
for (; first != last; <span style="color:#C80000;font-weight:bold">++result, ++first</span>)
  ::new (static_cast&lt;void*&gt;(&amp;*result))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</pre>
</blockquote>
</blockquote>
</li>
</ol>
<p>
If understood literally, it is required to call <tt>operator,(ForwardIterator, InputIterator)</tt>.
<p/>
For detailed discussion with code samples see 
<a href="http://stackoverflow.com/questions/8719829/should-the-implementation-guard-itself-against-comma-overloading">here</a>.
<p/>
Proposal:
</p>
<ol>
<li>
Add an exception to the rule in 16.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> by permitting
the implementation to call the comma operator as much as it wants to. I doubt we want this. or
</li>
<li>
Fix the description of the said algorithms and perhaps add a note to 16.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> 
that brings attention of the implementers to avoid this pitfall.
</li>
</ol>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
There are real questions here, that may require a paper to explore and answer properly.
</p>

<p><i>[2014-05-18, Daniel comments and suggests concrete wording]</i></p>


<p>
Other issues, such as <a href="2114">2114</a> already follow a similar spirit as the one suggested by bullet 2 of the
issue submitter. I assert that consideration of possible user-provided overloads of the comma-operator were not intended
by the original wording and doing so afterwards would unnecessarily complicate a future conceptualization of the library
and would needlessly restrict implementations.
<p/>
I don't think that a paper is needed to solve this issue, there is a simply way to ensure that the code-semantics
excludes consideration of user-provided comma operators. The provided wording below clarifies this by explicitly
casting the first argument of the operator to <tt>void</tt>. 
</p>

<p><i>[2015-05, Lenexa]</i></p>

<p>
DK: is putting it in the middle the right place for it?<br/>
STL: either works, but visually putting it in the middle is clearer, and for "++it1, ++i2, ++it3" it needs to be 
done after the second comma, so "++it1, (void) ++i2, (void) ++it3" is better than "(void) ++it1, ++i2, (void) ++it3"<br/>
ZY: for <tt><i>INVOKE</i></tt> yesterday we used <tt>static_cast&lt;void&gt;</tt> but here we're using C-style cast, why?<br/>
STL: for <tt><i>INVOKE</i></tt> I want to draw attention that there's an intentional coercion to <tt>void</tt> because that's 
the desired type. Here we only do it because that's the best way to prevent the problem, not because we specifically want a 
<tt>void</tt> type.<br/>
Move to Ready: 9 in favor, none opposed, 1 abstention 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 25.11.4 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class InputIterator, class ForwardIterator&gt;
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>:
</p>
<blockquote>
<pre>
for (; first != last; ++result, <ins>(void)</ins> ++first)
  ::new (static_cast&lt;void*&gt;(&amp;*result))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</pre>
</blockquote>
<p>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class InputIterator, class Size,class ForwardIterator&gt;
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                       ForwardIterator result);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>:
</p>
<blockquote>
<pre>
for (; n &gt; 0; ++result, <ins>(void)</ins> ++first, --n)
  ::new (static_cast&lt;void*&gt;(&amp;*result))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</pre>
</blockquote>
</blockquote>

</blockquote>
</li>

<li><p>Change 25.8.10 <a href="https://timsong-cpp.github.io/cppwp/alg.lex.comparison">[alg.lex.comparison]</a> p3 as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator1, class InputIterator2&gt;
  bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2);
template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
  bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp);
</pre>
<blockquote>
<p>
-3- <i>Remarks</i>: [&hellip;]
</p>
<blockquote>
<pre>
for ( ; first1 != last1 &amp;&amp; first2 != last2 ; ++first1, <ins>(void)</ins> ++first2) {
  if (*first1 &lt; *first2) return true;
  if (*first2 &lt; *first1) return false;
}
return first1 == last1 &amp;&amp; first2 != last2;
</pre>
</blockquote>
</blockquote>
</blockquote>

</li>
</ol>






</body>
</html>
