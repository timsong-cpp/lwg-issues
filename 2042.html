<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2042: Comparing forward_list::before_begin() to forward_list::end()</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-29 at 02:11:18 UTC</p>
<hr>
<h3><a name="2042" href="2042">2042.</a> Comparing <tt>forward_list::before_begin()</tt> to <tt>forward_list::end()</tt></h3>
<p><b>Section:</b> 23.3.9.3 [forwardlist.iter] <b>Status:</b> <a href="lwg-active.html#C++11">C++11</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2011-03-13 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++11">C++11</a> status.</p>
<p><b>Discussion:</b></p>
<p>For an object <tt>c</tt> of type <tt>forward_list&lt;X, Alloc&gt;</tt>, the iterators
<tt>c.before_begin()</tt> and <tt>c.end()</tt> are part of the same underlying sequence,
so the expression <tt>c.before_begin() == c.end()</tt>  must be well-defined.
But the standard says nothing about what the result of this expression
should be.  The forward iterator requirements says no dereferenceable
iterator is equal to a non-dereferenceable iterator and that two
dereferenceable iterators are equal if and only if they point to the
same element.  But since <tt>before_begin()</tt> and <tt>end()</tt> are both
non-dereferenceable, neither of these rules applies.
</p>

<p>
Many <tt>forward_list</tt> methods, such as <tt>insert_after()</tt>, have a
precondition that the iterator passed to them must not be equal to
<tt>end()</tt>. Thus, user code might look like the following:
</p>
<blockquote><pre>
void foo(forward_list&lt;int&gt;&amp; c, forward_list&lt;int&gt;::iterator it)
{
  assert(it != c.end());
  c.insert_after(it, 42);
}
</pre></blockquote>

<p>
Conversely, <tt>before_begin()</tt> was specifically designed to be used with
methods like <tt>insert_after()</tt>, so if <tt>c.before_begin()</tt> is passed to 
this function the assertion must not fail.
</p>

<p><i>[2011-03-14: Daniel comments and updates the suggested wording]</i></p>


<p>The suggested wording changes are necessary but not sufficient. Since there
does not exist an equivalent semantic definition of <tt>cbefore_begin()</tt> as
we have for <tt>cbegin()</tt>, this still leaves the question open whether
the normative remark applies to <tt>cbefore_begin()</tt> as well. A simple fix
is to define the operational semantics of <tt>cbefore_begin()</tt> in terms of
<tt>before_begin()</tt>.</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
General agreement that this is a serious bug.
<p/>
Pablo: Any objections to moving 2042 to Immediate?
<p/>
No objections. 
</p>



<p><b>Proposed resolution:</b></p>

<p>Add to the definition of <tt>forward_list::before_begin()</tt> 23.3.9.3 [forwardlist.iter] 
the following:</p>

<blockquote><pre>
iterator before_begin();
const_iterator before_begin() const;
const_iterator cbefore_begin() const;
</pre><blockquote><p>
-1- <i>Returns</i>: A non-dereferenceable iterator that, when incremented, is equal to the iterator returned by <tt>begin()</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>cbefore_begin()</tt> is equivalent to <tt>const_cast&lt;forward_list const&amp;>(*this).before_begin()</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: <tt>before_begin() == end()</tt> shall equal false.</ins>
</p></blockquote></blockquote>





</body>
</html>
