<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Closed Issues List</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<table>
<tr>
  <td align="left">Doc. no.</td>
  <td align="left">D????</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">2022-10-31</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">Programming Language C++</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Jonathan Wakely &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h1>C++ Standard Library Closed Issues List (Revision D123)</h1>
<p><p>Revised 2022-10-30 at 10:44:58 UTC</p>
</p>
  <p>Reference ISO/IEC IS 14882:2014(E)</p>
  <p>Also see:</p>
    <ul>
      <li><a href="lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="lwg-active.html">Library Active Issues List</a></li>
      <li><a href="lwg-defects.html">Library Defect Reports and Accepted Issues</a></li>
    </ul>

  <p>This document contains only library issues which have been closed
  by the Library Working Group as duplicates or not defects. That is,
  issues which have a status of <a href="lwg-active.html#Dup">Dup</a> or
  <a href="lwg-active.html#NAD">NAD</a>.
  See the <a href="lwg-defects.html">Library Defect Reports and Accepted Issues</a> for issues considered defects.
  See the <a href="lwg-active.html">Library Active Issues List</a> for active issues and more information.
  The introductory material in that document also applies to this document.</p>

<h2 id='History'>Revision History</h2>
<ul>
<li>D123: 2022-03-04 Since March 2022<ul>
<li><b>Summary:</b><ul>
<li>448 open issues, up by 93.</li>
<li>2842 closed issues, up by 34.</li>
<li>38 reassigned issues, down by 1.</li>
<li>3328 issues total, up by 126.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Ready issue: <a href="3754">3754</a>.</li>
<li>Added the following 31 Tentatively Ready issues: <a href="3732">3732</a>, <a href="3736">3736</a>, <a href="3738">3738</a>, <a href="3742">3742</a>, <a href="3743">3743</a>, <a href="3745">3745</a>, <a href="3746">3746</a>, <a href="3747">3747</a>, <a href="3750">3750</a>, <a href="3751">3751</a>, <a href="3753">3753</a>, <a href="3755">3755</a>, <a href="3757">3757</a>, <a href="3759">3759</a>, <a href="3760">3760</a>, <a href="3761">3761</a>, <a href="3762">3762</a>, <a href="3764">3764</a>, <a href="3765">3765</a>, <a href="3770">3770</a>, <a href="3771">3771</a>, <a href="3773">3773</a>, <a href="3774">3774</a>, <a href="3775">3775</a>, <a href="3778">3778</a>, <a href="3781">3781</a>, <a href="3782">3782</a>, <a href="3784">3784</a>, <a href="3785">3785</a>, <a href="3788">3788</a>, <a href="3792">3792</a>.</li>
<li>Added the following 10 Tentatively NAD issues: <a href="3726">3726</a>, <a href="3727">3727</a>, <a href="3735">3735</a>, <a href="3739">3739</a>, <a href="3740">3740</a>, <a href="3741">3741</a>, <a href="3752">3752</a>, <a href="3768">3768</a>, <a href="3779">3779</a>, <a href="3789">3789</a>.</li>
<li>Added the following 56 New issues: <a href="3681">3681</a>, <a href="3682">3682</a>, <a href="3684">3684</a>, <a href="3685">3685</a>, <a href="3686">3686</a>, <a href="3688">3688</a>, <a href="3689">3689</a>, <a href="3690">3690</a>, <a href="3691">3691</a>, <a href="3693">3693</a>, <a href="3694">3694</a>, <a href="3696">3696</a>, <a href="3697">3697</a>, <a href="3698">3698</a>, <a href="3699">3699</a>, <a href="3700">3700</a>, <a href="3706">3706</a>, <a href="3716">3716</a>, <a href="3717">3717</a>, <a href="3718">3718</a>, <a href="3720">3720</a>, <a href="3722">3722</a>, <a href="3723">3723</a>, <a href="3725">3725</a>, <a href="3728">3728</a>, <a href="3729">3729</a>, <a href="3730">3730</a>, <a href="3731">3731</a>, <a href="3734">3734</a>, <a href="3737">3737</a>, <a href="3744">3744</a>, <a href="3748">3748</a>, <a href="3749">3749</a>, <a href="3758">3758</a>, <a href="3763">3763</a>, <a href="3766">3766</a>, <a href="3769">3769</a>, <a href="3772">3772</a>, <a href="3783">3783</a>, <a href="3787">3787</a>, <a href="3790">3790</a>, <a href="3791">3791</a>, <a href="3793">3793</a>, <a href="3794">3794</a>, <a href="3795">3795</a>, <a href="3796">3796</a>, <a href="3797">3797</a>, <a href="3798">3798</a>, <a href="3799">3799</a>, <a href="3800">3800</a>, <a href="3801">3801</a>, <a href="3802">3802</a>, <a href="3803">3803</a>, <a href="3804">3804</a>, <a href="3805">3805</a>, <a href="3806">3806</a>.</li>
<li>Added the following 3 Open issues: <a href="3733">3733</a>, <a href="3777">3777</a>, <a href="3786">3786</a>.</li>
<li>Added the following 2 LEWG issues: <a href="3714">3714</a>, <a href="3776">3776</a>.</li>
<li>Added the following SG1 issue: <a href="3756">3756</a>.</li>
<li>Added the following 2 SG16 issues: <a href="3767">3767</a>, <a href="3780">3780</a>.</li>
<li>Added the following 19 WP issues: <a href="3683">3683</a>, <a href="3687">3687</a>, <a href="3692">3692</a>, <a href="3701">3701</a>, <a href="3702">3702</a>, <a href="3703">3703</a>, <a href="3704">3704</a>, <a href="3705">3705</a>, <a href="3707">3707</a>, <a href="3708">3708</a>, <a href="3709">3709</a>, <a href="3710">3710</a>, <a href="3711">3711</a>, <a href="3712">3712</a>, <a href="3713">3713</a>, <a href="3715">3715</a>, <a href="3719">3719</a>, <a href="3721">3721</a>, <a href="3724">3724</a>.</li>
<li>Added the following NAD issue: <a href="3695">3695</a>.</li>
<li>Changed the following 2 issues to Ready (from New): <a href="3594">3594</a>, <a href="3636">3636</a>.</li>
<li>Changed the following 7 issues to Tentatively Ready (from New): <a href="3028">3028</a>, <a href="3136">3136</a>, <a href="3177">3177</a>, <a href="3411">3411</a>, <a href="3597">3597</a>, <a href="3629">3629</a>, <a href="3677">3677</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="3545">3545</a>.</li>
<li>Changed the following issue to Tentatively Ready (from LEWG): <a href="3646">3646</a>.</li>
<li>Changed the following 2 issues to Tentatively NAD (from Open): <a href="2116">2116</a>, <a href="3357">3357</a>.</li>
<li>Changed the following issue to Tentatively NAD (from EWG): <a href="2432">2432</a>.</li>
<li>Changed the following 2 issues to Open (from New): <a href="2564">2564</a>, <a href="3167">3167</a>.</li>
<li>Changed the following issue to Open (from NAD): <a href="617">617</a>.</li>
<li>Changed the following 3 issues to WP (from Tentatively Ready): <a href="3670">3670</a>, <a href="3671">3671</a>, <a href="3672">3672</a>.</li>
<li>Changed the following issue to WP (from New): <a href="3617">3617</a>.</li>
<li>Changed the following issue to WP (from Open): <a href="3656">3656</a>.</li>
<li>Changed the following issue to WP (from SG1): <a href="3659">3659</a>.</li>
<li>Changed the following issue to WP (from SG9): <a href="3564">3564</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="2561">2561</a>.</li>
<li>Changed the following issue to Resolved (from EWG): <a href="2813">2813</a>.</li>
<li>Changed the following issue to TS (from Tentatively Ready): <a href="3649">3649</a>.</li>
<li>Changed the following 2 issues to NAD (from Tentatively NAD): <a href="3579">3579</a>, <a href="3667">3667</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2352">2352</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="3068">3068</a>.</li>
<li>Changed the following issue to NAD (from SG1): <a href="3611">3611</a>.</li>
</ul></li>
</ul>
</li>
<li>R122: 
2022-03-04 March 2022
<ul>
<li><b>Summary:</b><ul>
<li>355 open issues, up by 41.</li>
<li>2808 closed issues, up by 222.</li>
<li>39 reassigned issues, up by 4.</li>
<li>3202 issues total, up by 267.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 4 Tentatively Ready issues: <a href="3649">3649</a>, <a href="3670">3670</a>, <a href="3671">3671</a>, <a href="3672">3672</a>.</li>
<li>Added the following 2 Tentatively NAD issues: <a href="3579">3579</a>, <a href="3667">3667</a>.</li>
<li>Added the following 103 New issues: <a href="3416">3416</a>, <a href="3418">3418</a>, <a href="3423">3423</a>, <a href="3424">3424</a>, <a href="3429">3429</a>, <a href="3431">3431</a>, <a href="3436">3436</a>, <a href="3438">3438</a>, <a href="3439">3439</a>, <a href="3444">3444</a>, <a href="3451">3451</a>, <a href="3456">3456</a>, <a href="3457">3457</a>, <a href="3459">3459</a>, <a href="3463">3463</a>, <a href="3475">3475</a>, <a href="3484">3484</a>, <a href="3487">3487</a>, <a href="3489">3489</a>, <a href="3491">3491</a>, <a href="3493">3493</a>, <a href="3496">3496</a>, <a href="3497">3497</a>, <a href="3499">3499</a>, <a href="3501">3501</a>, <a href="3503">3503</a>, <a href="3504">3504</a>, <a href="3507">3507</a>, <a href="3508">3508</a>, <a href="3511">3511</a>, <a href="3512">3512</a>, <a href="3513">3513</a>, <a href="3516">3516</a>, <a href="3531">3531</a>, <a href="3537">3537</a>, <a href="3538">3538</a>, <a href="3550">3550</a>, <a href="3556">3556</a>, <a href="3569">3569</a>, <a href="3577">3577</a>, <a href="3578">3578</a>, <a href="3582">3582</a>, <a href="3583">3583</a>, <a href="3584">3584</a>, <a href="3586">3586</a>, <a href="3587">3587</a>, <a href="3594">3594</a>, <a href="3597">3597</a>, <a href="3599">3599</a>, <a href="3600">3600</a>, <a href="3602">3602</a>, <a href="3603">3603</a>, <a href="3604">3604</a>, <a href="3605">3605</a>, <a href="3606">3606</a>, <a href="3608">3608</a>, <a href="3609">3609</a>, <a href="3613">3613</a>, <a href="3614">3614</a>, <a href="3615">3615</a>, <a href="3617">3617</a>, <a href="3620">3620</a>, <a href="3622">3622</a>, <a href="3623">3623</a>, <a href="3624">3624</a>, <a href="3625">3625</a>, <a href="3626">3626</a>, <a href="3627">3627</a>, <a href="3628">3628</a>, <a href="3629">3629</a>, <a href="3630">3630</a>, <a href="3631">3631</a>, <a href="3633">3633</a>, <a href="3634">3634</a>, <a href="3635">3635</a>, <a href="3636">3636</a>, <a href="3637">3637</a>, <a href="3638">3638</a>, <a href="3640">3640</a>, <a href="3641">3641</a>, <a href="3642">3642</a>, <a href="3644">3644</a>, <a href="3645">3645</a>, <a href="3647">3647</a>, <a href="3651">3651</a>, <a href="3653">3653</a>, <a href="3655">3655</a>, <a href="3658">3658</a>, <a href="3662">3662</a>, <a href="3663">3663</a>, <a href="3664">3664</a>, <a href="3665">3665</a>, <a href="3666">3666</a>, <a href="3668">3668</a>, <a href="3669">3669</a>, <a href="3673">3673</a>, <a href="3674">3674</a>, <a href="3675">3675</a>, <a href="3676">3676</a>, <a href="3677">3677</a>, <a href="3678">3678</a>, <a href="3679">3679</a>, <a href="3680">3680</a>.</li>
<li>Added the following 5 Open issues: <a href="3441">3441</a>, <a href="3442">3442</a>, <a href="3488">3488</a>, <a href="3545">3545</a>, <a href="3656">3656</a>.</li>
<li>Added the following 6 LEWG issues: <a href="3445">3445</a>, <a href="3454">3454</a>, <a href="3486">3486</a>, <a href="3515">3515</a>, <a href="3534">3534</a>, <a href="3646">3646</a>.</li>
<li>Added the following 4 SG1 issues: <a href="3417">3417</a>, <a href="3485">3485</a>, <a href="3611">3611</a>, <a href="3659">3659</a>.</li>
<li>Added the following SG9 issue: <a href="3564">3564</a>.</li>
<li>Added the following 3 SG16 issues: <a href="3565">3565</a>, <a href="3576">3576</a>, <a href="3639">3639</a>.</li>
<li>Added the following 120 WP issues: <a href="3414">3414</a>, <a href="3419">3419</a>, <a href="3420">3420</a>, <a href="3421">3421</a>, <a href="3422">3422</a>, <a href="3425">3425</a>, <a href="3426">3426</a>, <a href="3427">3427</a>, <a href="3428">3428</a>, <a href="3430">3430</a>, <a href="3432">3432</a>, <a href="3433">3433</a>, <a href="3434">3434</a>, <a href="3435">3435</a>, <a href="3437">3437</a>, <a href="3443">3443</a>, <a href="3446">3446</a>, <a href="3447">3447</a>, <a href="3448">3448</a>, <a href="3449">3449</a>, <a href="3450">3450</a>, <a href="3453">3453</a>, <a href="3455">3455</a>, <a href="3460">3460</a>, <a href="3461">3461</a>, <a href="3462">3462</a>, <a href="3464">3464</a>, <a href="3465">3465</a>, <a href="3466">3466</a>, <a href="3467">3467</a>, <a href="3470">3470</a>, <a href="3471">3471</a>, <a href="3472">3472</a>, <a href="3473">3473</a>, <a href="3474">3474</a>, <a href="3476">3476</a>, <a href="3477">3477</a>, <a href="3480">3480</a>, <a href="3481">3481</a>, <a href="3482">3482</a>, <a href="3483">3483</a>, <a href="3490">3490</a>, <a href="3492">3492</a>, <a href="3494">3494</a>, <a href="3495">3495</a>, <a href="3498">3498</a>, <a href="3500">3500</a>, <a href="3502">3502</a>, <a href="3505">3505</a>, <a href="3506">3506</a>, <a href="3517">3517</a>, <a href="3518">3518</a>, <a href="3519">3519</a>, <a href="3520">3520</a>, <a href="3521">3521</a>, <a href="3522">3522</a>, <a href="3523">3523</a>, <a href="3525">3525</a>, <a href="3526">3526</a>, <a href="3527">3527</a>, <a href="3528">3528</a>, <a href="3529">3529</a>, <a href="3530">3530</a>, <a href="3532">3532</a>, <a href="3533">3533</a>, <a href="3535">3535</a>, <a href="3536">3536</a>, <a href="3539">3539</a>, <a href="3540">3540</a>, <a href="3541">3541</a>, <a href="3542">3542</a>, <a href="3543">3543</a>, <a href="3544">3544</a>, <a href="3546">3546</a>, <a href="3548">3548</a>, <a href="3549">3549</a>, <a href="3551">3551</a>, <a href="3552">3552</a>, <a href="3553">3553</a>, <a href="3554">3554</a>, <a href="3555">3555</a>, <a href="3557">3557</a>, <a href="3559">3559</a>, <a href="3560">3560</a>, <a href="3561">3561</a>, <a href="3563">3563</a>, <a href="3566">3566</a>, <a href="3567">3567</a>, <a href="3568">3568</a>, <a href="3570">3570</a>, <a href="3571">3571</a>, <a href="3572">3572</a>, <a href="3573">3573</a>, <a href="3574">3574</a>, <a href="3580">3580</a>, <a href="3581">3581</a>, <a href="3585">3585</a>, <a href="3589">3589</a>, <a href="3590">3590</a>, <a href="3591">3591</a>, <a href="3592">3592</a>, <a href="3593">3593</a>, <a href="3595">3595</a>, <a href="3598">3598</a>, <a href="3601">3601</a>, <a href="3607">3607</a>, <a href="3610">3610</a>, <a href="3612">3612</a>, <a href="3616">3616</a>, <a href="3618">3618</a>, <a href="3619">3619</a>, <a href="3621">3621</a>, <a href="3632">3632</a>, <a href="3643">3643</a>, <a href="3648">3648</a>, <a href="3650">3650</a>, <a href="3654">3654</a>, <a href="3657">3657</a>, <a href="3660">3660</a>, <a href="3661">3661</a>.</li>
<li>Added the following 11 Resolved issues: <a href="3452">3452</a>, <a href="3458">3458</a>, <a href="3469">3469</a>, <a href="3478">3478</a>, <a href="3479">3479</a>, <a href="3509">3509</a>, <a href="3510">3510</a>, <a href="3514">3514</a>, <a href="3524">3524</a>, <a href="3547">3547</a>, <a href="3575">3575</a>.</li>
<li>Added the following NAD Editorial issue: <a href="3558">3558</a>.</li>
<li>Added the following 7 NAD issues: <a href="3415">3415</a>, <a href="3440">3440</a>, <a href="3468">3468</a>, <a href="3562">3562</a>, <a href="3588">3588</a>, <a href="3596">3596</a>, <a href="3652">3652</a>.</li>
<li>Changed the following 2 issues to Open (from LEWG): <a href="3068">3068</a>, <a href="3357">3357</a>.</li>
<li>Changed the following issue to Open (from NAD): <a href="1102">1102</a>.</li>
<li>Changed the following issue to NAD Future (from LEWG): <a href="1025">1025</a>.</li>
<li>Changed the following 4 issues to WP (from Ready): <a href="3117">3117</a>, <a href="3211">3211</a>, <a href="3236">3236</a>, <a href="3249">3249</a>.</li>
<li>Changed the following issue to WP (from Tentatively Ready): <a href="2820">2820</a>.</li>
<li>Changed the following 22 issues to WP (from New): <a href="2191">2191</a>, <a href="2743">2743</a>, <a href="2774">2774</a>, <a href="2997">2997</a>, <a href="3088">3088</a>, <a href="3123">3123</a>, <a href="3143">3143</a>, <a href="3146">3146</a>, <a href="3152">3152</a>, <a href="3195">3195</a>, <a href="3265">3265</a>, <a href="3293">3293</a>, <a href="3306">3306</a>, <a href="3361">3361</a>, <a href="3391">3391</a>, <a href="3403">3403</a>, <a href="3404">3404</a>, <a href="3405">3405</a>, <a href="3406">3406</a>, <a href="3407">3407</a>, <a href="3410">3410</a>, <a href="3413">3413</a>.</li>
<li>Changed the following 10 issues to WP (from Open): <a href="2381">2381</a>, <a href="2731">2731</a>, <a href="2762">2762</a>, <a href="2818">2818</a>, <a href="2839">2839</a>, <a href="3036">3036</a>, <a href="3120">3120</a>, <a href="3121">3121</a>, <a href="3170">3170</a>, <a href="3171">3171</a>.</li>
<li>Changed the following issue to WP (from LEWG): <a href="3392">3392</a>.</li>
<li>Changed the following 2 issues to C++20 (from New): <a href="3290">3290</a>, <a href="3386">3386</a>.</li>
<li>Changed the following 280 issues to C++20 (from WP): <a href="1203">1203</a>, <a href="2139">2139</a>, <a href="2164">2164</a>, <a href="2183">2183</a>, <a href="2184">2184</a>, <a href="2243">2243</a>, <a href="2412">2412</a>, <a href="2444">2444</a>, <a href="2593">2593</a>, <a href="2597">2597</a>, <a href="2682">2682</a>, <a href="2783">2783</a>, <a href="2816">2816</a>, <a href="2843">2843</a>, <a href="2849">2849</a>, <a href="2851">2851</a>, <a href="2859">2859</a>, <a href="2870">2870</a>, <a href="2899">2899</a>, <a href="2932">2932</a>, <a href="2935">2935</a>, <a href="2936">2936</a>, <a href="2937">2937</a>, <a href="2940">2940</a>, <a href="2941">2941</a>, <a href="2942">2942</a>, <a href="2943">2943</a>, <a href="2944">2944</a>, <a href="2945">2945</a>, <a href="2946">2946</a>, <a href="2948">2948</a>, <a href="2950">2950</a>, <a href="2952">2952</a>, <a href="2953">2953</a>, <a href="2954">2954</a>, <a href="2958">2958</a>, <a href="2961">2961</a>, <a href="2964">2964</a>, <a href="2965">2965</a>, <a href="2966">2966</a>, <a href="2969">2969</a>, <a href="2970">2970</a>, <a href="2972">2972</a>, <a href="2974">2974</a>, <a href="2975">2975</a>, <a href="2976">2976</a>, <a href="2977">2977</a>, <a href="2978">2978</a>, <a href="2979">2979</a>, <a href="2980">2980</a>, <a href="2981">2981</a>, <a href="2982">2982</a>, <a href="2988">2988</a>, <a href="2989">2989</a>, <a href="2993">2993</a>, <a href="2995">2995</a>, <a href="2996">2996</a>, <a href="2998">2998</a>, <a href="3000">3000</a>, <a href="3001">3001</a>, <a href="3004">3004</a>, <a href="3005">3005</a>, <a href="3007">3007</a>, <a href="3008">3008</a>, <a href="3009">3009</a>, <a href="3012">3012</a>, <a href="3013">3013</a>, <a href="3014">3014</a>, <a href="3015">3015</a>, <a href="3017">3017</a>, <a href="3018">3018</a>, <a href="3024">3024</a>, <a href="3025">3025</a>, <a href="3026">3026</a>, <a href="3030">3030</a>, <a href="3031">3031</a>, <a href="3034">3034</a>, <a href="3035">3035</a>, <a href="3037">3037</a>, <a href="3038">3038</a>, <a href="3039">3039</a>, <a href="3040">3040</a>, <a href="3041">3041</a>, <a href="3042">3042</a>, <a href="3043">3043</a>, <a href="3045">3045</a>, <a href="3048">3048</a>, <a href="3050">3050</a>, <a href="3051">3051</a>, <a href="3054">3054</a>, <a href="3055">3055</a>, <a href="3058">3058</a>, <a href="3062">3062</a>, <a href="3065">3065</a>, <a href="3067">3067</a>, <a href="3070">3070</a>, <a href="3074">3074</a>, <a href="3075">3075</a>, <a href="3076">3076</a>, <a href="3077">3077</a>, <a href="3079">3079</a>, <a href="3080">3080</a>, <a href="3083">3083</a>, <a href="3087">3087</a>, <a href="3094">3094</a>, <a href="3096">3096</a>, <a href="3100">3100</a>, <a href="3101">3101</a>, <a href="3102">3102</a>, <a href="3103">3103</a>, <a href="3104">3104</a>, <a href="3112">3112</a>, <a href="3116">3116</a>, <a href="3119">3119</a>, <a href="3122">3122</a>, <a href="3127">3127</a>, <a href="3128">3128</a>, <a href="3129">3129</a>, <a href="3130">3130</a>, <a href="3131">3131</a>, <a href="3132">3132</a>, <a href="3133">3133</a>, <a href="3137">3137</a>, <a href="3140">3140</a>, <a href="3141">3141</a>, <a href="3144">3144</a>, <a href="3145">3145</a>, <a href="3147">3147</a>, <a href="3148">3148</a>, <a href="3149">3149</a>, <a href="3150">3150</a>, <a href="3153">3153</a>, <a href="3154">3154</a>, <a href="3158">3158</a>, <a href="3160">3160</a>, <a href="3169">3169</a>, <a href="3173">3173</a>, <a href="3175">3175</a>, <a href="3179">3179</a>, <a href="3180">3180</a>, <a href="3182">3182</a>, <a href="3183">3183</a>, <a href="3184">3184</a>, <a href="3185">3185</a>, <a href="3186">3186</a>, <a href="3187">3187</a>, <a href="3190">3190</a>, <a href="3191">3191</a>, <a href="3194">3194</a>, <a href="3196">3196</a>, <a href="3198">3198</a>, <a href="3199">3199</a>, <a href="3200">3200</a>, <a href="3201">3201</a>, <a href="3202">3202</a>, <a href="3206">3206</a>, <a href="3208">3208</a>, <a href="3209">3209</a>, <a href="3218">3218</a>, <a href="3221">3221</a>, <a href="3222">3222</a>, <a href="3224">3224</a>, <a href="3225">3225</a>, <a href="3226">3226</a>, <a href="3230">3230</a>, <a href="3231">3231</a>, <a href="3232">3232</a>, <a href="3233">3233</a>, <a href="3235">3235</a>, <a href="3237">3237</a>, <a href="3238">3238</a>, <a href="3241">3241</a>, <a href="3242">3242</a>, <a href="3243">3243</a>, <a href="3244">3244</a>, <a href="3245">3245</a>, <a href="3246">3246</a>, <a href="3247">3247</a>, <a href="3248">3248</a>, <a href="3250">3250</a>, <a href="3251">3251</a>, <a href="3252">3252</a>, <a href="3253">3253</a>, <a href="3254">3254</a>, <a href="3255">3255</a>, <a href="3256">3256</a>, <a href="3257">3257</a>, <a href="3259">3259</a>, <a href="3260">3260</a>, <a href="3262">3262</a>, <a href="3264">3264</a>, <a href="3266">3266</a>, <a href="3269">3269</a>, <a href="3270">3270</a>, <a href="3272">3272</a>, <a href="3273">3273</a>, <a href="3274">3274</a>, <a href="3276">3276</a>, <a href="3277">3277</a>, <a href="3280">3280</a>, <a href="3281">3281</a>, <a href="3282">3282</a>, <a href="3284">3284</a>, <a href="3285">3285</a>, <a href="3286">3286</a>, <a href="3291">3291</a>, <a href="3292">3292</a>, <a href="3294">3294</a>, <a href="3296">3296</a>, <a href="3299">3299</a>, <a href="3300">3300</a>, <a href="3301">3301</a>, <a href="3302">3302</a>, <a href="3303">3303</a>, <a href="3304">3304</a>, <a href="3307">3307</a>, <a href="3310">3310</a>, <a href="3313">3313</a>, <a href="3314">3314</a>, <a href="3315">3315</a>, <a href="3316">3316</a>, <a href="3317">3317</a>, <a href="3318">3318</a>, <a href="3319">3319</a>, <a href="3320">3320</a>, <a href="3321">3321</a>, <a href="3323">3323</a>, <a href="3324">3324</a>, <a href="3325">3325</a>, <a href="3326">3326</a>, <a href="3327">3327</a>, <a href="3328">3328</a>, <a href="3329">3329</a>, <a href="3330">3330</a>, <a href="3331">3331</a>, <a href="3332">3332</a>, <a href="3334">3334</a>, <a href="3335">3335</a>, <a href="3338">3338</a>, <a href="3340">3340</a>, <a href="3346">3346</a>, <a href="3347">3347</a>, <a href="3348">3348</a>, <a href="3349">3349</a>, <a href="3350">3350</a>, <a href="3351">3351</a>, <a href="3352">3352</a>, <a href="3354">3354</a>, <a href="3355">3355</a>, <a href="3356">3356</a>, <a href="3358">3358</a>, <a href="3359">3359</a>, <a href="3360">3360</a>, <a href="3362">3362</a>, <a href="3363">3363</a>, <a href="3364">3364</a>, <a href="3367">3367</a>, <a href="3369">3369</a>, <a href="3371">3371</a>, <a href="3372">3372</a>, <a href="3373">3373</a>, <a href="3374">3374</a>, <a href="3375">3375</a>, <a href="3377">3377</a>, <a href="3379">3379</a>, <a href="3380">3380</a>, <a href="3381">3381</a>, <a href="3382">3382</a>, <a href="3383">3383</a>, <a href="3384">3384</a>, <a href="3385">3385</a>, <a href="3387">3387</a>, <a href="3388">3388</a>, <a href="3389">3389</a>, <a href="3390">3390</a>, <a href="3393">3393</a>, <a href="3395">3395</a>, <a href="3396">3396</a>, <a href="3397">3397</a>, <a href="3398">3398</a>.</li>
<li>Changed the following issue to Resolved (from Tentatively Ready): <a href="3368">3368</a>.</li>
<li>Changed the following 16 issues to Resolved (from New): <a href="2154">2154</a>, <a href="2375">2375</a>, <a href="3006">3006</a>, <a href="3110">3110</a>, <a href="3135">3135</a>, <a href="3156">3156</a>, <a href="3212">3212</a>, <a href="3213">3213</a>, <a href="3258">3258</a>, <a href="3278">3278</a>, <a href="3283">3283</a>, <a href="3289">3289</a>, <a href="3345">3345</a>, <a href="3366">3366</a>, <a href="3376">3376</a>, <a href="3408">3408</a>.</li>
<li>Changed the following 4 issues to Resolved (from Open): <a href="2363">2363</a>, <a href="2741">2741</a>, <a href="3155">3155</a>, <a href="3168">3168</a>.</li>
<li>Changed the following 5 issues to Resolved (from LEWG): <a href="2690">2690</a>, <a href="2814">2814</a>, <a href="2825">2825</a>, <a href="3052">3052</a>, <a href="3228">3228</a>.</li>
<li>Changed the following 10 issues to Resolved (from Tentatively Resolved): <a href="2155">2155</a>, <a href="2292">2292</a>, <a href="2498">2498</a>, <a href="2808">2808</a>, <a href="2832">2832</a>, <a href="2999">2999</a>, <a href="3125">3125</a>, <a href="3151">3151</a>, <a href="3178">3178</a>, <a href="3322">3322</a>.</li>
<li>Changed the following 5 issues to NAD (from Tentatively NAD): <a href="2335">2335</a>, <a href="3207">3207</a>, <a href="3365">3365</a>, <a href="3394">3394</a>, <a href="3399">3399</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="1396">1396</a>.</li>
<li>Changed the following issue to NAD (from LEWG): <a href="3165">3165</a>.</li>
</ul></li>
</ul>
</li>
<li>R121: 
2020-03-02 post-Prague mailing
<ul>
<li><b>Summary:</b><ul>
<li>314 open issues, down by 66.</li>
<li>2586 closed issues, up by 114.</li>
<li>35 reassigned issues, up by 0.</li>
<li>2935 issues total, up by 48.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Tentatively Ready issue: <a href="3368">3368</a>.</li>
<li>Added the following 2 Tentatively NAD issues: <a href="3394">3394</a>, <a href="3399">3399</a>.</li>
<li>Added the following 20 New issues: <a href="3366">3366</a>, <a href="3370">3370</a>, <a href="3376">3376</a>, <a href="3378">3378</a>, <a href="3386">3386</a>, <a href="3391">3391</a>, <a href="3400">3400</a>, <a href="3401">3401</a>, <a href="3402">3402</a>, <a href="3403">3403</a>, <a href="3404">3404</a>, <a href="3405">3405</a>, <a href="3406">3406</a>, <a href="3407">3407</a>, <a href="3408">3408</a>, <a href="3409">3409</a>, <a href="3410">3410</a>, <a href="3411">3411</a>, <a href="3412">3412</a>, <a href="3413">3413</a>.</li>
<li>Added the following LEWG issue: <a href="3392">3392</a>.</li>
<li>Added the following 24 WP issues: <a href="3367">3367</a>, <a href="3369">3369</a>, <a href="3371">3371</a>, <a href="3372">3372</a>, <a href="3373">3373</a>, <a href="3374">3374</a>, <a href="3375">3375</a>, <a href="3377">3377</a>, <a href="3379">3379</a>, <a href="3380">3380</a>, <a href="3381">3381</a>, <a href="3382">3382</a>, <a href="3383">3383</a>, <a href="3384">3384</a>, <a href="3385">3385</a>, <a href="3387">3387</a>, <a href="3388">3388</a>, <a href="3389">3389</a>, <a href="3390">3390</a>, <a href="3393">3393</a>, <a href="3395">3395</a>, <a href="3396">3396</a>, <a href="3397">3397</a>, <a href="3398">3398</a>.</li>
<li>Changed the following 4 issues to Ready (from New): <a href="3117">3117</a>, <a href="3211">3211</a>, <a href="3236">3236</a>, <a href="3249">3249</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2820">2820</a>.</li>
<li>Changed the following 2 issues to Tentatively NAD (from New): <a href="2335">2335</a>, <a href="3365">3365</a>.</li>
<li>Changed the following 2 issues to Open (from New): <a href="2844">2844</a>, <a href="3305">3305</a>.</li>
<li>Changed the following 2 issues to Tentatively Resolved (from New): <a href="2498">2498</a>, <a href="3151">3151</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Open): <a href="3125">3125</a>.</li>
<li>Changed the following 25 issues to WP (from Ready): <a href="3264">3264</a>, <a href="3280">3280</a>, <a href="3281">3281</a>, <a href="3292">3292</a>, <a href="3302">3302</a>, <a href="3303">3303</a>, <a href="3304">3304</a>, <a href="3307">3307</a>, <a href="3310">3310</a>, <a href="3313">3313</a>, <a href="3315">3315</a>, <a href="3316">3316</a>, <a href="3317">3317</a>, <a href="3318">3318</a>, <a href="3319">3319</a>, <a href="3320">3320</a>, <a href="3321">3321</a>, <a href="3323">3323</a>, <a href="3324">3324</a>, <a href="3325">3325</a>, <a href="3326">3326</a>, <a href="3327">3327</a>, <a href="3329">3329</a>, <a href="3330">3330</a>, <a href="3331">3331</a>.</li>
<li>Changed the following 19 issues to WP (from Tentatively Ready): <a href="3194">3194</a>, <a href="3233">3233</a>, <a href="3254">3254</a>, <a href="3284">3284</a>, <a href="3285">3285</a>, <a href="3286">3286</a>, <a href="3291">3291</a>, <a href="3294">3294</a>, <a href="3296">3296</a>, <a href="3299">3299</a>, <a href="3300">3300</a>, <a href="3332">3332</a>, <a href="3338">3338</a>, <a href="3346">3346</a>, <a href="3349">3349</a>, <a href="3350">3350</a>, <a href="3351">3351</a>, <a href="3356">3356</a>, <a href="3360">3360</a>.</li>
<li>Changed the following 36 issues to WP (from New): <a href="3018">3018</a>, <a href="3141">3141</a>, <a href="3150">3150</a>, <a href="3175">3175</a>, <a href="3200">3200</a>, <a href="3201">3201</a>, <a href="3226">3226</a>, <a href="3237">3237</a>, <a href="3238">3238</a>, <a href="3242">3242</a>, <a href="3243">3243</a>, <a href="3247">3247</a>, <a href="3248">3248</a>, <a href="3250">3250</a>, <a href="3251">3251</a>, <a href="3252">3252</a>, <a href="3255">3255</a>, <a href="3260">3260</a>, <a href="3262">3262</a>, <a href="3269">3269</a>, <a href="3270">3270</a>, <a href="3301">3301</a>, <a href="3314">3314</a>, <a href="3328">3328</a>, <a href="3334">3334</a>, <a href="3335">3335</a>, <a href="3340">3340</a>, <a href="3347">3347</a>, <a href="3348">3348</a>, <a href="3352">3352</a>, <a href="3355">3355</a>, <a href="3358">3358</a>, <a href="3359">3359</a>, <a href="3362">3362</a>, <a href="3363">3363</a>, <a href="3364">3364</a>.</li>
<li>Changed the following 4 issues to WP (from Open): <a href="1203">1203</a>, <a href="2859">2859</a>, <a href="3050">3050</a>, <a href="3282">3282</a>.</li>
<li>Changed the following issue to WP (from LEWG): <a href="3354">3354</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="3336">3336</a>.</li>
<li>Changed the following 3 issues to NAD (from New): <a href="3271">3271</a>, <a href="3298">3298</a>, <a href="3333">3333</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="2860">2860</a>.</li>
</ul></li>
</ul>
</li>
<li>R120: 
2020-01-13 pre-Prague mailing
<ul>
<li><b>Summary:</b><ul>
<li>380 open issues, up by 4.</li>
<li>2472 closed issues, up by 7.</li>
<li>35 reassigned issues, up by 0.</li>
<li>2887 issues total, up by 11.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 2 Tentatively Ready issues: <a href="3356">3356</a>, <a href="3360">3360</a>.</li>
<li>Added the following 8 New issues: <a href="3355">3355</a>, <a href="3358">3358</a>, <a href="3359">3359</a>, <a href="3361">3361</a>, <a href="3362">3362</a>, <a href="3363">3363</a>, <a href="3364">3364</a>, <a href="3365">3365</a>.</li>
<li>Added the following LEWG issue: <a href="3357">3357</a>.</li>
<li>Changed the following 2 issues to Ready (from New): <a href="3280">3280</a>, <a href="3292">3292</a>.</li>
<li>Changed the following issue to Ready (from LEWG): <a href="3304">3304</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from New): <a href="3194">3194</a>, <a href="3254">3254</a>, <a href="3349">3349</a>, <a href="3350">3350</a>, <a href="3351">3351</a>.</li>
<li>Changed the following issue to LEWG (from New): <a href="3354">3354</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Ready): <a href="3322">3322</a>.</li>
<li>Changed the following 3 issues to Resolved (from New): <a href="2957">2957</a>, <a href="3023">3023</a>, <a href="3176">3176</a>.</li>
<li>Changed the following 3 issues to Resolved (from Open): <a href="2894">2894</a>, <a href="3061">3061</a>, <a href="3295">3295</a>.</li>
<li>Changed the following issue to Resolved (from EWG): <a href="2089">2089</a>.</li>
</ul></li>
</ul>
</li>
<li>R119: 
2019-12-09 post-Belfast mailing
<ul>
<li><b>Summary:</b><ul>
<li>376 open issues, up by 25.</li>
<li>2465 closed issues, up by 32.</li>
<li>35 reassigned issues, down by 1.</li>
<li>2876 issues total, up by 56.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 21 Ready issues: <a href="3302">3302</a>, <a href="3303">3303</a>, <a href="3307">3307</a>, <a href="3310">3310</a>, <a href="3313">3313</a>, <a href="3315">3315</a>, <a href="3316">3316</a>, <a href="3317">3317</a>, <a href="3318">3318</a>, <a href="3319">3319</a>, <a href="3320">3320</a>, <a href="3321">3321</a>, <a href="3322">3322</a>, <a href="3323">3323</a>, <a href="3324">3324</a>, <a href="3325">3325</a>, <a href="3326">3326</a>, <a href="3327">3327</a>, <a href="3329">3329</a>, <a href="3330">3330</a>, <a href="3331">3331</a>.</li>
<li>Added the following 5 Tentatively Ready issues: <a href="3299">3299</a>, <a href="3300">3300</a>, <a href="3332">3332</a>, <a href="3338">3338</a>, <a href="3346">3346</a>.</li>
<li>Added the following 27 New issues: <a href="3301">3301</a>, <a href="3305">3305</a>, <a href="3306">3306</a>, <a href="3308">3308</a>, <a href="3309">3309</a>, <a href="3314">3314</a>, <a href="3328">3328</a>, <a href="3333">3333</a>, <a href="3334">3334</a>, <a href="3335">3335</a>, <a href="3336">3336</a>, <a href="3337">3337</a>, <a href="3339">3339</a>, <a href="3340">3340</a>, <a href="3341">3341</a>, <a href="3342">3342</a>, <a href="3343">3343</a>, <a href="3344">3344</a>, <a href="3345">3345</a>, <a href="3347">3347</a>, <a href="3348">3348</a>, <a href="3349">3349</a>, <a href="3350">3350</a>, <a href="3351">3351</a>, <a href="3352">3352</a>, <a href="3353">3353</a>, <a href="3354">3354</a>.</li>
<li>Added the following LEWG issue: <a href="3304">3304</a>.</li>
<li>Added the following 2 Dup issues: <a href="3311">3311</a>, <a href="3312">3312</a>.</li>
<li>Changed the following issue to Ready (from New): <a href="3264">3264</a>.</li>
<li>Changed the following issue to Ready (from LEWG): <a href="3281">3281</a>.</li>
<li>Changed the following 7 issues to Tentatively Ready (from New): <a href="3233">3233</a>, <a href="3284">3284</a>, <a href="3285">3285</a>, <a href="3286">3286</a>, <a href="3291">3291</a>, <a href="3294">3294</a>, <a href="3296">3296</a>.</li>
<li>Changed the following issue to Open (from New): <a href="3295">3295</a>.</li>
<li>Changed the following issue to Open (from LEWG): <a href="3282">3282</a>.</li>
<li>Changed the following issue to LEWG (from New): <a href="3228">3228</a>.</li>
<li>Changed the following 4 issues to WP (from Ready): <a href="3070">3070</a>, <a href="3103">3103</a>, <a href="3149">3149</a>, <a href="3190">3190</a>.</li>
<li>Changed the following 23 issues to WP (from Tentatively Ready): <a href="3218">3218</a>, <a href="3221">3221</a>, <a href="3222">3222</a>, <a href="3224">3224</a>, <a href="3225">3225</a>, <a href="3230">3230</a>, <a href="3231">3231</a>, <a href="3232">3232</a>, <a href="3235">3235</a>, <a href="3241">3241</a>, <a href="3244">3244</a>, <a href="3245">3245</a>, <a href="3246">3246</a>, <a href="3253">3253</a>, <a href="3256">3256</a>, <a href="3257">3257</a>, <a href="3259">3259</a>, <a href="3266">3266</a>, <a href="3272">3272</a>, <a href="3273">3273</a>, <a href="3274">3274</a>, <a href="3276">3276</a>, <a href="3277">3277</a>.</li>
<li>Changed the following 2 issues to Resolved (from New): <a href="3239">3239</a>, <a href="3279">3279</a>.</li>
<li>Changed the following issue to Resolved (from SG1): <a href="2334">2334</a>.</li>
</ul></li>
</ul>
</li>
<li>R118: 
2019-10-06 pre-Belfast mailing
<ul>
<li><b>Summary:</b><ul>
<li>351 open issues, up by 48.</li>
<li>2433 closed issues, up by 0.</li>
<li>36 reassigned issues, up by 2.</li>
<li>2820 issues total, up by 50.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 10 Tentatively Ready issues: <a href="3253">3253</a>, <a href="3256">3256</a>, <a href="3257">3257</a>, <a href="3259">3259</a>, <a href="3266">3266</a>, <a href="3272">3272</a>, <a href="3273">3273</a>, <a href="3274">3274</a>, <a href="3276">3276</a>, <a href="3277">3277</a>.</li>
<li>Added the following 38 New issues: <a href="3249">3249</a>, <a href="3250">3250</a>, <a href="3251">3251</a>, <a href="3252">3252</a>, <a href="3254">3254</a>, <a href="3255">3255</a>, <a href="3258">3258</a>, <a href="3260">3260</a>, <a href="3261">3261</a>, <a href="3262">3262</a>, <a href="3263">3263</a>, <a href="3264">3264</a>, <a href="3265">3265</a>, <a href="3267">3267</a>, <a href="3268">3268</a>, <a href="3269">3269</a>, <a href="3270">3270</a>, <a href="3271">3271</a>, <a href="3275">3275</a>, <a href="3278">3278</a>, <a href="3279">3279</a>, <a href="3280">3280</a>, <a href="3283">3283</a>, <a href="3284">3284</a>, <a href="3285">3285</a>, <a href="3286">3286</a>, <a href="3287">3287</a>, <a href="3288">3288</a>, <a href="3289">3289</a>, <a href="3290">3290</a>, <a href="3291">3291</a>, <a href="3292">3292</a>, <a href="3293">3293</a>, <a href="3294">3294</a>, <a href="3295">3295</a>, <a href="3296">3296</a>, <a href="3297">3297</a>, <a href="3298">3298</a>.</li>
<li>Added the following 2 LEWG issues: <a href="3281">3281</a>, <a href="3282">3282</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from New): <a href="3235">3235</a>, <a href="3241">3241</a>, <a href="3244">3244</a>, <a href="3245">3245</a>, <a href="3246">3246</a>.</li>
</ul></li>
</ul>
</li>
<li>R117: 
2019-08-05 post-Cologne mailing
<ul>
<li><b>Summary:</b><ul>
<li>303 open issues, up by 8.</li>
<li>2433 closed issues, up by 20.</li>
<li>34 reassigned issues, down by 1.</li>
<li>2770 issues total, up by 27.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 6 Tentatively Ready issues: <a href="3222">3222</a>, <a href="3224">3224</a>, <a href="3225">3225</a>, <a href="3230">3230</a>, <a href="3231">3231</a>, <a href="3232">3232</a>.</li>
<li>Added the following 21 New issues: <a href="3223">3223</a>, <a href="3226">3226</a>, <a href="3227">3227</a>, <a href="3228">3228</a>, <a href="3229">3229</a>, <a href="3233">3233</a>, <a href="3234">3234</a>, <a href="3235">3235</a>, <a href="3236">3236</a>, <a href="3237">3237</a>, <a href="3238">3238</a>, <a href="3239">3239</a>, <a href="3240">3240</a>, <a href="3241">3241</a>, <a href="3242">3242</a>, <a href="3243">3243</a>, <a href="3244">3244</a>, <a href="3245">3245</a>, <a href="3246">3246</a>, <a href="3247">3247</a>, <a href="3248">3248</a>.</li>
<li>Changed the following 2 issues to Ready (from New): <a href="3070">3070</a>, <a href="3190">3190</a>.</li>
<li>Changed the following 2 issues to Ready (from Open): <a href="3103">3103</a>, <a href="3149">3149</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="3218">3218</a>, <a href="3221">3221</a>.</li>
<li>Changed the following 2 issues to Open (from New): <a href="2818">2818</a>, <a href="3170">3170</a>.</li>
<li>Changed the following 6 issues to WP (from Ready): <a href="2899">2899</a>, <a href="3055">3055</a>, <a href="3158">3158</a>, <a href="3169">3169</a>, <a href="3186">3186</a>, <a href="3187">3187</a>.</li>
<li>Changed the following 11 issues to WP (from Tentatively Ready): <a href="3183">3183</a>, <a href="3184">3184</a>, <a href="3185">3185</a>, <a href="3191">3191</a>, <a href="3196">3196</a>, <a href="3198">3198</a>, <a href="3199">3199</a>, <a href="3202">3202</a>, <a href="3206">3206</a>, <a href="3208">3208</a>, <a href="3209">3209</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="3091">3091</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="3139">3139</a>.</li>
<li>Changed the following issue to NAD (from LEWG): <a href="3138">3138</a>.</li>
</ul></li>
</ul>
</li>
<li>R116: 
2019-06-17 pre-Cologne mailing
<ul>
<li><b>Summary:</b><ul>
<li>295 open issues, up by 25.</li>
<li>2413 closed issues, up by 0.</li>
<li>35 reassigned issues, up by 0.</li>
<li>2743 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 6 Tentatively Ready issues: <a href="3198">3198</a>, <a href="3199">3199</a>, <a href="3202">3202</a>, <a href="3206">3206</a>, <a href="3208">3208</a>, <a href="3209">3209</a>.</li>
<li>Added the following Tentatively NAD issue: <a href="3207">3207</a>.</li>
<li>Added the following 18 New issues: <a href="3197">3197</a>, <a href="3200">3200</a>, <a href="3201">3201</a>, <a href="3203">3203</a>, <a href="3204">3204</a>, <a href="3205">3205</a>, <a href="3210">3210</a>, <a href="3211">3211</a>, <a href="3212">3212</a>, <a href="3213">3213</a>, <a href="3214">3214</a>, <a href="3215">3215</a>, <a href="3216">3216</a>, <a href="3217">3217</a>, <a href="3218">3218</a>, <a href="3219">3219</a>, <a href="3220">3220</a>, <a href="3221">3221</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="3191">3191</a>, <a href="3196">3196</a>.</li>
</ul></li>
</ul>
</li>
<li>R115: 
2019-04-02 post-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>270 open issues, down by 19.</li>
<li>2413 closed issues, up by 31.</li>
<li>35 reassigned issues, up by 0.</li>
<li>2718 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 2 Ready issues: <a href="3186">3186</a>, <a href="3187">3187</a>.</li>
<li>Added the following Tentatively Ready issue: <a href="3185">3185</a>.</li>
<li>Added the following 9 New issues: <a href="3188">3188</a>, <a href="3189">3189</a>, <a href="3190">3190</a>, <a href="3191">3191</a>, <a href="3192">3192</a>, <a href="3193">3193</a>, <a href="3194">3194</a>, <a href="3195">3195</a>, <a href="3196">3196</a>.</li>
<li>Changed the following 3 issues to Ready (from New): <a href="3055">3055</a>, <a href="3158">3158</a>, <a href="3169">3169</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="2899">2899</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="3183">3183</a>, <a href="3184">3184</a>.</li>
<li>Changed the following 4 issues to Open (from New): <a href="3036">3036</a>, <a href="3161">3161</a>, <a href="3168">3168</a>, <a href="3171">3171</a>.</li>
<li>Changed the following 5 issues to Tentatively Resolved (from New): <a href="2292">2292</a>, <a href="2808">2808</a>, <a href="2832">2832</a>, <a href="2999">2999</a>, <a href="3178">3178</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Open): <a href="2155">2155</a>.</li>
<li>Changed the following 2 issues to WP (from Ready): <a href="3012">3012</a>, <a href="3119">3119</a>.</li>
<li>Changed the following 11 issues to WP (from Tentatively Ready): <a href="3040">3040</a>, <a href="3077">3077</a>, <a href="3087">3087</a>, <a href="3101">3101</a>, <a href="3112">3112</a>, <a href="3133">3133</a>, <a href="3144">3144</a>, <a href="3173">3173</a>, <a href="3179">3179</a>, <a href="3180">3180</a>, <a href="3182">3182</a>.</li>
<li>Changed the following 2 issues to Resolved (from New): <a href="2951">2951</a>, <a href="3113">3113</a>.</li>
<li>Changed the following 16 issues to NAD (from Tentatively NAD): <a href="708">708</a>, <a href="935">935</a>, <a href="1121">1121</a>, <a href="1154">1154</a>, <a href="1188">1188</a>, <a href="1217">1217</a>, <a href="1235">1235</a>, <a href="1282">1282</a>, <a href="1289">1289</a>, <a href="1317">1317</a>, <a href="1406">1406</a>, <a href="1499">1499</a>, <a href="2226">2226</a>, <a href="2417">2417</a>, <a href="2600">2600</a>, <a href="3106">3106</a>.</li>
</ul></li>
</ul>
</li>
<li>R114: 
2019-01-21 pre-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>289 open issues, up by 14.</li>
<li>2382 closed issues, up by 1.</li>
<li>35 reassigned issues, up by 0.</li>
<li>2706 issues total, up by 15.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 4 Tentatively Ready issues: <a href="3173">3173</a>, <a href="3179">3179</a>, <a href="3180">3180</a>, <a href="3182">3182</a>.</li>
<li>Added the following 10 New issues: <a href="3170">3170</a>, <a href="3171">3171</a>, <a href="3172">3172</a>, <a href="3174">3174</a>, <a href="3175">3175</a>, <a href="3176">3176</a>, <a href="3177">3177</a>, <a href="3178">3178</a>, <a href="3183">3183</a>, <a href="3184">3184</a>.</li>
<li>Added the following NAD issue: <a href="3181">3181</a>.</li>
<li>Changed the following 4 issues to Tentatively Ready (from New): <a href="3077">3077</a>, <a href="3112">3112</a>, <a href="3133">3133</a>, <a href="3144">3144</a>.</li>
</ul></li>
</ul>
</li>
<li>R113: 
2018-11-26 post-San Diego mailing
<ul>
<li><b>Summary:</b><ul>
<li>275 open issues, down by 45.</li>
<li>2381 closed issues, up by 52.</li>
<li>35 reassigned issues, up by 0.</li>
<li>2691 issues total, up by 7.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 4 New issues: <a href="3166">3166</a>, <a href="3167">3167</a>, <a href="3168">3168</a>, <a href="3169">3169</a>.</li>
<li>Added the following LEWG issue: <a href="3165">3165</a>.</li>
<li>Added the following 2 NAD issues: <a href="3163">3163</a>, <a href="3164">3164</a>.</li>
<li>Changed the following issue to Ready (from New): <a href="3119">3119</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="3012">3012</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="3087">3087</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="3040">3040</a>.</li>
<li>Changed the following issue to Tentatively Ready (from LEWG): <a href="3101">3101</a>.</li>
<li>Changed the following 7 issues to Open (from New): <a href="2962">2962</a>, <a href="2994">2994</a>, <a href="3057">3057</a>, <a href="3061">3061</a>, <a href="3103">3103</a>, <a href="3121">3121</a>, <a href="3149">3149</a>.</li>
<li>Changed the following 2 issues to Open (from Core): <a href="2859">2859</a>, <a href="2860">2860</a>.</li>
<li>Changed the following issue to LEWG (from New): <a href="3138">3138</a>.</li>
<li>Changed the following issue to LEWG (from Open): <a href="2307">2307</a>.</li>
<li>Changed the following 10 issues to WP (from Ready): <a href="2183">2183</a>, <a href="2184">2184</a>, <a href="2412">2412</a>, <a href="2682">2682</a>, <a href="2697">2697</a>, <a href="2936">2936</a>, <a href="2995">2995</a>, <a href="2996">2996</a>, <a href="3054">3054</a>, <a href="3116">3116</a>.</li>
<li>Changed the following 24 issues to WP (from Tentatively Ready): <a href="2943">2943</a>, <a href="2960">2960</a>, <a href="3008">3008</a>, <a href="3025">3025</a>, <a href="3031">3031</a>, <a href="3037">3037</a>, <a href="3038">3038</a>, <a href="3065">3065</a>, <a href="3096">3096</a>, <a href="3122">3122</a>, <a href="3127">3127</a>, <a href="3128">3128</a>, <a href="3129">3129</a>, <a href="3130">3130</a>, <a href="3131">3131</a>, <a href="3132">3132</a>, <a href="3137">3137</a>, <a href="3140">3140</a>, <a href="3145">3145</a>, <a href="3147">3147</a>, <a href="3148">3148</a>, <a href="3153">3153</a>, <a href="3154">3154</a>, <a href="3160">3160</a>.</li>
<li>Changed the following issue to Resolved (from Tentatively Ready): <a href="3134">3134</a>.</li>
<li>Changed the following 6 issues to Resolved (from New): <a href="2318">2318</a>, <a href="2836">2836</a>, <a href="2841">2841</a>, <a href="2929">2929</a>, <a href="3022">3022</a>, <a href="3115">3115</a>.</li>
<li>Changed the following 6 issues to Resolved (from Open): <a href="1052">1052</a>, <a href="2151">2151</a>, <a href="2499">2499</a>, <a href="2780">2780</a>, <a href="2797">2797</a>, <a href="3111">3111</a>.</li>
<li>Changed the following 2 issues to NAD (from New): <a href="2563">2563</a>, <a href="3016">3016</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="1242">1242</a>.</li>
</ul></li>
</ul>
</li>
<li>R112: 
2018-10-08 pre-San Diego mailing
<ul>
<li><b>Summary:</b><ul>
<li>320 open issues, up by 36.</li>
<li>2329 closed issues, up by 3.</li>
<li>35 reassigned issues, up by 0.</li>
<li>2684 issues total, up by 39.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 15 Tentatively Ready issues: <a href="3127">3127</a>, <a href="3128">3128</a>, <a href="3129">3129</a>, <a href="3130">3130</a>, <a href="3131">3131</a>, <a href="3132">3132</a>, <a href="3134">3134</a>, <a href="3137">3137</a>, <a href="3140">3140</a>, <a href="3145">3145</a>, <a href="3147">3147</a>, <a href="3148">3148</a>, <a href="3153">3153</a>, <a href="3154">3154</a>, <a href="3160">3160</a>.</li>
<li>Added the following 22 New issues: <a href="3124">3124</a>, <a href="3126">3126</a>, <a href="3133">3133</a>, <a href="3135">3135</a>, <a href="3136">3136</a>, <a href="3138">3138</a>, <a href="3139">3139</a>, <a href="3141">3141</a>, <a href="3142">3142</a>, <a href="3143">3143</a>, <a href="3144">3144</a>, <a href="3146">3146</a>, <a href="3149">3149</a>, <a href="3150">3150</a>, <a href="3151">3151</a>, <a href="3152">3152</a>, <a href="3156">3156</a>, <a href="3157">3157</a>, <a href="3158">3158</a>, <a href="3159">3159</a>, <a href="3161">3161</a>, <a href="3162">3162</a>.</li>
<li>Added the following 2 Open issues: <a href="3125">3125</a>, <a href="3155">3155</a>.</li>
<li>Changed the following 6 issues to Tentatively Ready (from New): <a href="2960">2960</a>, <a href="3025">3025</a>, <a href="3031">3031</a>, <a href="3037">3037</a>, <a href="3065">3065</a>, <a href="3096">3096</a>.</li>
<li>Changed the following 3 issues to Tentatively Ready (from Open): <a href="2943">2943</a>, <a href="3008">3008</a>, <a href="3038">3038</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="3106">3106</a>.</li>
<li>Changed the following 5 issues to Open (from New): <a href="2220">2220</a>, <a href="3081">3081</a>, <a href="3085">3085</a>, <a href="3092">3092</a>, <a href="3120">3120</a>.</li>
<li>Changed the following issue to EWG (from Open): <a href="2813">2813</a>.</li>
<li>Changed the following issue to Resolved (from Tentatively NAD): <a href="1150">1150</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2840">2840</a>.</li>
<li>Changed the following issue to Resolved (from LEWG): <a href="1201">1201</a>.</li>
</ul></li>
</ul>
</li>
<li>R111: 
2018-06-25 post-Rapperswil mailing
<ul>
<li><b>Summary:</b><ul>
<li>284 open issues, up by 15.</li>
<li>2326 closed issues, up by 25.</li>
<li>35 reassigned issues, down by 26.</li>
<li>2645 issues total, up by 14.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Ready issue: <a href="3116">3116</a>.</li>
<li>Added the following Tentatively Ready issue: <a href="3122">3122</a>.</li>
<li>Added the following 10 New issues: <a href="3110">3110</a>, <a href="3112">3112</a>, <a href="3113">3113</a>, <a href="3115">3115</a>, <a href="3117">3117</a>, <a href="3118">3118</a>, <a href="3119">3119</a>, <a href="3120">3120</a>, <a href="3121">3121</a>, <a href="3123">3123</a>.</li>
<li>Added the following Open issue: <a href="3111">3111</a>.</li>
<li>Added the following LEWG issue: <a href="3114">3114</a>.</li>
<li>Changed the following 4 issues to Ready (from Review): <a href="2412">2412</a>, <a href="2682">2682</a>, <a href="2697">2697</a>, <a href="2936">2936</a>.</li>
<li>Changed the following 4 issues to Ready (from New): <a href="2183">2183</a>, <a href="2184">2184</a>, <a href="2995">2995</a>, <a href="3054">3054</a>.</li>
<li>Changed the following issue to Ready (from LEWG): <a href="2996">2996</a>.</li>
<li>Changed the following 16 issues to Tentatively NAD (from LEWG): <a href="708">708</a>, <a href="935">935</a>, <a href="1121">1121</a>, <a href="1150">1150</a>, <a href="1154">1154</a>, <a href="1188">1188</a>, <a href="1217">1217</a>, <a href="1235">1235</a>, <a href="1282">1282</a>, <a href="1289">1289</a>, <a href="1317">1317</a>, <a href="1406">1406</a>, <a href="1499">1499</a>, <a href="2226">2226</a>, <a href="2417">2417</a>, <a href="2600">2600</a>.</li>
<li>Changed the following issue to Open (from Review): <a href="2708">2708</a>.</li>
<li>Changed the following 7 issues to Open (from New): <a href="2173">2173</a>, <a href="2286">2286</a>, <a href="2829">2829</a>, <a href="3008">3008</a>, <a href="3038">3038</a>, <a href="3050">3050</a>, <a href="3082">3082</a>.</li>
<li>Changed the following 11 issues to Open (from LEWG): <a href="423">423</a>, <a href="523">523</a>, <a href="1052">1052</a>, <a href="1203">1203</a>, <a href="1238">1238</a>, <a href="1242">1242</a>, <a href="1396">1396</a>, <a href="1521">1521</a>, <a href="2471">2471</a>, <a href="2762">2762</a>, <a href="2780">2780</a>.</li>
<li>Changed the following 3 issues to LEWG (from New): <a href="3052">3052</a>, <a href="3068">3068</a>, <a href="3101">3101</a>.</li>
<li>Changed the following 3 issues to WP (from Ready): <a href="2139">2139</a>, <a href="3058">3058</a>, <a href="3076">3076</a>.</li>
<li>Changed the following 12 issues to WP (from Tentatively Ready): <a href="2970">2970</a>, <a href="3062">3062</a>, <a href="3067">3067</a>, <a href="3071">3071</a>, <a href="3074">3074</a>, <a href="3079">3079</a>, <a href="3080">3080</a>, <a href="3083">3083</a>, <a href="3094">3094</a>, <a href="3100">3100</a>, <a href="3102">3102</a>, <a href="3104">3104</a>.</li>
<li>Changed the following 4 issues to Resolved (from New): <a href="2511">2511</a>, <a href="2693">2693</a>, <a href="2776">2776</a>, <a href="2938">2938</a>.</li>
<li>Changed the following 2 issues to Resolved (from Open): <a href="2800">2800</a>, <a href="2897">2897</a>.</li>
<li>Changed the following 2 issues to Resolved (from LEWG): <a href="2040">2040</a>, <a href="2419">2419</a>.</li>
<li>Changed the following 2 issues to NAD (from New): <a href="2121">2121</a>, <a href="2892">2892</a>.</li>
</ul></li>
</ul>
</li>
<li>R110: 
2018-05-07 pre-Rapperswil mailing
<ul>
<li><b>Summary:</b><ul>
<li>269 open issues, up by 17.</li>
<li>2301 closed issues, up by 0.</li>
<li>61 reassigned issues, up by 0.</li>
<li>2631 issues total, up by 17.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 4 Tentatively Ready issues: <a href="3094">3094</a>, <a href="3100">3100</a>, <a href="3102">3102</a>, <a href="3104">3104</a>.</li>
<li>Added the following 13 New issues: <a href="3093">3093</a>, <a href="3095">3095</a>, <a href="3096">3096</a>, <a href="3097">3097</a>, <a href="3098">3098</a>, <a href="3099">3099</a>, <a href="3101">3101</a>, <a href="3103">3103</a>, <a href="3105">3105</a>, <a href="3106">3106</a>, <a href="3107">3107</a>, <a href="3108">3108</a>, <a href="3109">3109</a>.</li>
<li>No issues changed.</li>
</ul></li>
</ul>
</li>
<li>R109: 
2018-04-02 post-Jacksonville mailing
<ul>
<li><b>Summary:</b><ul>
<li>252 open issues, down by 5.</li>
<li>2301 closed issues, up by 36.</li>
<li>61 reassigned issues, down by 1.</li>
<li>2614 issues total, up by 30.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Ready issue: <a href="3076">3076</a>.</li>
<li>Added the following 6 Tentatively Ready issues: <a href="3067">3067</a>, <a href="3071">3071</a>, <a href="3074">3074</a>, <a href="3079">3079</a>, <a href="3080">3080</a>, <a href="3083">3083</a>.</li>
<li>Added the following 22 New issues: <a href="3063">3063</a>, <a href="3064">3064</a>, <a href="3065">3065</a>, <a href="3066">3066</a>, <a href="3068">3068</a>, <a href="3069">3069</a>, <a href="3070">3070</a>, <a href="3072">3072</a>, <a href="3073">3073</a>, <a href="3077">3077</a>, <a href="3078">3078</a>, <a href="3081">3081</a>, <a href="3082">3082</a>, <a href="3084">3084</a>, <a href="3085">3085</a>, <a href="3086">3086</a>, <a href="3087">3087</a>, <a href="3088">3088</a>, <a href="3089">3089</a>, <a href="3090">3090</a>, <a href="3091">3091</a>, <a href="3092">3092</a>.</li>
<li>Added the following WP issue: <a href="3075">3075</a>.</li>
<li>Changed the following issue to Ready (from New): <a href="3058">3058</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="2139">2139</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="2970">2970</a>, <a href="3062">3062</a>.</li>
<li>Changed the following 2 issues to Open (from New): <a href="2823">2823</a>, <a href="3049">3049</a>.</li>
<li>Changed the following issue to SG1 (from New): <a href="2506">2506</a>.</li>
<li>Changed the following 5 issues to WP (from Ready): <a href="2843">2843</a>, <a href="2969">2969</a>, <a href="2975">2975</a>, <a href="3014">3014</a>, <a href="3030">3030</a>.</li>
<li>Changed the following 27 issues to WP (from Tentatively Ready): <a href="2164">2164</a>, <a href="2243">2243</a>, <a href="2816">2816</a>, <a href="2849">2849</a>, <a href="2851">2851</a>, <a href="2989">2989</a>, <a href="3000">3000</a>, <a href="3002">3002</a>, <a href="3004">3004</a>, <a href="3005">3005</a>, <a href="3007">3007</a>, <a href="3009">3009</a>, <a href="3010">3010</a>, <a href="3013">3013</a>, <a href="3015">3015</a>, <a href="3017">3017</a>, <a href="3020">3020</a>, <a href="3026">3026</a>, <a href="3034">3034</a>, <a href="3035">3035</a>, <a href="3039">3039</a>, <a href="3041">3041</a>, <a href="3042">3042</a>, <a href="3043">3043</a>, <a href="3045">3045</a>, <a href="3048">3048</a>, <a href="3051">3051</a>.</li>
<li>Changed the following issue to WP (from New): <a href="2946">2946</a>.</li>
<li>Changed the following 2 issues to Resolved (from LEWG): <a href="2831">2831</a>, <a href="2968">2968</a>.</li>
</ul></li>
</ul>
</li>
<li>R108: 
2018-02-12 pre-Jacksonville mailing
<ul>
<li><b>Summary:</b><ul>
<li>257 open issues, up by 16.</li>
<li>2265 closed issues, up by 7.</li>
<li>62 reassigned issues, up by 0.</li>
<li>2584 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 6 Tentatively Ready issues: <a href="3041">3041</a>, <a href="3042">3042</a>, <a href="3043">3043</a>, <a href="3045">3045</a>, <a href="3048">3048</a>, <a href="3051">3051</a>.</li>
<li>Added the following 16 New issues: <a href="3044">3044</a>, <a href="3046">3046</a>, <a href="3047">3047</a>, <a href="3049">3049</a>, <a href="3050">3050</a>, <a href="3052">3052</a>, <a href="3053">3053</a>, <a href="3054">3054</a>, <a href="3055">3055</a>, <a href="3056">3056</a>, <a href="3057">3057</a>, <a href="3058">3058</a>, <a href="3059">3059</a>, <a href="3060">3060</a>, <a href="3061">3061</a>, <a href="3062">3062</a>.</li>
<li>Added the following Open issue: <a href="3040">3040</a>.</li>
<li>Changed the following 6 issues to Tentatively Ready (from New): <a href="2243">2243</a>, <a href="2816">2816</a>, <a href="2849">2849</a>, <a href="2851">2851</a>, <a href="2989">2989</a>, <a href="3015">3015</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2164">2164</a>.</li>
<li>Changed the following 3 issues to Review (from Open): <a href="2682">2682</a>, <a href="2708">2708</a>, <a href="2936">2936</a>.</li>
<li>Changed the following 4 issues to Open (from New): <a href="2839">2839</a>, <a href="2840">2840</a>, <a href="2990">2990</a>, <a href="3003">3003</a>.</li>
<li>Changed the following 2 issues to C++17 (from Open): <a href="2569">2569</a>, <a href="2587">2587</a>.</li>
<li>Changed the following 3 issues to Resolved (from New): <a href="2734">2734</a>, <a href="2821">2821</a>, <a href="2856">2856</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2055">2055</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2772">2772</a>.</li>
</ul></li>
</ul>
</li>
<li>R107: 
2017-11-28 2017 post-Albuquerque mailing
<ul>
<li><b>Summary:</b><ul>
<li>241 open issues, down by 16.</li>
<li>2258 closed issues, up by 29.</li>
<li>62 reassigned issues, up by 0.</li>
<li>2561 issues total, up by 13.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Ready issue: <a href="3030">3030</a>.</li>
<li>Added the following 3 Tentatively Ready issues: <a href="3034">3034</a>, <a href="3035">3035</a>, <a href="3039">3039</a>.</li>
<li>Added the following 7 New issues: <a href="3027">3027</a>, <a href="3028">3028</a>, <a href="3031">3031</a>, <a href="3032">3032</a>, <a href="3036">3036</a>, <a href="3037">3037</a>, <a href="3038">3038</a>.</li>
<li>Added the following Open issue: <a href="3029">3029</a>.</li>
<li>Added the following NAD Editorial issue: <a href="3033">3033</a>.</li>
<li>Changed the following 4 issues to Ready (from New): <a href="2843">2843</a>, <a href="2969">2969</a>, <a href="2975">2975</a>, <a href="3014">3014</a>.</li>
<li>Changed the following 11 issues to Tentatively Ready (from New): <a href="3000">3000</a>, <a href="3002">3002</a>, <a href="3004">3004</a>, <a href="3005">3005</a>, <a href="3007">3007</a>, <a href="3009">3009</a>, <a href="3010">3010</a>, <a href="3013">3013</a>, <a href="3017">3017</a>, <a href="3020">3020</a>, <a href="3026">3026</a>.</li>
<li>Changed the following 6 issues to Open (from New): <a href="2800">2800</a>, <a href="2833">2833</a>, <a href="2897">2897</a>, <a href="2943">2943</a>, <a href="3011">3011</a>, <a href="3012">3012</a>.</li>
<li>Changed the following 23 issues to WP (from Ready): <a href="2779">2779</a>, <a href="2870">2870</a>, <a href="2935">2935</a>, <a href="2941">2941</a>, <a href="2944">2944</a>, <a href="2945">2945</a>, <a href="2948">2948</a>, <a href="2950">2950</a>, <a href="2952">2952</a>, <a href="2953">2953</a>, <a href="2964">2964</a>, <a href="2965">2965</a>, <a href="2972">2972</a>, <a href="2976">2976</a>, <a href="2977">2977</a>, <a href="2978">2978</a>, <a href="2979">2979</a>, <a href="2980">2980</a>, <a href="2981">2981</a>, <a href="2982">2982</a>, <a href="2988">2988</a>, <a href="2993">2993</a>, <a href="2998">2998</a>.</li>
<li>Changed the following 2 issues to WP (from Tentatively Ready): <a href="3001">3001</a>, <a href="3024">3024</a>.</li>
<li>Changed the following issue to WP (from New): <a href="2958">2958</a>.</li>
<li>Changed the following 2 issues to Resolved (from New): <a href="2541">2541</a>, <a href="2799">2799</a>.</li>
</ul></li>
</ul>
</li>
<li>R106: 
2017-10-16 2017 pre-Albuquerque mailing
<ul>
<li><b>Summary:</b><ul>
<li>257 open issues, up by 22.</li>
<li>2229 closed issues, up by 0.</li>
<li>62 reassigned issues, up by 0.</li>
<li>2548 issues total, up by 22.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Tentatively Ready issue: <a href="3024">3024</a>.</li>
<li>Added the following 21 New issues: <a href="3005">3005</a>, <a href="3006">3006</a>, <a href="3007">3007</a>, <a href="3008">3008</a>, <a href="3009">3009</a>, <a href="3010">3010</a>, <a href="3011">3011</a>, <a href="3012">3012</a>, <a href="3013">3013</a>, <a href="3014">3014</a>, <a href="3015">3015</a>, <a href="3016">3016</a>, <a href="3017">3017</a>, <a href="3018">3018</a>, <a href="3019">3019</a>, <a href="3020">3020</a>, <a href="3021">3021</a>, <a href="3022">3022</a>, <a href="3023">3023</a>, <a href="3025">3025</a>, <a href="3026">3026</a>.</li>
<li>No issues changed.</li>
</ul></li>
</ul>
</li>
<li>R105: 
2017-07-30 2017 post-Toronto mailing
<ul>
<li><b>Summary:</b><ul>
<li>235 open issues, down by 22.</li>
<li>2229 closed issues, up by 36.</li>
<li>62 reassigned issues, up by 8.</li>
<li>2526 issues total, up by 22.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 Ready issues: <a href="2988">2988</a>, <a href="2993">2993</a>, <a href="2998">2998</a>.</li>
<li>Added the following Tentatively Ready issue: <a href="3001">3001</a>.</li>
<li>Added the following 14 New issues: <a href="2983">2983</a>, <a href="2984">2984</a>, <a href="2986">2986</a>, <a href="2987">2987</a>, <a href="2989">2989</a>, <a href="2990">2990</a>, <a href="2994">2994</a>, <a href="2995">2995</a>, <a href="2997">2997</a>, <a href="2999">2999</a>, <a href="3000">3000</a>, <a href="3002">3002</a>, <a href="3003">3003</a>, <a href="3004">3004</a>.</li>
<li>Added the following 3 LEWG issues: <a href="2985">2985</a>, <a href="2991">2991</a>, <a href="2996">2996</a>.</li>
<li>Added the following NAD issue: <a href="2992">2992</a>.</li>
<li>Changed the following 19 issues to Ready (from New): <a href="2870">2870</a>, <a href="2935">2935</a>, <a href="2941">2941</a>, <a href="2944">2944</a>, <a href="2945">2945</a>, <a href="2948">2948</a>, <a href="2950">2950</a>, <a href="2952">2952</a>, <a href="2953">2953</a>, <a href="2964">2964</a>, <a href="2965">2965</a>, <a href="2972">2972</a>, <a href="2976">2976</a>, <a href="2977">2977</a>, <a href="2978">2978</a>, <a href="2979">2979</a>, <a href="2980">2980</a>, <a href="2981">2981</a>, <a href="2982">2982</a>.</li>
<li>Changed the following issue to Ready (from LEWG): <a href="2779">2779</a>.</li>
<li>Changed the following 6 issues to Open (from New): <a href="2731">2731</a>, <a href="2741">2741</a>, <a href="2813">2813</a>, <a href="2820">2820</a>, <a href="2899">2899</a>, <a href="2936">2936</a>.</li>
<li>Changed the following 6 issues to LEWG (from New): <a href="2883">2883</a>, <a href="2884">2884</a>, <a href="2885">2885</a>, <a href="2922">2922</a>, <a href="2968">2968</a>, <a href="2973">2973</a>.</li>
<li>Changed the following issue to WP (from Ready): <a href="2932">2932</a>.</li>
<li>Changed the following 11 issues to WP (from Tentatively Ready): <a href="2444">2444</a>, <a href="2593">2593</a>, <a href="2597">2597</a>, <a href="2783">2783</a>, <a href="2937">2937</a>, <a href="2940">2940</a>, <a href="2942">2942</a>, <a href="2954">2954</a>, <a href="2961">2961</a>, <a href="2966">2966</a>, <a href="2974">2974</a>.</li>
<li>Changed the following 2 issues to C++17 (from New): <a href="2901">2901</a>, <a href="2956">2956</a>.</li>
<li>Changed the following 279 issues to C++17 (from WP): <a href="1169">1169</a>, <a href="2016">2016</a>, <a href="2059">2059</a>, <a href="2062">2062</a>, <a href="2063">2063</a>, <a href="2072">2072</a>, <a href="2076">2076</a>, <a href="2101">2101</a>, <a href="2106">2106</a>, <a href="2111">2111</a>, <a href="2119">2119</a>, <a href="2127">2127</a>, <a href="2129">2129</a>, <a href="2133">2133</a>, <a href="2156">2156</a>, <a href="2160">2160</a>, <a href="2166">2166</a>, <a href="2168">2168</a>, <a href="2170">2170</a>, <a href="2181">2181</a>, <a href="2192">2192</a>, <a href="2212">2212</a>, <a href="2217">2217</a>, <a href="2218">2218</a>, <a href="2219">2219</a>, <a href="2221">2221</a>, <a href="2223">2223</a>, <a href="2224">2224</a>, <a href="2230">2230</a>, <a href="2233">2233</a>, <a href="2234">2234</a>, <a href="2239">2239</a>, <a href="2244">2244</a>, <a href="2250">2250</a>, <a href="2259">2259</a>, <a href="2260">2260</a>, <a href="2261">2261</a>, <a href="2266">2266</a>, <a href="2273">2273</a>, <a href="2276">2276</a>, <a href="2296">2296</a>, <a href="2309">2309</a>, <a href="2310">2310</a>, <a href="2312">2312</a>, <a href="2325">2325</a>, <a href="2328">2328</a>, <a href="2336">2336</a>, <a href="2340">2340</a>, <a href="2353">2353</a>, <a href="2354">2354</a>, <a href="2361">2361</a>, <a href="2364">2364</a>, <a href="2365">2365</a>, <a href="2367">2367</a>, <a href="2369">2369</a>, <a href="2376">2376</a>, <a href="2377">2377</a>, <a href="2378">2378</a>, <a href="2380">2380</a>, <a href="2384">2384</a>, <a href="2385">2385</a>, <a href="2387">2387</a>, <a href="2393">2393</a>, <a href="2394">2394</a>, <a href="2396">2396</a>, <a href="2399">2399</a>, <a href="2400">2400</a>, <a href="2401">2401</a>, <a href="2403">2403</a>, <a href="2404">2404</a>, <a href="2406">2406</a>, <a href="2407">2407</a>, <a href="2408">2408</a>, <a href="2411">2411</a>, <a href="2415">2415</a>, <a href="2420">2420</a>, <a href="2422">2422</a>, <a href="2425">2425</a>, <a href="2426">2426</a>, <a href="2427">2427</a>, <a href="2428">2428</a>, <a href="2433">2433</a>, <a href="2434">2434</a>, <a href="2435">2435</a>, <a href="2436">2436</a>, <a href="2437">2437</a>, <a href="2438">2438</a>, <a href="2439">2439</a>, <a href="2440">2440</a>, <a href="2441">2441</a>, <a href="2442">2442</a>, <a href="2447">2447</a>, <a href="2448">2448</a>, <a href="2450">2450</a>, <a href="2454">2454</a>, <a href="2455">2455</a>, <a href="2458">2458</a>, <a href="2459">2459</a>, <a href="2460">2460</a>, <a href="2462">2462</a>, <a href="2464">2464</a>, <a href="2466">2466</a>, <a href="2467">2467</a>, <a href="2468">2468</a>, <a href="2469">2469</a>, <a href="2470">2470</a>, <a href="2473">2473</a>, <a href="2475">2475</a>, <a href="2476">2476</a>, <a href="2477">2477</a>, <a href="2482">2482</a>, <a href="2483">2483</a>, <a href="2484">2484</a>, <a href="2485">2485</a>, <a href="2486">2486</a>, <a href="2487">2487</a>, <a href="2488">2488</a>, <a href="2489">2489</a>, <a href="2492">2492</a>, <a href="2495">2495</a>, <a href="2503">2503</a>, <a href="2510">2510</a>, <a href="2514">2514</a>, <a href="2519">2519</a>, <a href="2520">2520</a>, <a href="2523">2523</a>, <a href="2531">2531</a>, <a href="2534">2534</a>, <a href="2536">2536</a>, <a href="2537">2537</a>, <a href="2540">2540</a>, <a href="2542">2542</a>, <a href="2544">2544</a>, <a href="2545">2545</a>, <a href="2549">2549</a>, <a href="2550">2550</a>, <a href="2556">2556</a>, <a href="2557">2557</a>, <a href="2559">2559</a>, <a href="2560">2560</a>, <a href="2562">2562</a>, <a href="2565">2565</a>, <a href="2566">2566</a>, <a href="2567">2567</a>, <a href="2571">2571</a>, <a href="2572">2572</a>, <a href="2576">2576</a>, <a href="2577">2577</a>, <a href="2578">2578</a>, <a href="2579">2579</a>, <a href="2581">2581</a>, <a href="2582">2582</a>, <a href="2583">2583</a>, <a href="2584">2584</a>, <a href="2585">2585</a>, <a href="2586">2586</a>, <a href="2589">2589</a>, <a href="2590">2590</a>, <a href="2591">2591</a>, <a href="2596">2596</a>, <a href="2598">2598</a>, <a href="2664">2664</a>, <a href="2667">2667</a>, <a href="2669">2669</a>, <a href="2670">2670</a>, <a href="2671">2671</a>, <a href="2672">2672</a>, <a href="2673">2673</a>, <a href="2674">2674</a>, <a href="2676">2676</a>, <a href="2678">2678</a>, <a href="2679">2679</a>, <a href="2680">2680</a>, <a href="2681">2681</a>, <a href="2683">2683</a>, <a href="2684">2684</a>, <a href="2685">2685</a>, <a href="2686">2686</a>, <a href="2687">2687</a>, <a href="2688">2688</a>, <a href="2689">2689</a>, <a href="2694">2694</a>, <a href="2696">2696</a>, <a href="2698">2698</a>, <a href="2699">2699</a>, <a href="2704">2704</a>, <a href="2706">2706</a>, <a href="2707">2707</a>, <a href="2709">2709</a>, <a href="2710">2710</a>, <a href="2711">2711</a>, <a href="2712">2712</a>, <a href="2716">2716</a>, <a href="2718">2718</a>, <a href="2719">2719</a>, <a href="2720">2720</a>, <a href="2721">2721</a>, <a href="2722">2722</a>, <a href="2723">2723</a>, <a href="2724">2724</a>, <a href="2725">2725</a>, <a href="2726">2726</a>, <a href="2727">2727</a>, <a href="2728">2728</a>, <a href="2729">2729</a>, <a href="2732">2732</a>, <a href="2735">2735</a>, <a href="2736">2736</a>, <a href="2738">2738</a>, <a href="2739">2739</a>, <a href="2740">2740</a>, <a href="2742">2742</a>, <a href="2744">2744</a>, <a href="2747">2747</a>, <a href="2748">2748</a>, <a href="2749">2749</a>, <a href="2752">2752</a>, <a href="2755">2755</a>, <a href="2756">2756</a>, <a href="2758">2758</a>, <a href="2759">2759</a>, <a href="2760">2760</a>, <a href="2765">2765</a>, <a href="2767">2767</a>, <a href="2768">2768</a>, <a href="2769">2769</a>, <a href="2770">2770</a>, <a href="2771">2771</a>, <a href="2773">2773</a>, <a href="2777">2777</a>, <a href="2778">2778</a>, <a href="2781">2781</a>, <a href="2782">2782</a>, <a href="2784">2784</a>, <a href="2785">2785</a>, <a href="2786">2786</a>, <a href="2787">2787</a>, <a href="2788">2788</a>, <a href="2789">2789</a>, <a href="2790">2790</a>, <a href="2793">2793</a>, <a href="2794">2794</a>, <a href="2795">2795</a>, <a href="2796">2796</a>, <a href="2801">2801</a>, <a href="2802">2802</a>, <a href="2804">2804</a>, <a href="2806">2806</a>, <a href="2807">2807</a>, <a href="2812">2812</a>, <a href="2824">2824</a>, <a href="2826">2826</a>, <a href="2834">2834</a>, <a href="2835">2835</a>, <a href="2837">2837</a>, <a href="2838">2838</a>, <a href="2842">2842</a>, <a href="2850">2850</a>, <a href="2853">2853</a>, <a href="2855">2855</a>, <a href="2857">2857</a>, <a href="2861">2861</a>, <a href="2866">2866</a>, <a href="2868">2868</a>, <a href="2872">2872</a>, <a href="2873">2873</a>, <a href="2874">2874</a>, <a href="2875">2875</a>, <a href="2876">2876</a>, <a href="2878">2878</a>, <a href="2890">2890</a>, <a href="2900">2900</a>, <a href="2903">2903</a>, <a href="2904">2904</a>, <a href="2905">2905</a>, <a href="2908">2908</a>, <a href="2911">2911</a>, <a href="2921">2921</a>, <a href="2934">2934</a>.</li>
<li>Changed the following 2 issues to Resolved (from New): <a href="2880">2880</a>, <a href="2955">2955</a>.</li>
<li>Changed the following 3 issues to Resolved (from Open): <a href="2070">2070</a>, <a href="2368">2368</a>, <a href="2665">2665</a>.</li>
<li>Changed the following issue to Resolved (from Pending Resolved): <a href="2798">2798</a>.</li>
<li>Changed the following 4 issues to NAD (from Tentatively NAD): <a href="760">760</a>, <a href="2337">2337</a>, <a href="2692">2692</a>, <a href="2717">2717</a>.</li>
<li>Changed the following 11 issues to NAD (from New): <a href="2852">2852</a>, <a href="2871">2871</a>, <a href="2886">2886</a>, <a href="2891">2891</a>, <a href="2893">2893</a>, <a href="2902">2902</a>, <a href="2907">2907</a>, <a href="2909">2909</a>, <a href="2916">2916</a>, <a href="2967">2967</a>, <a href="2971">2971</a>.</li>
<li>Changed the following issue to Dup (from New): <a href="2910">2910</a>.</li>
<li>Changed the following 77 issues to TS (from WP): <a href="2371">2371</a>, <a href="2374">2374</a>, <a href="2389">2389</a>, <a href="2390">2390</a>, <a href="2395">2395</a>, <a href="2409">2409</a>, <a href="2410">2410</a>, <a href="2418">2418</a>, <a href="2451">2451</a>, <a href="2463">2463</a>, <a href="2494">2494</a>, <a href="2500">2500</a>, <a href="2509">2509</a>, <a href="2515">2515</a>, <a href="2516">2516</a>, <a href="2517">2517</a>, <a href="2518">2518</a>, <a href="2521">2521</a>, <a href="2522">2522</a>, <a href="2525">2525</a>, <a href="2526">2526</a>, <a href="2527">2527</a>, <a href="2539">2539</a>, <a href="2551">2551</a>, <a href="2555">2555</a>, <a href="2558">2558</a>, <a href="2568">2568</a>, <a href="2570">2570</a>, <a href="2573">2573</a>, <a href="2574">2574</a>, <a href="2575">2575</a>, <a href="2588">2588</a>, <a href="2601">2601</a>, <a href="2602">2602</a>, <a href="2603">2603</a>, <a href="2605">2605</a>, <a href="2606">2606</a>, <a href="2607">2607</a>, <a href="2608">2608</a>, <a href="2609">2609</a>, <a href="2614">2614</a>, <a href="2615">2615</a>, <a href="2616">2616</a>, <a href="2618">2618</a>, <a href="2619">2619</a>, <a href="2621">2621</a>, <a href="2622">2622</a>, <a href="2624">2624</a>, <a href="2625">2625</a>, <a href="2627">2627</a>, <a href="2629">2629</a>, <a href="2632">2632</a>, <a href="2633">2633</a>, <a href="2634">2634</a>, <a href="2635">2635</a>, <a href="2636">2636</a>, <a href="2637">2637</a>, <a href="2640">2640</a>, <a href="2641">2641</a>, <a href="2644">2644</a>, <a href="2645">2645</a>, <a href="2647">2647</a>, <a href="2648">2648</a>, <a href="2649">2649</a>, <a href="2650">2650</a>, <a href="2652">2652</a>, <a href="2653">2653</a>, <a href="2655">2655</a>, <a href="2656">2656</a>, <a href="2657">2657</a>, <a href="2658">2658</a>, <a href="2660">2660</a>, <a href="2662">2662</a>, <a href="2733">2733</a>, <a href="2745">2745</a>, <a href="2750">2750</a>, <a href="2792">2792</a>.</li>
</ul></li>
</ul>
</li>
<li>R104: 
2017-06-18 2017 pre-Toronto mailing
<ul>
<li><b>Summary:</b><ul>
<li>257 open issues, up by 38.</li>
<li>2193 closed issues, up by 17.</li>
<li>54 reassigned issues, down by 19.</li>
<li>2504 issues total, up by 36.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 4 Tentatively Ready issues: <a href="2954">2954</a>, <a href="2961">2961</a>, <a href="2966">2966</a>, <a href="2974">2974</a>.</li>
<li>Added the following 32 New issues: <a href="2947">2947</a>, <a href="2948">2948</a>, <a href="2949">2949</a>, <a href="2950">2950</a>, <a href="2951">2951</a>, <a href="2952">2952</a>, <a href="2953">2953</a>, <a href="2955">2955</a>, <a href="2956">2956</a>, <a href="2957">2957</a>, <a href="2958">2958</a>, <a href="2959">2959</a>, <a href="2960">2960</a>, <a href="2962">2962</a>, <a href="2963">2963</a>, <a href="2964">2964</a>, <a href="2965">2965</a>, <a href="2967">2967</a>, <a href="2968">2968</a>, <a href="2969">2969</a>, <a href="2970">2970</a>, <a href="2971">2971</a>, <a href="2972">2972</a>, <a href="2973">2973</a>, <a href="2975">2975</a>, <a href="2976">2976</a>, <a href="2977">2977</a>, <a href="2978">2978</a>, <a href="2979">2979</a>, <a href="2980">2980</a>, <a href="2981">2981</a>, <a href="2982">2982</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="2940">2940</a>, <a href="2942">2942</a>.</li>
<li>Changed the following issue to Tentatively Ready (from LEWG): <a href="2593">2593</a>.</li>
<li>Changed the following issue to Open (from New): <a href="2797">2797</a>.</li>
<li>Changed the following 3 issues to Open (from LEWG): <a href="484">484</a>, <a href="1422">1422</a>, <a href="2055">2055</a>.</li>
<li>Changed the following issue to Pending Resolved (from Open): <a href="2798">2798</a>.</li>
<li>Changed the following issue to Resolved (from LEWG): <a href="2232">2232</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2898">2898</a>.</li>
<li>Changed the following 14 issues to NAD (from LEWG): <a href="255">255</a>, <a href="851">851</a>, <a href="877">877</a>, <a href="933">933</a>, <a href="1031">1031</a>, <a href="1053">1053</a>, <a href="1112">1112</a>, <a href="1120">1120</a>, <a href="1184">1184</a>, <a href="1320">1320</a>, <a href="2242">2242</a>, <a href="2430">2430</a>, <a href="2446">2446</a>, <a href="2854">2854</a>.</li>
</ul></li>
</ul>
</li>
<li>R103: 
2017-03-20 2017 post-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>219 open issues, down by 86.</li>
<li>2176 closed issues, up by 104.</li>
<li>73 reassigned issues, up by 0.</li>
<li>2468 issues total, up by 18.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Ready issue: <a href="2932">2932</a>.</li>
<li>Added the following Tentatively Ready issue: <a href="2937">2937</a>.</li>
<li>Added the following 13 New issues: <a href="2929">2929</a>, <a href="2933">2933</a>, <a href="2935">2935</a>, <a href="2936">2936</a>, <a href="2938">2938</a>, <a href="2939">2939</a>, <a href="2940">2940</a>, <a href="2941">2941</a>, <a href="2942">2942</a>, <a href="2943">2943</a>, <a href="2944">2944</a>, <a href="2945">2945</a>, <a href="2946">2946</a>.</li>
<li>Added the following Open issue: <a href="2931">2931</a>.</li>
<li>Added the following WP issue: <a href="2934">2934</a>.</li>
<li>Added the following NAD issue: <a href="2930">2930</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="2783">2783</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="2444">2444</a>, <a href="2597">2597</a>.</li>
<li>Changed the following issue to Review (from SG1): <a href="2412">2412</a>.</li>
<li>Changed the following issue to Open (from New): <a href="2894">2894</a>.</li>
<li>Changed the following 2 issues to Core (from New): <a href="2859">2859</a>, <a href="2860">2860</a>.</li>
<li>Changed the following 6 issues to WP (from Ready): <a href="2781">2781</a>, <a href="2782">2782</a>, <a href="2784">2784</a>, <a href="2785">2785</a>, <a href="2786">2786</a>, <a href="2787">2787</a>.</li>
<li>Changed the following 18 issues to WP (from Tentatively Ready): <a href="2260">2260</a>, <a href="2768">2768</a>, <a href="2769">2769</a>, <a href="2789">2789</a>, <a href="2794">2794</a>, <a href="2795">2795</a>, <a href="2804">2804</a>, <a href="2812">2812</a>, <a href="2824">2824</a>, <a href="2826">2826</a>, <a href="2834">2834</a>, <a href="2835">2835</a>, <a href="2837">2837</a>, <a href="2838">2838</a>, <a href="2842">2842</a>, <a href="2850">2850</a>, <a href="2853">2853</a>, <a href="2855">2855</a>.</li>
<li>Changed the following 3 issues to WP (from Review): <a href="2676">2676</a>, <a href="2790">2790</a>, <a href="2796">2796</a>.</li>
<li>Changed the following 22 issues to WP (from New): <a href="2788">2788</a>, <a href="2801">2801</a>, <a href="2802">2802</a>, <a href="2806">2806</a>, <a href="2807">2807</a>, <a href="2861">2861</a>, <a href="2866">2866</a>, <a href="2868">2868</a>, <a href="2872">2872</a>, <a href="2873">2873</a>, <a href="2874">2874</a>, <a href="2875">2875</a>, <a href="2876">2876</a>, <a href="2878">2878</a>, <a href="2890">2890</a>, <a href="2900">2900</a>, <a href="2903">2903</a>, <a href="2904">2904</a>, <a href="2905">2905</a>, <a href="2908">2908</a>, <a href="2911">2911</a>, <a href="2921">2921</a>.</li>
<li>Changed the following issue to WP (from LEWG): <a href="2857">2857</a>.</li>
<li>Changed the following issue to Resolved (from Review): <a href="2245">2245</a>.</li>
<li>Changed the following 27 issues to Resolved (from New): <a href="2715">2715</a>, <a href="2803">2803</a>, <a href="2862">2862</a>, <a href="2863">2863</a>, <a href="2864">2864</a>, <a href="2867">2867</a>, <a href="2869">2869</a>, <a href="2877">2877</a>, <a href="2879">2879</a>, <a href="2882">2882</a>, <a href="2887">2887</a>, <a href="2888">2888</a>, <a href="2889">2889</a>, <a href="2895">2895</a>, <a href="2912">2912</a>, <a href="2913">2913</a>, <a href="2914">2914</a>, <a href="2915">2915</a>, <a href="2917">2917</a>, <a href="2918">2918</a>, <a href="2919">2919</a>, <a href="2920">2920</a>, <a href="2924">2924</a>, <a href="2925">2925</a>, <a href="2926">2926</a>, <a href="2927">2927</a>, <a href="2928">2928</a>.</li>
<li>Changed the following 19 issues to Resolved (from Tentatively Resolved): <a href="839">839</a>, <a href="1041">1041</a>, <a href="2179">2179</a>, <a href="2208">2208</a>, <a href="2241">2241</a>, <a href="2294">2294</a>, <a href="2343">2343</a>, <a href="2370">2370</a>, <a href="2391">2391</a>, <a href="2424">2424</a>, <a href="2443">2443</a>, <a href="2501">2501</a>, <a href="2502">2502</a>, <a href="2505">2505</a>, <a href="2529">2529</a>, <a href="2548">2548</a>, <a href="2663">2663</a>, <a href="2677">2677</a>, <a href="2757">2757</a>.</li>
<li>Changed the following 3 issues to NAD (from New): <a href="2256">2256</a>, <a href="2449">2449</a>, <a href="2865">2865</a>.</li>
<li>Changed the following 2 issues to Dup (from New): <a href="2764">2764</a>, <a href="2896">2896</a>.</li>
</ul></li>
</ul>
</li>
<li>R102: 
2017-02-06 2017 pre-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>305 open issues, up by 89.</li>
<li>2072 closed issues, up by 9.</li>
<li>73 reassigned issues, up by 5.</li>
<li>2450 issues total, up by 103.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 9 Tentatively Ready issues: <a href="2826">2826</a>, <a href="2834">2834</a>, <a href="2835">2835</a>, <a href="2837">2837</a>, <a href="2838">2838</a>, <a href="2842">2842</a>, <a href="2850">2850</a>, <a href="2853">2853</a>, <a href="2855">2855</a>.</li>
<li>Added the following 89 New issues: <a href="2827">2827</a>, <a href="2829">2829</a>, <a href="2832">2832</a>, <a href="2833">2833</a>, <a href="2836">2836</a>, <a href="2839">2839</a>, <a href="2840">2840</a>, <a href="2841">2841</a>, <a href="2843">2843</a>, <a href="2844">2844</a>, <a href="2845">2845</a>, <a href="2846">2846</a>, <a href="2847">2847</a>, <a href="2848">2848</a>, <a href="2849">2849</a>, <a href="2851">2851</a>, <a href="2852">2852</a>, <a href="2856">2856</a>, <a href="2858">2858</a>, <a href="2859">2859</a>, <a href="2860">2860</a>, <a href="2861">2861</a>, <a href="2862">2862</a>, <a href="2863">2863</a>, <a href="2864">2864</a>, <a href="2865">2865</a>, <a href="2866">2866</a>, <a href="2867">2867</a>, <a href="2868">2868</a>, <a href="2869">2869</a>, <a href="2870">2870</a>, <a href="2871">2871</a>, <a href="2872">2872</a>, <a href="2873">2873</a>, <a href="2874">2874</a>, <a href="2875">2875</a>, <a href="2876">2876</a>, <a href="2877">2877</a>, <a href="2878">2878</a>, <a href="2879">2879</a>, <a href="2880">2880</a>, <a href="2881">2881</a>, <a href="2882">2882</a>, <a href="2883">2883</a>, <a href="2884">2884</a>, <a href="2885">2885</a>, <a href="2886">2886</a>, <a href="2887">2887</a>, <a href="2888">2888</a>, <a href="2889">2889</a>, <a href="2890">2890</a>, <a href="2891">2891</a>, <a href="2892">2892</a>, <a href="2893">2893</a>, <a href="2894">2894</a>, <a href="2895">2895</a>, <a href="2896">2896</a>, <a href="2897">2897</a>, <a href="2898">2898</a>, <a href="2899">2899</a>, <a href="2900">2900</a>, <a href="2901">2901</a>, <a href="2902">2902</a>, <a href="2903">2903</a>, <a href="2904">2904</a>, <a href="2905">2905</a>, <a href="2906">2906</a>, <a href="2907">2907</a>, <a href="2908">2908</a>, <a href="2909">2909</a>, <a href="2910">2910</a>, <a href="2911">2911</a>, <a href="2912">2912</a>, <a href="2913">2913</a>, <a href="2914">2914</a>, <a href="2915">2915</a>, <a href="2916">2916</a>, <a href="2917">2917</a>, <a href="2918">2918</a>, <a href="2919">2919</a>, <a href="2920">2920</a>, <a href="2921">2921</a>, <a href="2922">2922</a>, <a href="2923">2923</a>, <a href="2924">2924</a>, <a href="2925">2925</a>, <a href="2926">2926</a>, <a href="2927">2927</a>, <a href="2928">2928</a>.</li>
<li>Added the following 3 LEWG issues: <a href="2831">2831</a>, <a href="2854">2854</a>, <a href="2857">2857</a>.</li>
<li>Added the following Resolved issue: <a href="2830">2830</a>.</li>
<li>Added the following NAD Editorial issue: <a href="2828">2828</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from New): <a href="2789">2789</a>, <a href="2795">2795</a>, <a href="2804">2804</a>, <a href="2812">2812</a>, <a href="2824">2824</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="2768">2768</a>, <a href="2769">2769</a>.</li>
<li>Changed the following 2 issues to Review (from New): <a href="2790">2790</a>, <a href="2796">2796</a>.</li>
<li>Changed the following 2 issues to LEWG (from New): <a href="2814">2814</a>, <a href="2825">2825</a>.</li>
<li>Changed the following 2 issues to WP (from New): <a href="2792">2792</a>, <a href="2793">2793</a>.</li>
<li>Changed the following 3 issues to Resolved (from New): <a href="2805">2805</a>, <a href="2809">2809</a>, <a href="2810">2810</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2754">2754</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2822">2822</a>.</li>
</ul></li>
</ul>
</li>
<li>R101: 
2016-11-28 2016 post-Issaquah mailing
<ul>
<li><b>Summary:</b><ul>
<li>216 open issues, down by 44.</li>
<li>2063 closed issues, up by 85.</li>
<li>68 reassigned issues, up by 0.</li>
<li>2347 issues total, up by 41.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 Ready issues: <a href="2785">2785</a>, <a href="2786">2786</a>, <a href="2787">2787</a>.</li>
<li>Added the following Tentatively Ready issue: <a href="2794">2794</a>.</li>
<li>Added the following 34 New issues: <a href="2788">2788</a>, <a href="2789">2789</a>, <a href="2790">2790</a>, <a href="2792">2792</a>, <a href="2793">2793</a>, <a href="2795">2795</a>, <a href="2796">2796</a>, <a href="2797">2797</a>, <a href="2799">2799</a>, <a href="2800">2800</a>, <a href="2801">2801</a>, <a href="2802">2802</a>, <a href="2803">2803</a>, <a href="2804">2804</a>, <a href="2805">2805</a>, <a href="2806">2806</a>, <a href="2807">2807</a>, <a href="2808">2808</a>, <a href="2809">2809</a>, <a href="2810">2810</a>, <a href="2811">2811</a>, <a href="2812">2812</a>, <a href="2813">2813</a>, <a href="2814">2814</a>, <a href="2815">2815</a>, <a href="2816">2816</a>, <a href="2818">2818</a>, <a href="2819">2819</a>, <a href="2820">2820</a>, <a href="2821">2821</a>, <a href="2822">2822</a>, <a href="2823">2823</a>, <a href="2824">2824</a>, <a href="2825">2825</a>.</li>
<li>Added the following Open issue: <a href="2798">2798</a>.</li>
<li>Added the following 2 Resolved issues: <a href="2791">2791</a>, <a href="2817">2817</a>.</li>
<li>Changed the following 3 issues to Ready (from New): <a href="2781">2781</a>, <a href="2782">2782</a>, <a href="2784">2784</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2260">2260</a>.</li>
<li>Changed the following issue to Review (from New): <a href="2697">2697</a>.</li>
<li>Changed the following 3 issues to Open (from Tentatively Ready): <a href="2569">2569</a>, <a href="2754">2754</a>, <a href="2768">2768</a>.</li>
<li>Changed the following 2 issues to Open (from New): <a href="2597">2597</a>, <a href="2730">2730</a>.</li>
<li>Changed the following issue to LEWG (from New): <a href="2780">2780</a>.</li>
<li>Changed the following issue to Pending NAD Editorial (from Open): <a href="2178">2178</a>.</li>
<li>Changed the following 66 issues to WP (from Tentatively Ready): <a href="2062">2062</a>, <a href="2166">2166</a>, <a href="2221">2221</a>, <a href="2223">2223</a>, <a href="2261">2261</a>, <a href="2394">2394</a>, <a href="2460">2460</a>, <a href="2468">2468</a>, <a href="2475">2475</a>, <a href="2503">2503</a>, <a href="2510">2510</a>, <a href="2514">2514</a>, <a href="2519">2519</a>, <a href="2531">2531</a>, <a href="2534">2534</a>, <a href="2536">2536</a>, <a href="2540">2540</a>, <a href="2544">2544</a>, <a href="2556">2556</a>, <a href="2562">2562</a>, <a href="2567">2567</a>, <a href="2570">2570</a>, <a href="2578">2578</a>, <a href="2584">2584</a>, <a href="2589">2589</a>, <a href="2591">2591</a>, <a href="2598">2598</a>, <a href="2664">2664</a>, <a href="2672">2672</a>, <a href="2678">2678</a>, <a href="2679">2679</a>, <a href="2680">2680</a>, <a href="2681">2681</a>, <a href="2686">2686</a>, <a href="2694">2694</a>, <a href="2696">2696</a>, <a href="2699">2699</a>, <a href="2712">2712</a>, <a href="2722">2722</a>, <a href="2729">2729</a>, <a href="2732">2732</a>, <a href="2733">2733</a>, <a href="2735">2735</a>, <a href="2736">2736</a>, <a href="2738">2738</a>, <a href="2739">2739</a>, <a href="2740">2740</a>, <a href="2742">2742</a>, <a href="2744">2744</a>, <a href="2745">2745</a>, <a href="2747">2747</a>, <a href="2748">2748</a>, <a href="2749">2749</a>, <a href="2750">2750</a>, <a href="2752">2752</a>, <a href="2755">2755</a>, <a href="2756">2756</a>, <a href="2758">2758</a>, <a href="2759">2759</a>, <a href="2760">2760</a>, <a href="2765">2765</a>, <a href="2767">2767</a>, <a href="2771">2771</a>, <a href="2773">2773</a>, <a href="2777">2777</a>, <a href="2778">2778</a>.</li>
<li>Changed the following 4 issues to WP (from New): <a href="2518">2518</a>, <a href="2521">2521</a>, <a href="2525">2525</a>, <a href="2527">2527</a>.</li>
<li>Changed the following 3 issues to WP (from Open): <a href="2568">2568</a>, <a href="2588">2588</a>, <a href="2770">2770</a>.</li>
<li>Changed the following 2 issues to Resolved (from Tentatively Ready): <a href="2543">2543</a>, <a href="2753">2753</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="2763">2763</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2465">2465</a>.</li>
<li>Changed the following issue to Resolved (from SG1): <a href="2445">2445</a>.</li>
<li>Changed the following issue to NAD Editorial (from New): <a href="2201">2201</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2668">2668</a>.</li>
<li>Changed the following 2 issues to NAD (from Open): <a href="1173">1173</a>, <a href="2199">2199</a>.</li>
</ul></li>
</ul>
</li>
<li>R100: 
2016-10-17 2016 pre-Issaquah mailing
<ul>
<li><b>Summary:</b><ul>
<li>260 open issues, up by 31.</li>
<li>1978 closed issues, up by 5.</li>
<li>68 reassigned issues, up by 5.</li>
<li>2306 issues total, up by 41.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 21 Tentatively Ready issues: <a href="2744">2744</a>, <a href="2745">2745</a>, <a href="2747">2747</a>, <a href="2748">2748</a>, <a href="2749">2749</a>, <a href="2750">2750</a>, <a href="2752">2752</a>, <a href="2753">2753</a>, <a href="2754">2754</a>, <a href="2755">2755</a>, <a href="2756">2756</a>, <a href="2758">2758</a>, <a href="2759">2759</a>, <a href="2760">2760</a>, <a href="2765">2765</a>, <a href="2767">2767</a>, <a href="2768">2768</a>, <a href="2771">2771</a>, <a href="2773">2773</a>, <a href="2777">2777</a>, <a href="2778">2778</a>.</li>
<li>Added the following 13 New issues: <a href="2746">2746</a>, <a href="2751">2751</a>, <a href="2763">2763</a>, <a href="2764">2764</a>, <a href="2766">2766</a>, <a href="2772">2772</a>, <a href="2774">2774</a>, <a href="2776">2776</a>, <a href="2780">2780</a>, <a href="2781">2781</a>, <a href="2782">2782</a>, <a href="2783">2783</a>, <a href="2784">2784</a>.</li>
<li>Added the following 2 Open issues: <a href="2769">2769</a>, <a href="2770">2770</a>.</li>
<li>Added the following 2 LEWG issues: <a href="2762">2762</a>, <a href="2779">2779</a>.</li>
<li>Added the following Tentatively Resolved issue: <a href="2757">2757</a>.</li>
<li>Added the following NAD issue: <a href="2761">2761</a>.</li>
<li>Added the following Dup issue: <a href="2775">2775</a>.</li>
<li>Changed the following 45 issues to Tentatively Ready (from New): <a href="2166">2166</a>, <a href="2221">2221</a>, <a href="2261">2261</a>, <a href="2394">2394</a>, <a href="2460">2460</a>, <a href="2475">2475</a>, <a href="2503">2503</a>, <a href="2514">2514</a>, <a href="2519">2519</a>, <a href="2531">2531</a>, <a href="2534">2534</a>, <a href="2536">2536</a>, <a href="2540">2540</a>, <a href="2544">2544</a>, <a href="2556">2556</a>, <a href="2562">2562</a>, <a href="2567">2567</a>, <a href="2569">2569</a>, <a href="2570">2570</a>, <a href="2578">2578</a>, <a href="2584">2584</a>, <a href="2589">2589</a>, <a href="2591">2591</a>, <a href="2598">2598</a>, <a href="2664">2664</a>, <a href="2672">2672</a>, <a href="2678">2678</a>, <a href="2679">2679</a>, <a href="2680">2680</a>, <a href="2681">2681</a>, <a href="2686">2686</a>, <a href="2694">2694</a>, <a href="2696">2696</a>, <a href="2699">2699</a>, <a href="2712">2712</a>, <a href="2722">2722</a>, <a href="2729">2729</a>, <a href="2732">2732</a>, <a href="2733">2733</a>, <a href="2735">2735</a>, <a href="2736">2736</a>, <a href="2738">2738</a>, <a href="2739">2739</a>, <a href="2740">2740</a>, <a href="2742">2742</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from Open): <a href="2062">2062</a>, <a href="2223">2223</a>, <a href="2468">2468</a>, <a href="2510">2510</a>, <a href="2543">2543</a>.</li>
<li>Changed the following issue to Review (from New): <a href="2676">2676</a>.</li>
<li>Changed the following issue to Review (from Open): <a href="2245">2245</a>.</li>
<li>Changed the following 13 issues to Open (from New): <a href="2158">2158</a>, <a href="2358">2358</a>, <a href="2381">2381</a>, <a href="2465">2465</a>, <a href="2512">2512</a>, <a href="2530">2530</a>, <a href="2532">2532</a>, <a href="2568">2568</a>, <a href="2587">2587</a>, <a href="2588">2588</a>, <a href="2665">2665</a>, <a href="2682">2682</a>, <a href="2708">2708</a>.</li>
<li>Changed the following 3 issues to LEWG (from New): <a href="2242">2242</a>, <a href="2471">2471</a>, <a href="2593">2593</a>.</li>
<li>Changed the following 3 issues to LEWG (from Open): <a href="2095">2095</a>, <a href="2152">2152</a>, <a href="2153">2153</a>.</li>
<li>Changed the following 6 issues to Tentatively Resolved (from New): <a href="2343">2343</a>, <a href="2501">2501</a>, <a href="2502">2502</a>, <a href="2548">2548</a>, <a href="2663">2663</a>, <a href="2677">2677</a>.</li>
<li>Changed the following 4 issues to Tentatively Resolved (from Open): <a href="2294">2294</a>, <a href="2370">2370</a>, <a href="2424">2424</a>, <a href="2505">2505</a>.</li>
<li>Changed the following 3 issues to Tentatively Resolved (from LEWG): <a href="839">839</a>, <a href="1041">1041</a>, <a href="2443">2443</a>.</li>
<li>Changed the following issue to NAD Editorial (from New): <a href="2701">2701</a>.</li>
<li>Changed the following 2 issues to NAD (from New): <a href="2161">2161</a>, <a href="2535">2535</a>.</li>
</ul></li>
</ul>
</li>
<li>R99: 
2016-07-11 2016 post-Oulu mailing
<ul>
<li><b>Summary:</b><ul>
<li>292 open issues, down by 26.</li>
<li>1973 closed issues, up by 51.</li>
<li>2265 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 16 New issues: <a href="2722">2722</a>, <a href="2729">2729</a>, <a href="2730">2730</a>, <a href="2731">2731</a>, <a href="2732">2732</a>, <a href="2733">2733</a>, <a href="2734">2734</a>, <a href="2735">2735</a>, <a href="2736">2736</a>, <a href="2737">2737</a>, <a href="2738">2738</a>, <a href="2739">2739</a>, <a href="2740">2740</a>, <a href="2741">2741</a>, <a href="2742">2742</a>, <a href="2743">2743</a>.</li>
<li>Added the following 9 WP issues: <a href="2719">2719</a>, <a href="2720">2720</a>, <a href="2721">2721</a>, <a href="2723">2723</a>, <a href="2724">2724</a>, <a href="2725">2725</a>, <a href="2726">2726</a>, <a href="2727">2727</a>, <a href="2728">2728</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="2717">2717</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Open): <a href="2241">2241</a>.</li>
<li>Changed the following 21 issues to WP (from Ready): <a href="2181">2181</a>, <a href="2309">2309</a>, <a href="2310">2310</a>, <a href="2328">2328</a>, <a href="2393">2393</a>, <a href="2426">2426</a>, <a href="2436">2436</a>, <a href="2441">2441</a>, <a href="2451">2451</a>, <a href="2516">2516</a>, <a href="2542">2542</a>, <a href="2549">2549</a>, <a href="2550">2550</a>, <a href="2551">2551</a>, <a href="2555">2555</a>, <a href="2573">2573</a>, <a href="2667">2667</a>, <a href="2669">2669</a>, <a href="2670">2670</a>, <a href="2671">2671</a>, <a href="2673">2673</a>.</li>
<li>Changed the following 12 issues to WP (from Tentatively Ready): <a href="2509">2509</a>, <a href="2596">2596</a>, <a href="2674">2674</a>, <a href="2683">2683</a>, <a href="2684">2684</a>, <a href="2685">2685</a>, <a href="2688">2688</a>, <a href="2689">2689</a>, <a href="2698">2698</a>, <a href="2706">2706</a>, <a href="2707">2707</a>, <a href="2710">2710</a>.</li>
<li>Changed the following 6 issues to WP (from New): <a href="2687">2687</a>, <a href="2704">2704</a>, <a href="2709">2709</a>, <a href="2711">2711</a>, <a href="2716">2716</a>, <a href="2718">2718</a>.</li>
<li>Changed the following 2 issues to WP (from Open): <a href="2312">2312</a>, <a href="2422">2422</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2700">2700</a>.</li>
</ul></li>
</ul>
</li>
<li>R98: 
2016-05-29 2016 pre-Oulu mailing
<ul>
<li><b>Summary:</b><ul>
<li>318 open issues, up by 50.</li>
<li>1922 closed issues, up by 0.</li>
<li>2240 issues total, up by 50.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 10 Tentatively Ready issues: <a href="2596">2596</a>, <a href="2683">2683</a>, <a href="2684">2684</a>, <a href="2685">2685</a>, <a href="2688">2688</a>, <a href="2689">2689</a>, <a href="2698">2698</a>, <a href="2706">2706</a>, <a href="2707">2707</a>, <a href="2710">2710</a>.</li>
<li>Added the following Tentatively NAD issue: <a href="2692">2692</a>.</li>
<li>Added the following 37 New issues: <a href="2595">2595</a>, <a href="2597">2597</a>, <a href="2598">2598</a>, <a href="2599">2599</a>, <a href="2675">2675</a>, <a href="2676">2676</a>, <a href="2677">2677</a>, <a href="2678">2678</a>, <a href="2679">2679</a>, <a href="2680">2680</a>, <a href="2681">2681</a>, <a href="2682">2682</a>, <a href="2686">2686</a>, <a href="2687">2687</a>, <a href="2691">2691</a>, <a href="2693">2693</a>, <a href="2694">2694</a>, <a href="2695">2695</a>, <a href="2696">2696</a>, <a href="2697">2697</a>, <a href="2699">2699</a>, <a href="2700">2700</a>, <a href="2701">2701</a>, <a href="2702">2702</a>, <a href="2703">2703</a>, <a href="2704">2704</a>, <a href="2705">2705</a>, <a href="2708">2708</a>, <a href="2709">2709</a>, <a href="2711">2711</a>, <a href="2712">2712</a>, <a href="2713">2713</a>, <a href="2714">2714</a>, <a href="2715">2715</a>, <a href="2716">2716</a>, <a href="2717">2717</a>, <a href="2718">2718</a>.</li>
<li>Added the following 2 LEWG issues: <a href="2600">2600</a>, <a href="2690">2690</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="2674">2674</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2509">2509</a>.</li>
<li>Changed the following 2 issues to Tentatively Resolved (from New): <a href="2208">2208</a>, <a href="2529">2529</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Open): <a href="2179">2179</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from LEWG): <a href="2391">2391</a>.</li>
</ul></li>
</ul>
</li>
<li>R97: 
2016-03-22 2016 post-Jacksonville mailing
<ul>
<li><b>Summary:</b><ul>
<li>268 open issues, down by 37.</li>
<li>1922 closed issues, up by 40.</li>
<li>2190 issues total, up by 3.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 New issues: <a href="2592">2592</a>, <a href="2593">2593</a>, <a href="2594">2594</a>.</li>
<li>Changed the following 7 issues to Ready (from Review): <a href="2181">2181</a>, <a href="2309">2309</a>, <a href="2310">2310</a>, <a href="2328">2328</a>, <a href="2393">2393</a>, <a href="2441">2441</a>, <a href="2516">2516</a>.</li>
<li>Changed the following 11 issues to Ready (from New): <a href="2542">2542</a>, <a href="2549">2549</a>, <a href="2550">2550</a>, <a href="2551">2551</a>, <a href="2555">2555</a>, <a href="2573">2573</a>, <a href="2667">2667</a>, <a href="2669">2669</a>, <a href="2670">2670</a>, <a href="2671">2671</a>, <a href="2673">2673</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="2426">2426</a>.</li>
<li>Changed the following 2 issues to Ready (from LEWG): <a href="2436">2436</a>, <a href="2451">2451</a>.</li>
<li>Changed the following issue to Open (from Review): <a href="2424">2424</a>.</li>
<li>Changed the following issue to Open (from New): <a href="2368">2368</a>.</li>
<li>Changed the following 3 issues to WP (from Ready): <a href="2276">2276</a>, <a href="2523">2523</a>, <a href="2537">2537</a>.</li>
<li>Changed the following 25 issues to WP (from Tentatively Ready): <a href="2192">2192</a>, <a href="2450">2450</a>, <a href="2520">2520</a>, <a href="2522">2522</a>, <a href="2539">2539</a>, <a href="2545">2545</a>, <a href="2557">2557</a>, <a href="2558">2558</a>, <a href="2559">2559</a>, <a href="2560">2560</a>, <a href="2565">2565</a>, <a href="2566">2566</a>, <a href="2571">2571</a>, <a href="2572">2572</a>, <a href="2574">2574</a>, <a href="2575">2575</a>, <a href="2576">2576</a>, <a href="2577">2577</a>, <a href="2579">2579</a>, <a href="2581">2581</a>, <a href="2582">2582</a>, <a href="2583">2583</a>, <a href="2585">2585</a>, <a href="2586">2586</a>, <a href="2590">2590</a>.</li>
<li>Changed the following issue to WP (from Review): <a href="2296">2296</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="2554">2554</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2456">2456</a>.</li>
<li>Changed the following issue to NAD Editorial (from New): <a href="2666">2666</a>.</li>
<li>Changed the following issue to NAD (from Review): <a href="2402">2402</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2553">2553</a>.</li>
<li>Changed the following issue to NAD (from LEWG): <a href="2372">2372</a>.</li>
<li>Changed the following 2 issues to NAD Arrays (from Ready): <a href="2253">2253</a>, <a href="2255">2255</a>.</li>
<li>Changed the following 3 issues to NAD Arrays (from Open): <a href="2254">2254</a>, <a href="2264">2264</a>, <a href="2277">2277</a>.</li>
</ul></li>
</ul>
</li>
<li>R96: 
2016-02-12 2016 pre-Jacksonville mailing (includes the FS TS bugs for the first time)
<ul>
<li><b>Summary:</b><ul>
<li>305 open issues, up by 48.</li>
<li>1882 closed issues, up by 63.</li>
<li>2187 issues total, up by 111.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 19 Tentatively Ready issues: <a href="2557">2557</a>, <a href="2558">2558</a>, <a href="2559">2559</a>, <a href="2560">2560</a>, <a href="2565">2565</a>, <a href="2566">2566</a>, <a href="2571">2571</a>, <a href="2572">2572</a>, <a href="2574">2574</a>, <a href="2575">2575</a>, <a href="2576">2576</a>, <a href="2577">2577</a>, <a href="2579">2579</a>, <a href="2581">2581</a>, <a href="2582">2582</a>, <a href="2583">2583</a>, <a href="2585">2585</a>, <a href="2586">2586</a>, <a href="2590">2590</a>.</li>
<li>Added the following 30 New issues: <a href="2554">2554</a>, <a href="2555">2555</a>, <a href="2556">2556</a>, <a href="2561">2561</a>, <a href="2562">2562</a>, <a href="2563">2563</a>, <a href="2564">2564</a>, <a href="2567">2567</a>, <a href="2568">2568</a>, <a href="2569">2569</a>, <a href="2570">2570</a>, <a href="2573">2573</a>, <a href="2578">2578</a>, <a href="2584">2584</a>, <a href="2587">2587</a>, <a href="2588">2588</a>, <a href="2589">2589</a>, <a href="2591">2591</a>, <a href="2663">2663</a>, <a href="2664">2664</a>, <a href="2665">2665</a>, <a href="2666">2666</a>, <a href="2667">2667</a>, <a href="2668">2668</a>, <a href="2669">2669</a>, <a href="2670">2670</a>, <a href="2671">2671</a>, <a href="2672">2672</a>, <a href="2673">2673</a>, <a href="2674">2674</a>.</li>
<li>Added the following 3 NAD Future issues: <a href="2611">2611</a>, <a href="2612">2612</a>, <a href="2654">2654</a>.</li>
<li>Added the following 41 WP issues: <a href="2601">2601</a>, <a href="2602">2602</a>, <a href="2603">2603</a>, <a href="2605">2605</a>, <a href="2606">2606</a>, <a href="2607">2607</a>, <a href="2608">2608</a>, <a href="2609">2609</a>, <a href="2614">2614</a>, <a href="2615">2615</a>, <a href="2616">2616</a>, <a href="2618">2618</a>, <a href="2619">2619</a>, <a href="2621">2621</a>, <a href="2622">2622</a>, <a href="2624">2624</a>, <a href="2625">2625</a>, <a href="2627">2627</a>, <a href="2629">2629</a>, <a href="2632">2632</a>, <a href="2633">2633</a>, <a href="2634">2634</a>, <a href="2635">2635</a>, <a href="2636">2636</a>, <a href="2637">2637</a>, <a href="2640">2640</a>, <a href="2641">2641</a>, <a href="2644">2644</a>, <a href="2645">2645</a>, <a href="2647">2647</a>, <a href="2648">2648</a>, <a href="2649">2649</a>, <a href="2650">2650</a>, <a href="2652">2652</a>, <a href="2653">2653</a>, <a href="2655">2655</a>, <a href="2656">2656</a>, <a href="2657">2657</a>, <a href="2658">2658</a>, <a href="2660">2660</a>, <a href="2662">2662</a>.</li>
<li>Added the following 2 NAD Editorial issues: <a href="2639">2639</a>, <a href="2659">2659</a>.</li>
<li>Added the following 14 NAD issues: <a href="2580">2580</a>, <a href="2604">2604</a>, <a href="2610">2610</a>, <a href="2613">2613</a>, <a href="2617">2617</a>, <a href="2623">2623</a>, <a href="2626">2626</a>, <a href="2628">2628</a>, <a href="2630">2630</a>, <a href="2631">2631</a>, <a href="2638">2638</a>, <a href="2642">2642</a>, <a href="2646">2646</a>, <a href="2661">2661</a>.</li>
<li>Added the following 2 Dup issues: <a href="2643">2643</a>, <a href="2651">2651</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="2545">2545</a>.</li>
<li>Changed the following 2 issues to Review (from Open): <a href="2310">2310</a>, <a href="2516">2516</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2552">2552</a>.</li>
</ul></li>
</ul>
</li>
<li>R95: 
2015-11-15 2015 post-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>257 open issues, down by 37.</li>
<li>1819 closed issues, up by 47.</li>
<li>2076 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 10 New issues: <a href="2544">2544</a>, <a href="2545">2545</a>, <a href="2546">2546</a>, <a href="2547">2547</a>, <a href="2548">2548</a>, <a href="2549">2549</a>, <a href="2550">2550</a>, <a href="2551">2551</a>, <a href="2552">2552</a>, <a href="2553">2553</a>.</li>
<li>Changed the following 2 issues to Ready (from New): <a href="2523">2523</a>, <a href="2537">2537</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="2276">2276</a>.</li>
<li>Changed the following 3 issues to Tentatively Ready (from New): <a href="2520">2520</a>, <a href="2522">2522</a>, <a href="2539">2539</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="2192">2192</a>, <a href="2450">2450</a>.</li>
<li>Changed the following issue to Review (from Ready): <a href="2181">2181</a>.</li>
<li>Changed the following 4 issues to Review (from Open): <a href="2309">2309</a>, <a href="2393">2393</a>, <a href="2402">2402</a>, <a href="2441">2441</a>.</li>
<li>Changed the following issue to Open (from Tentatively Ready): <a href="2510">2510</a>.</li>
<li>Changed the following 10 issues to Open (from New): <a href="2117">2117</a>, <a href="2164">2164</a>, <a href="2290">2290</a>, <a href="2468">2468</a>, <a href="2499">2499</a>, <a href="2505">2505</a>, <a href="2509">2509</a>, <a href="2516">2516</a>, <a href="2524">2524</a>, <a href="2543">2543</a>.</li>
<li>Changed the following issue to SG1 (from New): <a href="2533">2533</a>.</li>
<li>Changed the following 35 issues to WP (from Ready): <a href="1169">1169</a>, <a href="2072">2072</a>, <a href="2101">2101</a>, <a href="2111">2111</a>, <a href="2119">2119</a>, <a href="2127">2127</a>, <a href="2133">2133</a>, <a href="2156">2156</a>, <a href="2218">2218</a>, <a href="2219">2219</a>, <a href="2244">2244</a>, <a href="2250">2250</a>, <a href="2259">2259</a>, <a href="2336">2336</a>, <a href="2353">2353</a>, <a href="2367">2367</a>, <a href="2380">2380</a>, <a href="2384">2384</a>, <a href="2385">2385</a>, <a href="2435">2435</a>, <a href="2447">2447</a>, <a href="2462">2462</a>, <a href="2466">2466</a>, <a href="2469">2469</a>, <a href="2473">2473</a>, <a href="2476">2476</a>, <a href="2477">2477</a>, <a href="2483">2483</a>, <a href="2484">2484</a>, <a href="2485">2485</a>, <a href="2486">2486</a>, <a href="2487">2487</a>, <a href="2489">2489</a>, <a href="2492">2492</a>, <a href="2494">2494</a>.</li>
<li>Changed the following 8 issues to WP (from Tentatively Ready): <a href="2224">2224</a>, <a href="2234">2234</a>, <a href="2273">2273</a>, <a href="2495">2495</a>, <a href="2500">2500</a>, <a href="2515">2515</a>, <a href="2517">2517</a>, <a href="2526">2526</a>.</li>
<li>Changed the following issue to Resolved (from Core): <a href="2165">2165</a>.</li>
<li>Changed the following 2 issues to NAD (from New): <a href="2474">2474</a>, <a href="2538">2538</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="2379">2379</a>.</li>
<li>Changed the following issue to NAD (from Resolved): <a href="2319">2319</a>.</li>
</ul></li>
</ul>
</li>
<li>R94: 
2015-09-25 2015 pre-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>294 open issues, up by 38.</li>
<li>1772 closed issues, up by 2.</li>
<li>2066 issues total, up by 40.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 4 Tentatively Ready issues: <a href="2510">2510</a>, <a href="2515">2515</a>, <a href="2517">2517</a>, <a href="2526">2526</a>.</li>
<li>Added the following 36 New issues: <a href="2504">2504</a>, <a href="2505">2505</a>, <a href="2506">2506</a>, <a href="2507">2507</a>, <a href="2508">2508</a>, <a href="2509">2509</a>, <a href="2511">2511</a>, <a href="2512">2512</a>, <a href="2513">2513</a>, <a href="2514">2514</a>, <a href="2516">2516</a>, <a href="2518">2518</a>, <a href="2519">2519</a>, <a href="2520">2520</a>, <a href="2521">2521</a>, <a href="2522">2522</a>, <a href="2523">2523</a>, <a href="2524">2524</a>, <a href="2525">2525</a>, <a href="2527">2527</a>, <a href="2528">2528</a>, <a href="2529">2529</a>, <a href="2530">2530</a>, <a href="2531">2531</a>, <a href="2532">2532</a>, <a href="2533">2533</a>, <a href="2534">2534</a>, <a href="2535">2535</a>, <a href="2536">2536</a>, <a href="2537">2537</a>, <a href="2538">2538</a>, <a href="2539">2539</a>, <a href="2540">2540</a>, <a href="2541">2541</a>, <a href="2542">2542</a>, <a href="2543">2543</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="2495">2495</a>, <a href="2500">2500</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="2234">2234</a>, <a href="2273">2273</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2051">2051</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2326">2326</a>.</li>
</ul></li>
</ul>
</li>
<li>R93: 
2014-05-22 2015 post-Lenexa mailing
<ul>
<li><b>Summary:</b><ul>
<li>256 open issues, down by 36.</li>
<li>1770 closed issues, up by 48.</li>
<li>2026 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 2 Ready issues: <a href="2492">2492</a>, <a href="2494">2494</a>.</li>
<li>Added the following 10 New issues: <a href="2493">2493</a>, <a href="2495">2495</a>, <a href="2496">2496</a>, <a href="2497">2497</a>, <a href="2498">2498</a>, <a href="2499">2499</a>, <a href="2500">2500</a>, <a href="2501">2501</a>, <a href="2502">2502</a>, <a href="2503">2503</a>.</li>
<li>Changed the following 2 issues to Ready (from Review): <a href="2111">2111</a>, <a href="2380">2380</a>.</li>
<li>Changed the following 20 issues to Ready (from New): <a href="2244">2244</a>, <a href="2250">2250</a>, <a href="2259">2259</a>, <a href="2336">2336</a>, <a href="2353">2353</a>, <a href="2367">2367</a>, <a href="2384">2384</a>, <a href="2385">2385</a>, <a href="2435">2435</a>, <a href="2462">2462</a>, <a href="2466">2466</a>, <a href="2473">2473</a>, <a href="2476">2476</a>, <a href="2477">2477</a>, <a href="2483">2483</a>, <a href="2484">2484</a>, <a href="2485">2485</a>, <a href="2486">2486</a>, <a href="2487">2487</a>, <a href="2489">2489</a>.</li>
<li>Changed the following 12 issues to Ready (from Open): <a href="1169">1169</a>, <a href="2072">2072</a>, <a href="2101">2101</a>, <a href="2119">2119</a>, <a href="2127">2127</a>, <a href="2133">2133</a>, <a href="2156">2156</a>, <a href="2181">2181</a>, <a href="2218">2218</a>, <a href="2219">2219</a>, <a href="2447">2447</a>, <a href="2469">2469</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2224">2224</a>.</li>
<li>Changed the following issue to Review (from New): <a href="2296">2296</a>.</li>
<li>Changed the following issue to Review (from Open): <a href="2328">2328</a>.</li>
<li>Changed the following 11 issues to Open (from New): <a href="2262">2262</a>, <a href="2289">2289</a>, <a href="2338">2338</a>, <a href="2348">2348</a>, <a href="2349">2349</a>, <a href="2370">2370</a>, <a href="2398">2398</a>, <a href="2402">2402</a>, <a href="2422">2422</a>, <a href="2450">2450</a>, <a href="2456">2456</a>.</li>
<li>Changed the following 8 issues to Open (from SG1): <a href="2245">2245</a>, <a href="2265">2265</a>, <a href="2276">2276</a>, <a href="2309">2309</a>, <a href="2363">2363</a>, <a href="2379">2379</a>, <a href="2426">2426</a>, <a href="2441">2441</a>.</li>
<li>Changed the following issue to LEWG (from New): <a href="2372">2372</a>.</li>
<li>Changed the following issue to EWG (from New): <a href="2432">2432</a>.</li>
<li>Changed the following issue to Deferred (from Open): <a href="2202">2202</a>.</li>
<li>Changed the following 14 issues to WP (from Ready): <a href="2160">2160</a>, <a href="2168">2168</a>, <a href="2364">2364</a>, <a href="2403">2403</a>, <a href="2406">2406</a>, <a href="2411">2411</a>, <a href="2425">2425</a>, <a href="2427">2427</a>, <a href="2428">2428</a>, <a href="2433">2433</a>, <a href="2434">2434</a>, <a href="2438">2438</a>, <a href="2439">2439</a>, <a href="2440">2440</a>.</li>
<li>Changed the following 18 issues to WP (from Tentatively Ready): <a href="2059">2059</a>, <a href="2076">2076</a>, <a href="2239">2239</a>, <a href="2369">2369</a>, <a href="2378">2378</a>, <a href="2410">2410</a>, <a href="2415">2415</a>, <a href="2418">2418</a>, <a href="2437">2437</a>, <a href="2448">2448</a>, <a href="2454">2454</a>, <a href="2455">2455</a>, <a href="2458">2458</a>, <a href="2459">2459</a>, <a href="2463">2463</a>, <a href="2467">2467</a>, <a href="2470">2470</a>, <a href="2482">2482</a>.</li>
<li>Changed the following 3 issues to WP (from New): <a href="2420">2420</a>, <a href="2464">2464</a>, <a href="2488">2488</a>.</li>
<li>Changed the following issue to WP (from Open): <a href="2063">2063</a>.</li>
<li>Changed the following 2 issues to WP (from SG1): <a href="2407">2407</a>, <a href="2442">2442</a>.</li>
<li>Changed the following issue to Resolved (from Review): <a href="2228">2228</a>.</li>
<li>Changed the following 3 issues to Resolved (from Open): <a href="1526">1526</a>, <a href="2274">2274</a>, <a href="2397">2397</a>.</li>
<li>Changed the following 5 issues to NAD (from New): <a href="2079">2079</a>, <a href="2251">2251</a>, <a href="2351">2351</a>, <a href="2373">2373</a>, <a href="2386">2386</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="2388">2388</a>.</li>
</ul></li>
</ul>
</li>
<li>R92: 
2015-04-09 pre-Lenexa mailing
<ul>
<li><b>Summary:</b><ul>
<li>292 open issues, up by 33.</li>
<li>1722 closed issues, up by 0.</li>
<li>2014 issues total, up by 33.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 5 Tentatively Ready issues: <a href="2459">2459</a>, <a href="2463">2463</a>, <a href="2467">2467</a>, <a href="2470">2470</a>, <a href="2482">2482</a>.</li>
<li>Added the following 27 New issues: <a href="2460">2460</a>, <a href="2461">2461</a>, <a href="2462">2462</a>, <a href="2464">2464</a>, <a href="2465">2465</a>, <a href="2466">2466</a>, <a href="2468">2468</a>, <a href="2471">2471</a>, <a href="2472">2472</a>, <a href="2473">2473</a>, <a href="2474">2474</a>, <a href="2475">2475</a>, <a href="2476">2476</a>, <a href="2477">2477</a>, <a href="2478">2478</a>, <a href="2479">2479</a>, <a href="2480">2480</a>, <a href="2481">2481</a>, <a href="2483">2483</a>, <a href="2484">2484</a>, <a href="2485">2485</a>, <a href="2486">2486</a>, <a href="2487">2487</a>, <a href="2488">2488</a>, <a href="2489">2489</a>, <a href="2490">2490</a>, <a href="2491">2491</a>.</li>
<li>Added the following Open issue: <a href="2469">2469</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Review): <a href="2378">2378</a>.</li>
<li>Changed the following 11 issues to Tentatively Ready (from New): <a href="2076">2076</a>, <a href="2239">2239</a>, <a href="2369">2369</a>, <a href="2410">2410</a>, <a href="2415">2415</a>, <a href="2418">2418</a>, <a href="2437">2437</a>, <a href="2448">2448</a>, <a href="2454">2454</a>, <a href="2455">2455</a>, <a href="2458">2458</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="2059">2059</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="2337">2337</a>.</li>
<li>Changed the following issue to Tentatively NAD (from Open): <a href="760">760</a>.</li>
<li>Changed the following 5 issues to Open (from New): <a href="2312">2312</a>, <a href="2388">2388</a>, <a href="2393">2393</a>, <a href="2444">2444</a>, <a href="2447">2447</a>.</li>
<li>Changed the following 4 issues to LEWG (from New): <a href="2391">2391</a>, <a href="2417">2417</a>, <a href="2436">2436</a>, <a href="2451">2451</a>.</li>
<li>Changed the following issue to EWG (from Open): <a href="2089">2089</a>.</li>
<li>Changed the following issue to Core (from New): <a href="2452">2452</a>.</li>
<li>Changed the following 13 issues to SG1 (from New): <a href="2236">2236</a>, <a href="2245">2245</a>, <a href="2265">2265</a>, <a href="2276">2276</a>, <a href="2309">2309</a>, <a href="2334">2334</a>, <a href="2363">2363</a>, <a href="2379">2379</a>, <a href="2407">2407</a>, <a href="2412">2412</a>, <a href="2426">2426</a>, <a href="2442">2442</a>, <a href="2445">2445</a>.</li>
<li>Changed the following issue to SG1 (from Open): <a href="2441">2441</a>.</li>
</ul></li>
</ul>
</li>
<li>R91: 
2014-11-23 post-Urbana mailing
<ul>
<li><b>Summary:</b><ul>
<li>259 open issues, up by 32.</li>
<li>1722 closed issues, down by 20.</li>
<li>1981 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 12 New issues: <a href="2447">2447</a>, <a href="2448">2448</a>, <a href="2449">2449</a>, <a href="2450">2450</a>, <a href="2451">2451</a>, <a href="2452">2452</a>, <a href="2453">2453</a>, <a href="2454">2454</a>, <a href="2455">2455</a>, <a href="2456">2456</a>, <a href="2457">2457</a>, <a href="2458">2458</a>.</li>
<li>Changed the following 2 issues to Ready (from Review): <a href="2160">2160</a>, <a href="2364">2364</a>.</li>
<li>Changed the following 11 issues to Ready (from New): <a href="2403">2403</a>, <a href="2406">2406</a>, <a href="2411">2411</a>, <a href="2425">2425</a>, <a href="2427">2427</a>, <a href="2428">2428</a>, <a href="2433">2433</a>, <a href="2434">2434</a>, <a href="2438">2438</a>, <a href="2439">2439</a>, <a href="2440">2440</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="2168">2168</a>.</li>
<li>Changed the following issue to Review (from New): <a href="2424">2424</a>.</li>
<li>Changed the following 5 issues to Open (from New): <a href="2307">2307</a>, <a href="2310">2310</a>, <a href="2383">2383</a>, <a href="2414">2414</a>, <a href="2441">2441</a>.</li>
<li>Changed the following 2 issues to Open (from NAD Future): <a href="760">760</a>, <a href="1173">1173</a>.</li>
<li>Changed the following 4 issues to LEWG (from New): <a href="2419">2419</a>, <a href="2430">2430</a>, <a href="2443">2443</a>, <a href="2446">2446</a>.</li>
<li>Changed the following 48 issues to LEWG (from NAD Future): <a href="255">255</a>, <a href="423">423</a>, <a href="484">484</a>, <a href="523">523</a>, <a href="532">532</a>, <a href="708">708</a>, <a href="839">839</a>, <a href="851">851</a>, <a href="877">877</a>, <a href="933">933</a>, <a href="935">935</a>, <a href="936">936</a>, <a href="961">961</a>, <a href="1025">1025</a>, <a href="1031">1031</a>, <a href="1041">1041</a>, <a href="1052">1052</a>, <a href="1053">1053</a>, <a href="1112">1112</a>, <a href="1120">1120</a>, <a href="1121">1121</a>, <a href="1150">1150</a>, <a href="1154">1154</a>, <a href="1184">1184</a>, <a href="1188">1188</a>, <a href="1201">1201</a>, <a href="1203">1203</a>, <a href="1217">1217</a>, <a href="1235">1235</a>, <a href="1238">1238</a>, <a href="1242">1242</a>, <a href="1282">1282</a>, <a href="1289">1289</a>, <a href="1317">1317</a>, <a href="1320">1320</a>, <a href="1396">1396</a>, <a href="1406">1406</a>, <a href="1422">1422</a>, <a href="1459">1459</a>, <a href="1484">1484</a>, <a href="1488">1488</a>, <a href="1493">1493</a>, <a href="1499">1499</a>, <a href="1521">1521</a>, <a href="2040">2040</a>, <a href="2055">2055</a>, <a href="2226">2226</a>, <a href="2232">2232</a>.</li>
<li>Changed the following 2 issues to Pending NAD (from Tentatively NAD): <a href="2302">2302</a>, <a href="2382">2382</a>.</li>
<li>Changed the following 11 issues to WP (from Ready): <a href="2016">2016</a>, <a href="2170">2170</a>, <a href="2340">2340</a>, <a href="2354">2354</a>, <a href="2377">2377</a>, <a href="2396">2396</a>, <a href="2399">2399</a>, <a href="2400">2400</a>, <a href="2401">2401</a>, <a href="2404">2404</a>, <a href="2408">2408</a>.</li>
<li>Changed the following 12 issues to WP (from Tentatively Ready): <a href="2106">2106</a>, <a href="2129">2129</a>, <a href="2212">2212</a>, <a href="2217">2217</a>, <a href="2230">2230</a>, <a href="2233">2233</a>, <a href="2266">2266</a>, <a href="2325">2325</a>, <a href="2361">2361</a>, <a href="2365">2365</a>, <a href="2376">2376</a>, <a href="2387">2387</a>.</li>
<li>Changed the following issue to Resolved (from Ready): <a href="2319">2319</a>.</li>
<li>Changed the following issue to Resolved (from Review): <a href="2118">2118</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="2416">2416</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="2108">2108</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="2429">2429</a>.</li>
</ul></li>
</ul>
</li>
<li>R90: 
2014-10-13 pre-Urbana mailing
<ul>
<li><b>Summary:</b><ul>
<li>227 open issues, up by 31.</li>
<li>1742 closed issues, up by 0.</li>
<li>1969 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 31 New issues: <a href="2416">2416</a>, <a href="2417">2417</a>, <a href="2418">2418</a>, <a href="2419">2419</a>, <a href="2420">2420</a>, <a href="2421">2421</a>, <a href="2422">2422</a>, <a href="2423">2423</a>, <a href="2424">2424</a>, <a href="2425">2425</a>, <a href="2426">2426</a>, <a href="2427">2427</a>, <a href="2428">2428</a>, <a href="2429">2429</a>, <a href="2430">2430</a>, <a href="2431">2431</a>, <a href="2432">2432</a>, <a href="2433">2433</a>, <a href="2434">2434</a>, <a href="2435">2435</a>, <a href="2436">2436</a>, <a href="2437">2437</a>, <a href="2438">2438</a>, <a href="2439">2439</a>, <a href="2440">2440</a>, <a href="2441">2441</a>, <a href="2442">2442</a>, <a href="2443">2443</a>, <a href="2444">2444</a>, <a href="2445">2445</a>, <a href="2446">2446</a>.</li>
<li>No issues changed.</li>
</ul></li>
</ul>
</li>
<li>R89: 
2014-07-08 post-Rapperswil mailing
<ul>
<li><b>Summary:</b><ul>
<li>196 open issues, up by 14.</li>
<li>1742 closed issues, up by 12.</li>
<li>1938 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 6 Ready issues: <a href="2396">2396</a>, <a href="2399">2399</a>, <a href="2400">2400</a>, <a href="2401">2401</a>, <a href="2404">2404</a>, <a href="2408">2408</a>.</li>
<li>Added the following 15 New issues: <a href="2391">2391</a>, <a href="2392">2392</a>, <a href="2393">2393</a>, <a href="2394">2394</a>, <a href="2398">2398</a>, <a href="2402">2402</a>, <a href="2403">2403</a>, <a href="2406">2406</a>, <a href="2407">2407</a>, <a href="2410">2410</a>, <a href="2411">2411</a>, <a href="2412">2412</a>, <a href="2413">2413</a>, <a href="2414">2414</a>, <a href="2415">2415</a>.</li>
<li>Added the following Open issue: <a href="2397">2397</a>.</li>
<li>Added the following 3 WP issues: <a href="2390">2390</a>, <a href="2395">2395</a>, <a href="2409">2409</a>.</li>
<li>Added the following NAD issue: <a href="2405">2405</a>.</li>
<li>Changed the following issue to Ready (from New): <a href="2377">2377</a>.</li>
<li>Changed the following 2 issues to Ready (from Deferred): <a href="2253">2253</a>, <a href="2255">2255</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="2325">2325</a>, <a href="2387">2387</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="2382">2382</a>.</li>
<li>Changed the following 3 issues to Review (from New): <a href="2364">2364</a>, <a href="2378">2378</a>, <a href="2380">2380</a>.</li>
<li>Changed the following 2 issues to Review (from Open): <a href="2118">2118</a>, <a href="2160">2160</a>.</li>
<li>Changed the following 3 issues to Open (from New): <a href="2168">2168</a>, <a href="2238">2238</a>, <a href="2273">2273</a>.</li>
<li>Changed the following 3 issues to Open (from Deferred): <a href="2254">2254</a>, <a href="2264">2264</a>, <a href="2277">2277</a>.</li>
<li>Changed the following 3 issues to WP (from New): <a href="2371">2371</a>, <a href="2374">2374</a>, <a href="2389">2389</a>.</li>
<li>Changed the following 4 issues to Resolved (from Deferred): <a href="2282">2282</a>, <a href="2283">2283</a>, <a href="2287">2287</a>, <a href="2333">2333</a>.</li>
<li>Changed the following issue to NAD (from Deferred): <a href="2305">2305</a>.</li>
</ul></li>
</ul>
</li>
<li>R88: 
2014-05-24 pre-Rapperswil mailing
<ul>
<li><b>Summary:</b><ul>
<li>182 open issues, up by 29.</li>
<li>1730 closed issues, up by 0.</li>
<li>1912 issues total, up by 29.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 Tentatively Ready issues: <a href="2361">2361</a>, <a href="2365">2365</a>, <a href="2376">2376</a>.</li>
<li>Added the following 26 New issues: <a href="2362">2362</a>, <a href="2363">2363</a>, <a href="2364">2364</a>, <a href="2366">2366</a>, <a href="2367">2367</a>, <a href="2368">2368</a>, <a href="2369">2369</a>, <a href="2370">2370</a>, <a href="2371">2371</a>, <a href="2372">2372</a>, <a href="2373">2373</a>, <a href="2374">2374</a>, <a href="2375">2375</a>, <a href="2377">2377</a>, <a href="2378">2378</a>, <a href="2379">2379</a>, <a href="2380">2380</a>, <a href="2381">2381</a>, <a href="2382">2382</a>, <a href="2383">2383</a>, <a href="2384">2384</a>, <a href="2385">2385</a>, <a href="2386">2386</a>, <a href="2387">2387</a>, <a href="2388">2388</a>, <a href="2389">2389</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from Open): <a href="2106">2106</a>, <a href="2129">2129</a>, <a href="2212">2212</a>, <a href="2230">2230</a>, <a href="2233">2233</a>.</li>
</ul></li>
</ul>
</li>
</ul>

<h2 id='Issues'>Closed Issues</h2>
<hr>
<h3><a name="2" href="2">2.</a> Auto_ptr conversions effects incorrect</h3>
<p><b>Section:</b> 99 [auto.ptr.conv] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1997-12-04 <b>Last modified:</b> 2016-08-09 17:08:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#auto.ptr.conv">issues</a> in [auto.ptr.conv].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 1 in &quot;Effects&quot;, says &quot;Calls
p-&gt;release()&quot; where it clearly must be &quot;Calls
p.release()&quot;. (As it is, it seems to require using
auto_ptr&lt;&gt;::operator-&gt; to refer to X::release, assuming that
exists.)</p>


<p><b>Proposed resolution:</b></p>
<p>Change 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> paragraph 1 Effects from 
&quot;Calls p-&gt;release()&quot; to &quot;Calls p.release()&quot;.</p>


<p><b>Rationale:</b></p>
<p>Not a defect: the proposed change is already found in the standard.
[Originally classified as a defect, later reclassified.]</p>





<hr>
<h3><a name="4" href="4">4.</a> <code>basic_string</code> <code>size_type</code> and <code>difference_type</code> should be implementation defined</h3>
<p><b>Section:</b> 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 1997-11-16 <b>Last modified:</b> 2016-08-09 17:08:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Morristown we changed the <code>size_type</code> and <code>difference_type</code> typedefs
for all the other containers to implementation defined with a
reference to 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>.  This should probably also have been
done for strings. </p>


<p><b>Rationale:</b></p>
<p>Not a defect.  [Originally classified as a defect, later
reclassified.]  <code>basic_string</code>, unlike the other standard library
template containers, is severely constrained by its use of
<code>char_traits</code>. Those types are dictated by the traits class, and are far
from implementation defined.</p>





<hr>
<h3><a name="6" href="6">6.</a> File position not an offset unimplementable</h3>
<p><b>Section:</b> 31.5.3 <a href="https://timsong-cpp.github.io/cppwp/fpos">[fpos]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1997-12-15 <b>Last modified:</b> 2016-08-09 17:08:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Table 88, in I/O, is too strict; it's unimplementable on systems
where a file position isn't just an offset. It also never says just
what <code>fpos&lt;&gt;</code> is really supposed to be.  [Here's my summary, which
Jerry agrees is more or less accurate. &quot;I think I now know what
the class really is, at this point: it's a magic cookie that
encapsulates an <code>mbstate_t</code> and a file position (possibly represented as
an <code>fpos_t</code>), it has syntactic support for pointer-like arithmetic, and
implementors are required to have real, not just syntactic, support
for arithmetic.&quot; This isn't standardese, of course.] </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes that the Standard is already clear,
and that the above summary is what the Standard in effect says.</p>





<hr>
<h3><a name="10" href="10">10.</a> Codecvt&lt;&gt;::do unclear</h3>
<p><b>Section:</b> 30.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.byname">[locale.codecvt.byname]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-01-14 <b>Last modified:</b> 2016-08-09 17:08:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="19">19</a></p>
<p><b>Discussion:</b></p>
<p>Section 22.2.1.5.2 says that codecvt&lt;&gt;::do_in and do_out
should return the value noconv if &quot;no conversion was
needed&quot;. However, I don't see anything anywhere that defines what
it means for a conversion to be needed or not needed. I can think of
several circumstances where one might plausibly think that a
conversion is not &quot;needed&quot;, but I don't know which one is
intended here. </p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="12" href="12">12.</a> Way objects hold allocators unclear</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1998-02-23 <b>Last modified:</b> 2016-08-09 17:08:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I couldn't find a statement in the standard saying whether the allocator object held by
a container is held as a copy of the constructor argument or whether a pointer of
reference is maintained internal. There is an according statement for compare objects and
how they are maintained by the associative containers, but I couldn't find anything
regarding allocators. </p>

<p>Did I overlook it? Is it an open issue or known defect? Or is it deliberately left
unspecified? </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes that the Standard is already
clear.&nbsp; See 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>, paragraph 8.</p>





<hr>
<h3><a name="43" href="43">43.</a> Locale table correction</h3>
<p><b>Section:</b> 30.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.byname">[locale.codecvt.byname]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Brendan Kehoe <b>Opened:</b> 1998-06-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="33">33</a></p>
<p><b>Discussion:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="45" href="45">45.</a> Stringstreams read/write pointers initial position unclear</h3>
<p><b>Section:</b> 31.8.4 <a href="https://timsong-cpp.github.io/cppwp/ostringstream">[ostringstream]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matthias Mueller <b>Opened:</b> 1998-05-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostringstream">issues</a> in [ostringstream].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In a comp.lang.c++.moderated Matthias Mueller wrote:</p>

<p>&quot;We are not sure how to interpret the CD2 (see 31.3 <a href="https://timsong-cpp.github.io/cppwp/iostream.forward">[iostream.forward]</a>, 31.8.4.2 <a href="https://timsong-cpp.github.io/cppwp/ostringstream.cons">[ostringstream.cons]</a>, 31.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.cons">[stringbuf.cons]</a>)
with respect to the question as to what the correct initial positions
of the write and&nbsp; read pointers of a stringstream should
be.&quot;</p>

<p>&quot;Is it the same to output two strings or to initialize the stringstream with the
first and to output the second?&quot;</p>

<p><i>[PJ Plauger, Bjarne Stroustrup, Randy Smithey, Sean Corfield, and
Jerry Schwarz have all offered opinions; see reflector messages
lib-6518, 6519, 6520, 6521, 6523, 6524.]</i></p>




<p><b>Rationale:</b></p>
<p>The LWG believes the Standard is correct as written. The behavior
of stringstreams is consistent with fstreams, and there is a
constructor which can be used to obtain the desired effect. This
behavior is known to be different from strstreams.</p>





<hr>
<h3><a name="58" href="58">58.</a> Extracting a char from a wide-oriented stream</h3>
<p><b>Section:</b> 31.7.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/istream.extractors">[istream.extractors]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-07-01 <b>Last modified:</b> 2017-04-22 20:55:04 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.extractors">issues</a> in [istream.extractors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.6.1.2.3 has member functions for extraction of signed char and
unsigned char, both singly and as strings. However, it doesn't say
what it means to extract a <tt>char</tt> from a
<tt>basic_streambuf&lt;charT, Traits&gt;</tt>. </p>

<p>basic_streambuf, after all, has no members to extract a char, so
basic_istream must somehow convert from charT to signed char or
unsigned char. The standard doesn't say how it is to perform that
conversion. </p>


<p><b>Rationale:</b></p>
<p>The Standard is correct as written.  There is no such extractor and
this is the intent of the LWG.</p>




<hr>
<h3><a name="65" href="65">65.</a> Underspecification of strstreambuf::seekoff</h3>
<p><b>Section:</b> D.12.2.4 <a href="https://timsong-cpp.github.io/cppwp/depr.strstreambuf.virtuals">[depr.strstreambuf.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.strstreambuf.virtuals">issues</a> in [depr.strstreambuf.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard says how this member function affects the current
stream position. (<tt>gptr</tt> or <tt>pptr</tt>) However, it does not
say how this member function affects the beginning and end of the
get/put area. </p>

<p>This is an issue when seekoff is used to position the get pointer
beyond the end of the current read area. (Which is legal. This is
implicit in the definition of <i>seekhigh</i> in D.7.1, paragraph 4.)
</p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that seekoff() is underspecified, but does not wish
to invest effort in this deprecated feature.</p>





<hr>
<h3><a name="67" href="67">67.</a> Setw useless for strings</h3>
<p><b>Section:</b> 23.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/string.io">[string.io]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-07-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="25">25</a></p>
<p><b>Discussion:</b></p>
<p>In a comp.std.c++ posting Michel Michaud wrote: What
should be output by: </p>

<pre>   string text(&quot;Hello&quot;);
   cout &lt;&lt; '[' &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; text &lt;&lt; ']';
</pre>

<p>Shouldn't it be:</p>

<pre>   [     Hello]</pre>

<p>Another person replied: Actually, according to the FDIS, the width
of the field should be the minimum of width and the length of the
string, so the output shouldn't have any padding. I think that this is
a typo, however, and that what is wanted is the maximum of the
two. (As written, setw is useless for strings. If that had been the
intent, one wouldn't expect them to have mentioned using its value.)
</p>

<p>It's worth pointing out that this is a recent correction anyway;
IIRC, earlier versions of the draft forgot to mention formatting
parameters whatsoever.</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="72" href="72">72.</a> Do_convert phantom member function</h3>
<p><b>Section:</b> 30.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="24">24</a></p>
<p><b>Discussion:</b></p>
<p>In 30.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a> par 3, and in 30.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a> par 8, a nonexistent member function
&quot;do_convert&quot; is mentioned. This member was replaced with
&quot;do_in&quot; and &quot;do_out&quot;, the proper referents in the
contexts above.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="73" href="73">73.</a> <tt>is_open</tt> should be const</h3>
<p><b>Section:</b> 31.10 <a href="https://timsong-cpp.github.io/cppwp/file.streams">[file.streams]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-27 <b>Last modified:</b> 2017-06-15 20:26:45 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#file.streams">issues</a> in [file.streams].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Classes <tt>basic_ifstream</tt>, <tt>basic_ofstream</tt>, and
<tt>basic_fstream</tt> all have a member function <tt>is_open</tt>. It
should be a <tt>const</tt> member function, since it does nothing but
call one of <tt>basic_filebuf</tt>'s const member functions. </p>


<p><b>Rationale:</b></p>
<p>Not a defect. This is a deliberate feature; const streams would be
meaningless.</p>




<hr>
<h3><a name="77" href="77">77.</a> Valarray operator[] const returning value</h3>
<p><b>Section:</b> 28.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/valarray.access">[valarray.access]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Levente Farkas <b>Opened:</b> 1998-09-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="389">389</a></p>
<p><b>Discussion:</b></p>
<p>valarray:<br/>
<br/>
&nbsp;&nbsp;&nbsp; <tt>T operator[] (size_t) const;</tt><br/>
<br/>
why not <br/>
<br/>
&nbsp;&nbsp;&nbsp; <tt>const T&amp; operator[] (size_t) const;</tt><br/>
<br/>
as in vector ???<br/>
<br/>
One can't copy even from a const valarray eg:<br/>
<br/>
&nbsp;&nbsp;&nbsp; <tt>memcpy(ptr, &amp;v[0], v.size() * sizeof(double));<br/>
</tt><br/>
[I] find this bug in valarray is very difficult.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes that the interface was deliberately designed that
way. That is what valarray was designed to do; that's where the
&quot;value array&quot; name comes from. LWG members further comment
that &quot;we don't want valarray to be a full STL container.&quot;
28.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/valarray.access">[valarray.access]</a> specifies properties that indicate &quot;an
absence of aliasing&quot; for non-constant arrays; this allows
optimizations, including special hardware optimizations, that are not
otherwise possible. </p>





<hr>
<h3><a name="81" href="81">81.</a> Wrong declaration of slice operations</h3>
<p><b>Section:</b> 28.6.5 <a href="https://timsong-cpp.github.io/cppwp/template.slice.array">[template.slice.array]</a>, 28.6.7 <a href="https://timsong-cpp.github.io/cppwp/template.gslice.array">[template.gslice.array]</a>, 28.6.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a>, 28.6.9 <a href="https://timsong-cpp.github.io/cppwp/template.indirect.array">[template.indirect.array]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#template.slice.array">issues</a> in [template.slice.array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Isn't the definition of copy constructor and assignment operators wrong?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Instead of</p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_array(const slice_array&amp;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_array&amp; operator=(const slice_array&amp;);</pre>

<p>IMHO they have to be</p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice_array(const slice_array&lt;T&gt;&amp;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice_array&amp; operator=(const slice_array&lt;T&gt;&amp;);</pre>

<p>Same for gslice_array. </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The Standard is correct as written. </p>




<hr>
<h3><a name="82" href="82">82.</a> Missing constant for set elements</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 5 specifies:</p>

<blockquote><p>
For set and multiset the value type is the same as the key type. For
map and multimap it is equal to pair&lt;const Key, T&gt;.  
</p></blockquote>

<p>Strictly speaking, this is not correct because for set and multiset
the value type is the same as the <b>constant</b> key type.</p>


<p><b>Rationale:</b></p>
<p>Not a defect. The Standard is correct as written; it uses a
different mechanism (const &amp;) for <tt>set</tt> and
<tt>multiset</tt>. See issue <a href="103">103</a> for a related
issue.</p>




<hr>
<h3><a name="84" href="84">84.</a> Ambiguity with string::insert()</h3>
<p><b>Section:</b> 23.4.3.6 <a href="https://timsong-cpp.github.io/cppwp/string.access">[string.access]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.access">issues</a> in [string.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>If I try</p>
<pre>    s.insert(0,1,' ');</pre>

<p>&nbsp; I get an nasty ambiguity. It might be</p>
<pre>    s.insert((size_type)0,(size_type)1,(charT)' ');</pre>

<p>which inserts 1 space character at position 0, or</p>
<pre>    s.insert((char*)0,(size_type)1,(charT)' ')</pre>

<p>which inserts 1 space character at iterator/address 0 (bingo!), or</p>
<pre>    s.insert((char*)0, (InputIterator)1, (InputIterator)' ')</pre>

<p>which normally inserts characters from iterator 1 to iterator '
'. But according to 23.1.1.9 (the &quot;do the right thing&quot; fix)
it is equivalent to the second. However, it is still ambiguous,
because of course I mean the first!</p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes this is a &quot;genetic
misfortune&quot; inherent in the design of string and thus not a
defect in the Standard as such .</p>




<hr>
<h3><a name="85" href="85">85.</a> String char types</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard seems not to require that charT is equivalent to
traits::char_type. So, what happens if charT is not equivalent to
traits::char_type?</p>


<p><b>Rationale:</b></p>
<p>There is already wording in 23.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits">[char.traits]</a> paragraph 3 that
requires them to be the same.</p>




<hr>
<h3><a name="87" href="87">87.</a> Error in description of string::compare()</h3>
<p><b>Section:</b> 23.4.3.7.8 <a href="https://timsong-cpp.github.io/cppwp/string.swap">[string.swap]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2016-11-12 20:15:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.swap">issues</a> in [string.swap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="5">5</a></p>
<p><b>Discussion:</b></p>
<p>The following <tt>compare()</tt> description is obviously a bug:</p>

<pre>
int compare(size_type pos, size_type n1, 
            charT *s, size_type n2 = npos) const;
</pre>

<p>because without passing <tt>n2</tt> it should compare up to the end of the
string instead of comparing <tt>npos</tt> characters (which throws an
exception) </p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="88" href="88">88.</a> Inconsistency between string::insert() and string::append()</h3>
<p><b>Section:</b> 23.4.3.7.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a>, 23.4.3.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2016-11-12 20:15:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.insert">issues</a> in [string.insert].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Why does </p>
<pre>  template&lt;class InputIterator&gt; 
       basic_string&amp; append(InputIterator first, InputIterator last);</pre>

<p>return a string, while</p>
<pre>  template&lt;class InputIterator&gt; 
       void insert(iterator p, InputIterator first, InputIterator last);</pre>

<p>returns nothing ?</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this stylistic inconsistency is not sufficiently 
serious to constitute a defect.</p>




<hr>
<h3><a name="89" href="89">89.</a> Missing throw specification for string::insert() and string::replace()</h3>
<p><b>Section:</b> 23.4.3.7.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a>, 23.4.3.7.6 <a href="https://timsong-cpp.github.io/cppwp/string.replace">[string.replace]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2016-11-12 20:15:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.insert">issues</a> in [string.insert].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="83">83</a></p>
<p><b>Discussion:</b></p>
<p>All insert() and replace() members for strings with an iterator as
first argument lack a throw specification. The throw
specification should probably be: length_error if size exceeds
maximum. </p>


<p><b>Rationale:</b></p>
<p>Considered a duplicate because it will be solved by the resolution
of issue <a href="83">83</a>.</p>





<hr>
<h3><a name="93" href="93">93.</a> Incomplete Valarray Subset Definitions</h3>
<p><b>Section:</b> 28.6 <a href="https://timsong-cpp.github.io/cppwp/numarray">[numarray]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numarray">issues</a> in [numarray].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>You can easily create subsets, but you can't easily combine them
with other subsets.  Unfortunately, you almost always needs an
explicit type conversion to valarray. This is because the standard
does not specify that valarray subsets provide the same operations as
valarrays. </p>

<p>For example, to multiply two subsets and assign the result to a third subset, you can't
write the following:</p>

<pre>va[slice(0,4,3)] = va[slice(1,4,3)] * va[slice(2,4,3)];</pre>

<p>Instead, you have to code as follows:</p>

<pre>va[slice(0,4,3)] = static_cast&lt;valarray&lt;double&gt; &gt;(va[slice(1,4,3)]) * 
                   static_cast&lt;valarray&lt;double&gt; &gt;(va[slice(2,4,3)]);</pre>

<p>This is tedious and error-prone. Even worse, it costs performance because each cast
creates a temporary objects, which could be avoided without the cast. </p>


<p><b>Proposed resolution:</b></p>
<p>Extend all valarray subset types so that they offer all valarray operations.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard; it is a request for an extension.</p>




<hr>
<h3><a name="94" href="94">94.</a> May library implementors add template parameters to Standard Library classes?</h3>
<p><b>Section:</b> 16.4.6 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-01-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#conforming">issues</a> in [conforming].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Is it a permitted extension for library implementors to add template parameters to
standard library classes, provided that those extra parameters have defaults? For example,
instead of defining <tt>template &lt;class T, class Alloc = allocator&lt;T&gt; &gt; class
vector;</tt> defining it as <tt>template &lt;class T, class Alloc = allocator&lt;T&gt;,
int N = 1&gt; class vector;</tt> </p>

<p>The standard may well already allow this (I can't think of any way that this extension
could break a conforming program, considering that users are not permitted to
forward-declare standard library components), but it ought to be explicitly permitted or
forbidden. </p>

<p>comment from Steve Cleary via comp.std.c++:</p>
<blockquote>
<p>I disagree [with the proposed resolution] for the following reason:
consider user library code with template template parameters. For
example, a user library object may be templated on the type of
underlying sequence storage to use (deque/list/vector), since these
classes all take the same number and type of template parameters; this
would allow the user to determine the performance tradeoffs of the
user library object. A similar example is a user library object
templated on the type of underlying set storage (set/multiset) or map
storage (map/multimap), which would allow users to change (within
reason) the semantic meanings of operations on that object.</p>
<p>I think that additional template parameters should be forbidden in
the Standard classes. Library writers don't lose any expressive power,
and can still offer extensions because additional template parameters
may be provided by a non-Standard implementation class:</p>
<pre> 
   template &lt;class T, class Allocator = allocator&lt;T&gt;, int N = 1&gt;
   class __vector
   { ... };
   template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
   class vector: public __vector&lt;T, Allocator&gt;
   { ... };
</pre>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Add a new subclause [presumably 17.4.4.9] following 16.4.6.13 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>:</p>

<blockquote>
  <p>17.4.4.9 Template Parameters</p> <p>A specialization of a
  template class described in the C++ Standard Library behaves the
  same as if the implementation declares no additional template
  parameters.</p> <p>Footnote: Additional template parameters with
  default values are thus permitted.</p>
</blockquote>

<p>Add &quot;template parameters&quot; to the list of subclauses at
the end of 16.4.6 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> paragraph 1.</p>

<p><i>[Kona: The LWG agreed the standard needs clarification. After
discussion with John Spicer, it seems added template parameters can be
detected by a program using template-template parameters. A straw vote
- &quot;should implementors be allowed to add template
parameters?&quot; found no consensus ; 5 - yes, 7 - no.]</i></p>




<p><b>Rationale:</b></p>
<p>
There is no ambiguity; the standard is clear as written.  Library
implementors are not permitted to add template parameters to standard
library classes.  This does not fall under the &quot;as if&quot; rule,
so it would be permitted only if the standard gave explicit license
for implementors to do this.  This would require a change in the 
standard.
</p>

<p>
The LWG decided against making this change, because it would break
user code involving template template parameters or specializations
of standard library class templates.
</p>





<hr>
<h3><a name="95" href="95">95.</a> Members added by the implementation</h3>
<p><b>Section:</b> 16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in [member.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 17.3.4.4/2 vs 17.3.4.7/0 there is a hole; an implementation could add virtual
members a base class and break user derived classes.</p>

<p>Example: </p>

<blockquote>
  <pre>// implementation code:
struct _Base { // _Base is in the implementer namespace
        virtual void foo ();
};
class vector : _Base // deriving from a class is allowed
{ ... };

// user code:
class vector_checking : public vector 
{
        void foo (); // don't want to override _Base::foo () as the 
                     // user doesn't know about _Base::foo ()
};</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Clarify the wording to make the example illegal.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard.&nbsp; The example is already
illegal.&nbsp; See 16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> paragraph 2.</p>




<hr>
<h3><a name="96" href="96">96.</a> Vector&lt;bool&gt; is not a container</h3>
<p><b>Section:</b> 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><tt>vector&lt;bool&gt;</tt> is not a container as its reference and
pointer types are not references and pointers. </p>

<p>Also it forces everyone to have a space optimization instead of a
speed one.</p>

<p><b>See also:</b> 99-0008 == N1185 Vector&lt;bool&gt; is
Nonconforming, Forces Optimization Choice.</p>

<p><i>[In Santa Cruz the LWG felt that this was Not A Defect.]</i></p>


<p><i>[In Dublin many present felt that failure to meet Container
requirements was a defect. There was disagreement as to whether
or not the optimization requirements constituted a defect.]</i></p>


<p><i>[The LWG looked at the following resolutions in some detail:
<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * Not A Defect.<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a note explaining that vector&lt;bool&gt; does not meet
Container requirements.<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * Remove vector&lt;bool&gt;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a new category of container requirements which
vector&lt;bool&gt; would meet.<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * Rename vector&lt;bool&gt;.<br/>
<br/>
No alternative had strong, wide-spread, support and every alternative
had at least one &quot;over my dead body&quot; response.<br/>
<br/>
There was also mention of a transition scheme something like (1) add
vector_bool and deprecate vector&lt;bool&gt; in the next standard. (2)
Remove vector&lt;bool&gt; in the following standard.]</i></p>


<p><i>[Modifying container requirements to permit returning proxies
(thus allowing container requirements conforming vector&lt;bool&gt;)
was also discussed.]</i></p>


<p><i>[It was also noted that there is a partial but ugly workaround in
that vector&lt;bool&gt; may be further specialized with a customer
allocator.]</i></p>


<p><i>[Kona: Herb Sutter presented his paper J16/99-0035==WG21/N1211,
<tt>vector&lt;bool&gt;</tt>: More Problems, Better Solutions. Much discussion
of a two step approach: a) deprecate, b) provide replacement under a
new name.  LWG straw vote on that: 1-favor, 11-could live with, 2-over
my dead body.  This resolution was mentioned in the LWG report to the
full committee, where several additional committee members indicated
over-my-dead-body positions.]</i></p>


<p>Discussed at Lillehammer.  General agreement that we should
  deprecate <tt>vector&lt;bool&gt;</tt> and introduce this functionality under
  a different name, e.g. <tt>bit_vector</tt>.  This might make it possible to
  remove the <tt>vector&lt;bool&gt;</tt> specialization in the standard that comes
  after C++0x. There was also a suggestion that
  in C++0x we could additional say that it's implementation defined
  whether <tt>vector&lt;bool&gt;</tt> refers to the specialization or to the
  primary template, but there wasn't general agreement that this was a
  good idea.</p>

<p>We need a paper for the new <tt>bit_vector</tt> class.</p>

<p><i>[
Batavia:
]</i></p>

<blockquote><p>
The LWG feels we need something closer to SGI's <tt>bitvector</tt> to ease migration
from <tt>vector&lt;bool&gt;</tt>.  Although some of the funcitonality from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
could well be used in such a template.  The concern is easing the API migration for those
users who want to continue using a bit-packed container.  Alan and Beman to work.
</p></blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
<tt>vector&lt;bool&gt;</tt> is now a conforming container under the revised terms of C++0x,
which supports containers of proxies.
</p>
<p>
Recommend NAD.
</p>
<p>
Two issues remain:
</p>
<p>
i/ premature optimization in the specification.
There is still some sentiment that deprecation is the correct way to go,
although it is still not clear what it would mean to deprecate a single
specialization of a template.
</p>
<p>
Recommend: Create a new issue for the discussion, leave as Open.
</p>
<p>
ii/ Request for a new bitvector class to guarantee the optimization, perhaps
with a better tuned interface.
</p>
<p>
This is a clear extension request that may be handled via a future TR.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We note that most of this issue has become moot over time,
and agree with Alisdair's recommendations.
Move to NAD Future for reconsideration of part (ii).
</p></blockquote>

<p><i>[
2009-07-29 Alisdair reopens:
]</i></p>


<blockquote>
<p>
This infamous issue was closed as NAD Future when concepts introduced
support for proxy iterators, so the only remaining requirement was to
provide a better type to support bitsets of dynamic length.  I fear we
must re-open this issue until the post-concept form of iterators is
available, and hopefully will support the necessary proxy functionality
to allow us to close this issue as NAD.
</p>

<p>
I recommend we spawn a separate issue (<a href="1184">1184</a>) requesting a dynamic length bitset
and pre-emptively file it as NAD Future.  It is difficult to resolve #96
when it effectively contains two separate sub-issues.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD, and give rationale.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
We now have:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2160.html">N2160</a>.
</p>



<p><b>Rationale:</b></p>
<p>
We want to support proxy iterators but that is going to be separate
work. Don't want to see this issue come back in these kinds of terms.
We're interested in a separate container, and proxy iterators, but both
of those are separate issues.
</p>
<p>
We've looked at a lot of ways to fix this that would be close to this,
but those things would break existing code. Attempts to fix this
directly have not been tractable, and removing it has not been
tractable. Therefore we are closing.
</p>





<hr>
<h3><a name="97" href="97">97.</a> Insert inconsistent definition</h3>
<p><b>Section:</b> 24 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><tt>insert(iterator, const value_type&amp;)</tt> is defined both on
sequences and on set, with unrelated semantics: insert here (in
sequences), and insert with hint (in associative containers). They
should have different names (B.S. says: do not abuse overloading).</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. It is a genetic misfortune of
the design, for better or for worse.</p>




<hr>
<h3><a name="99" href="99">99.</a> Reverse_iterator comparisons completely wrong</h3>
<p><b>Section:</b> 25.5.1.8 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.cmp">[reverse.iter.cmp]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The &lt;, &gt;, &lt;=, &gt;= comparison operator are wrong: they
return the opposite of what they should.</p>

<p>Note: same problem in CD2, these were not even defined in CD1.  SGI
STL code is correct; this problem is known since the Morristown
meeting but there it was too late</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. A careful reading shows the Standard is correct
as written. A review of several implementations show that they implement
exactly what the Standard says.</p>




<hr>
<h3><a name="100" href="100">100.</a> Insert iterators/ostream_iterators overconstrained</h3>
<p><b>Section:</b> 25.5.2 <a href="https://timsong-cpp.github.io/cppwp/insert.iterators">[insert.iterators]</a>, 25.6.5 <a href="https://timsong-cpp.github.io/cppwp/ostreambuf.iterator">[ostreambuf.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Overspecified For an insert iterator it, the expression *it is
required to return a reference to it. This is a simple possible
implementation, but as the SGI STL documentation says, not the only
one, and the user should not assume that this is the case.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this causes no harm and is not a defect in the
standard. The only example anyone could come up with caused some
incorrect code to work, rather than the other way around.</p>





<hr>
<h3><a name="101" href="101">101.</a> No way to free storage for vector and deque</h3>
<p><b>Section:</b> 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a>, 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>Reserve can not free storage, unlike string::reserve</p>

<p><i>[
2010-02-13 Alisdair adds:
]</i></p>


<blockquote>
<p>
This issue has been revisited and addressed (<a href="755">755</a>, <a href="850">850</a>). This issues should be reclassified to NAD Editorial to reflect
this action.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. The LWG has considered this
issue in the past and sees no need to change the Standard. Deque has
no reserve() member function. For vector, shrink-to-fit can be
expressed in a single line of code (where <tt>v</tt> is
<tt>vector&lt;T&gt;</tt>):
</p>

<blockquote>
  <p><tt>vector&lt;T&gt;(v).swap(v);&nbsp; // shrink-to-fit v</tt></p>
</blockquote>





<hr>
<h3><a name="102" href="102">102.</a> Bug in insert range in associative containers</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="264">264</a></p>
<p><b>Discussion:</b></p>
<p>Table 69 of Containers say that a.insert(i,j) is linear if [i, j) is ordered. It seems
impossible to implement, as it means that if [i, j) = [x], insert in an associative
container is O(1)!</p>


<p><b>Proposed resolution:</b></p>
<p>N+log (size()) if [i,j) is sorted according to value_comp()</p>


<p><b>Rationale:</b></p>
<p>Subsumed by issue <a href="264">264</a>.</p>





<hr>
<h3><a name="104" href="104">104.</a> Description of basic_string::operator[] is unclear</h3>
<p><b>Section:</b> 23.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.capacity">issues</a> in [string.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>It is not clear that undefined behavior applies when pos == size ()
for the non const version.</p>


<p><b>Proposed resolution:</b></p>
<p>Rewrite as: Otherwise, if pos &gt; size () or pos == size () and
the non-const version is used, then the behavior is undefined.</p>


<p><b>Rationale:</b></p>
<p>The Standard is correct. The proposed resolution already appears in
the Standard.</p>




<hr>
<h3><a name="105" href="105">105.</a> fstream ctors argument types desired</h3>
<p><b>Section:</b> 31.10 <a href="https://timsong-cpp.github.io/cppwp/file.streams">[file.streams]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#file.streams">issues</a> in [file.streams].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="454">454</a></p>
<p><b>Discussion:</b></p>


<p>fstream ctors take a const char* instead of string.<br/>
fstream ctors can't take wchar_t</p>

<p>An extension to add a const wchar_t* to fstream would make the
implementation non conforming.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. It might be an
interesting extension for the next Standard. </p>




<hr>
<h3><a name="107" href="107">107.</a> Valarray constructor is strange</h3>
<p><b>Section:</b> 28.6.2 <a href="https://timsong-cpp.github.io/cppwp/template.valarray">[template.valarray]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#template.valarray">issues</a> in [template.valarray].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The order of the arguments is (elem, size) instead of the normal
(size, elem) in the rest of the library. Since elem often has an
integral or floating point type, both types are convertible to each
other and reversing them leads to a well formed program.</p>


<p><b>Proposed resolution:</b></p>
<p>Inverting the arguments could silently break programs. Introduce
the two signatures (const T&amp;, size_t) and (size_t, const T&amp;),
but make the one we do not want private so errors result in a
diagnosed access violation. This technique can also be applied to STL
containers.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes that while the order of arguments is unfortunate,
it does not constitute a defect in the standard. The LWG believes that
the proposed solution will not work for valarray&lt;size_t&gt; and
perhaps other cases.</p>




<hr>
<h3><a name="111" href="111">111.</a> <tt>istreambuf_iterator::equal</tt> overspecified, inefficient</h3>
<p><b>Section:</b> 25.6.4.4 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator.ops">[istreambuf.iterator.ops]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-10-15 <b>Last modified:</b> 2017-11-29 22:35:18 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istreambuf.iterator.ops">issues</a> in [istreambuf.iterator.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The member <tt>istreambuf_iterator&lt;&gt;::equal</tt> is specified to be
unnecessarily inefficient. While this does not affect the efficiency
of conforming implementations of iostreams, because they can
&quot;reach into&quot; the iterators and bypass this function, it does
affect users who use <tt>istreambuf_iterators</tt>. </p>

<p>The inefficiency results from a too-scrupulous definition, which
requires a &quot;true&quot; result if neither iterator is at eof. In
practice these iterators can only usefully be compared with the
&quot;eof&quot; value, so the extra test implied provides no benefit,
but slows down users' code. </p>

<p>The solution is to weaken the requirement on the function to return
true only if both iterators are at eof. </p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Reopened by Alisdair.
</p></blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<p>
Recommend NAD. The proposed wording would violate the axioms of
concept requirement <tt>EqualityComparable</tt> axioms as part of concept <tt>InputIterator</tt>
and more specifically it would violate the explicit wording of
25.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>/7:
</p>

<blockquote><p>
If two iterators <tt>a</tt> and <tt>b</tt> of the same type are equal, then either <tt>a</tt>
and <tt>b</tt> are both dereferenceable or else neither is dereferenceable.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Agree NAD.
</p></blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Replace 99 [istreambuf.iterator::equal], paragraph 1, </p>

<blockquote>
  <p>-1- <i>Returns</i>: true if and only if both iterators are at end-of-stream, or neither is at
  end-of-stream, regardless of what streambuf object they use. </p>
</blockquote>

<p>with</p>

<blockquote>
  <p>-1- <i>Returns</i>: true if and only if both iterators are at
  end-of-stream, regardless of what streambuf object they use. </p>
</blockquote>



<p><b>Rationale:</b></p>
<p>It is not clear that this is a genuine defect. Additionally, the
LWG was reluctant to make a change that would result in 
<tt>operator==</tt> not being a equivalence relation. One consequence of
this change is that an algorithm that's passed the range <tt>[i, i)</tt>
would no longer treat it as an empty range.</p>





<hr>
<h3><a name="113" href="113">113.</a> Missing/extra iostream sync semantics</h3>
<p><b>Section:</b> 31.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a>, 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-10-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream">issues</a> in [istream].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 27.6.1.1, class basic_istream has a member function sync, described in 27.6.1.3,
paragraph 36. </p>

<p>Following the chain of definitions, I find that the various sync functions have defined
semantics for output streams, but no semantics for input streams. On the other hand,
basic_ostream has no sync function. </p>

<p>The sync function should at minimum be added to basic_ostream, for internal
consistency. </p>

<p>A larger question is whether sync should have assigned semantics for input streams. </p>

<p>Classic iostreams said streambuf::sync flushes pending output and attempts to return
unread input characters to the source. It is a protected member function. The filebuf
version (which is public) has that behavior (it backs up the read pointer). Class
strstreambuf does not override streambuf::sync, and so sync can't be called on a
strstream. </p>

<p>If we can add corresponding semantics to the various sync functions, we should. If not,
we should remove sync from basic_istream.</p>


<p><b>Rationale:</b></p>
<p>A sync function is not needed in basic_ostream because the flush function provides the
desired functionality.</p>

<p>As for the other points, the LWG finds the standard correct as written.</p>





<hr>
<h3><a name="116" href="116">116.</a> bitset cannot be constructed with a const char*</h3>
<p><b>Section:</b> 22.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-11-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="778">778</a></p>
<p><b>Discussion:</b></p>



<p>The following code does not compile with the EDG compiler:</p>

<blockquote>
  <pre>#include &lt;bitset&gt;
using namespace std;
bitset&lt;32&gt; b(&quot;111111111&quot;);</pre>
</blockquote>

<p>If you cast the ctor argument to a string, i.e.:</p>

<blockquote>
  <pre>bitset&lt;32&gt; b(string(&quot;111111111&quot;));</pre>
</blockquote>

<p>then it will compile. The reason is that bitset has the following templatized
constructor:</p>

<blockquote>
  <pre>template &lt;class charT, class traits, class Allocator&gt;
explicit bitset (const basic_string&lt;charT, traits, Allocator&gt;&amp; str, ...);</pre>
</blockquote>

<p>According to the compiler vendor, Steve Adamcyk at EDG, the user
cannot pass this template constructor a <tt>const char*</tt> and
expect a conversion to <tt>basic_string</tt>.  The reason is
&quot;When you have a template constructor, it can get used in
contexts where type deduction can be done. Type deduction basically
comes up with exact matches, not ones involving conversions.&quot;
</p>

<p>I don't think the intention when this constructor became
templatized was for construction from a <tt>const char*</tt> to no
longer work.</p>


<p><b>Proposed resolution:</b></p>
<p>Add to 22.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> a bitset constructor declaration</p>

<blockquote>
  <pre>explicit bitset(const char*);</pre>
</blockquote>

<p>and in Section 22.9.2.2 <a href="https://timsong-cpp.github.io/cppwp/bitset.cons">[bitset.cons]</a> add:</p>

<blockquote>
  <pre>explicit bitset(const char* str);</pre>
  <p>Effects: <br/>
  &nbsp;&nbsp;&nbsp; Calls <tt>bitset((string) str, 0, string::npos);</tt></p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Although the problem is real, the standard is designed that way so
it is not a defect.  Education is the immediate workaround. A future
standard may wish to consider the Proposed Resolution as an
extension.</p>





<hr>
<h3><a name="121" href="121">121.</a> Detailed definition for ctype&lt;wchar_t&gt; specialization</h3>
<p><b>Section:</b> 30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 22.1.1.1.1 has the following listed in Table 51: ctype&lt;char&gt; ,
ctype&lt;wchar_t&gt;. </p>

<p>Also Section 30.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.ctype">[locale.ctype]</a> says: </p>

<blockquote>
  <p>The instantiations required in Table 51 (22.1.1.1.1) namely ctype&lt;char&gt; and
  ctype&lt;wchar_t&gt; , implement character classing appropriate to the implementation's
  native character set. </p>
</blockquote>

<p>However, Section 30.4.2.4 <a href="https://timsong-cpp.github.io/cppwp/facet.ctype.special">[facet.ctype.special]</a>
only has a detailed description of the ctype&lt;char&gt; specialization, not the
ctype&lt;wchar_t&gt; specialization. </p>


<p><b>Proposed resolution:</b></p>
<p>Add the ctype&lt;wchar_t&gt; detailed class description to Section 
30.4.2.4 <a href="https://timsong-cpp.github.io/cppwp/facet.ctype.special">[facet.ctype.special]</a>. </p>


<p><b>Rationale:</b></p>
<p>Specialization for wchar_t is not needed since the default is acceptable.</p>





<hr>
<h3><a name="128" href="128">128.</a> Need open_mode() function for file stream, string streams, file buffers, and string&nbsp; buffers</h3>
<p><b>Section:</b> 31.8 <a href="https://timsong-cpp.github.io/cppwp/string.streams">[string.streams]</a>, 31.10 <a href="https://timsong-cpp.github.io/cppwp/file.streams">[file.streams]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-02-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.streams">issues</a> in [string.streams].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The following question came from Thorsten Herlemann:</p>

<blockquote>
  <p>You can set a mode when constructing or opening a file-stream or
  filebuf, e.g.  ios::in, ios::out, ios::binary, ... But how can I get
  that mode later on, e.g. in my own operator &lt;&lt; or operator
  &gt;&gt; or when I want to check whether a file-stream or
  file-buffer object passed as parameter is opened for input or output
  or binary? Is there no possibility? Is this a design-error in the
  standard C++ library? </p>
</blockquote>

<p>It is indeed impossible to find out what a stream's or stream
buffer's open mode is, and without that knowledge you don't know
how certain operations behave. Just think of the append mode. </p>

<p>Both streams and stream buffers should have a <tt>mode()</tt> function that returns the
current open mode setting. </p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Neither Howard nor Bill has received a customer request for this.
</p>
<p>
No consensus for change. The programmer can save this information to the side.
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>For stream buffers, add a function to the base class as a non-virtual function
qualified as const to 31.6.3 <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a>:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<tt>openmode mode() const</tt>;</p>

<p><b>&nbsp;&nbsp;&nbsp; Returns</b> the current open mode.</p>

<p>With streams, I'm not sure what to suggest. In principle, the mode
could already be returned by <tt>ios_base</tt>, but the mode is only
initialized for file and string stream objects, unless I'm overlooking
anything. For this reason it should be added to the most derived
stream classes. Alternatively, it could be added to <tt>basic_ios</tt>
and would be default initialized in <tt>basic_ios&lt;&gt;::init()</tt>.</p>


<p><b>Rationale:</b></p>
<p>This might be an interesting extension for some future, but it is
not a defect in the current standard. The Proposed Resolution is
retained for future reference.</p>





<hr>
<h3><a name="131" href="131">131.</a> list::splice throws nothing</h3>
<p><b>Section:</b> 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>What happens if a splice operation causes the size() of a list to grow 
beyond max_size()?</p>


<p><b>Rationale:</b></p>
<p>Size() cannot grow beyond max_size().&nbsp; </p>





<hr>
<h3><a name="135" href="135">135.</a> basic_iostream doubly initialized</h3>
<p><b>Section:</b> 31.7.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/iostream.cons">[iostream.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>-1- Effects Constructs an object of class basic_iostream, assigning
initial values to the base classes by calling
basic_istream&lt;charT,traits&gt;(sb) (lib.istream) and
basic_ostream&lt;charT,traits&gt;(sb) (lib.ostream)</p>

<p>The called for basic_istream and basic_ostream constructors call
init(sb). This means that the basic_iostream's virtual base class is
initialized twice.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.6.1.5.1, paragraph 1 to:</p>

<p>-1- Effects Constructs an object of class basic_iostream, assigning
initial values to the base classes by calling
basic_istream&lt;charT,traits&gt;(sb) (lib.istream).</p>


<p><b>Rationale:</b></p>
<p>The LWG agreed that the <tt> init()</tt> function is called
twice, but said that this is harmless and so not a defect in the
standard.</p>




<hr>
<h3><a name="138" href="138">138.</a> Class <tt>ctype_byname&lt;char&gt;</tt> redundant and misleading</h3>
<p><b>Section:</b> 30.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-03-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 30.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a> specifies that
<tt>ctype_byname&lt;char&gt;</tt> must be a specialization of the <tt>ctype_byname</tt>
template.</p>

<p>It is common practice in the standard that specializations of class templates are only
mentioned where the interface of the specialization deviates from the interface of the
template that it is a specialization of. Otherwise, the fact whether or not a required
instantiation is an actual instantiation or a specialization is left open as an
implementation detail. </p>

<p>Clause 22.2.1.4 deviates from that practice and for that reason is misleading. The
fact, that <tt>ctype_byname&lt;char&gt;</tt> is specified as a specialization suggests that there
must be something &quot;special&quot; about it, but it has the exact same interface as the
<tt>ctype_byname</tt> template. Clause 22.2.1.4 does not have any explanatory value, is at best
redundant, at worst misleading - unless I am missing anything. </p>

<p>Naturally, an implementation will most likely implement <tt>ctype_byname&lt;char&gt;</tt> as a
specialization, because the base class <tt>ctype&lt;char&gt;</tt> is a specialization with an
interface different from the <tt>ctype</tt> template, but that's an implementation detail and need
not be mentioned in the standard. </p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Reopened by Alisdair.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Moved to NAD.
</p></blockquote>



<p><b>Rationale:</b></p>
<p> The standard as written is mildly misleading, but the correct fix
is to deal with the underlying problem in the <tt>ctype_byname</tt> base class,
not in the specialization. See issue <a href="228">228</a>.</p>




<hr>
<h3><a name="140" href="140">140.</a> map&lt;Key, T&gt;::value_type does not satisfy the assignable requirement</h3>
<p><b>Section:</b> 24.4.4 <a href="https://timsong-cpp.github.io/cppwp/map">[map]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Mark Mitchell <b>Opened:</b> 1999-04-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote>
  <p>24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a><br/>
  <br/>
  expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return type
  &nbsp;&nbsp;&nbsp;&nbsp; pre/post-condition<br/>
  -------------&nbsp;&nbsp;&nbsp;&nbsp; ----------- &nbsp;&nbsp;&nbsp;&nbsp;
  -------------------<br/>
  X::value_type&nbsp;&nbsp;&nbsp; T
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  T is assignable<br/>
  <br/>
  24.4.4 <a href="https://timsong-cpp.github.io/cppwp/map">[map]</a><br/>
  <br/>
  A map satisfies all the requirements of a container.<br/>
  <br/>
  For a map&lt;Key, T&gt; ... the value_type is pair&lt;const Key, T&gt;.</p>
</blockquote>

<p>There's a contradiction here. In particular, `pair&lt;const Key,
T&gt;' is not assignable; the `const Key' cannot be assigned
to. So,&nbsp; map&lt;Key, T&gt;::value_type does not satisfy the
assignable requirement imposed by a container.</p>

<p><i>[See issue <a href="103">103</a> for the slightly related issue of
modification of set keys.]</i></p>



<p><b>Rationale:</b></p>
<p>The LWG believes that the standard is inconsistent, but that this
is a design problem rather than a strict defect. May wish to
reconsider for the next standard.</p>




<hr>
<h3><a name="143" href="143">143.</a> C .h header wording unclear</h3>
<p><b>Section:</b> 99 [depr.c.headers] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christophe de Dinechin <b>Opened:</b> 1999-05-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.c.headers">issues</a> in [depr.c.headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>[depr.c.headers] paragraph 2 reads:</p>

<blockquote>

<p>Each C header, whose name has the form name.h, behaves as if each
name placed in the Standard library namespace by the corresponding
cname header is also placed within the namespace scope of the
namespace std and is followed by an explicit using-declaration
(_namespace.udecl_)</p>

</blockquote>

<p>I think it should mention the global name space somewhere...&nbsp;
Currently, it indicates that name placed in std is also placed in
std...</p>

<p>I don't know what is the correct wording. For instance, if struct
tm is defined in time.h, ctime declares std::tm. However, the current
wording seems ambiguous regarding which of the following would occur
for use of both ctime and time.h:</p>

<blockquote>
  <pre>// version 1:
namespace std {
        struct tm { ... };
}
using std::tm;

// version 2:
struct tm { ... };
namespace std {
        using ::tm;
}

// version 3:
struct tm { ... };
namespace std {
        struct tm { ... };
}</pre>
</blockquote>

<p>I think version 1 is intended.</p>

<p><i>[Kona: The LWG agreed that the wording is not clear. It also
agreed that version 1 is intended, version 2 is not equivalent to
version 1, and version 3 is clearly not intended. The example below
was constructed by Nathan Myers to illustrate why version 2 is not
equivalent to version 1.</i></p>

<p><i>Although not equivalent, the LWG is unsure if (2) is enough of
a problem to be prohibited. Points discussed in favor of allowing
(2):</i></p>

<blockquote>
  <ul>
    <li><i>It may be a convenience to implementors.</i></li>
    <li><i>The only cases that fail are structs, of which the C library
      contains only a few.</i></li>
  </ul>
</blockquote>

<p><i>]</i></p>

<p><b>Example:</b></p>

<blockquote>

<pre>#include &lt;time.h&gt;
#include &lt;utility&gt;

int main() {
    std::tm * t;
    make_pair( t, t ); // okay with version 1 due to Koenig lookup
                       // fails with version 2; make_pair not found
    return 0;
}</pre>

</blockquote>


<p><b>Proposed resolution:</b></p>

<p>Replace 99 [depr.c.headers] paragraph 2 with:</p>

<blockquote>

<p> Each C header, whose name has the form name.h, behaves as if each
name placed in the Standard library namespace by the corresponding
cname header is also placed within the namespace scope of the
namespace std by name.h and is followed by an explicit
using-declaration (_namespace.udecl_) in global scope.</p>

</blockquote>



<p><b>Rationale:</b></p>
<p> The current wording in the standard is the result of a difficult
compromise that averted delay of the standard. Based on discussions
in Tokyo it is clear that there is no still no consensus on stricter
wording, so the issue has been closed. It is suggested that users not
write code that depends on Koenig lookup of C library functions.</p>




<hr>
<h3><a name="145" href="145">145.</a> adjustfield lacks default value</h3>
<p><b>Section:</b> 31.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-05-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>There is no initial value for the adjustfield defined, although
many people believe that the default adjustment were right. This is a
common misunderstanding. The standard only defines that, if no
adjustment is specified, all the predefined inserters must add fill
characters before the actual value, which is &quot;as if&quot; the
right flag were set. The flag itself need not be set.</p>

<p>When you implement a user-defined inserter you cannot rely on right
being the default setting for the adjustfield. Instead, you must be
prepared to find none of the flags set and must keep in mind that in
this case you should make your inserter behave &quot;as if&quot; the
right flag were set. This is surprising to many people and complicates
matters more than necessary.</p>

<p>Unless there is a good reason why the adjustfield should not be
initialized I would suggest to give it the default value that
everybody expects anyway.</p>



<p><b>Rationale:</b></p>
<p>This is not a defect. It is deliberate that the default is no bits
set. Consider Arabic or Hebrew, for example. See 30.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> paragraph 19, Table 61 - Fill padding.</p>




<hr>
<h3><a name="157" href="157">157.</a> Meaningless error handling for <tt>pword()</tt> and <tt>iword()</tt></h3>
<p><b>Section:</b> 31.5.2.6 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar K&uuml;hl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="41">41</a></p>
<p><b>Discussion:</b></p>
<p>According to paragraphs 2 and 4 of 31.5.2.6 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a>, the
functions <tt>iword()</tt> and <tt>pword()</tt> &quot;set the
<tt>badbit</tt> (which might throw an exception)&quot; on
failure. ... but what does it mean for <tt>ios_base</tt> to set the
<tt>badbit</tt>? The state facilities of the IOStream library are
defined in <tt>basic_ios</tt>, a derived class! It would be possible
to attempt a down cast but then it would be necessary to know the
character type used...</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="162" href="162">162.</a> Really &quot;formatted input functions&quot;?</h3>
<p><b>Section:</b> 31.7.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/istream.extractors">[istream.extractors]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar K&uuml;hl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2017-04-22 20:55:04 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.extractors">issues</a> in [istream.extractors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="60">60</a></p>
<p><b>Discussion:</b></p>
<p>It appears to be somewhat nonsensical to consider the functions
defined in the paragraphs 1 to 5 to be &quot;Formatted input
function&quot; but since these functions are defined in a section
labeled &quot;Formatted input functions&quot; it is unclear to me
whether these operators are considered formatted input functions which
have to conform to the &quot;common requirements&quot; from 31.7.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted.reqmts">[istream.formatted.reqmts]</a>: If this is the case, all manipulators, not just
<tt>ws</tt>, would skip whitespace unless <tt>noskipws</tt> is set
(... but setting <tt>noskipws</tt> using the manipulator syntax would
also skip whitespace :-)</p>

<p>See also issue <a href="166">166</a> for the same problem in formatted
output</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="163" href="163">163.</a> Return of <tt>gcount()</tt> after a call to <tt>gcount</tt></h3>
<p><b>Section:</b> 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar K&uuml;hl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="60">60</a></p>
<p><b>Discussion:</b></p>
<p>It is not clear which functions are to be considered unformatted
input functions. As written, it seems that all functions in 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> are unformatted input functions. However, it does not
really make much sense to construct a sentry object for
<tt>gcount()</tt>, <tt>sync()</tt>, ... Also it is unclear what
happens to the <tt>gcount()</tt> if eg. <tt>gcount()</tt>,
<tt>putback()</tt>, <tt>unget()</tt>, or <tt>sync()</tt> is called:
These functions don't extract characters, some of them even
&quot;unextract&quot; a character. Should this still be reflected in
<tt>gcount()</tt>? Of course, it could be read as if after a call to
<tt>gcount()</tt> <tt>gcount()</tt> return <tt>0</tt> (the last
unformatted input function, <tt>gcount()</tt>, didn't extract any
character) and after a call to <tt>putback()</tt> <tt>gcount()</tt>
returns <tt>-1</tt> (the last unformatted input function
<tt>putback()</tt> did &quot;extract&quot; back into the
stream). Correspondingly for <tt>unget()</tt>. Is this what is
intended?  If so, this should be clarified. Otherwise, a corresponding
clarification should be used.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="166" href="166">166.</a> Really &quot;formatted output functions&quot;?</h3>
<p><b>Section:</b> 31.7.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters">[ostream.inserters]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar K&uuml;hl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="60">60</a></p>
<p><b>Discussion:</b></p>
<p>From 31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a> it appears that all the functions
defined in 31.7.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters">[ostream.inserters]</a> have to construct a
<tt>sentry</tt> object. Is this really intended?</p> 

<p>This is basically the same problem as issue <a href="162">162</a> but
for output instead of input.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="177" href="177">177.</a> Complex operators cannot be explicitly instantiated</h3>
<p><b>Section:</b> 28.4.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1999-07-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>A user who tries to explicitly instantiate a complex non-member operator will
get compilation errors. Below is a simplified example of the reason why. The
problem is that iterator_traits cannot be instantiated on a non-pointer type
like float, yet when the compiler is trying to decide which operator+ needs to
be instantiated it must instantiate the declaration to figure out the first
argument type of a reverse_iterator operator.</p>
<pre>namespace std {
template &lt;class Iterator&gt; 
struct iterator_traits
{
    typedef typename Iterator::value_type value_type;
};

template &lt;class T&gt; class reverse_iterator;

// reverse_iterator operator+
template &lt;class T&gt; 
reverse_iterator&lt;T&gt; operator+
(typename iterator_traits&lt;T&gt;::difference_type, const reverse_iterator&lt;T&gt;&amp;);

template &lt;class T&gt; struct complex {};

// complex operator +
template &lt;class T&gt;
complex&lt;T&gt; operator+ (const T&amp; lhs, const complex&lt;T&gt;&amp; rhs) 
{ return complex&lt;T&gt;();} 
}

// request for explicit instantiation
template std::complex&lt;float&gt; std::operator+&lt;float&gt;(const float&amp;, 
     const std::complex&lt;float&gt;&amp;);</pre>
<p>See also c++-stdlib reflector messages: lib-6814, 6815, 6816.</p>


<p><b>Rationale:</b></p>
<p>Implementors can make minor changes and the example will
work. Users are not affected in any case.</p> <p>According to John
Spicer, It is possible to explicitly instantiate these operators using
different syntax: change &quot;std::operator+&lt;float&gt;&quot; to
&quot;std::operator+&quot;.</p>

<p>The proposed resolution of issue 120 is that users will not be able
to explicitly instantiate standard library templates. If that
resolution is accepted then library implementors will be the only ones
that will be affected by this problem, and they must use the indicated
syntax.</p>




<hr>
<h3><a name="178" href="178">178.</a> Should clog and cerr initially be tied to cout?</h3>
<p><b>Section:</b> 31.4.3 <a href="https://timsong-cpp.github.io/cppwp/narrow.stream.objects">[narrow.stream.objects]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1999-07-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#narrow.stream.objects">issues</a> in [narrow.stream.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 27.3.1 says &quot;After the object cerr is initialized,
cerr.flags() &amp; unitbuf is nonzero. Its state is otherwise the same as
required for ios_base::init (lib.basic.ios.cons).  It doesn't say
anything about the the state of clog.  So this means that calling
cerr.tie() and clog.tie() should return 0 (see Table 89 for
ios_base::init effects).
</p>
<p>
Neither of the popular standard library implementations
that I tried does this, they both tie cerr and clog
to &amp;cout. I would think that would be what users expect.
</p>


<p><b>Rationale:</b></p>
<p>The standard is clear as written.</p>
<p>27.3.1/5 says that &quot;After the object cerr is initialized, cerr.flags()
&amp; unitbuf is nonzero. Its state is otherwise the same as required for
ios_base::init (27.4.4.1).&quot; Table 89 in 27.4.4.1, which gives the
postconditions of basic_ios::init(), says that tie() is 0. (Other issues correct
ios_base::init to basic_ios::init().)</p>




<hr>
<h3><a name="188" href="188">188.</a> valarray helpers missing augmented assignment operators</h3>
<p><b>Section:</b> 28.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/valarray.cassign">[valarray.cassign]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 1999-08-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#valarray.cassign">issues</a> in [valarray.cassign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>26.5.2.6 defines augmented assignment operators
valarray&lt;T&gt;::op=(const T&amp;), but fails to provide
corresponding versions for the helper classes. Thus making the
following illegal:</p>
<blockquote>
<pre>#include &lt;valarray&gt;

int main()
{
std::valarray&lt;double&gt; v(3.14, 1999);

v[99] *= 2.0; // Ok

std::slice s(0, 50, 2);

v[s] *= 2.0; // ERROR
}</pre>
</blockquote>
<p>I can't understand the intent of that omission.  It makes the
valarray library less intuitive and less useful.</p>


<p><b>Rationale:</b></p>
<p>Although perhaps an unfortunate
design decision, the omission is not a defect in the current
standard.&nbsp; A future standard may wish to add the missing
operators.</p>




<hr>
<h3><a name="190" href="190">190.</a> min() and max() functions should be std::binary_functions</h3>
<p><b>Section:</b> 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Mark Rintoul <b>Opened:</b> 1999-08-26 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Both std::min and std::max are defined as template functions.  This
is very different than the definition of std::plus (and similar
structs) which are defined as function objects which inherit
std::binary_function.<br/>
<br/>
        This lack of inheritance leaves std::min and std::max somewhat useless in standard library algorithms which require
a function object that inherits std::binary_function.</p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
C++0x has lambdas to address this problem now.
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>Although perhaps an unfortunate design decision, the omission is not a defect
in the current standard.&nbsp; A future standard may wish to consider additional
function objects.</p>




<hr>
<h3><a name="191" href="191">191.</a> Unclear complexity for algorithms such as binary search</h3>
<p><b>Section:</b> 27.8.4 <a href="https://timsong-cpp.github.io/cppwp/alg.binary.search">[alg.binary.search]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1999-10-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.binary.search">issues</a> in [alg.binary.search].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The complexity of binary_search() is stated as "At most
log(last-first) + 2 comparisons", which seems to say that the
algorithm has logarithmic complexity. However, this algorithms is
defined for forward iterators. And for forward iterators, the need to
step element-by-element results into linear complexity. But such a
statement is missing in the standard. The same applies to
lower_bound(), upper_bound(), and equal_range().&nbsp;<br/>
<br/>
However, strictly speaking the standard contains no bug here. So this
might considered to be a clarification or improvement.
</p>


<p><b>Rationale:</b></p>
<p>The complexity is expressed in terms of comparisons, and that
complexity can be met even if the number of iterators accessed is
linear. Paragraph 1 already says exactly what happens to
iterators.</p>




<hr>
<h3><a name="192" href="192">192.</a> a.insert(p,t) is inefficient and overconstrained</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ed Brey <b>Opened:</b> 1999-06-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="233">233</a></p>
<p><b>Discussion:</b></p>
<p>As defined in 23.1.2, paragraph 7 (table 69), a.insert(p,t) suffers from
several problems:</p>
<table border="1" cellpadding="5">
  <tr>
    <td><b>expression</b></td>
    <td><b>return type</b></td>
    <td><b>pre/post-condition</b></td>
    <td><b>complexity</b></td>
  </tr>
  <tr>
    <td><tt>a.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t if and only if there is no element with key equivalent to the key of 
       t in containers with unique keys; always inserts t in containers with equivalent 
       keys. always returns the iterator pointing to the element with key equivalent to 
       the key of t . iterator p is a hint pointing to where the insert should start to search.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right after p .</td>
  </tr>
</table>
<p>1. For a container with unique keys, only logarithmic complexity is
guaranteed if no element is inserted, even though constant complexity is always
possible if p points to an element equivalent to t.</p>
<p>2. For a container with equivalent keys, the amortized constant complexity
guarantee is only useful if no key equivalent to t exists in the container.
Otherwise, the insertion could occur in one of multiple locations, at least one
of which would not be right after p.</p>
<p>3. By guaranteeing amortized constant complexity only when t is inserted
after p, it is impossible to guarantee constant complexity if t is inserted at
the beginning of the container. Such a problem would not exist if amortized
constant complexity was guaranteed if t is inserted before p, since there is
always some p immediately before which an insert can take place.</p>
<p>4. For a container with equivalent keys, p does not allow specification of
where to insert the element, but rather only acts as a hint for improving
performance. This negates the added functionality that p would provide if it
specified where within a sequence of equivalent keys the insertion should occur.
Specifying the insert location provides more control to the user, while
providing no disadvantage to the container implementation.</p>


<p><b>Proposed resolution:</b></p>
<p>In 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> paragraph 7, replace the row in table 69
for a.insert(p,t) with the following two rows:</p>
<table border="1" cellpadding="5">
  <tr>
    <td><b>expression</b></td>
    <td><b>return type</b></td>
    <td><b>pre/post-condition</b></td>
    <td><b>complexity</b></td>
  </tr>
  <tr>
    <td><tt>a_uniq.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t if and only if there is no element with key equivalent to the
      key of t. returns the iterator pointing to the element with key equivalent
      to the key of t.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right
      before p or p points to an element with key equivalent to t.</td>
  </tr>
  <tr>
    <td><tt>a_eq.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t and returns the iterator pointing to the newly inserted
      element. t is inserted right before p if doing so preserves the container
      ordering.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right
      before p.</td>
  </tr>
</table>



<p><b>Rationale:</b></p>
<p>Too big a change.&nbsp; Furthermore, implementors report checking
both before p and after p, and don't want to change this behavior.</p>





<hr>
<h3><a name="194" href="194">194.</a> rdbuf() functions poorly specified</h3>
<p><b>Section:</b> 31.5.4 <a href="https://timsong-cpp.github.io/cppwp/ios">[ios]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1999-09-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In classic iostreams, base class ios had an rdbuf function that returned a
pointer to the associated streambuf. Each derived class had its own rdbuf
function that returned a pointer of a type reflecting the actual type derived
from streambuf. Because in ARM C++, virtual function overrides had to have the
same return type, rdbuf could not be virtual.</p>
<p>In standard iostreams, we retain the non-virtual rdbuf function design, and
in addition have an overloaded rdbuf function that sets the buffer pointer.
There is no need for the second function to be virtual nor to be implemented in
derived classes.</p>
<p>Minor question: Was there a specific reason not to make the original rdbuf
function virtual?</p>
<p>Major problem: Friendly compilers warn about functions in derived classes
that hide base-class overloads. Any standard implementation of iostreams will
result in such a warning on each of the iostream classes, because of the
ill-considered decision to overload rdbuf only in a base class.</p>
<p>In addition, users of the second rdbuf function must use explicit
qualification or a cast to call it from derived classes. An explicit
qualification or cast to basic_ios would prevent access to any later overriding
version if there was one.</p>
<p>What I'd like to do in an implementation is add a using- declaration for the
second rdbuf function in each derived class. It would eliminate warnings about
hiding functions, and would enable access without using explicit qualification.
Such a change I don't think would change the behavior of any valid program, but
would allow invalid programs to compile:</p>
<blockquote>
  <pre> filebuf mybuf;
 fstream f;
 f.rdbuf(mybuf); // should be an error, no visible rdbuf</pre>
</blockquote>
<p>I'd like to suggest this problem as a defect, with the proposed resolution to
require the equivalent of a using-declaration for the rdbuf function that is not
replaced in a later derived class. We could discuss whether replacing the
function should be allowed.</p>


<p><b>Rationale:</b></p>
<p>For historical reasons, the standard is correct as written. There is a subtle difference between the base
class <tt> rdbuf()</tt> and derived class <tt>rdbuf()</tt>. The derived
class <tt> rdbuf()</tt> always returns the original streambuf, whereas the base class
<tt> rdbuf()</tt> will return the "current streambuf" if that has been changed by the variant you mention.</p>

<p>Permission is not required to add such an extension.  See 
16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>.</p>




<hr>
<h3><a name="196" href="196">196.</a> Placement new example has alignment problems</h3>
<p><b>Section:</b> 17.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/new.delete.placement">[new.delete.placement]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="114">114</a></p>
<p><b>Discussion:</b></p>
<p>The example in 17.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/new.delete.placement">[new.delete.placement]</a> paragraph 4 reads: </p>

<blockquote>

<p>[Example: This can be useful for constructing an object at a known address:<br/>
<br/>
<tt>&nbsp;&nbsp; char place[sizeof(Something)];<br/>
&nbsp;&nbsp; Something* p = new (place) Something();<br/>
<br/>
</tt>end example] </p>

</blockquote>

<p>This example has potential alignment problems. </p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="197" href="197">197.</a> max_size() underspecified</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 1999-10-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Must the value returned by max_size() be unchanged from call to call? </p>

<p>Must the value returned from max_size() be meaningful? </p>

<p>Possible meanings identified in lib-6827: </p>

<p>1) The largest container the implementation can support given "best
case" conditions - i.e. assume the run-time platform is "configured to
the max", and no overhead from the program itself. This may possibly
be determined at the point the library is written, but certainly no
later than compile time.<br/>
<br/>
2) The largest container the program could create, given "best case"
conditions - i.e. same platform assumptions as (1), but take into
account any overhead for executing the program itself. (or, roughly
"storage=storage-sizeof(program)"). This does NOT include any resource
allocated by the program. This may (or may not) be determinable at
compile time.<br/>
<br/>
3) The largest container the current execution of the program could
create, given knowledge of the actual run-time platform, but again,
not taking into account any currently allocated resource. This is
probably best determined at program start-up.<br/>
<br/>
4) The largest container the current execution program could create at
the point max_size() is called (or more correctly at the point
max_size() returns :-), given it's current environment (i.e. taking
into account the actual currently available resources). This,
obviously, has to be determined dynamically each time max_size() is
called. </p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>max_size() isn't useful for very many things, and the existing
  wording is sufficiently clear for the few cases that max_size() can
  be used for.  None of the attempts to change the existing wording
  were an improvement.</p>

<p>It is clear to the LWG that the value returned by max_size() can't
  change from call to call.</p>






<hr>
<h3><a name="203" href="203">203.</a> basic_istream::sentry::sentry() is uninstantiable with ctype&lt;user-defined type&gt;</h3>
<p><b>Section:</b> 31.7.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/istream.sentry">[istream.sentry]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt McClure and Dietmar K&uuml;hl <b>Opened:</b> 2000-01-01 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.sentry">issues</a> in [istream.sentry].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.6.1.1.2 Paragraph 4 states:</p>
<blockquote>
  <p>To decide if the character c is a whitespace character, the constructor
     performs ''as if'' it executes the following code fragment:&nbsp;</p>
  <pre>const ctype&lt;charT&gt;&amp; ctype = use_facet&lt;ctype&lt;charT&gt; &gt;(is.getloc());
if (ctype.is(ctype.space,c)!=0)
// c is a whitespace character.</pre>
</blockquote>

<p> But Table 51 in 22.1.1.1.1 only requires an implementation to
provide specializations for ctype&lt;char&gt; and
ctype&lt;wchar_t&gt;.  If sentry's constructor is implemented using
ctype, it will be uninstantiable for a user-defined character type
charT, unless the implementation has provided non-working (since it
would be impossible to define a correct ctype&lt;charT&gt; specialization
for an arbitrary charT) definitions of ctype's virtual member
functions.</p>

<p>
It seems the intent the standard is that sentry should behave, in
every respect, not just during execution, as if it were implemented
using ctype, with the burden of providing a ctype specialization
falling on the user.  But as it is written, nothing requires the
translation of sentry's constructor to behave as if it used the above
code, and it would seem therefore, that sentry's constructor should be
instantiable for all character types.
</p>

<p>
Note: If I have misinterpreted the intent of the standard with
respect to sentry's constructor's instantiability, then a note should
be added to the following effect:
</p>

<blockquote><p>
An implementation is forbidden from using the above code if it renders
the constructor uninstantiable for an otherwise valid character
type.
</p></blockquote>

<p>In any event, some clarification is needed.</p>



<p><b>Rationale:</b></p>
<p>It is possible but not easy to instantiate on types other than char
or wchar_t; many things have to be done first. That is by intention
and is not a defect.</p>




<hr>
<h3><a name="204" href="204">204.</a> distance(first, last) when &quot;last&quot; is before &quot;first&quot;</h3>
<p><b>Section:</b> 25.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Rintala Matti <b>Opened:</b> 2000-01-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 24.3.4 describes the function distance(first, last) (where first and
last are iterators) which calculates &quot;the number of increments or
decrements needed to get from 'first' to 'last'&quot;.</p>
<p>The function should work for forward, bidirectional and random access
iterators, and there is a requirement 24.3.4.5 which states that &quot;'last'
must be reachable from 'first'&quot;.</p>
<p>With random access iterators the function is easy to implement as &quot;last
- first&quot;.</p>
<p>With forward iterators it's clear that 'first' must point to a place before
'last', because otherwise 'last' would not be reachable from 'first'.</p>
<p>But what about bidirectional iterators? There 'last' is reachable from
'first' with the -- operator even if 'last' points to an earlier position than
'first'. However, I cannot see how the distance() function could be implemented
if the implementation does not know which of the iterators points to an earlier
position (you cannot use ++ or -- on either iterator if you don't know which
direction is the &quot;safe way to travel&quot;).</p>
<p>The paragraph 24.3.4.1 states that &quot;for ... bidirectional iterators they
use ++ to provide linear time implementations&quot;. However, the ++ operator is
not mentioned in the reachability requirement. Furthermore 24.3.4.4 explicitly
mentions that distance() returns the number of increments _or decrements_,
suggesting that it could return a negative number also for bidirectional
iterators when 'last' points to a position before 'first'.</p>
<p>Is a further requirement is needed to state that for forward and
bidirectional iterators &quot;'last' must be reachable from 'first' using the ++
operator&quot;. Maybe this requirement might also apply to random access
iterators so that distance() would work the same way for every iterator
category?</p>


<p><b>Rationale:</b></p>
<p>&quot;Reachable&quot; is defined in the standard in 25.3.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concepts">[iterator.concepts]</a> paragraph 6.
The definition is only in terms of operator++(). The LWG sees no defect in
the standard.</p>




<hr>
<h3><a name="205" href="205">205.</a>  numeric_limits unclear on how to determine floating point types</h3>
<p><b>Section:</b> 17.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.members">[numeric.limits.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Cleary <b>Opened:</b> 2000-01-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In several places in 17.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.members">[numeric.limits.members]</a>, a member is
described as &quot;Meaningful for all floating point types.&quot;
However, no clear method of determining a floating point type is
provided.</p>

<p>In 17.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/numeric.special">[numeric.special]</a>, paragraph 1 states &quot;. . . (for
example, epsilon() is only meaningful if is_integer is
false). . .&quot; which suggests that a type is a floating point type
if is_specialized is true and is_integer is false; however, this is
unclear.</p>

<p>When clarifying this, please keep in mind this need of users: what
exactly is the definition of floating point? Would a fixed point or
rational representation be considered one? I guess my statement here
is that there could also be types that are neither integer or
(strictly) floating point.</p>


<p><b>Rationale:</b></p>
<p>It is up to the implementor of a user define type to decide if it is a
floating point type.</p>




<hr>
<h3><a name="207" href="207">207.</a> ctype&lt;char&gt; members return clause incomplete</h3>
<p><b>Section:</b> 30.4.2.4.3 <a href="https://timsong-cpp.github.io/cppwp/facet.ctype.char.members">[facet.ctype.char.members]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 1999-11-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.ctype.char.members">issues</a> in [facet.ctype.char.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="153">153</a></p>
<p><b>Discussion:</b></p>
<p>
The <tt>widen</tt> and <tt>narrow</tt> member functions are described
in 22.2.1.3.2, paragraphs 9-11.  In each case we have two overloaded
signatures followed by a <b>Returns</b> clause.  The <b>Returns</b>
clause only describes one of the overloads.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the returns clause in 30.4.2.4.3 <a href="https://timsong-cpp.github.io/cppwp/facet.ctype.char.members">[facet.ctype.char.members]</a>
paragraph 10 from:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(low, high, to).</p>

<p>to:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(c) or do_widen(low, high, to), 
respectively.</p>

<p>Change the returns clause in 30.4.2.4.3 <a href="https://timsong-cpp.github.io/cppwp/facet.ctype.char.members">[facet.ctype.char.members]</a> paragraph 11
from:</p> 
<p>&nbsp;&nbsp;&nbsp; Returns: do_narrow(low, high, to).</p>

<p>to:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_narrow(c) or do_narrow(low, high, to), 
respectively.</p>


<p><b>Rationale:</b></p>
<p>Subsumed by issue <a href="153">153</a>, which addresses the same
paragraphs.</p>






<hr>
<h3><a name="213" href="213">213.</a> Math function overloads ambiguous</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 2000-02-26 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Due to the additional overloaded versions of numeric functions for
float and long double according to Section 26.5, calls such as int x;
std::pow (x, 4) are ambiguous now in a standard conforming
implementation. Current implementations solve this problem very
different (overload for all types, don't overload for float and long
double, use preprocessor, follow the standard and get
ambiguities).</p> <p>This behavior should be standardized or at least
identified as implementation defined.</p>


<p><b>Rationale:</b></p>
<p>These math issues are an
understood and accepted consequence of the design. They have
been discussed several times in the past. Users must write casts
or write floating point expressions as arguments.</p>




<hr>
<h3><a name="215" href="215">215.</a> Can a map's key_type be const?</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-02-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>A user noticed that this doesn't compile with the Rogue Wave library because
the rb_tree class declares a key_allocator, and allocator&lt;const int&gt; is
not legal, I think:</p>
<blockquote>
  <pre>map &lt; const int, ... &gt; // legal?</pre>
</blockquote>
<p>which made me wonder whether it is legal for a map's key_type to be const. In
email from Matt Austern he said:</p>
<blockquote>
<p>I'm not sure whether it's legal to declare a map with a const key type. I
hadn't thought about that question until a couple weeks ago. My intuitive
feeling is that it ought not to be allowed, and that the standard ought to say
so. It does turn out to work in SGI's library, though, and someone in the
compiler group even used it. Perhaps this deserves to be written up as an issue
too.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The &quot;key is assignable&quot; requirement from table 69 in
24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> already implies the key cannot be const.</p>




<hr>
<h3><a name="216" href="216">216.</a> setbase manipulator description flawed</h3>
<p><b>Section:</b> 31.7.7 <a href="https://timsong-cpp.github.io/cppwp/std.manip">[std.manip]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Hyman Rosen <b>Opened:</b> 2000-02-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#std.manip">issues</a> in [std.manip].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="193">193</a></p>
<p><b>Discussion:</b></p>
<p>31.7.7 <a href="https://timsong-cpp.github.io/cppwp/std.manip">[std.manip]</a> paragraph 5 says:</p>
<blockquote>
<pre>smanip setbase(int base);</pre>
<p> Returns: An object s of unspecified type such that if out is an
(instance of) basic_ostream then the expression out&lt;&lt;s behaves
as if f(s) were called, in is an (instance of) basic_istream then the
expression in&gt;&gt;s behaves as if f(s) were called. Where f can be
defined as:</p>
<pre>ios_base&amp; f(ios_base&amp; str, int base)
{
  // set basefield
  str.setf(n == 8 ? ios_base::oct :
                n == 10 ? ios_base::dec :
                n == 16 ? ios_base::hex :
                  ios_base::fmtflags(0), ios_base::basefield);
  return str;
}</pre>
</blockquote>
<p>There are two problems here. First, f takes two parameters, so the
description needs to say that out&lt;&lt;s and in&gt;&gt;s behave as if f(s,base)
had been called. Second, f is has a parameter named base, but is written as if
the parameter was named n.</p>
<p>Actually, there's a third problem. The paragraph has grammatical errors.
There needs to be an &quot;and&quot; after the first comma, and the &quot;Where
f&quot; sentence fragment needs to be merged into its preceding sentence. You
may also want to format the function a little better. The formatting above is
more-or-less what the Standard contains.</p>


<p><b>Rationale:</b></p>
<p>The resolution of this defect is subsumed by the proposed resolution for
issue <a href="193">193</a>.</p>

<p><i>[Tokyo: The LWG agrees that this is a defect and notes that it
occurs additional places in the section, all requiring fixes.]</i></p>








<hr>
<h3><a name="218" href="218">218.</a> Algorithms do not use binary predicate objects for default comparisons</h3>
<p><b>Section:</b> 27.8 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2000-03-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Many of the algorithms take an argument, pred, of template parameter type
BinaryPredicate or an argument comp of template parameter type Compare. These
algorithms usually have an overloaded version that does not take the predicate
argument. In these cases pred is usually replaced by the use of operator== and
comp is replaced by the use of operator&lt;.</p>
<p>This use of hard-coded operators is inconsistent with other parts of the
library, particularly the containers library, where equality is established
using equal_to&lt;&gt; and ordering is established using less&lt;&gt;. Worse,
the use of operator&lt;, would cause the following innocent-looking code to have
undefined behavior:</p>
<blockquote>
  <pre>vector&lt;string*&gt; vec;
sort(vec.begin(), vec.end());</pre>
</blockquote>
<p>The use of operator&lt; is not defined for pointers to unrelated objects. If
std::sort used less&lt;&gt; to compare elements, then the above code would be
well-defined, since less&lt;&gt; is explicitly specialized to produce a total
ordering of pointers.</p>


<p><b>Rationale:</b></p>
<p>This use of operator== and operator&lt; was a very deliberate, conscious, and
explicitly made design decision; these operators are often more efficient. The
predicate forms are available for users who don't want to rely on operator== and
operator&lt;.</p>




<hr>
<h3><a name="219" href="219">219.</a> <tt>find</tt> algorithm missing version that takes a binary predicate argument</h3>
<p><b>Section:</b> 27.6.6 <a href="https://timsong-cpp.github.io/cppwp/alg.find">[alg.find]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2000-03-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.find">issues</a> in [alg.find].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The find function always searches for a value using <tt>operator==</tt> to compare the
value argument to each element in the input iterator range. This is inconsistent
with other find-related functions such as <tt>find_end</tt> and <tt>find_first_of</tt>, which
allow the caller to specify a binary predicate object to be used for determining
equality. The fact that this can be accomplished using a combination of <tt>find_if</tt>
and <tt>bind_1st</tt> or <tt>bind_2nd</tt> does not negate the desirability of a consistent,
simple, alternative interface to <tt>find</tt>.</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Reopened by Alisdair.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The same thing can be achieved using <tt>find_if</tt> (as noted in the issue).
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<blockquote>
<p>In section 27.6.6 <a href="https://timsong-cpp.github.io/cppwp/alg.find">[alg.find]</a>, add a second prototype for find
(between the existing prototype and the prototype for find_if), as
follows:</p>
<pre>    template&lt;class InputIterator, class T, class BinaryPredicate&gt;
      InputIterator find(InputIterator first, InputIterator last,
                         const T&amp; value, BinaryPredicate bin_pred);</pre>
<p>Change the description of the return from:</p>
<blockquote>
  <p>Returns: The first iterator <tt>i</tt> in the range <tt>[first, last)</tt> for which the following corresponding
  conditions hold: <tt>*i == value</tt>, <tt>pred(*i) != false</tt>. Returns <tt>last</tt> if no such iterator is found.</p>
</blockquote>
<p>&nbsp;to:</p>
<blockquote>
  <p>Returns: The first iterator <tt>i</tt> in the range <tt>[first, last)</tt> for which the following&nbsp;
  corresponding condition holds: <tt>*i == value</tt>, <tt>bin_pred(*i,value) != false</tt>, <tt>pred(*)
  != false</tt>. Return <tt>last</tt> if no such iterator is found.</p>
</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
<p>This is request for a pure extension, so it is not a defect in the
current standard.&nbsp; As the submitter pointed out, &quot;this can
be accomplished using a combination of <tt>find_if</tt> and <tt>bind_1st</tt> or
<tt>bind_2nd</tt>&quot;.</p>




<hr>
<h3><a name="236" href="236">236.</a> ctype&lt;char&gt;::is() member modifies facet</h3>
<p><b>Section:</b> 30.4.2.4.3 <a href="https://timsong-cpp.github.io/cppwp/facet.ctype.char.members">[facet.ctype.char.members]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar K&uuml;hl <b>Opened:</b> 2000-04-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.ctype.char.members">issues</a> in [facet.ctype.char.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="28">28</a></p>
<p><b>Discussion:</b></p>
<p>The description of the <tt>is()</tt> member in paragraph 4 of 30.4.2.4.3 <a href="https://timsong-cpp.github.io/cppwp/facet.ctype.char.members">[facet.ctype.char.members]</a> is broken: According to this description, the
second form of the <tt>is()</tt> method modifies the masks in the
<tt>ctype</tt> object. The correct semantics if, of course, to obtain
an array of masks. The corresponding method in the general case,
ie. the <tt>do_is()</tt> method as described in 30.4.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.ctype.virtuals">[locale.ctype.virtuals]</a> paragraph 1 does the right thing.</p>


<p><b>Proposed resolution:</b></p>
  <p>Change paragraph 4 from</p>
    <blockquote><p>
    The second form, for all *p in the range [low, high), assigns
    vec[p-low] to table()[(unsigned char)*p].
    </p></blockquote>
  <p>to become</p>
    <blockquote><p>
    The second form, for all *p in the range [low, high), assigns
    table()[(unsigned char)*p] to vec[p-low].
  </p></blockquote>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="244" href="244">244.</a> Must <tt>find</tt>'s third argument be CopyConstructible?</h3>
<p><b>Section:</b> 27.6.6 <a href="https://timsong-cpp.github.io/cppwp/alg.find">[alg.find]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2000-05-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.find">issues</a> in [alg.find].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Is the following implementation of <tt>find</tt> acceptable?</p>

<pre>
        template&lt;class Iter, class X&gt;
        Iter find(Iter begin, Iter end, const X&amp; x)
        {
            X x1 = x;           // this is the crucial statement
            while (begin != end &amp;&amp; *begin != x1)
                ++begin;
            return begin;
        }
</pre>

<p>If the answer is yes, then it is implementation-dependent as to
whether the following fragment is well formed:</p>

<pre>
        vector&lt;string&gt; v;

        find(v.begin(), v.end(), &quot;foo&quot;);
</pre>

<p>At issue is whether there is a requirement that the third argument
of find be CopyConstructible.  There may be no problem here, but
analysis is necessary.</p>


<p><b>Rationale:</b></p>
<p>There is no indication in the standard that find's third argument
is required to be Copy Constructible.  The LWG believes that no such
requirement was intended.  As noted above, there are times when a user
might reasonably pass an argument that is not Copy Constructible.</p>




<hr>
<h3><a name="245" href="245">245.</a> Which operations on <tt>istream_iterator</tt> trigger input operations?</h3>
<p><b>Section:</b> 25.6.2 <a href="https://timsong-cpp.github.io/cppwp/istream.iterator">[istream.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2000-05-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I do not think the standard specifies what operation(s) on istream
iterators trigger input operations.  So, for example:</p>

<pre>
        istream_iterator&lt;int&gt; i(cin);

        int n = *i++;
</pre>

<p>I do not think it is specified how many integers have been read
from cin.  The number must be at least 1, of course, but can it be 2?
More?</p>


<p><b>Rationale:</b></p>
<p>The standard is clear as written: the stream is read every time
operator++ is called, and it is also read either when the iterator is
constructed or when operator* is called for the first time.  In the
example above, exactly two integers are read from cin.</p>

<p>There may be a problem with the interaction between istream_iterator
and some STL algorithms, such as find.  There are no guarantees about
how many times find may invoke operator++.</p>




<hr>
<h3><a name="246" href="246">246.</a> <tt>a.insert(p,t)</tt> is incorrectly specified</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Mark Rodgers <b>Opened:</b> 2000-05-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="233">233</a></p>
<p><b>Discussion:</b></p>
<p>Closed issue 192 raised several problems with the specification of
this function, but was rejected as Not A Defect because it was too big
a change with unacceptable impacts on existing implementations.
However, issues remain that could be addressed with a smaller change
and with little or no consequent impact.</p>

<ol>
   <li><p> The specification is inconsistent with the original
   proposal and with several implementations.</p>

   <p>The initial implementation by Hewlett Packard only ever looked
   immediately <i>before</i> p, and I do not believe there was any
   intention to standardize anything other than this behavior.
   Consequently, current implementations by several leading
   implementors also look immediately before p, and will only insert
   after p in logarithmic time.  I am only aware of one implementation
   that does actually look after p, and it looks before p as well.  It
   is therefore doubtful that existing code would be relying on the
   behavior defined in the standard, and it would seem that fixing
   this defect as proposed below would standardize existing
   practice.</p></li>

   <li><p>
   The specification is inconsistent with insertion for sequence
   containers.</p>

   <p>This is difficult and confusing to teach to newcomers.  All
   insert operations that specify an iterator as an insertion location
   should have a consistent meaning for the location represented by
   that iterator.</p></li>

   <li><p> As specified, there is no way to hint that the insertion
   should occur at the beginning of the container, and the way to hint
   that it should occur at the end is long winded and unnatural.</p>

   <p>For a container containing n elements, there are n+1 possible
   insertion locations and n+1 valid iterators.  For there to be a
   one-to-one mapping between iterators and insertion locations, the
   iterator must represent an insertion location immediately before
   the iterator.</p></li>

   <li><p> When appending sorted ranges using insert_iterators,
   insertions are guaranteed to be sub-optimal.</p>

   <p>In such a situation, the optimum location for insertion is
   always immediately after the element previously inserted.  The
   mechanics of the insert iterator guarantee that it will try and
   insert after the element after that, which will never be correct.
   However, if the container first tried to insert before the hint,
   all insertions would be performed in amortized constant
   time.</p></li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>In 23.1.2 [lib.associative.reqmts] paragraph 7, table 69, make
the following changes in the row for a.insert(p,t):</p>

<p><i>assertion/note pre/post condition:</i>
<br/>Change the last sentence from</p>
     <blockquote><p>
     &quot;iterator p is a hint pointing to where the insert should
     start to search.&quot;
     </p></blockquote>
<p>to</p>
     <blockquote><p>
     &quot;iterator p is a hint indicating that immediately before p
     may be a correct location where the insertion could occur.&quot;
     </p></blockquote>

<p><i>complexity:</i><br/>
Change the words "right after" to "immediately before".</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="249" href="249">249.</a> Return Type of <tt>auto_ptr::operator=</tt></h3>
<p><b>Section:</b> 99 [auto.ptr] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joseph Gottman <b>Opened:</b> 2000-06-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to section 20.4.5, the function
<tt>auto_ptr::operator=()</tt> returns a reference to an auto_ptr.
The reason that <tt>operator=()</tt> usually returns a reference is to
facilitate code like</p>

<pre>
    int x,y,z;
    x = y = z = 1;
</pre>

<p>However, given analogous code for <tt>auto_ptr</tt>s,</p>
<pre>
    auto_ptr&lt;int&gt; x, y, z;
    z.reset(new int(1));
    x = y = z;
</pre>

<p>the result would be that <tt>z</tt> and <tt>y</tt> would both be set to 
NULL, instead of all the <tt>auto_ptr</tt>s being set to the same value. 
This makes such cascading assignments useless and counterintuitive for 
<tt>auto_ptr</tt>s.</p>


<p><b>Proposed resolution:</b></p>
<p>Change <tt>auto_ptr::operator=()</tt> to return <tt>void</tt> instead
of an <tt>auto_ptr</tt> reference.</p>


<p><b>Rationale:</b></p>
<p>The return value has uses other than cascaded assignments: a user can
call an auto_ptr member function, pass the auto_ptr to a
function, etc.  Removing the return value could break working user
code.</p>




<hr>
<h3><a name="255" href="255">255.</a> Why do <tt>basic_streambuf&lt;&gt;::pbump()</tt> and <tt>gbump()</tt> take an int?</h3>
<p><b>Section:</b> 31.6.3 <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-12 <b>Last modified:</b> 2017-06-06 14:03:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_streambuf members gbump() and pbump() are specified to take an
int argument. This requirement prevents the functions from effectively
manipulating buffers larger than std::numeric_limits&lt;int&gt;::max()
characters. It also makes the common use case for these functions
somewhat difficult as many compilers will issue a warning when an
argument of type larger than int (such as ptrdiff_t on LLP64
architectures) is passed to either of the function. Since it's often the
result of the subtraction of two pointers that is passed to the
functions, a cast is necessary to silence such warnings. Finally, the
usage of a native type in the functions signatures is inconsistent with
other member functions (such as sgetn() and sputn()) that manipulate the
underlying character buffer. Those functions take a streamsize argument.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is part of a bigger problem. If anyone cares enough, they should
write a paper solving the bigger problem of offset types in iostreams.
</p>
<p>
This is related to the paper about large file sizes. Beman has already
agreed to drop the section of that paper that deals with this.
</p>
<p>
int is big enough for reasonable buffers.
</p>
<p>
Move to NAD Future.
</p>
<p>
This is related to LWG <a href="423">423</a>.
</p>
</blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>


<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Resolve as NAD</p>
<p>The previous rationale given suggested that LWG believes the change
is too big for now. Actually, changing the parameter type is too big
a change more or less forever, because that would break every
custom streambuf type; there are too many such types in the wild
to make a breaking change. The overload approach may be more plausible,
but is not an entirely breakage-free solution; it can produce
ambiguities, and can still break streambuf hierarchies.</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the signatures of these functions in the synopsis of template
class basic_streambuf (27.5.2) and in their descriptions (27.5.2.3.1, p4
and 27.5.2.3.2, p4) to take a streamsize argument.
</p>

<p>
Although this change has the potential of changing the ABI of the
library, the change will affect only platforms where int is different
than the definition of streamsize. However, since both functions are
typically inline (they are on all known implementations), even on such
platforms the change will not affect any user code unless it explicitly
relies on the existing type of the functions (e.g., by taking their
address). Such a possibility is IMO quite remote.
</p>

<p>
Alternate Suggestion from Howard Hinnant, c++std-lib-7780:
</p>

<p>
This is something of a nit, but I'm wondering if streamoff wouldn't be a 
better choice than streamsize.  The argument to pbump and gbump MUST be 
signed.  But the standard has this to say about streamsize 
(27.4.1/2/Footnote):
</p>

<blockquote><p>
     [Footnote: streamsize is used in most places where ISO C would use
     size_t.  Most of the uses of streamsize could use size_t, except for
     the strstreambuf constructors, which require negative values. It
     should probably be the signed type corresponding to size_t (which is
     what Posix.2 calls ssize_t). &mdash; end footnote]
</p></blockquote>

<p>
This seems a little weak for the argument to pbump and gbump.  Should we 
ever really get rid of strstream, this footnote might go with it, along 
with the reason to make streamsize signed.
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this change is too big for now.  We may wish to
reconsider this for a future revision of the standard.  One
possibility is overloading pbump, rather than changing the
signature.</p>
<p><i>[
[2006-05-04: Reopened at the request of Chris (Krzysztof &#379;elechowski)]
]</i></p>





<hr>
<h3><a name="257" href="257">257.</a> STL functional object and iterator inheritance.</h3>
<p><b>Section:</b> 99 [depr.base], 99 [iterator.basic] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Robert Dick  <b>Opened:</b> 2000-08-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.base">issues</a> in [depr.base].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the November 1997 Draft Standard, the results of deleting an
object of a derived class through a pointer to an object of its base class are
undefined if the base class has a non-virtual destructor.  Therefore, it is
potentially dangerous to publicly inherit from such base classes.
</p>

<p>Defect:
<br/>
The STL design encourages users to publicly inherit from a number of classes
which do nothing but specify interfaces, and which contain non-virtual
destructors.
</p>

<p>Attribution:
<br/>
Wil Evers and William E. Kempf suggested this modification for functional
objects.
</p>


<p><b>Proposed resolution:</b></p>
<p>
When a base class in the standard library is useful only as an interface
specifier, i.e., when an object of the class will never be directly
instantiated, specify that the class contains a protected destructor.  This
will prevent deletion through a pointer to the base class without performance,
or space penalties (on any implementation I'm aware of).
</p>

<p>
As an example, replace...
</p>

<pre>
    template &lt;class Arg, class Result&gt;
    struct unary_function {
            typedef Arg    argument_type;
            typedef Result result_type;
    };
</pre>

<p>
... with...
</p>

<pre>
    template &lt;class Arg, class Result&gt;
    struct unary_function {
            typedef Arg    argument_type;
            typedef Result result_type;
    protected:
            ~unary_function() {}
    };
</pre>

<p>
Affected definitions:
<br/>
  &nbsp;20.3.1 [lib.function.objects] -- unary_function, binary_function
  <br/>
  &nbsp;24.3.2 [lib.iterator.basic] -- iterator
</p>


<p><b>Rationale:</b></p>
<p>
The standard is clear as written; this is a request for change, not a
defect in the strict sense.  The LWG had several different objections
to the proposed change.  One is that it would prevent users from
creating objects of type <tt>unary_function</tt> and
<tt>binary_function</tt>.  Doing so can sometimes be legitimate, if users
want to pass temporaries as traits or tag types in generic code.
</p>





<hr>
<h3><a name="267" href="267">267.</a> interaction of strstreambuf::overflow() and seekoff()</h3>
<p><b>Section:</b> D.12.2.4 <a href="https://timsong-cpp.github.io/cppwp/depr.strstreambuf.virtuals">[depr.strstreambuf.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-10-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.strstreambuf.virtuals">issues</a> in [depr.strstreambuf.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It appears that the interaction of the strstreambuf members overflow()
and seekoff() can lead to undefined behavior in cases where defined
behavior could reasonably be expected. The following program
demonstrates this behavior:
</p>

<pre>
    #include &lt;strstream&gt;

    int main ()
    {
         std::strstreambuf sb;
         sb.sputc ('c');

         sb.pubseekoff (-1, std::ios::end, std::ios::in);
         return !('c' == sb.sgetc ());
    }
</pre>

<p>
D.7.1.1, p1 initializes strstreambuf with a call to basic_streambuf&lt;&gt;(),
which in turn sets all pointers to 0 in 27.5.2.1, p1.
</p>
 
<p>
27.5.2.2.5, p1 says that basic_streambuf&lt;&gt;::sputc(c) calls
overflow(traits::to_int_type(c)) if a write position isn't available (it
isn't due to the above).
</p>

<p>
D.7.1.3, p3 says that strstreambuf::overflow(off, ..., ios::in) makes at
least one write position available (i.e., it allows the function to make
any positive number of write positions available).
</p>

<p>
D.7.1.3, p13 computes newoff = seekhigh - eback(). In D.7.1, p4 we see
seekhigh = epptr() ? epptr() : egptr(), or seekhigh = epptr() in this
case. newoff is then epptr() - eback().
</p>

<p>
D.7.1.4, p14 sets gptr() so that gptr() == eback() + newoff + off, or
gptr() == epptr() + off holds.
</p>

<p>
If strstreambuf::overflow() made exactly one write position available
then gptr() will be set to just before epptr(), and the program will
return 0. Buf if the function made more than one write position
available, epptr() and gptr() will both point past pptr() and the
behavior of the program is undefined.
</p>


<p><b>Proposed resolution:</b></p>


   <p>Change the last sentence of D.12.2 <a href="https://timsong-cpp.github.io/cppwp/depr.strstreambuf">[depr.strstreambuf]</a> paragraph 4 from</p>

      <blockquote><p>
      Otherwise, seeklow equals gbeg and seekhigh is either pend, if
      pend is not a null pointer, or gend.
      </p></blockquote>

   <p>to become</p>

      <blockquote><p>
      Otherwise, seeklow equals gbeg and seekhigh is either gend if
      0 == pptr(), or pbase() + max where max is the maximum value of
      pptr() - pbase() ever reached for this stream.
      </p></blockquote>

<p><i>[
  pre-Copenhagen: Dietmar provided wording for proposed resolution.
]</i></p>


<p><i>[
  post-Copenhagen: Fixed a typo: proposed resolution said to fix
  4.7.1, not D.7.1.
]</i></p>




<p><b>Rationale:</b></p>
<p>This is related to issue <a href="65">65</a>: it's not clear what it
means to seek beyond the current area.  Without resolving issue <a href="65">65</a> we can't resolve this.  As with issue <a href="65">65</a>, 
the library working group does not wish to invest time nailing down
corner cases in a deprecated feature.</p>





<hr>
<h3><a name="269" href="269">269.</a> cstdarg and unnamed parameters</h3>
<p><b>Section:</b> 17.10 <a href="https://timsong-cpp.github.io/cppwp/support.exception">[support.exception]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> J. Stephen Adamczyk <b>Opened:</b> 2000-10-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.exception">issues</a> in [support.exception].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One of our customers asks whether this is valid C++:
</p>

<pre>
   #include &lt;cstdarg&gt;

   void bar(const char *, va_list);

   void
   foo(const char *file, const char *, ...)
   {
     va_list ap;
     va_start(ap, file);
     bar(file, ap);
     va_end(ap);
   }
</pre>

<p>
The issue being whether it is valid to use cstdarg when the final
parameter before the &quot;...&quot; is unnamed.  cstdarg is, as far
as I can tell, inherited verbatim from the C standard. and the
definition there (7.8.1.1 in the ISO C89 standard) refers to &quot;the
identifier of the rightmost parameter&quot;.  What happens when there
is no such identifier?
</p>

<p>
My personal opinion is that this should be allowed, but some tweak
might be required in the C++ standard.
</p>


<p><b>Rationale:</b></p>
<p>
Not a defect, the C and C++ standards are clear.  It is impossible to
use varargs if the parameter immediately before &quot;...&quot; has no
name, because that is the parameter that must be passed to va_start.
The example given above is broken, because va_start is being passed
the wrong parameter.
</p>

<p>
There is no support for extending varargs to provide additional
functionality beyond what's currently there.  For reasons of C/C++
compatibility, it is especially important not to make gratuitous
changes in this part of the C++ standard.  The C committee has already
been requested not to touch this part of the C standard unless
necessary.
</p>




<hr>
<h3><a name="277" href="277">277.</a> Normative encouragement in allocator requirements unclear</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2000-11-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.1.5, paragraph 5, the standard says that &quot;Implementors are
encouraged to supply libraries that can accept allocators that
encapsulate more general memory models and that support non-equal
instances.&quot; This is intended as normative encouragement to
standard library implementors.  However, it is possible to interpret
this sentence as applying to nonstandard third-party libraries.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.1.5, paragraph 5, change &quot;Implementors&quot; to
&quot;Implementors of the library described in this International
Standard&quot;.
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes the normative encouragement is already
sufficiently clear, and that there are no important consequences
even if it is misunderstood.</p>





<hr>
<h3><a name="279" href="279">279.</a> const and non-const iterators should have equivalent typedefs</h3>
<p><b>Section:</b> 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Cleary <b>Opened:</b> 2000-11-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This came from an email from Steve Cleary to Fergus in reference to
issue <a href="179">179</a>. The library working group briefly discussed
this in Toronto and believes it should be a separate issue.
</p>

<p>
Steve said: &quot;We may want to state that the const/non-const iterators must have
the same difference type, size_type, and category.&quot;
</p>

<p>
(Comment from Judy)
I'm not sure if the above sentence should be true for all
const and non-const iterators in a particular container, or if it means 
the container's iterator can't be compared with the container's
const_iterator unless the above it true. I suspect the former.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In <b>Section:</b> 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>,
table 65, in the assertion/note pre/post condition for X::const_iterator,
add the following:
</p>

<blockquote>
<p>
typeid(X::const_iterator::difference_type) == typeid(X::iterator::difference_type)
</p>

<p>
typeid(X::const_iterator::size_type) == typeid(X::iterator::size_type)
</p>

<p>
typeid(X::const_iterator::category) == typeid(X::iterator::category)
</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Going through the types one by one: Iterators don't have a
<tt>size_type</tt>.  We already know that the difference types are
identical, because the container requirements already say that the
difference types of both X::iterator and X::const_iterator are both
X::difference_type.  The standard does not require that X::iterator
and X::const_iterator have the same iterator category, but the LWG
does not see this as a defect: it's possible to imagine cases in which
it would be useful for the categories to be different.</p>

<p>It may be desirable to require X::iterator and X::const_iterator to
have the same value type, but that is a new issue. (Issue <a href="322">322</a>.)</p>






<hr>
<h3><a name="287" href="287">287.</a> conflicting ios_base fmtflags</h3>
<p><b>Section:</b> 31.5.2.3 <a href="https://timsong-cpp.github.io/cppwp/fmtflags.state">[fmtflags.state]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-12-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#fmtflags.state">issues</a> in [fmtflags.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Effects clause for ios_base::setf(fmtflags fmtfl) says
&quot;Sets fmtfl in flags()&quot;.  What happens if the user first calls
ios_base::scientific and then calls ios_base::fixed or vice-versa?
This is an issue for all of the conflicting flags, i.e. ios_base::left
and ios_base::right or ios_base::dec, ios_base::hex and ios_base::oct.
</p>

<p>
I see three possible solutions: 
</p>

<ol>
<li>Set ios_base::failbit whenever the user specifies a conflicting
flag with one previously explicitly set. If the constructor is
supposed to set ios_base::dec (see discussion below), then
the user setting hex or oct format after construction will not
set failbit. </li>
<li>The last call to setf &quot;wins&quot;, i.e. it clears any conflicting
previous setting.</li>
<li>All the flags that the user specifies are set, but when actually 
interpreting them, fixed always override scientific, right always 
overrides left, dec overrides hex which overrides oct.</li>
</ol>

<p>
Most existing implementations that I tried seem to conform to resolution #3,
except that when using the iomanip manipulator hex or oct then that always 
overrides dec, but calling setf(ios_base::hex) doesn't. 
</p>

<p>
There is a sort of related issue, which is that although the ios_base
constructor says that each ios_base member has an indeterminate value
after construction, all the existing implementations I tried explicitly set 
ios_base::dec.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
<tt>adjustfield</tt>, <tt>basefield</tt>, and <tt>floatfield</tt>
are each multi-bit fields.  It is possible to set multiple bits within
each of those fields.  (For example, <tt>dec</tt> and
<tt>oct</tt>). These fields are used by locale facets.  The LWG
reviewed the way in which each of those three fields is used, and
believes that in each case the behavior is well defined for any
possible combination of bits.  See for example Table 58, in 30.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>, noting the requirement in paragraph 6 of that
section.
</p>
<p>
Users are advised to use manipulators, or else use the two-argument
version of <tt>setf</tt>, to avoid unexpected behavior.
</p>





<hr>
<h3><a name="289" href="289">289.</a> &lt;cmath&gt; requirements missing C float and long double versions</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-12-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
    In ISO/IEC 9899:1990 Programming Languages C we find the following
    concerning &lt;math.h&gt;:
</p>

<blockquote><p>
         7.13.4 Mathematics &lt;math.h&gt;
         <br/>
         The names of all existing functions declared in the &lt;math.h&gt;
         header, suffixed with f or l, are reserved respectively for
         corresponding functions with float and long double arguments
         are return values.
</p></blockquote>

<p>
    For example, <tt>float&nbsp;sinf(float)</tt>
    is reserved.
</p>

<p>
    In the C99 standard, &lt;math.h&gt; must contain declarations
    for these functions.
</p>

<p>
So, is it acceptable for an implementor to add these prototypes to the
C++ versions of the math headers? Are they required?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add these Functions to Table 80, section 26.5 and to Table 99,
section C.2:
</p>

<pre>
    acosf asinf atanf atan2f ceilf cosf coshf 
    expf fabsf floorf fmodf frexpf ldexpf 
    logf log10f modff powf sinf sinhf sqrtf 
    tanf tanhf 
    acosl asinl atanl atan2l ceill cosl coshl 
    expl fabsl floorl fmodl frexpl ldexpl 
    logl log10l modfl powl sinl sinhl sqrtl 
    tanl tanhl
</pre>

<p>
There should probably be a note saying that these functions
are optional and, if supplied, should match the description in
the 1999 version of the C standard. In the next round
of C++ standardization they can then become mandatory. 
</p>


<p><b>Rationale:</b></p>
<p>The C90 standard, as amended, already permits (but does not
require) these functions, and the C++ standard incorporates the
C90 standard by reference.  C99 is not an issue, because it is
never referred to by the C++ standard.</p>





<hr>
<h3><a name="290" href="290">290.</a> Requirements to for_each and its function object</h3>
<p><b>Section:</b> 27.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2001-01-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The specification of the for_each algorithm does not have a
&quot;Requires&quot; section, which means that there are no
restrictions imposed on the function object whatsoever. In essence it
means that I can provide any function object with arbitrary side
effects and I can still expect a predictable result. In particular I
can expect that the function object is applied exactly last - first
times, which is promised in the &quot;Complexity&quot; section.
</p>

<p>I don't see how any implementation can give such a guarantee
without imposing requirements on the function object.
</p>

<p>Just as an example: consider a function object that removes
elements from the input sequence.  In that case, what does the
complexity guarantee (applies f exactly last - first times) mean?
</p>

<p>One can argue that this is obviously a nonsensical application and
a theoretical case, which unfortunately it isn't.  I have seen
programmers shooting themselves in the foot this way, and they did not
understand that there are restrictions even if the description of the
algorithm does not say so.
</p>
<p><i>[Lillehammer: This is more general than for_each.  We don't want
  the function object in transform invalidiating iterators
  either. There should be a note somewhere in clause 17 (17, not 25)
  saying that user code operating on a range may not invalidate
  iterators unless otherwise specified.  Bill will provide wording.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD.
</p>
<p>
It was felt that the current description is adequate, and that there are
limits to what the standard can reasonably say to prohibit perverse uses
of the library.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="293" href="293">293.</a> Order of execution in transform algorithm</h3>
<p><b>Section:</b> 27.7.4 <a href="https://timsong-cpp.github.io/cppwp/alg.transform">[alg.transform]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2001-01-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.transform">issues</a> in [alg.transform].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>This issue is related to issue 242.  In case that the resolution
proposed for issue 242 is accepted, we have have the following
situation: The 4 numeric algorithms (accumulate and consorts) as well
as transform would allow a certain category of side effects.  The
numeric algorithms specify that they invoke the functor &quot;for
every iterator i in the range [first, last) in order&quot;. transform,
in contrast, would not give any guarantee regarding order of
invocation of the functor, which means that the functor can be invoked
in any arbitrary order.
</p>

<p>Why would that be a problem?  Consider an example: say the
transformator that is a simple enumerator ( or more generally
speaking, &quot;is order-sensitive&quot; ).  Since a standard
compliant implementation of transform is free to invoke the enumerator
in no definite order, the result could be a garbled enumeration.
Strictly speaking this is not a problem, but it is certainly at odds
with the prevalent understanding of transform as an algorithms that
assigns &quot;a new _corresponding_ value&quot; to the output
elements.
</p>

<p>All implementations that I know of invoke the transformator in
definite order, namely starting from first and proceeding to last -
1. Unless there is an optimization conceivable that takes advantage of
the indefinite order I would suggest to specify the order, because it
eliminate the uncertainty that users would otherwise have regarding
the order of execution of their potentially order-sensitive function
objects.
</p>


<p><b>Proposed resolution:</b></p>
<p>In section 25.2.3 - Transform [lib.alg.transform] change:</p>
<blockquote><p>
-1- Effects: Assigns through every iterator i in the range [result,
result + (last1 - first1)) a new corresponding
value equal to op(*(first1 + (i - result)) or binary_op(*(first1 +
(i - result), *(first2 + (i - result))).
</p></blockquote>
<p>to:</p>
<blockquote><p>
-1- Effects: Computes values by  invoking the operation op or binary_op 
for every iterator in the range [first1, last1) in order. Assigns through
every iterator i in the range [result, result + (last1 - first1)) a new
corresponding
value equal to op(*(first1 + (i - result)) or binary_op(*(first1 +
(i - result), *(first2 + (i - result))).
</p></blockquote>


<p><b>Rationale:</b></p>
<p>For Input Iterators an order is already guaranteed, because
only one order is possible.  If a user who passes a Forward
Iterator to one of these algorithms really needs a specific
order of execution, it's possible to achieve that effect by
wrapping it in an Input Iterator adaptor.</p>





<hr>
<h3><a name="299" href="299">299.</a> Incorrect return types for iterator dereference</h3>
<p><b>Section:</b> 25.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a>, 25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> John Potter <b>Opened:</b> 2001-01-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 25.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a>,
Table 75 gives the return type of <tt>*r--</tt> as convertible to <tt>T</tt>.  This is
not consistent with Table 74 which gives the return type of <tt>*r++</tt> as
<tt>T&amp;</tt>.  <tt>*r++ = t</tt> is valid while <tt>*r-- = t</tt> is invalid.
</p>

<p>
In section 25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>,
Table 76 gives the return type of <tt>a[n]</tt> as convertible to <tt>T</tt>.  This is
not consistent with the semantics of <tt>*(a + n)</tt> which returns <tt>T&amp;</tt> by
Table 74.  <tt>*(a + n) = t</tt> is valid while <tt>a[n] = t</tt> is invalid.
</p>

<p>
Discussion from the Copenhagen meeting: the first part is
uncontroversial.  The second part, <tt>operator[]</tt> for Random Access
Iterators, requires more thought.  There are reasonable arguments on
both sides.  Return by value from <tt>operator[]</tt> enables some potentially
useful iterators, e.g. a random access "iota iterator" (a.k.a
"counting iterator" or "int iterator").  There isn't any obvious way
to do this with return-by-reference, since the reference would be to a
temporary.  On the other hand, <tt>reverse_iterator</tt> takes an
arbitrary Random Access Iterator as template argument, and its
<tt>operator[]</tt> returns by reference.  If we decided that the return type
in Table 76 was correct, we would have to change
<tt>reverse_iterator</tt>.  This change would probably affect user
code.
</p>

<p>
History: the contradiction between <tt>reverse_iterator</tt> and the
Random Access Iterator requirements has been present from an early
stage.  In both the STL proposal adopted by the committee
(N0527==94-0140) and the STL technical report (HPL-95-11 (R.1), by
Stepanov and Lee), the Random Access Iterator requirements say that
<tt>operator[]</tt>'s return value is "convertible to <tt>T</tt>".  In N0527
reverse_iterator's <tt>operator[]</tt> returns by value, but in HPL-95-11
(R.1), and in the STL implementation that HP released to the public,
reverse_iterator's <tt>operator[]</tt> returns by reference.  In 1995, the
standard was amended to reflect the contents of HPL-95-11 (R.1).  The
original intent for <tt>operator[]</tt> is unclear.
</p>

<p>
In the long term it may be desirable to add more fine-grained 
iterator requirements, so that access method and traversal strategy
can be decoupled.  (See "Improved Iterator Categories and
Requirements", N1297 = 01-0011, by Jeremy Siek.)  Any decisions
about issue 299 should keep this possibility in mind.
</p>

<p>Further discussion: I propose a compromise between John Potter's
resolution, which requires <tt>T&amp;</tt> as the return type of
<tt>a[n]</tt>, and the current wording, which requires convertible to
<tt>T</tt>. The compromise is to keep the convertible to <tt>T</tt>
for the return type of the expression <tt>a[n]</tt>, but to also add
<tt>a[n] = t</tt> as a valid expression. This compromise "saves" the
common case uses of random access iterators, while at the same time
allowing iterators such as counting iterator and caching file
iterators to remain random access iterators (iterators where the
lifetime of the object returned by <tt>operator*()</tt> is tied to the
lifetime of the iterator).
</p>

<p>
Note that the compromise resolution necessitates a change to
<tt>reverse_iterator</tt>. It would need to use a proxy to support
<tt>a[n] = t</tt>.
</p>

<p>
Note also there is one kind of mutable random access iterator that
will no longer meet the new requirements. Currently, iterators that
return an r-value from <tt>operator[]</tt> meet the requirements for a
mutable random access iterator, even though the expression <tt>a[n] =
t</tt> will only modify a temporary that goes away. With this proposed
resolution, <tt>a[n] = t</tt> will be required to have the same
operational semantics as <tt>*(a + n) = t</tt>.
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-09-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
Why can't we write through the reference returned from <tt>operator[]</tt> on a
random access iterator?
</p>

<p>
Recommended solution:
</p>

<p>
In table Table 104 &mdash; Random access iterator requirements, replace
</p>

<blockquote><p>
<tt>a[n]</tt> : convertible to <del><tt>const T &amp;</tt></del>
<ins><tt>T&amp;</tt> if <tt>X</tt> is mutable, otherwise convertible to <tt>const T&amp;</tt></ins>
</p></blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave Open. Alisdair to spearhead a paper on revivification.
</p></blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
In section 24.1.4 [lib.bidirectdional.iterators], change the return
type in table 75 from &quot;convertible to <tt>T</tt>&quot; to
<tt>T&amp;</tt>.
</p>

<p>
In section 24.1.5 [lib.random.access.iterators], change the
operational semantics for <tt>a[n]</tt> to &quot; the r-value of
<tt>a[n]</tt> is equivalent to the r-value of <tt>*(a +
n)</tt>&quot;. Add a new row in the table for the expression <tt>a[n] = t</tt>
with a return type of convertible to <tt>T</tt> and operational semantics of
<tt>*(a + n) = t</tt>.
</p>

<p><i>[Lillehammer: Real problem, but should be addressed as part of
  iterator redesign]</i></p>




<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</p></blockquote>







<hr>
<h3><a name="302" href="302">302.</a> Need error indication from codecvt&lt;&gt;::do_length</h3>
<p><b>Section:</b> 30.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.byname">[locale.codecvt.byname]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gregory Bumgardner <b>Opened:</b> 2001-01-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects of <tt>codecvt&lt;&gt;::do_length()</tt> are described in
22.2.1.5.2, paragraph 10.  As implied by that paragraph, and clarified
in issue <a href="75">75</a>, <tt>codecvt&lt;&gt;::do_length()</tt> must
process the source data and update the <tt>stateT</tt> argument just
as if the data had been processed by <tt>codecvt&lt;&gt;::in()</tt>.
However, the standard does not specify how <tt>do_length()</tt> would
report a translation failure, should the source sequence contain
untranslatable or illegal character sequences.
</p>

<p>
The other conversion methods return an &quot;error&quot; result value
to indicate that an untranslatable character has been encountered, but
<tt>do_length()</tt> already has a return value (the number of source
characters that have been processed by the method).
</p>


<p><b>Proposed resolution:</b></p>
<p>
This issue cannot be resolved without modifying the interface. An exception
cannot be used, as there would be no way to determine how many characters
have been processed and the state object would be left in an indeterminate
state.
</p>

<p>
A source compatible solution involves adding a fifth argument to length()
and do_length() that could be used to return position of the offending
character sequence. This argument would have a default value that would
allow it to be ignored:
</p>

<pre>
  int length(stateT&amp; state, 
             const externT* from, 
             const externT* from_end, 
             size_t max,
             const externT** from_next = 0);

  virtual
  int do_length(stateT&amp; state, 
                const externT* from, 
                const externT* from_end, 
                size_t max,
                const externT** from_next);
</pre>

<p>
Then an exception could be used to report any translation errors and
the from_next argument, if used, could then be used to retrieve the
location of the offending character sequence.
</p>


<p><b>Rationale:</b></p>
<p>The standard is already clear: the return value is the number of
"valid complete characters".  If it encounters an invalid sequence of
external characters, it stops.</p>





<hr>
<h3><a name="304" href="304">304.</a> Must <tt>*a</tt> return an lvalue when <tt>a</tt> is an input iterator?</h3>
<p><b>Section:</b> 25.3.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concepts">[iterator.concepts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2001-02-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We all &quot;know&quot; that input iterators are allowed to produce
values when dereferenced of which there is no other in-memory copy.
</p>

<p>
But: Table 72, with a careful reading, seems to imply that this can only be
the case if the value_type has no members (e.g. is a built-in type).
</p>

<p>The problem occurs in the following entry:</p>

<pre>
  a->m     pre: (*a).m is well-defined
           Equivalent to (*a).m
</pre>

<p>
<tt>*a.m</tt> can be well-defined if <tt>*a</tt> is not a reference
type, but since <tt>operator->()</tt> must return a pointer for
<tt>a->m</tt> to be well-formed, it needs something to return a
pointer <i>to</i>. This seems to indicate that <tt>*a</tt> must be
buffered somewhere to make a legal input iterator.
</p>

<p>I don't think this was intentional.</p>


<p><b>Rationale:</b></p>
<p>The current standard is clear and consistent.  Input iterators that
  return rvalues are in fact implementable.  They may in some cases
  require extra work, but it is still possible to define an operator->
  in such cases: it doesn't have to return a T*, but may return a
  proxy type.  No change to the standard is justified.</p>





<hr>
<h3><a name="309" href="309">309.</a> Does sentry catch exceptions?</h3>
<p><b>Section:</b> 31.7 <a href="https://timsong-cpp.github.io/cppwp/iostream.format">[iostream.format]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-03-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The descriptions of the constructors of basic_istream&lt;&gt;::sentry
( [istream::sentry]) and basic_ostream&lt;&gt;::sentry
( [ostream::sentry]) do not explain what the functions do in
case an exception is thrown while they execute. Some current
implementations allow all exceptions to propagate, others catch them
and set ios_base::badbit instead, still others catch some but let
others propagate.
</p>

<p>
The text also mentions that the functions may call setstate(failbit)
(without actually saying on what object, but presumably the stream
argument is meant).  That may have been fine for
basic_istream&lt;&gt;::sentry prior to issue <a href="195">195</a>, since
the function performs an input operation which may fail. However,
issue <a href="195">195</a> amends  [istream::sentry], p2 to
clarify that the function should actually call setstate(failbit |
eofbit), so the sentence in p3 is redundant or even somewhat
contradictory.
</p>

<p>
The same sentence that appears in  [ostream::sentry], p3
doesn't seem to be very meaningful for basic_istream&lt;&gt;::sentry
which performs no input. It is actually rather misleading since it
would appear to guide library implementers to calling
setstate(failbit) when os.tie()-&gt;flush(), the only called function,
throws an exception (typically, it's badbit that's set in response to
such an event).
</p>

<p><b>Additional comments from Martin, who isn't comfortable with the
    current proposed resolution</b> (see c++std-lib-11530)</p>

<p>
The istream::sentry ctor says nothing about how the function
deals with exemptions (27.6.1.1.2, p1 says that the class is
responsible for doing "exception safe"(*) prefix and suffix
operations but it doesn't explain what level of exception
safety the class promises to provide). The mockup example
of a "typical implementation of the sentry ctor" given in
27.6.1.1.2, p6, removed in ISO/IEC 14882:2003, doesn't show
exception handling, either. Since the ctor is not classified
as a formatted or unformatted input function, the text in
27.6.1.1, p1 through p4 does not apply. All this would seem
to suggest that the sentry ctor should not catch or in any
way handle exceptions thrown from any functions it may call.
Thus, the typical implementation of an istream extractor may
look something like [1].
</p>

<p>
The problem with [1] is that while it correctly sets ios::badbit
if an exception is thrown from one of the functions called from
the sentry ctor, if the sentry ctor reaches EOF while extracting
whitespace from a stream that has eofbit or failbit set in
exceptions(), it will cause an ios::failure to be thrown, which
will in turn cause the extractor to set ios::badbit.
</p>

<p>
The only straightforward way to prevent this behavior is to
move the definition of the sentry object in the extractor
above the try block (as suggested by the example in 22.2.8,
p9 and also indirectly supported by 27.6.1.3, p1). See [2].
But such an implementation will allow exceptions thrown from
functions called from the ctor to freely propagate to the
caller regardless of the setting of ios::badbit in the stream
object's exceptions().
</p>

<p>
So since neither [1] nor [2] behaves as expected, the only
possible solution is to have the sentry ctor catch exceptions
thrown from called functions, set badbit, and propagate those
exceptions if badbit is also set in exceptions(). (Another
solution exists that deals with both kinds of sentries, but
the code is non-obvious and cumbersome -- see [3].)
</p>

<p>
Please note that, as the issue points out, current libraries
do not behave consistently, suggesting  that implementors are
not quite clear on the exception handling in istream::sentry,
despite the fact that some LWG members might feel otherwise.
(As documented by the parenthetical comment here:
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1480.html#309)
</p>

<p>
Also please note that those LWG members who in Copenhagen
felt that "a sentry's constructor should not catch exceptions,
because sentries should only be used within (un)formatted input
functions and that exception handling is the responsibility of
those functions, not of the sentries," as noted here
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1310.html#309
would in effect be either arguing for the behavior described
in [1] or for extractors implemented along the lines of [3].
</p>

<p>
The original proposed resolution (Revision 25 of the issues
list) clarifies the role of the sentry ctor WRT exception
handling by making it clear that extractors (both library
or user-defined) should be implemented along the lines of
[2] (as opposed to [1]) and that no exception thrown from
the callees should propagate out of either function unless
badbit is also set in exceptions().
</p>


<p>[1] Extractor that catches exceptions thrown from sentry:</p>

<blockquote>
<pre>
struct S { long i; };

istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    ios::iostate err = ios::goodbit;
    try {
        const istream::sentry guard (strm, false);
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        bool rethrow;
        try {
            strm.setstate (ios::badbit);
            rethrow = false;
        }
        catch (...) {
            rethrow = true;
        }
        if (rethrow)
            throw;
    }
    if (err)
        strm.setstate (err);
    return strm;
}
</pre>
</blockquote>

<p>[2] Extractor that propagates exceptions thrown from sentry:</p>

<blockquote>
<pre>
istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    istream::sentry guard (strm, false);
    if (guard) {
        ios::iostate err = ios::goodbit;
        try {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
        catch (...) {
            bool rethrow;
            try {
                strm.setstate (ios::badbit);
                rethrow = false;
            }
            catch (...) {
                rethrow = true;
            }
            if (rethrow)
                throw;
        }
        if (err)
            strm.setstate (err);
    }
    return strm;
}
</pre>
</blockquote>

<p>
[3] Extractor that catches exceptions thrown from sentry
but doesn't set badbit if the exception was thrown as a
result of a call to strm.clear().
</p>

<blockquote>
<pre>
istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    const ios::iostate state = strm.rdstate ();
    const ios::iostate except = strm.exceptions ();
    ios::iostate err = std::ios::goodbit;
    bool thrown = true;
    try {
        const istream::sentry guard (strm, false);
        thrown = false;
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        if (thrown &amp;&amp; state &amp; except)
            throw;
        try {
            strm.setstate (ios::badbit);
            thrown = false;
        }
        catch (...) {
            thrown = true;
        }
        if (thrown)
            throw;
    }
    if (err)
        strm.setstate (err);

    return strm;
}
</pre>
</blockquote>

<p>
[Pre-Berlin] Reopened at the request of Paolo Carlini and Steve Clamage.
</p>

<p>
[Pre-Portland] A relevant newsgroup post:
</p>

<p>
The current proposed resolution of issue #309 is
unacceptable.   I write commerical software and coding around this
makes my code ugly, non-intuitive, and requires comments referring
people to this very issue.   Following is the full explanation of my
experience.
</p>
<p>
In the course of writing software for commercial use, I constructed
std::ifstream's based on user-supplied pathnames on typical POSIX
systems.
</p>
<p>
It was expected that some files that opened successfully might not read
successfully -- such as a pathname which actually refered to a
directory.   Intuitively, I expected the streambuffer underflow() code
to throw an exception in this situation, and recent implementations of
libstdc++'s basic_filebuf do just that (as well as many of my own
custom streambufs).
</p>
<p>
I also intuitively expected that the istream code would convert these
exceptions to the "badbit' set on the stream object, because I had not
requested exceptions.    I refer to 27.6.1.1. P4.
</p>
<p>
However, this was not the case on at least two implementations -- if
the first thing I did with an istream was call operator>>( T&amp; ) for T
among the basic arithmetic types and std::string.   Looking further I
found that the sentry's constructor was invoking the exception when it
pre-scanned for whitespace, and the extractor function (operator>>())
was not catching exceptions in this situation.
</p>
<p>
So, I was in a situation where setting 'noskipws' would change the
istream's behavior even though no characters (whitespace or not) could
ever be successfully read.
</p>
<p>
Also, calling .peek() on the istream before calling the extractor()
changed the behavior (.peek() had the effect of setting the badbit
ahead of time).
</p>
<p>
I found this all to be so inconsistent and inconvenient for me and my
code design, that I filed a bugzilla entry for libstdc++.   I was then
told that the bug cannot be fixed until issue #309 is resolved by the
committee.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD.
</p>
<p>
See the rationale in the issue. Paolo, who requested that the issue be
reopened, agreed with the rationale.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG agrees there is minor variation between implementations,
  but believes that it doesn't matter. This is a rarely used corner
  case. There is no evidence that this has any commercial importance
  or that it causes actual portability problems for customers trying
  to write code that runs on multiple implementations.</p>





<hr>
<h3><a name="313" href="313">313.</a> set_terminate and set_unexpected question</h3>
<p><b>Section:</b> 17.10.5.4 <a href="https://timsong-cpp.github.io/cppwp/terminate">[terminate]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2001-04-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#terminate">issues</a> in [terminate].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to section 18.7.3.3 of the standard, std::terminate() is
supposed to call the terminate_handler in effect immediately after
evaluating the throw expression.
</p>

<p>
Question: what if the terminate_handler in effect is itself
std::terminate?
</p>

<p>For example:</p>

<pre>
  #include &lt;exception&gt;

  int main () {
      std::set_terminate(std::terminate);
      throw 5;
      return 0;
  }
</pre>

<p>
Is the implementation allowed to go into an infinite loop?
</p>

<p>
I think the same issue applies to std::set_unexpected.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Infinite recursion is to be expected: users who set the terminate
handler to <tt>terminate</tt> are explicitly asking for <tt>terminate</tt>
to call itself.</p>





<hr>
<h3><a name="314" href="314">314.</a> Is the stack unwound when terminate() is called?</h3>
<p><b>Section:</b> 17.10.5.4 <a href="https://timsong-cpp.github.io/cppwp/terminate">[terminate]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2001-04-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#terminate">issues</a> in [terminate].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The standard appears to contradict itself about whether the stack is
unwound when the implementation calls terminate().
</p>

<p>From 18.7.3.3p2:</p>
<blockquote><p>
    Calls the terminate_handler function in effect immediately
    after evaluating the throw-expression (lib.terminate.handler),
    if called by the implementation [...]
</p></blockquote>

<p>So the stack is guaranteed not to be unwound.</p>

<p>But from 15.3p9:</p>
<blockquote><p>
    [...]whether or not the stack is unwound before this call
    to terminate() is implementation-defined (except.terminate).
</p></blockquote>

<p>
And 15.5.1 actually defines that in most cases the stack is unwound.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>There is definitely no contradiction between the core and library
clauses; nothing in the core clauses says that stack unwinding happens
after <tt>terminate</tt> is called.  18.7.3.3p2 does not say anything
about when terminate() is called; it merely specifies which
<tt>terminate_handler</tt> is used.</p>





<hr>
<h3><a name="323" href="323">323.</a> <tt>abs()</tt> overloads in different headers</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2001-06-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Currently the standard mandates the following overloads of
abs():</p>

<pre>
    abs(long), abs(int) in &lt;cstdlib&gt;

    abs(float), abs(double), abs(long double) in &lt;cmath&gt;

    template&lt;class T&gt; T abs(const complex&lt;T&gt;&amp;) in &lt;complex&gt;

    template&lt;class T&gt; valarray&lt;T&gt; abs(const valarray&lt;T&gt;&amp;); in &lt;valarray&gt;
</pre>

<p>
The problem is that having only some overloads visible of a function
that works on "implicitly inter-convertible" types is dangerous in
practice. The headers that get included at any point in a translation
unit can change unpredictably during program
development/maintenance. The wrong overload might be unintentionally
selected.
</p>

<p>
Currently, there is nothing that mandates the simultaneous visibility
of these overloads. Indeed, some vendors have begun fastidiously
reducing dependencies among their (public) headers as a QOI issue: it
helps people to write portable code by refusing to compile unless all
the correct headers are #included.
</p>

<p>The same issue may exist for other functions in the library.</p>

<p>Redmond: PJP reports that C99 adds two new kinds of <tt>abs</tt>: <tt>complex</tt>,
and <tt>int_max_abs</tt>.</p>

<p>Related issue: <a href="343">343</a>.</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
The situation is not sufficiently severe to warrant a change.
</p></blockquote>




<p><b>Rationale:</b></p>
<p>The programs that could potentially be broken by this situation are
  already fragile, and somewhat contrived: For example, a user-defined
  class that has conversion overloads both to <tt>long</tt> and
  to <tt>float</tt>.  If <tt>x</tt> is a value of such a class, then
  <tt>abs(x)</tt> would give the <tt>long</tt> version if the user
  included &lt;cstdlib&gt;, the <tt>float</tt> version if the user
  included &lt;cmath&gt;, and would be diagnosed as ambiguous at
  compile time if the user included both headers.  The LWG couldn't
  find an example of a program whose meaning would be changed (as
  opposed to changing it from well-formed to ill-formed) simply by
  adding another standard header.</p>

<p>Since the harm seems minimal, and there don't seem to be any simple
  and noninvasive solutions, this is being closed as NAD.  It is
  marked as "Future" for two reasons.  First, it might be useful to
  define an <tt>&lt;all&gt;</tt> header that would include all
  Standard Library headers.  Second, we should at least make sure that
  future library extensions don't make this problem worse.</p>





<hr>
<h3><a name="326" href="326">326.</a> Missing typedef in moneypunct_byname</h3>
<p><b>Section:</b> 30.4.7.5 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct.byname">[locale.moneypunct.byname]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-07-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The definition of the moneypunct facet contains the typedefs char_type
and string_type. Only one of these names, string_type, is defined in
the derived facet, moneypunct_byname.</p>


<p><b>Proposed resolution:</b></p>
<p>For consistency with the numpunct facet, add a typedef for
char_type to the definition of the moneypunct_byname facet in
30.4.7.5 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct.byname">[locale.moneypunct.byname]</a>.</p>


<p><b>Rationale:</b></p>
<p>The absence of the typedef is irrelevant.  Users can still access
the typedef, because it is inherited from the base class.</p>





<hr>
<h3><a name="330" href="330">330.</a> Misleading "exposition only" value in class locale definition</h3>
<p><b>Section:</b> 30.3.1 <a href="https://timsong-cpp.github.io/cppwp/locale">[locale]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-07-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The "exposition only" value of the std::locale::none constant shown in
the definition of class locale is misleading in that it on many
systems conflicts with the value assigned to one if the LC_XXX
constants (specifically, LC_COLLATE on AIX, LC_ALL on HP-UX, LC_CTYPE
on Linux and SunOS). This causes incorrect behavior when such a
constant is passed to one of the locale member functions that accept a
locale::category argument and interpret it as either the C LC_XXX
constant or a bitmap of locale::category values. At least three major
implementations adopt the suggested value without a change and
consequently suffer from this problem.
</p>

<p>
For instance, the following code will (presumably) incorrectly copy facets
belonging to the collate category from the German locale on AIX:
</p>

<pre>
  std::locale l (std::locale ("C"), "de_DE", std::locale::none);
</pre>


<p><b>Rationale:</b></p>
<p>The LWG agrees that it may be difficult to implement locale member
functions in such a way that they can take either <tt>category</tt>
arguments or the LC_ constants defined in &lt;cctype&gt;.  In light of
this requirement (30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a>, paragraph 2), and in light
of the requirement in the preceding paragraph that it is possible to
combine <tt>category</tt> bitmask elements with bitwise operations,
defining the <tt>category</tt> elements is delicate,
particularly if an implementor is constrained to work with a
preexisting C library.  (Just using the existing LC_ constants would
not work in general.)  There's no set of "exposition only" values that
could give library implementors proper guidance in such a delicate
matter.  The non-normative example we're giving is no worse than
any other choice would be.</p>

<p>See issue <a href="347">347</a>.</p>





<hr>
<h3><a name="332" href="332">332.</a> Consider adding increment and decrement operators to std::fpos&lt; T &gt; </h3>
<p><b>Section:</b> 31.5.3 <a href="https://timsong-cpp.github.io/cppwp/fpos">[fpos]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> PremAnand M. Rao <b>Opened:</b> 2001-08-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Increment and decrement operators are missing from 
Table 88 -- Position type requirements in 31.5.3 <a href="https://timsong-cpp.github.io/cppwp/fpos">[fpos]</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Table 88 (section 27.4.3) -- Position type requirements
be updated to include increment and decrement operators.
</p>

<pre>
expression        return type     operational    note

++p               fpos&amp;           p += O(1)
p++               fpos            { P tmp = p;
                                    ++p;
                                    return tmp; }
--p               fpos&amp;           p -= O(1)
p--               fpos            { P tmp = p;
                                    --p;
                                    return tmp; }
</pre>



<p><b>Rationale:</b></p>
<p>The LWG believes this is a request for extension, not a defect
report.  Additionally, nobody saw a clear need for this extension;
<tt>fpos</tt> is used only in very limited ways.</p>





<hr>
<h3><a name="342" href="342">342.</a> seek and eofbit</h3>
<p><b>Section:</b> 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-10-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I think we have a defect.</p>

<p>According to lwg issue <a href="60">60</a> which is now a dr, the
description of seekg in 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> paragraph 38 now looks
like:</p>

<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3, 
paragraph 1), except that it does not count the number of characters 
extracted and does not affect the value returned by subsequent calls to 
gcount(). After constructing a sentry object, if fail() != true, 
executes rdbuf()->pubseekpos( pos).
</p></blockquote>

<p>And according to lwg issue <a href="243">243</a> which is also now a dr,
27.6.1.3, paragraph 1 looks like:</p>

<blockquote><p>
Each unformatted input function begins execution by constructing an 
object of class sentry with the default argument noskipws (second) 
argument true. If the sentry object returns true, when converted to a 
value of type bool, the function endeavors to obtain the requested 
input.  Otherwise, if the sentry constructor exits by throwing an 
exception or if the sentry object returns false, when converted to a 
value of type bool, the function returns without attempting to obtain 
any input. In either case the number of extracted characters is set to 
0; unformatted input functions taking a character array of non-zero 
size as an argument shall also store a null character (using charT()) 
in the first location of the array. If an exception is thrown during 
input then ios::badbit is turned on in *this'ss error state. If 
(exception()&amp;badbit)!= 0 then the exception is rethrown. It also counts 
the number of characters extracted. If no exception has been thrown it 
ends by storing the count in a member object and returning the value 
specified. In any event the sentry object is destroyed before leaving 
the unformatted input function.
</p></blockquote>

<p>And finally 27.6.1.1.2/5 says this about sentry:</p>

<blockquote><p>
If, after any preparation is completed, is.good() is true, ok_ != false 
otherwise, ok_ == false.
</p></blockquote>

<p>
So although the seekg paragraph says that the operation proceeds if 
!fail(), the behavior of unformatted functions says the operation 
proceeds only if good().  The two statements are contradictory when only 
eofbit is set.  I don't think the current text is clear which condition 
should be respected.
</p>

<p><b>Further discussion from Redmond:</b></p>

<p>PJP: It doesn't seem quite right to say that <tt>seekg</tt> is
"unformatted". That makes specific claims about sentry that
aren't quite appropriate for seeking, which has less fragile failure
modes than actual input.  If we do really mean that it's unformatted
input, it should behave the same way as other unformatted input.  On
the other hand, "principle of least surprise" is that seeking from EOF
ought to be OK.</p>

<p>
Pre-Berlin:  Paolo points out several problems with the proposed resolution in
Ready state:
</p>

<ul>
<li>It should apply to both overloads of seekg.</li>
<li>tellg has similar issues, except that it should not call clear().</li>
<li>The point about clear() seems to apply to seekp().</li>
<li>Depending on the outcome of <a href="419">419</a>
if the sentry
sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then
you can never seek away from the end of stream.</li>
</ul>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD. Will reopen if proposed resolution is supplied.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>Change 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> to:</p>
<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1), except that it does not count the number of characters
extracted, does not affect the value returned by subsequent calls to
gcount(), and does not examine the value returned by the sentry
object. After constructing a sentry object, if <tt>fail() !=
true</tt>, executes <tt>rdbuf()->pubseekpos(pos)</tt>.  In
case of success, the function calls clear().
In case of failure, the function calls <tt>setstate(failbit)</tt>
(which may throw <tt>ios_base::failure</tt>).
</p></blockquote>

<p><i>[Lillehammer: Matt provided wording.]</i></p>




<p><b>Rationale:</b></p>
<p>In C, fseek does clear EOF.  This is probably what most users would
  expect.  We agree that having eofbit set should not deter a seek,
  and that a successful seek should clear eofbit. Note
  that <tt>fail()</tt> is true only if <tt>failbit</tt>
  or <tt>badbit</tt> is set, so using <tt>!fail()</tt>, rather
  than <tt>good()</tt>, satisfies this goal.</p>





<hr>
<h3><a name="344" href="344">344.</a> grouping + showbase</h3>
<p><b>Section:</b> 30.4.3 <a href="https://timsong-cpp.github.io/cppwp/category.numeric">[category.numeric]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-10-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When both grouping and showbase are active and the basefield is octal, 
does the leading 0 participate in the grouping or not? For example, 
should one format as: 0,123,456 or 0123,456?
</p>
<p>
An analogy can be drawn with hexadecimal.  It appears that 0x123,456 is 
preferred over 0x,123,456. However, this analogy is not universally 
accepted to apply to the octal base. The standard is not clear on how 
to format (or parse) in this manner.
</p>

<p><b>Proposed resolution:</b></p>
<p>
Insert into 30.4.4.1.3 <a href="https://timsong-cpp.github.io/cppwp/facet.numpunct.virtuals">[facet.numpunct.virtuals]</a> paragraph 3, just before the last
sentence:
</p>
<blockquote><p>
The leading hexadecimal base specifier "0x" does not participate in 
grouping. The leading '0' octal base specifier may participate in 
grouping. It is unspecified if the leading '0' participates in 
formatting octal numbers. In parsing octal numbers, the implementation 
is encouraged to accept both the leading '0' participating in the 
grouping, and not participating (e.g. 0123,456 or 0,123,456).
</p></blockquote>

<p><b>Rationale:</b></p>
<p>
The current behavior may be unspecified, but it's not clear that it
matters. This is an obscure corner case, since grouping is usually
intended for the benefit of humans and oct/hex prefixes are usually
intended for the benefit of machines. There is not a strong enough
consensus in the LWG for action.
</p>




<hr>
<h3><a name="348" href="348">348.</a> Minor issue with std::pair operator&lt;</h3>
<p><b>Section:</b> 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2001-10-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="532">532</a></p>
<p><b>Discussion:</b></p>


<p>
The current wording of 20.2.2 [lib.pairs] p6 precludes the use of
operator&lt; on any pair type which contains a pointer.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> paragraph 6, replace:</p>
<pre>
    Returns: x.first &lt; y.first || (!(y.first &lt; x.first) &amp;&amp; x.second &lt;
        y.second).
</pre>
<p>With:</p>
<pre>
    Returns: std::less&lt;T1&gt;()( x.first, y.first ) ||
             (!std::less&lt;T1&gt;()( y.first, x.first) &amp;&amp; 
             std::less&lt;T2&gt;()( x.second, y.second ) )
</pre>



<p><b>Rationale:</b></p>
<p>This is an instance of a much more general problem.  If we want
  operator&lt; to translate to std::less for pairs of pointers, where
  do we draw the line?  The same issue applies to individual
  pointers, smart pointer wrappers, std::vector&lt;T*&gt;, and so
  on.</p>

<p>Andy Koenig suggests that the real issue here is that we aren't
  distinguishing adequately between two different orderings, a
  "useful ordering" and a "canonical ordering" that's used just
  because we sometimes need <i>some</i> ordering without caring much
  which ordering it is.  Another example of the later is typeinfo's
  <tt>before</tt>.</p>






<hr>
<h3><a name="350" href="350">350.</a> allocator&lt;&gt;::address</h3>
<p><b>Section:</b> 20.2.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a>, 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2001-10-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="634">634</a></p>
<p><b>Discussion:</b></p>
<p>See c++std-lib-9006 and c++std-lib-9007.  This issue is taken
verbatim from -9007.</p>

<p>
The core language feature allowing definition of operator&amp;() applied 
to any non-builtin type makes that operator often unsafe to use in 
implementing libraries, including the Standard Library.  The result
is that many library facilities fail for legal user code, such as
the fragment</p>
<pre>
  class A { private: A* operator&amp;(); };
  std::vector&lt;A&gt; aa;

  class B { };
  B* operator&amp;(B&amp;) { return 0; }
  std::vector&lt;B&gt; ba;
</pre>

<p>
In particular, the requirements table for Allocator (Table 32) specifies
no semantics at all for member address(), and allocator&lt;&gt;::address is 
defined in terms of unadorned operator &amp;.
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 20.6.1.1, Change the definition of allocator&lt;&gt;::address from:</p>
<blockquote><p>
  Returns: &amp;x
</p></blockquote>

<p>to:</p>

<p>
  Returns: The value that the built in operator&amp;(x) would return if not 
  overloaded.
</p>

<p>
In 20.1.6, Table 32, add to the Notes column of the a.address(r) and
a.address(s) lines, respectively: 
</p>

<pre>
  allocator&lt;T&gt;::address(r)
  allocator&lt;T&gt;::address(s)
</pre> 

<p>In addition, in clause 17.4.1.1, add a statement:</p>

<blockquote><p>
 The Standard Library does not apply operator&amp; to any type for which
 operator&amp; may be overloaded.
</p></blockquote> 



<p><b>Rationale:</b></p>
<p>The LWG believes both examples are ill-formed.  The contained type
is required to be CopyConstructible (16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a>), and that
includes the requirement that &amp;t return the usual types and
values. Since allocators are intended to be used in conjunction with
containers, and since the CopyConstructible requirements appear to
have been written to deal with the concerns of this issue, the LWG
feels it is NAD unless someone can come up with a well-formed example
exhibiting a problem.</p>

<p>It may well be that the CopyConstructible requirements are too
  restrictive and that either the container requirements or the
  CopyConstructive requirements should be relaxed, but that's a far
  larger issue.  Marking this issue as "future" as a pointer to that
  larger issue.</p>





<hr>
<h3><a name="351" href="351">351.</a> unary_negate and binary_negate: struct or class?</h3>
<p><b>Section:</b> 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dale Riley <b>Opened:</b> 2001-11-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a> the header &lt;functional&gt; synopsis declares
the unary_negate and binary_negate function objects as struct.
However in  [negators] the unary_negate and binary_negate
function objects are defined as class.  Given the context, they are
not "basic function objects" like negate, so this is either a typo or
an editorial oversight.
</p>

<p><i>[Taken from comp.std.c++]</i></p>



<p><b>Proposed resolution:</b></p>
<p>Change the synopsis to reflect the useage in  [negators]</p>

<p><i>[Cura&ccedil;ao: Since the language permits &quot;struct&quot;, the LWG
views this as NAD. They suggest, however, that the Project Editor
might wish to make the change as editorial.]</i></p>







<hr>
<h3><a name="356" href="356">356.</a> Meaning of ctype_base::mask enumerators</h3>
<p><b>Section:</b> 30.4.2 <a href="https://timsong-cpp.github.io/cppwp/category.ctype">[category.ctype]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2002-01-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#category.ctype">issues</a> in [category.ctype].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>What should the following program print?</p>

<pre>
  #include &lt;locale&gt;
  #include &lt;iostream&gt;

  class my_ctype : public std::ctype&lt;char&gt;
  {
    typedef std::ctype&lt;char&gt; base;
  public:
    my_ctype(std::size_t refs = 0) : base(my_table, false, refs)
    {
      std::copy(base::classic_table(), base::classic_table() + base::table_size,
                my_table);
      my_table[(unsigned char) '_'] = (base::mask) (base::print | base::space);
    }
  private:
    mask my_table[base::table_size];
  };

  int main()
  {
    my_ctype ct;
    std::cout &lt;&lt; "isspace: " &lt;&lt; ct.is(std::ctype_base::space, '_') &lt;&lt; "    "
              &lt;&lt; "isalpha: " &lt;&lt; ct.is(std::ctype_base::alpha, '_') &lt;&lt; std::endl;
  }
</pre>

<p>The goal is to create a facet where '_' is treated as whitespace.</p>

<p>On gcc 3.0, this program prints "isspace: 1 isalpha: 0".  On
Microsoft C++ it prints "isspace: 1 isalpha: 1".</p>

<p>
I believe that both implementations are legal, and the standard does not
give enough guidance for users to be able to use std::ctype's
protected interface portably.</p>

<p>
The above program assumes that ctype_base::mask enumerators like
<tt>space</tt> and <tt>print</tt> are disjoint, and that the way to
say that a character is both a space and a printing character is to or
those two enumerators together.  This is suggested by the "exposition
only" values in 30.4.2 <a href="https://timsong-cpp.github.io/cppwp/category.ctype">[category.ctype]</a>, but it is nowhere specified in
normative text.  An alternative interpretation is that the more
specific categories subsume the less specific.  The above program
gives the results it does on the Microsoft compiler because, on that
compiler, <tt>print</tt> has all the bits set for each specific
printing character class.
</p>

<p>From the point of view of std::ctype's public interface, there's no
important difference between these two techniques.  From the point of
view of the protected interface, there is.  If I'm defining a facet
that inherits from std::ctype&lt;char&gt;, I'm the one who defines the
value that table()['a'] returns.  I need to know what combination of
mask values I should use.  This isn't so very esoteric: it's exactly
why std::ctype has a protected interface.  If we care about users
being able to write their own ctype facets, we have to give them a
portable way to do it.
</p>

<p>
Related reflector messages:
lib-9224, lib-9226, lib-9229, lib-9270, lib-9272, lib-9273, lib-9274,
lib-9277, lib-9279.
</p>

<p>Issue <a href="339">339</a> is related, but not identical.  The
proposed resolution if issue <a href="339">339</a> says that
ctype_base::mask must be a bitmask type. It does not say that the
ctype_base::mask elements are bitmask elements, so it doesn't
directly affect this issue.</p>

<p>More comments from Benjamin Kosnik, who believes that 
that C99 compatibility essentially requires what we're
calling option 1 below.</p>

<blockquote>
<pre>
I think the C99 standard is clear, that isspace -&gt; !isalpha.
--------

#include &lt;locale&gt;
#include &lt;iostream&gt;

class my_ctype : public std::ctype&lt;char&gt;
{
private:
  typedef std::ctype&lt;char&gt; base;
  mask my_table[base::table_size];

public:
  my_ctype(std::size_t refs = 0) : base(my_table, false, refs)
  {
    std::copy(base::classic_table(), base::classic_table() + base::table_size,
              my_table);
    mask both = base::print | base::space;
    my_table[static_cast&lt;mask&gt;('_')] = both;
  }
};

int main()
{
  using namespace std;
  my_ctype ct;
  cout &lt;&lt; "isspace: " &lt;&lt; ct.is(ctype_base::space, '_') &lt;&lt; endl;
  cout &lt;&lt; "isprint: " &lt;&lt; ct.is(ctype_base::print, '_') &lt;&lt; endl;

  // ISO C99, isalpha iff upper | lower set, and !space.
  // 7.5, p 193
  // -&gt; looks like g++ behavior is correct.
  // 356 -&gt; bitmask elements are required for ctype_base
  // 339 -&gt; bitmask type required for mask
  cout &lt;&lt; "isalpha: " &lt;&lt; ct.is(ctype_base::alpha, '_') &lt;&lt; endl;
}
</pre>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Informally, we have three choices:</p> 
<ol>
<li>Require that the enumerators are disjoint (except for alnum and
graph)</li>
<li>Require that the enumerators are not disjoint, and specify which
of them subsume which others.  (e.g. mandate that lower includes alpha
and print)</li>
<li>Explicitly leave this unspecified, which the result that the above
program is not portable.</li>
</ol>

<p>Either of the first two options is just as good from the standpoint
of portability.  Either one will require some implementations to
change.</p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that this is a real ambiguity, and that both
interpretations are conforming under the existing standard. However,
there's no evidence that it's causing problems for real users. Users
who want to define ctype facets portably can test the ctype_base masks
to see which interpretation is being used.</p>





<hr>
<h3><a name="357" href="357">357.</a> &lt;cmath&gt; float functions cannot return HUGE_VAL</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-02-26 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The float versions of the math functions have no meaningful value to return 
for a range error. The long double versions have a value they can return, 
but it isn't necessarily the most reasonable value.
</p>

<p>
Section 26.5 [lib.c.math], paragraph 5, says that C++ "adds float and long 
double overloaded versions of these functions, with the same semantics," 
referring to the math functions from the C90 standard.
</p>

<p>
The C90 standard, in section 7.5.1, paragraph 3, says that functions return 
"the value of the macro HUGE_VAL" when they encounter a range error. 
Section 7.5, paragraph 2, defines HUGE_VAL as a macro that "expands to a 
positive double expression, not necessarily representable as a float."
</p>

<p>
Therefore, the float versions of the math functions have no way to
signal a range error. <i>[Cura&ccedil;ao: The LWG notes that this isn't
strictly correct, since errno is set.]</i> The semantics require that they
return HUGE_VAL, but they cannot because HUGE_VAL might not be
representable as a float.
</p>

<p>
The problem with long double functions is less severe because HUGE_VAL is 
representable as a long double. On the other hand, it might not be a "huge" 
long double value, and might fall well within the range of normal return 
values for a long double function. Therefore, it does not make sense for a 
long double function to return a double (HUGE_VAL) for a range error.
</p>


<p><b>Proposed resolution:</b></p>
<p>Cura&ccedil;ao: C99 was faced with a similar problem, which they fixed by
adding HUGE_VALF and HUGE_VALL in addition to HUGE_VAL.</p>

<p>C++ must also fix, but it should be done in the context of the
general C99 based changes to C++, not via DR. Thus the LWG in Cura&ccedil;ao
felt the resolution should be NAD, FUTURE, but the issue is being held
open for one more meeting to ensure LWG members not present during the
discussion concur.</p>


<p><b>Rationale:</b></p>
<p>Will be fixed as part of more general work in the TR.</p>





<hr>
<h3><a name="361" href="361">361.</a> num_get&lt;&gt;::do_get (..., void*&amp;) checks grouping</h3>
<p><b>Section:</b> 30.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-03-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.2.2.2.2, p12 specifies that <tt>thousands_sep</tt> is to be inserted only
for integral types (issue 282 suggests that this should be done for
all arithmetic types).
</p>

<p>
22.2.2.1.2, p12 requires that grouping be checked for all extractors
including that for <tt>void*</tt>.
</p>

<p>
I don't think that's right. <tt>void*</tt> values should not be checked for
grouping, should they? (Although if they should, then <tt>num_put</tt> needs
to write them out, otherwise their extraction will fail.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the first sentence of 22.2.2.2.2, p12 from
</p>
<blockquote><p>
    Digit grouping is checked. That is, the positions of discarded
    separators is examined for consistency with
    use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping().
    If they are not consistent then ios_base::failbit is assigned
    to err.
</p></blockquote>

<p>to</p>
<blockquote><p>
    Except for conversions to void*, digit grouping is checked...
</p></blockquote>



<p><b>Rationale:</b></p>
<p>This would be a change: as it stands, the standard clearly
  specifies that grouping applies to void*.  A survey of existing
  practice shows that most existing implementations do that, as they
  should.</p>





<hr>
<h3><a name="366" href="366">366.</a> Excessive const-qualification</h3>
<p><b>Section:</b> 31 <a href="https://timsong-cpp.github.io/cppwp/input.output">[input.output]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown, Marc Paterno <b>Opened:</b> 2002-05-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following member functions are declared const, yet return non-const
pointers. We believe they are should be changed, because they allow code
that may surprise the user. See document N1360 for details and
rationale.
</p>

<p><i>[Santa Cruz: the real issue is that we've got const member
functions that return pointers to non-const, and N1360 proposes
replacing them by overloaded pairs.  There isn't a consensus about
whether this is a real issue, since we've never said what our
constness policy is for iostreams.  N1360 relies on a distinction
between physical constness and logical constness; that distinction, or
those terms, does not appear in the standard.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>In 27.4.4 and 27.4.4.2</p>
<p>Replace</p>
<pre>
  basic_ostream&lt;charT,traits&gt;* tie() const;
</pre>
<p>with</p>
<pre>
  basic_ostream&lt;charT,traits&gt;* tie();
  const basic_ostream&lt;charT,traits&gt;* tie() const;
</pre>

<p>and replace</p>
<pre>
  basic_streambuf&lt;charT,traits&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>
  basic_streambuf&lt;charT,traits&gt;* rdbuf();
  const basic_streambuf&lt;charT,traits&gt;* rdbuf() const;
</pre>

<p>In 27.5.2 and 27.5.2.3.1</p>
<p>Replace</p>
<pre>
  char_type* eback() const;
</pre>
<p>with</p>
<pre>
  char_type* eback();
  const char_type* eback() const;
</pre>

<p>Replace</p>
<pre>
  char_type gptr() const;
</pre>
<p>with</p>
<pre>
  char_type* gptr();
  const char_type* gptr() const;
</pre>

<p>Replace</p>
<pre>
  char_type* egptr() const;
</pre>
<p>with</p>
<pre>
  char_type* egptr();
  const char_type* egptr() const;
</pre>

<p>In 27.5.2 and 27.5.2.3.2</p>
<p>Replace</p>
<pre>
  char_type* pbase() const;
</pre>
<p>with</p>
<pre>
  char_type* pbase();
  const char_type* pbase() const;
</pre>

<p>Replace</p>
<pre>
  char_type* pptr() const;
</pre>
<p>with</p>
<pre>
  char_type* pptr();
  const char_type* pptr() const;
</pre>

<p>Replace</p>
<pre>
  char_type* epptr() const;
</pre>
<p>with</p>
<pre>
  char_type* epptr();
  const char_type* epptr() const;
</pre>

<p>In 27.7.2, 27.7.2.2, 27.7.3 27.7.3.2, 27.7.4, and 27.7.6</p>
<p>Replace</p>
<pre>
  basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>
  basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf();
  const basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf() const;
</pre>

<p>In  27.8.1.5, 27.8.1.7, 27.8.1.8, 27.8.1.10, 27.8.1.11, and 27.8.1.13</p>
<p>Replace</p>
<pre>
  basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>
  basic_filebuf&lt;charT,traits&gt;* rdbuf();
  const basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</pre>


<p><b>Rationale:</b></p>
<p>The existing specification is a bit sloppy, but there's no
  particular reason to change this other than tidiness, and there are
  a number of ways in which streams might have been designed
  differently if we were starting today.  There's no evidence that the
  existing constness policy is harming users.  We might consider
  a different constness policy as part of a full stream redesign.</p>





<hr>
<h3><a name="367" href="367">367.</a> remove_copy/remove_copy_if and Input Iterators</h3>
<p><b>Section:</b> 27.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2002-05-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
remove_copy and remove_copy_if (27.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>) permit their
input range to be marked with Input Iterators. However, since two
operations are required against the elements to copy (comparison and
assigment), when the input range uses Input Iterators, a temporary
copy must be taken to avoid dereferencing the iterator twice. This
therefore requires the value type of the InputIterator to be
CopyConstructible. If the iterators are at least Forward Iterators,
then the iterator can be dereferenced twice, or a reference to the
result maintained, so the temporary is not required.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add "If InputIterator does not meet the requirements of forward
iterator, then the value type of InputIterator must be copy
constructible. Otherwise copy constructible is not required." to
27.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a> paragraph 6.
</p>


<p><b>Rationale:</b></p>
<p>The assumption is that an input iterator can't be dereferenced
  twice.  There's no basis for that assumption in the Standard.</p>





<hr>
<h3><a name="368" href="368">368.</a> basic_string::replace has two "Throws" paragraphs</h3>
<p><b>Section:</b> 23.4.3.7.6 <a href="https://timsong-cpp.github.io/cppwp/string.replace">[string.replace]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2002-06-03 <b>Last modified:</b> 2016-11-12 20:15:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.replace">issues</a> in [string.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.4.3.7.6 <a href="https://timsong-cpp.github.io/cppwp/string.replace">[string.replace]</a> basic_string::replace, second
signature, given in paragraph 1, has two "Throws" paragraphs (3 and
5).
</p>

<p>
In addition, the second "Throws" paragraph (5) includes specification
(beginning with "Otherwise, the function replaces ...") that should be
part of the "Effects" paragraph.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is editorial. Both "throws" statements are true. The bug is
  just that the second one should be a sentence, part of the "Effects"
  clause, not a separate "Throws".  The project editor has been
  notified.</p>





<hr>
<h3><a name="372" href="372">372.</a> Inconsistent description of stdlib exceptions</h3>
<p><b>Section:</b> 16.4.6.13 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>, 17.8.3 <a href="https://timsong-cpp.github.io/cppwp/type.info">[type.info]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Randy Maddox <b>Opened:</b> 2002-07-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.exception.handling">issues</a> in [res.on.exception.handling].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>Paragraph 3 under clause 16.4.6.13 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>, Restrictions on
Exception Handling, states that "Any other functions defined in the
C++ Standard Library that do not have an exception-specification may
throw implementation-defined exceptions unless otherwise specified."
This statement is followed by a reference to footnote 178 at the
bottom of that page which states, apparently in reference to the C++
Standard Library, that "Library implementations are encouraged (but
not required) to report errors by throwing exceptions from (or derived
from) the standard exceptions."</p>

<p>These statements appear to be in direct contradiction to clause
17.8.3 <a href="https://timsong-cpp.github.io/cppwp/type.info">[type.info]</a>, which states "The class exception defines the
base class for the types of objects thrown as exceptions by the C++
Standard library components ...".</p>

<p>Is this inconsistent?</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Clause 17 is setting the overall library requirements, and it's
  clear and consistent.  This sentence from Clause 18 is descriptive,
  not setting a requirement on any other class.
</p>





<hr>
<h3><a name="374" href="374">374.</a> moneypunct::frac_digits returns int not unsigned</h3>
<p><b>Section:</b> 30.4.7.4.2 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct.members">[locale.moneypunct.members]</a>, 30.4.7.4.3 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct.virtuals">[locale.moneypunct.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-08-08 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 30.4.7.4.2 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct.members">[locale.moneypunct.members]</a>, frac_digits() returns type
"int". This implies that frac_digits() might return a negative value,
but a negative value is nonsensical. It should return "unsigned".
</p>

<p>
Similarly, in section 30.4.7.4.3 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct.virtuals">[locale.moneypunct.virtuals]</a>, do_frac_digits()
should return "unsigned".
</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Regardless of whether the return value is int or unsigned, it's
always conceivable that frac_digits might return a nonsensical
value. (Is 4294967295 really any better than -1?)  The clients of
moneypunct, the get and put facets, can and do perform range
checks.</p>





<hr>
<h3><a name="377" href="377">377.</a> basic_string::insert and length_error</h3>
<p><b>Section:</b> 23.4.3.7.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-08-16 <b>Last modified:</b> 2016-11-12 20:15:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.insert">issues</a> in [string.insert].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 23.4.3.7.4 <a href="https://timsong-cpp.github.io/cppwp/string.insert">[string.insert]</a>, paragraph 4, contains the following,
"Then throws <tt>length_error</tt> if <tt>size() &gt;= npos - rlen</tt>."
</p>

<p>
Related to DR 83, this sentence should probably be removed.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p><p>This requirement is redundant but correct.  No change is
needed.</p>




<hr>
<h3><a name="378" href="378">378.</a> locale immutability and locale::operator=()</h3>
<p><b>Section:</b> 30.3.1 <a href="https://timsong-cpp.github.io/cppwp/locale">[locale]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-09-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="31">31</a></p>
<p><b>Discussion:</b></p>
<p>
I think there is a problem with 22.1.1, p6 which says that
</p>
<pre>
    -6- An instance of locale is immutable; once a facet reference
        is obtained from it, that reference remains usable as long
        as the locale value itself exists.
</pre>
<p>
and 22.1.1.2, p4:
</p>
<pre>
    const locale&amp; operator=(const locale&amp; other) throw();

    -4- Effects: Creates a copy of other, replacing the current value.
</pre>
<p>
How can a reference to a facet obtained from a locale object remain
valid after an assignment that clearly must replace all the facets
in the locale object? Imagine a program such as this
</p>
<pre>
    std::locale loc ("de_DE");
    const std::ctype&lt;char> &amp;r0 = std::use_facet&lt;std::ctype&lt;char> >(loc);
    loc = std::locale ("en_US");
    const std::ctype&lt;char> &amp;r1 = std::use_facet&lt;std::ctype&lt;char> >(loc);
</pre>
<p>
Is r0 really supposed to be preserved and destroyed only when loc goes
out of scope?
</p>


<p><b>Proposed resolution:</b></p>
<p><i>[Summer '04 mid-meeting mailing: Martin and Dietmar believe this
  is a duplicate of issue <a href="31">31</a> and recommend that it be
  closed.
]</i></p>






<hr>
<h3><a name="382" href="382">382.</a> codecvt do_in/out result</h3>
<p><b>Section:</b> 30.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-08-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the descriptions of codecvt do_in() and do_out() leave
sufficient room for interpretation so that two implementations of
codecvt may not work correctly with the same filebuf. Specifically,
the following seems less than adequately specified:
</p>

<ol>
<li>
  the conditions under which the functions terminate
</li>
<li>
  precisely when the functions return ok
</li>
<li>
  precisely when the functions return partial
</li>
<li>
  the full set of conditions when the functions return error
</li>
</ol>

<ol>
<li>
   30.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a>, p2 says this about the effects of the
   function: ...Stops if it encounters a character it cannot
   convert...  This assumes that there *is* a character to
   convert. What happens when there is a sequence that doesn't form a
   valid source character, such as an unassigned or invalid UNICODE
   character, or a sequence that cannot possibly form a character
   (e.g., the sequence "\xc0\xff" in UTF-8)?
</li>
<li>
   Table 53 says that the function returns codecvt_base::ok
   to indicate that the function(s) "completed the conversion."
   Suppose that the source sequence is "\xc0\x80" in UTF-8,
   with from pointing to '\xc0' and (from_end==from + 1).
   It is not clear whether the return value should be ok
   or partial (see below).
</li>
<li>
   Table 53 says that the function returns codecvt_base::partial
   if "not all source characters converted." With the from pointers
   set up the same way as above, it is not clear whether the return
   value should be partial or ok (see above).
</li>
<li>
   Table 53, in the row describing the meaning of error mistakenly
   refers to a "from_type" character, without the symbol from_type
   having been defined. Most likely, the word "source" character
   is intended, although that is not sufficient. The functions
   may also fail when they encounter an invalid source sequence
   that cannot possibly form a valid source character (e.g., as
   explained in bullet 1 above).
</li>
</ol>
<p>
Finally, the conditions described at the end of 30.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a>, p4 don't seem to be possible:
</p>
<blockquote><p>
    "A return value of partial, if (from_next == from_end),
    indicates that either the destination sequence has not
    absorbed all the available destination elements, or that
    additional source elements are needed before another
    destination element can be produced."
</p></blockquote>
<p>
If the value is partial, it's not clear to me that (from_next
==from_end) could ever hold if there isn't enough room
in the destination buffer. In order for (from_next==from_end) to
hold, all characters in that range must have been successfully
converted (according to 30.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a>, p2) and since there are no
further source characters to convert, no more room in the
destination buffer can be needed.
</p>
<p>
It's also not clear to me that (from_next==from_end) could ever
hold if additional source elements are needed to produce another
destination character (not element as incorrectly stated in the
text). partial is returned if "not all source characters have
been converted" according to Table 53, which also implies that
(from_next==from) does NOT hold.
</p>
<p>
Could it be that the intended qualifying condition was actually
(from_next != from_end), i.e., that the sentence was supposed
to read
</p>
<blockquote><p>
    "A return value of partial, if (from_next != from_end),..."
</p></blockquote>
<p>
which would make perfect sense, since, as far as I understand it,
partial can only occur if (from_next != from_end)?
</p>
<p><i>[Lillehammer: Defer for the moment, but this really needs to be
  fixed. Right now, the description of codecvt is too vague for it to
  be a useful contract between providers and clients of codecvt
  facets.  (Note that both vendors and users can be both providers and
  clients of codecvt facets.) The major philosophical issue is whether
  the standard should only describe mappings that take a single wide
  character to multiple narrow characters (and vice versa), or whether
  it should describe fully general N-to-M conversions. When the
  original standard was written only the former was contemplated, but
  today, in light of the popularity of utf8 and utf16, that doesn't
  seem sufficient for C++0x. Bill supports general N-to-M conversions;
  we need to make sure Martin and Howard agree.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
codecvt is meant to be a 1-to-N to N-to-1 conversion. It does not work
well for N-to-M conversions. wbuffer_convert now exists, and handles
N-to-M cases. Also, there is a new specialization of codecvt that
permits UTF-16 &lt;-&gt; UTF-8 conversions.
</p>
<p>
NAD without prejudice. Will reopen if proposed resolution is supplied.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="385" href="385">385.</a> Does call by value imply the CopyConstructible requirement?</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2002-10-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many function templates have parameters that are passed by value;
a typical example is <tt>find_if</tt>'s <i>pred</i> parameter in
27.6.6 <a href="https://timsong-cpp.github.io/cppwp/alg.find">[alg.find]</a>.  Are the corresponding template parameters
(<tt>Predicate</tt> in this case) implicitly required to be
CopyConstructible, or does that need to be spelled out explicitly?
</p>

<p>
This isn't quite as silly a question as it might seem to be at first
sight.  If you call <tt>find_if</tt> in such a way that template
argument deduction applies, then of course you'll get call by value
and you need to provide a copy constructor.  If you explicitly provide
the template arguments, however, you can force call by reference by
writing something like <tt>find_if&lt;my_iterator,
my_predicate&amp;&gt;</tt>.  The question is whether implementation
are required to accept this, or whether this is ill-formed because
my_predicate&amp; is not CopyConstructible.
</p>

<p>
The scope of this problem, if it is a problem, is unknown.  Function
object arguments to generic algorithms in clauses 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>
and 28 <a href="https://timsong-cpp.github.io/cppwp/numerics">[numerics]</a> are obvious examples.  A review of the whole
library is necessary.
</p>
<p><i>[
This is really two issues.  First, predicates are typically passed by
value but we don't say they must be Copy Constructible.  They should
be. Second: is specialization allowed to transform value arguments
into references? References aren't copy constructible, so this should
not be allowed.
]</i></p>

<p><i>[
2007-01-12, Howard: First, despite the note above, references <b>are</b>
copy constructible. They just aren't assignable.  Second, this is very
closely related to <a href="92">92</a> and should be consistent with that.
That issue already says that implementations are allowed to copy
function objects.  If one passes in a reference, it is copyable, but
susceptible to slicing if one passes in a reference to a base.  Third,
with rvalue reference in the language one only needs to satisfy
MoveConstructible to pass an rvalue "by value".  Though the function
might still copy the function object internally (requiring
CopyConstructible). Finally (and fwiw), if we wanted to, it is easy to
code all of the std::algorithms such that they do not copy function
objects internally.  One merely passes them by reference internally if
desired (this has been fully implemented and shipped for several years).
 If this were mandated, it would reverse <a href="92">92</a>, allowing
function objects to reliably maintain state.  E.g. the example in <a href="92">92</a> would reliably remove only the third element.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>


<p><b>Rationale:</b></p>
<p>
Generic algorithms will be marked with concepts and these will imply a requirement
of MoveConstructible (not CopyConstructible).  The signature of the function will
then precisely describe and enforce the precise requirements.
</p>





<hr>
<h3><a name="388" href="388">388.</a> Use of <tt>complex</tt> as a key in associative containers</h3>
<p><b>Section:</b> 28.4 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2002-11-08 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Practice with <tt>std::complex&lt;&gt;</tt> and the associative containers
occasionally reveals artificial and distracting issues with constructs
resembling: <tt>std::set&lt;std::complex&lt;double&gt; &gt; s;</tt>
</p>

<p>
The main reason for the above to fail is the absence of an appropriate
definition for <tt>std::less&lt;std::complex&lt;T&gt; &gt;</tt>. That in turn comes from
the definition of the primary template <tt>std::less&lt;&gt;</tt> in terms of
<tt>operator&lt;</tt>.
</p>

<p>
The usual argument goes as follows: Since there is no ordering over
the complex field compatible with field operations it makes little
sense to define a function <tt>operator&lt;</tt> operating on the datatype
<tt>std::complex&lt;T&gt;</tt>.  That is fine. However, that reasoning does not carry
over to <tt>std::less&lt;T&gt;</tt> which is used, among other things, by associative
containers as an ordering useful to meet complexity requirements.
</p>

<p>Related issue: <a href="348">348</a>.</p>

<p><i>[
Pre Bellevue: Reopened at the request of Alisdair.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
This is a request for a design change, and not a defect in the standard.
It is in scope to consider, but the group feels that it is not a change
that we need to do. Is there a total ordering for floating point values,
including NaN? There is not a clear enough solution or big enough
problem for us to solve. Solving this problem would require solving the
problem for floating point, which is equally unclear. The LWG noted that
users who want to put objects into an associative container for which
<tt>operator&lt;</tt> isn't defined can simply provide their own comparison 
function object. NAD
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>Informally: Add a specialization of <tt>std::less</tt> for <tt>std::complex</tt>.</p>


<p><b>Rationale:</b></p>
<p>Discussed in Santa Cruz.  An overwhelming majority of the LWG
believes this should not be treated a DR: it's a request for a design
change, not a defect in the existing standard.  Most people (10-3)
believed that we probably don't want this change, period: as with
issue <a href="348">348</a>, it's hard to know where to draw the line.
The LWG noted that users who want to put objects into an associative
container for which <tt>operator&lt;</tt> isn't defined can simply
provide their own comparison function object.</p>





<hr>
<h3><a name="390" href="390">390.</a> CopyConstructible requirements too strict</h3>
<p><b>Section:</b> 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2002-10-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The CopyConstructible requirements in Table 30 state that for an
object t of type T (where T is CopyConstructible), the expression &amp;t
returns the address of t (with type T*). This requirement is overly
strict, in that it disallows types that overload operator&amp; to not
return a value of type T*. This occurs, for instance, in the <a
href="http://www.boost.org/libs/lambda">Boost.Lambda</a> library, where
operator&amp; is overloaded for a Boost.Lambda function object to return
another function object.
</p>

<p>Example:</p>

<pre>
  std::vector&lt;int&gt; u, v;
  int x;
  // ...
  std::transform(u.begin(), u.end(), std::back_inserter(v), _1 * x);
</pre>

<p>
_1 * x returns an unnamed function object with operator&amp; overloaded to
not return T* , therefore rendering the std::transform call ill-formed.
However, most standard library implementations will compile this code
properly, and the viability of such binder libraries is severely hindered
by the unnecessary restriction in the CopyConstructible requirements.
</p>

<p>
For reference, the address of an object can be retrieved without using
the address-of operator with the following function template:
</p>

<pre>
  template &lt;typename T&gt; T* addressof(T&amp; v)
  {
    return reinterpret_cast&lt;T*&gt;(
         &amp;const_cast&lt;char&amp;&gt;(reinterpret_cast&lt;const volatile char &amp;&gt;(v)));
  }
</pre>

<p>
Note: this relates directly to library issue <a href="350">350</a>, which
will need to be reexamined if the CopyConstructible requirements
change.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the last two rows of Table 30, eliminating the requirements
that &amp;t and &amp;u return the address of t and u, respectively.
</p>


<p><b>Rationale:</b></p>
<p>This was a deliberate design decision.  Perhaps it should be
   reconsidered for C++0x. </p>





<hr>
<h3><a name="392" href="392">392.</a> 'equivalence' for input iterators</h3>
<p><b>Section:</b> 25.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Corwin Joy <b>Opened:</b> 2002-12-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#input.iterators">active issues</a> in [input.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In section 25.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> table 72 -
'Input Iterator Requirements' we have as a postcondition of *a:
"If a==b and (a, b) is in the domain of == then *a is equivalent to *b".
</p>

<p>
In section 99 [istreambuf.iterator::equal] it states that
"istreambuf_iterator::equal returns true if and only if both iterators
are at end-of-stream, or neither is at end-of-stream, <i>regardless of
what streambuf object they use</i>."  (My emphasis).
</p>

<p>
The defect is that either 'equivalent' needs to be more precisely
defined or the conditions for equality in 99 [istreambuf.iterator::equal]
are incorrect. (Or both).
</p>

<p>Consider the following example:</p>
<pre>
   #include &lt;iostream&gt;
   #include &lt;fstream&gt;
   #include &lt;iterator&gt;
   using namespace std;

   int main() {
    ifstream file1("file1.txt"), file2("file2.txt");
    istreambuf_iterator&lt;char&gt; f1(file1), f2(file2);
    cout &lt;&lt; "f1 == f2 : " &lt;&lt; boolalpha &lt;&lt; (f1 == f2) &lt;&lt; endl;
    cout &lt;&lt; "f1 = " &lt;&lt; *f1 &lt;&lt; endl;
    cout &lt;&lt; "f2 = " &lt;&lt; *f2 &lt;&lt; endl;
    return 0;
   }
</pre>

<p>Now assuming that neither f1 or f2 are at the end-of-stream then
f1 == f2 by 99 [istreambuf.iterator::equal].</p>

<p>However, it is unlikely that *f1 will give the same value as *f2 except
by accident.</p>

<p>So what does *f1 'equivalent' to *f2 mean?  I think the standard should
be clearer on this point, or at least be explicit that this does not
mean that *f1 and *f2 are required to have the same value in the case
of input iterators.</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p><p>The two iterators aer not in the domain of ==</p>






<hr>
<h3><a name="393" href="393">393.</a> do_in/do_out operation on state unclear</h3>
<p><b>Section:</b> 30.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alberto Barbati <b>Opened:</b> 2002-12-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt.virtuals">issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
this DR follows the discussion on the previous thread "codecvt::do_in
not consuming external characters". It's just a clarification issue
and not a request for a change.
</p>
<p>
Can do_in()/do_out() produce output characters without consuming input 
characters as a result of operation on state?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a note at the end of 30.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a>, 
paragraph 3:
</p>

<p>
[Note: As a result of operations on state, it can return ok or partial 
and set from_next == from and to_next != to. --end note]
</p>


<p><b>Rationale:</b></p>
<p>
The submitter believes that standard already provides an affirmative
answer to the question. However, the current wording has induced a few
library implementors to make the incorrect assumption that
do_in()/do_out() always consume at least one internal character when
they succeed.
</p>

<p>
The submitter also believes that the proposed resolution is not in
conflict with the related issue 76. Moreover, by explicitly allowing
operations on state to produce characters, a codecvt implementation
may effectively implement N-to-M translations without violating the
"one character at a time" principle described in such issue. On a side
note, the footnote in the proposed resolution of issue 76 that
informally rules out N-to-M translations for basic_filebuf should be
removed if this issue is accepted as valid.
</p>


<p><i>[
Kona (2007): The proposed resolution is to add a note. Since this is
non-normative, the issue is editorial, but we believe that the note is
correct. Proposed Disposition: NAD, Editorial
]</i></p>






<hr>
<h3><a name="394" href="394">394.</a> behavior of formatted output on failure</h3>
<p><b>Section:</b> 31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-12-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a contradiction in Formatted output about what bit is
supposed to be set if the formatting fails. On sentence says it's
badbit and another that it's failbit.
</p>
<p>
27.6.2.5.1, p1 says in the Common Requirements on Formatted output
functions:
</p>
<pre>
     ... If the generation fails, then the formatted output function
     does setstate(ios::failbit), which might throw an exception.
</pre>
<p>
27.6.2.5.2, p1 goes on to say this about Arithmetic Inserters:
</p>
<p>
     ... The formatting conversion occurs as if it performed the
     following code fragment:
</p>
<pre>
     bool failed =
         use_facet&lt;num_put&lt;charT,ostreambuf_iterator&lt;charT,traits>
         > >
         (getloc()).put(*this, *this, fill(), val). failed();

     ... If failed is true then does setstate(badbit) ...
</pre>
<p>
The original intent of the text, according to Jerry Schwarz (see
c++std-lib-10500), is captured in the following paragraph:
</p>
<p>
In general "badbit" should mean that the stream is unusable because
of some underlying failure, such as disk full or socket closure;
"failbit" should mean that the requested formatting wasn't possible
because of some inconsistency such as negative widths.  So typically
if you clear badbit and try to output something else you'll fail
again, but if you clear failbit and try to output something else
you'll succeed.
</p>
<p>
In the case of the arithmetic inserters, since num_put cannot
report failure by any means other than exceptions (in response
to which the stream must set badbit, which prevents the kind of
recoverable error reporting mentioned above), the only other
detectable failure is if the iterator returned from num_put
returns true from failed().
</p>
<p>
Since that can only happen (at least with the required iostream
specializations) under such conditions as the underlying failure
referred to above (e.g., disk full), setting badbit would seem
to be the appropriate response (indeed, it is required in
27.6.2.5.2, p1). It follows that failbit can never be directly
set by the arithmetic (it can only be set by the sentry object
under some unspecified conditions).
</p>
<p>
The situation is different for other formatted output functions
which can fail as a result of the streambuf functions failing
(they may do so by means other than exceptions), and which are
then required to set failbit.
</p>
<p>
The contradiction, then, is that ostream::operator&lt;&lt;(int) will
set badbit if the disk is full, while operator&lt;&lt;(ostream&amp;,
char) will set failbit under the same conditions. To make the behavior
consistent, the Common requirements sections for the Formatted output
functions should be changed as proposed below.
</p>
<p><i>[Kona: There's agreement that this is a real issue.  What we
  decided at Kona: 1. An error from the buffer (which can be detected
  either directly from streambuf's member functions or by examining a
  streambuf_iterator) should always result in badbit getting set.
  2. There should never be a circumstance where failbit gets set.
  That represents a formatting error, and there are no circumstances
  under which the output facets are specified as signaling a
  formatting error. (Even more so for string output that for numeric
  because there's nothing to format.)  If we ever decide to make it
  possible for formatting errors to exist then the facets can signal
  the error directly, and that should go in clause 22, not clause 27.
  3. The phrase "if generation fails" is unclear and should be
  eliminated.  It's not clear whether it's intended to mean a buffer
  error (e.g. a full disk), a formatting error, or something else.
  Most people thought it was supposed to refer to buffer errors; if
  so, we should say so.  Martin will provide wording.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
NAD. This issue is already fixed.
</p></blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="397" href="397">397.</a> <tt>ostream::sentry</tt> dtor throws exceptions</h3>
<p><b>Section:</b> 31.7.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.sentry">[ostream.sentry]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.sentry">issues</a> in [ostream.sentry].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
17.4.4.8, p3 prohibits library dtors from throwing exceptions.
    </p>
    <p>
27.6.2.3, p4 says this about the ostream::sentry dtor:
    </p>
    <pre>
    -4- If ((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception())
        is true, calls os.flush().
    </pre>
    <p>
27.6.2.6, p7 that describes ostream::flush() says:
    </p>
    <pre>
    -7- If rdbuf() is not a null pointer, calls rdbuf()->pubsync().
        If that function returns ?-1 calls setstate(badbit) (which
        may throw ios_base::failure (27.4.4.3)).
    </pre>
    <p>
That seems like a defect, since both pubsync() and setstate() can
throw an exception.
    </p>
<p><i>[
The contradiction is real.  Clause 17 says destructors may never
throw exceptions, and clause 27 specifies a destructor that does
throw.  In principle we might change either one.  We're leaning
toward changing clause 17: putting in an "unless otherwise specified"
clause, and then putting in a footnote saying the sentry destructor
is the only one that can throw.  PJP suggests specifying that
sentry::~sentry() should internally catch any exceptions it might cause.
]</i></p>


<p><i>[
See <a href="418">418</a> and <a href="622">622</a> for related issues.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Move to Review. Add "Throws: nothing" to the specification of <tt>ostream::sentry::~sentry()</tt>.
</p>
</blockquote>

<p><i>[
2009-10-13 Daniel adds:
]</i></p>


<blockquote><p>
The proposed resolution of <a href="835">835</a> is written to match the outcome
of this issue.
</p></blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Move to Open.  Our intent is to solve this issue with <a href="835">835</a>.
</p></blockquote>

<p><i>[
2010-03-06 Martin updates wording.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Editorial.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="835">835</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after  [ostream::sentry] p17:
</p>

<blockquote>
<pre>
~sentry();
</pre>
<blockquote>
<p>
-17- If <tt>(os.flags() &amp; ios_base::unitbuf)</tt>
is <tt>true</tt>, calls <tt>os.flush()</tt>.
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>
</blockquote>





<hr>
<h3><a name="398" href="398">398.</a> effects of end-of-file on unformatted input functions</h3>
<p><b>Section:</b> 31.7.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.sentry">[ostream.sentry]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.sentry">issues</a> in [ostream.sentry].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
While reviewing unformatted input member functions of istream
for their behavior when they encounter end-of-file during input
I found that the requirements vary, sometimes unexpectedly, and
in more than one case even contradict established practice (GNU
libstdc++ 3.2, IBM VAC++ 6.0, STLPort 4.5, SunPro 5.3, HP aCC
5.38, Rogue Wave libstd 3.1, and Classic Iostreams).
    </p>
    <p>
The following unformatted input member functions set eofbit if they
encounter an end-of-file (this is the expected behavior, and also
the behavior of all major implementations):
    </p>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    get (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    get (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    getline (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    getline (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    ignore (int, int_type);
    </pre>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    read (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it encounters end-of-file.
    </p>
    <pre>
    streamsize readsome (char_type*, streamsize);
    </pre>

    <p>
The following unformated input member functions set failbit but
not eofbit if they encounter an end-of-file (I find this odd
since the functions make it impossible to distinguish a general
failure from a failure due to end-of-file; the requirement is
also in conflict with all major implementation which set both
eofbit and failbit):
    </p>
    <pre>
    int_type get();
    </pre>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    get (char_type&amp;);
    </pre>
    <p>
These functions only set failbit of they extract no characters,
otherwise they don't set any bits, even on failure (I find this
inconsistency quite unexpected; the requirement is also in
conflict with all major implementations which set eofbit
whenever they encounter end-of-file):
    </p>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    get (basic_streambuf&lt;charT, traits>&amp;, char_type);
    </pre>
    <pre>
    basic_istream&lt;charT, traits>&amp;
    get (basic_streambuf&lt;charT, traits>&amp;);
    </pre>
    <p>
This function sets no bits (all implementations except for
STLport and Classic Iostreams set eofbit when they encounter
end-of-file):
    </p>
    <pre>
    int_type peek ();
    </pre>
<p>Informally, what we want is a global statement of intent saying
  that eofbit gets set if we trip across EOF, and then we can take
  away the specific wording for individual functions.  A full review
  is necessary.  The wording currently in the standard is a mishmash,
  and changing it on an individual basis wouldn't make things better.
  Dietmar will do this work.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Moved to NAD.  See 31.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a> p3.
</p></blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="399" href="399">399.</a> volations of unformatted input function requirements</h3>
<p><b>Section:</b> 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
The Effects clauses for the two functions below violate the
general requirements on unformatted input functions outlined
in 27.6.1.3: they do not begin by constructing a sentry object.
Instead, they begin by calling widen ('\n'), which may throw
an exception. The exception is then allowed to propagate from
the unformatted input function irrespective of the setting of
exceptions().
    </p>
    <p>
Note that in light of 27.6.1.1, p3 and p4, the fact that the
functions allow exceptions thrown from widen() to propagate
may not strictly speaking be a defect (but the fact that the
functions do not start by constructing a sentry object still
is). However, since an exception thrown from ctype&lt;charT>
::widen() during any other input operation (say, from within
a call to num_get&lt;charT>::get()) will be caught and cause
badbit to be set, these two functions should not be treated
differently for the sake of consistency.
    </p>
  

<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Not a defect.  The standard is consistent, and the behavior required
by the standard is unambiguous.  Yes, it's theoretically possible for
widen to throw.  (Not that this will happen for the default ctype
facet or for most real-world replacement ctype facets.)  Users who
define ctype facets that can throw, and who care about this behavior,
can use alternative signatures that don't call widen.
</p>






<hr>
<h3><a name="408" href="408">408.</a> Is <tt>vector&lt;reverse_iterator&lt;char*&gt; &gt;</tt> forbidden?</h3>
<p><b>Section:</b> 25.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2003-06-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've been discussing iterator semantics with Dave Abrahams, and a 
surprise has popped up.  I don't think this has been discussed before.
</p>

<p>
25.3.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concepts">[iterator.concepts]</a> says that the only operation that can be performed on "singular"
iterator values is to assign a non-singular value to them.  (It 
doesn't say they can be destroyed, and that's probably a defect.)  
Some implementations have taken this to imply that there is no need 
to initialize the data member of a <tt>reverse_iterator&lt;&gt;</tt> in the default
constructor.  As a result, code like
</p>
<blockquote><pre>
  std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt; v(7);
  v.reserve(1000);
</pre></blockquote>
<p>
invokes undefined behavior, because it must default-initialize the
vector elements, and then copy them to other storage.  Of course many 
other vector operations on these adapters are also left undefined,
and which those are is not reliably deducible from the standard.
</p>

<p>
I don't think that 24.1 was meant to make standard-library iterator 
types unsafe.  Rather, it was meant to restrict what operations may 
be performed by functions which take general user- and standard 
iterators as arguments, so that raw pointers would qualify as
iterators.  However, this is not clear in the text, others have come 
to the opposite conclusion.
</p>

<p>
One question is whether the standard iterator adaptors have defined
copy semantics.  Another is whether they have defined destructor
semantics: is
</p>
<blockquote><pre>
  { std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt;  v(7); }
</pre></blockquote>
<p>
undefined too?
</p>

<p>
Note this is not a question of whether algorithms are allowed to
rely on copy semantics for arbitrary iterators, just whether the
types we actually supply support those operations.  I believe the 
resolution must be expressed in terms of the semantics of the 
adapter's argument type.  It should make clear that, e.g., the 
<tt>reverse_iterator&lt;T&gt;</tt> constructor is actually required to execute
<tt>T()</tt>, and so copying is defined if the result of <tt>T()</tt> is copyable.
</p>

<p>
Issue <a href="235">235</a>, which defines <tt>reverse_iterator</tt>'s default
constructor more precisely, has some relevance to this issue.
However, it is not the whole story.
</p>

<p>
The issue was whether 
</p>
<blockquote><pre>
  reverse_iterator() { }
</pre></blockquote>
<p>
is allowed, vs. 
</p>
<blockquote><pre>
  reverse_iterator() : current() { }
</pre></blockquote>

<p>
The difference is when <tt>T</tt> is <tt>char*</tt>, where the first leaves the member
uninitialized, and possibly equal to an existing pointer value, or
(on some targets) may result in a hardware trap when copied.
</p>

<p>
8.5 paragraph 5 seems to make clear that the second is required to
satisfy DR <a href="235">235</a>, at least for non-class Iterator argument
types.
</p>

<p>
But that only takes care of <tt>reverse_iterator</tt>, and doesn't establish
a policy for all iterators.  (The reverse iterator adapter was just
an example.)  In particular, does my function
</p>
<blockquote><pre>
  template &lt;typename Iterator&gt;
    void f() { std::vector&lt;Iterator&gt;  v(7); } 
</pre></blockquote>
<p>
evoke undefined behavior for some conforming iterator definitions?
I think it does, now, because <tt>vector&lt;&gt;</tt> will destroy those singular
iterator values, and that's explicitly disallowed.
</p>

<p>
24.1 shouldn't give blanket permission to copy all singular iterators,
because then pointers wouldn't qualify as iterators.  However, it
should allow copying of that subset of singular iterator values that
are default-initialized, and it should explicitly allow destroying any
iterator value, singular or not, default-initialized or not.
</p>

<p>Related issues: <a href="407">407</a>, <a href="1012">1012</a></p>
<p><i>[
We don't want to require all singular iterators to be copyable,
because that is not the case for pointers.  However, default
construction may be a special case.  Issue: is it really default
construction we want to talk about, or is it something like value
initialization?  We need to check with core to see whether default
constructed pointers are required to be copyable; if not, it would be
wrong to impose so strict a requirement for iterators.
]</i></p>


<p><i>[
2009-05-10 Alisdair provided wording.
]</i></p>


<blockquote><p>
The comments regarding destroying singular iterators have already been
resolved.  That just leaves copying (with moving implied).
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is related to LWG <a href="1012">1012</a>.
</p>
<p>
Note that there is a bug in the proposed resolution to LWG <a href="1012">1012</a>. The
change to  [reverse.iter.con] should be modified so that the word
"default" in the second sentence of the Effects clause is replaced by
"value."
</p>
<p>
We believe that the proposed fix to LWG <a href="1012">1012</a> (now corrected) is
sufficient to solve the problem for reverse_iterator. However, Alisdair
pointed out that LWG <a href="1012">1012</a> does not solve the general problem for authors
of iterator adaptors.
</p>
<p>
There are some problems with the proposed resolution. The phrase "safely
copyable" is not a term of art. Also, it mentions a
DefaultConstructible? concept.
</p>
<p>
Move to Review after Alisdair updates the wording.
</p>
</blockquote>

<p><i>[
2009-07-31 Alisdair revised wording:
]</i></p>


<p><i>[
2009-08-17 Alisdair and Daniel collaborate on slightly revised wording.
This issue depends upon <a href="724">724</a>
]</i></p>


<p><i>[
2009-10-14 Daniel adds:
]</i></p>


<blockquote><p>
There is a clear dependency on <a href="1213">1213</a>, because the term "singular",
which is used as part of the resolution, is not properly defined yet.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to Open. Alisdair will provide improved wording to make
this have "value semantics" and otherwise behave like a valid iterator.
</p></blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new paragrpah to Iterator concepts 25.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> after para 5 (the one describing
singular iterators)
</p>
<blockquote>
<p>
Just as a regular pointer to an array guarantees that there is a pointer
value pointing past the last element of the array, so for any iterator
type there is an iterator value that points past the last element of a
corresponding container. These values are called <i>past-the-end</i> values.
Values of an iterator <tt>i</tt> for which the expression <tt>*i</tt> is defined are called
<i>dereferenceable</i>. The library never assumes that past-the-end values are
dereferenceable. Iterators can also have singular values that are not
associated with any container. [<i>Example:</i> After the declaration of an
uninitialized pointer <tt>x</tt> (as with <tt>int* x;</tt>), <tt>x</tt> must always be assumed to
have a singular value of a pointer. &mdash; <i>end example</i>] Results of most
expressions are undefined for singular values; the only exceptions are
destroying an iterator that holds a singular value and the assignment of
a non-singular value to an iterator that holds a singular value. In this
case the singular value is overwritten the same way as any other value.
Dereferenceable values are always non-singular.
</p>
<p><ins>
After value-initialization, any iterator that satisfies the
<tt>DefaultConstructible</tt> requirements ([defaultconstructible]) shall not introduce undefined behaviour
when used <ins>as</ins> the
source of a copy or move operation, even if it would
otherwise be singular. [<i>Note:</i> This guarantee is not offered for
default-initialization (9.4 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>), although the distinction only
matters for types with trivial default constructors such as pointers. &mdash;
<i>end note</i>]
</ins></p>


</blockquote>






<hr>
<h3><a name="417" href="417">417.</a> what does <tt>ctype::do_widen()</tt> return on failure</h3>
<p><b>Section:</b> 30.4.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.ctype.virtuals">[locale.ctype.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.ctype.virtuals">issues</a> in [locale.ctype.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Effects and Returns clauses of the <tt>do_widen()</tt> member function of
the <tt>ctype</tt> facet fail to specify the behavior of the function on failure.
That the function may not be able to simply cast the narrow character
argument to the type of the result since doing so may yield the wrong value
for some <tt>wchar_t</tt> encodings. Popular implementations of <tt>ctype&lt;wchar_t&gt;</tt> that
use <tt>mbtowc()</tt> and UTF-8 as the native encoding (e.g., GNU glibc) will fail
when the argument's MSB is set. There is no way for the the rest of locale
and iostream to reliably detect this failure. 
</p>
<p><i>[Kona: This is a real problem.  Widening can fail.  It's unclear
  what the solution should be.  Returning <tt>WEOF</tt> works for the <tt>wchar_t</tt>
  specialization, but not in general.  One option might be to add a
  default, like <i>narrow</i>.  But that's an incompatible change.
  Using <i>traits::eof</i> might seem like a good idea, but facets
  don't have access to traits (a recurring problem).  We could
  have <i>widen</i> throw an exception, but that's a scary option;
  existing library components aren't written with the assumption
  that <i>widen</i> can throw.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
NAD. The behavior is specified for all of the facets that an
implementation is required to provide, for the basic character set.
</p></blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="418" href="418">418.</a> exceptions thrown during iostream cleanup</h3>
<p><b>Section:</b> 31.5.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/ios.init">[ios.init]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.init">issues</a> in [ios.init].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The dtor of the <tt>ios_base::Init</tt> object is supposed to call <tt>flush()</tt> on the
6 standard iostream objects <tt>cout</tt>, <tt>cerr</tt>, <tt>clog</tt>, <tt>wcout</tt>,
<tt>wcerr</tt>, and <tt>wclog</tt>.
This call may cause an exception to be thrown.
</p>

<p>
17.4.4.8, p3 prohibits all library destructors from throwing exceptions.
</p>

<p>
The question is: What should this dtor do if one or more of these calls
to <tt>flush()</tt> ends up throwing an exception? This can happen quite easily
if one of the facets installed in the locale imbued in the iostream
object throws.
</p>
<p><i>[Kona: We probably can't do much better than what we've got, so
  the LWG is leaning toward NAD.  At the point where the standard
  stream objects are being cleaned up, the usual error reporting
  mechanism are all unavailable.  And exception from <tt>flush</tt> at this
  point will definitely cause problems.  A quality implementation
  might reasonably swallow the exception, or call <tt>abort</tt>, or do
  something even more drastic.]</i></p>


<p><i>[
See <a href="397">397</a> and <a href="622">622</a> for related issues.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Moved to NAD, no consensus for change.
</p></blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="421" href="421">421.</a> is <tt>basic_streambuf</tt> copy-constructible?</h3>
<p><b>Section:</b> 31.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/streambuf.cons">[streambuf.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#streambuf.cons">issues</a> in [streambuf.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The reflector thread starting with c++std-lib-11346 notes that the class
template <tt>basic_streambuf</tt>, along with <tt>basic_stringbuf</tt> and <tt>basic_filebuf</tt>,
is copy-constructible but that the semantics of the copy constructors
are not defined anywhere. Further, different implementations behave
differently in this respect: some prevent copy construction of objects
of these types by declaring their copy ctors and assignment operators
private, others exhibit undefined behavior, while others still give
these operations well-defined semantics.
</p>

<p>
Note that this problem doesn't seem to be isolated to just the three
types mentioned above. A number of other types in the library section
of the standard provide a compiler-generated copy ctor and assignment
operator yet fail to specify their semantics.  It's believed that the
only types for which this is actually a problem (i.e. types where the
compiler-generated default may be inappropriate and may not have been
intended) are locale facets.  See issue <a href="439">439</a>.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
NAD. Option B is already in the Working Draft.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
27.5.2 [lib.streambuf]:  Add into the synopsis, public section, just above the destructor declaration:
</p>

<blockquote>
<pre>
basic_streambuf(const basic_streambuf&amp; sb);
basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>
</blockquote>

<p>Insert after 27.5.2.1, paragraph 2:</p>
<blockquote>
<pre>
basic_streambuf(const basic_streambuf&amp; sb);
</pre>

<p>Constructs a copy of <tt>sb</tt>.</p>
<p>Postcondtions:</p>
<pre>
                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<pre>
basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>

<p>Assigns the data members of <tt>sb</tt> to this.</p>

<p>Postcondtions:</p>
<pre>
                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<p>Returns: *this.</p>
</blockquote>

<p>27.7.1 [lib.stringbuf]:</p>

<p><b>Option A:</b></p>

<blockquote>
<p>Insert into the <tt>basic_stringbuf</tt> synopsis in the private section:</p>

<pre>
basic_stringbuf(const basic_stringbuf&amp;);             // not defined
basic_stringbuf&amp; operator=(const basic_stringbuf&amp;);  // not defined
</pre>
</blockquote>

<p><b>Option B:</b></p>

<blockquote>
<p>Insert into the <tt>basic_stringbuf</tt> synopsis in the public section:</p>

<pre>
basic_stringbuf(const basic_stringbuf&amp; sb);
basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);
</pre>

<p>27.7.1.1, insert after paragraph 4:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);</pre>

<p>
Constructs an independent copy of <tt>sb</tt> as if with <tt>sb.str()</tt>, and with the openmode that <tt>sb</tt> was constructed with.
</p>

<p>Postcondtions: </p>
<pre>
               str() == sb.str()
               gptr()  - eback() == sb.gptr()  - sb.eback()
               egptr() - eback() == sb.egptr() - sb.eback()
               pptr()  - pbase() == sb.pptr()  - sb.pbase()
               getloc() == sb.getloc()
</pre>

<p>
Note:  The only requirement on <tt>epptr()</tt> is that it point beyond the initialized range if an 
output sequence exists.  There is no requirement that <tt>epptr() - pbase() == sb.epptr() - sb.pbase()</tt>.
</p>

<pre>basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);</pre>
<p>
After assignment the <tt>basic_stringbuf</tt> has the same state as if it were initially copy constructed 
from <tt>sb</tt>, except that the <tt>basic_stringbuf</tt> is allowed to retain any excess capacity it 
might have, which may in turn effect the value of <tt>epptr()</tt>.
</p>
</blockquote>

<p>27.8.1.1 [lib.filebuf]</p>

<p>Insert at the bottom of the <tt>basic_filebuf</tt> synopsis:</p>

<blockquote>
<pre>
private:
  basic_filebuf(const basic_filebuf&amp;);             // not defined
  basic_filebuf&amp; operator=(const basic_filebuf&amp;);  // not defined
</pre>
</blockquote>
<p><i>[Kona: this is an issue for <tt>basic_streambuf</tt> itself and for its
  derived classes.  We are leaning toward allowing <tt>basic_streambuf</tt> to
  be copyable, and specifying its precise semantics.  (Probably the
  obvious: copying the buffer pointers.)  We are less sure whether
  the <tt>streambuf</tt> derived classes should be copyable.  Howard will
  write up a proposal.]</i></p>


<p><i>[Sydney: Dietmar presented a new argument against <tt>basic_streambuf</tt>
  being copyable: it can lead to an encapsulation violation. <tt>filebuf</tt>
  inherits from <tt>streambuf</tt>. Now suppose you inherit a <tt>my_hijacking_buf</tt>
  from <tt>streambuf</tt>. You can copy the <tt>streambuf</tt> portion of a <tt>filebuf</tt> to a
  <tt>my_hijacking_buf</tt>, giving you access to the pointers into the
  <tt>filebuf</tt>'s internal buffer. Perhaps not a very strong argument, but
  it was strong enough to make people nervous. There was weak
  preference for having <tt>streambuf</tt> not be copyable. There was weak
  preference for having <tt>stringbuf</tt> not be copyable even if <tt>streambuf</tt>
  is. Move this issue to open for now.
]</i></p>


<p><i>[
2007-01-12, Howard:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html#27.5.2%20-%20Class%20template%20basic_streambuf%3CcharT,traits%3E">Rvalue Reference Recommendations for Chapter 27</a>
recommends protected copy constructor and assignment for <tt>basic_streambuf</tt> with the same semantics
as would be generated by the compiler.  These members aid in derived classes implementing move semantics.
A protected copy constructor and copy assignment operator do not expose encapsulation more so than it is
today as each data member of a <tt>basic_streambuf</tt> is already both readable and writable by derived
classes via various get/set protected member functions (<tt>eback()</tt>, <tt>setp()</tt>, etc.).  Rather
a protected copy constructor and copy assignment operator simply make the job of derived classes implementing
move semantics less tedious and error prone.
]</i></p>




<p><b>Rationale:</b></p>
<p>
27.5.2 [lib.streambuf]: The proposed <tt>basic_streambuf</tt> copy constructor
and assignment operator are the same as currently implied by the lack
of declarations: public and simply copies the data members.  This
resolution is not a change but a clarification of the current
standard.
</p>

<p>
27.7.1 [lib.stringbuf]: There are two reasonable options: A) Make
<tt>basic_stringbuf</tt> not copyable.  This is likely the status-quo of
current implementations.  B) Reasonable copy semantics of
<tt>basic_stringbuf</tt> can be defined and implemented.  A copyable
<tt>basic_streambuf</tt> is arguably more useful than a non-copyable one.  This
should be considered as new functionality and not the fixing of a
defect.  If option B is chosen, ramifications from issue 432 are taken
into account.
</p>

<p>
27.8.1.1 [lib.filebuf]: There are no reasonable copy semantics for
<tt>basic_filebuf</tt>.
</p>






<hr>
<h3><a name="424" href="424">424.</a> normative notes</h3>
<p><b>Section:</b> 16.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/structure.summary">[structure.summary]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2016-11-12 20:15:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The text in 17.3.1.1, p1 says:
<br/>

"Paragraphs labelled "Note(s):" or "Example(s):" are informative, other
paragraphs are normative."
<br/>

The library section makes heavy use of paragraphs labeled "Notes(s),"
some of which are clearly intended to be normative (see list 1), while
some others are not (see list 2). There are also those where the intent
is not so clear (see list 3).
<br/><br/>

List 1 -- Examples of (presumably) normative Notes:
<br/>

20.2.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a>, p3,<br/>
20.2.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a>, p10,<br/>
23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a>, p11,<br/>
30.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/locale.cons">[locale.cons]</a>, p11,<br/>
24.3.8.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a>, p2,<br/>
27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a>, p3,<br/>
28.4.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a>, p15,<br/>
31.6.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/streambuf.virt.get">[streambuf.virt.get]</a>, p7.<br/>
<br/>

List 2 -- Examples of (presumably) informative Notes:
<br/>

17.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/new.delete.placement">[new.delete.placement]</a>, p3,<br/>
23.4.3.7.6 <a href="https://timsong-cpp.github.io/cppwp/string.replace">[string.replace]</a>, p14,<br/>
30.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a>, p3,<br/>
27.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a>, p4,<br/>
28.4.5 <a href="https://timsong-cpp.github.io/cppwp/complex.member.ops">[complex.member.ops]</a>, p1,<br/>
31.5.2.6 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a>, p6.<br/>
<br/>

List 3 -- Examples of Notes that are not clearly either normative
or informative:
<br/>

30.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/locale.cons">[locale.cons]</a>, p8,<br/>
30.3.1.6 <a href="https://timsong-cpp.github.io/cppwp/locale.statics">[locale.statics]</a>, p6,<br/>
31.6.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/streambuf.virt.put">[streambuf.virt.put]</a>, p4.<br/>
<br/>

None of these lists is meant to be exhaustive.
</p>

<p><i>[Definitely a real problem.  The big problem is there's material
  that doesn't quite fit any of the named paragraph categories
  (e.g. <b>Effects</b>).  Either we need a new kind of named
  paragraph, or we need to put more material in unnamed paragraphs
  jsut after the signature.  We need to talk to the Project Editor
  about how to do this.
]</i></p>


<p><i>[
Bellevue: Specifics of list 3: First 2 items correct in std (22.1.1.2,
22.1.1.5) Third item should be non-normative (27.5.2.4.5), which Pete
will handle editorially.
]</i></p>


<p><i>[
post San Francisco:  Howard: reopened, needs attention.
]</i></p>


<p><i>[Pete: I changed the paragraphs marked "Note" and "Notes" to use "Remark" and "Remarks".
Fixed as editorial.  This change has been in the WD since the post-Redmond mailing, in 2004.
Recommend NAD.]</i></p>


<p><i>[
Batavia:  We feel that the references in List 2 above should be changed from <i>Remarks</i>
to <i>Notes</i>.  We also feel that those items in List 3 need to be double checked for
the same change.  Alan and Pete to review.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
A spot-check of List 2 suggests the issue is still relevant,
and a review of List 3 still seems called-for.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="429" href="429">429.</a> typo in basic_ios::clear(iostate)</h3>
<p><b>Section:</b> 31.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="412">412</a></p>
<p><b>Discussion:</b></p>
        <p>

The Effects clause in 27.4.4.3, p5 describing the effects of a call to
the ios_base member function clear(iostate state) says that the function
only throws if the respective bits are already set prior to the function
call. That's obviously not the intent. If it was, a call to clear(badbit)
on an object for which (rdstate() == goodbit &amp;&amp; exceptions() == badbit)
holds would not result in an exception being thrown.

        </p>
    
    <p><b>Proposed resolution:</b></p>
        <p>

The text ought to be changed from
<br/>

"If (rdstate() &amp; exceptions()) == 0, returns. ..."
<br/>

to
<br/>

"If (state &amp; exceptions()) == 0, returns. ..."
        </p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="433" href="433">433.</a> Contradiction in specification of unexpected()</h3>
<p><b>Section:</b> 99 [unexpected] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Vyatcheslav Sysoltsev <b>Opened:</b> 2003-09-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause  [except.unexpected] paragraph 1 says that "void unexpected();
is called (18.7.2) immediately after completing the stack unwinding
for the former function", but 18.7.2.4 (Effects) says that "void
unexpected(); . . . Calls the unexpected_handler function in effect
immediately after evaluating the throwexpression (18.7.2.2),".  Isn't
here a contradiction: 15.5.2 requires stack have been unwound when in
void unexpected() and therefore in unexpected_handler but 18.7.2.4
claims that unexpected_handler is called "in effect immediately" after
evaluation of throw expression is finished, so there is no space left
for stack to be unwound therefore?  I think the phrase "in effect
immediately" should be removed from the standard because it brings
ambiguity in understanding.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>There is no contradiction.  The phrase "in effect immediately" is
  just to clarify which handler is to be called.</p>





<hr>
<h3><a name="437" href="437">437.</a> Formatted output of function pointers is confusing</h3>
<p><b>Section:</b> 31.7.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.arithmetic">[ostream.inserters.arithmetic]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ivan Godard <b>Opened:</b> 2003-10-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.inserters.arithmetic">issues</a> in [ostream.inserters.arithmetic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given:
</p>
<pre>
void f(int) {}
void(*g)(int) = f;
cout &lt;&lt; g;
</pre>

<p>
(with the expected #include and usings), the value printed is a rather
surprising "true". Rather useless too.
</p>

<p>The standard defines:</p>

<pre>ostream&amp; operator&lt;&lt;(ostream&amp;, void*);</pre>

<p>which picks up all data pointers and prints their hex value, but does
not pick up function pointers because there is no default conversion
from function pointer to void*. Absent that, we fall back to legacy
conversions from C and the function pointer is converted to bool.
</p>

<p>There should be an analogous inserter that prints the address of a
  function pointer.</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is indeed a wart, but there is no good way to solve it.  C
  doesn't provide a portable way of outputting the address of a
  function point either.</p>





<hr>
<h3><a name="439" href="439">439.</a> Should facets be copyable?</h3>
<p><b>Section:</b> 30.4 <a href="https://timsong-cpp.github.io/cppwp/locale.categories">[locale.categories]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-11-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The following facets classes have no copy constructors described in
  the standard, which, according to the standard, means that they are
  supposed to use the compiler-generated defaults.  Default copy
  behavior is probably inappropriate.  We should either make these
  classes uncopyable or else specify exactly what their constructors do.</p>

<p>Related issue: <a href="421">421</a>.</p>

<pre>
        ctype_base
        ctype
        ctype_byname
        ctype&lt;char>
        ctype_byname&lt;char>
        codecvt_base
        codecvt
        codecvt_byname
        num_get
        num_put
        numpunct
        numpunct_byname
        collate
        collate_byname
        time_base
        time_get
        time_get_byname
        time_put
        time_put_byname
        money_get
        money_put
        money_base
        moneypunct
        moneypunct_byname
        messages_base
        messages
        messages_byname
</pre>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The copy constructor in the base class is private.</p>





<hr>
<h3><a name="440" href="440">440.</a> Should std::complex use unqualified transcendentals?</h3>
<p><b>Section:</b> 28.4.8 <a href="https://timsong-cpp.github.io/cppwp/complex.transcendentals">[complex.transcendentals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-11-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.transcendentals">issues</a> in [complex.transcendentals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Operations like <tt>pow</tt> and <tt>exp</tt> on
<tt>complex&lt;T&gt;</tt> are typically implemented in terms of
operations like <tt>sin</tt> and <tt>cos</tt> on <tt>T</tt>.  
Should implementations write this as <tt>std::sin</tt>, or as plain
unqualified <tt>sin</tt>?
</p>

<p>The issue, of course, is whether we want to use
argument-dependent lookup in the case where <tt>T</tt> is a
user-defined type.  This is similar to the issue of valarray
transcendentals, as discussed in issue <a href="226">226</a>.</p>

<p>This issue differs from valarray transcendentals in two important
ways.  First, "the effect of instantiating the template
<tt>complex</tt> for types other than float, double or long double is
unspecified." (28.4.2 <a href="https://timsong-cpp.github.io/cppwp/complex.syn">[complex.syn]</a>) Second, the standard does not
dictate implementation, so there is no guarantee that a particular
real math function is used in the implementation of a particular
complex function.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>If you instantiate std::complex for user-defined types, all bets
are off.</p>





<hr>
<h3><a name="446" href="446">446.</a> Iterator equality between different containers</h3>
<p><b>Section:</b> 25.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a>, 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Andy Koenig <b>Opened:</b> 2003-12-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What requirements does the standard place on equality comparisons between
iterators that refer to elements of different containers.  For example, if
<tt>v1</tt> and <tt>v2</tt> are empty vectors, is <tt>v1.end() == v2.end()</tt> 
allowed to yield true? Is it allowed to throw an exception?
</p>

<p>
The standard appears to be silent on both questions.
</p>
<p><i>[Sydney: The intention is that comparing two iterators from
different containers is undefined, but it's not clear if we say that,
or even whether it's something we should be saying in clause 23 or in
clause 24.  Intuitively we might want to say that equality is defined
only if one iterator is reachable from another, but figuring out how
to say it in any sensible way is a bit tricky: reachability is defined
in terms of equality, so we can't also define equality in terms of
reachability.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Daniel volunteered to work on this.
</p></blockquote>

<p><i>[
2009-09-20 Daniel provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave as Open. Alisdair has volunteered to refine the wording.
</p></blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph between 25.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a>/7+8:
</p>

<blockquote>
<p>
[..] The result of the application of functions in the library to invalid
ranges is undefined.
</p>

<p><ins>The result of directly or indirectly evaluating any comparison function
or the binary - operator with two iterator values as arguments that
were obtained
from two different ranges <tt>r1</tt> and <tt>r2</tt> (including their past-the-end values) which
are not subranges of one common range is undefined, unless explicitly
described otherwise.</ins>
</p>

</blockquote>






<hr>
<h3><a name="447" href="447">447.</a> Wrong template argument for time facets</h3>
<p><b>Section:</b> 30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2003-12-26 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="327">327</a></p>
<p><b>Discussion:</b></p>
<p>
22.1.1.1.1/4, table 52, "Required Instantiations", lists, among others:
</p>
<pre>
    time_get&lt;char,InputIterator>
    time_get_byname&lt;char,InputIterator>
    time_get&lt;wchar_t,OutputIterator>
    time_get_byname&lt;wchar_t,OutputIterator>
</pre>

<p>
The second argument to the last two should be InputIterator, not
OutputIterator.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the second template argument to InputIterator.
</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="450" href="450">450.</a> set::find is inconsistent with associative container requirements</h3>
<p><b>Section:</b> 24.4.6 <a href="https://timsong-cpp.github.io/cppwp/set">[set]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#set">issues</a> in [set].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="214">214</a></p>
<p><b>Discussion:</b></p>
<p>map/multimap have:</p>

<pre>
    iterator find(const key_type&amp; x) const;
    const_iterator find(const key_type&amp; x) const;
</pre>

<p>
which is consistent with the table of associative container requirements.
But set/multiset have:
</p>
<pre>
    iterator find(const key_type&amp;) const;
</pre>

<p>
set/multiset should look like map/multimap, and honor the requirements
table, in this regard.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="451" href="451">451.</a> Associative erase should return an iterator</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 24.4 <a href="https://timsong-cpp.github.io/cppwp/associative">[associative]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="130">130</a></p>
<p><b>Discussion:</b></p>
<p>map/multimap/set/multiset have:</p>
<pre>
    void erase(iterator);
    void erase(iterator, iterator);
</pre>

<p>But there's no good reason why these can't return an iterator, as for
vector/deque/list:</p>
<pre>
    iterator erase(iterator);
    iterator erase(iterator, iterator);
</pre>



<p><b>Proposed resolution:</b></p>
<p>
Informally: The table of associative container requirements, and the
relevant template classes, should return an iterator designating the
first element beyond the erased subrange.
</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="452" href="452">452.</a>  locale::combine should be permitted to generate a named locale</h3>
<p><b>Section:</b> 30.3.1.4 <a href="https://timsong-cpp.github.io/cppwp/locale.members">[locale.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.members">issues</a> in [locale.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<pre>
template&lt;class Facet>
    locale::combine(const locale&amp;) const;
</pre>
<p>
is obliged to create a locale that has no name. This is overspecification
and overkill. The resulting locale should follow the usual rules -- it
has a name if the locale argument has a name and Facet is one of the
standard facets.
</p>

<p><i>[
 Sydney and post-Sydney (see c++std-lib-13439, c++std-lib-13440,
 c++std-lib-13443): agreed that it's overkill to say that the locale
 is obligated to be nameless.  However, we also can't require it to
 have a name.  At the moment, locale names are based on categories
 and not on individual facets.  If a locale contains two different
 facets of different names from the same category, then this would
 not fit into existing naming schemes.  We need to give
 implementations more freedom.  Bill will provide wording.
]</i></p>




<p><b>Rationale:</b></p>
<p>After further discussion the LWG decided to close this as NAD.
  The fundamental problem is that names right now are per-category,
  not per-facet.  The <tt>combine</tt> member function works at the
  wrong level of granularity.</p>





<hr>
<h3><a name="454" href="454">454.</a> <tt>basic_filebuf::open</tt> should accept <tt>wchar_t</tt> names</h3>
<p><b>Section:</b> 31.10.2.4 <a href="https://timsong-cpp.github.io/cppwp/filebuf.members">[filebuf.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="105">105</a></p>
<p><b>Discussion:</b></p>
<pre>
    basic_filebuf *basic_filebuf::open(const char *, ios_base::open_mode);
</pre>

<p>should be supplemented with the overload:</p>

<pre>
    basic_filebuf *basic_filebuf::open(const wchar_t *, ios_base::open_mode);
</pre>

<p>
Depending on the operating system, one of these forms is fundamental and
the other requires an implementation-defined mapping to determine the
actual filename.
</p>

<p><i>[Sydney: Yes, we want to allow <tt>wchar_t</tt> filenames.  Bill will
  provide wording.]</i></p>


<p><i>[
In Toronto we noted that this is issue 5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1569.htm">N1569</a>.
]</i></p>

<p>
How does this interact with the newly-defined character types, and how
do we avoid interface explosion considering <tt>std::string</tt> overloads that
were added? Propose another solution that is different than the
suggestion proposed by PJP.
</p>
<p>
Suggestion is to make a member template function for <tt>basic_string</tt> (for
<tt>char</tt>, <tt>wchar_t</tt>, <tt>u16char</tt>, <tt>u32char</tt> instantiations), and then just keep a
<tt>const char*</tt> member.
</p>
<p>
Goal is to do implicit conversion between character string literals to
appropriate <tt>basic_string</tt> type. Not quite sure if this is possible.
</p>
<p>
Implementors are free to add specific overloads for non-char character
types.
</p>

<p><i>[
Martin adds pre-Sophia Antipolis:
]</i></p>


<blockquote><p>
Please see <a href="http://wiki.dinkumware.com/twiki/pub/Wg21sophiaAntipolis/LibraryWorkingGroup/issue-454.html">issue 454: problems and solutions</a>.
</p></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Beman is concerned that making these changes to <tt>basic_filebuf</tt> is not
usefully changed unless <tt>fstream</tt> is also changed; this also only handles
<tt>wchar_t</tt> and not other character types.
</p>
<p>
The TR2 filesystem library is a more complete solution, but is not available soon.
</p>
</blockquote>

<p><i>[
Martin adds:  please reference
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2683.html">N2683</a> for
problems and solutions.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>Change from:</p>
<blockquote>
<pre>
basic_filebuf&lt;charT,traits>* open(
    const char* s,
    ios_base::openmode mode );
</pre>

<p>
Effects: If is_open() != false, returns a null pointer.
Otherwise, initializes the filebuf as required. It then
opens a file, if possible, whose name is the NTBS s ("as if"
by calling std::fopen(s,modstr)).</p>
</blockquote>

<p>to:</p>

<blockquote>
<pre>
basic_filebuf&lt;charT,traits>* open(
    const char* s,
    ios_base::openmode mode );

basic_filebuf&lt;charT,traits>* open(
    const wchar_t* ws,
    ios_base::openmode mode );
</pre>

<p>
<i>Effects</i>: If <tt>is_open() != false</tt>, returns a null pointer.
Otherwise, initializes the <tt>filebuf</tt> as required. It then
opens a file, if possible, whose name is the NTBS <tt>s</tt> ("as if"
by calling <tt>std::fopen(s,modstr)</tt>).
For the second signature, the NTBS <tt>s</tt> is determined from the
WCBS <tt>ws</tt> in an implementation-defined manner.
</p>

<p>
(NOTE: For a system that "naturally" represents a filename
as a WCBS, the NTBS s in the first signature may instead
be mapped to a WCBS; if so, it follows the same mapping
rules as the first argument to open.)
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Slightly controversial, but by a 7-1 straw poll the LWG agreed to move
this to Ready.  The controversy was because the mapping between wide
names and files in a filesystem is implementation defined.  The
counterargument, which most but not all LWG members accepted, is that
the mapping between narrow files names and files is also
implemenation defined.</p>

<p><i>[Lillehammer: Moved back to "open" status, at Beman's urging.
(1) Why just basic_filebuf, instead of also basic_fstream (and
possibly other things too). (2) Why not also constructors that take
std::basic_string? (3) We might want to wait until we see Beman's
filesystem library; we might decide that it obviates this.]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
Move again to Ready.
</p>
<p>
There is a timing issue here. Since the filesystem library will not be
in C++0x, this should be brought forward. This solution would remain
valid in the context of the proposed filesystem.
</p>
<p>
This issue has been kicking around for a while, and the wchar_t addition
alone would help many users. Thus, we suggest putting this on the
reflector list with an invitation for someone to produce proposed
wording that covers basic_fstream. In the meantime, we suggest that the
proposed wording be adopted as-is.
</p>
<p>
If more of the Lillehammer questions come back, they should be
introduced as separate issues.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Some existing implementations provide overload already. Expected
filesystem "path" object overloads neatly, without surprises; implying
NAD.
</p></blockquote>







<hr>
<h3><a name="458" href="458">458.</a> 24.1.5 contains unintended limitation for <tt>operator-</tt></h3>
<p><b>Section:</b> 25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2004-02-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 24.1.5 [lib.random.access.iterators], table 76 the operational
semantics for the expression "<tt>r -= n</tt>" are defined as "<tt>return r += -n</tt>".
This means, that the expression <tt>-n</tt> must be valid, which is not the case
for unsigned types.
</p>

<p><i>[
Sydney: Possibly not a real problem, since difference type is required
to be a signed integer type. However, the wording in the standard may
be less clear than we would like.
]</i></p>


<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
This issue refers to a requirements table we have removed.
</p>
<p>
The issue might now relate to 25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a> p5.
However, the rationale in the issue already recognises that the
<tt>difference_type</tt> must be signed, so this really looks NAD.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with Alisdair's observations.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Need to look at again without concepts.
</p>
<p>
There was a question about this phrase in the discussion: "the
expression <tt>-n</tt> must be valid, which is not the case for unsigned types."
If <tt>n</tt> is an object of the iterator <tt>difference_type</tt> (eg <tt>ptrdiff_t</tt>), 
then it is never unsigned.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
The group reviewed the wording in the draft and agreed that <tt>n</tt> is of
difference type, the difference type is signed, and the current wording
is correct.  Moved to NAD.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
To remove this limitation, I suggest to change the
operational semantics for this column to:
</p>
<blockquote><pre>
    { Distance m = n;
      if (m >= 0)
        while (m--) --r;
      else
        while (m++) ++r;
      return r; }
</pre></blockquote>






<hr>
<h3><a name="459" href="459">459.</a> Requirement for widening in stage 2 is overspecification</h3>
<p><b>Section:</b> 30.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-03-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>When parsing strings of wide-character digits, the standard
  requires the library to widen narrow-character "atoms" and compare
  the widened atoms against the characters that are being parsed.
  Simply narrowing the wide characters would be far simpler, and
  probably more efficient.  The two choices are equivalent except in
  convoluted test cases, and many implementations already ignore the
  standard and use narrow instead of widen.</p>

<p>
First, I disagree that using narrow() instead of widen() would
necessarily have unfortunate performance implications. A possible
implementation of narrow() that allows num_get to be implemented
in a much simpler and arguably comparably efficient way as calling
widen() allows, i.e. without making a virtual call to do_narrow every
time, is as follows:
</p>

<pre>
  inline char ctype&lt;wchar_t>::narrow (wchar_t wc, char dflt) const
  {
      const unsigned wi = unsigned (wc);

      if (wi > UCHAR_MAX)
          return typeid (*this) == typeid (ctype&lt;wchar_t>) ?
                 dflt : do_narrow (wc, dflt);

      if (narrow_ [wi] &lt; 0) {
         const char nc = do_narrow (wc, dflt);
         if (nc == dflt)
             return dflt;
         narrow_ [wi] = nc;
      }

      return char (narrow_ [wi]);
  }
</pre>

<p>
Second, I don't think the change proposed in the issue (i.e., to use
narrow() instead of widen() during Stage 2) would be at all
drastic. Existing implementations with the exception of libstdc++
currently already use narrow() so the impact of the change on programs
would presumably be isolated to just a single implementation. Further,
since narrow() is not required to translate alternate wide digit
representations such as those mentioned in issue <a href="303">303</a> to
their narrow equivalents (i.e., the portable source characters '0'
through '9'), the change does not necessarily imply that these
alternate digits would be treated as ordinary digits and accepted as
part of numbers during parsing. In fact, the requirement in 30.4.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.ctype.virtuals">[locale.ctype.virtuals]</a>, p13 forbids narrow() to translate an alternate
digit character, wc, to an ordinary digit in the basic source
character set unless the expression
(ctype&lt;charT>::is(ctype_base::digit, wc) == true) holds. This in
turn is prohibited by the C standard (7.25.2.1.5, 7.25.2.1.5, and
5.2.1, respectively) for charT of either char or wchar_t.
</p>

<p><i>[Sydney: To a large extent this is a nonproblem. As long as
you're only trafficking in char and wchar_t we're only dealing with a
stable character set, so you don't really need either 'widen' or
'narrow': can just use literals. Finally, it's not even clear whether
widen-vs-narrow is the right question; arguably we should be using
codecvt instead.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
NAD. The standard is clear enough as written.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>Change stage 2 so that implementations are permitted to use either
technique to perform the comparison:</p>
<ol>
  <li> call widen on the atoms and compare (either by using
      operator== or char_traits&lt;charT>::eq) the input with
      the widened atoms, or</li>
  <li> call narrow on the input and compare the narrow input
      with the atoms</li>
  <li> do (1) or (2) only if charT is not char or wchar_t,
      respectively; i.e., avoid calling widen or narrow
      if it the source and destination types are the same</li>
</ol>





<hr>
<h3><a name="462" href="462">462.</a> Destroying objects with static storage duration</h3>
<p><b>Section:</b> 6.9.3.4 <a href="https://timsong-cpp.github.io/cppwp/basic.start.term">[basic.start.term]</a>, 17.4 <a href="https://timsong-cpp.github.io/cppwp/cstdint">[cstdint]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-03-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
3.6.3 Termination spells out in detail the interleaving of static
destructor calls and calls to functions registered with atexit. To
match this behavior requires intimate cooperation between the code
that calls destructors and the exit/atexit machinery. The former
is tied tightly to the compiler; the latter is a primitive mechanism
inherited from C that traditionally has nothing to do with static
construction and destruction. The benefits of intermixing destructor
calls with atexit handler calls is questionable at best, and <i>very</i>
difficult to get right, particularly when mixing third-party C++
libraries with different third-party C++ compilers and C libraries
supplied by still other parties.
</p>

<p>
I believe the right thing to do is defer all static destruction
until after all atexit handlers are called. This is a change in
behavior, but one that is likely visible only to perverse test
suites. At the very least, we should <i>permit</i> deferred destruction
even if we don't require it.
</p>

<p><i>[If this is to be changed, it should probably be changed by CWG.
  At this point, however, the LWG is leaning toward NAD.  Implementing
  what the standard says is hard work, but it's not impossible and
  most vendors went through that pain years ago.  Changing this
  behavior would be a user-visible change, and would break at least
  one real application.]</i></p>


<p><i>[
Batavia:  Send to core with our recommendation that we should permit deferred
destruction but not require it.
]</i></p>


<p><i>[
Howard:  The course of action recommended in Batavia would undo LWG
issue <a href="3">3</a> and break current code implementing the "phoenix
singleton". Search the net for "phoenix singleton atexit" to get a feel
for the size of the adverse impact this change would have.  Below is
sample code which implements the phoenix singleton and would break if
<tt>atexit</tt> is changed in this way:
]</i></p>


<blockquote><pre>
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;new&gt;

class A
{
    bool alive_;
    A(const A&amp;);
    A&amp; operator=(const A&amp;);
public:
    A() : alive_(true) {std::cout &lt;&lt; "A()\n";}
    ~A() {alive_ = false; std::cout &lt;&lt; "~A()\n";}
    void use()
    {
        if (alive_)
            std::cout &lt;&lt; "A is alive\n";
        else
            std::cout &lt;&lt; "A is dead\n";
    }
};

void deallocate_resource();

// This is the phoenix singleton pattern
A&amp; get_resource(bool create = true)
{
    static std::aligned_storage&lt;sizeof(A), std::alignment_of&lt;A&gt;::value&gt;::type buf;
    static A* a;
    if (create)
    {
        if (a != (A*)&amp;buf)
        {
            a = ::new (&amp;buf) A;
            std::atexit(deallocate_resource);
        }
    }
    else
    {
        a-&gt;~A();
        a = (A*)&amp;buf + 1;
    }
    return *a;
}

void deallocate_resource()
{
    get_resource(false);
}

void use_A(const char* message)
{
    A&amp; a = get_resource();
    std::cout &lt;&lt; "Using A " &lt;&lt; message &lt;&lt; "\n";
    a.use();
}

struct B
{
    ~B() {use_A("from ~B()");}
};

B b;

int main()
{
    use_A("from main()");
}
</pre></blockquote>

<p>
The correct output is:
</p>

<blockquote><pre>
A()
Using A from main()
A is alive
~A()
A()
Using A from ~B()
A is alive
~A()
</pre></blockquote>

<p><i>[
Bellevue: Confirmed no interaction with <tt>quick_exit</tt>.
Strong feeling against mandating the change. Leaning towards NAD rather than permitting the change,
as this would make common implementations of pheonix-singleton pattern implementation defined, as noted by Howard.
Bill agrees issue is no longer serious, and accepts NAD.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="463" href="463">463.</a> <tt>auto_ptr</tt> usability issues</h3>
<p><b>Section:</b> 99 [auto.ptr] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2003-12-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
TC1 CWG DR #84 effectively made the <tt>template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;()</tt>
member of <tt>auto_ptr</tt> (20.4.5.3/4) obsolete.
</p>

<p>
The sole purpose of this obsolete conversion member is to enable copy
initialization base from r-value derived (or any convertible types like
cv-types) case:
</p>
<pre>
#include &lt;memory&gt;
using std::auto_ptr;

struct B {};
struct D : B {};

auto_ptr&lt;D&gt; source();
int sink(auto_ptr&lt;B&gt;);
int x1 = sink( source() ); // #1 EDG - no suitable copy constructor
</pre>

<p>
The excellent analysis of conversion operations that was given in the final
<tt>auto_ptr</tt> proposal
(http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1997/N1128.pdf)
explicitly specifies this case analysis (case 4). DR #84 makes the analysis
wrong and actually comes to forbid the loophole that was exploited by the
<tt>auto_ptr</tt> designers.
</p>

<p>
I didn't encounter any compliant compiler (e.g. EDG, GCC, BCC and VC) that
ever allowed this case. This is probably because it requires 3 user defined
conversions and in fact current compilers conform to DR #84.
</p>

<p>
I was surprised to discover that the obsolete conversion member actually has
negative impact of the copy initialization base from l-value derived
case:</p>
<pre>
auto_ptr&lt;D&gt; dp;
int x2 = sink(dp); // #2 EDG - more than one user-defined conversion applies
</pre>

<p>
I'm sure that the original intention was allowing this initialization using
the <tt>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp; a)</tt> constructor (20.4.5.1/4) but
since in this copy initialization it's merely user defined conversion (UDC)
and the obsolete conversion member is UDC with the same rank (for the early
overloading stage) there is an ambiguity between them.
</p>

<p>
Removing the obsolete member will have impact on code that explicitly
invokes it:
</p>
<pre>
int y = sink(source().operator auto_ptr&lt;B>());
</pre>

<p>
IMHO no one ever wrote such awkward code and the reasonable workaround for
#1 is:
</p>
<pre>
int y = sink( auto_ptr&lt;B>(source()) );
</pre>

<p>
I was even more surprised to find out that after removing the obsolete
conversion member the initialization was still ill-formed:
<tt>int x3 = sink(dp); // #3 EDG - no suitable copy constructor</tt>
</p>

<p>
This copy initialization semantically requires copy constructor which means
that both template conversion constructor and the <tt>auto_ptr_ref</tt> conversion
member (20.4.5.3/3) are required which is what was explicitly forbidden in
DR #84. This is a bit amusing case in which removing ambiguity results with
no candidates.
</p>

<p>
I also found exception safety issue with <tt>auto_ptr</tt> related to <tt>auto_ptr_ref</tt>:
</p>
<pre>
int f(auto_ptr&lt;B>, std::string);
auto_ptr&lt;B> source2();

// string constructor throws while auto_ptr_ref
// "holds" the pointer
int x4 = f(source2(), "xyz"); // #4
</pre>

<p>
The theoretic execution sequence that will cause a leak:
</p>
<ol>
<li>call auto_ptr&lt;B>::operator auto_ptr_ref&lt;B>()</li>
<li>call string::string(char const*) and throw</li>
</ol>

<p>
According to 20.4.5.3/3 and 20.4.5/2 the <tt>auto_ptr_ref</tt> conversion member
returns <tt>auto_ptr_ref&lt;Y&gt;</tt> that holds <tt>*this</tt> and this is another defect since
the type of <tt>*this</tt> is <tt>auto_ptr&lt;X&gt;</tt> where <tt>X</tt> might 
be different from <tt>Y</tt>. Several library vendors (e.g. SGI) implement 
<tt>auto_ptr_ref&lt;Y&gt;</tt> with <tt>Y*</tt> as member which
is much more reasonable. Other vendor implemented <tt>auto_ptr_ref</tt> as
defectively required and it results with awkward and catastrophic code:
<tt>int oops = sink(auto_ptr&lt;B>(source())); // warning recursive on all control paths</tt>
</p>

<p>
Dave Abrahams noticed that there is no specification saying that
<tt>auto_ptr_ref</tt> copy constructor can't throw.
</p>

<p>
My proposal comes to solve all the above issues and significantly simplify
<tt>auto_ptr</tt> implementation. One of the fundamental requirements from 
<tt>auto_ptr</tt> is that it can be constructed in an intuitive manner (i.e. 
like ordinary pointers) but with strict ownership semantics which yield that source
<tt>auto_ptr</tt> in initialization must be non-const. My idea is to add additional
constructor template with sole propose to generate ill-formed, diagnostic
required, instance for const auto_ptr arguments during instantiation of
declaration. This special constructor will not be instantiated for other
types which is achievable using 14.8.2/2 (SFINAE). Having this constructor
in hand makes the constructor <tt>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y> const&amp;)</tt>
legitimate since the actual argument can't be const yet non const r-value
are acceptable.
</p>

<p>
This implementation technique makes the "private auxiliary class"
<tt>auto_ptr_ref</tt> obsolete and I found out that modern C++ compilers (e.g. EDG,
GCC and VC) consume the new implementation as expected and allow all
intuitive initialization and assignment cases while rejecting illegal cases
that involve const <tt>auto_ptr</tt> arguments.
</p>

<p>The proposed auto_ptr interface:</p>

<pre>
namespace std {
    template&lt;class X&gt; class auto_ptr {
    public:
        typedef X element_type;

        // 20.4.5.1 construct/copy/destroy:
        explicit auto_ptr(X* p=0) throw();
        auto_ptr(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;) throw();
        auto_ptr&amp; operator=(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;) throw();
        ~auto_ptr() throw();

        // 20.4.5.2 members:
        X&amp; operator*() const throw();
        X* operator->() const throw();
        X* get() const throw();
        X* release() throw();
        void reset(X* p=0) throw();

    private:
        template&lt;class U&gt;
        auto_ptr(U&amp; rhs, typename
unspecified_error_on_const_auto_ptr&lt;U&gt;::type = 0);
    };
}
</pre>

<p>
One compliant technique to implement the <tt>unspecified_error_on_const_auto_ptr</tt>
helper class is using additional private <tt>auto_ptr</tt> member class template like
the following:
</p>
<pre>
template&lt;typename T&gt; struct unspecified_error_on_const_auto_ptr;

template&lt;typename T&gt;
struct unspecified_error_on_const_auto_ptr&lt;auto_ptr&lt;T&gt; const&gt;
{ typedef typename auto_ptr&lt;T&gt;::const_auto_ptr_is_not_allowed type; };
</pre>

<p>
There are other techniques to implement this helper class that might work
better for different compliers (i.e. better diagnostics) and therefore I
suggest defining its semantic behavior without mandating any specific
implementation. IMO, and I didn't found any compiler that thinks otherwise,
14.7.1/5 doesn't theoretically defeat the suggested technique but I suggest
verifying this with core language experts.
</p>

<p><b>Further changes in standard text:</b></p>
<p>Remove section 20.4.5.3</p>

<p>Change 20.4.5/2 to read something like:
Initializing <tt>auto_ptr&lt;X&gt;</tt> from <tt>const auto_ptr&lt;Y&gt;</tt> will result with unspecified
ill-formed declaration that will require unspecified diagnostic.</p>

<p>Change 20.4.5.1/4,5,6 to read:</p>

<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp; a) throw();</pre>
<p> 4 <i>Requires</i>: <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.</p>
<p> 5 <i>Effects</i>: Calls <tt>const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(a).release()</tt>.</p>
<p> 6 <i>Postconditions</i>: <tt>*this</tt> holds the pointer returned from <tt>a.release()</tt>.</p>

<p>Change 20.4.5.1/10</p>
<pre>
template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt; a) throw();
</pre>
<p>
10 <i>Requires</i>: <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>. The expression <tt>delete
get()</tt> is well formed.
</p>

<p>LWG TC DR #127 is obsolete.</p>

<p>
Notice that the copy constructor and copy assignment operator should remain
as before and accept non-<tt>const auto_ptr&amp;</tt> since they have effect on the form
of the implicitly declared copy constructor and copy assignment operator of
class that contains auto_ptr as member per 12.8/5,10:
</p>
<pre>
struct X {
    // implicit X(X&amp;)
    // implicit X&amp; operator=(X&amp;)
    auto_ptr&lt;D> aptr_;
};
</pre>

<p>
In most cases this indicates about sloppy programming but preserves the
current <tt>auto_ptr</tt> behavior.
</p>

<p>
Dave Abrahams encouraged me to suggest fallback implementation in case that
my suggestion that involves removing of <tt>auto_ptr_ref</tt> will not be accepted.
In this case removing the obsolete conversion member to <tt>auto_ptr&lt;Y&gt;</tt> and
20.4.5.3/4,5 is still required in order to eliminate ambiguity in legal
cases. The two constructors that I suggested will co exist with the current
members but will make <tt>auto_ptr_ref</tt> obsolete in initialization contexts.
<tt>auto_ptr_ref</tt> will be effective in assignment contexts as suggested in DR
#127 and I can't see any serious exception safety issues in those cases
(although it's possible to synthesize such). <tt>auto_ptr_ref&lt;X&gt;</tt> semantics will
have to be revised to say that it strictly holds pointer of type <tt>X</tt> and not
reference to an <tt>auto_ptr</tt> for the favor of cases in which <tt>auto_ptr_ref&lt;Y&gt;</tt> is
constructed from <tt>auto_ptr&lt;X&gt;</tt> in which <tt>X</tt> is different from 
<tt>Y</tt> (i.e. assignment from r-value derived to base).
</p>

<p><i>[Redmond: punt for the moment. We haven't decided yet whether we
  want to fix auto_ptr for C++-0x, or remove it and replace it with
  move_ptr and unique_ptr.]</i></p>


<p><i>[
Oxford 2007: Recommend NAD.  We're just going to deprecate it.  It still works for simple use cases
and people know how to deal with it.  Going forward <tt>unique_ptr</tt> is the recommended
tool.
]</i></p>


<p><i>[
2007-11-09: Reopened at the request of David Abrahams, Alisdair Meredith and Gabriel Dos Reis.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
This is a complicated issue, so we agreed to defer discussion until
later in the week so that interested parties can read up on it.
</p></blockquote>

<p><i>[
2009-10-04 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest to close this issue as NAD. The reasons are two-fold: First, the
suggested proposed resolution uses no longer appropriate language means
to solve this issue, which has the effect that the recommended resolution is
another - but better - form of hack. Second, either following the suggested
resolution or the now more natural alternative via the added member set
</p>

<blockquote><pre>
template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp;&amp;) throw();
template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp;) throw();
</pre></blockquote>

<p>
would still have a non-zero probability to break user-code that actively
references <tt>auto_ptr_ref</tt>. This risk seems to indicate that a
decision which would not touch the current spec of <tt>auto_ptr</tt> at
all (but deprecating it) and instead recommending to use
<tt>unique_ptr</tt> for new code instead might have the best
cost-benefit ratio. IMO the current solution of <a href="1100">1100</a> can
be considered as an active user-support for this transition.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD. Alisdair will open a new issue (<a href="1247">1247</a>) with
proposed wording to handle <tt>auto_ptr_ref</tt>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 99 [auto.ptr]:
</p>

<blockquote><pre>
namespace std { 
  <del>template &lt;class Y&gt; struct auto_ptr_ref {};</del>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt; struct constant_object;</ins>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt;</ins>
  <ins>struct cannot_transfer_ownership_from</ins>
    <ins>: constant_object&lt;T&gt; {};</ins>

  template &lt;class X&gt; class auto_ptr { 
  public: 
    typedef X element_type; 

    // D.9.1.1 construct/copy/destroy: 
    explicit auto_ptr(X* p =0) throw(); 
    auto_ptr(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp;) throw(); 
    auto_ptr&amp; operator=(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del>) throw();
    <del>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw();</del>
    ~auto_ptr() throw(); 

    // D.9.1.2 members: 
    X&amp; operator*() const throw();
    X* operator-&gt;() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    <del>// D.9.1.3 conversions:</del>
    <del>auto_ptr(auto_ptr_ref&lt;X&gt;) throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() throw();</del>

    <ins>// exposition only</ins>
    <ins>template&lt;class U&gt;</ins>
    <ins>auto_ptr(U&amp; rhs, typename cannot_transfer_ownership_from&lt;U&gt;::error = 0);</ins>
  }; 

  template &lt;&gt; class auto_ptr&lt;void&gt; 
  { 
  public: 
    typedef void element_type; 
  }; 

}
</pre></blockquote>

<p>
Remove 99 [auto.ptr.conv].
</p>

<p>
Change 99 [auto.ptr], p3:
</p>

<blockquote><p>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the object it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same object at
the same time the behavior of the program is undefined. <ins>Templates
<tt>constant_object</tt> and <tt>cannot_transfer_ownership_from</tt>,
and the final constructor of <tt>auto_ptr</tt> are for exposition only.
For any types <tt>X</tt> and <tt>Y</tt>, initializing
<tt>auto_ptr&lt;X&gt;</tt> from <tt>const auto_ptr&lt;Y&gt;</tt> is
ill-formed, diagnostic required.</ins> [<i>Note:</i> The uses of
<tt>auto_ptr</tt> include providing temporary exception-safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. <tt>auto_ptr</tt> does not meet the <tt>CopyConstructible</tt>
and <tt>Assignable</tt> requirements for Standard Library container
elements and thus instantiating a Standard Library container with an
<tt>auto_ptr</tt> results in undefined behavior. <i>-- end note</i>]
</p></blockquote>

<p>
Change  [auto.ptr.cons], p5:
</p>

<blockquote>
<pre>
template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp; a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
</p>
<p>
<i>Effects:</i> Calls <ins><tt>const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(</tt></ins><tt>a</tt><ins><tt>)</tt></ins><tt>.release()</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>*this</tt> holds the pointer returned from <tt>a.release()</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change  [auto.ptr.cons], p10:
</p>

<blockquote>
<pre>
template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del> a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
The expression <tt>delete get()</tt> is well formed.
</p>
<p>
<i>Effects:</i> Calls <tt>reset(a.release())</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="466" href="466">466.</a> <tt>basic_string</tt> ctor should prevent null pointer error</h3>
<p><b>Section:</b> 23.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.require">[string.require]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2004-06-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Today, my colleagues and me wasted a lot of time. After some time, I
found the problem. It could be reduced to the following short example:
</p>

<pre>
  #include &lt;string&gt;
  int main() { std::string( 0 ); }
</pre>

<p>The problem is that the tested compilers (GCC 2.95.2, GCC 3.3.1 and
Comeau online) compile the above without errors or warnings! The
programs (at least for the GCC) resulted in a SEGV.</p>

<p>I know that the standard explicitly states that the ctor of string
requires a <tt>char*</tt> which is not zero. STLs could easily detect the above
case with a private ctor for <tt>basic_string</tt> which takes a single '<tt>int</tt>'
argument. This would catch the above code at compile time and would not
ambiguate any other legal ctors.</p>

<p><i>[Redmond: No great enthusiasm for doing this.  If we do,
  however, we want to do it for all places that take <tt>charT*</tt>
  pointers, not just the single-argument constructor.  The other
  question is whether we want to catch this at compile time (in which
  case we catch the error of a literal 0, but not an expression whose
  value is a null pointer), at run time, or both.
  Recommend NAD.  Relegate this functionality to debugging implementations.]</i></p>


<p><i>[
Post Summit: Alisdair requests this be re-opened as several new language facilities are
designed to solve exactly this kind of problem.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We are unable to achieve consensus on an approach to a resolution.
There is some sentiment for treating this as a QOI matter.
It is also possible
that when <tt>string</tt> is brought into the concepts world,
this issue might be addressed in that context.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We considered three options:
</p>

<ul>
<li>The proposed resolution.</li>
<li>NAD</li>
<li>Interpret a null pointer as the empty string.</li>
</ul>

<p>
The consensus was NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>
</p>

<blockquote><pre>
<ins>basic_string( nullptr_t ) = delete;</ins>
</pre></blockquote>





<hr>
<h3><a name="470" href="470">470.</a> accessing containers from their elements' special functions</h3>
<p><b>Section:</b> 24 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The standard doesn't prohibit the destructors (or any other special
functions) of containers' elements invoked from a member function
of the container from "recursively" calling the same (or any other)
member function on the same container object, potentially while the
container is in an intermediate state, or even changing the state
of the container object while it is being modified. This may result
in some surprising (i.e., undefined) behavior.
</p>

<p>Read email thread starting with c++std-lib-13637 for more.</p>



<p><b>Proposed resolution:</b></p>

<p>Add to Container Requirements the following new paragraph:</p>

<pre>
    Unless otherwise specified, the behavior of a program that
    invokes a container member function f from a member function
    g of the container's value_type on a container object c that
    called g from its mutating member function h, is undefined.
    I.e., if v is an element of c, directly or indirectly calling
    c.h() from v.g() called from c.f(), is undefined.
</pre>

<p><i>[Redmond: This is a real issue, but it's probably a clause 17
  issue, not clause 23.  We get the same issue, for example, if we
  try to destroy a stream from one of the stream's callback functions.]</i></p>

  


<p><b>Rationale:</b></p>
<p>
Recommend NAD.  We agree this is an issue, but not a defect.
We believe that there is no wording we can put in the standard
that will cover all cases without introducing unfortunate
corner cases.
</p>





<hr>
<h3><a name="472" href="472">472.</a> Missing "Returns" clause in std::equal_range</h3>
<p><b>Section:</b> 27.8.4.4 <a href="https://timsong-cpp.github.io/cppwp/equal.range">[equal.range]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Prateek R Karandikar <b>Opened:</b> 2004-06-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#equal.range">issues</a> in [equal.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="270">270</a></p>
<p><b>Discussion:</b></p>
<p>
There is no "Returns:" clause for std::equal_range, which returns non-void.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Fixed as part of issue <a href="270">270</a>.</p>






<hr>
<h3><a name="476" href="476">476.</a> Forward Iterator implied mutability</h3>
<p><b>Section:</b> 25.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-07-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>24.1/3 says:</p>
<blockquote><p>
  Forward iterators satisfy all the requirements of the input and
  output iterators and can be used whenever either kind is specified
</p></blockquote>

<p>
The problem is that satisfying the requirements of output iterator
means that you can always assign *something* into the result of
dereferencing it.  That makes almost all non-mutable forward
iterators non-conforming.  I think we need to sever the refinement
relationship between forward iterator and output iterator.
</p>

<p>Related issue: <a href="200">200</a>.  But this is not a dup.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Yes, 24.1/3 does say that. But it's introductory material. The
precise specification is in 24.1.3, and the requrements table there is
right.  We don't need to fine-tune introductory wording.  (Especially
since this wording is likely to be changed as part of the iterator
overhaul.)</p> 





<hr>
<h3><a name="477" href="477">477.</a> Operator-> for const forward iterators</h3>
<p><b>Section:</b> 25.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-07-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="478">478</a></p>
<p><b>Discussion:</b></p>
<p>
The Forward Iterator requirements table contains the following:
</p>
<pre>
 expression  return type         operational  precondition
                                  semantics
  ==========  ==================  ===========  ==========================
  a->m        U&amp; if X is mutable, (*a).m       pre: (*a).m is well-defined.
              otherwise const U&amp;

  r->m        U&amp;                  (*r).m       pre: (*r).m is well-defined.
</pre>

<p>
The first line is exactly right.  The second line is wrong.  Basically
it implies that the const-ness of the iterator affects the const-ness
of referenced members.  But Paragraph 11 of [lib.iterator.requirements] says:
</p>

<blockquote><p>
   In the following sections, a and b denote values of type const X, n
   denotes a value of the difference type Distance, u, tmp, and m
   denote identifiers, r denotes a value of X&amp;, t denotes a value of
   value type T, o denotes a value of some type that is writable to
   the output iterator.
</p></blockquote>

<p>AFAICT if we need the second line at all, it should read the same
as the first line.</p>

<p>Related issue: <a href="478">478</a></p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that this is a real problem.  Marked as a DUP
  because the LWG chose to adopt the solution proposed in
  <a href="478">478</a>.
</p>





<hr>
<h3><a name="479" href="479">479.</a> Container requirements and placement new</h3>
<p><b>Section:</b> 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2004-08-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="580">580</a></p>
<p><b>Discussion:</b></p>
<p>Nothing in the standard appears to make this program ill-formed:</p>

<pre>
  struct C {
    void* operator new( size_t s ) { return ::operator new( s ); }
    // NOTE: this hides in-place and nothrow new
  };

  int main() {
    vector&lt;C> v;
    v.push_back( C() );
  }
</pre>

<p>Is that intentional?  We should clarify whether or not we intended
  to require containers to support types that define their own special
  versions of <tt>operator new</tt>.</p>

<p><i>[
Lillehammer: A container will definitely never use this overridden
operator new, but whether it will fail to compile is unclear from the
standard.  Are containers supposed to use qualified or unqualified
placement new?  20.4.1.1 is somewhat relevant, but the standard
doesn't make it completely clear whether containers have to use
Allocator::construct(). If containers don't use it, the details of how
containers use placement new are unspecified. That is the real bug,
but it needs to be fixed as part of the allocator overhaul.  Weak
support that the eventual solution should make this code well formed.
]</i></p>




<p><b>Proposed resolution:</b></p>







<hr>
<h3><a name="480" href="480">480.</a> unary_function and binary_function should have protected nonvirtual destructors</h3>
<p><b>Section:</b> 99 [depr.base] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2004-08-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.base">issues</a> in [depr.base].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The classes std::unary_function and std::binary_function are both
designed to be inherited from but contain no virtual functions.  This
makes it too easy for a novice programmer to write code like
binary_function&lt;int, int, int> *p = new plus&lt;int>; delete p;</p>

<p>There are two common ways to prevent this source of undefined
behavior: give the base class a public virtual destructor, or give it
a protected nonvirtual destructor.  Since unary_function and
binary_function have no other virtual functions, (note in particular
the absence of an operator()() ), it would cost too much to give them
public virtual destructors.  Therefore, they should be given protected
nonvirtual destructors.</p>


<p><b>Proposed resolution:</b></p>
<p>Change Paragraph 20.3.1 of the Standard from</p>
<pre>
    template &lt;class Arg, class Result>
    struct unary_function {
        typedef Arg argument_type;
        typedef Result result_type;
    };

    template &lt;class Arg1, class Arg2, class Result>
    struct binary_function {
        typedef Arg1 first_argument_type;
        typedef Arg2 second_argument_type;
        typedef Result result_type;
    };
</pre>

<p>to</p>
<pre>
    template &lt;class Arg, class Result>
        struct unary_function {
        typedef Arg argument_type;
        typedef Result result_type;
    protected:
        ~unary_function() {}
    };

    template &lt;class Arg1, class Arg2, class Result>
    struct binary_function {
        typedef Arg1 first_argument_type;
        typedef Arg2 second_argument_type;
        typedef Result result_type;
    protected:
        ~binary_function() {}
    };
</pre>


<p><b>Rationale:</b></p>
<p>The LWG doesn't believe the existing definition causes anybody any
  concrete harm.</p>





<hr>
<h3><a name="481" href="481">481.</a> unique's effects on the range [result, last)</h3>
<p><b>Section:</b> 27.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2004-08-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard says that unique(first, last) "eliminates all but the
first element from every consecutive group of equal elements" in
[first, last) and returns "the end of the resulting range".  So a
postcondition is that [first, result) is the same as the old [first,
last) except that duplicates have been eliminated.
</p>

<p>What postconditions are there on the range [result, last)?  One
  might argue that the standard says nothing about those values, so
  they can be anything.  One might also argue that the standard
  doesn't permit those values to be changed, so they must not be.
  Should the standard say something explicit one way or the other?</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>We don't want to make many guarantees about what's in [result,
end). Maybe we aren't being quite explicit enough about not being
explicit, but it's hard to think that's a major problem.</p>





<hr>
<h3><a name="483" href="483">483.</a> Heterogeneous equality and EqualityComparable</h3>
<p><b>Section:</b> 27.6 <a href="https://timsong-cpp.github.io/cppwp/alg.nonmodifying">[alg.nonmodifying]</a>, 27.7 <a href="https://timsong-cpp.github.io/cppwp/alg.modifying.operations">[alg.modifying.operations]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2004-09-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="283">283</a></p>
<p><b>Discussion:</b></p>
<p>c++std-lib-14262</p>

<p>[lib.alg.find] requires T to be EqualityComparable:</p>

<pre>
template &lt;class InputIterator, class T>
   InputIterator find(InputIterator first, InputIterator last,
                      const T&amp; value);
</pre>

<p>
However the condition being tested, as specified in the Effects
clause, is actually *i == value, where i is an InputIterator.
</p>

<p>
The two clauses are in agreement only if the type of *i is T, but this
isn't necessarily the case. *i may have a heterogeneous comparison
operator that takes a T, or a T may be convertible to the type of *i.
</p>

<p>Further discussion (c++std-lib-14264): this problem affects a
  number of algorithsm in clause 25, not just <tt>find</tt>.  We
  should try to resolve this problem everywhere it appears.</p>


<p><b>Proposed resolution:</b></p>

<p>[lib.alg.find]:</p>
<blockquote><p>
   Remove [lib.alg.find]/1.
</p></blockquote>

<p>[lib.alg.count]:</p>
<blockquote><p>
   Remove [lib.alg.count]/1.
</p></blockquote>

<p>[lib.alg.search]:</p>
<blockquote><p>
   Remove "Type T is EqualityComparable (20.1.1), " from [lib.alg.search]/4.
</p></blockquote>

<p>[lib.alg.replace]:</p>

<blockquote>
   <p>
   Remove [lib.alg.replace]/1.
   Replace [lb.alg.replace]/2 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [first, last) for which *i == value
       or pred(*i) holds perform *i = new_value.
       </p></blockquote>

   <p>
   Remove the first sentence of /4.
   Replace the beginning of /5 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [result, result + (last -
       first)), assign to *i either...
       </p></blockquote>

   <p>(Note the defect here, current text says assign to i, not *i).</p>
</blockquote>

<p>[lib.alg.fill]:</p>

<blockquote>
   <p>
   Remove "Type T is Assignable (23.1), " from /1.
   Replace /2 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [first, last) or [first, first + n),
       perform *i = value.
       </p></blockquote>
</blockquote>

<p>[lib.alg.remove]:</p>
<blockquote><p>
   Remove /1.
   Remove the first sentence of /6.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>Duplicate of (a subset of) issue <a href="283">283</a>.</p>






<hr>
<h3><a name="486" href="486">486.</a> min/max CopyConstructible requirement is too strict</h3>
<p><b>Section:</b> 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-10-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="281">281</a></p>
<p><b>Discussion:</b></p>
<p>A straightforward implementation of these algorithms does not need to
copy T.</p>


<p><b>Proposed resolution:</b></p>
<p>drop the the words "and CopyConstructible" from paragraphs 1 and 4</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="487" href="487">487.</a> Allocator::construct is too limiting</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dhruv Matani <b>Opened:</b> 2004-10-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard's version of allocator::construct(pointer,
const_reference) severely limits what you can construct using this
function.  Say you can construct a socket from a file descriptor. Now,
using this syntax, I first have to manually construct a socket from
the fd, and then pass the constructed socket to the construct()
function so it will just to an uninitialized copy of the socket I
manually constructed. Now it may not always be possible to copy
construct a socket eh! So, I feel that the changes should go in the
allocator::construct(), making it:
</p>
<pre>
    template&lt;typename T>
    struct allocator{
      template&lt;typename T1>
      void construct(pointer T1 const&amp; rt1);
    };
</pre>

<p>
Now, the ctor of the class T which matches the one that takes a T1 can
be called! Doesn't that sound great?
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>NAD. STL uses copying all the time, and making it possible for
  allocators to construct noncopyable objects is useless in the
  absence of corresponding container changes. We might consider this
  as part of a larger redesign of STL.</p>





<hr>
<h3><a name="489" href="489">489.</a> std::remove / std::remove_if wrongly specified</h3>
<p><b>Section:</b> 27.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 25.2.7 [lib.alg.remove], paragraphs 1 to 5 describe the
behavior of the mutating sequence operations std::remove and
std::remove_if. However, the wording does not reflect the intended
behavior [Note: See definition of intended behavior below] of these
algorithms, as it is known to the C++ community [1].
</p>



<p>1) Analysis of current wording:</p>


<p>25.2.7 [lib.alg.remove], paragraph 2:</p>

<p>Current wording says:
"Effects: Eliminates all the elements referred to by iterator i in the
range [first, last) for which the following corresponding conditions
hold: *i == value, pred(*i) != false."</p>

<p>
This sentences expresses specifically that all elements denoted by the
(original) range [first, last) for which the corresponding condition
hold will be eliminated. Since there is no formal definition of the term
"eliminate" provided, the meaning of "eliminate" in everyday language
implies that as postcondition, no element in the range denoted by
[first, last) will hold the corresponding condition on reiteration over
the range [first, last).
</p>

<p>
However, this is neither the intent [Note: See definition of intended
behavior below] nor a general possible approach. It can be easily proven
that if all elements of the original range[first, last) will hold the
condition, it is not possible to substitute them by an element for which
the condition will not hold.
</p>


<p>25.2.7 [lib.alg.remove], paragraph 3:</p>

<p>
Current wording says:
"Returns: The end of the resulting range."
</p>

<p>
The resulting range is not specified. In combination with 25.2.7
[lib.alg.remove], paragraph 2, the only reasonable interpretation of
this so-called resulting range is the range [first,last) - thus
returning always the ForwardIterator 'last' parameter.
</p>


<p>
25.2.7 [lib.alg.remove], paragraph 4:
</p>

<p>
Current wording says:
"Notes: Stable: the relative order of the elements that are not removed
is the same as their relative order in the original range"
</p>

<p>
This sentences makes use of the term "removed", which is neither
specified, nor used in a previous paragraph (which uses the term
"eliminate"), nor unamgiuously separated from the name of the algorithm.
</p>


<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the intended
behavior was that all elements of the range [first, last) which do not
hold the condition *i == value (std::remove) or  pred(*i) != false
(std::remove_if)], call them s-elements [Note: s...stay], will be placed
into a contiguous subrange of [first, last), denoted by the iterators
[first, return value). The number of elements in the resulting range
[first, return value) shall be equal to the number of s-elements in the
original range [first, last). The relative order of the elements in the
resulting subrange[first, return value) shall be the same as the
relative order of the corresponding elements in the original range. It
is undefined whether any elements in the resulting subrange [return
value, last) will hold the corresponding condition, or not.
</p>

<p>
All implementations known to the author of this Defect Report comply
with this intent. Since the intent  of the behavior (contrary to the
current wording) is also described in various utility references serving
the C++ community [1], it is not expected that fixing the paragraphs
will influence current code - unless the code relies on the behavior as
it is described by current wording and the implementation indeed
reflects the current wording, and not the intent.
</p>



<p>3) Proposed fixes:</p>


<p>Change 25.2.7 [lib.alg.remove], paragraph 2 to:</p>

<p>
"Effect: Places all the elements referred to by iterator i in the range
[first, last) for which the following corresponding conditions hold :
!(*i == value), pred(*i) == false into the subrange [first, k) of the
original range, where k shall denote a value of type ForwardIterator. It
is undefined whether any elements in the resulting subrange [k, last)
will hold the corresponding condition, or not."
</p>

<p>Comments to the new wording:</p>

<p>
a) "Places" has no special meaning, and the everyday language meaning
should fit.
b) The corresponding conditions were negated compared to the current
wording, becaue the new wording requires it.
c) The wording "of the original range" might be redundant, since any
subrange starting at 'first' and containing no more elements than the
original range is implicitly a subrange of the original range [first,
last).
d) The iterator k was introduced instead of "return value" in order to
avoid a cyclic dependency on 25.2.7/3. The wording ", where k shall
denote a value of type ForwardIterator" might be redundant, because it
follows implicitly by 25.2.7/3.
e) "Places" does, in the author's opinion, explicitly forbid duplicating
any element holding the corresponding condition in the original range
[first, last) within the resulting range [first, k). If there is doubt
this term might be not unambiguous regarding this, it is suggested that
k is specified more closely by the following wording: "k shall denote a
value of type ForwardIterator [Note: see d)] so that k - first is equal
to the number of elements in the original range [first, last) for which
the corresponding condition did hold". This could also be expressed as a
separate paragraph "Postcondition:"
f) The senctence "It is undefined whether any elements in the resulting
subrange [k, last) will hold the corresponding condition, or not." was
added consciously so the term "Places" does not imply if the original
range [first, last) contains n elements holding the corresponding
condition, the identical range[first, last) will also contain exactly n
elements holding the corresponding condition after application of the
algorithm.
</p>

<p>
Change 25.2.7 [lib.alg.remove], paragraph 3 to:

"Returns: The iterator k."
</p>

<p>
Change 25.2.7 [lib.alg.remove], paragraph 4 to:

"Notes: Stable: the relative order of the elements that are placed into
the subrange [first, return value) shall be the same as their relative
order was in the original range [first, last) prior to application of
the algorithm."
</p>

<p>
Comments to the new wording:
</p>

<p>
a) the wording "was ...  prior to application of the algorithm" is used
to explicitly distinguish the original range not only by means of
iterators, but also by a 'chronological' factor from the resulting range
[first, return value). It might be redundant.
</p>

<p>
[1]:
The wording of these references is not always unambiguous, and provided
examples partially contradict verbal description of the algorithms,
because the verbal description resembles the problematic wording of
ISO/IEC 14882:2003.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG believes that the standard is sufficiently clear, and that
  there is no evidence of any real-world confusion about this point.</p>





<hr>
<h3><a name="490" href="490">490.</a> std::unique wrongly specified</h3>
<p><b>Section:</b> 27.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 25.2.8 [lib.alg.unique], paragraphs 1 to 3 describe the
behavior of the mutating sequence operation std::unique. However, the
wording does not reflect the intended behavior [Note: See definition of
intended behavior below] of these algorithms, as it is known to the C++
community [1].</p>



<p>1) Analysis of current wording:</p>


<p>25.2.8 [lib.alg.unique], paragraph 1:</p>

<p>
Current wording says:
"Effects: Eliminates all but the first element from every consecutive
group of equal elements referred to by the iterator i in the range
[first, last) for which the following corresponding conditions hold: *i
== *(i - 1) or pred(*i, *(i -1)) != false"
</p>

<p>
This sentences expresses specifically that all elements denoted by the
(original) range [first, last) which are not but the first element from
a consecutive group of equal elements (where equality is defined as *i
== *(i - 1) or pred(*i, *(i - 1)) ! = false) [Note: See DR 202], call
them r-elements [Note: r...remove], will be eliminated. Since there is
no formal definition of the term "eliminate" provided, it is undefined
how this "elimination" takes place. But the meaning of "eliminate" in
everyday language seems to disallow explicitly that after application of
the algorithm, any r-element will remain at any position of the range
[first, last) [2].
</p>

<p>
Another defect in the current wording concerns the iterators used to
compare two elements for equality: The current wording contains the
expression "(i - 1)", which is not covered by 25/9 [Note: See DR
submitted by Thomas Mang regarding invalid iterator arithmetic
expressions].
</p>


<p>
25.2.8 [lib.alg.unique], paragraph 2:
</p>
<p>Current wording says:
"Returns: The end of the resulting range."</p>

<p>
The resulting range is not specified. In combination with 25.2.8
[lib.alg.unique], paragraph 1, one reasonable interpretation (in the
author's opinion even the only possible interpretation) of this
so-called resulting range is the range [first, last) - thus returning
always the ForwardIterator 'last' parameter.
</p>

<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the intended
behavior was that all elements denoted by the original range [first,
last) which are the first element from a consecutive group of elements
for which the corresponding conditions: *(i-1) == *i (for the version of
unique without a predicate argument) or pred(*(i-1), *i) ! = false (for
the version of unique with a predicate argument) [Note: If such a group
of elements consists of only a single element, this is also considered
the first element] [Note: See resolutions of DR 202], call them
s-elements [Note: s...stay], will be placed into a contiguous subrange
of [first, last), denoted by the iterators [first, return value). The
number of elements in the resulting range [first, return value) shall be
equal to the number of s-elements in the original range [first, last).
Invalid iterator arithmetic expressions are expected to be resolved as
proposed in DR submitted by Thomas Mang regarding invalid iterator
arithmetic expressions. It is also assumed by the author that the
relative order of the elements in the resulting subrange [first, return
value) shall be the same as the relative order of the corresponding
elements (the s-elements) in the original range [Note: If this was not
intended behavior, the additional proposed paragraph about stable order
will certainly become obsolete].
Furthermore, the resolutions of DR 202 are partially considered.
</p>

<p>
All implementations known to the author of this Defect Report comply
with this intent [Note: Except possible effects of DR 202]. Since this
intent of the behavior (contrary to the current wording) is also
described in various utility references serving the C++ community [1],
it is not expected that fixing the paragraphs will influence current
code [Note: Except possible effects of DR 202] - unless the code relies
on the behavior as it is described by current wording and the
implementation indeed reflects the current wording, and not the intent.
</p>



<p>3) Proposed fixes:</p>

<p>
Change 25.2.8 [lib.alg.unique], paragraph 1 to:
</p>

<p>
"Effect: Places the first element from every consecutive group of
elements, referred to by the iterator i in the range [first, last), for
which the following conditions hold: *(i-1) == *i (for the version of
unique without a predicate argument) or pred(*(i -1), *i) != false (for
the version of unique with a predicate argument), into the subrange
[first, k) of the original range, where k shall denote a value of type
ForwardIterator."
</p>

<p>Comments to the new wording:</p>

<p>
a) The new wording was influenced by the resolutions of DR 202. If DR
202 is resolved in another way, the proposed wording need also
additional review.
b) "Places" has no special meaning, and the everyday language meaning
should fit.
c) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
d) The wording "(for the version of unique without a predicate
argument)" and "(for the version of unique with a predicate argument)"
was added consciously for clarity and is in resemblence with current
23.2.2.4 [lib.list.ops], paragraph 19. It might be considered redundant.
e) The wording "of the original range" might be redundant, since any
subrange starting at first and containing no more elements than the
original range is implicitly a subrange of the original range [first,
last).
f) The iterator k was introduced instead of "return value" in order to
avoid a cyclic dependency on 25.2.8 [lib.alg.unique], paragraph 2. The
wording ", where k shall denote a value of type ForwardIterator" might
be redundant, because it follows implicitly by 25.2.8 [lib.alg.unique],
paragraph 2.
g) "Places" does, in the author's opinion, explicitly forbid duplicating
any s-element in the original range [first, last) within the resulting
range [first, k). If there is doubt this term might be not unambiguous
regarding this, it is suggested that k is specified more closely by the
following wording: "k shall denote a value of type ForwardIterator
[Note: See f)] so that k - first is equal to the number of elements in
the original range [first, last) being the first element from every
consecutive group of elements for which the corresponding condition did
hold". This could also be expressed as a separate paragraph
"Postcondition:".
h) If it is considered that the wording is unclear whether it declares
the element of a group which consists of only a single element
implicitly to be the first element of this group [Note: Such an
interpretation could eventually arise especially in case last - first ==
1] , the following additional sentence is proposed: "If such a group of
elements consists of only a single element, this element is also
considered the first element."
</p>

<p>
Change 25.2.8 [lib.alg.unique], paragraph 2 to:
"Returns: The iterator k."
</p>

<p>
Add a separate paragraph "Notes:" as 25.2.8 [lib.alg.unique], paragraph
2a or 3a, or a separate paragraph "Postcondition:" before 25.2.8
[lib.alg.unique], paragraph 2 (wording inside {} shall be eliminated if
the preceding expressions are used, or the preceding expressions shall
be eliminated if wording inside {} is used):
</p>

<p>
"Notes:{Postcondition:} Stable: the relative order of the elements that
are placed into the subrange [first, return value {k}) shall be the same
as their relative order was in the original range [first, last) prior to
application of the algorithm."
</p>

<p>Comments to the new wording:</p>

<p>
a) It is assumed by the author that the algorithm was intended to be
stable.
In case this was not the intent, this paragraph becomes certainly
obsolete.
b) The wording "was ...  prior to application of the algorithm" is used
to explicitly distinguish the original range not only by means of
iterators, but also by a 'chronological' factor from the resulting range
[first, return value). It might be redundant.
</p>

<p>
25.2.8 [lib.alg.unique], paragraph 3:
</p>
<p>See DR 239.</p>

<p>
4) References to other DRs:
</p>

<p>
See DR 202, but which does not address any of the problems described in
this Defect Report [Note: This DR is supposed to complement DR 202].
See DR 239.
See DR submitted by Thomas Mang regarding invalid iterator arithmetic
expressions.
</p>

<p>
[1]:
The wording of these references is not always unambiguous, and provided
examples partially contradict verbal description of the algorithms,
because the verbal description resembles the problematic wording of
ISO/IEC 14882:2003.
</p>

<p>
[2]:
Illustration of conforming implementations according to current wording:
</p>

<p>
One way the author of this DR considers how this "elimination" could be
achieved by a conforming implementation according to current wording is
by substituting each r-element by _any_ s-element [Note: s...stay; any
non-r-element], since all r-elements are "eliminated".
</p>

<p>
In case of a sequence consisting of elements being all 'equal' [Note:
See DR 202], substituting each r-element by the single s-element is the
only possible solution according to current wording.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG believes the standard is sufficiently clear. No
implementers get it wrong, and changing it wouldn't cause any code to
change, so there is no real-world harm here.</p>





<hr>
<h3><a name="491" href="491">491.</a> std::list&lt;>::unique incorrectly specified</h3>
<p><b>Section:</b> 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraphs 19 to 21 describe the
behavior of the std::list&lt;T, Allocator>::unique operation. However, the
current wording is defective for various reasons.</p>



<p>
1) Analysis of current wording:
</p>

<p>24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph 19:</p>

<p>
Current wording says:
"Effects:  Eliminates all but the first element from every consecutive
group of equal elements referred to by the iterator i in the range
[first + 1, last) for which *i == *(i - 1) (for the version of unique
with no argument) or pred(*i, *(i -1)) (for the version of unique with a
predicate argument) holds."</p>

<p>
This sentences makes use of the undefined term "Eliminates". Although it
is, to a certain degree, reasonable to consider the term "eliminate"
synonymous with "erase", using "Erase" in the first place, as the
wording of 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph 15 does, would be clearer.</p>

<p>
The range of the elements referred to by iterator i is "[first + 1,
last)". However, neither "first" nor "last" is defined.</p>

<p>
The sentence makes three times use of iterator arithmetic expressions (
"first + 1", "*i == *(i - 1)", "pred(*i, *(i -1))" ) which is not
defined for bidirectional iterator [see DR submitted by Thomas Mang
regarding invalid iterator arithmetic expressions].</p>

<p>
The same problems as pointed out in DR 202 (equivalence relation / order
of arguments for pred()) apply to this paragraph.</p>

<p>
24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph 20:
</p>

<p>
Current wording says:
"Throws: Nothing unless an exception in thrown by *i == *(i-1) or
pred(*i, *(i - 1))"</p>

<p>
The sentence makes two times use of invalid iterator arithmetic
expressions ( "*i == *(i - 1)", "pred(*i, *(i -1))" ).
</p>
<p>
[Note: Minor typos: "in" / missing dot at end of sentence.]
</p>

<p>
24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph 21:</p>

<p>
Current wording says:
"Complexity: If the range (last - first) is not empty, exactly (last -
first) - 1 applications of the corresponding predicate, otherwise no
application of the predicate.</p>

<p>
See DR 315 regarding "(last - first)" not yielding a range.</p>

<p>
Invalid iterator arithmetic expression "(last - first) - 1" left .</p>


<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that "eliminate" is
supposed to be synonymous to "erase", that "first" is equivalent to an
iterator obtained by a call to begin(), "last" is equivalent to an
iterator obtained by a call to end(), and that all invalid iterator
arithmetic expressions are resolved as described in DR submitted by
Thomas Mang regarding invalid iterator arithmetic expressions.</p>

<p>
Furthermore, the resolutions of DR 202 are considered regarding
equivalence relation and order of arguments for a call to pred.</p>

<p>
All implementations known to the author of this Defect Report comply
with these assumptions, apart from the impact of the alternative
resolution of DR 202. Except for the changes implied by the resolutions
of DR 202, no impact on current code is expected.</p>

<p>
3) Proposed fixes:</p>

<p>
Change 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph 19 to:</p>

<p>
"Effect: Erases all but the first element from every consecutive group
of elements, referred to by the iterator i in the range [begin(),
end()), for which the following conditions hold: *(i-1) == *i (for the
version of unique with no argument) or pred(*(i-1), *i) != false (for
the version of unique with a predicate argument)."</p>

<p>
Comments to the new wording:</p>

<p>
a) The new wording was influenced by DR 202 and the resolutions
presented there. If DR 202 is resolved in another way, the proposed
wording need also additional review.
b) "Erases" refers in the author's opinion unambiguously to the member
function "erase". In case there is doubt this might not be unamgibuous,
a direct reference to the member function "erase" is suggested [Note:
This would also imply a change of 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph
15.].
c) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
d) The wording "(for the version of unique with no argument)" and "(for
the version of unique with a predicate argument)" was kept consciously
for clarity.
e) "begin()" substitutes "first", and "end()" substitutes "last". The
range need adjustment from "[first + 1, last)" to "[begin(), end())" to
ensure a valid range in case of an empty list.
f) If it is considered that the wording is unclear whether it declares
the element of a group which consists of only a single element
implicitly to be the first element of this group [Note: Such an
interpretation could eventually arise especially in case size() == 1] ,
the following additional sentence is proposed: "If such a group of
elements consists of only a single element, this element is also
considered the first element."</p>

<p>
Change 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph 20 to:</p>

<p>
"Throws: Nothing unless an exception is thrown by *(i-1) == *i or
pred(*(i-1), *i)."</p>

<p>
Comments to the new wording:</p>

<p>
a) The wording regarding the conditions is identical to proposed
24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph 19. If 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>,
paragraph 19 is resolved in another way, the proposed wording need also
additional review.
b) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
c) Typos fixed.</p>

<p>
Change 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, paragraph 21 to:</p>

<p>
"Complexity: If empty() == false, exactly size() - 1 applications of the
corresponding predicate, otherwise no applications of the corresponding
predicate."</p>

<p>
Comments to the new wording:</p>

<p>
a) The new wording is supposed to also replace the proposed resolution
of DR 315, which suffers from the problem of undefined "first" / "last".
</p>

<p>
5) References to other DRs:</p>

<p>See DR 202.
See DR 239.
See DR 315.
See DR submitted by Thomas Mang regarding invalid iterator arithmetic
expressions.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>"All implementations known to the author of this Defect Report
comply with these assumption", and "no impact on current code is
expected", i.e. there is no evidence of real-world confusion or
harm.</p>





<hr>
<h3><a name="492" href="492">492.</a> Invalid iterator arithmetic expressions</h3>
<p><b>Section:</b> 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Various clauses other than clause 25 make use of iterator arithmetic not
supported by the iterator category in question.
Algorithms in clause 25 are exceptional because of 25 [lib.algorithms],
paragraph 9, but this paragraph does not provide semantics to the
expression "iterator - n", where n denotes a value of a distance type
between iterators.</p>

<p>1) Examples of current wording:</p>

<p>Current wording outside clause 25:</p>

<p>
23.2.2.4 [lib.list.ops], paragraphs 19-21: "first + 1", "(i - 1)",
"(last - first)"
23.3.1.1 [lib.map.cons], paragraph 4: "last - first"
23.3.2.1 [lib.multimap.cons], paragraph 4: "last - first"
23.3.3.1 [lib.set.cons], paragraph 4: "last - first"
23.3.4.1 [lib.multiset.cons], paragraph 4: "last - first"
24.4.1 [lib.reverse.iterators], paragraph 1: "(i - 1)"
</p>

<p>
[Important note: The list is not complete, just an illustration. The
same issue might well apply to other paragraphs not listed here.]</p>

<p>None of these expressions is valid for the corresponding iterator
category.</p>

<p>Current wording in clause 25:</p>

<p>
25.1.1 [lib.alg.foreach], paragraph 1: "last - 1"
25.1.3 [lib.alg.find.end], paragraph 2: "[first1, last1 -
(last2-first2))"
25.2.8 [lib.alg.unique], paragraph 1: "(i - 1)"
25.2.8 [lib.alg.unique], paragraph 5: "(i - 1)"
</p>

<p>
However, current wording of 25 [lib.algorithms], paragraph 9 covers
neither of these four cases:</p>

<p>Current wording of 25 [lib.algorithms], paragraph 9:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
these cases the semantics of a+n is the same as that of</p>
<pre>
{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>and that of b-a is the same as of return distance(a, b)"</p>

<p>
This paragrpah does not take the expression "iterator - n" into account,
where n denotes a value of a distance type between two iterators [Note:
According to current wording, the expression "iterator - n" would be
resolved as equivalent to "return distance(n, iterator)"]. Even if the
expression "iterator - n" were to be reinterpreted as equivalent to
"iterator + -n" [Note: This would imply that "a" and "b" were
interpreted implicitly as values of iterator types, and "n" as value of
a distance type], then 24.3.4/2 interfers because it says: "Requires: n
may be negative only for random access and bidirectional iterators.",
and none of the paragraphs quoted above requires the iterators on which
the algorithms operate to be of random access or bidirectional category.
</p>

<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the expression
"iterator1 + n" and "iterator1 - iterator2" has the semantics as
described in current 25 [lib.algorithms], paragraph 9, but applying to
all clauses. The expression "iterator1 - n" is equivalent to an
result-iterator for which the expression "result-iterator + n" yields an
iterator denoting the same position as iterator1 does. The terms
"iterator1", "iterator2" and "result-iterator" shall denote the value of
an iterator type, and the term "n" shall denote a value of a distance
type between two iterators.</p>

<p>
All implementations known to the author of this Defect Report comply
with these assumptions.
No impact on current code is expected.</p>

<p>3) Proposed fixes:</p>


<p>Change 25 [lib.algorithms], paragraph 9 to:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
this paragraph, a and b denote values of an iterator type, and n denotes
a value of a distance type between two iterators. In these cases the
semantics of a+n is the same as that of</p>
<pre>
{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>,the semantics of a-n denotes the value of an iterator i for which the
following condition holds:
advance(i, n) == a,
and that of b-a is the same as of
return distance(a, b)".
</p>

<p>Comments to the new wording:</p>

<p>
a) The wording " In this paragraph, a and b denote values of an iterator
type, and n denotes a value of a distance type between two iterators."
was added so the expressions "b-a" and "a-n" are distinguished regarding
the types of the values on which they operate.
b) The wording ",the semantics of a-n denotes the value of an iterator i
for which the following condition holds: advance(i, n) == a" was added
to cover the expression 'iterator - n'. The wording "advance(i, n) == a"
was used to avoid a dependency on the semantics of a+n, as the wording
"i + n == a" would have implied. However, such a dependency might well
be deserved.
c) DR 225 is not considered in the new wording.
</p>

<p>
Proposed fixes regarding invalid iterator arithmetic expressions outside
clause 25:</p>

<p>
Either
a) Move modified 25 [lib.algorithms], paragraph 9 (as proposed above)
before any current invalid iterator arithmetic expression. In that case,
the first sentence of 25 [lib.algorithms], paragraph 9, need also to be
modified and could read: "For the rest of this International Standard,
...." / "In the description of the following clauses including this
...." / "In the description of the text below ..." etc. - anyways
substituting the wording "algorithms", which is a straight reference to
clause 25.
In that case, 25 [lib.algorithms] paragraph 9 will certainly become
obsolete.
Alternatively,
b) Add an appropiate paragraph similar to resolved 25 [lib.algorithms],
paragraph 9, to the beginning of each clause containing invalid iterator
arithmetic expressions.
Alternatively,
c) Fix each paragraph (both current wording and possible resolutions of
DRs) containing invalid iterator arithmetic expressions separately.
</p>

<p>5) References to other DRs:</p>

<p>
See DR 225.
See DR 237. The resolution could then also read "Linear in last -
first".
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Keep open and ask Bill to provide wording.
</p></blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote><p>
This issue is related to <a href="997">997</a>.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Hinnant: this isn't going to change any user's code or any vendor's implementation.
</p>
<p>
No objection to "NAD without prejudice." If anyone proposes a
resolution, the LWG will consider it.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>[Lillehammer: Minor issue, but real. We have a blanket statement
about this in 25/11. But (a) it should be in 17, not 25; and (b) it's
not quite broad enough, because there are some arithmetic expressions
it doesn't cover. Bill will provide wording.]</i></p>







<hr>
<h3><a name="493" href="493">493.</a> Undefined Expression in Input Iterator Note Title</h3>
<p><b>Section:</b> 25.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-12-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#input.iterators">active issues</a> in [input.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>1) In 24.1.1/3, the following text is currently present.</p>

<p>"Note: For input iterators, a==b does not imply ++a=++b (Equality does
not guarantee the substitution property or referential transparency)."</p>

<p>However, when in Table 72, part of the definition of ++r is given as:</p>

<p>"pre: r is dereferenceable.
post: any copies of the previous value of r are no longer required
either to be dereferenceable ..."</p>

<p>While a==b does not imply that b is a copy of a, this statement should
perhaps still be made more clear.</p>

<p>2) There are no changes to intended behaviour</p>

<p>
3) This Note should be altered to say "Note: For input iterators a==b,
when its behaviour is defined ++a==++b may still be false (Equality does
not guarantee the substitution property or referential transparency).</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is descriptive text, not normative, and the meaning is clear.</p>





<hr>
<h3><a name="494" href="494">494.</a> Wrong runtime complexity for associative container's insert and delete</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Hans B os <b>Opened:</b> 2004-12-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to [lib.associative.reqmts] table 69, the runtime comlexity
of insert(p, t) and erase(q) can be done in amortized constant time.</p>

<p>It was my understanding that an associative container could be
implemented as a balanced binary tree.</p>

<p>For inser(p, t), you 'll have to iterate to p's next node to see if t
can be placed next to p.  Furthermore, the insertion usually takes
place at leaf nodes. An insert next to the root node will be done at
the left of the root next node</p>

<p>So when p is the root node you 'll have to iterate from the root to
its next node, which  takes O(log(size)) time in a balanced tree.</p>

<p>If you insert all values with insert(root, t) (where root is the
root of the tree before insertion) then each insert takes O(log(size))
time.  The amortized complexity per insertion will be O(log(size))
also.</p>

<p>For erase(q), the normal algorithm for deleting a node that has no
empty left or right subtree, is to iterate to the next (or previous),
which is a leaf node. Then exchange the node with the next and delete
the leaf node.  Furthermore according to DR 130, erase should return
the next node of the node erased.  Thus erasing the root node,
requires iterating to the next node.</p>

<p>Now if you empty a map by deleting the root node until the map is
empty, each operation will take O(log(size)), and the amortized
complexity is still O(log(size)).</p>

<p>The operations can be done in amortized constant time if iterating
to the next node can be done in (non amortized) constant time.  This
can be done by putting all nodes in a double linked list.  This
requires two extra links per node.  To me this is a bit overkill since
you can already efficiently insert or erase ranges with erase(first,
last) and insert(first, last).</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Only "amortized constant" in special circumstances, and we believe
  that's implementable. That is: doing this N times will be O(N), not
  O(log N).</p>





<hr>
<h3><a name="499" href="499">499.</a> Std. doesn't seem to require stable_sort() to be stable!</h3>
<p><b>Section:</b> 27.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/stable.sort">[stable.sort]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Prateek Karandikar <b>Opened:</b> 2005-04-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><p>
17.3.1.1 Summary</p>

<p>
1 The Summary provides a synopsis of the category, and introduces the 
first-level subclauses. Each subclause also provides a summary, listing 
the headers specified in the subclause and the library entities 
provided in each header. 
</p>
<p>
2 Paragraphs labelled "Note(s):" or "Example(s):" are informative, 
other paragraphs are normative.
</p></blockquote> 

<p>So this means that a "Notes" paragraph wouldn't be normative. </p>

<blockquote><p>
25.3.1.2 stable_sort
</p>
<pre>
template&lt;class RandomAccessIterator&gt; 
void stable_sort(RandomAccessIterat or first, RandomAccessIterator last); 

template&lt;class RandomAccessIterator, class Compare&gt; 
void stable_sort(RandomAccessIterat or first, RandomAccessIterator last, Compare comp);
</pre>
<p>
1 Effects: Sorts the elements in the range [first, last).
</p>
<p>
2 Complexity: It does at most N(log N)^2 (where N == last - first) 
comparisons; if enough extra memory is available, it is N log N.
</p>
<p>
3 Notes: Stable: the relative order of the equivalent elements is 
preserved. 
</p></blockquote> 

<p>
The Notes para is informative, and nowhere else is stability mentioned above. 
</p>

<p>
Also, I just searched for the word "stable" in my copy of the Standard. 
and the phrase "Notes: Stable: the relative order of the elements..." 
is repeated several times in the Standard library clauses for 
describing various functions. How is it that stability is talked about 
in the informative paragraph? Or am I missing something obvious? 
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
This change has already been made.
</p>





<hr>
<h3><a name="500" href="500">500.</a> do_length cannot be implemented correctly</h3>
<p><b>Section:</b> 30.4.2.6 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.byname">[locale.codecvt.byname]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Krzysztof &#379;elechowski <b>Opened:</b> 2005-05-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol>
<li>codecvt::do_length is of type int;</li>
<li>it is assumed to be sort-of returning from_next - from of type ptrdiff_t;</li>
<li>ptrdiff_t cannot be cast to an int without data loss.</li>
</ol>
<p>
Contradiction.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="501" href="501">501.</a> Proposal: strengthen guarantees of lib.comparisons</h3>
<p><b>Section:</b> 99 [depr.base] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Me &lt;anti_spam_email2003@yahoo.com&gt; <b>Opened:</b> 2005-06-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.base">issues</a> in [depr.base].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><p>
"For templates greater, less, greater_equal, and less_equal,
the specializations for any pointer type yield a total order, even if
the built-in operators &lt;, &gt;, &lt;=, &gt;= do not."
</p></blockquote>

<p>
The standard should do much better than guarantee that these provide a
total order, it should guarantee that it can be used to test if memory
overlaps, i.e. write a portable memmove. You can imagine a platform
where the built-in operators use a uint32_t comparison (this tests for
overlap on this platform) but the less&lt;T*&gt; functor is allowed to be
defined to use a int32_t comparison. On this platform, if you use
std::less with the intent of making a portable memmove, comparison on
an array that straddles the 0x7FFFFFFF/0x8000000 boundary can give
incorrect results.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a footnote to 20.5.3/8 saying:
</p>

<blockquote><p>
Given a p1 and p2 such that p1 points to N objects of type T and p2
points to M objects of type T. If [p1,p1+N) does not overlap [p2,p2+M),
less returns the same value when comparing all pointers in [p1,p1+N) to
all pointers in [p2,p2+M). Otherwise, there is a value Q and a value R
such that less returns the same value when comparing all pointers in
[p1,p1+Q) to all pointers in [p2,p2+R) and an opposite value when
comparing all pointers in [p1+Q,p1+N) to all pointers in [p2+R,p2+M).
For the sake of completeness, the null pointer value (4.10) for T is
considered to be an array of 1 object that doesn't overlap with any
non-null pointer to T. less_equal, greater, greater_equal, equal_to,
and not_equal_to give the expected results based on the total ordering
semantics of less. For T of void, treat it as having similar semantics
as T of char i.e. less&lt;cv T*&gt;(a, b) gives the same results as less&lt;cv
void*&gt;(a, b) which gives the same results as less&lt;cv char*&gt;((cv
char*)(cv void*)a, (cv char*)(cv void*)b).
</p></blockquote>

<p>
I'm also thinking there should be a footnote to 20.5.3/1 saying that if
A and B are similar types (4.4/4), comp&lt;A&gt;(a,b) returns the same value
as comp&lt;B&gt;(a,b) (where comp is less, less_equal, etc.). But this might
be problematic if there is some really funky operator overloading going
on that does different things based on cv (that should be undefined
behavior if somebody does that though). This at least should be
guaranteed for all POD types (especially pointers) that use the
built-in comparison operators.
</p>



<p><b>Rationale:</b></p>
<p>
less is already required to provide a strict weak ordering which is good enough
to detect overlapping memory situations.
</p>





<hr>
<h3><a name="502" href="502">502.</a> Proposition: Clarification of the interaction between a facet and an iterator</h3>
<p><b>Section:</b> 30.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/locale.category">[locale.category]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Conrade Zseleghovski <b>Opened:</b> 2005-06-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Motivation:
</p>

<p>
This requirement seems obvious to me, it is the essence of code modularity. 
I have complained to Mr. Plauger that the Dinkumware library does not 
observe this principle but he objected that this behaviour is not covered in 
the standard.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
No objection to NAD, Fixed.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Append the following point to 22.1.1.1.1:
</p>

<p>
6. The implementation of a facet of Table 52 parametrized with an 
InputIterator/OutputIterator should use that iterator only as character 
source/sink respectively.
For a *_get facet, it means that the value received depends only on the 
sequence of input characters and not on how they are accessed.
For a *_put facet, it means that the sequence of characters output depends 
only on the value to be formatted and not of how the characters are stored.
</p>

<p><i>[
Berlin:  Moved to Open, Need to clean up this area to make it clear
locales don't have to contain open ended sets of facets. Jack, Howard,
Bill.
]</i></p>







<hr>
<h3><a name="503" href="503">503.</a> more on locales</h3>
<p><b>Section:</b> 30.4 <a href="https://timsong-cpp.github.io/cppwp/locale.categories">[locale.categories]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2005-06-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
a) In 22.2.1.1 para. 2 we refer to "the instantiations required in Table
51" to refer to the facet *objects* associated with a locale. And we
almost certainly mean just those associated with the default or "C"
locale. Otherwise, you can't switch to a locale that enforces a different
mapping between narrow and wide characters, or that defines additional
uppercase characters.
</p>

<p>
b) 22.2.1.5 para. 3 (codecvt) has the same issues.
</p>

<p>
c) 22.2.1.5.2 (do_unshift) is even worse. It *forbids* the generation of
a homing sequence for the basic character set, which might very well need
one.
</p>

<p>
d) 22.2.1.5.2 (do_length) likewise dictates that the default mapping
between wide and narrow characters be taken as one-for-one.
</p>

<p>
e) 22.2.2 para. 2 (num_get/put) is both muddled and vacuous, as far as
I can tell. The muddle is, as before, calling Table 51 a list of
instantiations. But the constraint it applies seems to me to cover
*all* defined uses of num_get/put, so why bother to say so?
</p>

<p>
f) 22.2.3.1.2 para. 1(do_decimal_point) says "The required instantiations
return '.' or L'.'.) Presumably this means "as appropriate for the
character type. But given the vague definition of "required" earlier,
this overrules *any* change of decimal point for non "C" locales.
Surely we don't want to do that.
</p>

<p>
g) 22.2.3.1.2 para. 2 (do_thousands_sep) says "The required instantiations
return ',' or L','.) As above, this probably means "as appropriate for the
character type. But this overrules the "C" locale, which requires *no*
character ('\0') for the thousands separator. Even if we agree that we
don't mean to block changes in decimal point or thousands separator,
we should also eliminate this clear incompatibility with C.
</p>

<p>
h) 22.2.3.1.2 para. 2 (do_grouping) says "The required instantiations
return the empty string, indicating no grouping." Same considerations
as for do_decimal_point.
</p>

<p>
i) 22.2.4.1 para. 1 (collate) refers to "instantiations required in Table
51". Same bad jargon.
</p>

<p>
j) 22.2.4.1.2 para. 1 (do_compare) refers to "instantiations required
in Table 51". Same bad jargon.
</p>

<p>
k) 22.2.5 para. 1 (time_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
l) 22.2.6 para. 2 (money_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
m) 22.2.6.3.2 (do_pos/neg_format) says "The instantiations required
in Table 51 ... return an object of type pattern initialized to
{symbol, sign, none, value}." This once again *overrides* the "C"
locale, as well as any other locale."
</p>

<p>
3) We constrain the use_facet calls that can be made by num_get/put,
so why don't we do the same for money_get/put? Or for any of the
other facets, for that matter?
</p>

<p>
4) As an almost aside, we spell out when a facet needs to use the ctype
facet, but several also need to use a codecvt facet and we don't say so.
</p>
<p><i>[
Berlin: Bill to provide wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
No objection to NAD.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="504" href="504">504.</a> Integer types in pseudo-random number engine requirements</h3>
<p><b>Section:</b> 28.5.3 <a href="https://timsong-cpp.github.io/cppwp/rand.req">[rand.req]</a>, 99 [tr.rand.req] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req">issues</a> in [rand.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.req], Paragraph 2 states that "... s is a value of integral type,
g is an ... object returning values of unsigned integral type ..."
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 5.1.1 [tr.rand.req], Paragraph 2 replace
</p>

<blockquote><p>
... s is a value of integral type, g is an lvalue of a type other than X that
defines a zero-argument function object returning values of <del>unsigned integral</del> type
<ins><tt>unsigned long int</tt></ins>,
...
</p></blockquote>

<p>
In 5.1.1 [tr.rand.seq], Table 16, replace in the line for X(s)
</p>

<blockquote><p>
creates an engine with the initial internal state
determined by <ins><tt>static_cast&lt;unsigned long&gt;(</tt></ins><tt><i>s</i></tt><ins><tt>)</tt></ins>
</p></blockquote>

<p><i>[
Mont Tremblant:  Both s and g should be unsigned long.
This should refer to the constructor signatures. Jens  provided wording post Mont Tremblant.
]</i></p>


<p><i>[
Berlin:  N1932 adopts the proposed resolution:  see 26.3.1.3/1e and Table 3 row 2. Moved
to Ready.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Jens:  Just requiring X(unsigned long) still makes it possible
for an evil library writer to also supply a X(int) that does something
unexpected.  The wording above requires that X(s) always performs
as if X(unsigned long) would have been called.  I believe that is
sufficient and implements our intentions from Mont Tremblant.  I
see no additional use in actually requiring a X(unsigned long)
signature.  u.seed(s) is covered by its reference to X(s), same
arguments.
</p>


<p><i>[
Portland:  Subsumed by N2111.
]</i></p>





<hr>
<h3><a name="506" href="506">506.</a> Requirements of Distribution parameter for variate_generator</h3>
<p><b>Section:</b> 28.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a>, 99 [tr.rand.var] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 requires that template argument U (which corresponds to template
parameter Engine) satisfy all uniform random number generator requirements.
However, there is no  analogous requirement regarding the template argument
that corresponds to template parameter Distribution.  We believe there should
be, and that it should require that this template argument satisfy all random
distribution requirements.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Consequence 1: Remove the precondition clauses [tr.rand.var]/16 and /18.
</p>
<p>
Consequence 2: Add max() and min() functions to those distributions that
do not already have them.
</p>

<p><i>[
Mont Tremblant: Jens reccommends NAD, min/max not needed everywhere.
Marc supports having min and max to satisfy generic programming interface.
]</i></p>




<p><b>Rationale:</b></p>
<p>Berlin:  N1932 makes this moot: variate_generator has been eliminated.</p>





<hr>
<h3><a name="509" href="509">509.</a> Uniform_int template parameters</h3>
<p><b>Section:</b> 28.5.9.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.uni">[rand.dist.uni]</a>, 99 [tr.rand.dist.iunif] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.uni">issues</a> in [rand.dist.uni].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.dist.iunif] the uniform_int distribution currently has a single
template parameter, IntType, used as the input_type and as the result_type
of the distribution.  We believe there is no reason to conflate these types
in this way.
</p>


<p><b>Proposed resolution:</b></p>
<p>
We recommend that there be a second template  parameter to
reflect the distribution's input_type, and that the existing first template
parameter continue to reflect (solely) the result_type:
</p>
<blockquote><pre>
template&lt; class IntType = int, UIntType = unsigned int &gt;
class uniform_int
{
public:
  // types
  typedef  UIntType  input_type;
  typedef  IntType   result_type;
</pre></blockquote>

<p><i>[
Berlin: Moved to NAD.  N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>







<hr>
<h3><a name="510" href="510">510.</a> Input_type for bernoulli_distribution</h3>
<p><b>Section:</b> 28.5.9.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern">[rand.dist.bern]</a>, 99 [tr.rand.dist.bern] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.dist.bern] the distribution currently requires;
</p>
<blockquote><pre>
typedef  int  input_type;
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
We believe this is an unfortunate choice, and recommend instead:
</p>
<blockquote><pre>
typedef  unsigned int  input_type;
</pre></blockquote>

<p><i>[
Berlin:  Moved to NAD. N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>







<hr>
<h3><a name="511" href="511">511.</a> Input_type for binomial_distribution</h3>
<p><b>Section:</b> 28.5.9 <a href="https://timsong-cpp.github.io/cppwp/rand.dist">[rand.dist]</a>, 99 [tr.rand.dist.bin] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist">issues</a> in [rand.dist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike all other distributions in TR1, this binomial_distribution has an
implementation-defined  input_type.  We believe this is an unfortunate choice,
because it hinders users from writing portable code.  It also hinders the
writing of compliance tests.  We recommend instead:
</p>
<blockquote><pre>
typedef  RealType  input_type;
</pre></blockquote>
<p>
While this choice is somewhat arbitrary (as it was for some of the other
distributions), we make  this particular choice because (unlike all other
distributions) otherwise this template would not publish its RealType
argument and so users could not write generic code that accessed this
second template parameter.  In this respect, the choice is consistent with
the other distributions in  TR1. 
</p>
<p>
We have two reasons for recommending that a real type be specified instead.
One reason is  based specifically on characteristics of binomial distribution
implementations, while the other is based on mathematical characteristics of
probability distribution functions in general.
</p>
<p>
Implementations of binomial distributions commonly use Stirling approximations
for values in certain ranges.  It is far more natural to use real values to
represent these approximations than it would be to use integral values to do
so.  In other ranges, implementations reply on the Bernoulli  distribution to
obtain values.  While TR1's bernoulli_distribution::input_type is specified as
int, we believe this would be better specified as double.
</p>
<p>
This brings us to our main point:  The notion of a random distribution rests
on the notion of a cumulative distribution function, which in turn mathematically
depends on a continuous dependent variable.  Indeed, such a distribution function
would be meaningless if it depended on  discrete values such as integers - and this
remains true even if the distribution function were to take discrete steps.
</p>
<p>
Although this note is specifically about binomial_distribution::input_type,
we intend to recommend that all of the random distributions input_types be
specified as a real type (either a RealType template parameter, or double,
as appropriate).
</p>
<p>
Of the nine distributions in TR1, four already have this characteristic
(uniform_real, exponential_distribution, normal_distribution, and
gamma_distribution).  We have already argued the case for the binomial the
remaining four distributions.
</p>
<p>
In the case of uniform_int, we believe that the calculations to produce an
integer result in a  specified range from an integer in a different specified
range is best done using real arithmetic.  This is because it involves a
product, one of whose terms is the ratio of the extents of the two ranges.
Without real arithmetic, the results become less uniform: some numbers become
more  (or less) probable that they should be.  This is, of course, undesireable
behavior in a uniform distribution.
</p>
<p>
Finally, we believe that in the case of the bernoulli_distribution (briefly
mentioned earlier), as well as the cases of the geometric_distribution and the
poisson_distribution, it would be far more natural to have a real input_type.
This is because the most natural computation involves the  random number
delivered and the distribution's parameter p (in the case of bernoulli_distribution,
for example, the computation is a comparison against p), and p is already specified
in each case as having some real type.
</p>


<p><b>Proposed resolution:</b></p>
<blockquote><pre>
typedef  RealType  input_type;
</pre></blockquote>

<p><i>[
Berlin:  Moved to NAD.  N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>






<hr>
<h3><a name="512" href="512">512.</a> Seeding <tt>subtract_with_carry_01</tt> from a single unsigned long</h3>
<p><b>Section:</b> 28.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a>, 99 [tr.rand.eng.sub1] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 8 specifies the algorithm by which a <tt>subtract_with_carry_01</tt> engine
is to be seeded given a single unsigned long.  This algorithm is seriously
flawed in the case where the engine parameter w (also known as word_size)
exceeds 31 [bits].  The key part of the paragraph reads:
</p>
<blockquote><p>
sets x(-r) ... x(-1) to (lcg(1)*2**(-w)) mod 1
</p></blockquote>
<p>
and so forth. 
</p>
<p>
Since the specified linear congruential engine, lcg, delivers numbers with
a maximum of 2147483563 (just a shade under 31 bits), then when w is, for
example, 48, each of the x(i) will be less than 2**-17.  The consequence
is that roughly the first 400 numbers delivered will be conspicuously
close to either zero or one.
</p>
<p>
Unfortunately, this is not an innocuous flaw:  One of the predefined engines
in [tr.rand.predef], namely <tt>ranlux64_base_01</tt>, has w = 48 and would exhibit
this poor behavior, while the original N1378 proposal states that these
pre-defined engines are intended to be of "known good properties."
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 5.1.4.4 [tr.rand.eng.sub1], replace the "effects" clause for
void seed(unsigned long value = 19780503) by
</p>

<blockquote><p>
<i>Effects:</i> If <tt>value == 0</tt>, sets value to <tt>19780503</tt>. In any
case, <del>with a linear congruential generator <tt>lcg</tt>(i) having parameters
<tt><i>m<sub>lcg</sub></i> = 2147483563</tt>, <tt><i>a<sub>lcg</sub></i> = 40014</tt>,
<tt><i>c<sub>lcg</sub></i> = 0</tt>, and <tt><i>lcg</i>(0) = value</tt>,</del>
sets <ins>carry<tt>(-1)</tt> and</ins> <tt>x(-r) &hellip; x(-1)</tt>
<ins>as if executing</ins></p>

<blockquote><pre><ins>
linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; lcg(value);
seed(lcg);
</ins></pre></blockquote>

<p>
<del>to <tt>(<i>lcg</i>(1) &middot; 2<sup>-<i>w</i></sup>) mod 1
&hellip; (<i>lcg</i>(<i>r</i>) &middot; 2<sup>-<i>w</i></sup>) mod 1</tt>,
respectively. If <tt><i>x</i>(-1) == 0</tt>, sets carry<tt>(-1) = 2<sup>-<i>w</i></sup></tt>,
else sets carry<tt>(-1) = 0</tt>.</del></p>
</blockquote>

<p><i>[
Jens provided revised wording post Mont Tremblant.
]</i></p>


<p><i>[
Berlin: N1932 adopts the originally-proposed resolution of the issue.
Jens's supplied wording is a clearer description of what is
intended.  Moved to Ready.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Jens: I'm using an explicit type here, because fixing the
prose would probably not qualify for the (with issue <a href="504">504</a> even
stricter) requirements we have for seed(Gen&amp;).
</p>

<p><i>[
Portland: Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="513" href="513">513.</a> Size of state for subtract_with_carry_01</h3>
<p><b>Section:</b> 28.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a>, 99 [tr.rand.eng.sub1] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 begins:
</p>
<blockquote><p>
The size of the state is r.
</p></blockquote>
<p>
However, this is not quite consistent with the remainder of the paragraph
which specifies a total  of nr+1 items in the textual representation of
the state.  We recommend the sentence be corrected to match:
</p>
<blockquote><p>
The size of the state is nr+1.
</p></blockquote>
<p>
To give meaning to the coefficient n, it may be also desirable to move
n's definition from later in the paragraph.  Either of the following
seem reasonable formulations:
</p>
<blockquote><p>
With n=..., the size of the state is nr+1.
</p></blockquote>
<blockquote><p>
The size of the state is nr+1, where n=... .
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
Jens:  I plead for "NAD" on the grounds that "size of state" is only
used as an argument for big-O complexity notation, thus
constant factors and additions don't count.
]</i></p>


<p><i>[
Berlin: N1932 adopts the proposed NAD.
]</i></p>







<hr>
<h3><a name="514" href="514">514.</a> Size of state for subtract_with_carry</h3>
<p><b>Section:</b> 28.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.sub">[rand.eng.sub]</a>, 99 [tr.rand.eng.sub] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 2 begins:
</p>
<blockquote><p>
The size of the state is r.
</p></blockquote>
<p>
However, the next sentence specifies a total of r+1 items in the textual
representation of the state,  r specific x's as well as a specific carry.
This makes a total of r+1 items that constitute the size of the state,
rather than r.
</p>


<p><b>Proposed resolution:</b></p>
<p>
We recommend the sentence be corrected to match:
</p>
<blockquote><p>
 The size of the state is r+1.
</p></blockquote>

<p><i>[
Jens:  I plead for "NAD" on the grounds that "size of state" is only
used as an argument for big-O complexity notation, thus
constant factors and additions don't count.
]</i></p>


<p><i>[
Berlin: N1932 adopts the proposed NAD.
]</i></p>







<hr>
<h3><a name="515" href="515">515.</a> Random number engine traits</h3>
<p><b>Section:</b> 28.5.2 <a href="https://timsong-cpp.github.io/cppwp/rand.synopsis">[rand.synopsis]</a>, 99 [tr.rand.synopsis] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.synopsis">issues</a> in [rand.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
To accompany the concept of a pseudo-random number engine as defined in Table 17,
we propose and recommend an adjunct template, engine_traits, to be declared in
[tr.rand.synopsis] as:
</p>
<blockquote><pre>
template&lt; class PSRE &gt;
class engine_traits;
</pre></blockquote>
<p>
This template's primary purpose would be as an aid to generic programming involving
pseudo-random number engines.  Given only the facilities described in tr1, it would
be very difficult to produce any algorithms involving the notion of a generic engine.
The intent of this proposal is to  provide, via engine_traits&lt;&gt;, sufficient
descriptive information to allow an algorithm to employ a pseudo-random number engine
without regard to its exact type, i.e., as a template parameter.
</p>
<p>
For example, today it is not possible to write an efficient generic function that
requires any specific number of random bits.  More specifically, consider a
cryptographic application that internally needs 256 bits of randomness per call:
</p>
<blockquote><pre>
template&lt; class Eng, class InIter, class OutIter &gt;
void crypto( Eng&amp; e, InIter in, OutIter out );
</pre></blockquote>
<p>
Without knowning the number of bits of randomness produced per call to a provided
engine, the algorithm has no means of determining how many times to call the engine.
</p>
<p>
In a new section [tr.rand.eng.traits], we proposed to define the engine_traits
template as: 
</p>
<blockquote><pre>
template&lt; class PSRE &gt;
class engine_traits
{
  static  std::size_t  bits_of_randomness = 0u;
  static  std::string  name()  { return "unknown_engine"; }
  // TODO: other traits here
};
</pre></blockquote>
<p>
Further, each engine described in [tr.rand.engine] would be accompanied by a
complete specialization of this new engine_traits template.
</p>



<p><b>Proposed resolution:</b></p>
<p><i>[
Berlin:  Walter: While useful for implementation per TR1, N1932 has no need for this
feature.  Recommend close as NAD.
]</i></p>



<p><b>Rationale:</b></p>
<p>
Recommend NAD,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1932.pdf">N1932</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>
covers this.  Already in WP.
</p>





<hr>
<h3><a name="516" href="516">516.</a> Seeding subtract_with_carry_01 using a generator</h3>
<p><b>Section:</b> 28.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a>, 99 [tr.rand.eng.sub1] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 6 says:
</p>
<blockquote><p>
... obtained by successive invocations of g, ... 
</p></blockquote>
<p>
We recommend instead:
</p>
<blockquote><p>
... obtained by taking successive invocations of g mod 2**32, ...
</p></blockquote>
<p>
as the context seems to require only 32-bit quantities be used here.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Berlin: N1932 adopts the proposed resultion: see 26.3.3.4/7.  Moved to Ready.
</p>

<p><i>[
Portland:  Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="517" href="517">517.</a> Should include name in external representation</h3>
<p><b>Section:</b> 28.5.3 <a href="https://timsong-cpp.github.io/cppwp/rand.req">[rand.req]</a>, 99 [tr.rand.req] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req">issues</a> in [rand.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The last two rows of Table 16 deal with the i/o requirements of an engine,
specifying that the textual representation of an engine's state,
appropriately formatted, constitute the engine's  external representation.
</p>
<p>
This seems adequate when an engine's type is known.  However, it seems
inadequate in the  context of generic code, where it becomes useful and
perhaps even necessary to determine an engine's type via input.
</p>
<p>
</p>


<p><b>Proposed resolution:</b></p>
<p>
We therefore recommend that, in each of these two rows of Table 16, the
text "textual representation" be expanded so as to read "engine name
followed by the textual representation."
</p>

<p><i>[
Berlin: N1932 considers this NAD. This is a QOI issue.
]</i></p>







<hr>
<h3><a name="526" href="526">526.</a> Is it undefined if a function in the standard changes in parameters?</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2005-09-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Problem: There are a number of places in the C++ standard library where
it is possible to write what appear to be sensible ways of calling
functions, but which can cause problems in some (or all)
implementations, as they cause the values given to the function to be
changed in a way not specified in standard (and therefore not coded to
correctly work). These fall into two similar categories.
</p>

<p>
1) Parameters taken by const reference can be changed during execution
of the function
</p>

<p>
Examples:
</p>

<p>
Given std::vector&lt;int&gt; v:
</p>
<p>
v.insert(v.begin(), v[2]);
</p>
<p>
v[2] can be changed by moving elements of vector
</p>


<p>
Given std::list&lt;int&gt; l:
</p>
<p>
l.remove(*l.begin());
</p>
<p>
Will delete the first element, and then continue trying to access it.
This is particularily vicious, as it will appear to work in almost all
cases.
</p>

<p>
2) A range is given which changes during the execution of the function:
Similarly,
</p>

<p>
v.insert(v.begin(), v.begin()+4, v.begin()+6);
</p>

<p>
This kind of problem has been partly covered in some cases. For example
std::copy(first, last, result) states that result cannot be in the range
[first, last). However, does this cover the case where result is a
reverse_iterator built from some iterator in the range [first, last)?
Also, std::copy would still break if result was reverse_iterator(last +
1), yet this is not forbidden by the standard
</p>

<p>
Solution:
</p>

<p>
One option would be to try to more carefully limit the requirements of
each function. There are many functions which would have to be checked.
However as has been shown in the std::copy case, this may be difficult.
A simpler, more global option would be to somewhere insert text similar to:
</p>

<p>
If the execution of any function would change either any values passed
by reference or any value in any range passed to a function in a way not
defined in the definition of that function, the result is undefined.
</p>

<p>
Such code would have to at least cover chapters 23 and 25 (the sections
I read through carefully). I can see no harm on applying it to much of
the rest of the standard.
</p>

<p>
Some existing parts of the standard could be improved to fit with this,
for example the requires for 25.2.1 (Copy) could be adjusted to:
</p>

<p>
Requires: For each non-negative integer n &lt; (last - first), assigning to
*(result + n) must not alter any value in the range [first + n, last).
</p>

<p>
However, this may add excessive complication.
</p>

<p>
One other benefit of clearly introducing this text is that it would
allow a number of small optimisations, such as caching values passed
by const reference.
</p>

<p>
Matt Austern adds that this issue also exists for the <tt>insert</tt> and
<tt>erase</tt> members of the ordered and unordered associative containers.
</p>

<p><i>[
Berlin: Lots of controversey over how this should be solved. Lots of confusion
as to whether we're talking about self referencing iterators or references.
Needs a good survey as to the cases where this matters, for which
implementations, and how expensive it is to fix each case.
]</i></p>




<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD.
</p>
<ul>
<li><tt>vector::insert(iter, value)</tt> is required to work because the standard
doesn't give permission for it not to work.</li>
<li><tt>list::remove(value)</tt> is required to work because the standard
doesn't give permission for it not to work.</li>
<li><tt>vector::insert(iter, iter, iter)</tt> is not required to work because
24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, p4 says so.</li>
<li><tt>copy</tt> has to work, except where 27.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a> says
it doesn't have to work.  While a language lawyer can tear this wording apart,
it is felt that the wording is not prone to accidental interpretation.</li>
<li>The current working draft provide exceptions for the unordered associative
containers similar to the containers requirements which exempt the member
template insert functions from self referencing.</li>
</ul>





<hr>
<h3><a name="528" href="528">528.</a> <tt>const_iterator</tt> <tt>iterator</tt> issue when they are the same type</h3>
<p><b>Section:</b> 24.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a>, 99 [tr.unord.unord] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2005-10-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
while implementing the resolution of issue 6.19 I'm noticing the
following: according to 6.3.4.3/2 (and 6.3.4.5/2), for unordered_set and
unordered_multiset:
</p>

<blockquote><p>
    "The iterator and const_iterator types are both const types. It is
unspecified whether they are the same type"
</p></blockquote>

<p>
Now, according to the resolution of 6.19, we have overloads of insert
with hint and erase (single and range) both for iterator and
const_iterator, which, AFAICS, can be meaningful at the same time *only*
if iterator and const_iterator *are* in fact different types.
</p>
<p>
Then, iterator and const_iterator are *required* to be different types?
Or that is an unintended consequence? Maybe the overloads for plain
iterators should be added only to unordered_map and unordered_multimap?
Or, of course, I'm missing something?
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to 6.3.4.3p2 (and 6.3.4.5p2):
</p>
<p>
2  ... The iterator and const_iterator types are both <del>const</del>
<ins>constant</ins> iterator types.
It is unspecified whether they are the same type. 
</p>

<p>
Add a new subsection to 17.4.4 [lib.conforming]:
</p>

<blockquote>
<p>
An implementation shall not supply an overloaded function
       signature specified in any library clause if such a signature
       would be inherently ambiguous during overload resolution
       due to two library types referring to the same type.
</p>
<p>
       [Note: For example, this occurs when a container's iterator
       and const_iterator types are the same. -- end note]
</p>
</blockquote>

<p><i>[
Post-Berlin: Beman supplied wording.
]</i></p>




<p><b>Rationale:</b></p><p>
Toronto:  The first issue has been fixed by N2350 (the insert and erase members
are collapsed into one signature).  Alisdair to open a separate issue on the
chapter 17 wording.
</p>




<hr>
<h3><a name="529" href="529">529.</a> The standard encourages redundant and confusing preconditions</h3>
<p><b>Section:</b> 99 [res.on.required] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2005-10-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.4.3.8/1 says:
</p>

<blockquote><p>
Violation of the preconditions specified in a function's 
Required behavior: paragraph results in undefined behavior unless the 
function's Throws: paragraph specifies throwing an exception when the 
precondition is violated.
</p></blockquote>

<p>
This implies that a precondition violation can lead to defined
behavior.  That conflicts with the only reasonable definition of
precondition: that a violation leads to undefined behavior.  Any other
definition muddies the waters when it comes to analyzing program
correctness, because precondition violations may be routinely done in
correct code (e.g. you can use std::vector::at with the full
expectation that you'll get an exception when your index is out of
range, catch the exception, and continue).  Not only is it a bad
example to set, but it encourages needless complication and redundancy
in the standard.  For example:
</p>

<blockquote><pre>
  21 Strings library 
  21.3.3 basic_string capacity

  void resize(size_type n, charT c);

  5 Requires: n &lt;= max_size()
  6 Throws: length_error if n &gt; max_size().
  7 Effects: Alters the length of the string designated by *this as follows:
</pre></blockquote>

<p>
The Requires clause is entirely redundant and can be dropped.  We
could make that simplifying change (and many others like it) even
without changing 17.4.3.8/1; the wording there just seems to encourage
the redundant and error-prone Requires: clause.
</p>

<p><i>[
Batavia:  Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue:  NAD Editorial, this group likes 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2121.html">N2121</a>,
Pete agrees, accepting it is Pete's business.
General agreement that precondition violations are synonymous with UB.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
1. Change 17.4.3.8/1 to read:
</p>

<blockquote><p>
Violation of the preconditions specified in a function's
<i>Required behavior:</i> paragraph results in undefined behavior
<del>unless the function's <i>Throws:</i> paragraph specifies throwing
an exception when the precondition is violated</del>.
</p></blockquote>

<p>
2. Go through and remove redundant Requires: clauses.  Specifics to be
   provided by Dave A.
</p>

<p><i>[
Berlin: The LWG requests a detailed survey of part 2 of the proposed resolution.
]</i></p>


<p><i>[
Alan provided the survey
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2121.html">N2121</a>.
]</i></p>







<hr>
<h3><a name="536" href="536">536.</a> Container iterator constructor and explicit convertibility</h3>
<p><b>Section:</b> 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz <b>Opened:</b> 2005-12-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="589">589</a></p>
<p><b>Discussion:</b></p>
<p>
The iterator constructor X(i,j) for containers as defined in 23.1.1 and
23.2.2 does only require that i and j be input iterators but
nothing is said about their associated value_type. There are three
sensible
options:
</p>
<ol>
<li>iterator's value_type is exactly X::value_type (modulo cv).</li>
<li>iterator's value_type is *implicitly* convertible to X::value_type.</li>
<li>iterator's value_type is *explicitly* convertible to X::value_type.</li>
</ol>
<p>
The issue has practical implications, and stdlib vendors have
taken divergent approaches to it: Dinkumware follows 2,
libstdc++ follows 3.
</p>
<p>
The same problem applies to the definition of insert(p,i,j) for
sequences and insert(i,j) for associative contianers, as well as
assign.
</p>

<p><i>[
The following added by Howard and the example code was originally written by
Dietmar.
]</i></p>

<p>
Valid code below?
</p>

<blockquote><pre>
#include &lt;vector&gt; 
#include &lt;iterator&gt; 
#include &lt;iostream&gt; 

struct foo 
{ 
    explicit foo(int) {} 
}; 

int main() 
{ 
    std::vector&lt;int&gt; v_int; 
    std::vector&lt;foo&gt; v_foo1(v_int.begin(), v_int.end()); 
    std::vector&lt;foo&gt; v_foo2((std::istream_iterator&lt;int&gt;(std::cin)), 
                             std::istream_iterator&lt;int&gt;()); 
} 
</pre></blockquote>
<p><i>[
Berlin: Some support, not universal, for respecting the explicit qualifier.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="544" href="544">544.</a> minor NULL problems in C.2</h3>
<p><b>Section:</b> C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2005-11-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to C.2.2.3, p1, "the macro NULL, defined in any of &lt;clocale&gt;,
&lt;cstddef&gt;, &lt;cstdio&gt;, &lt;cstdlib&gt;, &lt;cstring&gt;, &lt;ctime&gt;,
or &lt;cwchar&gt;." This is consistent with the C standard.
</p>
<p>
However, Table 95 in C.2 fails to mention &lt;clocale&gt; and &lt;cstdlib&gt;.
</p>
<p>
In addition, C.2, p2 claims that "The C++ Standard library provides
54 standard macros from the C library, as shown in Table 95." While
table 95 does have 54 entries, since a couple of them (including the
NULL macro) are listed more than once, the actual number of macros
defined by the C++ Standard Library may not be 54.
</p>


<p><b>Proposed resolution:</b></p>
<p>
I propose we add &lt;clocale&gt; and &lt;cstdlib&gt; to Table 96 and remove the
number of macros from C.2, p2 and reword the sentence as follows:
</p>
<blockquote><p>
The C++ Standard library <del>provides 54 standard macros from</del>
<ins>defines a number macros corresponding to those defined by</ins> the C 
<ins>Standard</ins> library, as shown in Table 96.
</p></blockquote>

<p><i>[
Portland:  Resolution is considered editorial.  It will be incorporated into the WD.
]</i></p>







<hr>
<h3><a name="546" href="546">546.</a> [tr1] _Longlong and _ULonglong are integer types</h3>
<p><b>Section:</b> 5.1.1 [tr1::tr.rand.req] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2016-10-31 21:06:13 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The TR sneaks in two new integer types, _Longlong and _Ulonglong, in [tr.c99].
The rest of the TR should use that type.  I believe this affects two places.
First, the random number requirements, 5.1.1/10-11, lists all of the types with
which template parameters named IntType and UIntType may be instantiated.
_Longlong (or "long long", assuming it is added to C++0x) should be added to the
IntType list, and UIntType (again, or "unsigned long long") should be added to
the UIntType list.  Second, 6.3.2 lists the types for which hash&lt;&gt; is
required to be instantiable. _Longlong and _Ulonglong should be added to that
list, so that people may use long long as a hash key.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We are not going to fix TR1.
</p>
<p>
The paper "long long goes to the library" addresses the integration of
long long into the C++0x library.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="547" href="547">547.</a> division should be floating-point, not integer</h3>
<p><b>Section:</b> 28.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a>, 99 [tr.rand] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 10 describes how a variate generator uses numbers produced by an
engine to pass to a generator. The sentence that concerns me is: "Otherwise, if
the value for engine_value_type::result_type is true and the value for
Distribution::input_type is false [i.e. if the engine produces integers and the
engine wants floating-point values], then the numbers in s_eng are divided by
engine().max() - engine().min() + 1 to obtain the numbers in s_e." Since the
engine is producing integers, both the numerator and the denominator are
integers and we'll be doing integer division, which I don't think is what we
want. Shouldn't we be performing a conversion to a floating-point type first?
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD as the affected section is now gone and so the issue is moot.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>.
</p>





<hr>
<h3><a name="548" href="548">548.</a> May random_device block?</h3>
<p><b>Section:</b> 28.5.7 <a href="https://timsong-cpp.github.io/cppwp/rand.device">[rand.device]</a>, 99 [tr.rand.device] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.device">issues</a> in [rand.device].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class random_device "produces non-deterministic random numbers", using some
external source of entropy. In most real-world systems, the amount of available
entropy is limited. Suppose that entropy has been exhausted. What is an
implementation permitted to do? In particular, is it permitted to block
indefinitely until more random bits are available, or is the implementation
required to detect failure immediately? This is not an academic question. On
Linux a straightforward implementation would read from /dev/random, and "When
the entropy pool is empty, reads to /dev/random will block until additional
environmental noise is gathered." Programmers need to know whether random_device
is permitted to (or possibly even required to?) behave the same way.
</p>

<p><i>[
Berlin: Walter: N1932 considers this NAD. Does the standard specify whether std::cin
may block?
]</i></p>


<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a> (NAD).
</p>





<hr>
<h3><a name="549" href="549">549.</a> Undefined variable in binomial_distribution</h3>
<p><b>Section:</b> 28.5.9 <a href="https://timsong-cpp.github.io/cppwp/rand.dist">[rand.dist]</a>, 99 [tr.rand.dist.bin] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist">issues</a> in [rand.dist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 1 says that "A binomial distributon random distribution produces
integer values i&gt;0 with p(i) = (n choose i) * p*i * (1-p)^(t-i), where t and
p are the parameters of the distribution. OK, that tells us what t, p, and i
are. What's n?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Berlin: Typo: "n" replaced by "t" in N1932: see 26.3.7.2.2/1.
</p>

<p><i>[
Portland:  Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="553" href="553">553.</a> very minor editorial change <tt>intptr_t</tt> / <tt>uintptr_t</tt></h3>
<p><b>Section:</b> 17.4.2 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, 99 [tr.c99.cstdint.syn] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-01-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis, some types are identified as optional: <tt>int8_t</tt>, <tt>int16_t</tt>,
and so on, consistently with C99, indeed.
</p>
<p>
On the other hand, <tt>intptr_t</tt> and <tt>uintptr_t</tt>, are not marked as such and
probably should, consistently with C99, 7.18.1.4.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 17.4.2 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>:
</p>

<blockquote><pre>
...
typedef <i>signed integer type</i> intptr_t;    <ins><i>// optional</i></ins>
...
typedef <i>unsigned integer type</i> uintptr_t;    <ins><i>// optional</i></ins>
...
</pre></blockquote>



<p><b>Rationale:</b></p><p>
Recommend NAD and fix as editorial with the proposed resolution.
</p>




<hr>
<h3><a name="554" href="554">554.</a> Problem with lwg DR 184 numeric_limits&lt;bool&gt;</h3>
<p><b>Section:</b> 17.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/numeric.special">[numeric.special]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-01-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.special">issues</a> in [numeric.special].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe we have a bug in the resolution of:
<a href="184">184</a>
(WP status).
</p>

<p>
The resolution spells out each member of <tt>numeric_limits&lt;bool&gt;</tt>.
The part I'm having a little trouble with is:
</p>
<blockquote><pre>
static const bool traps = false;
</pre></blockquote>

<p>
Should this not be implementation defined?  Given:
</p>

<blockquote><pre>
int main()
{
     bool b1 = true;
     bool b2 = false;
     bool b3 = b1/b2;
}
</pre></blockquote>

<p>
If this causes a trap, shouldn't <tt>numeric_limits&lt;bool&gt;::traps</tt> be
<tt>true</tt>?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.2.1.5p3:
</p>

<blockquote><p>
-3- The specialization for <tt>bool</tt> shall be provided as follows: </p>
<blockquote><pre>
namespace std { 
   template &lt;&gt; class numeric_limits&lt;bool&gt; {
      ...
      static const bool traps = <del>false</del> <ins><i>implementation-defined</i></ins>;
      ...
   };
}
</pre></blockquote>
</blockquote>

<p><i>[
Redmond:  NAD because traps refers to values, not operations.  There is no bool
value that will trap.
]</i></p>







<hr>
<h3><a name="555" href="555">555.</a> [tr1] 8.21/1: typo</h3>
<p><b>Section:</b> 8.21 [tr1::tr.c99.boolh] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-02-02 <b>Last modified:</b> 2016-10-31 21:06:13 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This one, if nobody noticed it yet, seems really editorial:
s/cstbool/cstdbool/
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 8.21p1:
</p>
<blockquote><p>
-1- The header behaves as if it defines the additional macro defined in
<tt>&lt;cst<ins>d</ins>bool&gt;</tt> by including the header <tt>&lt;cstdbool&gt;</tt>.
</p></blockquote>

<p><i>[
Redmond:  Editorial.
]</i></p>







<hr>
<h3><a name="557" href="557">557.</a> TR1: div(_Longlong, _Longlong) vs div(intmax_t, intmax_t)</h3>
<p><b>Section:</b> 17.4 <a href="https://timsong-cpp.github.io/cppwp/cstdint">[cstdint]</a>, 99 [tr.c99.cstdint] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-02-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint">issues</a> in [cstdint].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing a problem with such overloads: when, _Longlong == intmax_t ==
long long we end up, essentially, with the same arguments and different
return types (lldiv_t and imaxdiv_t, respectively). Similar issue with
abs(_Longlong) and abs(intmax_t), of course.
</p>
<p>
Comparing sections 8.25 and 8.11, I see an important difference,
however: 8.25.3 and 8.25.4 carefully describe div and abs for _Longlong
types (rightfully, because not moved over directly from C99), whereas
there is no equivalent in 8.11: the abs and div overloads for intmax_t
types appear only in the synopsis and are not described anywhere, in
particular no mention in 8.11.2 (at variance with 8.25.2).
</p>
<p>
I'm wondering whether we really, really, want div and abs for intmax_t...
</p>



<p><b>Proposed resolution:</b></p>



<p><i>[
Portland: no consensus.
]</i></p>


<p><b>Rationale:</b></p>
<p><i>[
Batavia, Bill: The <tt>&lt;cstdint&gt;</tt> synopsis in  [tr.c99.cinttypes.syn] contains:
]</i></p>

<blockquote><pre>
intmax_t imaxabs(intmax_t i);
intmax_t abs(intmax_t i);

imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
imaxdiv_t div(intmax_t numer, intmax_t denom);
</pre></blockquote>

<p><i>[
and in  [tr.c99.cinttypes.def]:
]</i></p>


<blockquote><p>
The header defines all functions, types, and macros the same as C99
subclause 7.8.
</p></blockquote>

<p><i>[
This is as much definition as we give for most other C99 functions,
so nothing need change. We might, however, choose to add the footnote:
]</i></p>


<blockquote><p>
[<i>Note:</i> These overloads for <tt>abs</tt> and <tt>div</tt> may well be equivalent to
those that take <tt>long long</tt> arguments. If so, the implementation is
responsible for avoiding conflicting declarations. -- <i>end note</i>]
</p></blockquote>

<p><i>[
Bellevue: NAD Editorial. Pete must add a footnote, as described below.
]</i></p>


<blockquote>
<p><i>[
Looks like a real problem. Dietmar suggests div() return a template
type. Matt: looks like imaxdiv_t is loosly defined. Can it be a typedef
for lldiv_t when _Longlong == intmax_t? PJP seems to agree. We would
need a non-normative note declaring that the types lldiv_t and imaxdiv_t
may not be unique if intmax_t==_longlong.
]</i></p>

</blockquote>






<hr>
<h3><a name="558" href="558">558.</a> lib.input.iterators Defect</h3>
<p><b>Section:</b> 25.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2006-02-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#input.iterators">active issues</a> in [input.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote>
<p>
  24.1.1 Input iterators [lib.input.iterators]
</p>
<p>
  1 A class or a built-in type X satisfies the requirements of an
  input iterator for the value type T if the following expressions are
  valid, where U is the type of any specified member of type T, as
  shown in Table 73.
</p>
</blockquote>
<p>
There is no capital U used in table 73.  There is a lowercase u, but
that is clearly not meant to denote a member of type T.  Also, there's
no description in 24.1.1 of what lowercase a means.  IMO the above
should have been...Hah, a and b are already covered in 24.1/11, so maybe it
should have just been:
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.1.1p1:
</p>
<blockquote><p>
-1- A class or a built-in type <tt>X</tt> satisfies the requirements of an
input iterator for the value type <tt>T</tt> if the following expressions 
are valid<del>, where <tt>U</tt> is the type of any specified member of type
<tt>T</tt>,</del> as shown in Table 73.
</p></blockquote>

<p><i>[
Portland: Editorial.
]</i></p>







<hr>
<h3><a name="560" href="560">560.</a> User-defined allocators without default constructor</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sergey P. Derevyago <b>Opened:</b> 2006-02-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<h4>1. The essence of the problem.</h4>
<p>
User-defined allocators without default constructor are not explicitly
supported by the standard but they can be supported just like std::vector
supports elements without default constructor.
</p>
<p>
As a result, there exist implementations that work well with such allocators
and implementations that don't.
</p>

<h4>2. The cause of the problem.</h4>
<p>
1) The standard doesn't explicitly state this intent but it should. In
particular, 20.1.5p5 explicitly state the intent w.r.t. the allocator
instances that compare non-equal. So it can similarly state the intent w.r.t.
the user-defined allocators without default constructor.
</p>
<p>
2) Some container operations are obviously underspecified. In particular,
21.3.7.1p2 tells:
</p>
<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt; operator+(
    const charT* lhs,
    const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs
  );
</pre>
<p>
Returns: <tt>basic_string&lt;charT,traits,Allocator&gt;(lhs) + rhs</tt>.
</p>
</blockquote>
<p>
That leads to the basic_string&lt;charT,traits,Allocator&gt;(lhs, Allocator()) call.
Obviously, the right requirement is:
</p>
<blockquote><p>
Returns: <tt>basic_string&lt;charT,traits,Allocator&gt;(lhs, rhs.get_allocator()) + rhs</tt>.
</p></blockquote>
<p>
It seems like a lot of DRs can be submitted on this "Absent call to
get_allocator()" topic.
</p>

<h4>3. Proposed actions.</h4>
<p>
1) Explicitly state the intent to allow for user-defined allocators without
default constructor in 20.1.5 Allocator requirements.
</p>
<p>
2) Correct all the places, where a correct allocator object is available
through the get_allocator() call but default Allocator() gets passed instead.
</p>
<h4>4. Code sample.</h4>
<p>
Let's suppose that the following memory pool is available:
</p>
<blockquote><pre>
class mem_pool {
      // ...
      void* allocate(size_t size);
      void deallocate(void* ptr, size_t size);
};
</pre></blockquote>
<p>
So the following allocator can be implemented via this pool:
</p>
<blockquote><pre>
class stl_allocator {
      mem_pool&amp; pool;

 public:
      explicit stl_allocator(mem_pool&amp; mp) : pool(mp) {}
      stl_allocator(const stl_allocator&amp; sa) : pool(sa.pool) {}
      template &lt;class U&gt;
      stl_allocator(const stl_allocator&lt;U&gt;&amp; sa)  : pool(sa.get_pool()) {}
      ~stl_allocator() {}

      pointer allocate(size_type n, std::allocator&lt;void&gt;::const_pointer = 0)
      {
       return (n!=0) ? static_cast&lt;pointer&gt;(pool.allocate(n*sizeof(T))) : 0;
      }

      void deallocate(pointer p, size_type n)
      {
       if (n!=0) pool.deallocate(p, n*sizeof(T));
      }

      // ...
};
</pre></blockquote>
<p>
Then the following code works well on some implementations and doesn't work on
another:
</p>
<blockquote><pre>
typedef basic_string&lt;char, char_traits&lt;char&gt;, stl_allocator&lt;char&gt; &gt; 
  tl_string;
mem_pool mp;
tl_string s1("abc", stl_allocator&lt;int&gt;(mp));
printf("(%s)\n", ("def"+s1).c_str());
</pre></blockquote>
<p>
In particular, on some implementations the code can't be compiled without
default stl_allocator() constructor.
</p>
<p>
The obvious way to solve the compile-time problems is to intentionally define
a NULL pointer dereferencing default constructor
</p>
<blockquote><pre>
stl_allocator() : pool(*static_cast&lt;mem_pool*&gt;(0)) {}
</pre></blockquote>
<p>
in a hope that it will not be called. The problem is that it really gets
called by operator+(const char*, const string&amp;) under the current 21.3.7.1p2
wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD.  <tt>operator+()</tt> with <tt>string</tt> already requires the desired
semantics of copying the allocator from one of the strings (<i>lhs</i> when there is a choice).
</p>





<hr>
<h3><a name="568" href="568">568.</a> [tr1] <tt>log2</tt> overloads missing</h3>
<p><b>Section:</b> 8.16.4 [tr1::tr.c99.cmath.over] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-03-07 <b>Last modified:</b> 2016-02-01 11:04:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>log2</tt> is missing from the list of "additional overloads" in 8.16.4 [tr1::tr.c99.cmath.over] p1.
</p>

<p>
Hinnant:  This is a TR1 issue only.  It is fixed in the current (N2135) WD.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree this has been fixed in the Working Draft.
Move to NAD.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add <tt>log2</tt> to the list of functions in 8.16.4 [tr1::tr.c99.cmath.over] p1.
</p>





<hr>
<h3><a name="569" href="569">569.</a> Postcondition for basic_ios::clear(iostate) incorrectly stated</h3>
<p><b>Section:</b> 31.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Seungbeom Kim <b>Opened:</b> 2006-03-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="272">272</a></p>
<p><b>Discussion:</b></p>
<p>
Section: 27.4.4.3 [lib.iostate.flags]
</p>
<p>
Paragraph 4 says:
</p>
<blockquote>
<blockquote><pre>
void clear(iostate <i>state</i> = goodbit);
</pre></blockquote>
<p>
<i>Postcondition:</i> If <tt>rdbuf()!=0</tt> then <tt><i>state</i> == rdstate();</tt>
otherwise <tt>rdstate()==<i>state</i>|ios_base::badbit</tt>.
</p>
</blockquote>

<p>
The postcondition "rdstate()==state|ios_base::badbit" is parsed as
"(rdstate()==state)|ios_base::badbit", which is probably what the
committee meant.
</p>




<p><b>Rationale:</b></p>






<hr>
<h3><a name="570" href="570">570.</a> Request adding additional explicit specializations of <tt>char_traits</tt></h3>
<p><b>Section:</b> 23.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits">[char.traits]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jack Reeves <b>Opened:</b> 2006-04-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the Standard Library specifies only a declaration for template class
<tt>char_traits&lt;&gt;</tt> and requires the implementation provide two explicit
specializations: <tt>char_traits&lt;char&gt;</tt> and <tt>char_traits&lt;wchar_t&gt;</tt>. 
I feel the Standard should require explicit specializations for all built-in 
character types, i.e. <tt>char</tt>, <tt>wchar_t</tt>, <tt>unsigned char</tt>, 
and <tt>signed char</tt>.
</p>
<p>
I have put together a paper
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1985.htm">N1985</a>)
that describes this in more detail and
includes all the necessary wording.
</p>
<p><i>[
Portland: Jack will rewrite
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1985.htm">N1985</a>
to propose a primary template that will work with other integral types.
]</i></p>

<p><i>[
Toronto: issue has grown with addition of <tt>char16_t</tt> and <tt>char32_t</tt>.
]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
We suggest that Jack be asked about the status of his paper, and if it
is not forthcoming, the work-item be assigned to someone else. If no one
steps forward to do the paper before the next meeting, we propose to
make this NAD without further discussion. We leave this Open for now,
but our recommendation is NAD.
</p>
<p>
Note: the issue statement should be updated, as the Toronto comment has
already been resolved. E.g., char_traits specializations for <tt>char16_t</tt>
and <tt>char32_t</tt> are now in the working paper.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote><p>
Nobody has submitted the requested paper, so we move to NAD, as suggested by the decision at the last meeting.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="571" href="571">571.</a> Update C90 references to C99?</h3>
<p><b>Section:</b> 2 <a href="https://timsong-cpp.github.io/cppwp/intro.refs">[intro.refs]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-04-08 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#intro.refs">issues</a> in [intro.refs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
1.2 Normative references [intro.refs] of the WP currently refers to ISO/IEC
9899:1990, Programming languages - C. Should that be changed to ISO/IEC
9899:1999?
</p>
<p>
What impact does this have on the library?
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 1.2/1 [intro.refs] of the WP, change:
</p>
<blockquote>
<ul>
<li>ISO/IEC 9899:<del>1990</del><ins>1999 + TC1 + TC2</ins>, <i>Programming languages - C</i></li>
</ul>
</blockquote>



<p><b>Rationale:</b></p><p>
Recommend NAD, fixed editorially.
</p>




<hr>
<h3><a name="572" href="572">572.</a> Oops, we gave 507 WP status</h3>
<p><b>Section:</b> 28.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a>, 99 [tr.rand] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-04-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Berlin, as a working group, we voted in favor of N1932 which makes issue 507 moot:
variate_generator has been eliminated.  Then in full committee we voted to give
this issue WP status (mistakenly).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike the proposed resolution of issue 507.
</p>
<p><i>[
post-Portland:  Walter and Howard recommend NAD.  The proposed resolution of 507 no longer
exists in the current WD.
]</i></p>



<p><b>Rationale:</b></p>
<p>
NAD.  Will be moot once
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2135.pdf">N2135</a>
is adopted.
</p>





<hr>
<h3><a name="573" href="573">573.</a> C++0x file positioning should handle modern file sizes</h3>
<p><b>Section:</b> 31.5.3 <a href="https://timsong-cpp.github.io/cppwp/fpos">[fpos]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-04-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two deficiencies related to file sizes:
</p>
<ol>
<li>It doesn't appear that the Standard Library is specified in
      a way that handles modern file sizes, which are often too
      large to be represented by an unsigned long.</li>

<li>The <tt>std::fpos</tt> class does not currently have the ability to
      set/get file positions.</li>
</ol>
<p>
The Dinkumware implementation of the Standard Library as shipped with the Microsoft compiler copes with these issues by:
</p>
<ol style="list-style-type:upper-alpha">
<li>Defining <tt>fpos_t</tt> be <tt>long long</tt>, which is large enough to
      represent any file position likely in the foreseeable future.</li>

<li>Adding member functions to class <tt>fpos</tt>. For example,
<blockquote><pre>
fpos_t seekpos() const;
</pre></blockquote>
</li>
</ol>
<p>
Because there are so many types relating to file positions and offsets (<tt>fpos_t</tt>,
<tt>fpos</tt>, <tt>pos_type</tt>, <tt>off_type</tt>, <tt>streamoff</tt>, <tt>streamsize</tt>, 
<tt>streampos</tt>, <tt>wstreampos</tt>, and perhaps more), it is difficult to know if 
the Dinkumware extensions are sufficient. But they seem a useful starting place for 
discussions, and they do represent existing practice.
</p>

<p><i>[
Kona (2007): We need a paper. It would be nice if someone proposed
clarifications to the definitions of <tt>pos_type</tt> and <tt>off_type</tt>. Currently
these definitions are horrible. Proposed Disposition: Open
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is the subject of paper N2926.
</p>
<p>
If we choose to take any action, we will move the paper, so the issue can be closed.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="579" href="579">579.</a> <tt>erase(iterator)</tt> for unordered containers should not return an iterator</h3>
<p><b>Section:</b> 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz <b>Opened:</b> 2006-06-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses ES-2</b></p>

<p>
See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2023.pdf">N2023</a>
for full discussion.
</p>

<p><i>[
2009-12-11 Paolo opens:
]</i></p>


<blockquote><p>
I'm asking for DR 579 to be re-opened, basing on recent discussions on the
library reflector, see Message c++std-lib-26040 and replies.
</p></blockquote>

<p><i>[
2010-02-07 Paolo updates wording.
]</i></p>


<blockquote><p>
As pointed out by Chris in c++std-lib-26040, that an
<tt>erase(unordered_container, iterator)</tt> returning an <tt>iterator</tt> can
easily implemented in user code, if needed; that actually returning an
<tt>iterator</tt> costs nothing for the overload taking two <tt>iterator</tt>s,
thus that proposed change is only for consistency; that
<tt>forward_list::erase_after</tt> also returns <tt>void</tt> (for different
reasons, granted, but isn't that any "<tt>erase</tt>" function in the containers
uniformly returns an <tt>iterator</tt>); that, also in thread started by Chris'
message, Alberto pointed out that the proxy idea isn't a good one; that users
both of the GNU and Boost implementations are reporting serious performance
problems with the current version returning an <tt>iterator</tt>.
</p></blockquote>

<p><i>[
2010-02-07 Original wording saved here:
]</i></p>


<blockquote class="note">
<p>
Option 1:
</p>

<p>
The problem can be eliminated by omitting the requirement that <tt>a.erase(q)</tt> return an 
iterator. This is, however, in contrast with the equivalent requirements for other 
standard containers.
</p>

<p>
Option 2:
</p>

<p>
<tt>a.erase(q)</tt> can be made to compute the next iterator only when explicitly requested: 
the technique consists in returning a proxy object implicitly convertible to <tt>iterator</tt>, so 
that
</p>

<blockquote><pre>
iterator q1=a.erase(q);
</pre></blockquote>

<p>
works as expected, while
</p>

<blockquote><pre>
a.erase(q);
</pre></blockquote>

<p>
does not ever invoke the conversion-to-iterator operator, thus avoiding the associated 
computation. To allow this technique, some sections of TR1 along the line "return value 
is an iterator..." should be changed to "return value is an unspecified object implicitly 
convertible to an iterator..." Although this trick is expected to work transparently, it can 
have some collateral effects when the expression <tt>a.erase(q)</tt> is used inside generic 
code.
</p>

</blockquote>

<p><i>[
2010-03-27 Joaqu&iacute;n adds:
]</i></p>


<blockquote>
<p>
Signature of <tt>iterator erase(const_iterator)</tt> should be changed to <tt>void
erase(const_iterator)</tt>. If this is not viable an acceptable tradeoff
could be to make the return type of <tt>erase(const_iterator)</tt>
<i>implementation defined</i>.
</p>

<p>
The standard should allow implementations of unordered associative
containers using either singly or doubly linked lists.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2023.pdf">N2023</a>
proves that singly-linked lists implementations cannot provide the required
complexity for <tt>iterator erase(const_iterator)</tt>. Thus, some action is
needed to allow both implementations.
</p>

<p> 
Option 1: Changing the required complexity from O(1) to O(log n). This option
merely masks a design flaw. Users are forcefully penalized for what they don't
use (the returned iterator). Besides, they would have to learn about the
pathological (yet very real) situations where using <tt>erase</tt> can lead to
quadratic performance. Two out of these three objections remain even if some
alternative member function like <tt>void quick_erase(const_iterator)</tt> is
thrown in to the interface.
</p>

<p> 
Some objections have been expressed to changing return type of <tt>erase</tt> to
<tt>void</tt>, arguing that it would break current existing practice with
standard library implementations based on doubly-linked lists, where the problem
does not occur. However implementations based on drafts should not block the
resolution of a serious design issue, more so when the issue will hurt future
users of C++, as it's happening already.
</p>

<p> 
Option 2: Make <tt>erase</tt> return type <i>implementation defined</i>. There's
a possible tradeoff with the objectors above consisting in changing the
signature to <i>implementation defined</i> <tt>erase(iterator)</tt>, so that
returning an iterator is indeed a valid extension. To this it can be argued that
this would make implementantions returning an iterator look as somehow promoting
proprietary extensions: this in my opinion is not a valid argument since those
implementations are <em>already</em> extending the required interface by
providing bidirectional iterators (just forward iterators are required).
</p>
</blockquote>

<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
<p>
The issue was lengthy discussed and implementation experience was demonstrated that a non-void return
type is implementable for both single-linked and double-linked lists without loss of efficiency.
</p>

<p>
By a 12-1-1-0 poll voted to keep the return type of erase as <tt>iterator</tt> instead of 
<tt>void</tt> and a second 0-0-3-10 poll rejected the additional proposal to add a 
<tt>quick_erase</tt> returning <tt>void</tt>, thus LWG decided for NAD.
</p>
</blockquote>


<p><b>Rationale:</b></p>

<p>
No consensus for a change.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="580" href="580">580.</a> unused allocator members</h3>
<p><b>Section:</b> 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="479">479</a></p>
<p><b>Discussion:</b></p>
<p>

C++ Standard Library  templates that take an allocator  as an argument
are    required    to    call    the    <code>allocate()</code>    and
<code>deallocate()</code>  members of the  allocator object  to obtain
storage.  However, they do not appear to be required to call any other
allocator      members      such     as      <code>construct()</code>,
<code>destroy()</code>,           <code>address()</code>,          and
<code>max_size()</code>.  This makes these allocator members less than
useful in portable programs.

        </p>
        <p>

It's unclear to me whether the absence of the requirement to use these
allocator  members  is  an  unintentional  omission  or  a  deliberate
choice. However,  since the functions exist in  the standard allocator
and  since  they are  required  to  be  provided by  any  user-defined
allocator I  believe the standard  ought to be clarified  to explictly
specify  whether programs  should or  should not  be able  to  rely on
standard containers calling the functions.

        </p>
        <p>

I  propose  that all  containers  be required  to  make  use of  these
functions.

        </p>
<p><i>[
Batavia:  We support this resolution.  Martin to provide wording.
]</i></p>

<p><i>[
pre-Oxford:  Martin provided wording.
]</i></p>


<p><i>[
2009-04-28 Pablo adds:
]</i></p>


<blockquote><p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2554.pdf">N2554</a>
(scoped allocators),
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>
(allocator concepts), and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2810.pdf">N2810</a>
(allocator defects), address all of these points EXCEPT <tt>max_size()</tt>.
So, I would add a note to that affect and re-class the defect as belonging
to section 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
The comment in the description of this issue that this "would be"
rendered editorial by the adoption of N2257 is confusing. It appears
that N2257 was never adopted.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</p></blockquote>



    <p><b>Proposed resolution:</b></p>
       <p>

Specifically, I propose to change 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>,
p9 as follows:

       </p>
           <blockquote>
<p>
-9- Copy constructors  for all container types defined  in this clause
<ins>that   are  parametrized  on   <code>Allocator</code></ins>  copy
<del>an</del><ins>the</ins>  allocator argument from  their respective
first parameters.

All other  constructors for  these container types  take a<del>n</del>
<ins>const</ins>  <code>Allocator&amp;</code>  argument  (20.1.6),  an
allocator whose <code>value_type</code> is the same as the container's
<code>value_type</code>.

A copy of this  argument <del>is</del><ins>shall be</ins> used for any
memory  allocation <ins> and  deallocation</ins> performed<del>,</del>
by these  constructors and by all  member functions<del>,</del> during
the  lifetime  of each  container  object.   <ins>Allocation shall  be
performed  "as  if"  by  calling  the  <code>allocate()</code>  member
function on  a copy  of the allocator  object of the  appropriate type
<sup>New  Footnote)</sup>,   and  deallocation  "as   if"  by  calling
<code>deallocate()</code> on  a copy of  the same allocator  object of
the corresponding type.</ins>

<ins>A  copy of  this argument  shall also  be used  to  construct and
destroy objects whose lifetime  is managed by the container, including
but not  limited to those of  the container's <code>value_type</code>,
and  to  obtain  their  address.   All  objects  residing  in  storage
allocated by a  container's allocator shall be constructed  "as if" by
calling the <code>construct()</code> member  function on a copy of the
allocator object of  the appropriate type.  The same  objects shall be
destroyed "as if"  by calling <code>destroy()</code> on a  copy of the
same allocator object  of the same type.  The  address of such objects
shall be obtained "as if" by calling the <code>address()</code> member
function  on  a  copy  of  the allocator  object  of  the  appropriate
type.</ins>

<ins>Finally, a copy  of this argument shall be  used by its container
object to determine  the maximum number of objects  of the container's
<code>value_type</code> the container may  store at the same time. The
container  member function <code>max_size()</code> obtains  this number
from      the      value      returned      by     a      call      to
<code>get_allocator().max_size()</code>.</ins>

In   all  container   types  defined   in  this   clause <ins>that  are
parametrized     on    <code>Allocator</code></ins>,     the    member
<code>get_allocator()</code>     returns     a     copy     of     the
<code>Allocator</code>     object     used     to    construct     the
container.<sup>258)</sup>
</p>
<p>
New Footnote: This type  may be different from <code>Allocator</code>:
it     may    be     derived    from     <code>Allocator</code>    via
<code>Allocator::rebind&lt;U&gt;::other</code>   for  the  appropriate
type <code>U</code>.
</p>
           </blockquote>
       <p>

The proposed wording seems cumbersome but I couldn't think of a better
way   to  describe   the   requirement  that   containers  use   their
<code>Allocator</code>  to manage  only objects  (regardless  of their
type)  that  persist  over  their  lifetimes  and  not,  for  example,
temporaries  created on the  stack. That  is, containers  shouldn't be
required  to  call  <code>Allocator::construct(Allocator::allocate(1),
elem)</code>  just to  construct a  temporary copy  of an  element, or
<code>Allocator::destroy(Allocator::address(temp),     1)</code>    to
destroy temporaries.

       </p>


<p><i>[
Howard: This same paragraph will need some work to accommodate <a href="431">431</a>.
]</i></p>


<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>





<hr>
<h3><a name="582" href="582">582.</a> specialized algorithms and volatile storage</h3>
<p><b>Section:</b> 27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>Related to <a href="1029">1029</a></p>
        <p>

The specialized  algorithms [lib.specialized.algorithms] are specified
as having the general effect of invoking the following expression:

        </p>
            <pre>

new (static_cast&lt;void*&gt;(&amp;*i))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type (x)

            </pre>
        <p>

This  expression is  ill-formed  when the  type  of the  subexpression
<code>&amp;*i</code> is some volatile-qualified <code>T</code>.

        </p>

<p><i>[
Batavia:  Lack of support for proposed resolution but agree there is a
defect.  Howard to look at wording.  Concern that move semantics
properly expressed if iterator returns rvalue.
]</i></p>



<p><i>[
2009-06-17 Pablo adds:
]</i></p>


<blockquote>

<p>Propose that Issue <a href="582">582</a> be closed NAD.</p>
<p>
Issue <a href="582">582</a> asks that <tt>uninitialized_copy</tt>,
<tt>uninitialized_fill</tt>, and <tt>uninitialized_fill_n</tt> should be
well-formed if the result type is volatile.  My feeling is that the
standard does not, and should not, guarantee any useful behavior when
constructors are invoked on volatile storage, so making it syntactically
legal to call <tt>uninitialized_copy</tt> on volatile storage is not useful. A
possible editorial change would be to put my previous sentence into a
non-normative note.
</p>
<p>
Note that the three sections starting with 27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a> do not
yet have concepts.  Here's a first crack at the first one:
</p>
<blockquote><pre>
template &lt;InputIterator InIter, OutputIterator OutIter&gt;
requires ExplicitConvertible&lt;HasDereference&lt;OutIter::reference&gt;::result,
                             OutIter::value_type&amp;&gt;
      &amp;&amp; Convertible&lt;OutIter::value_type*, void*&gt;
      &amp;&amp; ExplicitConvertible&lt;OutIter::value_type, InIter::reference&gt;
  OutIter uninitialized_copy(InIter first, InIter last, OutIter result);
</pre>
<blockquote>
<p>
Effects:
</p>
<blockquote><pre>
while (first != last) {
  typedef OutIter::value_type value_type;
  value_type&amp; outRef = static_cast&lt;value_type&amp;&gt;(*result++);
  ::new (static_cast&lt;void*&gt;(addressof(outRef))) value_type(*first++);
}
</pre></blockquote>
</blockquote>

</blockquote>

<p>
Notes:
</p>
<ol>
<li>This definition is actually LESS constrained than in C++03 because
there is no requirement that the result be a forward iterator.
</li>
<li>
If
OutIter returns a proxy type with an overloaded operator&amp;, this
definition probably won't compile.  Lifting this limitation while
allowing value_type to have an overloaded operator&amp; would be hard, but
is probably possible with careful overloading.  I'm not sure it's worth
it.
</li>
<li>
This definition retains the prohibition on the use of volatile types for the result.
</li>
</ol>

</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We don't deal with volatile in the library.
</p>
<p>
Jim: should we state that explicitly somewhere?
</p>
<p>
Beman: you might argue that clause 17 should say something about
volatile. However, if you want to raise we argument, we should open it
as a separate issue and consult with experts on concurrency.
</p>
<p>
Hinnant: actually, some library components do handle volatile, so we'd
need to be very careful about what we say in clause 17.
</p>
<p>
No objection to NAD.
</p>
<p>
Move to NAD.
</p>
</blockquote>

    

    <p><b>Proposed resolution:</b></p>
        <p>

In order  to allow these algorithms  to operate on  volatile storage I
propose to change the expression so as to make it well-formed even for
pointers  to volatile  types.  Specifically,  I propose  the following
changes to clauses 20 and 24. Change 20.6.4.1, p1 to read:

        </p>
            <pre>

<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*result))
        value_type (*first);

            </pre>
        <p>

change 20.6.4.2, p1 to read

        </p>
            <pre>

<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

and change 20.6.4.3, p1 to read

        </p>
            <pre>

<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; n--; ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

In   addition,  since   there   is  no   partial  specialization   for
<code>iterator_traits&lt;volatile T*&gt;</code>  I propose to  add one
to parallel such specialization  for &lt;const T*&gt;. Specifically, I
propose to add the following text to the end of 24.3.1, p3:

        </p>
        <p>

and for pointers to volatile as 

        </p>
            <pre>

namespace std {
template&lt;class T&gt; struct iterator_traits&lt;volatile T*&gt; {
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef volatile T* pointer;
typedef volatile T&amp; reference;
typedef random_access_iterator_tag iterator_category;
};
}

            </pre>
        <p>

Note that  the change to  <code>iterator_traits</code> isn't necessary
in order to implement the  specialized algorithms in a way that allows
them to operate on volatile  strorage. It is only necesassary in order
to specify  their effects in terms  of <code>iterator_traits</code> as
is  done here.   Implementations can  (and some  do) achieve  the same
effect by means of function template overloading.

        </p>
    



<hr>
<h3><a name="583" href="583">583.</a> <tt>div()</tt> for unsigned integral types</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-06-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is no <tt>div()</tt> function for unsigned integer types.
</p>
<p>
There are several possible resolutions.  The simplest one is noted below.  Other
possibilities include a templated solution.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to 26.7 [lib.c.math] paragraph 8:
</p>

<blockquote><pre>
struct udiv_t div(unsigned, unsigned);
struct uldiv_t div(unsigned long, unsigned long);
struct ulldiv_t div(unsigned long long, unsigned long long);
</pre></blockquote>



<p><b>Rationale:</b></p><p>
Toronto:  C99 does not have these unsigned versions because
the signed version exist just to define the implementation-defined behavior
of signed integer division.  Unsigned integer division has no implementation-defined
behavior and thus does not need this treatment.
</p>




<hr>
<h3><a name="584" href="584">584.</a> missing int <tt>pow(int,int)</tt> functionality</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-06-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is no <tt>pow()</tt> function for any integral type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add something like:
</p>

<blockquote><pre>
template&lt; typename T&gt;
T power( T x, int n );
// requires: n &gt;=0
</pre></blockquote>


<p><b>Rationale:</b></p><p>
Toronto:  We already have <tt>double pow(<i>integral</i>, <i>integral</i>)</tt> from 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> p11.
</p>




<hr>
<h3><a name="585" href="585">585.</a> facet error reporting</h3>
<p><b>Section:</b> 30.4 <a href="https://timsong-cpp.github.io/cppwp/locale.categories">[locale.categories]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor, Paolo Carlini <b>Opened:</b> 2006-06-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section  22.2, paragraph 2  requires facet  <code>get()</code> members
that    take    an    <code>ios_base::iostate&amp;</code>    argument,
<code><i>err</i></code>,  to   ignore  the  (initial)   value  of  the
argument, but to set it to <code>ios_base::failbit</code> in case of a
parse error.

        </p>
        <p>

We  believe  there  are  a   few  minor  problems  with  this  blanket
requirement  in   conjunction  with   the  wording  specific   to  each
<code>get()</code> member function.

        </p>
        <p>

First,  besides <code>get()</code>  there are  other  member functions
with     a      slightly     different     name      (for     example,
<code>get_date()</code>). It's not completely clear that the intent of
the  paragraph  is  to  include  those  as  well,  and  at  least  one
implementation has interpreted the requirement literally.

        </p>
        <p>

Second,    the     requirement    to    "set     the    argument    to
<code>ios_base::failbit</code>  suggests that  the  functions are  not
permitted    to   set    it   to    any   other    value    (such   as
<code>ios_base::eofbit</code>,   or   even  <code>ios_base::eofbit   |
ios_base::failbit</code>).

        </p>
        <p>

However, 22.2.2.1.2, p5 (Stage  3 of <code>num_get</code> parsing) and
p6 (<code>bool</code> parsing)  specifies that the <code>do_get</code>
functions  perform <code><i>err</i> |=  ios_base::eofbit</code>, which
contradicts  the earlier  requirement to  ignore  <i>err</i>'s initial
value.

        </p>
        <p>

22.2.6.1.2,  p1  (the  Effects  clause of  the  <code>money_get</code>
facet's  <code>do_get</code>  member  functions) also  specifies  that
<code><i>err</i></code>'s initial  value be used to  compute the final
value  by  ORing  it  with  either  <code>ios_base::failbit</code>  or
with<code>ios_base::eofbit | ios_base::failbit</code>.

        </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Move to NAD.
</p></blockquote>

    

    <p><b>Proposed resolution:</b></p>
        <p>

We believe the  intent is for all facet member  functions that take an
<code>ios_base::iostate&amp;</code> argument to:

        </p>
            <ul>
                <li>

ignore the initial value of the <code><i>err</i></code> argument,

                </li>
                <li>

reset <code><i>err</i></code>  to <code>ios_base::goodbit</code> prior
to any further processing,

                </li>
                <li>

and       set      either       <code>ios_base::eofbit</code>,      or
<code>ios_base::failbit</code>, or both in <code><i>err</i></code>, as
appropriate,  in response  to  reaching the  end-of-file  or on  parse
error, or both.

                </li>
            </ul>
        <p>

To that effect we propose to change 22.2, p2 as follows:

        </p>
        <p>

The  <i>put</i><del>()</del>  members  make  no  provision  for  error
reporting.   (Any  failures of  the  OutputIterator  argument must  be
extracted   from  the   returned  iterator.)    <ins>Unless  otherwise
specified, </ins>the <i>get</i><del>()</del>  members  <ins>that</ins>
take an  <code>ios_base::iostate&amp;</code> argument <del>whose value
they  ignore,  but  set  to  ios_base::failbit  in  case  of  a  parse
error.</del><ins>,   <code><i>err</i></code>,   start  by   evaluating
<code>err  =   ios_base::goodbit</code>,  and  may   subsequently  set
<i>err</i>     to     either     <code>ios_base::eofbit</code>,     or
<code>ios_base::failbit</code>,     or     <code>ios_base::eofbit    |
ios_base::failbit</code> in response to reaching the end-of-file or in
case of a parse error, or both, respectively.</ins>

        </p>
    
    
<p><i>[
Kona (2007): We need to change the proposed wording to clarify that the
phrase "the get members" actually denotes <tt>get()</tt>, <tt>get_date()</tt>, etc.
Proposed Disposition: Open
]</i></p>




<hr>
<h3><a name="587" href="587">587.</a> iststream ctor missing description</h3>
<p><b>Section:</b> D.12.3.2 <a href="https://timsong-cpp.github.io/cppwp/depr.istrstream.cons">[depr.istrstream.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The  <code>iststream(char*, streamsize)</code>  ctor is  in  the class
synopsis  in D.7.2  but its  signature is  missing in  the description
below (in D.7.2.1).

        </p>
    

    <p><b>Proposed resolution:</b></p>
        <p>

This seems like a simple editorial issue and the missing signature can
be added to the one for <code>const char*</code> in paragraph 2.

        </p>

<p><i>[
post Oxford: Noted that it is already fixed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2284.pdf">N2284</a>
]</i></p>


    



<hr>
<h3><a name="588" href="588">588.</a> requirements on zero sized <tt>tr1::arrays</tt> and other details</h3>
<p><b>Section:</b> 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2006-07-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording used for section 23.2.1 [lib.array] seems to be subtly
ambiguous about zero sized arrays (N==0). Specifically:
</p>
<p>
* "An instance of array&lt;T, N&gt; stores N elements of type T, so that
[...]"
</p>
<p>
Does this imply that a zero sized array object stores 0 elements, i.e.
that it cannot store any element of type T? The next point clarifies
the rationale behind this question, basically how to implement begin()
and end():
</p>
<p>
* 23.2.1.5 [lib.array.zero], p2: "In the case that N == 0, begin() ==
end() == unique value."
</p>
<p>
What does "unique" mean in this context? Let's consider the following
possible implementations, all relying on a partial specialization:
</p>
<blockquote><pre>
a)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        ....

        iterator begin()
        { return iterator( reinterpret_cast&lt; T * &gt;( this ) ); }
        ....

    };
</pre></blockquote>
<p>
This has been used in boost, probably intending that the return value
had to be unique to the specific array object and that array couldn't
store any T. Note that, besides relying on a reinterpret_cast, has
(more than potential) alignment problems.
</p>
<blockquote><pre>
b)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        T t;

        iterator begin()
        { return iterator( &amp;t ); }
        ....

    };
</pre></blockquote>
<p>
This provides a value which is unique to the object and to the type of
the array, but requires storing a T. Also, it would allow the user to
mistakenly provide an initializer list with one element.
</p>
<p>
A slight variant could be returning *the* null pointer of type T
</p>
<blockquote><pre>
    return static_cast&lt;T*&gt;(0);
</pre></blockquote>
<p>
In this case the value would be unique to the type array&lt;T, 0&gt; but not
to the objects (all objects of type array&lt;T, 0&gt; with the same value
for T would yield the same pointer value).
</p>
<p>
Furthermore this is inconsistent with what the standard requires from
allocation functions (see library issue 9).
</p>
<p>
c) same as above but with t being a static data member; again, the
value would be unique to the type, not to the object.
</p>
<p>
d) to avoid storing a T *directly* while disallowing the possibility
to use a one-element initializer list a non-aggregate nested class
could be defined
</p>
<blockquote><pre>
    struct holder { holder() {} T t; } h;
</pre></blockquote>
<p>
and then begin be defined as
</p>
<blockquote><pre>
 iterator begin() { return &amp;h.t; }
</pre></blockquote>
<p>
But then, it's arguable whether the array stores a T or not.
Indirectly it does.
</p>
<p>
-----------------------------------------------------
</p>
<p>
Now, on different issues:
</p>
<p>
* what's the effect of calling assign(T&amp;) on a zero-sized array? There
seems to be only mention of front() and back(), in 23.2.1 [lib.array]
p4 (I would also suggest to move that bullet to section 23.2.1.5
[lib.array.zero], for locality of reference)
</p>
<p>
* (minor) the opening paragraph of 23.2.1 [lib.array] wording is a bit
inconsistent with that of other sequences: that's not a problem in
itself, but compare it for instance with "A vector is a kind of
sequence that supports random access iterators"; though the intent is
obvious one might argue that the wording used for arrays doesn't tell
what an array is, and relies on the reader to infer that it is what
the &lt;array&gt; header defines.
</p>
<p>
* it would be desiderable to have a static const data member of type
std::size_t, with value N, for usage as integral constant expression
</p>
<p>
* section 23.1 [lib.container.requirements] seem not to consider
fixed-size containers at all, as it says: "[containers] control
allocation and deallocation of these objects [the contained objects]
through constructors, destructors, *insert and erase* operations"
</p>
<p>
* max_size() isn't specified: the result is obvious but, technically,
it relies on table 80: "size() of the largest possible container"
which, again, doesn't seem to consider fixed size containers
</p>

<p><i>[
2009-05-29 Daniel adds:
]</i></p>


<blockquote>
<ol style="list-style-type:lower-alpha">
<li>
<p>
star bullet 1 ("what's the effect of calling <tt>assign(T&amp;)</tt> on a
zero-sized array?[..]");
</p>
<blockquote><p>
<tt>assign</tt> has been renamed to <tt>fill</tt> and the semantic of <tt>fill</tt> is now
defined in terms of
the free algorithm <tt>fill_n</tt>, which is well-defined for this situation.
</p></blockquote>
</li>
<li>
<p>
star bullet 3 ("it would be desiderable to have a static const data
member..."):
</p>
<blockquote><p>
It seems that <tt>tuple_size&lt;array&lt;T, N&gt; &gt;::value</tt> as of 24.3.7.7 <a href="https://timsong-cpp.github.io/cppwp/array.tuple">[array.tuple]</a> does
provide this functionality now.
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Alisdair to address by the next meeting, or declare NAD.
</p>
<p>
Moved to Tentatively NAD.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to NAD.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><i>[
Kona (2007): requirements on zero sized <tt>tr1::array</tt>s and other details
Issue 617: <tt>std::array</tt> is a sequence that doesn't satisfy the sequence
requirements? Alisdair will prepare a paper. Proposed Disposition: Open
]</i></p>





<hr>
<h3><a name="590" href="590">590.</a> Type traits implementation latitude should be removed for C++0x</h3>
<p><b>Section:</b> 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a>, 99 [tr.meta.req] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-08-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.4.9 [lib.meta.req], Implementation requirements, provides latitude for type
traits implementers that is not needed in C++0x. It includes the wording:
</p>

<blockquote><p>
[<i>Note:</i> the latitude granted to implementers in this clause is temporary,
and is expected to be removed in future revisions of this document. -- <i>end note</i>]
</p></blockquote>

<p>
Note:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2157.html">N2157: Minor Modifications to the type traits Wording</a>
also has the intent of removing this wording from the WP.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Remove 20.4.9 [lib.meta.req] in its entirety from the WP.
</p>

<p><i>[
post-Oxford: Recommend NAD Editorial.  This resolution is now in the
current working draft.
]</i></p>







<hr>
<h3><a name="591" href="591">591.</a> Misleading "built-in</h3>
<p><b>Section:</b> 17.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.members">[numeric.limits.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> whyglinux <b>Opened:</b> 2006-08-08 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.2.1.2 numeric_limits members [lib.numeric.limits.members]
Paragraph 7:
</p>
<blockquote><p>
"For built-in integer types, the number of non-sign bits in the
representation."
</p></blockquote>

<p>
26.1 Numeric type requirements [lib.numeric.requirements]
Footnote:
</p>

<blockquote><p>
"In other words, value types. These include built-in arithmetic types,
pointers, the library class complex, and instantiations of valarray for
value types."
</p></blockquote>

<p>
Integer types (which are bool, char, wchar_t, and the signed and
unsigned integer types) and arithmetic types (which are integer and
floating types) are all built-in types and thus there are no
non-built-in (that is, user-defined) integer or arithmetic types. Since
the redundant "built-in" in the above 2 sentences can mislead that
there may be built-in or user-defined integer and arithmetic types
(which is not correct), the "built-in" should be removed.
</p>


<p><b>Proposed resolution:</b></p>
<p>
18.2.1.2 numeric_limits members [lib.numeric.limits.members]
Paragraph 7:
</p>
<blockquote><p>
"For <del>built-in</del> integer types, the number of non-sign bits in the
representation."
</p></blockquote>

<p>
26.1 Numeric type requirements [lib.numeric.requirements]
Footnote:
</p>

<blockquote><p>
"In other words, value types. These include <del>built-in</del> arithmetic types,
pointers, the library class complex, and instantiations of valarray for
value types."
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
Recommend NAD / Editorial.  The proposed resolution is accepted as editorial.
</p>





<hr>
<h3><a name="592" href="592">592.</a> Incorrect treatment of rdbuf()->close() return type</h3>
<p><b>Section:</b> 31.10.3.4 <a href="https://timsong-cpp.github.io/cppwp/ifstream.members">[ifstream.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2006-08-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ifstream.members">issues</a> in [ifstream.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just spotted a minor problem in 27.8.1.7
[lib.ifstream.members] para 4 and also 27.8.1.13
[lib.fstream.members] para 4. In both places it says:
</p>
<blockquote>
<pre>
void close();
</pre>
<p>
Effects: Calls rdbuf()-&gt;close() and, if that function returns false, ...
</p>
</blockquote>
<p>
However, basic_filebuf::close() (27.8.1.2) returns a pointer to the
filebuf on success, null on failure, so I think it is meant to
say "if that function returns a null pointer". Oddly, it is
correct for basic_ofstream.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 31.10.3.4 <a href="https://timsong-cpp.github.io/cppwp/ifstream.members">[ifstream.members]</a>, p5:
</p>

<blockquote><p>
<i>Effects:</i> Calls <tt>rdbuf()-&gt;close()</tt> and, if that function
<ins>fails (</ins>returns <del><tt>false</tt></del> <ins>a null pointer)</ins>,
calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>
(27.4.4.3)).
</p></blockquote>

<p>
Change 31.10.5.4 <a href="https://timsong-cpp.github.io/cppwp/fstream.members">[fstream.members]</a>, p5:
</p>

<blockquote><p>
<i>Effects:</i> Calls <tt>rdbuf()-&gt;close()</tt> and, if that function
<ins>fails (</ins>returns <del><tt>false</tt></del> <ins>a null pointer)</ins>,
calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>
(27.4.4.3)).
</p></blockquote>



<p><i>[
Kona (2007): Proposed Disposition: NAD, Editorial
]</i></p>





<hr>
<h3><a name="597" href="597">597.</a> [dec.tr] The notion of 'promotion' cannot be emulated by user-defined types.</h3>
<p><b>Section:</b> 3.2 [dec.tr::trdec.types.types] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daveed Vandevoorde <b>Opened:</b> 2006-04-05 <b>Last modified:</b> 2016-01-31 17:16:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#dec.tr::trdec.types.types">issues</a> in [dec.tr::trdec.types.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In a private email, Daveed writes:
</p>
<blockquote>
<p>
I am not familiar with the C TR, but my guess is that the
class type approach still won't match a built-in type
approach because the notion of "promotion" cannot be
emulated by user-defined types.
</p>
<p>
Here is an example:
</p>
</blockquote>
<pre>

         struct S {
           S(_Decimal32 const&amp;);  // Converting constructor
         };
         void f(S);

         void f(_Decimal64);

         void g(_Decimal32 d) {
           f(d);
         }
</pre>

<blockquote>
<p>
If _Decimal32 is a built-in type, the call f(d) will likely
resolve to f(_Decimal64) because that requires only a
promotion, whereas f(S) requires a user-defined conversion.
</p>
<p>
If _Decimal32 is a class type, I think the call f(d) will be
ambiguous because both the conversion to _Decimal64 and the
conversion to S will be user-defined conversions with neither
better than the other.
</p>
</blockquote>
<p>
Robert comments:
</p>
<p>
In general, a library of arithmetic types cannot exactly emulate the behavior of the intrinsic numeric types.  There are several ways to tell whether an implementation of the decimal types uses compiler intrinisics or a library.  For example:
</p>
<pre>
                 _Decimal32 d1;
                 d1.operator+=(5);  // If d1 is a builtin type, this won't compile.
</pre>
<p>
In preparing the decimal TR, we have three options:
</p>
<ol>
<li>require that the decimal types be class types</li>
<li>require that the decimal types be builtin types, like float and double</li>
<li>specify a library of class types, but allow enough implementor latitude that a conforming implementation could instead provide builtin types</li>
</ol>
<p>
We decided as a group to pursue option #3, but that approach implies that implementations may not agree on the semantics of certain use cases (first example, above), or on whether certain other cases are well-formed (second example).  Another potentially important problem is that, under the present definition of POD, the decimal classes are not POD types, but builtins will be.
</p>
<p>
Note that neither example above implies any problems with respect to C-to-C++ compatibility, since neither example can be expressed in C.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Decimal numeric types may either be builtin types or library types. We
only intend to specify the common subset of behaviors of the two
implementation approaches. The front matter of the Decimal TR says this
explicitly.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="606" href="606">606.</a> [dec.tr] allow narrowing conversions</h3>
<p><b>Section:</b> 3.2 [dec.tr::trdec.types.types] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-15 <b>Last modified:</b> 2016-01-31 17:16:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#dec.tr::trdec.types.types">issues</a> in [dec.tr::trdec.types.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In c++std-lib-17205, Martin writes:
</p>
<blockquote><p>
...was it a deliberate design choice to make narrowing assignments ill-formed while permitting narrowing compound assignments?  For instance:
</p></blockquote>
<pre>
      decimal32 d32;
      decimal64 d64;

      d32 = 64;     // error
      d32 += 64;    // okay
</pre>
<p>
In c++std-lib-17229, Robert responds:
</p>
<blockquote><p>
It is a vestige of an old idea that I forgot to remove from the paper.  Narrowing assignments should be permitted.  The bug is that the converting constructors that cause narrowing should not be explicit.  Thanks for pointing this out.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The current state of the Decimal TR is the result of a deliberate design
decision that has been examined many times.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
1.  In "3.2.2 Class <code>decimal32</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversions:
</p>
<pre>
                // <i>3.2.2.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal32(decimal64 <i>d64</i>);
                <del>explicit</del> decimal32(decimal128 <i>d128</i>);
</pre>
<p>
2.  Do the same thing in "3.2.2.2. Conversion from floating-point type."
</p>
<p>
3.  In "3.2.3 Class <code>decimal64</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversion:
</p>
<pre>
                // <i>3.2.3.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal64(decimal128 <i>d128</i>);
</pre>
<p>
4.  Do the same thing in "3.2.3.2. Conversion from floating-point type."
</p>

<p><i>[
Redmond: We prefer explicit conversions for narrowing and implicit for widening.
]</i></p>






<hr>
<h3><a name="614" href="614">614.</a> <tt>std::string</tt> allocator requirements still inconsistent</h3>
<p><b>Section:</b> 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is based on N2134, where 21.3.1/2 states:
"... The Allocator object used shall be a copy of the Allocator object 
passed to the basic_string object's constructor or, if the constructor does 
not take an Allocator argument, a copy of a default-constructed Allocator 
object."
</p>
<p>
Section 21.3.2/1 lists two constructors:
</p>
<blockquote><pre>
basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str );

basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str ,
             size_type pos , size_type n = npos,
             const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
and then says "In the first form, the Allocator value used is copied from 
str.get_allocator().", which isn't an option according to 21.3.1.
</p>
<p><i>[
Batavia:  We need blanket statement to the effect of:
]</i></p>


<ol>
<li>If an allocator is passed in, use it, or,</li>
<li>If a string is passed in, use its allocator.</li>
</ol>
<p><i>[
Review constructors and functions that return a string; make sure we follow these
rules (substr, operator+, etc.).  Howard to supply wording.
]</i></p>


<p><i>[
Bo adds:  The new container constructor which takes only a <tt>size_type</tt> is not
consistent with 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>, p9 which says in part:
]</i></p>


<blockquote><p>
All other constructors for these container types take an
<tt>Allocator&amp;</tt> argument (20.1.2), an allocator whose value type
is the same as the container's value type. A copy of this argument is
used for any memory allocation performed, by these constructors and by
all member functions, during the lifetime of each container object.
</p></blockquote>

<p><i>[
post Bellevue: We re-confirm that the issue is real. Pablo will provide wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Move to NAD.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="615" href="615">615.</a> Inconsistencies in Section 21.4</h3>
<p><b>Section:</b> 23.5 <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in [c.strings].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current draft N2134, 21.4/1 says
</p>
<p>
"Tables 59,228) 60, 61, 62,and 63 229) 230) describe headers &lt;cctype&gt;, 
&lt;cwctype&gt;, &lt;cstring&gt;, &lt;cwchar&gt;, and &lt;cstdlib&gt; (character conversions), 
respectively."
</p>
<p>
Here footnote 229 applies to table 62, not table 63.
</p>
<p>
Also, footnote 230 lists the new functions in table 63, "atoll, strtoll, 
strtoull, strtof, and strtold added by TR1". However, strtof is not present 
in table 63.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD, editorial.  Send to Pete.
</p>





<hr>
<h3><a name="626" href="626">626.</a> new <i>Remark</i> clauses not documented</h3>
<p><b>Section:</b> 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The <i>Remark</i> clauses newly  introduced into the Working Paper 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>)
are  not mentioned  in  16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> where  we list  the
meaning  of <i>Effects</i>, <i>Requires</i>,  and other  clauses (with
the exception  of <i>Notes</i> which are documented  as informative in
16.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/structure.summary">[structure.summary]</a>, p2, and which they replace in many cases).

        </p>
        <p>

Propose add a bullet for <i>Remarks</i> along with a brief description.

        </p>
<p><i>[
Batavia:  Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue: Already resolved in current working paper.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="627" href="627">627.</a> Low memory and exceptions</h3>
<p><b>Section:</b> 17.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2007-01-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#new.delete.single">active issues</a> in [new.delete.single].</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I recognize the need for nothrow guarantees in the exception reporting
mechanism, but I strongly believe that implementors also need an escape hatch
when memory gets really low. (Like, there's not enough heap to construct and
copy exception objects, or not enough stack to process the throw.) I'd like to
think we can put this escape hatch in 17.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a>,
<tt>operator new</tt>, but I'm not sure how to do it. We need more than a
footnote, but the wording has to be a bit vague. The idea is that if
<tt>new</tt> can't allocate something sufficiently small, it has the right to
<tt>abort</tt>/call <tt>terminate</tt>/call <tt>unexpected</tt>.
</p>

<p><i>[
Bellevue: NAD.  1.4p2 specifies a program must behave correctly "within
its resource limits", so no further escape hatch is necessary.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="631" href="631">631.</a> conflicting requirements for <tt>BinaryPredicate</tt></h3>
<p><b>Section:</b> 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2007-01-31 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The general requirements for <tt><tt>BinaryPredicate</tt></tt> (in 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>/8) contradict the implied specific requirements for
some functions. In particular, it says that:
</p>

<blockquote><p>
[...] if an algorithm takes <tt>BinaryPredicate <i>binary_pred</i></tt>
as its argument and <tt><i>first1</i></tt> and <i>first2</i> as its
iterator arguments, it should work correctly in the construct <tt>if
(binary_pred (*<i>first1</i> , *<i>first2</i> )){...}</tt>.
<tt>BinaryPredicate</tt> always takes the first iterator type as its
first argument, that is, in those cases when <tt>T <i>value</i></tt> is
part of the signature, it should work correctly in the context of <tt>if
(binary_pred (*<i>first1</i> , <i>value</i>)){...}</tt>.
</p></blockquote>

<p>
In the description of <tt>upper_bound</tt> (27.8.4.3 <a href="https://timsong-cpp.github.io/cppwp/upper.bound">[upper.bound]</a>/2), however, the use is described as
"<tt>!comp(<i>value</i>, <i>e</i>)</tt>", where <tt><i>e</i></tt> is an
element of the sequence (a result of dereferencing
<tt>*<i>first</i></tt>).
</p>

<p>
In the description of <tt>lexicographical_compare</tt>, we have both
"<tt>*<i>first1</i> &lt; *<i>first2</i></tt>" and "<tt>*<i>first2</i>
&lt; *<i>first1</i></tt>" (which presumably implies "<tt>comp(
*<i>first1</i>, *<i>first2</i> )</tt>" and "<tt>comp( *<i>first2</i>,
*<i>first1</i> )</tt>".
</p>

<p>
Logically, the <tt>BinaryPredicate</tt> is used as an ordering
relationship, with the semantics of "less than".  Depending on the
function, it may be used to determine equality, or any of the inequality
relationships; doing this requires being able to use it with either
parameter first.  I would thus suggest that the requirement be:
</p>

<p>
Alternatively, one could specify an order for each function. IMHO, this
would be more work for the committee, more work for the implementors,
and of no real advantage for the user: some functions, such as
<tt>lexicographical_compare</tt> or <tt>equal_range</tt>, will still require both
functions, and it seems like a much easier rule to teach that both
functions are always required, rather than to have a complicated list of
when you only need one, and which one.
</p>

<p><i>[
Toronto:  Moved to Open.  ConceptGCC seems to get <tt>lower_bound</tt>
and <tt>upper_bound</tt> to work withoutt these changes.
]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Move to Review. The small problem with the "iterator type"
will be fixed. The cited functions (<tt>lower_bound</tt>, <tt>uppwer_bound</tt>,
<tt>equal_range</tt>) don't actually use <tt>BinaryPredicate</tt> , and where it is used,
it is consistent with  [algorithm]/8, so the main complaint of the issue
is moot.
</p></blockquote>

<p><i>[
2010-01-16 Beman clarified wording.
]</i></p>


<p><i>[
2010-01-31: Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p><i>[
post San Francisco:
]</i></p>


<blockquote>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2759.pdf">N2759</a>.
</p>
</blockquote>

<p>
2010-01-31: The draft standard is well specified as is, and this specification
is desired.  Issues <a href="556">556</a> and <a href="870">870</a> solve the remaining
unclearness regarding the meaning of BinaryPredicate.
</p>



<p><b>Proposed resolution:</b></p>
<p><i>Change 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> paragraph 8 as indicated:</i></p>

<blockquote>

<p>
8 The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a
function object that when applied to the result of dereferencing two
corresponding iterators or to dereferencing an iterator and type <tt>T</tt> when
<tt>T</tt> is part of the signature returns a value testable as true. <ins>
<tt>BinaryPredicate</tt> always takes the first iterator <tt>value_type</tt> as
one of its arguments; which argument is unspecified.</ins> <del>In other words,
if</del> <ins> If</ins> an algorithm takes <tt>BinaryPredicate binary_pred</tt>
as its argument and <tt>first1</tt> and <tt>first2</tt> as its iterator
arguments, it should work correctly <ins>both</ins> in the construct <tt>if
(binary_pred(*first1, *first2)){...}</tt> <ins>and <tt>if (binary_pred (*first2,
*first1)){...}</tt></ins>. <del><tt>BinaryPredicate</tt> always takes the first
iterator type as its first argument, that is, in</del> <ins>In</ins> those cases
when <tt>T value</tt> is part of the signature, it should work correctly in the
context of <tt> if (binary_pred(*first1, value)){...}</tt> <ins>and of <tt>if
(binary_pred (value, *first1)){...}</tt></ins>. <del> <tt>binary_pred</tt> shall
not apply any non-constant function through the dereferenced iterators.</del>
<ins>[<i>Note:</i> if the two types are not identical, and neither is
convertable to the other, this may require that the <tt>BinaryPredicate</tt> be
a functional object with two overloaded <tt>operator()()</tt> functions.
&mdash; <i>end note</i>]</ins>
</p>

</blockquote>






<hr>
<h3><a name="632" href="632">632.</a> Time complexity of <tt>size()</tt> for <tt>std::set</tt></h3>
<p><b>Section:</b> 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Lionel B <b>Opened:</b> 2007-02-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group discussion:
</p>
<blockquote>
<p>
Anyone know if the Standard has anything to say about the time complexity
of <tt>size()</tt> for <tt>std::set</tt>?   I need to access a set's size (<em>not</em> 
to know if it is empty!) heavily during an algorithm and was thus wondering 
whether I'd be better off tracking the size "manually" or whether that'd be pointless.
</p>
<p>
That would be pointless. <tt>size()</tt> is O(1).
</p>
<p>
Nit: the standard says "should" have constant time. Implementations may take
license to do worse. I know that some do this for <tt>std::list&lt;&gt;</tt> as a part of
some trade-off with other operation.
</p>

<p>
I was aware of that, hence my reluctance to use size() for std::set.
</p>
<p>
However, this reason would not apply to <tt>std::set&lt;&gt;</tt> as far as I can see.
</p>
<p>
Ok, I guess the only option is to try it and see...
</p>
</blockquote>

<p>
If I have any recommendation to the C++ Standards Committee it is that
implementations must (not "should"!) document clearly[1], where known, the
time complexity of *all* container access operations.
</p>
<p>
[1] In my case (gcc 4.1.1) I can't swear that the time complexity of size()
for std::set is not documented... but if it is it's certainly well hidden
away.
</p>

<p><i>[
Kona (2007): This issue affects all the containers. We'd love to see a
paper dealing with the broad issue. We think that the complexity of the
<tt>size()</tt> member of every container -- except possibly <tt>list</tt> -- should be
O(1). Alan has volunteered to provide wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Mandating O(1) size will not fly, too many implementations would be
invalidated. Alan to provide wording that toughens wording, but that
does not absolutely mandate O(1).
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We observed that the wording "should" (in note a) has no effect.
Howard prefers that O(1) size be mandated.
It is not clear that this issue can be resolved to everyone's satisfaction,
but Alan will provide wording nonetheless.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Fixed by paper N2923.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="633" href="633">633.</a> Return clause mentions undefined "type()"</h3>
<p><b>Section:</b> 22.10.17.3.6 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.targ">[func.wrap.func.targ]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-02-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.targ">issues</a> in [func.wrap.func.targ].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.10.17.3.6 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.targ">[func.wrap.func.targ]</a>, p4 says:
</p>
<blockquote><p>
<i>Returns:</i> If <tt>type() == typeid(T)</tt>, a pointer to the stored
function target; otherwise a null pointer.
</p></blockquote>

<ol>
<li>
There exists neither a type, a typedef <tt>type</tt>, nor member
function <tt>type()</tt> in class template function nor in the global or
<tt>std</tt> namespace.
</li>
<li>
Assuming that <tt>type</tt> should have been <tt>target_type()</tt>,
this description would lead to false results, if <tt>T = <i>cv</i>
void</tt> due to returns clause 22.10.17.3.6 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.targ">[func.wrap.func.targ]</a>, p1.
</li>
</ol>



<p><b>Proposed resolution:</b></p>
<p>
Change 22.10.17.3.6 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.targ">[func.wrap.func.targ]</a>, p4:
</p>

<blockquote><p>
<i>Returns:</i> If <tt><del>type()</del> <ins>target_type()</ins> == typeid(T) <ins>&amp;&amp; typeid(T) !=
typeid(void)</ins></tt>, a pointer to the stored function target;
otherwise a null pointer.
</p></blockquote>

<p><i>[
Pete: Agreed. It's editorial, so I'll fix it.
]</i></p>







<hr>
<h3><a name="636" href="636">636.</a> 26.5.2.3 valarray::operator[]</h3>
<p><b>Section:</b> 28.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/valarray.access">[valarray.access]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signature of the const operator[] has been changed to return a const 
reference.
</p>
<p>
The description in paragraph 1 still says that the operator returns by 
value.
</p>
<p><i>[
Pete recommends editorial fix.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="637" href="637">637.</a> &sect;[c.math]/10 inconsistent return values</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-13 <b>Last modified:</b> 2016-02-01 11:19:56 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a>, paragraph 10 has long lists of added signatures for float and long double 
functions. All the signatures have float/long double return values, which is 
inconsistent with some of the double functions they are supposed to 
overload.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a>, paragraph 10,
</p>

<blockquote><pre>
<del>float</del> <ins>int</ins> ilogb(float);
<del>float</del> <ins>long</ins> lrint(float);
<del>float</del> <ins>long</ins> lround(float);
<del>float</del> <ins>long long</ins> llrint(float);
<del>float</del> <ins>long long</ins> llround(float);

<del>long double</del> <ins>int</ins> ilogb(long double);
<del>long double</del> <ins>long</ins> lrint(long double);
<del>long double</del> <ins>long</ins> lround(long double);
<del>long double</del> <ins>long long</ins> llrint(long double);
<del>long double</del> <ins>long long</ins> llround(long double);
</pre></blockquote>





<hr>
<h3><a name="639" href="639">639.</a> Still problems with exceptions during streambuf IO</h3>
<p><b>Section:</b> 31.7.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/istream.extractors">[istream.extractors]</a>, 31.7.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters">[ostream.inserters]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-02-17 <b>Last modified:</b> 2017-04-22 20:55:04 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.extractors">issues</a> in [istream.extractors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There already exist two active DR's for the wording of  [istream::extractors]/13
from 14882:2003(E), namely <a href="64">64</a> and <a href="413">413</a>.
</p>

<p>
Even with these proposed corrections, already maintained in N2134,
I have the feeling, that the current wording does still not properly
handle the "exceptional" situation. The combination of para 14
</p>

<blockquote><p>
"[..] Characters are extracted and inserted until
any of the following occurs:
</p>
<p>
[..]
</p>
<p>
- an exception occurs (in which case the exception is caught)."
</p></blockquote>

<p>
and 15
</p>

<blockquote><p>
"If the function inserts no characters, it calls setstate(failbit),
which
may throw ios_base::failure (27.4.4.3). If it inserted no characters
because it caught an exception thrown while extracting characters
from *this and failbit is on in exceptions() (27.4.4.3), then the
caught
exception is rethrown."
</p></blockquote>

<p>
both in N2134 seems to imply that any exception, which occurs
*after* at least one character has been inserted is caught and lost
for
ever. It seems that even if failbit is on in exceptions() rethrow is
not
allowed due to the wording "If it inserted no characters because it
caught an exception thrown while extracting".
</p>

<p>
Is this behaviour by design?
</p>

<p>
I would like to add that its output counterpart in 31.7.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters">[ostream.inserters]</a>/7-9
(also
N2134) does not demonstrate such an exception-loss-behaviour.
On the other side, I wonder concerning several subtle differences
compared to input::
</p>
<p>
1) Paragraph 8 says at its end:
</p>

<blockquote><p>
"- an exception occurs while getting a character from sb."
</p></blockquote>

<p>
Note that there is nothing mentioned which would imply that such
an exception will be caught compared to  [istream::extractors]/14.
</p>

<p>
2) Paragraph 9 says:
</p>

<blockquote><p>
"If the function inserts no characters, it calls setstate(failbit)
(which
may throw ios_base::failure (27.4.4.3)). If an exception was thrown
while extracting a character, the function sets failbit in error
state,
and if failbit is on in exceptions() the caught exception is
rethrown."
</p></blockquote>

<p>
The sentence starting with "If an exception was thrown" seems to
imply that such an exception *should* be caught before.
</p>


<p><b>Proposed resolution:</b></p>
<p>
(a) In  [istream::extractors]/15 (N2134) change the sentence
</p>

<blockquote><p>
If the function inserts no characters, it calls
<tt>setstate(failbit)</tt>, which may throw <tt>ios_base::failure</tt>
(27.4.4.3). If <del>it inserted no characters because it caught an
exception thrown while extracting characters from <tt>*this</tt></del>
<ins>an exception was thrown while extracting a character from
<tt>*this</tt>, the function sets <tt>failbit</tt> in error state,</ins>
and <tt>failbit</tt> is on in <tt>exceptions()</tt> (27.4.4.3), then the
caught exception is rethrown.
</p></blockquote>

<p>
(b) In 31.7.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters">[ostream.inserters]</a>/8 (N2134) change the sentence:
</p>

<blockquote>
<p>
Gets characters from <tt>sb</tt> and inserts them in <tt>*this</tt>.
Characters are read from <tt>sb</tt> and inserted until any of the
following occurs:
</p>
<ul>
<li>end-of-file occurs on the input sequence;</li>
<li>inserting in the output sequence fails (in which case the character to be inserted is not extracted);</li>
<li>an exception occurs while getting a character from <tt>sb</tt> <ins>(in which
case the exception is caught)</ins>.</li>
</ul>
</blockquote>



<p><b>Rationale:</b></p><p>
This extractor is described as a formatted input function so the
exception behavior is already specified. There is additional behavior
described in this section that applies to the case in which failbit is
set. This doesn't contradict the usual exception behavior for formatted
input functions because that applies to the case in which badbit is set.
</p>




<hr>
<h3><a name="641" href="641">641.</a> Editorial fix for 27.6.4 (N2134)</h3>
<p><b>Section:</b> 31.7.8 <a href="https://timsong-cpp.github.io/cppwp/ext.manip">[ext.manip]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-02-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The function <tt>f</tt> in para 4 (31.7.8 <a href="https://timsong-cpp.github.io/cppwp/ext.manip">[ext.manip]</a>) references an unknown <tt>strm</tt>
in the following line:
</p>

<blockquote><pre>
mg.get(Iter(str.rdbuf()), Iter(), intl, strm, err, mon);
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 31.7.8 <a href="https://timsong-cpp.github.io/cppwp/ext.manip">[ext.manip]</a>, p4:
</p>

<blockquote><pre>
mg.get(Iter(str.rdbuf()), Iter(), intl, str<del>m</del>, err, mon);
</pre></blockquote>

<p><i>[
Oxford:  Editorial.
]</i></p>







<hr>
<h3><a name="642" href="642">642.</a> Invalidated fstream footnotes in N2134</h3>
<p><b>Section:</b> 31.10.3.4 <a href="https://timsong-cpp.github.io/cppwp/ifstream.members">[ifstream.members]</a>, 31.10.4.4 <a href="https://timsong-cpp.github.io/cppwp/ofstream.members">[ofstream.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-02-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ifstream.members">issues</a> in [ifstream.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard wording of N2134 has extended the 14882:2003(E)
wording for the ifstream/ofstream/fstream open function to fix
a long standing problem, see <a href="409">409</a>.
</p>

<p>
Now it's properly written as
</p>

<blockquote><p>
"If that function does not return a null pointer calls clear(),
otherwise
calls setstate(failbit)[..]"
</p></blockquote>

<p>
instead of the previous
</p>

<blockquote><p>
"If that function returns a null pointer, calls setstate(failbit)[..]
</p></blockquote>

<p>
While the old footnotes saying
</p>

<blockquote><p>
"A successful open does not change the error state."
</p></blockquote>

<p>
where correct and important, they are invalid now for ifstream and
ofstream (because clear *does* indeed modify the error state) and
should be removed (Interestingly fstream itself never had these,
although
they where needed for that time).
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 31.10.3.4 <a href="https://timsong-cpp.github.io/cppwp/ifstream.members">[ifstream.members]</a>, remove footnote:
</p>

<blockquote><p>
<del><sup>334)</sup> A successful open does not change the error state.</del>
</p></blockquote>

<p>
In 31.10.4.4 <a href="https://timsong-cpp.github.io/cppwp/ofstream.members">[ofstream.members]</a>, remove footnote:
</p>

<blockquote><p>
<del><sup>335)</sup> A successful open does not change the error state.</del>
</p></blockquote>






<hr>
<h3><a name="644" href="644">644.</a> Possible typos in 'function' description</h3>
<p><b>Section:</b> 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>
</p>
<p>
The note in paragraph 2 refers to 'undefined void operators', while the
section declares a pair of operators returning <tt>bool</tt>.
</p>

<p><i>[
Post-Sophia Antipolis:
]</i></p>


<blockquote><p>
Changed from Pending WP to Open.  This issue was voted to WP at the same time the operators were
changed from private to deleted.  The two issues stepped on each other.  What do we want the return
type of these deleted functions to be?
</p></blockquote>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest harmonizing this issue with similar classes. E.g. in
20.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.weak">[util.smartptr.weak]</a> <tt>bool</tt> return values for
</p>
<blockquote><pre>
template &lt;class Y&gt; bool operator&lt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&lt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&gt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&gt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;
</pre></blockquote>

<p>
are used and basically all <em>newer</em> provided deleted copy assignment operators
of type <tt>X</tt> use the canonical return type <tt>X&amp;</tt> instead of <tt>void</tt>. Since the note
mentioned in the issue description has now already been changed to
</p>
<blockquote><p>
deleted overloads close possible hole in the type system
</p></blockquote>
<p>
it seems to be of even lesser need to perform the change. Therefore
I recommend declaring the issue as NAD.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with Daniel's recommendation.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>
</p>

<blockquote><pre>
...
private:
   // 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>, undefined operators:
   template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator==(const function&lt;Function2&gt;&amp;);
   template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator!=(const function&lt;Function2&gt;&amp;);
};
</pre></blockquote>

<p>
Change 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>
</p>

<blockquote><pre>
template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator==(const function&lt;Function2&gt;&amp;);
template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator!=(const function&lt;Function2&gt;&amp;);
</pre></blockquote>





<hr>
<h3><a name="645" href="645">645.</a> Missing members in match_results</h3>
<p><b>Section:</b> 32.9 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-02-26 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the description given in 32.9 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a>/2 the class template
match_results "shall satisfy the requirements of a Sequence, [..],
except that only operations defined for const-qualified Sequences
are supported".
Comparing the provided operations from 32.9 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a>/3 with the
sequence/container tables 80 and 81 one recognizes the following
missing operations:
</p>

<p>
1) The members
</p>

<blockquote><pre>
const_iterator rbegin() const;
const_iterator rend() const;
</pre></blockquote>

<p>
should exists because 23.1/10 demands these for containers
(all sequences are containers) which support bidirectional
iterators. Aren't these supported by match_result? This is not
explicitely expressed, but it's somewhat implied by two arguments:
</p>
<p>
(a) Several typedefs delegate to
<tt>iterator_traits&lt;BidirectionalIterator&gt;</tt>.
</p>
<p>
(b) The existence of <tt>const_reference operator[](size_type n) const</tt>
implies even random-access iteration.
I also suggest, that <tt>match_result</tt> should explicitly mention,
which minimum iterator category is supported and if this does
not include random-access the existence of <tt>operator[]</tt> is
somewhat questionable.
</p>
<p>
2) The new "convenience" members
</p>
<blockquote><pre>
const_iterator cbegin() const;
const_iterator cend() const;
const_iterator crbegin() const;
const_iterator crend() const;
</pre></blockquote>
<p>
should be added according to tables 80/81.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following members to the <tt>match_results</tt> synopsis after <tt>end()</tt> in 32.9 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a>
para 3:
</p>

<blockquote><pre>
const_iterator cbegin() const; 
const_iterator cend() const;
</pre></blockquote>

<p>
In section 32.9.5 <a href="https://timsong-cpp.github.io/cppwp/re.results.acc">[re.results.acc]</a> change:
</p>

<blockquote>
<pre>
const_iterator begin() const;
<ins>const_iterator cbegin() const;</ins>
</pre>
<blockquote>
<p>
-7- <i>Returns:</i> A starting iterator that enumerates over all the sub-expressions stored in <tt>*this</tt>.
</p>
</blockquote>

<pre>
const_iterator end() const;
<ins>const_iterator cend() const;</ins>
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> A terminating iterator that enumerates over all the sub-expressions stored in <tt>*this</tt>.
</p>
</blockquote>
</blockquote>



<p><i>[
Kona (2007): Voted to adopt proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>
except removing the entry in the table container requirements.  Moved to Review.
]</i></p>


<p><i>[
Bellevue:  Proposed wording now in the WP.
]</i></p>





<hr>
<h3><a name="647" href="647">647.</a> Inconsistent <tt>regex_search</tt> params</h3>
<p><b>Section:</b> 32.10.3 <a href="https://timsong-cpp.github.io/cppwp/re.alg.search">[re.alg.search]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-02-26 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.10.3 <a href="https://timsong-cpp.github.io/cppwp/re.alg.search">[re.alg.search]</a>/5 declares
</p>

<blockquote><pre>
template &lt;class iterator, class charT, class traits&gt;
bool regex_search(iterator first, iterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</pre></blockquote>

<p>
where it's not explained, which iterator category
the parameter iterator belongs to. This is inconsistent
to the preceding declaration in the synopsis section
32.3 <a href="https://timsong-cpp.github.io/cppwp/re.syn">[re.syn]</a>, which says:
</p>

<blockquote><pre>
template &lt;class BidirectionalIterator, class charT, class traits&gt;
bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 32.10.3 <a href="https://timsong-cpp.github.io/cppwp/re.alg.search">[re.alg.search]</a>/5 replace all three occurences of param "iterator" with
"BidirectionalIterator"
</p>

<blockquote><pre>
template &lt;class <del>iterator</del> <ins>BidirectionalIterator</ins>, class charT, class traits&gt;
  bool regex_search(<del>iterator</del> <ins>BidirectionalIterator</ins> first, <del>iterator</del> <ins>BidirectionalIterator</ins> last, 
                    const basic_regex&lt;charT, traits&gt;&amp; e, 
                    regex_constants::match_flag_type flags = 
                      regex_constants::match_default);
</pre>
<p>
-6- <i>Effects:</i> Behaves "as if" by constructing an object what of
type <tt>match_results&lt;<del>iterator</del>
<ins>BidirectionalIterator</ins>&gt;</tt> and then returning the result
of <tt>regex_search(first, last, what, e, flags)</tt>.
</p>
</blockquote>


<p><b>Rationale:</b></p><p>
Applied to working paper while issue was still in New status.
</p>




<hr>
<h3><a name="648" href="648">648.</a> regex_iterator c'tor needs clarification/editorial fix</h3>
<p><b>Section:</b> 32.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/re.regiter.cnstr">[re.regiter.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-03-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 32.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/re.regiter.cnstr">[re.regiter.cnstr]</a>/2 the effects paragraph starts with:
</p>

<blockquote>
<p>
<i>Effects:</i> Initializes begin and end to point to the beginning and the
end of the target sequence, sets pregex to &amp;re, sets flags to f,[..]
</p></blockquote>

<p>
There are two issues with this description:
</p>

<ol>
<li>
The meaning of very first part of this quote is unclear, because
there is no target sequence provided, instead there are given two
parameters a and b, both of type BidirectionalIterator. The mentioned
part does not explain what a and b represent.
</li>
<li>
There does not exist any parameter f, but instead a parameter
m in the constructor declaration, so this is actually an editorial
fix.
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
In 32.11.1.2 <a href="https://timsong-cpp.github.io/cppwp/re.regiter.cnstr">[re.regiter.cnstr]</a>/2 change the above quoted part by
</p>

<blockquote><p>
<i>Effects:</i> Initializes <tt>begin</tt> and <tt>end</tt> to point to
the beginning and the end of the target sequence <ins>designated by the
iterator range <tt>[a, b)</tt></ins>, sets <tt>pregex</tt> to
<tt>&amp;re</tt>, sets <tt>flags</tt> to <tt><del>f</del>
<ins>m</ins></tt>, then calls <tt>regex_search(begin, end, match,
*pregex, flags)</tt>. If this call returns <tt>false</tt> the
constructor sets <tt>*this</tt> to the end-of-sequence iterator.
</p></blockquote>





<hr>
<h3><a name="649" href="649">649.</a> Several typos in regex_token_iterator constructors</h3>
<p><b>Section:</b> 32.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.cnstr">[re.tokiter.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-03-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.tokiter.cnstr">issues</a> in [re.tokiter.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 32.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.cnstr">[re.tokiter.cnstr]</a>/1+2 both the constructor declaration
and the following text shows some obvious typos:
</p>
<p>
1) The third constructor form is written as
</p>
<blockquote><pre>
template &lt;std::size_t N&gt;
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, 
                       const regex_type&amp; re, 
                       const int (&amp;submatches)[R], 
                       regex_constants::match_flag_type m = 
                         regex_constants::match_default);
</pre></blockquote>

<p>
where the dimensions of submatches are specified by an
unknown value R, which should be N.
</p>
<p>
2) Paragraph 2 of the same section says in its last sentence:
</p>

<blockquote><p>
The third constructor initializes the member <tt>subs</tt> to hold a
copy of the sequence of integer values pointed to by the iterator range
<tt>[&amp;submatches, &amp;submatches + R)</tt>.
</p></blockquote>

<p>
where again R must be replaced by N.
</p>

<p>
3) Paragraph 3 of the same section says in its first sentence:
</p>

<blockquote><p>
Each constructor then sets <tt>N</tt> to <tt>0</tt>, and
<tt>position</tt> to <tt>position_iterator(a, b, re, f)</tt>.
</p></blockquote>

<p>
where a non-existing parameter "f" is mentioned, which must be
replaced
by the parameter "m".
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 32.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.cnstr">[re.tokiter.cnstr]</a>/1:
</p>
<blockquote><pre>
template &lt;std::size_t N&gt;
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, 
                       const regex_type&amp; re, 
                       const int (&amp;submatches)[<del>R</del> <ins>N</ins>], 
                       regex_constants::match_flag_type m = 
                         regex_constants::match_default);
</pre></blockquote>

<p>
Change 32.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.cnstr">[re.tokiter.cnstr]</a>/2:
</p>

<blockquote><p>
<i>Effects:</i> The first constructor initializes the member
<tt>subs</tt> to hold the single value <tt>submatch</tt>. The second
constructor initializes the member <tt>subs</tt> to hold a copy of the
argument <tt>submatches</tt>. The third constructor initializes the
member <tt>subs</tt> to hold a copy of the sequence of integer values
pointed to by the iterator range <tt>[&amp;submatches, &amp;submatches +
<del>R</del> <ins>N</ins>)</tt>.
</p></blockquote>

<p>
Change 32.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.cnstr">[re.tokiter.cnstr]</a>/3:
</p>

<blockquote><p>
Each constructor then sets <tt>N</tt> to <tt>0</tt>, and
<tt>position</tt> to <tt>position_iterator(a, b, re, <del>f</del>
<ins>m</ins>)</tt>. If <tt>position</tt> is not an end-of-sequence
iterator the constructor sets <tt>result</tt> to the address of the
current match. Otherwise if any of the values stored in <tt>subs</tt> is
equal to <tt>-1</tt> the constructor sets <tt>*this</tt> to a suffix
iterator that points to the range <tt>[a, b)</tt>, otherwise the
constructor sets <tt>*this</tt> to an end-of-sequence iterator.
</p></blockquote>






<hr>
<h3><a name="653" href="653">653.</a> Library reserved names</h3>
<p><b>Section:</b> 2 <a href="https://timsong-cpp.github.io/cppwp/intro.refs">[intro.refs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-03-08 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#intro.refs">issues</a> in [intro.refs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
</p>
<blockquote>
<p>
2 <a href="https://timsong-cpp.github.io/cppwp/intro.refs">[intro.refs]</a> Normative references
</p>

<p>
The following standards contain provisions which, through reference in
this text, constitute provisions of this Interna- tional Standard. At
the time of publication, the editions indicated were valid. All
standards are subject to revision, and parties to agreements based on
this International Standard are encouraged to investigate the
possibility of applying the most recent editions of the standards
indicated below. Members of IEC and ISO maintain registers of currently
valid International Standards.
</p>

<ul>
<li>Ecma International, ECMAScript Language Specification, Standard
Ecma-262, third edition, 1999.</li>
<li>ISO/IEC 2382 (all parts), Information technology - Vocabulary</li>
<li>ISO/IEC 9899:1990, Programming languages - C</li>
<li>ISO/IEC 9899/Amd.1:1995, Programming languages - C, AMENDMENT 1: C
Integrity</li>
<li>ISO/IEC 9899:1999, Programming languages - C</li>
<li>ISO/IEC 9899:1999/Cor.1:2001 Programming languages - C</li>
<li>ISO/IEC 9899:1999/Cor.2:2004 Programming languages - C</li>
<li>ISO/IEC 9945:2003, Information Technology-Portable Operating System
Interface (POSIX)</li>
<li>ISO/IEC 10646-1:1993 Information technology - Universal Multiple-Octet
Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual
Plane</li>
</ul>
</blockquote>

<p>
I'm not sure how many of those reserve naming patterns that might affect
us, but I am equally sure I don't own a copy of any of these to check!
</p>
<p>
The point is to list the reserved naming patterns, rather than the
individual names themselves - although we may want to list C keywords
that are valid identifiers in C++ but likely to cause trouble in shared
headers (e.g. restrict)
</p>

<p><i>[
Kona (2007): Recommend NAD.  No one has identified a specific defect, just the possibility of one.
]</i></p>


<p><i>[
Post-Kona: Alisdair request Open. A good example of the problem was a
discussion of the system error proposal, where it was pointed out an all-caps
identifier starting with a capital E conflicted with reserved macro names for
both Posix and C.  I had absolutely no idea of this rule, and suspect I was
not the only one in the room.<br/>
<br/>
Resolution will require someone with access to all the listed documents to
research their respective name reservation rules, or people with access to
specific documents add their rules to this issue until the list is complete.
]</i></p>


<p><i>[
Bellevue: Wording is aleady present in various standards, and no-one has come forward with wording.
Suggest a formal paper rather than a defect report is the correct way to proceed.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="656" href="656">656.</a> Typo in subtract_with_carry_engine declaration</h3>
<p><b>Section:</b> 28.5.2 <a href="https://timsong-cpp.github.io/cppwp/rand.synopsis">[rand.synopsis]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-03-08 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.synopsis">issues</a> in [rand.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.5.2 <a href="https://timsong-cpp.github.io/cppwp/rand.synopsis">[rand.synopsis]</a> the header <tt>&lt;random&gt;</tt> synopsis
contains an unreasonable closing curly brace inside the
<tt>subtract_with_carry_engine</tt> declaration.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the current declaration in 28.5.2 <a href="https://timsong-cpp.github.io/cppwp/rand.synopsis">[rand.synopsis]</a>
</p>

<blockquote><pre>
template &lt;class UIntType, size_t w<del>}</del>, size_t s, size_t r&gt;
class subtract_with_carry_engine;
</pre></blockquote>


<p><i>[
Pete: Recommends editorial.
]</i></p>





<hr>
<h3><a name="657" href="657">657.</a> unclear requirement about header inclusion</h3>
<p><b>Section:</b> 16.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/using.headers">[using.headers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2007-03-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#using.headers">issues</a> in [using.headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/using.headers">[using.headers]</a> states:
</p>

<blockquote><p>
A translation unit shall include a header only outside of any
external declaration or definition, [...]
</p></blockquote>

<p>
I see three problems with this requirement:
</p>

<ol style="list-style-type:lower-alpha">
<li><p>The C++ standard doesn't define what an "external declaration" or
an "external definition" are (incidentally the C99 standard does, and
has a sentence very similar to the above regarding header inclusion).
</p><p>
I think the intent is that the #include directive shall lexically
appear outside *any* declaration; instead, when the issue was pointed
out on comp.std.c++ at least one poster interpreted "external
declaration" as "declaration of an identifier with external linkage".
If this were the correct interpretation, then the two inclusions below
would be legal:
</p>
<blockquote><pre>
  // at global scope
  static void f()
  {
# include &lt;cstddef&gt;
  }

  static void g()
  {
# include &lt;stddef.h&gt;
  }
</pre></blockquote>
<p>
(note that while the first example is unlikely to compile correctly,
the second one may well do)
</p></li>

<li><p>as the sentence stands, violations will require a diagnostic; is
this the intent? It was pointed out on comp.std.c++ (by several
posters) that at least one way to ensure a diagnostic exists:
</p>
<blockquote><p>
   [If there is an actual file for each header,] one simple way
   to implement this would be to insert a reserved identifier
   such as __begin_header  at the start of each standard header.
   This reserved identifier would be ignored for all other
   purposes, except that, at the appropriate point in phase 7, if
   it is found inside an external definition, a diagnostic is
   generated. There's many other similar ways to achieve the same
   effect.
   </p>
<p>                                 --James Kuyper, on comp.std.c++
</p></blockquote></li>

<li><p>is the term "header" meant to be limited to standard headers?
Clause 17 is all about the library, but still the general question is
interesting and affects one of the points in the explicit namespaces
proposal (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1691.html">n1691</a>):
</p>
<blockquote><p>
    Those seeking to conveniently enable argument-dependent
    lookups for all operators within an explicit namespace
    could easily create a header file that does so:
</p><pre>
    namespace mymath::
    {
        #include "using_ops.hpp"
    }
</pre></blockquote>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p><p>
We believe that the existing language does not cause any real confusion
and any new formulation of the rules that we could come up with are
unlikely to be better than what's already in the standard.
</p>




<hr>
<h3><a name="662" href="662">662.</a> Inconsistent handling of incorrectly-placed thousands separators</h3>
<p><b>Section:</b> 30.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2007-04-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From Section 30.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a>, paragraphs 11 and 12, it is implied
that the value read from a stream must be stored
even if the placement of thousands separators does not conform to the
<code>grouping()</code> specification from the <code>numpunct</code> facet.
Since incorrectly-placed thousands separators are flagged as an extraction
failure (by the means of <code>failbit</code>), we believe it is better not
to store the value. A consistent strategy, in which any kind of extraction
failure leaves the input item intact, is conceptually cleaner, is able to avoid
corner-case traps, and is also more understandable from the programmer's point
of view.
</p>
<p>
Here is a quote from <i>"The C++ Programming Language (Special Edition)"</i>
by B.&nbsp;Stroustrup (Section&nbsp;D.4.2.3, pg.&nbsp;897):
</p>
<blockquote><p>
<i>"If a value of the desired type could not be read, failbit is set in r.
[...] An input operator will use r to determine how to set the state of its
stream. If no error was encountered, the value read is assigned through v;
otherwise, v is left unchanged."</i>
</p></blockquote>
<p>
This statement implies that <code>rdstate()</code> alone is sufficient to
determine whether an extracted value is to be assigned to the input item
<i>val</i> passed to <code>do_get</code>. However, this is in disagreement
with the current C++ Standard. The above-mentioned assumption is true in all
cases, except when there are mismatches in digit grouping. In the latter case,
the parsed value is assigned to <i>val</i>, and, at the same time, <i>err</i>
is assigned to <code>ios_base::failbit</code> (essentially "lying" about the
success of the operation). Is this intentional? The current behavior raises
both consistency and usability concerns.
</p>
<p>
Although digit grouping is outside the scope of <code>scanf</code> (on which
the virtual methods of <code>num_get</code> are based), handling of grouping
should be consistent with the overall behavior of scanf. The specification of
<code>scanf</code> makes a distinction between input failures and matching
failures, and yet both kinds of failures have no effect on the input items
passed to <code>scanf</code>. A mismatch in digit grouping logically falls in
the category of matching failures, and it would be more consistent, and less
surprising to the user, to leave the input item intact whenever a failure is
being signaled.
</p>
<p>
The extraction of <code>bool</code> is another example outside the scope of
<code>scanf</code>, and yet consistent, even in the event of a successful
extraction of a <code>long</code> but a failed conversion from
<code>long</code> to <code>bool</code>.
</p>
<p>
Inconsistency is further aggravated by the fact that, when failbit is set,
subsequent extraction operations are no-ops until <code>failbit</code> is
explicitly cleared. Assuming that there is no explicit handling of
<code>rdstate()</code> (as in <code>cin&gt;&gt;i&gt;&gt;j</code>) it is
counter-intuitive to be able to extract an integer with mismatched digit
grouping, but to be unable to extract another, properly-formatted integer
that immediately follows.
</p>
<p>
Moreover, setting <code>failbit</code>, and selectively assigning a value to
the input item, raises usability problems. Either the strategy of
<code>scanf</code> (when there is no extracted value in case of failure), or
the strategy of the <code>strtol</code> family (when there is always an
extracted value, and there are well-defined defaults in case of a failure) are
easy to understand and easy to use. On the other hand, if <code>failbit</code>
alone cannot consistently make a difference between a failed extraction, and a
successful but not-quite-correct extraction whose output happens to be the same
as the previous value, the programmer must resort to implementation tricks.
Consider the following example:
</p>
<pre>
    int i = old_i;
    cin &gt;&gt; i;
    if (cin.fail())
        // can the value of i be trusted?
        // what does it mean if i == old_i?
        // ...
</pre>
<p>
Last but not least, the current behvaior is not only confusing to the casual
reader, but it has also been confusing to some book authors. Besides
Stroustrup's book, other books (e.g. "Standard C++ IOStreams and Locales" by
Langer and Kreft) are describing the same mistaken assumption. Although books
are not to be used instead of the standard reference, the readers of these
books, as well as the people who are generally familiar to <code>scanf</code>,
are even more likely to misinterpret the standard, and expect the input items
to remain intact when a failure occurs.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 30.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a>:
</p>

<blockquote>
<p>
<b>Stage 3:</b> The result of stage 2 processing can be one of
</p>
<ul>
<li>A sequence of <code>chars</code> has been accumulated in stage 2 that is converted (according to the rules of <code>scanf</code>) to a value of the type of <code><i>val</i></code>.  <del>This value is stored in <code><i>val</i></code> and <code>ios_base::goodbit</code> is stored in <code><i>err</i></code>.</del></li>

<li>The sequence of <code>chars</code> accumulated in stage 2 would have caused <code>scanf</code> to report an input failure. <code>ios_base::failbit</code> is assigned to <code><i>err</i></code>.</li>
</ul>
<p>
<ins>In the first case,</ins> <del>D</del><ins>d</ins>igit grouping is checked.  That is, the positions of discarded separators is examined for consistency with <code>use_facet&lt;numpunct&lt;charT&gt; &gt;(<i>loc</i>).grouping()</code>.  If they are not consistent then <code>ios_base::failbit</code> is assigned to <code><i>err</i></code>.  <ins>Otherwise, the value that was converted in stage 2 is stored in <code><i>val</i></code> and <code>ios_base::goodbit</code> is stored in <code><i>err</i></code>.</ins>
</p>
</blockquote>


<p><b>Rationale:</b></p><p>
post-Toronto: Changed from New to NAD at the request of the author.  The preferred solution of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2327.pdf">N2327</a>
makes this resolution obsolete.
</p>




<hr>
<h3><a name="663" href="663">663.</a> Complexity Requirements</h3>
<p><b>Section:</b> 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> para 5 says
</p>

<blockquote><p>
-5- Complexity requirements specified in the library
clauses are upper bounds, and implementations that provide better
complexity guarantees satisfy the requirements.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
The library clauses suggest general
guidelines regarding complexity, but we have been unable to discover
any absolute hard-and-fast formulae for these requirements. Unless
or until the Library group standardizes specific hard-and-fast
formulae, we regard all the complexity requirements as subject to a
"fudge factor" without any intrinsic upper bound.
</p></blockquote>

<p>
[Plum ref
_23213Y31 etc]
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p><p>
Kona (2007): No specific instances of underspecification have been
identified, and big-O notation always involves constant factors.
</p>




<hr>
<h3><a name="667" href="667">667.</a> <tt>money_get</tt>'s widened minus sign</h3>
<p><b>Section:</b> 30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a>, para 1 says:
</p>

<blockquote><p>
The result is returned as an integral value
stored in <tt>units</tt> or as a sequence of digits possibly preceded by a
minus sign (as produced by <tt>ct.widen(c)</tt> where <tt>c</tt> is '-' or in the range
from '0' through '9', inclusive) stored in <tt>digits</tt>.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
Some implementations interpret this to mean that a facet derived from
<tt>ctype&lt;wchar_t&gt;</tt> can provide its own member <tt>do_widen(char)</tt>
which produces e.g. <tt>L'@'</tt> for the "widened" minus sign, and that the
<tt>'@'</tt> symbol will appear in the resulting sequence of digits.  Other
implementations have assumed that one or more places in the standard permit the
implementation to "hard-wire" <tt>L'-'</tt> as the "widened" minus sign.  Are
both interpretations permissible, or only  one?
</p></blockquote>

<p>
[Plum ref _222612Y14]
</p>

<p>
Furthermore: if <tt>ct.widen('9')</tt> produces <tt>L'X'</tt> (a non-digit), does a
parse fail if a <tt>'9'</tt> appears in the subject string? [Plum ref _22263Y33]
</p>

<p><i>[
Kona (2007): Bill and Dietmar to provide proposed wording.
]</i></p>


<p><i>[
post Bellevue: Bill adds:
]</i></p>


<blockquote><p>
The Standard is clear that the minus sign stored in <tt>digits</tt> is <tt>ct.widen('-')</tt>.
The subject string must contain characters <tt>c</tt> in the set <tt>[-0123456789]</tt>
which are translated by <tt>ct.widen(c)</tt> calls before being stored in <tt>digits</tt>;
the widened characters are not relevant to the parsing of the subject string.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with Bill's comment above,
in line with the first of the interpretations offered in the issue.
Move to NAD.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="668" href="668">668.</a> <tt>money_get</tt>'s empty minus sign</h3>
<p><b>Section:</b> 30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a>, para 3 says:
</p>

<blockquote><p>
If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign
that corresponds to the source of the empty string.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
A <tt>negative_sign</tt> of "" means "there is no
way to write a negative sign" not "any null sequence is a negative
sign, so it's always there when you look for it".
</p></blockquote>

<p>
[Plum ref _222612Y32]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording and interpretation of existing wording.
]</i></p>


<p>
Related to <a href="669">669</a>.
</p>

<p><i>[
2009-05-17 Howard adds:
]</i></p>


<blockquote>
<p>
I disagree that a <tt>negative_sign</tt> of "" means "there is no way to
write a negative sign".  The meaning requires the sentences of 30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a> p3 following that quoted above to be
taken into account:
</p>

<blockquote><p>
-3- ... If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign that
corresponds to the source of the empty string. Otherwise, the character
in the indicated position must match the first character of <tt>pos</tt>
or <tt>neg</tt>, and the result is given the corresponding sign. If the
first character of <tt>pos</tt> is equal to the first character of
<tt>neg</tt>, or if both strings are empty, the result is given a
positive sign.
</p></blockquote>

<p>
So a <tt>negative_sign</tt> of "" means "there is no way to write a
negative sign" only when <tt>positive_sign</tt> is also "".  However
when <tt>negative_sign</tt> is "" and <tt>postive_sign.size() &gt;
0</tt>, then one writes a negative value by not writing the
<tt>postive_sign</tt> in the position indicated by
<tt>money_base::sign</tt>.
For example:
</p>

<blockquote><pre>
pattern = {symbol, sign, value, none}
positive_sign = "+"
negative_sign = ""
$123   // a negative value, using optional sign
$+123  // a positive value
$-123  // a parse error
</pre></blockquote>

<p>
And:
</p>

<blockquote><pre>
pattern = {symbol, sign, value, none}
positive_sign = ""
negative_sign = ""
$123   // a positive value, no sign possible
$+123  // a parse error
$-123  // a parse error
</pre></blockquote>


<p>
And (regarding <a href="669">669</a>):
</p>

<blockquote><pre>
pattern = {symbol, sign, value, none}
positive_sign = "-"
negative_sign = "-"
$123   // a parse error, sign is mandatory
$+123  // a parse error
$-123  // a positive value
</pre></blockquote>


<p>
The text seems both unambiguous and clear to me.  I recommend NAD for
both this issue and <a href="669">669</a>.  However I would have no
objection to adding examples such as those above.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This discussion applies equally to issue <a href="669">669</a> (q.v.).
Howard has added examples above,
and recommends either NAD or a resolution that adds his (or similar) examples
to the Working Paper.
</p>
<p>
Alan would like to rewrite paragraph 3.
</p>
<p>
We recommend moving to NAD.
Anyone who feels strongly about adding the examples
is invited to submit corresponding wording.
We further recommend issue <a href="669">669</a> be handled identically.
</p>
</blockquote>

<p><i>[
2009-07-14 Alan reopens with improved wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
No consensus for closing as NAD.  Leave in Review.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD.  Agreed that the original assessment as NAD was correct.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a> p3:
</p>

<blockquote><p>
-3- <del>If the first character (if any) in the string pos returned by
<tt>mp.positive_sign()</tt> or the string <tt>neg</tt> returned by
<tt>mp.negative_sign()</tt> is recognized in the position indicated by
sign in the format pattern, it is consumed and any remaining characters
in the string are required after all the other format components.
[<i>Example:</i> If <tt>showbase</tt> is off, then for a <tt>neg</tt>
value of "()" and a currency symbol of "L", in "(100 L)" the "L" is
consumed; but if <tt>neg</tt> is "-", the "L" in "-100 L" is not
consumed. -- <i>end example</i>] If <tt>pos</tt> or <tt>neg</tt> is
empty, the sign component is optional, and if no sign is detected, the
result is given the sign that corresponds to the source of the empty
string. Otherwise, the character in the indicated position must match
the first character of <tt>pos</tt> or <tt>neg</tt>, and the result is
given the corresponding sign. If the first character of <tt>pos</tt> is
equal to the first character of <tt>neg</tt>, or if both strings are
empty, the result is given a positive sign.</del>

<ins>The sign pattern strings <tt>pos</tt> and <tt>neg</tt> are returned by
<tt>mp.positive_sign()</tt> and <tt>mp.negative_sign()</tt> respectively. A sign pattern
is matched if its first character is recognized in <tt>s</tt> in the position
indicated by <tt>sign</tt> in the format pattern, or if the pattern is empty and
there is no sign recognized in <tt>s</tt>. A match is required to occur. If both
patterns are matched, the result is given a positive sign, otherwise the
result is given the sign corresponding to the matched pattern. 
If the pattern contains more than one character, the characters after the first 
must be matched in <tt>s</tt> after all other format components. 
If any sign
characters are matched, <tt>s</tt> is consumed up to and including those characters.
[<i>Example:</i> If <tt>showbase</tt> is off, then for a <tt>neg</tt>
value of "<tt>()</tt>" and a currency symbol of "<tt>L</tt>", in
"<tt>(100 L)</tt>" the entire string is consumed; but for a <tt>neg</tt>
value of "<tt>-</tt>", in "<tt>-100 L</tt>", the string is consumed
through the second "<tt>0</tt>" (the space and "<tt>L</tt>" are not consumed). &mdash; <i>end
example</i>] </ins>
</p></blockquote>





<hr>
<h3><a name="669" href="669">669.</a> Equivalent postive and negative signs in <tt>money_get</tt></h3>
<p><b>Section:</b> 30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a>, para 3 sentence 4 says:
</p>

<blockquote><p>
If the first character of <tt>pos</tt> is equal to the first character of <tt>neg</tt>, 
or if both strings are empty, the result is given a positive sign.
</p></blockquote>

<p>
One interpretation is that an input sequence must match either the
positive pattern or the negative pattern, and then in either event it
is interpreted as positive.  The following objections has been raised:
</p>

<blockquote><p>
The input can successfully match only a positive sign, so the negative
pattern is an unsuccessful match.
</p></blockquote>

<p>
[Plum ref _222612Y34, 222612Y51b]
</p>

<p><i>[
Bill to provide proposed wording and interpretation of existing wording.
]</i></p>


<p><i>[
2009-05-17 See Howard's comments in related issue <a href="668">668</a>.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This discussion applies equally to issue <a href="668">668</a> (q.v.).
Howard has added examples there,
and recommends either NAD or a resolution that adds his (or similar) examples
to the Working Paper.
</p>
<p>
We recommend moving to NAD.
Anyone who feels strongly about adding the examples
is invited to submit corresponding wording.
We further recommend issue <a href="668">668</a> be handled identically.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="670" href="670">670.</a> <tt>money_base::pattern</tt> and <tt>space</tt></h3>
<p><b>Section:</b> 30.4.7.4 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct">[locale.moneypunct]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.moneypunct">issues</a> in [locale.moneypunct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="836">836</a></p>
<p><b>Discussion:</b></p>
<p>
30.4.7.4 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct">[locale.moneypunct]</a>, para 2 says:
</p>

<blockquote><p>
The value <tt>space</tt> indicates that at least one space is required at 
that position.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
Whitespace is optional when matching space. (See 30.4.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.money.get.virtuals">[locale.money.get.virtuals]</a>, para 2.)
</p></blockquote>

<p>
[Plum ref _22263Y22]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording. We agree that C++03 is
ambiguous, and that we want C++0X to say "space" means 0 or more
whitespace characters on input.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="683" href="683">683.</a> regex_token_iterator summary error</h3>
<p><b>Section:</b> 32.11.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter">[re.tokiter]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2007-06-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.tokiter">issues</a> in [re.tokiter].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.11.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter">[re.tokiter]</a>, p3 says:
</p>
<blockquote>
<p>
After it is constructed, the iterator finds and stores a value
<tt>match_results&lt;BidirectionalIterator&gt;</tt> position and sets the
internal count <tt>N</tt> to zero.
</p>
</blockquote>

<p>
Should read:
</p>

<blockquote>
<p>
After it is constructed, the iterator finds and stores a value
<tt><del>match_results</del><ins>regex_iterator</ins>&lt;BidirectionalIterator<ins>, charT, traits</ins>&gt;</tt>
position and sets the internal count <tt>N</tt> to zero.
</p>
</blockquote>

<p><i>[
John adds:
]</i></p>


<blockquote><p>
Yep, looks like a typo/administrative fix to me.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="684" href="684">684.</a> Unclear which members of match_results should be used in comparison</h3>
<p><b>Section:</b> 32.9 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Nozomu Katoo <b>Opened:</b> 2007-05-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 32.3 <a href="https://timsong-cpp.github.io/cppwp/re.syn">[re.syn]</a> of N2284, two template functions 
are declared here: 
</p>
<blockquote><pre>
// 28.10, class template match_results: 
  &lt;<i>snip</i>&gt;
// match_results comparisons 
  template &lt;class BidirectionalIterator, class Allocator&gt; 
    bool operator== (const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                     const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2); 
  template &lt;class BidirectionalIterator, class Allocator&gt; 
    bool operator!= (const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                     const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2); 

// 28.10.6, match_results swap:
</pre></blockquote>

<p>
But the details of these two bool operator functions (i.e., which members of
<tt>match_results</tt> should be used in comparison) are not described in any
following sections.
</p>

<p><i>[
John adds:
]</i></p>


<blockquote><p>
That looks like a bug: <tt>operator==</tt> should return <tt>true</tt> only if
the two objects refer to the same match - ie if one object was constructed as a
copy of the other.
</p></blockquote>

<p><i>[
Kona (2007): Bill and Pete to add minor wording to that proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Add a new section after 32.9.8 <a href="https://timsong-cpp.github.io/cppwp/re.results.swap">[re.results.swap]</a>, which reads:
</p>
<p>
28.10.7 match_results non-member functions.
</p>

<blockquote>
<pre>
template&lt;class BidirectionalIterator, class Allocator&gt; 
  bool operator==(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                  const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>true</tt> only if the two objects refer to the same match.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>
template&lt;class BidirectionalIterator, class Allocator&gt; 
  bool operator!=(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                  const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>!(m1 == m2)</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>
template&lt;class BidirectionalIterator, class Allocator&gt; 
  void swap(match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
            match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>m1.swap(m2)</tt>.
</p>
</blockquote>
</blockquote>


<p><i>[
Bellevue:  Proposed wording now in WP.
]</i></p>





<hr>
<h3><a name="686" href="686">686.</a> <tt>unique_ptr</tt> and <tt>shared_ptr</tt> fail to specify non-convertibility to int for unspecified-bool-type</h3>
<p><b>Section:</b> 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a>, 20.3.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2007-06-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.observers">issues</a> in [unique.ptr.single.observers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library uses the <tt>operator <i>unspecified-bool-type</i>() const</tt> idiom in
five places. In three of those places (22.10.17.3.4 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.cap">[func.wrap.func.cap]</a>, function capacity 
for example) the returned value is constrained to disallow
unintended conversions to int. The standardese is
</p>
<blockquote><p>
The return type shall not be convertible to <tt>int</tt>.
</p></blockquote>
<p>
This constraint is omitted for <tt>unique_ptr</tt> and <tt>shared_ptr</tt>. It should be added for those.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Close as NAD. Accepting paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2435.htm">N2435</a>
makes it irrelevant.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
To the <i>Returns</i> paragraph for <tt>operator <i>unspecified-bool-type</i>()
const</tt> of 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> paragraph 11 and 20.3.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> paragraph 16, add the sentence:
</p>
<blockquote><p>
The return type shall not be convertible to <tt>int</tt>.
</p></blockquote>


<p><i>[
Kona (2007): Uncertain if <tt>nullptr</tt> will address this issue.
]</i></p>





<hr>
<h3><a name="690" href="690">690.</a> abs(long long) should return long long</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2007-06-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Quoting the latest draft (n2135), 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a>: 
</p>

<blockquote>
<p>
The added signatures are:
</p>
<blockquote><pre>
long abs(long); // labs()
long abs(long long); // llabs()
</pre></blockquote>
</blockquote>
<p>
Shouldn't <tt>abs(long long)</tt> have <tt>long long</tt> as return type?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a>: 
</p>
<blockquote><pre>
<ins>long </ins>long abs(long long); // llabs()
</pre></blockquote>


<p><b>Rationale:</b></p><p>
Had already been fixed in the WP by the time the LWG reviewed this.
</p>




<hr>
<h3><a name="701" href="701">701.</a> [tr1] assoc laguerre poly's</h3>
<p><b>Section:</b> 5.2.1.1 [tr1::tr.num.sf.Lnm] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Crawford <b>Opened:</b> 2007-06-30 <b>Last modified:</b> 2016-02-01 11:04:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I see that the definition the associated Laguerre
polynomials 5.2.1.1 [tr1::tr.num.sf.Lnm] has been corrected since
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf">N1687</a>.
However, the draft standard only specifies ranks of integer value <tt>m</tt>,
while the associated Laguerre polynomials are actually valid for real
values of <tt>m &gt; -1</tt>.  In the case of non-integer values of <tt>m</tt>, the
definition  <tt><i>L</i><sub>n</sub><sup>(m)</sup> = (1/n!)e<sup>x</sup>x<sup>-m</sup> (d/dx)<sup>n</sup> (e<sup>-x</sup>x<sup>m+n</sup>)</tt>
must be used, which also holds for integer values of <tt>m</tt>.  See
Abramowitz &amp; Stegun, 22.11.6 for the general case, and 22.5.16-17 for
the integer case.  In fact fractional values are most commonly used in
physics, for example to <tt>m = +/- 1/2</tt> to describe the harmonic
oscillator in 1 dimension, and <tt>1/2, 3/2, 5/2, ...</tt> in 3
dimensions.
</p>
<p>
If I am correct, the calculation of the more general case is no
more difficult, and is in fact the function implemented in the GNU
Scientific Library.  I would urge you to consider upgrading the 
standard, either adding extra functions for real <tt>m</tt> or switching the
current ones to <tt>double</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We understand the issue, and have opted not to extend as recommended.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="702" href="702">702.</a> [tr1] Restriction in associated Legendre functions</h3>
<p><b>Section:</b> 5.2.1.2 [tr1::tr.num.sf.Plm] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Crawford <b>Opened:</b> 2007-06-30 <b>Last modified:</b> 2016-02-01 11:04:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One other small thing, in 5.2.1.2 [tr1::tr.num.sf.Plm], the restriction should  be
<tt>|x| &lt;= 1</tt>, not <tt>x &gt;= 0</tt>.</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The error has been corrected in the pending IS.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="707" href="707">707.</a> null pointer constant for <tt>exception_ptr</tt></h3>
<p><b>Section:</b> 17.10.7 <a href="https://timsong-cpp.github.io/cppwp/propagation">[propagation]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2007-07-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
From the Toronto Core wiki:
</p>

<p>
What do you mean by "null pointer constant"? How do you guarantee that
<tt>exception_ptr() == 1</tt> doesn't work?  Do you even want to prevent that?
What's the semantics?  What about <tt>void *p = 0; exception_ptr() == p</tt>?
Maybe disallow those in the interface, but how do you do that with
portable C++? Could specify just "make it work".
</p>

<p>
Peter's response:
</p>

<p>
null pointer constant as defined in 7.3.12 <a href="https://timsong-cpp.github.io/cppwp/conv.ptr">[conv.ptr]</a>. Intent is "just make it
work", can be implemented as assignment operator taking a unique pointer
to member, as in the unspecified bool type idiom.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Original implementation was possible using the "unspecified-null-pointer" idiom, similar to unspecified-bool.
</p>
<p>
Even simpler now with nullptr_t.
</p>
<p>
NAD Rationale : null pointer constant is a perfectly defined term, and
while API is clearly implementable there is no need to spell out
implementation details.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="708" href="708">708.</a> Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 30 <a href="https://timsong-cpp.github.io/cppwp/localization">[localization]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-07-28 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>


<p><i>[
San Francisco: Bill and Nick still intend to provide wording, but this
is a part of the task to be addressed by the group that will look into
issue <a href="860">860</a>.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's our intention to stay in sync with WG14. If WG14 makes a decision
that requires a change in WG21 the issue will be reopened.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: <tt>uselocale()</tt> is bad; pass locales around as objects</p>

<p><i>[Kona 2019]</i></p>

<p>Jonathan points out: The standard already allows per-thread locales, see [locale] p9.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="717" href="717">717.</a> Incomplete <tt>valarray::operator[]</tt> specification in [valarray.access]</h3>
<p><b>Section:</b> 28.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/valarray.access">[valarray.access]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-08-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the return type of <tt>valarray</tt>'s <tt>operator[] const</tt> overload has been
changed to <tt>const T&amp;</tt> as described in <a href="389">389</a> several paragraphs of
the section 28.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/valarray.access">[valarray.access]</a> are now
incompletely
specified, because many requirements and guarantees should now also
apply to the const overload. Most notably, the address and reference
guarantees should be extended to the const overload case.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/valarray.access">[valarray.access]</a>:
</p>

<blockquote>
<p>
-1- <del>When applied to a constant array, the subscript operator returns a
reference to the corresponding element of the array. When applied to a
non-constant array, t</del><ins>T</ins>he subscript operator returns a
reference to the corresponding element of the array.
</p>

<p>
-3- The expression <tt>&amp;a[i+j] == &amp;a[i] + j</tt> evaluates as <tt>true</tt> for all <tt>size_t i</tt>
and <tt>size_t j</tt> such that <tt>i+j</tt> is less 
than the length of the <del>non-constant</del> array <tt>a</tt>.
</p>

<p>
-4- Likewise, the expression <tt>&amp;a[i] != &amp;b[j]</tt> evaluates
as <tt>true</tt> for any two <del>non-constant</del> arrays <tt>a</tt> and
<tt>b</tt> and for any <tt>size_t i</tt> and <tt>size_t j</tt> such that
<tt>i</tt> is less than the length of <tt>a</tt> and <tt>j</tt> is less
than the length of <tt>b</tt>. This property indicates an absence of
aliasing and may be used to advantage by optimizing
compilers.<sup>281)</sup>
</p>

<p>
-5- The reference returned by the subscript operator for a<ins>n</ins> <del>non-constant</del> array is guaranteed to be valid until
the member function <tt>resize(size_t, T)</tt> (26.5.2.7) is called for that array or until the lifetime 
of that array ends, whichever happens first.
</p>

</blockquote>






<hr>
<h3><a name="718" href="718">718.</a> <tt>basic_string</tt> is not a sequence</h3>
<p><b>Section:</b> 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>/3 states:
</p>

<blockquote>
<p>
The class template <tt>basic_string</tt> conforms to the requirements for a 
Sequence (23.1.1) and for a Reversible Container (23.1).
</p>
</blockquote>

<p>
First of all, 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> is no longer "Sequence" but "Sequence container". 
Secondly, after the resent changes to containers (<tt>emplace</tt>, <tt>push_back</tt>, 
<tt>const_iterator</tt> parameters to <tt>insert</tt> and <tt>erase</tt>), <tt>basic_string</tt> is not 
even close to conform to the current requirements.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<ul>
<li>emplace, for example, may not make sense for strings. Is also likely suboptimal</li>
<li>with concepts do we need to maintain string as sequence container?</li>
<li>One approach might be to say something like: string is a sequence except it doesn't have these functions</li>
</ul>
<ul>
<li>basic_string already has push_back</li>
<li>const_iterator parameters to insert and erase should be added to basic_string</li>
<li>this leaves emplace to handle -- we have the following options:
<ul>
<li>option 1: add it to string even though it's optional</li>
<li>option 2: make emplace optional to sequences (move from table 89 to 90)</li>
<li>option 3: say string not sequence (the proposal),</li>
<li>option 4: add an exception to basic string wording.</li>
</ul>
</li>
</ul>
<p>General consensus is to suggest option 2.</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Move to NAD Editorial
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove this sentence, in recognition of the fact that <tt>basic_string</tt> is 
not just a <tt>vector</tt>-light for literal types, but something quite 
different, a string abstraction in its own right.
</p>





<hr>
<h3><a name="721" href="721">721.</a> <tt>wstring_convert</tt> inconsistensies</h3>
<p><b>Section:</b> D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-27 <b>Last modified:</b> 2017-04-22 20:23:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.string">active issues</a> in [depr.conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.string">issues</a> in [depr.conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 says that the <tt>Codecvt</tt> template parameter shall meet the 
requirements of <tt>std::codecvt</tt>, even though <tt>std::codecvt</tt> itself cannot 
be used (because of a protected destructor).
</p>

<p>
How are we going to explain this code to beginning programmers?
</p>

<blockquote><pre>
template&lt;class I, class E, class S&gt;
struct codecvt : std::codecvt&lt;I, E, S&gt;
{
    ~codecvt()
    { }
};

void main()
{
    std::wstring_convert&lt;codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt; compiles_ok;
    
    std::wstring_convert&lt;std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt;   not_ok;
}
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Bill will propose a resolution.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
codecvt isn't intended for beginning programmers. This is a regrettable
consequence of the original design of the facet.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="725" href="725">725.</a> Optional sequence container requirements column label</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2007-09-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 90: (Optional sequence container operations) states the
"assertion note pre/post-condition" of <tt>operator[]</tt> to be
</p>

<blockquote><pre>
*(a.begin() + n)
</pre></blockquote>

<p>
Surely that's meant to be "operational semantics?"
</p>



<p><b>Proposed resolution:</b></p>
<blockquote>
<table border="1">
<caption>Table 90: Optional sequence container operations</caption>
<tr>
<th>expression</th> <th>return type</th> <th><del>assertion/note<br/>pre/post-condition</del><br/> <ins>operational semantics</ins></th> <th>container</th>
</tr>
</table>
</blockquote>






<hr>
<h3><a name="726" href="726">726.</a> Missing <tt>regex_replace()</tt> overloads</h3>
<p><b>Section:</b> 32.10.4 <a href="https://timsong-cpp.github.io/cppwp/re.alg.replace">[re.alg.replace]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-09-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Two overloads of <tt>regex_replace()</tt> are currently provided:
</p>

<blockquote><pre>
template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
 
template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
</pre></blockquote>

<ol>
<li>Overloads taking <tt>const charT *</tt> are provided for <tt>regex_match()</tt> and
<tt>regex_search()</tt>, but not <tt>regex_replace()</tt>.  This is inconsistent.</li>
<li>
<p>The absence of <tt>const charT *</tt> overloads prevents ordinary-looking code from compiling, such as:</p>

<blockquote><pre>
const string s("kitten");
const regex r("en");
cout &lt;&lt; regex_replace(s, r, "y") &lt;&lt; endl;
</pre></blockquote>

<p>
The compiler error message will be something like "could not deduce
template argument for 'const std::basic_string&lt;_Elem&gt; &amp;' from 'const
char[1]'".
</p>

<p>
Users expect that anything taking a <tt>basic_string&lt;charT&gt;</tt> can also take a
<tt>const charT *</tt>.  In their own code, when they write a function taking
<tt>std::string</tt> (or <tt>std::wstring</tt>), they can pass a <tt>const char *</tt> (or <tt>const
wchar_t *</tt>), thanks to <tt>basic_string</tt>'s implicit constructor.  Because the
regex algorithms are templated on <tt>charT</tt>, they can't rely on
<tt>basic_string</tt>'s implicit constructor (as the compiler error message
indicates, template argument deduction fails first).
</p>

<p>
If a user figures out what the compiler error message means, workarounds
are available - but they are all verbose.  Explicit template arguments
could be given to <tt>regex_replace()</tt>, allowing <tt>basic_string</tt>'s implicit
constructor to be invoked - but <tt>charT</tt> is the last template argument, not
the first, so this would be extremely verbose.  Therefore, constructing
a <tt>basic_string</tt> from each C string is the simplest workaround.
</p>
</li>

<li>
There is an efficiency consideration: constructing <tt>basic_string</tt>s can
impose performance costs that could be avoided by a library
implementation taking C strings and dealing with them directly. 
(Currently, for replacement sources, C strings can be converted into
iterator pairs at the cost of verbosity, but for format strings, there
is no way to avoid constructing a <tt>basic_string</tt>.)
</li>
</ol>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote><p>
We note that Boost already has these overloads. However, the proposed
wording is provided only for 32.10.4 <a href="https://timsong-cpp.github.io/cppwp/re.alg.replace">[re.alg.replace]</a>; wording is needed for the synopsis
as well. We also note that this has impact on <tt>match_results::format</tt>,
which may require further overloads.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Daniel to tweak for us.
</p></blockquote>

<p><i>[
2009-07-25 Daniel tweaks both this issue and <a href="727">727</a>.
]</i></p>


<blockquote>
<p>
This is solved by the proposed resolution of <a href="727">727</a>.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave Open. Though we believe this is solved by the proposed resolution
to <a href="727">727</a>.
</p></blockquote>

<p><i>[
2010-01-27 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="727">727</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Provide additional overloads for <tt>regex_replace()</tt>: one additional
overload of the iterator-based form (taking <tt>const charT* fmt</tt>), and three
additional overloads of the convenience form (one taking <tt>const charT*
str</tt>, another taking <tt>const charT* fmt</tt>, and the third taking both <tt>const
charT* str</tt> and <tt>const charT* fmt</tt>).  32.10.4 <a href="https://timsong-cpp.github.io/cppwp/re.alg.replace">[re.alg.replace]</a>:
</p>

<blockquote>
<pre>
template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
<p>...</p>
<pre>
template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
</blockquote>






<hr>
<h3><a name="729" href="729">729.</a> Problem in [rand.req.eng]/3</h3>
<p><b>Section:</b> 28.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.req.eng">[rand.req.eng]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.eng">issues</a> in [rand.req.eng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 3rd table row in 28.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.req.eng">[rand.req.eng]</a>/3 requires random number engines to accept any 
arithmetic type as a seed, which is then casted to the engine's <tt>result_type</tt> and subsequently 
used for seeding the state of the engine. The requirement stated as "Creates an engine with 
initial state determined by <tt>static_cast&lt;X::result_type&gt;(s)</tt>" forces random number engines 
to either use a seeding method that completely depends on the <tt>result_type</tt> (see the discussion 
of seeding for the <tt>mersenne_twister_engine</tt> in point T2 above) or at least to throw away "bits 
of randomness" in the seed value if the <tt>result_type</tt> is smaller than the seed type. This seems 
to be inappropriate for many modern random number generators, in particular F2-linear or 
cryptographic ones, which operate on an internal bit array that in principle is independent of the 
type of numbers returned.
</p>

<p>
<b>Possible resolution:</b> I propose to change the wording to a version similar to "Creates an 
engine with initial state determined by <tt>static_cast&lt;UintType&gt;(s)</tt>, where <tt>UintType</tt> is an 
implementation specific unsigned integer type."
</p>

<p>
Additionally, the definition of s in 28.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.req.eng">[rand.req.eng]</a>/1 c) could be restricted to unsigned integer types.
</p>

<p>
Similarly, the type of the seed in 28.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/rand.req.adapt">[rand.req.adapt]</a>/3 e) could be left unspecified.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In reply to the discussion in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
regarding this issue:
</p>
<p>
The descriptions of all engines and engine adaptors given in sections
28.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a> and 28.5.5 <a href="https://timsong-cpp.github.io/cppwp/rand.adapt">[rand.adapt]</a> already specify the concrete
types of the integer arguments for seeding. Hence, relaxing the general
requirement in 28.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.req.eng">[rand.req.eng]</a> would not affect portability and
reproducibility of the standard library. Furthermore, it is not clear to
me what exactly the guarantee "with initial state determined by
<tt>static_cast&lt;X::result_type&gt;(s)</tt>" is useful for. On the other hand,
relaxing the requirement would allow developers to implement  other
random number engines that do not have to cast all arithmetic seed
arguments to their result_types.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Propose close NAD for the reasons given in N2424.
</p></blockquote>




<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
Change row 3 of table 105 "Random number engine requirements" in 28.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.req.eng">[rand.req.eng]</a>/3
</p>

<blockquote><p>
Creates an engine with initial state determined by
<tt><del>static_cast&lt;X::result_type&gt;(</del>s<del>)</del></tt>
</p></blockquote>

<p>
Similarly, change 28.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/rand.req.adapt">[rand.req.adapt]</a>/3 e)
</p>

<blockquote><p>
When <tt>X::X</tt> is invoked with <del>an <tt>X::result_type</tt></del> value <tt>s</tt>
<ins>of arithmetic type (3.9.1)</ins>, ...
</p></blockquote>

</blockquote>






<hr>
<h3><a name="730" href="730">730.</a> Comment on [rand.req.adapt]/3 e)</h3>
<p><b>Section:</b> 28.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/rand.req.adapt">[rand.req.adapt]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If an engine adaptor is invoked with an argument of type <tt>seed_seq</tt>, then all base 
engines are specified to be seeded with this <tt>seed_seq</tt>. As <tt>seed_seq</tt>'s randomization method is 
qualified as constant, this procedure will ef fectively initialize all base engines with the same seed 
(though the resulting state might still dif fer to a certain degree if the engines are of different types). 
It is not clear whether this mode of operation is in general appropriate, hence -- as far as the 
stated requirements are of general nature and not just specific to the engine adaptors provided by 
the library -- it might be better to leave the behaviour unspecified, since the current definition of 
<tt>seed_seq</tt> does not allow for a generally satisfying specification.
</p>

<p>
<b>Posssible resolution:</b> [As above]
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Close NAD for the reasons given in N2424.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="731" href="731">731.</a> proposal for a customizable <tt>seed_seq</tt></h3>
<p><b>Section:</b> 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The proper way to seed random number engines seems to be the most frequently 
discussed issue of the 28.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a> proposal. While the new <tt>seed_seq</tt> approach is already rather 
general and probably sufficient for most situations, it is unlikely to be optimal in every case (one 
problem was pointed out in point T5 above). In some situations it might, for instance, be better to 
seed the state with a cryptographic generator. 
</p>
<p>
In my opinion this is a pretty strong argument for extending the standard with a simple facility to 
customize the seeding procedure. This could, for example, be done with the following minimal 
changes:
</p>

<p>
<b>Possible resolution:</b>
</p>

<ol style="list-style-type:lower-alpha">
<li>
Turn the interface specification of 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a>/2 into a "SeedSeq" requirement, where the 
exact behaviour of the constructors and the randomize method are left unspecified and where the
const qualification for randomize is removed. Classes implementing this interface are additionally 
required to specialize the traits class in c).
</li>
<li>
Provide the class <tt>seed_seq</tt> as a default implementation of the SeedSeq interface.
</li>
<li>
<p>
Supplement the <tt>seed_seq</tt> with a traits class
</p>
<blockquote><pre>
template &lt;typename T&gt; 
struct is_seed_seq { static const bool value = false; }
</pre></blockquote>
<p>and the specialization</p>
<blockquote><pre>
template &lt;&gt; 
struct is_seed_seq&lt;seed_seq&gt; { static const bool value = true; }
</pre></blockquote>
<p>which users can supplement with further specializations.</p>
</li>
<li>
Change 28.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.req.eng">[rand.req.eng]</a>/1 d) to "q is an lvalue of a type that fulfils the SeedSeq requirements", and 
modify the constructors and seed methods in 28.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a> appropriately (the actual implementation 
could be done using the SFINAE technique).
</li>
</ol>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
See N2424. Close NAD but note that "conceptizing" the library may cause
this problem to be solved by that route.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="733" href="733">733.</a> Comment on [rand.req.dist]/9</h3>
<p><b>Section:</b> 28.5.3.6 <a href="https://timsong-cpp.github.io/cppwp/rand.req.dist">[rand.req.dist]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.dist">issues</a> in [rand.req.dist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirement "P shall have a declaration of the form <tt>typedef X distribution_- 
type</tt>" effectively makes the use of inheritance for implementing distributions very inconvenient, 
because the child of a distribution class in general will not satisfy this requirement. In my opinion 
the benefits of having a typedef in the parameter class pointing back to the distribution class are 
not worth the hassle this requirement causes. [In my code base I never made use of the nested 
typedef but on several occasions could have profited from being able to use simple inheritance for 
the implementation of a distribution class.]
</p>

<p>
<b>Proposed resolution:</b> I propose to drop this requirement.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Close NAD for the reasons given in N2424. In practice it is not inconvenient to meet these requirements.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="735" href="735">735.</a> Unfortunate naming</h3>
<p><b>Section:</b> 28.5.9.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern.bin">[rand.dist.bern.bin]</a>, 28.5.9.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern.negbin">[rand.dist.bern.negbin]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In my opinion the choice of name for the <tt>t</tt> parameter of the <tt>binomial_distribution</tt>
is very unfortunate. In virtually every internet reference, book and software implementation 
this parameter is called <tt>n</tt> instead, see for example Wikipedia, Mathworld, Evans et al. (1993) 
Statistical Distributions, 2nd E., Wiley, p. 38, the R statistical computing language, p. 926, 
Mathematica and Matlab.
</p>

<p>
Similarly, the choice of <tt>k</tt> for the parameter of the negative binomial distributions is rather unusual. 
The most common choice for the negative binomial distribution seems to be <tt>r</tt> instead.
</p>

<p>
Choosing unusual names for the parameters causes confusion among users and makes the 
interface unnecessarily inconvenient to use.
</p>

<p>
<b>Possible resolution:</b> For these reasons, I propose to change the name of the respective parameters
to <tt>n</tt> and <tt>r</tt>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
In N2424. NAD It has been around for a while. It is hardly universal,
there is prior art, and this would confuse people.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="736" href="736">736.</a> Comment on [rand.dist.samp.discrete]</h3>
<p><b>Section:</b> 28.5.9.6.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.discrete">[rand.dist.samp.discrete]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.samp.discrete">issues</a> in [rand.dist.samp.discrete].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol style="list-style-type:lower-alpha">
<li>
The specification for <tt>discrete_distribution</tt> requires the member <tt>probabilities()</tt>
to return a vector of <i>standardized</i> probabilities, which forces the implementation every time to 
divide each probability by the sum of all probabilities, as the sum will in practice almost never be 
exactly 1.0. This is unnecessarily inef ficient as the implementation would otherwise not need to 
compute the standardized probabilities at all and could instead work with the non-standardized 
probabilities and the sum. If there was no standardization the user would just get back the 
probabilities that were previously supplied to the distribution object, which to me seems to be the 
more obvious solution.
</li>
<li>
The behaviour of <tt>discrete_distribution</tt> is not specified in case the number of given
probabilities is larger than the maximum number representable by the IntType.
</li>
</ol>

<p>
<b>Possible resolution:</b> I propose to change the specification such that the non-standardized 
probabilities need to be returned and that an additional requirement is included for the number 
of probabilities to be smaller than the maximum of IntType.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In reply to the discussion in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
of this issue:
</p>
<p>
Rescaled floating-point parameter vectors can not be expected to compare
equal because of the limited precision of floating-point numbers.
My proposal would at least guarantee that a parameter
vector (of type double) passed into the distribution would compare equal
with the one returned by the <tt>probabilities()</tt> method. Furthermore, I do
not understand why "the changed requirement would lead to a significant
increase in the amount of state in the distribution object". A typical
implementation's state would increase by exactly one number: the sum of
all probabilities. The textual representation for serialization would
not need to grow at all. Finally, the proposed replacement "<tt>0 &lt; n &lt;=
numeric_limits&lt;IntType&gt;::max() + 1</tt>" makes the implementation
unnecessarily complicated, "<tt>0 &lt; n &lt;= numeric_limits&lt;IntType&gt;::max()</tt>"
would be better.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
In N2424. We agree with the observation and the proposed resolution to
part b). We recommend the wording n &gt; 0 be replaced with 0 &lt; n
numeric_limits::max() + 1. However, we disagree with part a), as it
would interfere with the definition of parameters' equality. Further,
the changed requirement would lead to a significant increase in the
amount of state of the distribution object.
</p>

<p>
As it stands now, it is convenient, and the changes proposed make it
much less so.
</p>

<p>
NAD. Part a the current behavior is desirable. Part b, any constructor
can fail, but the rules under which it can fail do not need to be listed
here.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In 28.5.9.6.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.discrete">[rand.dist.samp.discrete]</a>:
</p>

<p>
Proposed wording a):
</p>

<blockquote>
<p>
Change in para. 2
</p>

<blockquote><p>
Constructs a <tt>discrete_distribution</tt> object with <tt>n=1</tt> and <tt>p<sub>0</sub> <ins>= w<sub>0</sub></ins> = 1</tt>
</p></blockquote>

<p>
and change in para. 5
</p>

<blockquote><p>
<i>Returns:</i> A <tt>vector&lt;double&gt;</tt> whose <tt>size</tt> member returns <tt>n</tt> and whose
<tt>operator[]</tt> member returns <del><tt>p<sub>k</sub></tt></del>
<ins>the weight <tt>w<sub>k</sub></tt> as a double value</ins>
when invoked with argument <tt>k</tt> for <tt>k = 0,
..., n-1</tt>
</p></blockquote>

</blockquote>

<p>
Proposed wording b):
</p>

<blockquote>
<p>
Change in para. 3:
</p>

<blockquote><p>
If <tt>firstW == lastW</tt>, let the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist
of the single value <tt>w<sub>0</sub> = 1</tt>. Otherwise, <tt>[firstW,lastW)</tt> shall form a
sequence <tt>w</tt> of length <tt>n <del>&gt; 0</del></tt> 
<ins>such that <tt>0 &lt; n &lt;= numeric_limits&lt;IntType&gt;::max()</tt>,</ins>
and <tt>*firstW</tt> shall yield a value <tt>w<sub>0</sub></tt>
convertible to <tt>double</tt>. [<i>Note:</i> The values <tt>w<sub>k</sub></tt> are commonly known
as the weights . <i>-- end note</i>]
</p></blockquote>

</blockquote>

</blockquote>





<hr>
<h3><a name="737" href="737">737.</a> Comment on [rand.dist.samp.pconst]</h3>
<p><b>Section:</b> 28.5.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol style="list-style-type:lower-alpha">
<li>
The discussion in point T11 above regarding <tt>probabilities()</tt> similarly applies 
to the method <tt>densities()</tt> of <tt>piecewise_constant_distribution</tt>.
</li>
<li>
<p>
The design of the constructor
</p>
<blockquote><pre>
template &lt;class InputIteratorB, class InputIteratorW&gt; 
piecewise_constant_distribution( InputIteratorB firstB, InputIteratorB lastB, 
                                 InputIteratorW firstW);
</pre></blockquote>
<p>
is unnecessarily unsafe, as there is no separate end-iterator given for the weights. I can't see 
any performance or convenience reasons that would justify the risks inherent in such a function 
interface, in particular the risk that input error might go unnoticed.
</p>
</li>
</ol>

<p>
<b>Possible resolution:</b> I propose to add an <tt>InputIteratorW lastW</tt> argument to the interface.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>

<blockquote><p>
In reply to the discussion in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
I'd like to make the same comments as for <a href="736">736</a>.
</p></blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
In N2424. There is already precedent elsewhere in the library. Follows existing convention. NAD.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In 28.5.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a>:
</p>

<p>
Proposed wording a)
</p>

<blockquote>
<p>
Change in para. 2
</p>
<blockquote><p>
Constructs a <tt>piecewise_constant_distribution</tt> object with <tt>n = 1</tt>, <tt>p<sub>0</sub> <ins>= w<sub>0</sub></ins> = 1</tt>,
<tt>b<sub>0</sub> = 0</tt>, and <tt>b<sub>1</sub> = 1</tt>
</p></blockquote>

<p>
and change in para. 5
</p>

<blockquote><p>
A <tt>vector&lt;result_type&gt;</tt> whose <tt>size</tt> member returns <tt>n</tt> and whose <tt>operator[]</tt>
member returns <del><tt>p<sub>k</sub></tt></del>
<ins>the weight <tt>w<sub>k</sub></tt> as a double value</ins>
when invoked with argument <tt>k</tt> for <tt>k = 0, ..., n-1</tt>
</p></blockquote>

</blockquote>

<p>
Proposed wording b)
</p>

<blockquote>
<p>
Change both occurrences of
</p>

<blockquote><pre>
"piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                 InputIteratorW firstW<ins>, InputIteratorW lastW</ins>)
</pre></blockquote>

<p>
and change in para. 3
</p>

<blockquote><p>
<del>the length of the sequence <tt>w</tt> starting from <tt>firstW</tt> shall be at least <tt>n</tt>,
<tt>*firstW</tt> shall return a value <tt>w<sub>0</sub></tt> that is convertible to <tt>double</tt>, and any
<tt>w<sub>k</sub></tt> for <tt>k &gt;= n</tt> shall be ignored by the distribution</del>
<ins><tt>[firstW, lastW)</tt> shall form a sequence <tt>w</tt> of length <tt>n</tt> whose leading element
<tt>w<sub>0</sub></tt> shall be convertible to <tt>double</tt></ins>
</p></blockquote>

</blockquote>


</blockquote>






<hr>
<h3><a name="738" href="738">738.</a> Editorial issue in [rand.adapt.disc]/3</h3>
<p><b>Section:</b> 28.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/rand.adapt.disc">[rand.adapt.disc]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.adapt.disc">issues</a> in [rand.adapt.disc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the template parameter <tt>p</tt> and <tt>r</tt> are of type <tt>size_t</tt>, the member <tt>n</tt> in the class 
exposition should have type <tt>size_t</tt>, too.
</p>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="739" href="739">739.</a> Defect in [rand.util.canonical]/3</h3>
<p><b>Section:</b> 28.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/rand.util.canonical">[rand.util.canonical]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.canonical">issues</a> in [rand.util.canonical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity of <tt>generate_canonical</tt> is specified to be "exactly k=max(1, ceil(b/log2 
R)) invocations of g". This terms involves a logarithm that is not rounded and hence can not (in 
general) be computed at compile time. As this function template is performance critical, I propose 
to replace ceil(b/log2 R) with ceil(b/floor(log2 R)).
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
In N2424. Close NAD as described there.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="741" href="741">741.</a> Const-incorrect <tt>get_deleter</tt> function for <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.3.2.2.11 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.getdeleter">[util.smartptr.getdeleter]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-09-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.getdeleter">issues</a> in [util.smartptr.getdeleter].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following issue was raised by Alf P. Steinbach in c.l.c++.mod:
</p>

<p>
According to the recent draft N2369, both the header memory synopsis
of 20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a> and 20.3.2.2.11 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.getdeleter">[util.smartptr.getdeleter]</a> declare:
</p>

<blockquote><pre>
template&lt;class D, class T&gt; D* get_deleter(shared_ptr&lt;T&gt; const&amp; p);
</pre></blockquote>

<p>
This allows to retrieve the pointer to a mutable deleter of a <tt>const
shared_ptr</tt> (if that owns one) and therefore contradicts the usual
philosophy that associated functors are either read-only (e.g.
<tt>key_comp</tt> or <tt>value_comp</tt> of <tt>std::map</tt>) or do at least reflect
the mutability of the owner (as seen for the both overloads of
<tt>unique_ptr::get_deleter</tt>).
Even the next similar counter-part of <tt>get_deleter</tt> - the two
overloads of <tt>function::target</tt> in the class template function
synopsis 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> or in 22.10.17.3.6 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.targ">[func.wrap.func.targ]</a> - do
properly mirror the const-state of the owner.
</p>

<p><b>Possible proposed resolutions:</b></p>

<p>
Replace the declarations of <tt>get_deleter</tt> in the header <tt>&lt;memory&gt;</tt>
synopsis of 20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a> and in 20.3.2.2.11 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.getdeleter">[util.smartptr.getdeleter]</a> by one of the
following alternatives (A) or (B):
</p>

<ol style="list-style-type:upper-alpha">
<li>
Provide <b>only</b> the immutable variant. This would reflect the
current praxis of <tt>container::get_allocator()</tt>, <tt>map::key_comp()</tt>, or
<tt>map::value_comp</tt>.

<blockquote><pre>
template&lt;class D, class T&gt; const D* get_deleter(shared_ptr&lt;T&gt; const&amp; p);
</pre></blockquote>
</li>
<li>
Just remove the function.
</li>
</ol>

<p>
Alberto Ganesh Barbati adds:
</p>

<ol style="list-style-type:upper-alpha" start="3">
<li>
<p>
Replace it with two functions:
</p>
<blockquote><pre>
template &lt;class D, class T&gt; D get_deleter(shared_ptr&lt;T&gt; const&amp;);
template &lt;class D, class T&gt; bool has_deleter(shared_ptr&lt;T&gt; const&amp;);
</pre></blockquote>

<p>
The first one would throw if <tt>D</tt> is the wrong type, while the latter would
never throw. This approach would reflect the current praxis of
<tt>use_facet/has_facet</tt>, with the twist of returning the deleter by value as
<tt>container::get_allocator()</tt> do.
</p>
</li>
</ol>

<p>
Peter Dimov adds:
</p>

<blockquote>
<p>
My favorite option is "not a defect". A, B and C break useful code.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Concern this is similar to confusing "pointer to const" with "a constant pointer".
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="745" href="745">745.</a> copy_exception API slices.</h3>
<p><b>Section:</b> 17.10.7 <a href="https://timsong-cpp.github.io/cppwp/propagation">[propagation]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It could be I did not understand the design rationale, but I thought
copy_exception would produce an exception_ptr to the most-derived (dynamic)
type of the passed exception.  Instead it slices, which appears to be less
useful, and a likely source of FAQ questions in the future.
</p>
<p>
(Peter Dimov suggests NAD)
</p>

<p><i>[
Bellevue: 
]</i></p>


<blockquote>
<p>
How could this be implemented in a way that the dynamic type is cloned?
</p>
<p>
The feature is designed to create an exception_ptr from an object whose
static type is identical to the dynamic type and thus there is no
slicing involved.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="747" href="747">747.</a> We have 3 separate type traits to identify classes supporting no-throw operations</h3>
<p><b>Section:</b> 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have 3 separate type traits to identify classes supporting no-throw
operations, which are very useful when trying to provide exception safety
guarantees.  However, I'm not entirely clear on what the current wording
requires of a conforming implementation.  To quote from
<tt>has_nothrow_default_constructor</tt>:
</p>
<blockquote><p>
or <tt>T</tt> is a class type with a default constructor that is known not to throw
any exceptions
</p></blockquote>
<p>
What level of magic do we expect to deduce if this is known?
</p>
<p>
E.g.
</p>

<blockquote><pre>
struct test{
 int x;
 test() : x() {}
};
</pre></blockquote>
<p>
Should I expect a conforming compiler to 
 <tt>assert( has_nothrow_constructor&lt;test&gt;::value )</tt>
</p>
<p>
Is this a QoI issue?
</p>
<p>
Should I expect to 'know' only if-and-only-if there is an inline definition
available?
</p>
<p>
Should I never expect that to be true, and insist that the user supplies an
empty throw spec if they want to assert the no-throw guarantee?
</p>
<p>
It would be helpful to maybe have a footnote explaining what is required,
but right now I don't know what to suggest putting in the footnote.
</p>
<p>
(agreement since is that trivial ops and explicit no-throws are required.
Open if QoI should be allowed to detect further)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
This looks like a QoI issue.
In the case of trivial and nothrow it is known. Static analysis of the program is definitely into QoI.
Move to OPEN. Need to talk to Core about this.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
This is QoI.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="748" href="748">748.</a> The is_abstract type trait is defined by reference to 10.4.</h3>
<p><b>Section:</b> 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I am trying to decide is a pure virtual function is a <i>necessary</i> as well as
sufficient requirement to be classified as abstract?
</p>
<p>
For instance, is the following (non-polymorphic) type considered abstract?
</p>
<blockquote><pre>
struct abstract {
protected:
 abstract(){}
 abstract( abstract const &amp; ) {}
 ~abstract() {}
};
</pre></blockquote>
<p>
(Suggested that this may be NAD, with an editorial fix-up from Pete on the
core wording to make clear that abstract requires a pure virtual function)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Core has clarified that the definition abstract is adequate. Issue withdrawn by submitter. NAD.
</p>





<hr>
<h3><a name="750" href="750">750.</a> The current definition for <tt>is_convertible</tt> requires that the type be
implicitly convertible, so explicit constructors are ignored.</h3>
<p><b>Section:</b> 21.3.7 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.rel">active issues</a> in [meta.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="719">719</a></p>
<p><b>Discussion:</b></p>
<p>
With the pending arrival of explicit conversion functions though, I'm
wondering if we want an additional trait, <tt>is_explictly_convertible</tt>?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Duplicate of <a href="719">719</a> (for our purposes).
</p></blockquote>

<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="751" href="751">751.</a> change pass-by-reference members of <tt>vector&lt;bool&gt;</tt> to pass-by-value?</h3>
<p><b>Section:</b> 24.3.12 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.bool">active issues</a> in [vector.bool].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of <tt>vector&lt;bool&gt;</tt> members take const bool&amp; as arguments.
Is there any chance we could change them to pass-by-value or would I 
be wasting everyone's time if wrote up an issue?
</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
As we understand it, the original requester (Martin Sebor) would like
for implementations to be permitted to pass-by-value. Alisdair suggests
that if this is to be resolved, it should be resolved more generally,
e.g. in other containers as well.
</p>
<p>
We note that this would break ABI. However, we also suspect that this
might be covered under the "as-if" rule in section 1.9.
</p>
<p>
Many in the group feel that for vector&lt;bool&gt;, this is a "don't care",
and that at this point in the process it's not worth the bandwidth.
</p>
<p>
Issue <a href="679">679</a> -- which was in ready status pre-Bellevue and is
now in the working paper -- is related to this, though not a duplicate.
</p>
<p>
Moving to Open with a task for Alisdair to craft a informative note to
be put whereever appropriate in the WP. This note would clarify places
where pass-by-const-ref can be transformed to pass-by-value under the
as-if rule.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This is really a clause 17 issue, rather than something specific to vector&lt;bool&gt;.
</p>
<p>
Move to Open. Alisdair to provide a resolution. Alternately, Howard can
close this as NAD and then open a new issue to handle the general issue
(rather than the vector&lt;bool&gt; one).
</p>
<p>
Howard:  Haven't yet opened new issue.  Lacking wording for it.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
NAD.  Insufficient motivation to make any changes.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="754" href="754">754.</a> Ambiguous return clause for <tt>std::uninitialized_copy</tt></h3>
<p><b>Section:</b> 27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2007-10-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
14882-2003, [lib.uninitialized.copy] is currently written as follows:
</p>

<blockquote>
<pre>
template &lt;class InputIterator, class ForwardIterator&gt;
  ForwardIterator uninitialized_copy(InputIterator <i>first</i>, InputIterator <i>last</i>,
                                     ForwardIterator <i>result</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>
for (; first != last; ++result, ++first)
  new (static_cast&lt;void*&gt;(&amp;*result))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</pre></blockquote>
<p>
-2- <i>Returns:</i> <tt><i>result</i></tt>
</p>
</blockquote>
</blockquote>

<p>
similarily for N2369, and its corresponding section
27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a>.
</p>

<p>
It's not clear to me what the return clause is supposed to mean, I see
two
possible interpretations:
</p>

<ol style="list-style-type:lower-alpha">
<li>
The notion of <tt><i>result</i></tt> is supposed to mean the value given by the
function parameter <tt><i>result</i></tt> [Note to the issue editor: Please use italics for
<tt><i>result</i></tt>].
This seems somewhat implied by recognizing that both the function
parameter
and the name used in the clause do have the same italic font.
</li>
<li>
The notion of "result" is supposed to mean the value of <tt><i>result</i></tt>
after the
preceding effects clause. This is in fact what all implementations I
checked
do (and which is probably it's intend, because it matches the
specification of <tt>std::copy</tt>).
</li>
</ol>

<p>
The problem is: I see nothing in the standard which grants that this
interpretation
is correct, specifically [lib.structure.specifications] or
16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>
resp. do not clarify which "look-up" rules apply for names found in
the elements
of the detailed specifications - Do they relate to the corresponding
synopsis or
to the effects clause (or possibly other elements)? Fortunately most
detailed
descriptions are unambigious in this regard, e.g. this problem does
not apply
for <tt>std::copy</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the wording of the return clause to say (27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a>):
</p>

<blockquote>
<p>
-2- <i>Returns:</i> <ins>The value of</ins> <tt><i>result</i></tt> <ins>after effects have taken place.</ins>
</p>
</blockquote>


<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Resolution: NAD editorial -- project editor to decide if change is
worthwhile. Concern is that there are many other places this might
occur.
</p></blockquote>




<hr>
<h3><a name="757" href="757">757.</a> Typo in the synopsis of vector</h3>
<p><b>Section:</b> 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a>, there is the signature:
</p>

<blockquote><pre>
void insert(const_iterator position, size_type n, T&amp;&amp; x);
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>
iterator insert(const_iterator position, T&amp;&amp; x);
</pre></blockquote>

<p>
24.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> is fine.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a>:
</p>

<blockquote><pre>
iterator insert(const_iterator position, const T&amp; x); 
<ins>iterator insert(const_iterator position, T&amp;&amp; x);</ins>
void     insert(const_iterator position, size_type n, const T&amp; x); 
<del>void     insert(const_iterator position, size_type n, T&amp;&amp; x);</del>
</pre></blockquote>





<hr>
<h3><a name="760" href="760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2017-07-17 23:27:54 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="767">767</a> and to <a href="2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="2164">2164</a> addresses this issue and therefore considers <a href="760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="763" href="763">763.</a> Renaming <tt>emplace()</tt> overloads</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sylvain Pion <b>Opened:</b> 2007-12-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The associative containers provide 2 overloads of <tt>emplace()</tt>:
</p>

<blockquote><pre>
template &lt;class... Args&gt; pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
</pre></blockquote>

<p>
This is a problem if you mean the first overload while passing
a <tt>const_iterator</tt> as first argument.
</p>

<p><i>[
Related to <a href="767">767</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<p>
This can be disambiguated by passing "begin" as the first argument in
the case when the non-default choice is desired. We believe that desire
will be rare.
</p>

<p><i>[For related discussion see <a href="1302">1302</a>]</i></p>


<p>
LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a> 
renamed one of the overloads to <tt>emplace_hint</tt>.
</p>

<p>
Resolution: Change state to NAD.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Rename one of the two overloads.
For example to <tt>emplace_here</tt>, <tt>hint_emplace</tt>...
</p>





<hr>
<h3><a name="764" href="764">764.</a> <tt>equal_range</tt> on unordered containers should return a <tt>pair</tt> of <tt>local_iterators</tt></h3>
<p><b>Section:</b> 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2007-11-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
    A major attribute of the unordered containers is that iterating 
though them inside a bucket is very fast while iterating between buckets 
can be much slower.  If an unordered container has a low load factor, 
iterating between the last iterator in one bucket and the next iterator, 
which is in another bucket, is <tt>O(bucket_count())</tt> which may be much 
larger than <tt>O(size())</tt>.
</p>
<p>
    If <tt>b</tt> is an non-const unordered container of type <tt>B</tt> and <tt>k</tt> is an 
object of it's <tt>key_type</tt>, then <tt>b.equal_range(k)</tt> currently returns 
<tt>pair&lt;B::iterator, B::iterator&gt;</tt>. Consider the following code:
</p>

<blockquote><pre>
B::iterator lb, ub;
tie(lb, ub) = b.equal_range(k);
for (B::iterator it = lb; it != ub; ++it) {
        // Do something with *it
}
</pre></blockquote>

<p>
If <tt>b.equal_range(k)</tt> returns a non-empty range (i.e. <tt>b</tt> contains at least 
on element whose key is equivalent to <tt>k</tt>), then every iterator in the 
half-open range <tt>[lb, ub)</tt> will be in the same bucket, but <tt>ub</tt> will likely 
either be in a different bucket or be equal to <tt>b.end()</tt>.  In either case, 
iterating between <tt>ub - 1</tt> and <tt>ub</tt> could take a much longer time than 
iterating through the rest of the range.
</p>
<p>
If instead of returning <tt>pair&lt;iterator, iterator&gt;</tt>, <tt>equal_range</tt> were to 
return <tt>pair&lt;local_iterator, local_iterator&gt;</tt>, then <tt>ub</tt> (which, like <tt>lb</tt>, 
would now be a <tt>local_iterator</tt>) could be guaranteed to always be in the 
same bucket as <tt>lb</tt>. In the cases where currently <tt>ub</tt> is equal to <tt>b.end()</tt>
or is in a different bucket, <tt>ub</tt> would be equal to <tt>b.end(b.bucket(key))</tt>. 
  This would make iterating between <tt>lb</tt> and <tt>ub</tt> much faster, as every 
iteration would be constant time.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
The proposed resolution breaks consistency with other container types
for dubious benefit, and iterators are already constant time.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the entry for <tt>equal_range</tt> in Table 93 (24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>) as follows:
</p>
<table border="1">
<tr>
<th>expression</th> <th>return type</th> <th>assertion/note pre/post-condition</th> <th>complexity</th>
</tr>

<tr>
<td><tt>b.equal_range(k)</tt></td>
<td><tt>pair&lt;<ins>local_</ins>iterator,<ins>local_</ins>iterator&gt;; pair&lt;const_<ins>local_</ins>iterator,const_<ins>local_</ins>iterator&gt;</tt> for <tt>const b</tt>.</td>
<td>Returns a range containing all elements with keys equivalent to <tt>k</tt>. Returns <tt>make_pair(b.end(<ins>b.bucket(key)</ins>),b.end(<ins>b.bucket(key)</ins>))</tt> if no such elements exist.</td>
<td>Average case &Theta;<tt>(b.count(k))</tt>. Worst case &Theta;<tt>(b.size())</tt>. </td>
</tr>
</table>





<hr>
<h3><a name="773" href="773">773.</a> issues with random</h3>
<p><b>Section:</b> 28.5.9.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.uni">[rand.dist.uni]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-01-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.uni">issues</a> in [rand.dist.uni].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol>
<li>
28.5.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.uni.int">[rand.dist.uni.int]</a> <tt>uniform_int</tt> constructor has changed the default
max constructor parameter from 9 (in TR1) to <tt>max()</tt>. The value
is arbitrary at best and shouldn't be lightly changed because
it breaks backward compatibility.
</li>

<li>
28.5.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.uni.int">[rand.dist.uni.int]</a> <tt>uniform_int</tt> has a parameter <tt>param</tt> that you can
provide on construction or <tt>operator()</tt>, set, and get. But there
is not even a hint of what this might be for.
</li>

<li>
28.5.9.2.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.uni.real">[rand.dist.uni.real]</a> <tt>uniform_real</tt>. Same issue as #2.
</li>
</ol>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
NAD. Withdrawn.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="784" href="784">784.</a> unique_lock::release</h3>
<p><b>Section:</b> 33.6.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique.mod">[thread.lock.unique.mod]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Constantine Sapuntzakis <b>Opened:</b> 2008-02-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_lock::release</tt> will probably lead to many mistakes where people
call <tt>release</tt> instead of <tt>unlock</tt>. I just coded such a mistake using the
boost pre-1.35 threads library last week.
</p>

<p>
In many threading libraries, a call with <tt>release</tt> in it unlocks the
lock (e.g. ReleaseMutex in Win32, java.util.concurrent.Semaphore).
</p>

<p>
I don't call <tt>unique_lock::lock</tt> much at all, so I don't get to see the
symmetry between <tt>::lock</tt> and <tt>::unlock</tt>. I usually use the constructor to
lock the mutex. So I'm left to remember whether to call <tt>release</tt> or
<tt>unlock</tt> during the few times I need to release the mutex before the scope
ends. If I get it wrong, the compiler doesn't warn me.
</p>

<p>
An alternative name for release may be <tt>disown</tt>.
</p>

<p>
This might be a rare case where usability is hurt by consistency with
the rest of the C++ standard (e.g. <tt>std::auto_ptr::release</tt>).
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Change a name from release to disown. However prior art uses the release
name. Compatibility with prior art is more important that any possible
benefit such a change might make. We do not see the benefit for
changing. NAD
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 33.6.5.4 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique">[thread.lock.unique]</a>:
</p>

<blockquote><pre>
template &lt;class Mutex&gt; 
class unique_lock 
{ 
public:
   ...
   mutex_type* <del>release</del> <ins>disown</ins>();
   ...
};
</pre></blockquote>

<p>
Change 33.6.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique.mod">[thread.lock.unique.mod]</a>:
</p>

<blockquote><pre>
mutex_type *<del>release</del> <ins>disown</ins>();
</pre></blockquote>





<hr>
<h3><a name="785" href="785">785.</a> [tr1] Random Number Requirements in TR1</h3>
<p><b>Section:</b> 5.1.4.5 [tr1::tr.rand.eng.disc], 5.1.4.6 [tr1::tr.rand.eng.xor] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> John Maddock <b>Opened:</b> 2008-01-15 <b>Last modified:</b> 2016-02-01 11:04:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 16 of TR1 requires that all Pseudo Random Number generators have a
</p>

<blockquote><pre>
seed(integer-type s)
</pre></blockquote>

<p>
member function that is equivalent to:
</p>

<blockquote><pre>
mygen = Generator(s)
</pre></blockquote>

<p>
But the generators <tt>xor_combine</tt> and <tt>discard_block</tt> have no such seed member, only the
</p>

<blockquote><pre>
template &lt;class Gen&gt;
seed(Gen&amp;);
</pre></blockquote>

<p>
member, which will not accept an integer literal as an argument: something that appears to violate the intent of Table 16.
</p>

<p>
So... is this a bug in TR1?
</p>

<p>
This is a real issue BTW, since the Boost implementation does adhere to the requirements of Table 16, while at least one commercial implementation does not and follows a strict adherence to sections 5.1.4.5 and 5.1.4.6 instead.
</p>

<p><i>[
Jens adds:
]</i></p>


<blockquote><p>
Both engines do have the necessary
constructor, therefore the omission of the <tt>seed()</tt> member
functions appears to be an oversight.
</p></blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote><p>
Recommend NAD: <tt>xor_combine</tt> does no longer exist and <tt>discard_block[_engine]</tt>
has now the required seed overload accepting a <tt>result_type</tt>, which shall be an
unsigned integral type.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to NAD as recommended.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
NAD Recommended.
</p>





<hr>
<h3><a name="790" href="790">790.</a> <tt>xor_combine::seed</tt> not specified</h3>
<p><b>Section:</b> 99 [rand.adapt.xor] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.adapt.xor">issues</a> in [rand.adapt.xor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>xor_combine::seed(result_type)</tt> and <tt>seed(seed_seq&amp;)</tt> don't say what
happens to each of the sub-engine seeds. (Should probably do the same
to both, unlike TR1.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Overcome by the previous proposal. NAD mooted by resolution of <a href="789">789</a>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="791" href="791">791.</a> <tt>piecewise_constant_distribution::densities</tt> has wrong name</h3>
<p><b>Section:</b> 28.5.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>piecewise_constant_distribution::densities()</tt> should be <tt>probabilities()</tt>,
just like <tt>discrete_distribution</tt>. (There's no real use for weights divided
by areas.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Fermilab does not agree with this summary. As defined in the equation in
26.4.8.5.2/4, the quantities are indeed probability densities not
probabilities. Because we view this distribution as a parameterization
of a *probability density function*, we prefer to work in terms of
probability densities.
</p>

<p>
We don't think this should be changed.
</p>

<p>
If there is a technical argument about why the implementation dealing
with these values can't be as efficient as one dealing with
probabilities, we might reconsider. We don't care about this one member
function being somewhat more or less efficient; we care about the size
of the distribution object and the speed of the calls to generate
variates.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change synopsis in 28.5.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a>:
</p>

<blockquote><pre>
template &lt;class RealType = double&gt; 
class piecewise_constant_distribution 
{ 
public:
    ...
    vector&lt;double&gt; <del>densities</del> <ins>probabilities</ins>() const;
    ...
};
</pre></blockquote>

<p>
Change 28.5.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a>/6:
</p>

<blockquote><pre>
vector&lt;double&gt; <del>densities</del> <ins>probabilities</ins>() const;
</pre></blockquote>






<hr>
<h3><a name="795" href="795">795.</a> <tt>general_pdf_distribution</tt> should be dropped</h3>
<p><b>Section:</b> 99 [rand.dist.samp.genpdf] <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.samp.genpdf">issues</a> in [rand.dist.samp.genpdf].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="732">732</a></p>
<p><b>Discussion:</b></p>
<p>
<tt>general_pdf_distribution</tt> should be dropped. (It's a research topic in
adaptive numerical integration.)
</p>

<p><i>[
Stephan Tolksdorf notes:
]</i></p>


<blockquote><p>
This appears to be a duplicate of <a href="732">732</a>.
</p></blockquote>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="796" href="796">796.</a> <tt>ranlux48_base</tt> returns wrong value</h3>
<p><b>Section:</b> 28.5.6 <a href="https://timsong-cpp.github.io/cppwp/rand.predef">[rand.predef]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>ranlux48_base</tt> is supposed to be
61839128582725. We get 192113843633948. (Note that the underlying
generator was changed in Kona.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Submitter withdraws defect.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 28.5.6 <a href="https://timsong-cpp.github.io/cppwp/rand.predef">[rand.predef]</a>/p5:
</p>

<blockquote>
<pre>
typedef subtract_with_carry_engine&lt;uint_fast64_t, 48, 5, 12&gt; 
        ranlux48_base; 
</pre>
<blockquote><p>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>ranlux48_base</tt> shall produce the value
<del>61839128582725</del> <ins>192113843633948</ins>.
</p></blockquote>
</blockquote>





<hr>
<h3><a name="797" href="797">797.</a> <tt>ranlux48</tt> returns wrong value</h3>
<p><b>Section:</b> 28.5.6 <a href="https://timsong-cpp.github.io/cppwp/rand.predef">[rand.predef]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>ranlux48</tt> is supposed to be
249142670248501. We get 88229545517833. (Note that this depends
on <tt>ranlux48_base</tt>.)
</p>
<p><i>[
Bellevue:
]</i></p>


<blockquote><p>
Submitter withdraws defect.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 28.5.6 <a href="https://timsong-cpp.github.io/cppwp/rand.predef">[rand.predef]</a>/p6:
</p>

<blockquote>
<pre>
typedef discard_block_engine&lt;ranlux48_base, 389, 11&gt; 
        ranlux48
</pre>
<blockquote><p>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>ranlux48</tt> shall produce the value
<del>249142670248501</del> <ins>88229545517833</ins>.
</p></blockquote>
</blockquote>





<hr>
<h3><a name="799" href="799">799.</a> [tr1] [tr.rand.eng.mers] and [rand.eng.mers]</h3>
<p><b>Section:</b> 99 [tr1::rand.eng.mers], 5.1.4.2 [tr1::tr.rand.eng.mers] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2008-02-18 <b>Last modified:</b> 2016-02-01 11:04:06 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
5.1.4.2 [tr1::tr.rand.eng.mers](10) requires that <tt>operator==</tt> for the <tt>mersenne_twister</tt>
returns <tt>true</tt> if and only if the states of two <tt>mersenne_twisters</tt>,
consisting each of <tt>n</tt> integers between <tt>0</tt> and <tt>2<sup>w</sup> - 1</tt>, are completely
equal. This is a contradiction with 5.1.1 [tr1::tr.rand.req](3) because the given
definition of the state also includes the lower <tt>r</tt> bits of <tt>x(i-n)</tt>, which
will never be used to generate a random number. If two <tt>mersenne_twister</tt>s
only differ in the lower bits of <tt>x(i-n)</tt> they will not compare equal,
although they will produce an identical sequence of random numbers.
</p>

<p>
99 [tr1::rand.eng.mers] in the latest C++ draft does not specify the behaviour
of <tt>operator==</tt> but uses a similar definition of the state and, just like
5.1.4.2 [tr1::tr.rand.eng.mers], requires the textual representation of a
<tt>mersenne_twister_engine</tt> to consist of <tt>X<sub>i-n</sub></tt> to <tt>X<sub>i-1</sub></tt>, including the
lower bits of <tt>X<sub>i-n</sub></tt>. This leads to two problems: First, the
unsuspecting implementer is likely to erroneously compare the lower <tt>r</tt>
bits of <tt>X<sub>i-n</sub></tt> in <tt>operator==</tt>. Second, if only the lower <tt>r</tt> bits differ,
two <tt>mersenne_twister_engine</tt>s will compare equal (if correctly
implemented) but have different textual representations, which
conceptually is a bit ugly.
</p>

<p>
I propose that a paragraph or footnote is added to 99 [tr1::rand.eng.mers] which
clarifies that the lower <tt>r</tt> bits of <tt>X<sub>i-n</sub></tt> are not to be compared in
<tt>operator==</tt> and <tt>operator!=</tt>. It would only be consequent if furthermore
the specification for the textual respresentation was changed to
<tt>X<sub>i-n</sub> bitand ((2<sup>w</sup> - 1) - (2<sup>r</sup> - 1)), X<sub>i-(n-1)</sub>, ...,  X<sub>i-1</sub></tt> or
something similar.
</p>

<p>
These changes would likely have no practical effect, but would allow an
implementation that does the right thing to be standard-conformant.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Fermi Lab has no objection to the proposed change. However it feels that
more time is needed to check the details, which would suggest a change
to REVIEW.
</p>
<p>
Bill feels that this is NAD, not enough practical importance to abandon
the simple definition of equality, and someone would have to do a lot
more study to ensure that all cases are covered for a very small
payback. The submitter admits that "These changes would likely have no
practical effect,", and according to Plum's razor this means that it is
not worth the effort!
</p>
<p>
Revisted: Agree that the fact that there is no practical difference means that no change can be justified.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 99 [tr1::rand.eng.mers]:
</p>

<blockquote>
<p>
Insert at the end of para 2.:
</p>

<blockquote><p>
[<i>Note:</i> The lower <tt>r</tt> bits of <tt>X<sub>i-n</sub></tt> do not influence
the state transition and hence should not be compared when comparing two
<tt>mersenne_twister_engine</tt> objects. <i>-- end note</i>]
</p></blockquote>

<p>
In para 5. change:
</p>

<blockquote><p>
The textual representation of <tt>x<sub>i</sub></tt> consists of the values of
<tt>X<sub>i-n</sub> <ins>bitand ((2<sup>w</sup> - 1) - (2<sup>r</sup> - 1)),  X<sub>i-(n-1)</sub></ins>,
..., X<sub>i-1</sub></tt>, in that order.
</p></blockquote>
</blockquote>





<hr>
<h3><a name="802" href="802">802.</a> <tt>knuth_b</tt> returns wrong value</h3>
<p><b>Section:</b> 28.5.6 <a href="https://timsong-cpp.github.io/cppwp/rand.predef">[rand.predef]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>knuth_b</tt> is supposed to be
1112339016. We get 2126698284.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.5.6 <a href="https://timsong-cpp.github.io/cppwp/rand.predef">[rand.predef]</a>/p8:
</p>

<blockquote>
<pre>
typedef shuffle_order_engine&lt;minstd_rand0, 256&gt; 
        knuth_b; 
</pre>
<blockquote><p>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>knuth_b</tt> shall produce the value
<del>1112339016</del> <ins>2126698284</ins>.
</p></blockquote>
</blockquote>


<p><i>[
Bellevue: Submitter withdraws defect. "We got the wrong value for entirely the right reasons". NAD.
]</i></p>





<hr>
<h3><a name="812" href="812">812.</a> unsolicited multithreading considered harmful?</h3>
<p><b>Section:</b> 27.8.2 <a href="https://timsong-cpp.github.io/cppwp/alg.sort">[alg.sort]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paul McKenney <b>Opened:</b> 2008-02-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Multi-threading is a good thing, but unsolicited multi-threading can
potentially be harmful.  For example, <tt>sort()</tt> performance might be
greatly increased via a multithreaded implementation.  However, such
a multithreaded implementation could result in concurrent invocations
of the user-supplied comparator.  This would in turn result in problems
given a caching comparator that might be written for complex sort keys.
Please note that this is not a theoretical issue, as multithreaded
implementations of <tt>sort()</tt> already exist.
</p>
<p>
Having a multithreaded <tt>sort()</tt> available is good, but it should not
be the default for programs that are not explicitly multithreaded.
Users should not be forced to deal with concurrency unless they have
asked for it.
</p>

<p><i>[
This may be covered by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2410.html">N2410</a>
Thread-Safety in the Standard Library (Rev 1).
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p><p>
This is already covered by 17.6.5.6/20 in N2723.
</p>




<hr>
<h3><a name="822" href="822">822.</a> Object with explicit copy constructor no longer <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2008-04-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just noticed that the following program is legal in C++03, but
is forbidden in the current draft:
</p>

<blockquote><pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;

class Toto
{
public:
    Toto() {}
    explicit Toto( Toto const&amp; ) {}
} ;

int
main()
{
    std::vector&lt; Toto &gt; v( 10 ) ;
    return 0 ;
}
</pre></blockquote>

<p>
Is this change intentional?  (And if so, what is the
justification?  I wouldn't call such code good, but I don't see
any reason to break it unless we get something else in return.)
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
The subgroup that looked at this felt this was a good change, but it may
already be handled by incoming concepts (we're not sure).
</p></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: Proposed resolution kinda funky as these tables no longer
exist. Move from direct init to copy init. Clarify with Doug, recommends
NAD.
</p>
<p>
Walter: Suggest NAD via introduction of concepts.
</p>
<p>
Recommend close as NAD.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Need to look at again without concepts.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Move to Ready with original proposed resolution.
</p>
<p><i>[Howard:  Original proposed resolution restored.]</i></p>

</blockquote>

<p><i>[
2010-11 Batavia:
]</i></p>

<p>
This issue was re-reviewed in relation to [another issue, number to follow],
and the verdict was reversed.  Explicit copy and move constructors are rare
beasts, and the ripple effect of this fix was far more difficult to contain
than simply saying such types do not satisfy the <tt>MoveConstructible</tt>
and <tt>CopyConstructible</tt> requirements.
</p>

<blockquote>
<p>
In 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> change Table 33: <tt>MoveConstructible</tt> requirements [moveconstructible]:
</p>

<blockquote>
<table border="1">
<tr>
<th>expression</th><th>post-condition</th>
</tr>
<tr>
<td><tt>T t<ins>(rv)</ins><del> = rv</del></tt></td><td><tt>t</tt> is equivalent to the value of <tt>rv</tt> before the construction</td>
</tr>
<tr>
<td colspan="2" align="center">...</td>
</tr>
</table>
</blockquote>

<p>
In 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> change Table 34: <tt>CopyConstructible</tt> requirements [copyconstructible]:
</p>

<blockquote>
<table border="1">
<tr>
<th>expression</th><th>post-condition</th>
</tr>
<tr>
<td><tt>T t<ins>(u)</ins><del> = u</del></tt></td><td>the value of <tt>u</tt> is unchanged and is equivalent to <tt>t</tt></td>
</tr>
<tr>
<td colspan="2" align="center">...</td>
</tr>
</table>
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p><p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3215.htm">n3215</a>.
</p>




<hr>
<h3><a name="826" href="826">826.</a> Equivalent of <tt>%'d</tt>, or rather, lack thereof?</h3>
<p><b>Section:</b> 30.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/locale.nm.put">[locale.nm.put]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the spirit of <tt>printf vs iostream</tt>...
</p>

<p>
POSIX <tt>printf</tt> says that <tt>%'d</tt> should insert grouping characters (and the
implication is that in the absence of <tt>'</tt> no grouping characters are
inserted). The <tt>num_put</tt> facet, on the other hand, seems to always insert
grouping characters. Can this be considered a defect worth fixing for
C++0x? Maybe <tt>ios_base</tt> needs an additional flag?
</p>

<p><i>[
Pablo Halpern:
]</i></p>


<blockquote><p>
I'm not sure it constitutes a defect, but I would be in favor of adding
another flag (and corresponding manipulator).
</p></blockquote>

<p><i>[
Martin Sebor:
]</i></p>


<blockquote><p>
I don't know if it qualifies as a defect but I agree that there
should be an easy way to control whether the thousands separator
should or shouldn't be inserted. A new flag would be in line with
the current design of iostreams (like <tt>boolalpha</tt>, <tt>showpos</tt>, or
<tt>showbase</tt>).
</p></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote><p>
This is not a part of C99. LWG suggests submitting a paper may be appropriate.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="830" href="830">830.</a> Incomplete list of char_traits specializations</h3>
<p><b>Section:</b> 23.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits">[char.traits]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dietmar K&#252;hl <b>Opened:</b> 2008-04-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  Paragraph 4 of 23.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits">[char.traits]</a> mentions that this
  section specifies two specializations (<code>char_traits&lt;char&gt;</code>
  and (<code>char_traits&lt;wchar_t&gt;</code>). However, there are actually
  four specializations provided, i.e. in addition to the two above also
  <code>char_traits&lt;char16_t&gt;</code> and <code>char_traits&lt;char32_t&gt;</code>).
  I guess this was just an oversight and there is nothing wrong with just
  fixing this.
</p>

<p><i>[
Alisdair adds:
]</i></p>

<blockquote><p>
<tt>char_traits&lt; char16/32_t &gt;</tt>
should also be added to <tt>&lt;ios_fwd&gt;</tt> in 31.3 <a href="https://timsong-cpp.github.io/cppwp/iostream.forward">[iostream.forward]</a>, and all the specializations
taking a <tt>char_traits</tt> parameter in that header.
</p></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Idea of the issue is ok.
</p>
<p>
Alisdair to provide wording, once that wording arrives, move to review.
</p>

</blockquote>

<p><i>[
2009-05-04 Alisdair adds:
]</i></p>


<blockquote>
<p>
The main point of the issue was resolved editorially in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>,
so we are
close to NAD Editorial.
However, exploring the issue we found a second tweak was necessary for
<tt>&lt;iosfwd&gt;</tt> and that is still outstanding, so here are the words I am long
overdue delivering:
</p>

<p><i>[
Howard:  I've put Alisdair's words into the proposed wording section and
moved the issue to Review.
]</i></p>


</blockquote>

<p><i>[
Original proposed wording.
]</i></p>


<blockquote>

<p>
  Replace paragraph 4 of 23.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits">[char.traits]</a> by:
</p>
<blockquote>
<p>
  This subclause specifies a struct template, <code>char_traits&lt;charT&gt;</code>,
  and four explicit specializations of it, <code>char_traits&lt;char&gt;</code>,
  <code>char_traits&lt;char16_t&gt;</code>, <code>char_traits&lt;char32_t&gt;</code>, and
  <code>char_traits&lt;wchar_t&gt;</code>, all of which appear in the header
  &lt;string&gt; and satisfy the requirements below.
</p>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree.  Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change Forward declarations 31.3 <a href="https://timsong-cpp.github.io/cppwp/iostream.forward">[iostream.forward]</a>:
</p>

<blockquote>
<p>
<b>Header <tt>&lt;iosfwd&gt;</tt> synopsis</b>
</p>
<pre>
namespace std {
   template&lt;class charT&gt; class char_traits;
   template&lt;&gt; class char_traits&lt;char&gt;;
   <ins>template&lt;&gt; class char_traits&lt;char16_t&gt;;</ins>
   <ins>template&lt;&gt; class char_traits&lt;char32_t&gt;;</ins>
   template&lt;&gt; class char_traits&lt;wchar_t&gt;;
...
}
</pre>
</blockquote>





<hr>
<h3><a name="831" href="831">831.</a> wrong type for not_eof()</h3>
<p><b>Section:</b> 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations">[char.traits.specializations]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dietmar K&#252;hl <b>Opened:</b> 2008-04-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.specializations">issues</a> in [char.traits.specializations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  In Table 56 (Traits requirements) the <tt>not_eof()</tt> member function
  is using an argument of type <i>e</i> which denotes an object of
  type <code>X::int_type</code>. However, the specializations in
  23.2.4 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations">[char.traits.specializations]</a> all use <code>char_type</code>.
  This would effectively mean that the argument type actually can't
  represent EOF in the first place. I'm pretty sure that the type used
  to be <code>int_type</code> which is quite obviously the only sensible
  argument.
</p>
<p>
  This issue is close to being editorial. I suspect that the proposal
  changing this section to include the specializations for <code>char16_t</code>
  and <code>char32_t</code> accidentally used the wrong type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
  In 23.2.4.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char">[char.traits.specializations.char]</a>,
   [char.traits.specializations.char16_t],
   [char.traits.specializations.char32_t], and
   [char.traits.specializations.wchar_t] correct the
  argument type from <code>char_type</code> to <code>int_type</code>.
</p>


<p><b>Rationale:</b></p><p>
Already fixed in WP.
</p>




<hr>
<h3><a name="832" href="832">832.</a> Applying constexpr to System error support</h3>
<p><b>Section:</b> 19.5 <a href="https://timsong-cpp.github.io/cppwp/syserr">[syserr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-05-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Initialization of objects of class <tt>error_code</tt>
(19.5.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode">[syserr.errcode]</a>) and class
<tt>error_condition</tt> (19.5.5 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition">[syserr.errcondition]</a>) can be made simpler and more reliable by use of
the new <tt>constexpr</tt> feature 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2349.pdf">N2349</a>]
of C++0x. Less code will need to be
generated for both library implementations and user programs when
manipulating constant objects of these types. 
</p>

<p>
This was not proposed originally because the constant expressions
proposal was moving into the standard at about the same time as the
Diagnostics Enhancements proposal 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>],
and it wasn't desirable to
make the later depend on the former. There were also technical concerns
as to how <tt>constexpr</tt> would apply to references. Those concerns are now
resolved; <tt>constexpr</tt> can't be used for references, and that fact is
reflected in the proposed resolution.
</p>

<p>
Thanks to Jens Maurer, Gabriel Dos Reis, and Bjarne Stroustrup for clarification of <tt>constexpr</tt> requirements.
</p>

<p>
LWG issue <a href="804">804</a> is related in that it raises the question of whether the
exposition only member <tt>cat_</tt> of class <tt>error_code</tt> (19.5.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode">[syserr.errcode]</a>) and class
<tt>error_condition</tt> (19.5.5 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition">[syserr.errcondition]</a>) should be presented as a reference or pointer.
While in the context of <a href="804">804</a> that is arguably an editorial question,
presenting it as a pointer becomes more or less required with this
proposal, given <tt>constexpr</tt> does not play well with references. The
proposed resolution thus changes the private member to a pointer, which
also brings it in sync with real implementations.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote><p>
On going question of extern pointer vs. inline functions for interface.
</p></blockquote>

<p><i>[
Pre-San Francisco:
]</i></p>


<blockquote>
<p>
Beman Dawes reports that this proposal is unimplementable, and thus NAD.
</p>
<p>
Implementation would require <tt>constexpr</tt> objects of classes derived
from class <tt>error_category</tt>, which has virtual functions, and that is
not allowed by the core language. This was determined when trying to
implement the proposal using a constexpr enabled compiler provided
by Gabriel Dos Reis, and subsequently verified in discussions with
Gabriel and Jens Maurer.
</p>

</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
The proposed wording assumes the LWG <a href="805">805</a> proposed wording has been
applied to the WP, resulting in the former <tt>posix_category</tt> being renamed
<tt>generic_category</tt>. If <a href="805">805</a> has not been applied, the names in this
proposal must be adjusted accordingly.
</p>

<p>
Change 19.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.overview">[syserr.errcat.overview]</a> Class
<tt>error_category</tt> overview <tt>error_category</tt> synopsis  as
indicated:
</p>

<blockquote><pre>
<del>const error_category&amp; get_generic_category();</del>
<del>const error_category&amp; get_system_category();</del>

<del>static</del> <ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> generic_category<del> = get_generic_category()</del>;
<del>static</del> <ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>native_category</del> system_category<del> = get_system_category()</del>;
</pre></blockquote>

<p>
Change 19.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.objects">[syserr.errcat.objects]</a> Error category objects as indicated:
</p>

<blockquote>
<pre>
<ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>get_</del>generic_category<del>()</del>;
</pre>
<p>
<del><i>Returns:</i> A reference</del> <ins><tt>generic_category</tt> shall point</ins>
to <del>an</del> <ins>a statically initialized</ins> object of a type derived from
class <tt>error_category</tt>.
</p>

<p>
<del><i>Remarks:</i></del> The object's <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's <tt>name</tt> virtual function shall return a pointer to the string
<tt>"GENERIC"</tt>.
</p>

<pre>
<ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>get_</del>system_category<del>()</del>;
</pre>

<p>
<del><i>Returns:</i> A reference</del> <ins><tt>system_category</tt> shall point</ins>
to <del>an</del> <ins>a statically
initialized</ins> object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<del><i>Remarks:</i></del>  The object's <tt>equivalent</tt> virtual functions shall behave as
specified for class <tt>error_category</tt>. The object's <tt>name</tt> virtual function
shall return a pointer to the string <tt>"system"</tt>. The object's
<tt>default_error_condition</tt> virtual function shall behave as follows:
</p>

<p>
If the argument <tt>ev</tt> corresponds to a POSIX <tt>errno</tt> value <tt>posv</tt>, the function
shall return <tt>error_condition(posv, generic_category)</tt>. Otherwise, the
function shall return <tt>error_condition(ev, system_category)</tt>. What
constitutes correspondence for any given operating system is
unspecified. [<i>Note:</i> The number of potential system error codes is large
and unbounded, and some may not correspond to any POSIX <tt>errno</tt> value.
Thus implementations are given latitude in determining correspondence.
<i>-- end note</i>]
</p>
</blockquote>

<p>
Change 19.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.overview">[syserr.errcode.overview]</a> Class <tt>error_code</tt> overview as indicated:
</p>

<blockquote><pre>
class error_code {
public:
  ...;
  <ins>constexpr</ins> error_code(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  const error_category<del>&amp;</del><ins>*</ins> category() const;
  ...
private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre></blockquote>

<p>
Change 19.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.constructors">[syserr.errcode.constructors]</a> Class <tt>error_code</tt> constructors as indicated:
</p>

<blockquote>
<pre>
<ins>constexpr</ins> error_code(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_code</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.modifiers">[syserr.errcode.modifiers]</a> Class <tt>error_code</tt> modifiers  as indicated:
</p>

<blockquote>
<pre>
void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.observers">[syserr.errcode.observers]</a> Class <tt>error_code</tt> observers  as indicated:
</p>

<blockquote>
<pre>
const error_category<del>&amp;</del><ins>*</ins> category() const;
</pre>

<p>
<i>Returns:</i> <tt>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition.overview">[syserr.errcondition.overview]</a> Class <tt>error_condition</tt> overview   as indicated:
</p>

<blockquote>
<pre>
class error_condition {
public:
  ...;
  <ins>constexpr</ins> error_condition(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  const error_category<del>&amp;</del><ins>*</ins> category() const;
  ...
private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre>
</blockquote>

<p>
Change 19.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition.constructors">[syserr.errcondition.constructors]</a> Class <tt>error_condition</tt> constructors as indicated:
</p>

<blockquote>
<pre>
<ins>constexpr</ins> error_condition(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_condition</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.5.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition.modifiers">[syserr.errcondition.modifiers]</a> Class <tt>error_condition</tt> modifiers as indicated:
</p>

<blockquote>
<pre>
void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.5.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcondition.observers">[syserr.errcondition.observers]</a> Class <tt>error_condition</tt> observers as indicated:
</p>

<blockquote>
<pre>
const error_category<del>&amp;</del><ins>*</ins> category() const;
</pre>
<p>
<i>Returns:</i> <tt>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Throughout 19.5 <a href="https://timsong-cpp.github.io/cppwp/syserr">[syserr]</a> System error support, change "<tt>category().</tt>"  to "<tt>category()-&gt;</tt>".
Appears approximately six times.
</p>

<p>
<i>[Partially Editorial]</i> In 19.5.6 <a href="https://timsong-cpp.github.io/cppwp/syserr.compare">[syserr.compare]</a> Comparison operators,
paragraphs 2 and 4, change "<tt>category.equivalent(</tt>"  to
"<tt>category()-&gt;equivalent(</tt>".
</p>

<p>
Change 19.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.syserr.overview">[syserr.syserr.overview]</a> Class system_error overview as indicated:
</p>

<blockquote><pre>
public:
  system_error(error_code ec, const string&amp; what_arg);
  system_error(error_code ec);
  system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat,
      const string&amp; what_arg);
  system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat);
</pre></blockquote>

<p>
Change 19.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.syserr.members">[syserr.syserr.members]</a> Class system_error members as indicated:
</p>

<blockquote>
<pre>
system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat, const string&amp; what_arg);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt> and
<tt>strcmp(runtime_error::what(), what_arg.c_str()) == 0</tt>.
</p>
</blockquote>

<pre>
system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt> and
<tt>strcmp(runtime_error::what(), "") == 0</tt>.
</p>
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
NAD because Beman said so.
</p></blockquote>





<hr>
<h3><a name="833" href="833">833.</a> Freestanding implementations header list needs review for C++0x</h3>
<p><b>Section:</b> 16.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-05-14 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Once the C++0x standard library is feature complete, the LWG needs to
review 16.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a> Freestanding implementations header list to
ensure it reflects LWG consensus.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This is a placeholder defect to remind us to review the table once we've
stopped adding headers to the library.
</p>
<p>
Three new headers that need to be added to the list:
</p>
<blockquote><pre>
&lt;initializer_list&gt; &lt;concept&gt; &lt;iterator_concepts&gt;
</pre></blockquote>
<p>
<tt>&lt;iterator_concepts&gt;</tt>, in particular, has lots of stuff
that isn't needed, so maybe the stuff that is needed should be broken
out into a separate header.
</p>
<p>
Robert: What about <tt>reference_closure</tt>? It's currently in
<tt>&lt;functional&gt;</tt>.
</p>
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<ol>
<li>
The comment regarding <tt>reference_closure</tt> seems moot since it was just
recently decided to remove that.
</li>
<li>
A reference to proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>
("Fixing freestanding") should be added. This
paper e.g. proposes to add only <tt>&lt;initializer_list&gt;</tt> to the include list
of freestanding.
</li>
</ol>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Addressed by paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="837" href="837">837.</a> 
   <code>basic_ios::copyfmt()</code> overly loosely specified
 </h3>
<p><b>Section:</b> 31.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.members">[basic.ios.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

The <code>basic_ios::copyfmt()</code> member function is specified in 31.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.members">[basic.ios.members]</a> to have the following effects:

   </p>
   <blockquote><p>

<i>Effects</i>: If <code>(this == &amp;rhs)</code> does
nothing. Otherwise assigns to the member objects of <code>*this</code>
the corresponding member objects of <code>rhs</code>, except that
</p>
     <ul>
       <li>

<code>rdstate()</code> and <code>rdbuf()</code> are left unchanged;

       </li>
       <li>

<code>exceptions()</code> is altered last by
calling <code>exceptions(rhs.except)</code>

       </li>
       <li>

the contents of arrays pointed at by <code>pword</code>
and <code>iword</code> are copied not the pointers themselves

       </li>
     </ul>
   </blockquote>
   <p>

Since the rest of the text doesn't specify what the member objects
of <code>basic_ios</code> are this seems a little too loose.

</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed resolution.
Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>

I propose to tighten things up by adding a <i>Postcondition</i> clause
to the function like so:

   </p>
   <blockquote><p>
     <i>Postconditions:</i>
   </p>
     <table border="1">
       <thead>
         <tr>
           <th colspan="2"><code>copyfmt()</code> postconditions</th>
         </tr>
         <tr>
           <th>Element</th>
           <th>Value</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td><code>rdbuf()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>tie()</code></td>
           <td><code>rhs.tie()</code></td>
         </tr>
         <tr> 
           <td><code>rdstate()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>exceptions()</code></td>
           <td><code>rhs.exceptions()</code></td>
         </tr>
         <tr> 
           <td><code>flags()</code></td>
           <td><code>rhs.flags()</code></td>
         </tr>
         <tr> 
           <td><code>width()</code></td>
           <td><code>rhs.width()</code></td>
         </tr>
         <tr> 
           <td><code>precision()</code></td>
           <td><code>rhs.precision()</code></td>
         </tr>
         <tr> 
           <td><code>fill()</code></td>
           <td><code>rhs.fill()</code></td>
         </tr>
         <tr> 
           <td><code>getloc()</code></td>
           <td><code>rhs.getloc()</code></td>
         </tr>
       </tbody>
     </table>
   </blockquote>
   <p>

The format of the table follows Table 117 (as
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2588.pdf">N2588</a>): <code>basic_ios::init()</code>
effects.

   </p>
   <p>

The intent of the new table is not to impose any new requirements or
change existing ones, just to be more explicit about what I believe is
already there.

   </p>
 



<hr>
<h3><a name="840" href="840">840.</a> <tt>pair</tt> default template argument</h3>
<p><b>Section:</b> 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2008-05-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have one issue with <tt>std::pair</tt>. Well, it might just be a very annoying
historical accident, but why is there no default template argument for
the second template argument? This is so annoying when the type in
question is looong and hard to write (type deduction with <tt>auto</tt> won't
help those cases where we use it as a return or argument type).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 22.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> to read:
</p>

<blockquote><pre>
template &lt;class T1, class T2 <ins>= T1</ins>&gt; struct pair;
</pre></blockquote>

<p>
Change 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> to read:
</p>

<blockquote><pre>
namespace std {
 template &lt;class T1, class T2 <ins>= T1</ins>&gt;
 struct pair {
   typedef T1 first_type;
   typedef T2 second_type;
   ...
</pre></blockquote>


<p><b>Rationale:</b></p><p>
<tt>std::pair</tt> is a heterogeneous container.
</p>




<hr>
<h3><a name="841" href="841">841.</a> cstdint.syn inconsistent with C99</h3>
<p><b>Section:</b> 17.4.2 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

In specifying the names of macros and types defined in
header <code>&lt;stdint.h&gt;</code>, C99 makes use of the
symbol <code><i>N</i></code> to accommodate unusual platforms with
word sizes that aren't powers of two. C99
permits <code><i>N</i></code> to take on any positive integer value
(including, for example, 24).

   </p>
   <p>

In  [stdint.sy] Header <code>&lt;cstdint&gt;</code>
synopsis, C++ on the other hand, fixes the value
of <code><i>N</i></code> to 8, 16, 32, and 64, and specifies only
types with these exact widths. 

   </p>
   <p>

In addition, paragraph 1 of the same section makes use of a rather
informal shorthand notation to specify sets of macros. When
interpreted strictly, the notation specifies macros such
as <code>INT_8_MIN</code> that are not intended to be specified.

   </p>
   <p>

Finally, the section is missing the usual table of symbols defined
in that header, making it inconsistent with the rest of the
specification.

   </p>
 
 <p><b>Proposed resolution:</b></p>
   <p>

I propose to use the same approach in the C++ spec as C99 uses, that
is, to specify the header synopsis in terms of "exposition only" types
that make use of the symbol <code><i>N</i></code> to denote one or
more of a theoretically unbounded set of widths.

   </p>
   <p>

Further, I propose to add a new table to section listing the symbols
defined in the header using a more formal notation that avoids
introducing inconsistencies.

   </p>
   <p>

To this effect, in  [stdint.sy]
Header <code>&lt;cstdint&gt;</code> synopsis, replace both the
synopsis and paragraph 1 with the following text:

   </p>
   <blockquote>
     <p>
     </p>
       <ol>
         <li>

In the names defined in the <code>&lt;cstdint&gt;</code> header, the
symbol <code><i>N</i></code> represents a positive decimal integer
with no leading zeros (e.g., 8 or 24, but not 0, 04, or 048). With the
exception of exact-width types, macros and types for values
of <code><i>N</i></code> in the set of 8, 16, 32, and 64 are
required. Exact-width types, and any macros and types for values
of <code><i>N</i></code> other than 8, 16, 32, and 64 are
optional. However, if an implementation provides integer types with
widths of 8, 16, 32, or 64 bits, the corresponding exact-width types
and macros are required.

         </li>
       </ol>
     <pre>
namespace std {

   // required types

   // Fastest minimum-width integer types
   typedef <i>signed integer type</i>   int_fast8_t;
   typedef <i>signed integer type</i>   int_fast16_t;
   typedef <i>signed integer type</i>   int_fast32_t;
   typedef <i>signed integer type</i>   int_fast64_t;

   typedef <i>unsigned integer type</i> uint_fast8_t;
   typedef <i>unsigned integer type</i> uint_fast16_t;
   typedef <i>unsigned integer type</i> uint_fast32_t;
   typedef <i>unsigned integer type</i> uint_fast64_t;

   // Minimum-width integer types
   typedef <i>signed integer type</i>   int_least8_t;
   typedef <i>signed integer type</i>   int_least16_t;
   typedef <i>signed integer type</i>   int_least32_t;
   typedef <i>signed integer type</i>   int_least64_t;

   typedef <i>unsigned integer type</i> uint_least8_t;
   typedef <i>unsigned integer type</i> uint_least16_t;
   typedef <i>unsigned integer type</i> uint_least32_t;
   typedef <i>unsigned integer type</i> uint_least64_t;

   // Greatest-width integer types
   typedef <i>signed integer type</i>   intmax_t;
   typedef <i>unsigned integer type</i> uintmax_t;

   // optionally defined types

   // Exact-width integer types
   typedef <i>signed integer type</i>   int<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint<i>N</i>_t;

   // Fastest minimum-width integer types for values
   // of <i>N</i> other than 8, 16, 32, and 64
   typedef <i>signed integer type</i>   uint_fast<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint_fast<i>N</i>_t;

   // Minimum-width integer types for values
   // of <i>N</i> other than 8, 16, 32, and 64
   typedef <i>signed integer type</i>   uint_least<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint_least<i>N</i>_t;

   // Integer types capable of holding object pointers
   typedef <i>signed integer type</i>   intptr_t;
   typedef <i>signed integer type</i>   intptr_t;

}</pre>
   </blockquote>
   <p>

[Note to editor: Remove all of the existing paragraph 1 from  [stdint.sy].]

   </p>
   <blockquote><p>
     Table ??: Header <code>&lt;cstdint&gt;</code> synopsis
	 </p>
     <table border="1">
       <thead>
         <tr>
           <th>Type</th>
           <th colspan="3">Name(s)</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td rowspan="11"><b>Macros:</b></td>
           <td><tt>INT<i>N</i>_MIN</tt></td>
           <td><tt>INT<i>N</i>_MAX</tt></td>
           <td><tt>UINT<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INT_FAST<i>N</i>_MIN</tt></td>
           <td><tt>INT_FAST<i>N</i>_MAX</tt></td>
           <td><tt>UINT_FAST<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INT_LEAST<i>N</i>_MIN</tt></td>
           <td><tt>INT_LEAST<i>N</i>_MAX</tt></td>
           <td><tt>UINT_LEAST<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INTPTR_MIN</tt></td>
           <td><tt>INTPTR_MAX</tt></td>
           <td><tt>UINTPTR_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INTMAX_MIN</tt></td>
           <td><tt>INTMAX_MAX</tt></td>
           <td><tt>UINTMAX_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>PTRDIFF_MIN</tt></td>
           <td><tt>PTRDIFF_MAX</tt></td>
           <td><tt>PTRDIFF_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>SIG_ATOMIC_MIN</tt></td>
           <td><tt>SIG_ATOMIC_MAX</tt></td>
           <td><tt>SIZE_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>WCHAR_MIN</tt></td>
           <td><tt>WCHAR_MAX</tt></td>
         <td></td>
         </tr>
         <tr>
           <td><tt>WINT_MIN</tt></td>
           <td><tt>WINT_MAX</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>INT<i>N</i>_C()</tt></td>
           <td><tt>UINT<i>N</i>_C()</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>INTMAX_C()</tt></td>
           <td><tt>UINTMAX_C()</tt></td>
           <td></td>
         </tr>
         <tr>
           <td rowspan="5"><b>Types:</b></td>
           <td><tt>int<i>N</i>_t</tt></td>
           <td><tt>uint<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>int_fast<i>N</i>_t</tt></td>
           <td><tt>uint_fast<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>int_least<i>N</i>_t</tt></td>
           <td><tt>uint_least<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>intptr_t</tt></td>
           <td><tt>uintptr_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>intmax_t</tt></td>
           <td><tt>uintmax_t</tt></td>
           <td></td>
         </tr>
       </tbody>
     </table>
   </blockquote>
 




<hr>
<h3><a name="849" href="849">849.</a> missing type traits to compute root class and derived class of types in a class hierachy</h3>
<p><b>Section:</b> 21.3.8.7 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The type traits library contains various traits to dealt with
polymorphic types, e.g. <tt>std::has_virtual_destructor</tt>, <tt>std::is_polymorphic</tt>
and <tt>std::is_base_of</tt>. However, there is no way to compute the unique
public base class of a type  if such  one exists.  Such a trait could be
very useful if one needs to instantiate a specialization made for the
root class whenever a derived class is passed as parameter. For example,
imagine that you wanted to specialize <tt>std::hash</tt> for a class
hierarchy---instead of specializing each class, you could specialize the
<tt>std::hash&lt;root_class&gt;</tt> and provide a partial specialization that worked
for all derived classes.
</p>

<p>
This ability---to specify operations in terms of their equivalent in the
root class---can be done with e.g. normal functions, but there is,
AFAIK, no way to do it for class templates. Being able to access
compile-time information about the type-hierachy can be very powerful,
and I therefore also suggest traits that computes the directly derived
class whenever that is possible.
</p>

<p>
If the computation can not be done, the traits should fall back on an
identity transformation. I expect this gives the best overall usability.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following to the synopsis in 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> under "other transformations":
</p>

<blockquote><pre>
template&lt; class T &gt; struct direct_base_class;
template&lt; class T &gt; struct direct_derived_class;
template&lt; class T &gt; struct root_base_class;
</pre></blockquote>

<p>
Add three new entries to table 51 (21.3.8.7 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a>) with the following content
</p>

<blockquote>
<table border="1">
<tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct direct_base_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the accessible unambiguous direct base class of <tt>T</tt>.
If no such type exists, the member typedef <tt>type</tt> shall equal <tt>T</tt>.</td>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct direct_derived_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the unambiguous type which has <tt>T</tt>
as an accessible unambiguous direct base class. If no such type exists, the member typedef
<tt>type</tt> shall equal <tt>T</tt>.</td>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct root_base_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the accessible unambiguous most indirect base class of
<tt>T</tt>. If no such type exists, the member typedef type shall equal <tt>T</tt>.</td>
</tr>
</table>
</blockquote>



<p><b>Rationale:</b></p><p>
2008-9-16 San Francisco:  Issue pulled by author prior to being reviewed by the LWG.
</p>




<hr>
<h3><a name="851" href="851">851.</a> simplified array construction</h3>
<p><b>Section:</b> 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2017-06-06 14:03:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is an issue that came up on the libstdc++ list, where a
discrepancy between "C" arrays and C++0x's <tt>std::array</tt> was pointed
out.
</p>

<p>
In "C," this array usage is possible:
</p>

<blockquote><pre>
int ar[] = {1, 4, 6};
</pre></blockquote>

<p>
But for C++, 
</p>

<blockquote><pre>
std::array&lt;int&gt; a = { 1, 4, 6 }; // error
</pre></blockquote>

<p>
Instead, the second parameter of the <tt>array</tt> template must be
explicit, like so:
</p>

<blockquote><pre>
std::array&lt;int, 3&gt; a = { 1, 4, 6 };
</pre></blockquote>

<p>
Doug Gregor proposes the following solution, that assumes
generalized initializer lists.
</p>

<blockquote><pre>
template&lt;typename T, typename... Args&gt;
inline array&lt;T, sizeof...(Args)&gt; 
make_array(Args&amp;&amp;... args) 
{ return { std::forward&lt;Args&gt;(args)... };  }
</pre></blockquote>

<p>
Then, the way to build an <tt>array</tt> from a list of unknown size is:
</p>

<blockquote><pre>
auto a = make_array&lt;T&gt;(1, 4, 6);
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Benjamin: Move to Ready?
</p>
<p>
Bjarne: I'm not convinced this is useful enough to add, so I'd like us
to have time to reflect on it.
</p>
<p>
Alisdair: the constraints are wrong, they should be
</p>
<blockquote><pre>
template&lt;ValueType T, ValueType... Args&gt;
requires Convertible&lt;Args, T&gt;...
array&lt;T, sizeof...(Args)&gt; make_array(Args&amp;&amp;... args);
</pre></blockquote>
<p>
Alidair: this would be useful if we had a constexpr version.
</p>
<p>
Bjarne: this is probably useful for arrays with a small number of
elements, but it's not clearly useful otherwise.
</p>
<p>
Consensus is to move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest a fix and a simplification of the current proposal: Recent
prototyping by
Howard showed, that a fix is required because narrowing conversion
9.4.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>/6 b.3
would severely limit the possible distribution of argument types, e.g.
the expression
<tt>make_array&lt;double&gt;(1, 2.0)</tt> is ill-formed, because the narrowing
happens <em>inside</em> the
function body where no constant expressions exist anymore. Furthermore
given e.g.
</p>
<blockquote><pre>
int f();
double g();
</pre></blockquote>
<p>
we probably want to support
</p>
<blockquote><pre>
make_array&lt;double&gt;(f(), g());
</pre></blockquote>

<p>
as well. To make this feasible, the currently suggested expansion
</p>

<blockquote><pre>
{ std::forward&lt;Args&gt;(args)... }
</pre></blockquote>

<p>
needs to be replaced by
</p>

<blockquote><pre>
{ static_cast&lt;T&gt;(std::forward&lt;Args&gt;(args))... }
</pre></blockquote>

<p>
which is safe, because we already ensure convertibility via the
element-wise <tt>Convertible&lt;Args, T&gt;</tt> requirement. Some other fixes are
necessary: The <tt>ValueType</tt> requirement for the function <em>parameters</em>
is invalid, because all lvalue arguments will deduce to an lvalue-reference,
thereby no longer satisfying this requirement.
</p>

<p>
The suggested simplification is to provide a default-computed effective
type for the result array based on common_type and decay, in
unconstrained form:
</p>

<blockquote><pre>
template&lt;typename... Args&gt;
array&lt;typename decay&lt;typename common_type&lt;Args...&gt;::type&gt;::type,
sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</pre></blockquote>

<p>
The approach used below is similar to that of <tt>make_pair</tt> and <tt>make_tuple</tt>
using a symbol <tt>C</tt> to represent the decayed common type [Note: Special
handling of <tt>reference_wrapper</tt> types is intentionally <em>not</em> provided, because
our target has so satisfy <tt>ValueType</tt>, thus under the revised proposal only
an all-<tt>reference_wrapper</tt>-arguments would be well-formed and an array of
<tt>reference_wrapper</tt> will be constructed]. I do currently not suggest to
add new concepts reflecting <tt>decay</tt> and <tt>common_type</tt>, but an implementor will
need something like this to succeed. Note that we use a similar fuzziness for
<tt>make_pair</tt> and <tt>make_tuple</tt> currently. This fuzziness is not related to
the currently
missing <tt>Constructible&lt;Vi, Ti&amp;&amp;&gt;</tt> requirement for those functions. The following
proposal fixes that miss for <tt>make_array</tt>. If the corresponding <tt>C</tt> type
deduction is
explicitly wanted for standardization, here the implementation
</p>

<blockquote><pre>
auto concept DC&lt;typename... T&gt; {
  typename type = typename decay&lt;typename common_type&lt;T...&gt;::type&gt;::type;
}
</pre></blockquote>

<p>
where <tt>C</tt> is identical to <tt>DC&lt;Args...&gt;::type</tt> in the proposed resolution below.
</p>
<p>
I intentionally added no further type relation between type and the concept
template parameters, but instead added this requirement below to make
the specification as transparent as possible. As written this concept is
satisfied, if the corresponding associated type exists.
</p>

<p><b>Suggested Resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 24.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>:
</p>
<blockquote><pre>
<ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 24.3.7.7 <a href="https://timsong-cpp.github.io/cppwp/array.tuple">[array.tuple]</a> Tuple interface to class template array
the following new section:
</p>
<blockquote>
<p>
23.4.1.7 Array creation functions [array.creation]
</p>

<pre>
<ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);</ins>
</pre>

<blockquote>
<p><ins>
Let <tt>C</tt> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.
</ins></p>
<p>
<ins><i>Returns:</i> an <tt>array&lt;C, sizeof...(Args)&gt;</tt> initialized with
<tt>{ static_cast&lt;C&gt;(std::forward&lt;Args&gt;(args))... }</tt>.
</ins></p>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
The proposed resolution uses concepts.
</p>
<p>
Daniel to rewrite the proposed resolution.
</p>
<p>
Leave Open.
</p>
</blockquote>

<p><i>[
2009-07-25 Daniel provides rewritten proposed resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Argument for NAD future: everything about this could be added on. This
does not require changes to the existing text.
</p></blockquote>

<p><i>[2015-11-29, Alisdair comments]</i></p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4391">N4391</a> was adopted for Fundamentals 2 at the Lenexa meeting.
</p>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>


<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>It seems as if deduction guides can solve most of the problem. In addition
to that, make_array is available in Library Fundamentals TS v2. If
it's desired to be able to specify the type but not the extent, make_array
can do that, and if make_array isn't acceptable for that, we are talking
about a language extension in deduction guides, which needs a proposal
paper.</p>
<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 24.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>:
</p>

<blockquote><pre>
<ins>template&lt;class... Args&gt;
  array&lt;<i>CT</i>, sizeof...(Args)&gt;
  make_array(Args&amp;&amp;... args);</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 24.3.7.7 <a href="https://timsong-cpp.github.io/cppwp/array.tuple">[array.tuple]</a> "Tuple interface to class template array" the
following new section:
</p>

<blockquote>
<p>
<ins>XX.X.X.X Array creation functions [array.creation]</ins>
</p>

<pre><ins>
template&lt;class... Args&gt;
array&lt;<i>CT</i>, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args)
</ins></pre>

<blockquote>
<p>
<ins>Let <i>CT</i> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.</ins>
</p>
<p>
<ins><i>Returns:</i> An <tt>array&lt;<i>CT</i>, sizeof...(Args)&gt;</tt> initialized with <tt>{
static_cast&lt;<i>CT</i>&gt;(std::forward&lt;Args&gt;(args))... }</tt>.</ins>
</p>

<p><ins>
[<i>Example:</i>
</ins></p>
<blockquote><pre><ins>
int i = 0; int&amp; ri = i;
make_array(42u, i, 2.78, ri);
</ins></pre></blockquote>
<p><ins>
returns an array of type
</ins></p>
<blockquote><pre><ins>
array&lt;double, 4&gt;
</ins></pre></blockquote>

<p><ins>
&mdash;<i>end example</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>








<hr>
<h3><a name="855" href="855">855.</a> capacity() and reserve() for deque?</h3>
<p><b>Section:</b> 24.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Herv&eacute; Br&ouml;nnimann <b>Opened:</b> 2008-06-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#deque.capacity">issues</a> in [deque.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The main point is that <tt>capacity</tt> can be viewed as a mechanism to  
guarantee the validity of <tt>iterators</tt> when only <tt>push_back/pop_back</tt>
operations are used.  For <tt>vector</tt>, this goes with reallocation.  For  
<tt>deque</tt>, this is a bit more subtle:  <tt>capacity()</tt> of a <tt>deque</tt> may shrink,  
whereas that of <tt>vector</tt> doesn't.   In a circular buffer impl. of the  
map, as Howard did, there is very similar notion of capacity: as long  
as <tt>size()</tt> is less than <tt>B * (</tt>total size of the map <tt>- 2)</tt>, it is  
guaranteed that no <tt>iterator</tt> is invalidated after any number of  
<tt>push_front/back</tt> and <tt>pop_front/back</tt> operations.  But this does not  
hold for other implementations.
</p>
<p>
Still, I believe, <tt>capacity()</tt> can be defined by <tt>size() +</tt>  how many  
<tt>push_front/back</tt> minus <tt>pop_front/back</tt> that can be performed before  
terators are invalidated.  In a classical impl., <tt>capacity() = size()
+ </tt> the min distance to either "physical" end of the deque (i.e.,  
counting the empty space in the last block plus all the blocks until  
the end of the map of block pointers).  In Howard's circular buffer  
impl., <tt>capacity() = B * (</tt>total size of the map <tt>- 2)</tt> still works with  
this definition, even though the guarantee could be made stronger.
</p>
<p>
A simple picture of a deque:
</p>
<blockquote><pre>
A-----|----|-----|---F+|++++|++B--|-----|-----Z
</pre></blockquote>
<p>
(A,Z mark the beginning/end, | the block boundaries, F=front, B=back,  
and - are uninitialized, + are initialized)
In that picture:  <tt>capacity = size() + min(dist(A,F),dist(B,Z)) = min 
(dist(A,B),dist(F,Z))</tt>.
</p>
<p>
<tt>Reserve(n)</tt> can grow the map of pointers and add possibly a number of  
empty blocks to it, in order to guarantee that the next <tt>n-size()
push_back/push_front</tt> operations will not invalidate iterators, and  
also will not allocate (i.e. cannot throw).  The second guarantee is  
not essential and can be left as a QoI.  I know well enough existing  
implementations of <tt>deque</tt> (sgi/stl, roguewave, stlport, and  
dinkumware) to know that either can be implemented with no change to  
the existing class layout and code, and only a few modifications if  
blocks are pre-allocated (instead of always allocating a new block,  
check if the next entry in the map of block pointers is not zero).
</p>
<p>
Due to the difference with <tt>vector</tt>, wording is crucial.  Here's a  
proposed wording to make things concrete;  I tried to be reasonably  
careful but please double-check me:
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Hans: should the Returns clause for capacity read "1 Returns: A lower
bound..." rather than "1 Returns: An upper bound..."
</p>
<p>
Howard: maybe what's needed is capacity_front and capacity_back. In
fact, I think I implemented a deque that had these members as
implementation details.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add new signatures to synopsis in 24.3.8 <a href="https://timsong-cpp.github.io/cppwp/deque">[deque]</a>:
</p>

<blockquote><pre>
size_type capacity() const;
bool reserve(size_type n);
</pre></blockquote>

<p>
Add new signatures to 24.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a>:
</p>

<blockquote>
<pre>
size_type capacity() const;
</pre>
<blockquote>
<p>
1 <i>Returns:</i> An upper bound on <tt>n + max(n_f - m_f, n_b - m_b)</tt>  such  
that, for any sequence of <tt>n_f push_front</tt>, <tt>m_f pop_front</tt>, <tt>n_b  
push_back</tt>, and <tt>m_b pop_back</tt> operations, interleaved in any order,  
starting with the current <tt>deque</tt> of size <tt>n</tt>, the <tt>deque</tt> does not  
invalidate any of its iterators except to the erased elements.
</p>
<p>
2 <i>Remarks:</i>  Unlike a <tt>vector</tt>'s capacity, the capacity of a <tt>deque</tt> can  
decrease after a sequence of insertions at both ends, even if none of  
the operations caused the <tt>deque</tt> to invalidate any of its iterators  
except to the erased elements.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>
bool reserve(size_type n);
</pre>
<blockquote>
<p>
2 <i>Effects:</i> A directive that informs a <tt>deque</tt> of a planned sequence of  
<tt>push_front</tt>, <tt>pop_front</tt>, <tt>push_back</tt>, and <tt>pop_back</tt> operations, so that it  
can manage iterator invalidation accordingly. After <tt>reserve()</tt>,  
<tt>capacity()</tt> is greater or equal to the argument of <tt>reserve</tt> if this  
operation returns <tt>true</tt>; and equal to the previous value of <tt>capacity()</tt>
otherwise.  If an exception is thrown, there are no effects.
</p>
<p>
3 <i>Returns:</i> <tt>true</tt> if iterators are invalidated as a result of this  
operation, and false otherwise.
</p>
<p>
4 <i>Complexity:</i> It does not change the size of the sequence and takes  
at most linear time in <tt>n</tt>.
</p>
<p>
5 <i>Throws:</i> <tt>length_error</tt> if <tt>n &gt; max_size()</tt>.
</p>
<p>
6 <i>Remarks:</i> It is guaranteed that no invalidation takes place during a  
sequence of <tt>insert</tt> or <tt>erase</tt> operations at either end that happens  
after a call to <tt>reserve()</tt> except to the erased elements, until the  
time when an insertion would make <tt>max(n_f-m_f, n_b-m_b)</tt> larger than  
<tt>capacity()</tt>, where <tt>n_f</tt> is the number of <tt>push_front</tt>, <tt>m_f</tt> of <tt>pop_front</tt>,  
<tt>n_b</tt> of <tt>push_back</tt>, and <tt>m_b</tt> of <tt>pop_back</tt> operations since the call to  
<tt>reserve()</tt>.
</p>
<p>
7        An implementation is free to pre-allocate buffers so as to  
offer the additional guarantee that no exception will be thrown  
during such a sequence other than by the element constructors.
</p>
</blockquote>
</blockquote>

<p>
And 24.3.8.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a> para 1, can be enhanced:
</p>

<blockquote><p>
1 <i>Effects:</i> An insertion in the middle of the deque invalidates all the iterators and references to elements of the
deque. An insertion at either end of the deque invalidates all the iterators to the deque,
<ins>unless provisions have been made with reserve,</ins>
but has no effect on the validity of references to elements of the deque.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>Complication outweighs the benefit.</p>





<hr>
<h3><a name="862" href="862">862.</a> Impossible complexity for 'includes'</h3>
<p><b>Section:</b> 27.8.7.2 <a href="https://timsong-cpp.github.io/cppwp/includes">[includes]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-07-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#includes">issues</a> in [includes].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 27.8.7.2 <a href="https://timsong-cpp.github.io/cppwp/includes">[includes]</a> the complexity is "at most -1 comparisons" if passed
two empty ranges.  I don't know how to perform a negative number of
comparisions!
</p>

<p>
This same issue also applies to:
</p>

<ul>
<li><tt>set_union</tt></li>
<li><tt>set_intersection</tt></li>
<li><tt>set_difference</tt></li>
<li><tt>set_symmetric_difference</tt></li>
<li><tt>merge</tt></li>
</ul>

<p><i>[
2009-03-30 Beman adds:
]</i></p>


<blockquote><p>
Suggest NAD. The complexity of empty ranges is -1 in other places in the
standard. See 27.8.6 <a href="https://timsong-cpp.github.io/cppwp/alg.merge">[alg.merge]</a> <tt>merge</tt> and
<tt>inplace_merge</tt>, and <tt>forward_list</tt> merge, for example.
The time and effort to find and fix all places in the standard where
empty range[s] result in negative complexity isn't worth the very
limited benefit.
</p></blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
I'm not happy with NAD if we can find a simple solution.
</p>
<p>
How about adding a rider somewhere in clause 17 suggesting that complexities
that specify a negative number of operations are treated as specifying zero
operations?  That should generically solve the issue without looking for
further cases.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Pete to provide "straightforward" wording.
Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>





<hr>
<h3><a name="863" href="863">863.</a> What is the state of a stream after close() succeeds</h3>
<p><b>Section:</b> 31.10 <a href="https://timsong-cpp.github.io/cppwp/file.streams">[file.streams]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2008-07-08 <b>Last modified:</b> 2017-06-15 20:26:45 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#file.streams">issues</a> in [file.streams].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Suppose writing to an <tt>[o]fstream</tt> fails and you later close the <tt>stream</tt>.
The <tt>overflow()</tt> function is called to flush the buffer (if it exists).
Then the file is unconditionally closed, as if by calling <tt>flcose</tt>.
</p>
<p>
If either <tt>overflow</tt> or <tt>fclose</tt> fails, <tt>close()</tt> reports failure, and clearly
the <tt>stream</tt> should be in a failed or bad state.
</p>
<p>
Suppose the buffer is empty or non-existent (so that <tt>overflow()</tt> does not
fail), and <tt>fclose</tt> succeeds. The <tt>close()</tt> function reports success, but
what is the state of the <tt>stream</tt>?
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Tom's impression is that the issue is about the <tt>failbit</tt>, etc.
</p>
<p>
Bill responds that the stream is now closed,
and any status bits remain unchanged.
</p>
<p>
See the description of <tt>close()</tt> in 31.10.5.4 <a href="https://timsong-cpp.github.io/cppwp/fstream.members">[fstream.members]</a>.
</p>
<p>
We prefer not to add wording to say that nothing changes.
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="864" href="864">864.</a> Defect in atomic wording</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-07-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There's an error in 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a>/p9:
</p>

<blockquote>
<pre>
C atomic_load(const volatile A * object);
C atomic_load_explicit(const volatile A * object, memory_order);
C A ::load(memory_order order = memory_order_seq_cst) const volatile;
</pre>
<blockquote>
<p>
<i>Requires:</i> The <tt>order</tt> argument shall not be <tt>memory_order_acquire</tt> nor
<tt>memory_order_acq_rel</tt>.
</p>
</blockquote>
</blockquote>

<p>
I believe that this should state
</p>
<blockquote><p>
shall not be <tt>memory_order_release</tt>.
</p></blockquote>

<p>
There's also an error in 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a>/p17:
</p>

<blockquote><p>
... When only one <tt>memory_order</tt> argument is supplied, the value of success
is <tt>order</tt>, and
the value of failure is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<tt>memory_order_require</tt> ...
</p></blockquote>
<p>
I believe this should state
</p>
<blockquote><p>
shall be replaced by the value <tt>memory_order_acquire</tt> ...
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a>/p9:
</p>

<blockquote>
<pre>
C atomic_load(const volatile A * object);
C atomic_load_explicit(const volatile A * object, memory_order);
C A ::load(memory_order order = memory_order_seq_cst) const volatile;
</pre>
<blockquote>
<p>
<i>Requires:</i> The <tt>order</tt> argument shall not be <del><tt>memory_order_acquire</tt></del>
<ins><tt>memory_order_release</tt></ins> nor <tt>memory_order_acq_rel</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a>/p17:
</p>

<blockquote><p>
... When only one <tt>memory_order</tt> argument is supplied, the value of success
is <tt>order</tt>, and
the value of failure is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<del><tt>memory_order_require</tt></del> <ins><tt>memory_order_acquire</tt></ins> ...
</p></blockquote>



<p><b>Rationale:</b></p>
<p>Already fixed by the time the LWG processed it.</p>





<hr>
<h3><a name="867" href="867">867.</a> Valarray and value-initialization</h3>
<p><b>Section:</b> 28.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/valarray.cons">[valarray.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-07-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From 28.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/valarray.cons">[valarray.cons]</a>, paragraph 2:
</p>

<blockquote><pre>
explicit  valarray(size_t);
</pre>
<blockquote><p>
The array created by this constructor has a length equal to the value of the argument. The elements
of the array are constructed using the default constructor for the instantiating type <tt>T</tt>.
</p></blockquote>
</blockquote>

<p>
The problem is that the most obvious <tt>T</tt>s for <tt>valarray</tt> are <tt>float</tt>
and <tt>double</tt>, they don't have a default constructor. I guess the intent is to value-initialize
the elements, so I suggest replacing:
</p>

<blockquote><p>
The elements of the array are constructed using the default constructor for the instantiating type <tt>T</tt>.
</p></blockquote>
<p>
with
</p>
<blockquote><p>
The elements of the array are value-initialized.
</p></blockquote>

<p>
There is another reference to the default constructor of <tt>T</tt> in the non-normative note in paragraph 9.
That reference should also be replaced. (The normative wording in paragraph 8 refers to <tt>T()</tt>
and so it doesn't need changes).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed resolution.
Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/valarray.cons">[valarray.cons]</a>, paragraph 2:
</p>

<blockquote>
<pre>
explicit  valarray(size_t);
</pre>
<blockquote><p>
The array created by this constructor has a length equal to the value of the argument. The elements
of the array are <del>constructed using the default constructor for the instantiating type <tt>T</tt></del>
<ins>value-initialized (9.4 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>)</ins>.
</p></blockquote>
</blockquote>

<p>
Change 28.6.2.8 <a href="https://timsong-cpp.github.io/cppwp/valarray.members">[valarray.members]</a>, paragraph 9:
</p>

<blockquote><p>
[<i>Example:</i> If the argument has the value -2, the first two elements of the result will be <del>constructed using the 
default constructor</del>
<ins>value-initialized (9.4 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>)</ins>;
the third element of the result will be assigned the value of the first element of the argument; etc. <i>-- end example</i>]
</p></blockquote>






<hr>
<h3><a name="873" href="873">873.</a> signed integral type and unsigned integral type are not clearly defined</h3>
<p><b>Section:</b> 6.8.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Travis Vitek <b>Opened:</b> 2008-06-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
      Neither the term "signed integral type" nor the term "unsigned
      integral type" is defined in the core language section of the
      standard, therefore the library section should avoid its use.  The
      terms <i>signed integer type</i> and <i>unsigned integer type</i> are
      indeed defined (in 6.8.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>), thus the usages should be
      replaced accordingly.
    </p>

    <p>
      Note that the key issue here is that "signed" + "integral type" !=
      "signed integral type".
      
      The types <code>bool</code>, <code>char</code>, <code>char16_t</code>,
      <code>char32_t</code> and <code>wchar_t</code> are all listed as
      integral types, but are neither of <i>signed integer type</i> or
      <i>unsigned integer type</i>. According to 6.8 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a> p7, a synonym for
      integral type is <i>integer type</i>.
      
      Given this, one may choose to assume that an <i>integral type</i> that
      can represent values less than zero is a <i>signed integral type</i>.
      Unfortunately this can cause ambiguities.
      
      As an example, if <code>T</code> is <code>unsigned char</code>, the
      expression <code>make_signed&lt;T&gt;::type</code>, is supposed to
      name a signed integral type. There are potentially two types that
      satisfy this requirement, namely <code>signed char</code> and
      <code>char</code> (assuming <code>CHAR_MIN &lt; 0</code>).
    </p>

<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Plum, Sebor to review.
</p></blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote><p>
The proposed resolution needs to be "conceptualized". Currently we have
in  [concept.support] only concept <tt>IntegralType</tt>
for all "integral types", thus indeed the current <tt>Container</tt>
concept and Iterator concepts are sufficiently satisfied with "integral
types". If the changes are applied, we might ask core for concept
<tt>BilateralIntegerType</tt> and add proper restrictions to the library
concepts.
</p></blockquote>

  

  <p><b>Proposed resolution:</b></p>
    <p>
      I propose to use the terms "signed integer type" and "unsigned integer
      type" in place of "signed integral type" and "unsigned integral type"
      to eliminate such ambiguities.
    </p>
    
    <p>
      The proposed change makes it absolutely clear that the difference
      between two pointers cannot be <tt>char</tt> or <tt>wchar_t</tt>,
      but could be any of the signed integer types.
      7.6.6 <a href="https://timsong-cpp.github.io/cppwp/expr.add">[expr.add]</a> paragraph 6...
    </p>
    <blockquote>
      <p>
      </p>
        <ol>
          <li>
            When two pointers to elements of the same array object are
            subtracted, the result is the difference of the subscripts of
            the two array elements. The type of the result is an
            implementation-defined <del>signed integral
            type</del><ins>signed integer type</ins>; this type shall be the
            same type that is defined as <code>std::ptrdiff_t</code> in the
            <code>&lt;cstdint&gt;</code> header (18.1)...
          </li>
        </ol>
    </blockquote>

    <p>
      The proposed change makes it clear that <tt>X::size_type</tt> and
      <tt>X::difference_type</tt> cannot be <tt>char</tt> or
      <tt>wchar_t</tt>, but could be one of the signed or unsigned integer
      types as appropriate.
      16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> table 40...
    </p>
    <blockquote><p>
      Table 40: Allocator requirements
	  </p>
      <table border="1">
        <thead>
          <tr>
            <th>expression</th>
            <th>return type</th>
            <th>assertion/note/pre/post-condition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>X::size_type</tt></td>
            <td>
              <del>unsigned integral type</del>
              <ins>unsigned integer type</ins>
            </td>
            <td>a type that can represent the size of the largest object in
            the allocation model.</td>
          </tr>
          <tr>
            <td><tt>X::difference_type</tt></td>
            <td>
              <del>signed integral type</del>
              <ins>signed integer type</ins>
            </td>
            <td>a type that can represent the difference between any two
            pointers in the allocation model.</td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    <p>
      The proposed change makes it clear that <tt>make_signed&lt;T&gt;::type</tt>
      must be one of the signed integer types as defined in 3.9.1. Ditto for
      <tt>make_unsigned&lt;T&gt;type</tt> and unsigned integer types.
      21.3.8.4 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.sign">[meta.trans.sign]</a> table 48...
    </p>
    <blockquote><p>
      Table 48: Sign modifications
	  </p>
      <table border="1">
        <thead>
          <tr>
            <th>Template</th>
            <th>Comments</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <tt>template &lt;class T&gt; struct make_signed;</tt>
            </td>
            <td>
              If <code>T</code> names a (possibly cv-qualified) <del>signed
              integral type</del><ins>signed integer type</ins> (3.9.1) then
              the member typedef <code>type</code> shall name the type
              <code>T</code>; otherwise, if <code>T</code> names a (possibly
              cv-qualified) <del>unsigned integral type</del><ins>unsigned
              integer type</ins> then <code>type</code> shall name the
              corresponding <del>signed integral type</del><ins>signed
              integer type</ins>, with the same cv-qualifiers as
              <code>T</code>; otherwise, <code>type</code> shall name the
              <del>signed integral type</del><ins>signed integer type</ins>
              with the smallest rank (4.13) for which <code>sizeof(T) ==
              sizeof(type)</code>, with the same cv-qualifiers as
              <code>T</code>.

              <i>Requires:</i> <code>T</code> shall be a (possibly
              cv-qualified) integral type or enumeration but not a
              <code>bool</code> type.
            </td>
          </tr>
          <tr>
            <td>
              <tt>template &lt;class T&gt; struct make_unsigned;</tt>
            </td>
            <td>
              If <code>T</code> names a (possibly cv-qualified)
              <del>unsigned integral type</del><ins>unsigned integer
              type</ins> (3.9.1) then the member typedef <code>type</code>
              shall name the type <code>T</code>; otherwise, if
              <code>T</code> names a (possibly cv-qualified) <del>signed
              integral type</del><ins>signed integer type</ins> then
              <code>type</code> shall name the corresponding <del>unsigned
              integral type</del><ins>unsigned integer type</ins>, with the
              same cv-qualifiers as <code>T</code>; otherwise,
              <code>type</code> shall name the <del>unsigned integral
              type</del><ins>unsigned integer type</ins> with the smallest
              rank (4.13) for which <code>sizeof(T) == sizeof(type)</code>,
              with the same cv-qualifiers as <code>T</code>.

              <i>Requires:</i> <code>T</code> shall be a (possibly
              cv-qualified) integral type or enumeration but not a
              <code>bool</code> type.
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>


    <p>
      Note: I believe that the basefield values should probably be
      prefixed with <tt>ios_base::</tt> as they are in 30.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>

      The listed virtuals are all overloaded on signed and unsigned integer
      types, the new wording just maintains consistency.

      30.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> table 78...
    </p>
    <blockquote><p>
      Table 78: Integer Conversions
	  </p>
      <table border="1">
        <thead>
          <tr>
            <th>State</th>
            <th><tt>stdio</tt> equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>basefield == oct</tt></td>
            <td><tt>%o</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == hex</tt></td>
            <td><tt>%X</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == 0</tt></td>
            <td><tt>%i</tt></td>
          </tr>
          <tr>
            <td><del>signed integral type</del><ins>signed integer
            type</ins></td>
            <td><tt>%d</tt></td>
          </tr>
          <tr>
            <td><del>unsigned integral type</del><ins>unsigned integer
            type</ins></td>
            <td><tt>%u</tt></td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    
    
    <p>
      Rationale is same as above.
      30.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> table 80...
    </p>
    <blockquote><p>
      Table 80: Integer Conversions
	  </p>
      <table border="1">
        <thead>
          <tr>
            <th>State</th>
            <th><tt>stdio</tt> equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>basefield == ios_base::oct</tt></td>
            <td><tt>%o</tt></td>
          </tr>
          <tr>
            <td><tt>(basefield == ios_base::hex) &amp;&amp;
            !uppercase</tt></td>
            <td><tt>%x</tt></td>
          </tr>
          <tr>
            <td><tt>(basefield == ios_base::hex)</tt></td>
            <td><tt>%X</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == 0</tt></td>
            <td><tt>%i</tt></td>
          </tr>
          <tr>
            <td>for a <del>signed integral type</del><ins>signed integer
            type</ins></td>
            <td><tt>%d</tt></td>
          </tr>
          <tr>
            <td>for a <del>unsigned integral type</del><ins>unsigned integer
            type</ins></td>
            <td><tt>%u</tt></td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    
    <p>
      24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> table 80...
    </p>
    <blockquote><p>
      Table 89: Container requirements
	  </p>
      <table border="1">
        <thead>
          <tr>
            <th>expression</th>
            <th>return type</th>
            <th>operational semantics</th>
            <th>assertion/note/pre/post-condition</th>
            <th>complexity</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>X::difference_type</tt></td>
            <td><del>signed integral type</del><ins>signed integer type</ins></td>
            <td>&nbsp;</td>
            <td>is identical to the difference type of <tt>X::iterator</tt>
            and <tt>X::const_iterator</tt></td>
            <td>compile time</td>
          </tr>
          <tr>
            <td><tt>X::size_type</tt></td>
            <td><del>unsigned integral type</del><ins>unsigned integer type</ins></td>
            <td>&nbsp;</td>
            <td><tt>size_type</tt> can represent any non-negative value of
            <tt>difference_type</tt></td>
            <td>compile time</td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    <p>
      25.3.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concepts">[iterator.concepts]</a> paragraph 1...
    </p>
    <blockquote><p>
      Iterators are a generalization of pointers that allow a C++ program to
      work with different data structures (containers) in a uniform manner.
      To be able to construct template algorithms that work correctly and
      efficiently on different types of data structures, the library
      formalizes not just the interfaces but also the semantics and
      complexity assumptions of iterators. All input iterators
      <code>i</code> support the expression <code>*i</code>, resulting in a
      value of some class, enumeration, or built-in type <code>T</code>,
      called the <i>value type</i> of the iterator. All output iterators
      support the expression <code>*i = o</code> where <code>o</code> is a
      value of some type that is in the set of types that are
      <i>writable</i> to the particular iterator type of <code>i</code>. All
      iterators <code>i</code> for which the expression <code>(*i).m</code>
      is well-defined, support the expression <code>i->m</code> with the
      same semantics as <code>(*i).m</code>. For every iterator type
      <code>X</code> for which equality is defined, there is a corresponding
      <del>signed integral type</del> <ins>signed integer type</ins> called
      the <i>difference type</i> of the iterator.
    </p></blockquote>
    
    <p>
      I'm a little unsure of this change. Previously this paragraph would
      allow instantiations of <tt>linear_congruential_engine</tt> on
      <tt>char</tt>, <tt>wchar_t</tt>, <tt>bool</tt>, and other types. The
      new wording prohibits this.
      28.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.lcong">[rand.eng.lcong]</a> paragraph 2...
    </p>
    <blockquote><p>
      The template parameter <code>UIntType</code> shall denote an
      <del>unsigned integral type</del><ins>unsigned integer type</ins>
      large enough to store values as large as <code>m - 1</code>. If the
      template parameter <code>m</code> is 0, the modulus <code>m</code>
      used throughout this section 26.4.3.1 is
      <code>numeric_limits&lt;result_type&gt;::max()</code> plus 1.  [Note:
      The result need not be representable as a value of type
      <code>result_type</code>. --end note] Otherwise, the following
      relations shall hold: <code>a &lt; m</code> and <code>c &lt;
      m</code>.
    </p></blockquote>
    
    <p>
      Same rationale as the previous change.
      99 [rand.adapt.xor] paragraph 6...
    </p>
    <blockquote><p>
      Both <code>Engine1::result_type</code> and
      <code>Engine2::result_type</code> shall denote (possibly different)
      <del>unsigned integral types</del><ins>unsigned integer types</ins>.
      The member <i>result_type</i> shall denote either the type
      <i>Engine1::result_type</i> or the type <i>Engine2::result_type</i>,
      whichever provides the most storage according to clause 3.9.1.
    </p></blockquote>
    
    <p>
      28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a> paragraph 7...
    </p>
    <blockquote><p>
      <i>Requires:</i><code>RandomAccessIterator</code> shall meet the
      requirements of a random access iterator (24.1.5) such that
      <code>iterator_traits&lt;RandomAccessIterator&gt;::value_type</code>
      shall denote an <del>unsigned integral type</del><ins>unsigned integer
      type</ins> capable of accomodating 32-bit quantities.  
    </p></blockquote>

    <p>
      By making this change, integral types that happen to have a signed
      representation, but are not signed integer types, would no longer be
      required to use a two's complement representation. This may go against
      the original intent, and should be reviewed.
      33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> paragraph 24...
    </p>
    <blockquote><p>
      <i>Remark:</i> For <del>signed integral types</del><ins>signed integer
      types</ins>, arithmetic is defined using two's complement
      representation. There are no undefined results. For address types, the
      result may be an undefined address, but the operations otherwise have
      no undefined behavior.
    </p></blockquote>
    
  




<hr>
<h3><a name="877" href="877">877.</a> to <tt>throw()</tt> or to <i>Throw:</i> Nothing.</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-08-23 <b>Last modified:</b> 2018-06-23 21:28:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Recent changes to
the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">working
draft</a> have introduced a gratuitous inconsistency with the C++ 2003
version of the specification with respect to exception guarantees
provided by standard functions. While the C++ 2003 standard
consistenly uses the empty exception specification, <tt>throw()</tt>,
to declare functions that are guaranteed not to throw exceptions, the
current working draft contains a number of "<i>Throws:</i> Nothing."
clause to specify essentially the same requirement. The difference
between the two approaches is that the former specifies the behavior
of programs that violate the requirement (<tt>std::unexpected()</tt>
is called) while the latter leaves the behavior undefined.

       </p>
       <p>

A survey of the working draft reveals that there are a total of 209
occurrences of <tt>throw()</tt> in the library portion of the spec,
the majority in clause 18, a couple (literally) in 19, a handful in
20, a bunch in 22, four in 24, one in 27, and about a dozen in D.9.

       </p>
       <p>

There are also 203 occurrences of "<i>Throws:</i> Nothing." scattered
throughout the spec.

       </p>
       <p>

While sometimes there are good reasons to use the "<i>Throws:</i>
Nothing."  approach rather than making use of <tt>throw()</tt>, these
reasons do not apply in most of the cases where this new clause has
been introduced and the empty exception specification would be a
better approach.

       </p>
       <p>

First, functions declared with the empty exception specification
permit compilers to generate better code for calls to such
functions. In some cases, the compiler might even be able to eliminate
whole chunks of user-written code when instantiating a generic
template on a type whose operations invoked from the template
specialization are known not to throw. The prototypical example are
the <tt>std::uninitialized_copy()</tt>
and <tt>std::uninitialized_fill()</tt> algorithms where the
entire <tt>catch(...)</tt> block can be optimized away.

       </p>
       <p>

For example, given the following definition of
the <tt>std::uninitialized_copy</tt> function template and a
user-defined type <tt>SomeType</tt>:

       </p>
       <blockquote>
           <pre>
template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
uninitialized_copy (InputIterator first, InputIterator last, ForwardIterator res)
{
   typedef iterator_traits&lt;ForwardIterator&gt;::value_type ValueType;

   ForwardIterator start = res;

   try {
       for (; first != last; ++first, ++res)
           ::new (&amp;*res) ValueType (*first);
   }
   catch (...) {
       for (; start != res; --start)
           (&amp;*start)->~ValueType ();
       throw;
   }
   return res;
}

struct SomeType {
   SomeType (const SomeType&amp;) <ins>throw ()</ins>;
}</pre>
       </blockquote>
       <p>

compilers are able to emit the following efficient specialization
of <tt>std::uninitialized_copy&lt;const SomeType*, SomeType*&gt;</tt>
(note that the <tt>catch</tt> block has been optimized away):

       </p>
       <blockquote>
           <pre>
template &lt;&gt; SomeType*
uninitialized_copy (const SomeType *first, const SomeType *last, SomeType *res)
{
   for (; first != last; ++first, ++res)
       ::new (res) SomeType (*first);

   return res;
}</pre>
       </blockquote>
       <p>

Another general example is default constructors which, when decorated
with <tt>throw()</tt>, allow the compiler to eliminate the
implicit <tt>try</tt> and <tt>catch</tt> blocks that it otherwise must
emit around each the invocation of the constructor
in <i>new-expressions</i>.

       </p>
       <p>

For example, given the following definitions of
class <tt>MayThrow</tt> and <tt>WontThrow</tt> and the two
statements below:

       </p>
       <blockquote>
           <pre>
struct MayThrow {
   MayThrow ();
};

struct WontThrow {
   WontThrow () <ins>throw ()</ins>;
};

MayThrow  *a = new MayThrow [N];
WontThrow *b = new WontThrow [N];</pre>

       </blockquote>
       <p>

the compiler generates the following code for the first statement:

       </p>
       <blockquote>
           <pre>
MayThrow *a;
{
   MayThrow *first = operator new[] (N * sizeof (*a));
   MayThrow *last  = first + N;
   MayThrow *next  = first;
   try {
       for ( ; next != last; ++next)
           new (next) MayThrow;
   }
   catch (...) {
       for ( ; first != first; --next)
           next->~MayThrow ();
       operator delete[] (first);
       throw;
   }
   a = first;
}</pre>
       </blockquote>
       <p>

but it is can generate much more compact code for the second statement:

       </p>
       <blockquote>
           <pre>
WontThrow *b    = operator new[] (N * sizeof (*b));
WontThrow *last = b + N;
for (WontThrow *next = b; next != last; ++next)
   new (next) WontThrow;
</pre>
       </blockquote>
       <p>

Second, in order for users to get the maximum benefit out of the new
<tt>std::has_nothrow_xxx</tt> traits when using standard library types
it will be important for implementations to decorate all non throwing
copy constructors and assignment operators with <tt>throw()</tt>. Note
that while an optimizer may be able to tell whether a function without
an explicit exception specification can throw or not based on its
definition, it can only do so when it can see the source code of the
definition. When it can't it must assume that the function may
throw. To prevent violating the One Definition Rule,
the <tt>std::has_nothrow_xxx</tt> trait must return the most
pessimistic guess across all translation units in the program, meaning
that <tt>std::has_nothrow_xxx&lt;T&gt;::value</tt> must evaluate to
<tt>false</tt> for any <tt>T</tt> whose <tt>xxx</tt>
(where <tt>xxx</tt> is default or copy ctor, or assignment operator)
is defined out-of-line.

       </p>
       <p>

<b>Counterarguments:</b>

       </p>
       <p>

During the discussion of this issue
on <a href="mailto:lib@lists.isocpp.org">lib@lists.isocpp.org</a>
(starting with post <tt>c++std-lib-21950</tt>) the following arguments
in favor of the "<i>Throws:</i> Nothing." style have been made.

       </p>
         <ol>
           <li>

Decorating functions that cannot throw with the empty exception
specification can cause the compiler to generate suboptimal code for
the implementation of the function when it calls other functions that
aren't known to the compiler not to throw (i.e., that aren't decorated
with <tt>throw()</tt> even if they don't actually throw). This is a
common situation when the called function is a C or POSIX function.

           </li>
           <li>

Alternate, proprietary mechanisms exist (such as
GCC <a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Function-Attributes.html#index-g_t_0040code_007bnothrow_007d-function-attribute-2160"><tt>__attribute__((nothrow))</tt></a>
or Visual
C++ <a href="http://msdn.microsoft.com/en-us/library/49147z04(VS.80).aspx"><tt>__declspec(nothrow)</tt></a>)
that let implementers mark up non-throwing functions, often without
the penalty mentioned in (1) above. The C++ standard shouldn't
preclude the use of these potentially more efficient mechanisms.

           </li>
           <li>

There are functions, especially function templates, that invoke
user-defined functions that may or may not be
declared <tt>throw()</tt>. Declaring such functions with the empty
exception specification will cause compilers to generate suboptimal
code when the user-defined function isn't also declared not to throw.

           </li>
        </ol>
       <p>

The answer to point (1) above is that implementers can (and some have)
declare functions with <tt>throw()</tt> to indicate to the compiler
that calls to the function can safely be assumed not to throw in order
to allow it to generate efficient code at the call site without also
having to define the functions the same way and causing the compiler
to generate suboptimal code for the function definition. That is, the
function is declared with <tt>throw()</tt> in a header but it's
defined without it in the source file. The <tt>throw()</tt>
declaration is suppressed when compiling the definition to avoid
compiler errors. This technique, while strictly speaking no permitted
by the language, is safe and has been employed in practice. For
example, the GNU C library takes this approach. Microsoft Visual C++
takes a similar approach by simply assuming that no function with C
language linkage can throw an exception unless it's explicitly
declared to do so using the language extension <tt>throw(...)</tt>.

       </p>
       <p>

Our answer to point (2) above is that there is no existing practice
where C++ Standard Library implementers have opted to make use of the
proprietary mechanisms to declare functions that don't throw. The
language provides a mechanism specifically designed for this
purpose. Avoiding its use in the specification itself in favor of
proprietary mechanisms defeats the purpose of the feature. In
addition, making use of the empty exception specification
inconsistently, in some areas of the standard, while conspicuously
avoiding it and making use of the "<i>Throws:</i> Nothing." form in
others is confusing to users.

       </p>
       <p>

The answer to point (3) is simply to exercise caution when declaring
functions and especially function templates with the empty exception
specification. Functions that required not to throw but that may call
back into user code are poor candidates for the empty exception
specification and should instead be specified using "<i>Throws:</i>
Nothing." clause.

      </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We need someone to do an extensive review.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>The discussed discrepancy isn't relevant any longer: now we have 
noexcept and have deprecated throw(). Additionally, the guidance on 
narrow vs. wide contracts, Requires clauses, and noexcept/Throws means
that the proposed resolution is more subtle even if updated 
in terms of noexcept().</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Resolve as NAD</p>

   
   <p><b>Proposed resolution:</b></p>
       <p>

We propose two possible solutions. Our recommendation is to adopt
Option 1 below.

       </p>
       <p>

<b>Option 1:</b>

       </p>
       <p>

Except for functions or function templates that make calls back to
user-defined functions that may not be declared <tt>throw()</tt>
replace all occurrences of the "<i>Throws:</i> Nothing." clause with
the empty exception specification. Functions that are required not to
throw but that make calls back to user code should be specified to
"<i>Throw:</i> Nothing."

       </p>
       <p>

<b>Option 2:</b>

       </p>
       <p>

For consistency, replace all occurrences of the empty exception
specification with a "<i>Throws:</i> Nothing." clause.

       </p>
   



<hr>
<h3><a name="879" href="879">879.</a> Atomic load const qualification</h3>
<p><b>Section:</b> 33.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alexander Chemeris <b>Opened:</b> 2008-08-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>atomic_address</tt> type and <tt>atomic&lt;T*&gt;</tt> specialization provide atomic
updates to pointers.  However, the current specification requires
that the types pointer be to non-const objects.  This restriction
is unnecessary and unintended.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
Move to review.  Lawrence will first check with Peter whether the
current examples are sufficient, or whether they need to be expanded to
include all cases.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Lawrence will handle all issues relating to atomics in a single paper.
</p>
<p>
LWG will defer discussion on atomics until that paper appears.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.htm">N2992</a>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add const qualification to the pointer values of the <tt>atomic_address</tt>
and <tt>atomic&lt;T*&gt;</tt> specializations.  E.g.
</p>

<blockquote><pre>
typedef struct atomic_address {
   void store(<ins>const</ins> void*, memory_order = memory_order_seq_cst) volatile;
   void* exchange( <ins>const</ins> void*, memory_order = memory_order_seq_cst) volatile;
   bool compare_exchange( <ins>const</ins> void*&amp;, <ins>const</ins> void*,
                          memory_order, memory_order) volatile;
   bool compare_exchange( <ins>const</ins> void*&amp;, <ins>const</ins> void*,
                          memory_order = memory_order_seq_cst ) volatile;
   void* operator=(<ins>const</ins> void*) volatile;
} atomic_address;

void atomic_store(volatile atomic_address*, <ins>const</ins> void*);
void atomic_store_explicit(volatile atomic_address*, <ins>const</ins> void*,
                          memory_order);
void* atomic_exchange(volatile atomic_address*<ins>, const void*</ins>);
void* atomic_exchange_explicit(volatile atomic_address*, <ins>const</ins> void*,
                              memory_order);
bool atomic_compare_exchange(volatile atomic_address*,
                            <ins>const</ins> void**, <ins>const</ins> void*);
bool atomic_compare_exchange_explicit(volatile atomic_address*,
                                     <ins>const</ins> void**, <ins>const</ins> void*,
                                     memory_order, memory_order);
</pre></blockquote>





<hr>
<h3><a name="887" href="887">887.</a> issue with condition::wait_...</h3>
<p><b>Section:</b> 33.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Posix/C++ working group has identified an inconsistency between
Posix and the C++ working draft in that Posix requires the clock to be
identified at creation, whereas C++ permits identifying the clock at the
call to wait.  The latter cannot be implemented with the former.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Howard recommends NAD with the following explanation:
</p>

<p>
The intent of the current wording is for the <tt>condtion_variable::wait_until</tt>
be able to handle user-defined clocks as well as clocks the system knows about.
This can be done by providing overloads for the known clocks, and another
overload for unknown clocks which synchs to a known clock before waiting.
For example:
</p>

<blockquote><pre>
template &lt;class Duration&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                               const chrono::time_point&lt;chrono::system_clock, Duration&gt;&amp; abs_time)
{
    using namespace chrono;
    nanoseconds d = __round_up&lt;nanoseconds&gt;(abs_time.time_since_epoch());
    __do_timed_wait(lock.mutex()-&gt;native_handle(), time_point&lt;system_clock, nanoseconds&gt;(d));
    return system_clock::now() &lt; abs_time;
}

template &lt;class Clock, class Duration&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                               const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)
{
    using namespace chrono;
    system_clock::time_point    s_entry = system_clock::now();
    typename Clock::time_point  c_entry = Clock::now();
    nanoseconds dn = __round_up&lt;nanoseconds&gt;(abs_time.time_since_epoch() -
                                              c_entry.time_since_epoch());
    __do_timed_wait(lock.mutex()-&gt;native_handle(), s_entry + dn);
    return Clock::now() &lt; abs_time;
}
</pre></blockquote>

<p>
In the above example, <tt>system_clock</tt> is the only clock which the underlying
condition variable knows how to deal with.  One overload just passes that clock
through.  The second overload (approximately) converts the unknown clock into
a <tt>system_clock  time_point</tt> prior to passing it down to the native
condition variable.
</p>

<p>
On Posix systems vendors are free to add implementation defined constructors which
take a clock.  That clock can be stored in the condition_variable, and converted
to (or not as necessary) as shown above.
</p>

<p>
If an implementation defined constructor takes a clock (for example), then part
of the semantics for that implementation defined ctor might include that a
<tt>wait_until</tt> using a clock other than the one constructed with results
in an error (exceptional condition) instead of a conversion to the stored clock.
Such a design is up to the vendor as once an implementation defined ctor is used,
the vendor is free to specifiy the behavior of waits and/or notifies however
he pleases (when the cv is constructed in an implementation defined manner).
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
"POSIX people will review the proposed NAD resolution at their upcoming NY
meeting.
</p>

<p>
See the minutes at: <a href="http://wiki.dinkumware.com/twiki/bin/view/Posix/POSIX-CppBindingWorkingGroupNewYork2009">http://wiki.dinkumware.com/twiki/bin/view/Posix/POSIX-CppBindingWorkingGroupNewYork2009</a>.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Move to NAD.
</p></blockquote>

<p><i>[
2009-07-18 Detlef reopens the issue:
]</i></p>


<blockquote>
<p>
On Friday afternoon in Frankfurt is was decided that 887 is NAD.
This decision was mainly based on a sample implementation presented
by Howard that implemented one clock on top of another.
Unfortunately this implementation doesn't work for the probably most
important case where a system has a monotonic clock and a real-time
clock (or "wall time" clock):
</p>
<p>
If the underlying "system_clock" is a monotonic clock, and
the program waits on the real-time clock, and the real-time clock
is set forward, the wait will unblock too late.
</p>

<p>
If the underlying "system_clock" is a real-time clock, and the
program waits on the monotonic clock, and the real-time clock
is set back, the wait again will unblock too late.
</p>

<p>
Sorry that I didn't remember this on Friday, but it was Friday
afternoon after a busy week...
</p>

<p>
So as the decision was made on a wrong asumption, I propose to re-open
the issue.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard adds:
]</i></p>


<blockquote>
<p>
Detlef correctly argues that <tt>condition_variable::wait_until</tt> could
return "too late" in the context of clocks being adjusted during the wait.  I agree
with his logic.  But I disagree that this makes this interface unimplementable
on POSIX.
</p>

<p>
The POSIX spec also does not guarantee that <tt>pthread_cond_timedwait</tt> does
not return "too late" when clocks are readjusted during the wait.  Indeed, the
POSIX specification lacks any requirements at all concerning how soon
<tt>pthread_cond_timedwait</tt> returns after a time out.  This is evidently a
QOI issue by the POSIX standard.  Here is a quote of the most relevant normative
text concerning <tt>pthread_cond_timedwait</tt> found
<a href="http://www.unix.org/single_unix_specification/">here</a>.
</p>

<blockquote><p>
The <tt>pthread_cond_timedwait()</tt> function shall be equivalent to
<tt>pthread_cond_wait()</tt>, except that an error is returned if the absolute
time specified by <tt>abstime</tt> passes (that is, system time equals or exceeds
<tt>abstime</tt>) before the condition <tt>cond</tt> is signaled or broadcasted, or if the
absolute time specified by <tt>abstime</tt> has already been passed at the time
of the call.
</p></blockquote>

<p>
I.e. the POSIX specification speaks of the error code returned in case of a time
out, but not on the timeliness of that return.
</p>

<p>
Might this simply be an oversight, or minor defect in the POSIX specification?
</p>

<p>
I do not believe so.  This same section goes on to say in <em>non-normative</em>
text:
</p>

<blockquote><p>
For cases when the system clock is advanced discontinuously by an
operator, it is expected that implementations process any timed wait
expiring at an intervening time as if that time had actually occurred.
</p></blockquote>

<p>
Here is non-normative wording encouraging the implementation to ignore an advancing
underlying clock and subsequently causing an early (spurious) return.  There is
no wording at all which addresses Detlef's example of a "late return".  With
<tt>pthread_cond_timedwait</tt> this would be caused by setting the system clock
backwards.  It seems reasonable to assume, based on the wording that is already
in the POSIX spec, that again, the discontinuously changed clock would be ignored
by <tt>pthread_cond_timedwait</tt>. 
</p>

<p>
A noteworthy difference between <tt>pthread_cond_timedwait</tt> and
<tt>condition_variable::wait_until</tt> is that the POSIX spec appears to
say that <tt>ETIMEDOUT</tt> should be returned if <tt>pthread_cond_timedwait</tt>
returns because of timeout signal, whether or not the system clock was discontinuously
advanced during the wait.  In contrast <tt>condition_variable::wait_until</tt>
always returns:
</p>

<blockquote><pre>
<tt>Clock::now() &lt; abs_time</tt>
</pre></blockquote>

<p>
That is, the C++ spec requires that the clock be rechecked (detecting discontinuous
adjustments during the wait) at the time of return.  <tt>condition_variable::wait_until</tt>
may indeed return early or late.  But regardless it will return a value
reflecting timeout status at the time of return (even if clocks have been adjusted).
Of course the clock may be adjusted after the return value is computed but before the client has
a chance to read the result of the return.  Thus there are no iron-clad guarantees
here.
</p>

<p>
<tt>condition_variable::wait_until</tt> (and <tt>pthread_cond_timedwait</tt>)
is little more than a convenience function for making sure
<tt>condition_variable::wait</tt> doesn't hang for an unreasonable amount of
time (where the client gets to define "unreasonable").  I do not think it
is in anyone's interest to try to make it into anything more than that.
</p>

<p>
I maintain that this is a useful and flexible specification in the spirit of
C++, and is implementable on POSIX.  The implementation technique described above
is a reasonable approach.  There may also be higher quality approaches.  This
specification, like the POSIX specification, gives a wide latitude for QOI.
</p>

<p>
I continue to recommend NAD, but would not object to a clarifying note regarding
the behavior of <tt>condition_variable::wait_until</tt>.  At the moment, I do
not have good wording for such a note, but welcome suggestions.
</p>

</blockquote>

<p><i>[
2009-09-30: See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2969.html">N2969</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
The LWG is in favor of Detlef to supply revision which adopts Option 2 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2969.html">N2969</a>
but is modified by saying that <tt>system_clock</tt> must be available for <tt>wait_until</tt>.
</p></blockquote>

<p><i>[
2010-02-11 Anthony provided wording.
]</i></p>


<p><i>[
2010-02-22 Anthony adds:
]</i></p>


<blockquote>
<p>
I am strongly against
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2999.html">N2999</a>.
</p>

<p>
Firstly, I think that the most appropriate use of a timed wait on a condition
variable is with a monotonic clock, so it ought to be guaranteed to be available
on systems that support such a clock. Also, making the set of supported clocks
implementation defined essentially kills portability around the use of
user-defined clocks.
</p>

<p>
I also think that <tt>wait_for</tt> is potentially useful, and trivially
implementable given a working templated <tt>wait_until</tt> and a monotonic
clock.
</p>

<p>
I also disagree with many of Detlef's points in the rationale. In a system with
hard latency limits there is likely to be a monotonic clock, otherwise you have
no way of measuring against these latency limits since the <tt>system_clock</tt>
may change arbitrarily. In such systems, you <em>want</em> to be able to use
<tt>wait_for</tt>, or <tt>wait_until</tt> with a monotonic clock.
</p>

<p>
I disagree that the <tt>wait_*</tt> functions cannot be implemented correctly on
top of POSIX: I have done so. The only guarantee in the working draft is that
when the function returns certain properties are true; there is no guarantee
that the function will return <em>immediately</em> that the properties are true.
My resolution to issue 887 makes this clear. How small the latency is is QoI.
</p>

<p>
On systems without a monotonic clock, you cannot measure the problem since the
system clock can change arbitrarily so any timing calculations you make may be
wrong due to clock changes.
</p>

<p>
On systems with a monotonic clock, you can choose to use it for your condition
variables. If you are waiting against a <tt>system_clock::time_point</tt> then
you can check the clock when waking, and either return as a timeout or spurious
wake depending on whether <tt>system_clock::now()</tt> is before or after the
specified <tt>time_point</tt>.
</p>

<p>
Windows <em>does</em> provide condition variables from Vista onwards. I choose
not to use them, but they are there. If people are concerned about
implementation difficulty, the Boost implementation can be used for most
purposes; the Boost license is pretty liberal in that regard.
</p>

<p>
My preferred resolution to issue 887 is currently the PR in the issues list.
</p>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
There is no consensus for moving the related paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2999.html">N2999</a>
into the WP.
</p>
<p>
There was support for moving this issue as proposed to Ready, but the support
was insufficient to call a consensus.
</p>
<p>
There was consensus for moving this issue to NAD as opposed to leaving it open.
Rationale added.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
The standard as written is sufficiently implementable and self consistent.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph after 33.2.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.timing">[thread.req.timing]</a>p3:
</p>

<blockquote>
<p>
3 The resolution of timing provided by an implementation depends on both
operating system and hardware. The finest resolution provided by an
implementation is called the <i>native resolution</i>.
</p>

<p><ins>
If a function in this clause takes a timeout argument, and the time point or
elapsed time specified passes before the function returns, the latency between
the timeout occurring and the function returning is unspecified [<i>Note:</i>
Implementations should strive to keep such latency as small as possible, but
portable code should not rely on any specific upper limits &mdash; <i>end
note</i>]
</ins></p>
</blockquote>





<hr>
<h3><a name="892" href="892">892.</a> Forward_list issues...</h3>
<p><b>Section:</b> 99 [forwardlist.ops] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Ed Smith-Rowland <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I was looking at the latest draft on <tt>forward_list</tt>.  Especially the splice methods.
</p>
<p>
The first one splices a whole list after a given iterator in <tt>this</tt>.  The name is <tt>splice_after</tt>.
I think in 99 [forwardlist.ops] paragraph 40
change:
</p>
<blockquote><p>
<i>Effect:</i> Insert the contents of <tt>x</tt> <del>before</del> <ins>after</ins> <tt>position</tt>, ...
</p></blockquote>

<p>
A deeper issue involves the complexity.  <tt>forward_list</tt> has no <tt>size</tt> and we
don't know when we've reached the end except to walk up to it.  To
splice we would need to hook the end of the source list to the item
after <tt>position</tt> in this list.  This would involve walking length of the
source list until we got to the last dereference-able element in source.
There's no way we could do this in O(1) unless we stored a bogus end in
<tt>forward_list</tt>.
</p>
<p>
OTOH, the last version of <tt>splice_after</tt> with iterator ranges we could do
in O(1) because we know how to hook the end of the source range to ...
</p>
<p>
Unless I'm misconceiving the whole thing.  Which is possible.  I'll look at it again.
</p>
<p>
I'm pretty sure about the first part though.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This issue is more complicated than it looks.
</p>
<p>
paragraph 47: replace each <tt>(first, last) with (first, last]</tt>
</p>
<p>
add a statement after paragraph 48 that complexity is O(1)
</p>
<p>
remove the complexity statement from the first overload of splice_after
</p>
<p>
We may have the same problems with other modifiers, like erase_after.
Should it require that all iterators in the range (position, last] be
dereferenceable?
</p>
<p>
We do, however, like the proposed changes and consider them Editorial.
Move to NAD Editorial, Pending. Howard to open a new issue to handle the
problems with the complexity requirements.
</p>
<p>
Opened <a href="897">897</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 99 [forwardlist.ops] paragraph 40
change:
</p>
<blockquote><p>
<i>Effect:</i> Insert the contents of <tt>x</tt> <del>before</del> <ins>after</ins> <tt>position</tt>, ...
</p></blockquote>





<hr>
<h3><a name="895" href="895">895.</a> "Requires:" on std::string::at et al</h3>
<p><b>Section:</b> 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> James Dennett <b>Opened:</b> 2008-09-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="625">625</a></p>
<p><b>Discussion:</b></p>
<p>
Per discussion, we need an issue open to cover looking at "Requires"
clauses which are not constraints on user code, such as that on
<tt>std::basic_string::at</tt>.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
 Alan to address in paper.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="901" href="901">901.</a> insert iterators can move from lvalues</h3>
<p><b>Section:</b> 25.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/insert.iterator">[insert.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 282</b></p>

<p>
The requires clause on the <tt>const T &amp;</tt> overloads in
<tt>back_insert_iterator/front_insert_iterator/insert_iterator</tt> mean that the
assignment operator will implicitly move from lvalues of a move-only type.
</p>
<p>
Suggested resolutions are:
</p>
<ol style="list-style-type:lower-alpha">
<li>
Add another overload with a negative constraint on copy-constructible
and flag it "= delete".
</li>
<li>
Drop the copy-constructible overload entirely and rely on perfect
forwarding to catch move issues one level deeper.
</li>
<li>
This is a fundamental problem in move-syntax that relies on the
presence of two overloads, and we need to look more deeply into this
area as a whole - do not solve this issue in isolation.
</li>
</ol>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
Both comment and issue have been resolved by the adoption of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
(rvalue references safety fix) at the last meeting.
</p>

<p>
Suggest resolve as NAD Editorial with a reference to the paper.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree that this has been resolved in the latest Working Draft.
Move to NAD.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD, addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>.
</p>





<hr>
<h3><a name="902" href="902">902.</a> Regular is the wrong concept to constrain numeric_limits</h3>
<p><b>Section:</b> 17.3.5 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-24 <b>Last modified:</b> 2017-06-15 20:52:51 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.limits">active issues</a> in [numeric.limits].</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits">issues</a> in [numeric.limits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 32 and DE 16</b></p>

<p>
<tt>numeric_limits</tt> has functions specifically designed to return NaNs, which
break the model of <tt>Regular</tt> (via its axioms.)  While floating point types
will be acceptible in many algorithms taking <tt>Regular</tt> values, it is not
appopriate for this specific API and we need a less refined constraint.
</p>

<p>FR 32:</p>

<blockquote><p>
The definition of <tt>numeric_limits&lt;&gt;</tt> as requiring a regular
type is both conceptually wrong and operationally illogical. As we
pointed before, this mistake needs to be corrected. For example, the
template can be left unconstrained. In fact this reflects a much more
general problem with concept_maps/axioms and their interpretations. It
appears that the current text heavily leans toward experimental academic
type theory.
</p></blockquote>

<p>DE 16:</p>

<blockquote><p>
The class template <tt>numeric_limits</tt> should not specify the Regular concept
requirement for its template parameter, because it contains functions
returning NaN values for floating-point types; these values violate the
semantics of EqualityComparable.
</p></blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Move to Open.  Alisdair and Gaby will work on a solution, along with the new
treatment of axioms in clause 14.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="903" href="903">903.</a> <tt>back_insert_iterator</tt> issue</h3>
<p><b>Section:</b> 25.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/back.insert.iterator">[back.insert.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2008-09-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#back.insert.iterator">issues</a> in [back.insert.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just noticed this; don't know how far the problem(?) extends or
whether it's new or existing: <tt>back_insert_iterator</tt>'s <tt>operator*</tt> is not
<tt>const</tt>, so you can't dereference a <tt>const</tt> one.
</p>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<p>
If done, this change should be applied for <tt>front_insert_iterator</tt>,
<tt>insert_iterator</tt>, <tt>ostream_iterator</tt>, and <tt>ostreambuf_iterator</tt> as well.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that these all are output iterators.
Howard points out that <tt>++*i</tt>
would no longer work if we made this change.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-05-25 Daniel adds:
]</i></p>


<ol>
<li>
If <a href="1009">1009</a> is accepted, <tt>OutputIterator</tt> does no longer support post increment.
</li>
<li>
To support backward compatibility a second overload of <tt>operator*</tt>
can be added.
Note that the <tt>HasDereference</tt> concept (and the <tt>HasDereference</tt> part of concept
<tt>Iterator</tt>) was specifically refactored to cope with optional const
qualification and
to properly reflect the dual nature of built-in <tt>operator*</tt> as of
12.6 <a href="https://timsong-cpp.github.io/cppwp/over.literal">[over.literal]</a>/6.
</li>
</ol>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="905" href="905">905.</a> Mutex specification questions</h3>
<p><b>Section:</b> 33.6.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-09-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="893">893</a></p>
<p><b>Discussion:</b></p>
<p>
A few questions on the current WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>:
</p>
<p>
33.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>/24 says an expression
<tt>mut.unlock()</tt> "Throws: Nothing." I'm assuming that, per 99 [res.on.required], errors that violate the precondition "The
calling thread shall own the mutex" opens the door for throwing an
exception anyway, such as to report unbalanced unlock operations and
unlocking from a thread that does not have ownership. Right?
</p>
<p>
33.6.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a>/3 (actually numbered paragraph "27"
in the WP; this is just a typo I think) says
</p>
<blockquote>
<p>
The behavior of a program is undefined if:
</p>
<ul>
<li>it destroys a <tt>mutex</tt> object owned by any thread,</li>
<li>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or</li>
<li>a thread terminates while owning a <tt>mutex</tt> object.</li>
</ul>
</blockquote>

<p>
As already discussed, I think the second bullet should be removed, and
such a <tt>lock()</tt> or <tt>try_lock()</tt> should fail with an
exception or returning <tt>false</tt>, respectively.
</p>
<p>
A potential addition to the list would be
</p>
<ul>
<li>a thread unlocks a <tt>mutex</tt> it does not have ownership of.</li>
</ul>
<p>
but without that the status quo text endorses the technique of the
program logically transferring ownership of a mutex to another thread
with correctness enforced by programming discipline. Was that intended?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Two resolutions: "not a defect" and "duplicate", as follows:
</p>
<ul>
<li>
33.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>/24: NAD. If the precondition
fails the program has undefined behaviour and therefore an
implementation may throw an exception already.
</li>
<li>
33.6.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a>/3 bullet 2: Already addressed by issue <a href="893">893</a>.
</li>
<li>
33.6.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a>/3 proposed addition: NAD. This is
already covered by the mutex requirements, which have ownership as a
Precondition.
</li>
</ul>
</blockquote>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="906" href="906">906.</a> <tt>ObjectType</tt> is the wrong concept to constrain <tt>initializer_list</tt></h3>
<p><b>Section:</b> 17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-09-26 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The currently proposed constraint on <tt>initializer_list</tt>'s element type
<tt>E</tt> is that is has to meet <tt>ObjectType</tt>. This is an underspecification,
because both core language and library part of <tt>initializer_list</tt>
make clear, that it references an implicitly allocated array:
</p>
<p>
9.4.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>/4:
</p>
<blockquote><p>
When an initializer list is implicitly converted to a
<tt>std::initializer_list&lt;E&gt;</tt>, the object passed is constructed as if the
implementation allocated an array of N elements of type <tt>E</tt>, where
N is the number of elements in the initializer list.[..]
</p></blockquote>

<p>
17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>/2.
</p>

<blockquote><p>
An object of type <tt>initializer_list&lt;E&gt;</tt> provides access to an array of
objects of type <tt>const E</tt>.[..]
</p></blockquote>

<p>
Therefore, <tt>E</tt> needs to fulfill concept <tt>ValueType</tt> (thus excluding
abstract class types). This stricter requirement should be added
to prevent deep instantiation errors known from the bad old times,
as shown in the following example:
</p>

<blockquote><pre>
// Header A: (Should concept-check even in stand-alone modus)

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void generate_and_do_3(T a) {
  std::initializer_list&lt;T&gt; list{T(), std::move(a), T()};
  ...
}

void do_more();
void do_more_or_less();

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void more_generate_3() {
  do_more();
  generate_and_do_3(T());
}

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void something_and_generate_3() {
  do_more_or_less();
  more_generate_3();
}

// Test.cpp

#include "A.h"

class Abstract {
public:
  virtual ~Abstract();
  virtual void foo() = 0; // abstract type
  Abstract(Abstract&amp;&amp;){} // MoveConstructible
  Abstract(){} // DefaultConstructible
};

int main() {
  // The restricted template *accepts* the argument, but
  // causes a deep instantiation error in the internal function
  // generate_and_do_3:
  something_and_generate_3&lt;Abstract&gt;();
}
</pre></blockquote>

<p>
The proposed stricter constraint does not minimize the aim to
support more general containers for which <tt>ObjectType</tt> would be
sufficient. If such an extended container (lets assume it's still a
class template) provides a constructor that accepts an <tt>initializer_list</tt>
only <em>this</em> constructor would need to be restricted on <tt>ValueType</tt>:
</p>

<blockquote><pre>
template&lt;ObjectType T&gt;
class ExtContainer {
public:
  requires ValueType&lt;T&gt;
  ExtContainer(std::initializer_list&lt;T&gt;);
  ...
};
</pre></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Tentatively Ready.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Need to look at again without concepts.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
In 17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>/p.1 replace in "header <tt>&lt;initializer_list&gt;</tt> synopsis"
the constraint "<tt>ObjectType</tt>" in the template parameter list by the
constraint "<tt>ValueType</tt>".
</li>
</ol>






<hr>
<h3><a name="910" href="910">910.</a> Effects of MoveAssignable</h3>
<p><b>Section:</b> 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-09-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 150</b></p>

<p>
The description of the effect of <tt>operator=</tt> in the <tt>MoveAssignable</tt>
concept, given in paragraph 7 is:
</p>

<blockquote><pre>
result_type  T::operator=(T&amp;&amp;  rv);  // inherited from HasAssign&lt;T, T&amp;&amp;&gt;
</pre>

<blockquote><p>
<i>Postconditions:</i> the constructed <tt>T</tt> object is equivalent to the value of
<tt>rv</tt> before the assignment. [<i>Note:</i> there is no
requirement on the value of <tt>rv</tt> after the assignment.  <i>--end note</i>]
</p></blockquote>
</blockquote>

<p>
The sentence contains a typo (what is the "constructed <tt>T</tt> object"?)
probably due to a cut&amp;paste from <tt>MoveConstructible</tt>. Moreover, the
discussion of LWG issue <a href="675">675</a> shows that the postcondition is too generic
and might not reflect the user expectations. An implementation of the
move assignment that just calls <tt>swap()</tt> would always fulfill the
postcondition as stated, but might have surprising side-effects in case
the source rvalue refers to an object that is not going to be
immediately destroyed. See LWG issue <a href="900">900</a> for another example. Due to
the sometimes intangible nature of the "user expectation", it seems
difficult to have precise normative wording that could cover all cases
without introducing unnecessary restrictions. However a non-normative
clarification could be a very helpful warning sign that swapping is not
always the correct thing to do.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Issue 910 is exactly the reason BSI advanced the Editorial comment UK-150.
</p>
<p>
The post-conditions after assignment are at a minimum that the object
referenced by rv must be safely destructible, and the transaction should not
leak resources.  Ideally it should be possible to simply assign rv a new
valid state after the call without invoking undefined behaviour, but any
other use of the referenced object would depend upon additional guarantees
made by that type.
</p>
</blockquote>

<p><i>[
2009-05-09 Howard adds:
]</i></p>


<blockquote>
<p>
The intent of the rvalue reference work is that the moved from <tt>rv</tt> is
a valid object.  Not one in a singular state.  If, for example, the moved from
object is a <tt>vector</tt>, one should be able to do anything on that moved-from
<tt>vector</tt> that you can do with any other <tt>vector</tt>.  However you would
first have to query it to find out what its current state is.  E.g. it might have <tt>capacity</tt>,
it might not.  It might have a non-zero <tt>size</tt>, it might not.  But regardless,
you can <tt>push_back</tt> on to it if you want.
</p>

<p>
That being said, most standard code is now conceptized.  That is, the concepts
list the only operations that can be done with templated types - whether or not
the values have been moved from.
</p>

<p>
Here is user-written code which must be allowed to be legal:
</p>
<blockquote><pre>
#include &lt;vector&gt;
#include &lt;cstdio&gt;

template &lt;class Allocator&gt;
void
inspect(std::vector&lt;double, Allocator&gt;&amp;&amp; v)
{
    std::vector&lt;double, Allocator&gt; result(move(v));
    std::printf("moved from vector has %u size and %u capacity\n", v.size(), v.capacity());
    std::printf("The contents of the vector are:\n");
    typedef typename std::vector&lt;double, Allocator&gt;::iterator I;
    for (I i = v.begin(), e = v.end(); i != e; ++i)
        printf("%f\n", *i);
}

int main()
{
    std::vector&lt;double&gt; v1(100, 5.5);
    inspect(move(v1));
}
</pre></blockquote>

<p>
The above program does not treat the moved-from <tt>vector</tt> as singular.  It
only treats it as a <tt>vector</tt> with an unknown value.
</p>
<p>
I believe the current proposed wording is consistent with my view on this.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree that the proposed resolution
is an improvement over the current wording.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Need to look at again without concepts.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Walter will consult with Dave and Doug.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
We believe this is handled by the resolution to issue <a href="1204">1204</a>,
but there is to much going on in this area to be sure.  Defer for now.
</p></blockquote>

<p><i>[
2010-01-23 Moved to Tentatively NAD Concepts after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
The current <tt>MoveAssignable</tt> requirements say everything that can be said
in general.  Each std-defined type has a more detailed specification of move
assignment.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In  [concept.copymove], replace the postcondition in paragraph 7 with:
</p>

<blockquote><p>
<i>Postconditions:</i> <tt>*this</tt> is equivalent to the value of <tt>rv</tt> before the
assignment. [<i>Note:</i> there is no requirement on the value of <tt>rv</tt> after the
assignment, but the
effect should be unsurprising to the user even in case <tt>rv</tt> is not
immediately destroyed. This may require that resources previously owned
by <tt>*this</tt> are released instead of transferred to <tt>rv</tt>. <i>-- end note</i>]
</p></blockquote>





<hr>
<h3><a name="912" href="912">912.</a> Array swap needs to be conceptualized</h3>
<p><b>Section:</b> 27.7.3 <a href="https://timsong-cpp.github.io/cppwp/alg.swap">[alg.swap]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-10-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.swap">issues</a> in [alg.swap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the adaption of <a href="809">809</a>
we have a new algorithm <tt>swap</tt> for C-arrays, which needs to be conceptualized.
</p>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote><p>
Recommend as NAD Editorial: The changes have already been applied to the WP
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to NAD; the changes have already been made.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Replace in 27.7.3 <a href="https://timsong-cpp.github.io/cppwp/alg.swap">[alg.swap]</a> before p. 3 until p. 4 by
</p>

<blockquote><pre>
template &lt;<del>class</del> <ins>ValueType</ins> T, size_t N&gt;
<ins>requires Swappable&lt;T&gt;</ins>
void swap(T (&amp;a)[N], T (&amp;b)[N]);
</pre>
<blockquote>
<p>
<del><i>Requires:</i> <tt>T</tt> shall be <tt>Swappable</tt>.</del>
</p>
<p>
<i>Effects:</i> <tt>swap_ranges(a, a + N, b);</tt>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="913" href="913">913.</a> Superfluous requirements for replace algorithms</h3>
<p><b>Section:</b> 27.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-10-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(A) 27.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a>/1:
</p>

<blockquote><p>
<i>Requires:</i> The expression <tt>*first = new_value</tt> shall be valid.
</p></blockquote>

<p>
(B) 27.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a>/4:
</p>

<blockquote><p>
<i>Requires:</i> The results of the expressions <tt>*first</tt> and <tt>new_value</tt> shall
be writable to the result output iterator.[..]
</p></blockquote>

<p>
Since conceptualization, the quoted content of these clauses is covered
by the existing requirements
</p>

<p>
(A) <tt>OutputIterator&lt;Iter, const T&amp;&gt;</tt>
</p>

<p>
and
</p>

<p>
(B) <tt>OutputIterator&lt;OutIter, InIter::reference&gt; &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt;</tt>
</p>

<p>
resp, and thus should be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol style="list-style-type:upper-alpha">
<li>
<p>
Remove 27.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a>/1.
</p>
<blockquote><pre>
template&lt;ForwardIterator Iter, class T&gt; 
  requires OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp; OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;Iter::value_type, T&gt; 
  void replace(Iter first, Iter last, 
               const T&amp; old_value, const T&amp; new_value); 

template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred, class T&gt; 
  requires OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp; OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  void replace_if(Iter first, Iter last, 
                  Pred pred, const T&amp; new_value);
</pre>
<blockquote><p>
<del>1 <i>Requires:</i> The expression <tt>*first = new_value</tt> shall be valid.</del>
</p></blockquote>
</blockquote>
</li>
<li>
<p>
27.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a>/4: Remove the sentence "The results of the
expressions <tt>*first</tt> and
<tt>new_value</tt> shall be writable to the result output iterator.".
</p>
<blockquote><pre>
template&lt;InputIterator InIter, typename OutIter, class T&gt; 
  requires OutputIterator&lt;OutIter, InIter::reference&gt; 
        &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;InIter::value_type, T&gt; 
  OutIter replace_copy(InIter first, InIter last, 
                       OutIter result, 
                       const T&amp; old_value, const T&amp; new_value);

template&lt;InputIterator InIter, typename OutIter,
         Predicate&lt;auto, InIter::value_type&gt; Pred, class T&gt; 
  requires OutputIterator&lt;OutIter, InIter::reference&gt; 
        &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  OutIter replace_copy_if(InIter first, InIter last, 
                          OutIter result, 
                          Pred pred, const T&amp; new_value);
</pre>
<blockquote><p>
4 <i>Requires:</i> <del>The results of the expressions <tt>*first</tt> and
<tt>new_value</tt> shall be writable to the <tt>result</tt> output
iterator.</del> The ranges <tt>[first,last)</tt> and <tt>[result,result +
(last - first))</tt> shall not overlap.
</p></blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="914" href="914">914.</a> Superfluous requirement for unique</h3>
<p><b>Section:</b> 27.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-10-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a>/2: "Requires: The comparison function shall be an
equivalence relation."
</p>

<p>
The essence of this is already covered by the given requirement
</p>

<blockquote><pre>
EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred
</pre></blockquote>

<p>
and should thus be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove 27.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a>/2
</p>

<blockquote><pre>
template&lt;ForwardIterator Iter&gt;
  requires OutputIterator&lt;Iter, Iter::reference&gt;
        &amp;&amp; EqualityComparable&lt;Iter::value_type&gt;
  Iter unique(Iter first, Iter last);

template&lt;ForwardIterator Iter, EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred&gt;
  requires OutputIterator&lt;Iter, RvalueOf&lt;Iter::reference&gt;::type&gt;
        &amp;&amp; CopyConstructible&lt;Pred&gt;
  Iter unique(Iter first, Iter last,
               Pred pred);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> ...
</p>
<p>
<del>2 <i>Requires:</i> The comparison function shall be an equivalence relation.</del>
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="915" href="915">915.</a> <tt>minmax</tt> with <tt>initializer_list</tt> should return
<tt>pair</tt> of <tt>T</tt>, not <tt>pair</tt> of <tt>const T&amp;</tt></h3>
<p><b>Section:</b> 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-10-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the proposed changes for
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>
were not clear enough in
this point:
</p>

<blockquote><p>
27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a>, before p.23 + p.24 + before p. 27 + p. 28 say that the return
type of the <tt>minmax</tt> overloads with an <tt>initializer_list</tt> is
<tt>pair&lt;const T&amp;, const T&amp;&gt;</tt>,
which is inconsistent with the decision for the other <tt>min/max</tt> overloads which take
a <tt>initializer_list</tt> as argument and return a <tt>T</tt>, not a <tt>const T&amp;</tt>.
Doing otherwise for <tt>minmax</tt> would easily lead to unexpected life-time
problems by using <tt>minmax</tt> instead of <tt>min</tt> and <tt>max</tt> separately.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</p></blockquote>

<p><i>[
2009-08-18 Daniel adds:
]</i></p>


<blockquote><p>
Recommend NAD since the proposed changes have already been performed
as part of editorial work of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Can't find <tt>initializer_list</tt> form of <tt>minmax</tt> anymore, only variadic
version. Seems like we had an editing clash with concepts. Leave Open,
at least until editorial issues resolved. Bring this to Editor's attention.
</p></blockquote>

<p><i>[
2010 Pittsburgh:  Pete to reapply
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>.
]</i></p>




<p><b>Rationale:</b></p><p>
Solved by reapplying
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>.
</p>

<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>/2, header <tt>&lt;algorithm&gt;</tt> synopsis change as indicated:
</p>

<blockquote><pre>
template&lt;<del>class</del><ins>LessThanComparable</ins> T&gt;
<ins>requires CopyConstructible&lt;T&gt;</ins>
pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
minmax(initializer_list&lt;T&gt; t);

template&lt;class T, <del>class</del><ins>StrictWeakOrder&lt;auto, T&gt;</ins> Compare&gt;
<ins>requires CopyConstructible&lt;T&gt;</ins>
pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre></blockquote>
</li>
<li>
<p>
In 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> change as indicated (Begin: Just before p.20):
</p>
<blockquote><pre>
template&lt;<del>class</del><ins>LessThanComparable</ins> T&gt;
  <ins>requires CopyConstructible&lt;T&gt;</ins>
  pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
  minmax(initializer_list&lt;T&gt; t);
</pre>
<blockquote>
<p>
<del>-20- <i>Requires:</i> <tt>T</tt> is <tt>LessThanComparable</tt> and
<tt>CopyConstructible</tt>.</del>
</p>
<p>
-21- <i>Returns:</i> <tt>pair&lt;<del>const </del>T<del>&amp;</del>, <del>const
</del>T<del>&amp;</del>&gt;(x, y)</tt> where <tt>x</tt> is the
smallest value and <tt>y</tt> the largest value in the <tt>initializer_list</tt>.
</p>
</blockquote>

<p>[..]</p>
<pre>
template&lt;class T, <del>class</del><ins>StrictWeakOrder&lt;auto, T&gt;</ins> Compare&gt;
  <ins>requires CopyConstructible&lt;T&gt;</ins>
  pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
  minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre>

<blockquote>
<p>
<del>-24- <i>Requires:</i> type <tt>T</tt> is <tt>LessThanComparable</tt> and <tt>CopyConstructible</tt>.</del>
</p>
<p>
-25- <i>Returns:</i> <tt>pair&lt;<del>const </del>T<del>&amp;</del>, <del>const
</del>T<del>&amp;</del>&gt;(x, y)</tt> where <tt>x</tt> is the
smallest value and <tt>y</tt> largest value in the <tt>initializer_list</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="916" href="916">916.</a> Redundant move-assignment operator of <tt>pair</tt> should be removed</h3>
<p><b>Section:</b> 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-10-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>see also <a href="917">917</a>.</b></p>

<p>
The current WP provides the following assignment operators for <tt>pair</tt>
in 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a>/1:
</p>

<ol>
<li>
<pre>
template&lt;class U , class V&gt;
requires HasAssign&lt;T1, const U&amp;&gt; &amp;&amp; HasAssign&lt;T2, const V&amp;&gt;
pair&amp; operator=(const pair&lt;U , V&gt;&amp; p);
</pre>
</li>
<li>
<pre>
requires MoveAssignable&lt;T1&gt; &amp;&amp; MoveAssignable&lt;T2&gt; pair&amp; operator=(pair&amp;&amp; p );
</pre>
</li>
<li>
<pre>
template&lt;class U , class V&gt;
requires HasAssign&lt;T1, RvalueOf&lt;U&gt;::type&gt; &amp;&amp; HasAssign&lt;T2, RvalueOf&lt;V&gt;::type&gt;
pair&amp; operator=(pair&lt;U , V&gt;&amp;&amp; p);
</pre>
</li>
</ol>

<p>
It seems that the functionality of (2) is completely covered by (3), therefore
(2) should be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes the extra assignment operators are necessary for resolving
ambiguities, but that does not mean it needs to be part of the specification.
</p>
<p>
Move to Open.
We recommend this be looked at in the context of the ongoing work
related to the pair templates.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Leave this open pending the removal of concepts from the WD.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD, see issue <a href="801">801</a>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<ol style="list-style-type:upper-alpha">
<li>
<p>
In 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> p. 1, class <tt>pair</tt> and just before p. 13 remove the declaration:
</p>

<blockquote><pre>
requires MoveAssignable&lt;T1&gt; &amp;&amp; MoveAssignable&lt;T2&gt; pair&amp; operator=(pair&amp;&amp; p );
</pre></blockquote>
</li>

<li>
Remove p.13+p.14
</li>

</ol>





<hr>
<h3><a name="917" href="917">917.</a> Redundant move-assignment operator of <tt>tuple</tt> should be removed</h3>
<p><b>Section:</b> 22.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-10-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>see also <a href="916">916</a>.</b></p>
<p>
N2770 (and thus now the WP) removed the
non-template move-assignment operator from tuple's class definition,
but the latter individual member description does still provide this
operator. Is this (a) an oversight and can it (b) be solved as part of an
editorial process?
</p>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We believe that the proposed resolution's part 1 is editorial.
</p>
<p>
Regarding part 2, we either remove the specification as proposed,
or else add back the declaration to which the specification refers.
Alisdair and Bill prefer the latter.
It is not immediately obvious whether the function is intended to be present.
</p>
<p>
We recommend that the Project Editor restore the missing declaration
and that we keep part 2 of the issue alive.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Leave this open pending the removal of concepts from the WD.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD, see issue <a href="801">801</a>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, class <tt>tuple</tt> just before member <tt>swap</tt> please
change as indicated:
</p>
<p><i>[
This fixes an editorial loss between N2798 to N2800
]</i></p>

<blockquote><pre>
template &lt;class... UTypes&gt;
requires HasAssign&lt;Types, const UTypes&amp;&gt;...
<ins>tuple&amp; operator=(const pair&lt;UTypes...&gt;&amp;);</ins>

template &lt;class... UTypes&gt;
requires HasAssign&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
<ins>tuple&amp; operator=(pair&lt;UTypes...&gt;&amp;&amp;);</ins>
</pre></blockquote>
</li>
<li>
<p>
In 22.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>, starting just before p. 11 please remove
as indicated:
</p>

<blockquote><pre>
<del>requires MoveAssignable&lt;Types&gt;... tuple&amp; operator=(tuple&amp;&amp; u);</del>
</pre>
<blockquote>
<p>
<del>-11- <i>Effects:</i> Move-assigns each element of <tt>u</tt> to the corresponding
element of <tt>*this</tt>.</del>
</p>
<p>
<del>-12- <i>Returns:</i> <tt>*this</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="918" href="918">918.</a> Swap for tuple needs to be conceptualized</h3>
<p><b>Section:</b> 22.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-10-04 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="522">522</a> was accepted after <tt>tuple</tt> had been conceptualized,
therefore this step needs to be completed.
</p>

<p><i>[
Post Summit Daniel adds
]</i></p>


<blockquote><p>
This is now NAD Editorial (addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>)
except for item 3 in the proposed wording.
</p></blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote><p>
As of the recent WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>),
this issue is now completely covered by editorial changes (including the third bullet), 
therefore I unconditionally recommend NAD.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We observed that all the proposed changes have already been applied to the
Working Draft, rendering this issue moot.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In both 22.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a>/2 and 22.4.12 <a href="https://timsong-cpp.github.io/cppwp/tuple.special">[tuple.special]</a> change
</p>

<blockquote><pre>
template &lt;<del>class</del> <ins>Swappable</ins>... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
</pre></blockquote>

</li>

<li>
<p>
In 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, class <tt>tuple</tt> definition and in
22.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a>, change
</p>

<blockquote><pre>
<ins>requires Swappable&lt;Types&gt;...</ins>void swap(tuple&amp;);
</pre></blockquote>

</li>

<li>
<p>
In 22.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a> remove the current requires-clause, which says:
</p>

<blockquote><p>
<del><i>Requires:</i> Each type in <tt>Types</tt> shall be <tt>Swappable</tt></del>
</p></blockquote>
</li>

</ol>






<hr>
<h3><a name="919" href="919">919.</a> (<tt>forward_</tt>)<tt>list</tt> specialized remove algorithms are over constrained</h3>
<p><b>Section:</b> 99 [forwardlist.ops], 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2008-10-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signatures of <tt>forwardlist::remove</tt> and <tt>list::remove</tt>
defined in 99 [forwardlist.ops] before 11 + 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> before 15:
</p>

<blockquote><pre>
requires EqualityComparable&lt;T&gt; void remove(const T&amp; value);
</pre></blockquote>

<p>
are asymmetric to their predicate variants (which only require
<tt>Predicate</tt>, <em>not</em> <tt>EquivalenceRelation</tt>) and with the free algorithm
remove (which only require <tt>HasEqualTo</tt>). Also, nothing in the
pre-concept WP
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
implies that <tt>EqualityComparable</tt> should
be the intended requirement.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution,
but would like additional input from concepts experts.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-07-21 Alisdair adds:
]</i></p>


<blockquote><p>
Current rationale and wording for this issue is built around concepts. I
suggest the issue reverts to Open status. I believe there is enough of
an issue to review after concepts are removed from the WP to re-examine
the issue in Santa Cruz, rather than resolve as NAD Concepts.
</p></blockquote>

<p><i>[
2009-10-10 Daniel adds:
]</i></p>


<blockquote><p>
Recommend NAD: The concept-free wording as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
has no longer the
over-specified requirement
<tt>EqualityComparable</tt> for the remove function that uses <tt>==</tt>. In fact, now
the same test conditions exists
as for the free algorithm <tt>remove</tt> (27.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>). The error was
introduced in the process of conceptifying.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD, solved by the removal of concepts.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<ol style="list-style-type:upper-alpha">
<li>
<p>
Replace in 99 [forwardlist.ops] before 11 and in 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> before 15
</p>

<blockquote><pre>
requires <del>EqualityComparable&lt;T&gt;</del> <ins>HasEqualTo&lt;T, T&gt;</ins> void remove(const T&amp; value);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="926" href="926">926.</a> Sequentially consistent fences, relaxed operations and modification order</h3>
<p><b>Section:</b> 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-10-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 313</b></p>

<p>
There was an interesting issue raised over on comp.programming.threads
today regarding the following example
</p>

<blockquote><pre>
// Thread 1:
x.store(1, memory_order_relaxed);           // SX
atomic_thread_fence(memory_order_seq_cst);  // F1
y.store(1, memory_order_relaxed);           // SY1
atomic_thread_fence(memory_order_seq_cst);  // F2
r1 = y.load(memory_order_relaxed);          // RY

// Thread 2:
y.store(0, memory_order_relaxed);          // SY2
atomic_thread_fence(memory_order_seq_cst); // F3
r2 = x.load(memory_order_relaxed);         // RX
</pre></blockquote>

<p>
is the outcome <tt>r1 == 0</tt> and <tt>r2 == 0</tt> possible?
</p>
<p>
I think the intent is that this is not possible, but I am not sure the
wording guarantees that. Here is my analysis:
</p>
<p>
Since all the fences are SC, there must be a total order between them.
<tt>F1</tt> must be before <tt>F2</tt> in that order since they are in
the same thread. Therefore <tt>F3</tt> is either before <tt>F1</tt>,
between <tt>F1</tt> and <tt>F2</tt> or after <tt>F2</tt>.
</p>
<p>
If <tt>F3</tt> is <em>after</em> <tt>F2</tt>, then we can apply 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>p5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>:
</p>

<blockquote><p>
For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic object
<tt>M</tt>, where <tt>A</tt> modifies <tt>M</tt> and <tt>B</tt> takes
its value, if there are <tt>memory_order_seq_cst</tt> fences <tt>X</tt>
and <tt>Y</tt> such that <tt>A</tt> is sequenced before <tt>X</tt>,
<tt>Y</tt> is sequenced before <tt>B</tt>, and <tt>X</tt> precedes
<tt>Y</tt> in <tt>S</tt>, then <tt>B</tt> observes either the effects of
<tt>A</tt> or a later modification of <tt>M</tt> in its modification
order.
</p></blockquote>

<p>
In this case, <tt>A</tt> is <tt>SX</tt>, <tt>B</tt> is <tt>RX</tt>, the
fence <tt>X</tt> is <tt>F2</tt> and the fence <tt>Y</tt> is <tt>F3</tt>,
so <tt>RX</tt> must see 1.
</p>
<p>
If <tt>F3</tt> is <em>before</em> <tt>F2</tt>, this doesn't apply, but
<tt>F3</tt> can therefore be before or after <tt>F1</tt>.
</p>
<p>
If <tt>F3</tt> is <em>after</em> <tt>F1</tt>, the same logic applies, but this
time the fence <tt>X</tt> is <tt>F1</tt>. Therefore again, <tt>RX</tt>
must see 1.
</p>
<p>
Finally we have the case that <tt>F3</tt> is <em>before</em> <tt>F1</tt>
in the SC ordering. There are now no guarantees about <tt>RX</tt>, and
<tt>RX</tt> can see <tt>r2==0</tt>.
</p>
<p>
We can apply 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>p5 again. This time,
<tt>A</tt> is <tt>SY2</tt>, <tt>B</tt> is <tt>RY</tt>, <tt>X</tt> is
<tt>F3</tt> and <tt>Y</tt> is <tt>F1</tt>. Thus <tt>RY</tt> must observe
the effects of <tt>SY2</tt> or a later modification of <tt>y</tt> in its
modification order.
</p>
<p>
Since <tt>SY1</tt> is sequenced before <tt>RY</tt>, <tt>RY</tt> must
observe the effects of <tt>SY1</tt> or a later modification of
<tt>y</tt> in its modification order.
</p>
<p>
In order to ensure that <tt>RY</tt> sees <tt>(r1==1)</tt>, we must see
that <tt>SY1</tt> is later in the modification order of <tt>y</tt> than
<tt>SY2</tt>.
</p>
<p>
We're now skating on thin ice. Conceptually, <tt>SY2</tt> happens-before
<tt>F3</tt>, <tt>F3</tt> is SC-ordered before <tt>F1</tt>, <tt>F1</tt>
happens-before <tt>SY1</tt>, so <tt>SY1</tt> is later in the
modification order <tt>M</tt> of <tt>y</tt>, and <tt>RY</tt> must see
the result of <tt>SY1</tt> (<tt>r1==1</tt>). However, I don't think the
words are clear on that.
</p>

<p><i>[
Post Summit Hans adds:
]</i></p>


<blockquote>
<p>
In my (Hans') view, our definition of fences will always be weaker than
what particular hardware will guarantee.  <tt>Memory_order_seq_cst</tt> fences
inherently don't guarantee sequential consistency anyway, for good
reasons (e.g. because they can't enforce a total order on stores).
 Hence I don't think the issue demonstrates a gross failure to achieve
what we intended to achieve.  The example in question is a bit esoteric.
 Hence, in my view, living with the status quo certainly wouldn't be a
disaster either.
</p>
<p>
In any case, we should probably add text along the lines of the
following between p5 and p6 in 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>:
</p>
<blockquote><p>
[Note: <tt>Memory_order_seq_cst</tt> only ensures sequential consistency for a
data-race-free program that uses exclusively <tt>memory_order_seq_cst</tt>
operations.  Any use of weaker ordering will invalidate this guarantee
unless extreme care is used.  In particular, <tt>memory_order_seq_cst</tt> fences
only ensure a total order for the fences themselves.  They cannot, in
general, be used to restore sequential consistency for atomic operations
with weaker ordering specifications.]
</p></blockquote>

<p>
Also see thread beginning at c++std-lib-23271.
</p>

</blockquote>

<p><i>[
Herve's correction:
]</i></p>

<blockquote>
<p>
Minor point, and sorry for the knee jerk reaction: I admit to having
no knowledge of Memory_order_seq_cst, but my former boss (John Lakos)
has ingrained an automatic introspection on the use of "only".   I
think you meant:
</p>

<blockquote><p>
[Note: <tt>Memory_order_seq_cst</tt> ensures sequential consistency only
for . . . .  In particular, <tt>memory_order_seq_cst</tt> fences ensure a
total order only for . . .
</p></blockquote>
<p>
Unless, of course, <tt>Memory_order_seq_cst</tt> really do nothing but ensure
sequential consistency for a data-race-free program that uses
exclusively <tt>memory_order_seq_cst</tt> operations.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph after 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>p5 that says
</p>

<blockquote><p>
For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic object
<tt>M</tt>, where <tt>A</tt> and <tt>B</tt> modify <tt>M</tt>, if there
are <tt>memory_order_seq_cst</tt> fences <tt>X</tt> and <tt>Y</tt> such
that <tt>A</tt> is sequenced before <tt>X</tt>, <tt>Y</tt> is sequenced
before <tt>B</tt>, and <tt>X</tt> precedes <tt>Y</tt> in <tt>S</tt>,
then <tt>B</tt> occurs later than <tt>A</tt> in the modifiction order of
<tt>M</tt>.
</p></blockquote>





<hr>
<h3><a name="927" href="927">927.</a> <tt>Dereferenceable</tt>  should be <tt>HasDereference</tt></h3>
<p><b>Section:</b> 99 [allocator.concepts] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2008-10-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
99 [allocator.concepts] contains a reference to a concept named
<tt>Dereferenceable</tt>. No such concept exists.
</p>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote><p>
The proposal given in the paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2829.pdf">N2829</a>
would automatically resolve this issue.
</p></blockquote>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This particular set of changes has already been made.
There are two related changes later on (and possibly also an earlier Example);
these can be handled editorially.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change all uses of the concept <tt>Dereferenceable</tt> to
<tt>HasDereference</tt> in 99 [allocator.concepts].
</p>





<hr>
<h3><a name="928" href="928">928.</a> Wrong concepts used for <tt>tuple</tt>'s comparison operators</h3>
<p><b>Section:</b> 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2008-10-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest working draft for C++0x, <tt>tuple</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>
are declared as 
</p>

<blockquote><pre>
template&lt;class... TTypes, class... UTypes&gt; 
  requires EqualityComparable&lt;TTypes, UTypes&gt;... 
  bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre></blockquote>

<p>
and
</p>

<blockquote><pre>
template&lt;class... TTypes, class... UTypes&gt; 
  requires LessThanComparable&lt;TTypes, UTypes&gt;... 
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre></blockquote>

<p>
But the concepts <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt> only take one 
parameter, not two.  Also, even if <tt>LessThanComparable</tt> could take two 
parameters, the definition of <tt>tuple::operator&lt;()</tt> should also require 
</p>

<blockquote><pre>
LessThanComparable&lt;UTypes, TTypes&gt;... // (note the order) 
</pre></blockquote>

<p>
since the algorithm for <tt>tuple::operator&lt;</tt> is the following (pseudo-code)
</p>

<blockquote><pre>
for (size_t N = 0; N &lt; sizeof...(TTypes); ++N) { 
    if (get&lt;N&gt;(t) &lt; get&lt;N&gt;(u) return true; 
    else if ((get&lt;N&gt;(u) &lt; get&lt;N&gt;(t)) return false; 
} 

return false; 
</pre></blockquote>

<p>
Similar problems hold for <tt>tuples</tt>'s other comparison operators.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote><p>
Recommend Tentatively Ready.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 22.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a> and 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> change:
</p>

<blockquote><pre>
template&lt;class... TTypes, class... UTypes&gt;
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;TTypes, UTypes&gt;...
  bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;TTypes, UTypes&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;TTypes, UTypes&gt;...
  bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;<del>U</del><ins>T</ins>Types, <del>T</del><ins>U</ins>Types&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;<del>U</del><ins>T</ins>Types, <del>T</del><ins>U</ins>Types&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;TTypes, UTypes&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
</pre></blockquote>





<hr>
<h3><a name="930" href="930">930.</a> Access to std::array data as built-in array type</h3>
<p><b>Section:</b> 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-11-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The Working Draft (N2798) allows access to the elements of
<tt>std::array</tt> by its <tt>data()</tt> member function:
</p>

<blockquote>

<h5>23.2.1.4 array::data [array.data]</h5>
<pre>
 T *data();
 const T *data() const;
</pre>
<ol><li>
 Returns: elems.
</li></ol>
</blockquote>

<p>
Unfortunately, the result of <tt>std::array::data()</tt> cannot be bound
to a reference to a built-in array of the type of <tt>array::elems</tt>.
And <tt>std::array</tt> provides no other way to get a reference to
<tt>array::elems</tt>. 
This hampers the use of <tt>std::array</tt>, for example when trying to
pass its data to a C style API function:
</p>

<pre>
 // Some C style API function. 
 void set_path( char (*)[MAX_PATH] );

 std::array&lt;char,MAX_PATH&gt; path;
 set_path( path.data() );  // error
 set_path( &amp;(path.data()) );  // error
</pre>

 <p>
Another example, trying to pass the array data to an instance of another
C++ class:
</p>

<pre>
 // Represents a 3-D point in space.
 class three_d_point {
 public:
   explicit three_d_point(const double (&amp;)[3]); 
 };

 const std::array&lt;double,3&gt; coordinates = { 0, 1, 2 };
 three_d_point point1( coordinates.data() );  // error.
 three_d_point point2( *(coordinates.data()) );  // error.
</pre>

<p>
A user might be tempted to use <tt>std::array::elems</tt> instead, but
doing so isn't recommended, because <tt>std::array::elems</tt> is "for
exposition only".  Note that Boost.Array users might already use
<tt>boost::array::elems</tt>, as its documentation doesn't explicitly
state that <tt>boost::array::elems</tt> is for exposition only:
http://www.boost.org/doc/libs/1_36_0/doc/html/boost/array.html
</p>
<p>
I can think of three options to solve this issue:
</p>
<ol><li>
Remove the words "exposition only" from the definition of
<tt>std::array::elems</tt>, as well as the note saying that "elems is
shown for exposition only."
</li><li>
Change the signature of <tt>std::array::data()</tt>, so that it would
return a reference to the built-in array, instead of a pointer to its
first element.
</li><li>
Add extra member functions, returning a reference to the built-in array.
</li></ol>
<p>
Lawrence Crowl wrote me that it might be better to leave
<tt>std::array::elems</tt> "for exposition only", to allow alternate
representations to allocate the array data dynamically.  This might be
of interest to the embedded community, having to deal with very limited
stack sizes.
</p>
<p>
The second option, changing the return type of
<tt>std::array::data()</tt>, would break backward compatible to current
Boost and TR1 implementations, as well as to the other contiguous
container (<tt>vector</tt> and <tt>string</tt>) in a very subtle way.
For example, the following call to <tt>std::swap</tt> currently swap two
locally declared pointers <tt>(data1, data2)</tt>, for any container
type <tt>T</tt> that has a <tt>data()</tt> member function. When
<tt>std::array::data()</tt> is changed to return a reference, the
<tt>std::swap</tt> call may swap the container elements instead.
</p>

<pre>
 template &lt;typename T&gt;
 void func(T&amp; container1, T&amp; container2)
 {
   // Are data1 and data2 pointers or references?
   auto data1 = container1.data();
   auto data2 = container2.data();

   // Will this swap two local pointers, or all container elements?
   std::swap(data1, data2);
 }
</pre>

<p>
The following concept is currently satisfied by all contiguous
containers, but it no longer is for <tt>std::array</tt>, when
<tt>array::data()</tt>
is changed to return a reference (tested on ConceptGCC Alpha 7):
</p>

<pre>
 auto concept ContiguousContainerConcept&lt;typename T&gt;
 {
   typename value_type = typename T::value_type;
   const value_type * T::data() const;
 }
</pre>

<p>
Still it's worth considering having <tt>std::array::data()</tt> return a
reference, because it might be the most intuitive option, from a user's
point of view.  Nicolai Josuttis (who wrote <tt>boost::array</tt>)
mailed me that he very much prefers this option.
</p>
<p>
Note that for this option, the definition of <tt>data()</tt> would also
need to be revised for zero-sized arrays, as its return type cannot be a
reference to a zero-sized built-in array.  Regarding zero-sized array,
<tt>data()</tt> could throw an exception.  Or there could be a partial
specialization of <tt>std::array</tt> where <tt>data()</tt> returns
<tt>T*</tt> or gets removed.
</p>
<p>
Personally I prefer the third option, adding a new member function to
<tt>std::array</tt>, overloaded for const and non-const access,
returning a reference to the built-in array, to avoid those compatible
issues. I'd propose naming the function <tt>std::array::c_array()</tt>,
which sounds intuitive to me. Note that <tt>boost::array</tt> already
has a <tt>c_array()</tt> member, returning a pointer, but Nicolai told
me that this one is only there for historical reasons. (Otherwise a name
like <tt>std::array::native_array()</tt> or
<tt>std::array::builtin_array()</tt> would also be fine with me.) 
According to my proposed resolution, a zero-sized <tt>std::array</tt> does not need
to have <tt>c_array()</tt>, while it is still required to have
<tt>data()</tt> functions.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>

<p>
Alisdair: Don't like p4 suggesting implementation-defined behaviour.
</p>
<p>
Walter: What about an explicit conversion operator, instead of adding
the new member function?
</p>
<p>
Alisdair: Noodling about:
</p>
<blockquote><pre>
template&lt;size_t N, ValueType T&gt;
struct array
{
  T elems[N];

// fantasy code starts here

// crazy decltype version for grins only
//requires True&lt;(N&gt;0)&gt;
//explict operator decltype(elems) &amp; () { return elems; }

// conversion to lvalue ref
requires True&lt;(N&gt;0)&gt;
explict operator T(&amp;)[N] () &amp; { return elems; }

// conversion to const lvalue ref
requires True&lt;(N&gt;0)&gt;
explict operator const T(&amp;)[N] () const &amp; { return elems; }

// conversion to rvalue ref using ref qualifiers
requires True&lt;(N&gt;0)&gt;
explict operator T(&amp;&amp;)[N] () &amp;&amp; { return elems; }

// fantasy code ends here

explicit operator bool() { return true; }
};
</pre></blockquote>

<p>
This seems legal but odd. Jason Merrill says currently a CWG issue 613
on the non-static data member that fixes the error that current G++
gives for the non-explicit, non-conceptualized version of this. Verdict
from human compiler: seems legal.
</p>
<p>
Some grumbling about zero-sized arrays being allowed and supported.
</p>
<p>
Walter: Would this address the issue? Are we inclined to go this route?
</p>
<p>
Alan: What would usage look like?
</p>
<blockquote><pre>
// 3-d point in space
struct three_d_point
{
  explicit three_d_point(const double (&amp;)[3]);
};

void sink(double*);

const std::array&lt;double, 3&gt; coordinates = { 0, 1, 2 };
three_d_point point1( coordinates.data() ); //error
three_d_point point2( *(coordinates.data()) ); // error
three_d_point point3( coordinates ); // yay!

sink(cooridinates); // error, no conversion
</pre></blockquote>

<p>
Recommended Open with new wording. Take the required clause and add the
explicit conversion operators, not have a <tt>typedef</tt>. At issue still is use
<tt>decltype</tt> or use <tt>T[N]</tt>. In favour of using <tt>T[N]</tt>, even though use of
<tt>decltype</tt> is specially clever.
</p>

</blockquote>

<p><i>[
Post Summit, further discussion in the thread starting with c++std-lib-23215.
]</i></p>


<p><i>[
2009-07 post-Frankfurt (Saturday afternoon group):
]</i></p>


<blockquote>
<p>
The idea to resolve the issue by adding explicit conversion operators
was abandoned, because it would be inconvenient to use, especially when
passing the array to a template function, as mentioned by Daniel. So we
reconsidered the original proposed resolution, which appeared
acceptable, except for its proposed changes to 24.3.7.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a>, which
allowed <tt>c_array_type</tt> and <tt>c_array()</tt> to be absent for a zero-sized array.
Alisdair argued that such wording would disallow certain generic use
cases. New wording for 24.3.7.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> was agreed upon (Howard: and
is reflected in the proposed resolution).
</p>
<p>
Move to Review
</p>
</blockquote>

<p><i>[
2009-07-31 Alisdair adds:
]</i></p>


<blockquote>
<p>
I will be unhappy voting the proposed resolution for 930 past review
until we have implementation experience with reference qualifiers. 
Specifically, I want to understand the impact of the missing overload
for <tt>const &amp;&amp;</tt> (if any.)
</p>

<p>
If we think the issue is important enough it might be worthwhile
stripping the ref qualifiers for easy progress next meeting, and opening
yet another issue to put them back with experience.
</p>

<p>
Recommend deferring any decision on splitting the issue until we get LWG
feedback next meeting - I may be the lone dissenting voice if others are
prepared to proceed without it.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD. There was not enough consensus that this was sufficiently
useful. There are known other ways to do this, such as small inline
conversion functions.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the template definition of array, 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>/3:
</p>

<blockquote>
<pre><ins>
typedef T c_array_type[N];
c_array_type &amp; c_array() &amp;;
c_array_type &amp;&amp; c_array() &amp;&amp;;
const c_array_type &amp; c_array() const &amp;;
</ins>
</pre>
</blockquote>

<p>
Add the following subsection to 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>, after  [array.data]:
</p>

<blockquote>
<h5><ins>23.2.1.5 array::c_array [array.c_array]</ins></h5>
    <pre><ins>
c_array_type &amp; c_array() &amp;;
c_array_type &amp;&amp; c_array() &amp;&amp;;
const c_array_type &amp; c_array() const &amp;;
</ins></pre>
<blockquote>
<p>
<ins><i>Returns:</i> <tt>elems</tt>.</ins>
</p>
</blockquote>

</blockquote>



<p>
Change Zero sized arrays 24.3.7.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a>:
</p>

<blockquote>

<p>-2- ...</p>

<p><ins>
The type <tt>c_array_type</tt> is unspecified for a zero-sized array.
</ins></p>

<p>
-3- The effect of calling <ins><tt>c_array()</tt>,</ins> <tt>front()</tt><ins>,</ins> or
<tt>back()</tt> for a zero-sized array is implementation defined.
</p>
</blockquote>






<hr>
<h3><a name="933" href="933">933.</a> Unique_ptr defect</h3>
<p><b>Section:</b> 20.3.1.3.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-11-27 <b>Last modified:</b> 2018-06-23 21:28:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.modifiers">issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we are supporting stateful deleters, we need an overload for
<tt>reset</tt> that
takes a deleter as well.
</p>

<blockquote><pre>
void reset(pointer p, deleter_type d);
</pre></blockquote>

<p>
We probably need two overloads to support move-only deleters, and
this sounds uncomfortably like the two constructors I have been ignoring
for now...
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard comments that we have the functionality via move-assigment.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD Future.
</p></blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>Pointer-accepting overloads of <tt>reset()</tt> are discouraged &mdash; the same
functionality is available via move-assignment and that is more idiomatic.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="935" href="935">935.</a> clock error handling needs to be specified</h3>
<p><b>Section:</b> 29.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock">[time.clock]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-11-24 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Each of the three clocks specified in Clocks 29.7 <a href="https://timsong-cpp.github.io/cppwp/time.clock">[time.clock]</a>
provides the member function:
</p>

<blockquote><pre>
static time_point now();
</pre></blockquote>

<p>
The semantics specified by Clock requirements 29.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a>
make no mention of error handling. Thus the function may throw <tt>bad_alloc</tt>
or an implementation-defined exception (16.4.6.13 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>
paragraph 4).
</p>

<p>
Some implementations of these functions on POSIX, Windows, and
presumably on other operating systems, may fail in ways only detectable
at runtime. Some failures on Windows are due to supporting chipset
errata and can even occur after successful calls to a clock's <tt>now()</tt>
function.
</p>

<p>
These functions are used in cases where exceptions are not appropriate
or where the specifics of the exception or cause of error need to be
available to the user. See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error
handling (Rev 1)</i>, for more specific discussion of use cases. Thus some change in
the interface of now is required.
</p>

<p>
The proposed resolution has been implemented in the Boost version of the
chrono library. No problems were encountered.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be deferred until the next Committee Draft
has been issued and the prerequisite paper has been accepted.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD future. Too late to make this change without having already
accepted the hybrid error handling proposal.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD. Needs a paper. Proposed resolution no longer applies.</p>


<p><b>Proposed resolution:</b></p>
<p>
Accept the proposed wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error handling (Rev 1)</i>.
</p>

<p>
Change <tt>Clock</tt> requirements 29.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a> as indicated:
</p>

<blockquote>
<p>
-2- In Table 55 <tt>C1</tt> and <tt>C2</tt> denote clock types. <tt>t1</tt> and
<tt>t2</tt> are values returned by <tt>C1::now()</tt> where the call 
returning <tt>t1</tt> happens before (1.10) the call returning <tt>t2</tt> and
both of these calls happen before <tt>C1::time_point::max()</tt>.
<ins><tt>ec</tt> denotes an object of type <tt>error_code</tt> 
(19.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.overview">[syserr.errcode.overview]</a>).</ins>
</p>

<table border="1">
<caption>Table 55 &mdash; Clock requirements</caption>
<tr>
<th>Expression</th><th>Return type</th><th>Operational semantics</th>
</tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>

<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point</tt></td>
<td>Returns a <tt>time_point</tt> object representing the current point in time.
</td>
</tr>

<tr>
<td><tt><ins>C1::now(ec)</ins></tt></td>
<td><tt><ins>C1::time_point</ins></tt></td>
<td><ins>Returns a <tt>time_point</tt> object representing the current point in time.</ins>
</td>
</tr>
</table>
</blockquote>

<p>
Change class <tt>system_clock</tt> 29.7.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system">[time.clock.system]</a> as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>monotonic_clock</tt> 99 [time.clock.monotonic] as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>high_resolution_clock</tt> 29.7.8 <a href="https://timsong-cpp.github.io/cppwp/time.clock.hires">[time.clock.hires]</a> as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>






<hr>
<h3><a name="937" href="937">937.</a> Atomics for standard typedef types</h3>
<p><b>Section:</b> 33.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Clark Nelson <b>Opened:</b> 2008-12-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 89</b></p>

<blockquote>
<p>
The types in the table "Atomics for standard typedef types" should be
typedefs, not classes. These semantics are necessary for compatibility
with C.
</p>

<p>
Change the classes to typedefs.
</p>
</blockquote>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>
specified different requirements for atomic analogs of fundamental
integer types (such as <tt>atomic_int</tt>) and for atomic analogs of <tt>&lt;cstdint&gt;</tt>
typedefs (such as <tt>atomic_size_t</tt>). Specifically, <tt>atomic_int</tt> et al. were
specified to be distinct classes, whereas <tt>atomic_size_t</tt> et al. were
specified to be typedefs. Unfortunately, in applying
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>
to the WD, that distinction was erased, and the atomic analog of every <tt>&lt;cstdint&gt;</tt>
typedef is required to be a distinct class.
</p>

<p>
It shouldn't be required that the atomic analog of every <tt>&lt;cstdint&gt;</tt>
typedef be a typedef for some fundamental integer type. After all,
<tt>&lt;cstdint&gt;</tt> is supposed to provide standard names for extended integer
types. So there was a problem in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>,
which certainly could have been
interpreted to require that. But the status quo in the WD is even worse,
because it's unambiguously wrong.
</p>

<p>
What is needed are words to require the existence of a bunch of type
names, without specifying whether they are class names or typedef names.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Change status to NAD, editorial. See US 89 comment notes above.
</p>
<p>
Direct the editor to turn the types into typedefs as proposed in the
comment. Paper approved by committee used typedefs, this appears to have
been introduced as an editorial change. Rationale: for compatibility
with C.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="941" href="941">941.</a> Ref-qualifiers for assignment operators</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-12-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The assignment and equality operators <tt>=</tt> and <tt>==</tt> are easily confused, just
because of their visual similarity, and in this case a simple typo can cause
a serious bug. When the left side of an <tt>operator=</tt> is an rvalue, it's
highly unlikely that the assignment was intended by the programmer:
</p>
<blockquote><pre>
if ( func() = value )  // Typical typo: == intended!
</pre></blockquote>
<p>
Built-in types don't support assignment to an rvalue, but unfortunately,
a lot of types provided by the Standard Library do.
</p>
<p>
Fortunately the language now offers a syntax to prevent a certain member
function from having an rvalue as <tt>*this</tt>: by adding a ref-qualifier (<tt>&amp;</tt>)
to the member function declaration.  Assignment operators are explicitly
mentioned as a use case of ref-qualifiers, in "Extending Move Semantics
To <tt>*this</tt> (Revision 1)",
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> by Daveed
Vandevoorde and Bronek Kozicki
</p>
<p>
Hereby I would like to propose adding ref-qualifiers to all appropriate
assignment operators in the library.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open.
We recommend this be deferred until after the next Committee Draft.
</p></blockquote>

<p><i>[
Frankfurt 2009-07:
]</i></p>


<blockquote>
<p>
The LWG declined to move forward with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2819.html">N2819</a>.
</p>
<p>
Moved to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
A proposed resolution is provided by the paper on this subject,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2819.html">N2819</a>,
<i>Ref-qualifiers for assignment operators of the Standard Library</i>
</p>





<hr>
<h3><a name="942" href="942">942.</a> Atomics synopsis typo</h3>
<p><b>Section:</b> 33.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Holger Grund <b>Opened:</b> 2008-12-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="880">880</a></p>
<p><b>Discussion:</b></p>



<p>
I'm looking at 33.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> and can't really make sense of a couple of things.
</p>
<p>
Firstly, there appears to be a typo in the <tt>&lt;cstdatomic&gt;</tt> synopsis:
</p>

<blockquote>
<p>
The <tt>atomic_exchange</tt> overload taking an <tt>atomic_address</tt>
is missing the second parameter:
</p>

<blockquote><pre>
void* atomic_exchange(volatile atomic_address*);
</pre></blockquote>

<p>
should be
</p>

<blockquote><pre>
void* atomic_exchange(volatile atomic_address*<ins>, void*</ins>);
</pre></blockquote>

<p>
Note, that this is <em>not</em> covered by <a href="880">880</a> "Missing atomic exchange parameter",
which only talks about the <tt>atomic_bool</tt>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 33.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a>/2:
</p>

<blockquote><pre>
void* atomic_exchange(volatile atomic_address*<ins>, void*</ins>);
</pre></blockquote>






<hr>
<h3><a name="945" href="945">945.</a> <tt>system_clock::rep</tt> not specified</h3>
<p><b>Section:</b> 29.7.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system">[time.clock.system]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.clock.system">issues</a> in [time.clock.system].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 29.7.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system">[time.clock.system]</a>, the declaration of <tt>system_clock::rep</tt> says "see
below", but there is nothing below that describes it.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
This note refers to:
</p>

<blockquote><p>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt> shall be <tt>true</tt>.
</p></blockquote>

<p>
I.e. this is standardeze for "<tt>system_clock::rep</tt> is signed".
Perhaps an editorial note along the lines of:
</p>

<blockquote><p>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt>
shall be <tt>true</tt>. <ins>[<i>Note:</i> <tt>system_clock::rep</tt> shall be signed. <i>-- end note</i>].</ins>
</p></blockquote>

<p>
?
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the direction of the proposed resolution.
Move to NAD Editorial.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a note to 29.7.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system">[time.clock.system]</a>, p2:
</p>
<blockquote><p>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt>
shall be <tt>true</tt>. <ins>[<i>Note:</i> <tt>system_clock::rep</tt> shall be signed. <i>-- end note</i>].</ins>
</p></blockquote>





<hr>
<h3><a name="946" href="946">946.</a> <tt>duration_cast</tt> improperly specified</h3>
<p><b>Section:</b> 29.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cast">[time.duration.cast]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cast">[time.duration.cast]</a>/3:
</p>
<blockquote><p>
.... All intermediate computations shall be
carried out in the widest possible representation... .
</p></blockquote>

<p>
So ignoring floating-point types for the moment, all this arithmetic has to be done
using the implementation's largest integral type, even if both arguments
use <tt>int</tt> for their representation. This seems excessive. And it's not at
all clear what this means if we don't ignore floating-point types.
</p>

<p>
This issue is related to <a href="952">952</a>.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
The intent of this remark is that intermediate computations are carried out
using:
</p>

<blockquote><pre>
common_type&lt;typename ToDuration::rep, Rep, intmax_t&gt;::type
</pre></blockquote>

<p>
The Remark was intended to be clarifying prose supporting the rather algorithmic description
of the previous paragraph.  I'm open to suggestions.  Perhaps the entire paragraph
3 (Remarks) would be better dropped?
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We view this as a specific case of issue <a href="952">952</a>,
and should be resolved when that issue is resolved.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="952" href="952">952.</a> Various threading bugs #2</h3>
<p><b>Section:</b> 29.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cast">[time.duration.cast]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cast">[time.duration.cast]</a> specifies an implementation and imposes
requirements in text (and the implementation doesn't satisfy all of the
text requirements). Pick one.
</p>

<p>
This issue is related to <a href="946">946</a>.
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<p>
The <i>Remarks</i> paragraph is an English re-statement of the preceeding
<i>Returns</i> clause.  It was meant to be clarifying and motivating, not
confusing.  I'm not aware with how the <i>Remarks</i> contradicts the <i>Returns</i> clause
but I'm ok with simply removing the <i>Remarks</i>.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete suggests that this could be resolved
by rephrasing the Remarks to Notes.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="955" href="955">955.</a> Various threading bugs #5</h3>
<p><b>Section:</b> 29.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a> requires that a clock type have a member
typedef named <tt>time_point</tt> that names an instantiation of the
template <tt>time_point</tt>, and a member named <tt>duration</tt> that
names an instantiation of the template <tt>duration</tt>. This mixing of
levels is confusing. The typedef names should be different from the
template names.
</p>

<p><i>[
Post Summit, Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-05-04 Howard adds:
]</i></p>


<blockquote>
<p>
The reason that the typedef names were given the same name as the class templates
was so that clients would not have to stop and think about whether they were
using the clock's native <tt>time_point</tt> / <tt>duration</tt> or the class
template directly.  In this case, one person's confusion is another person's
encapsulation.  The detail that sometimes one is referring to the clock's
native types, and sometimes one is referring to an independent type is
<em>purposefully</em> "hidden" because it is supposed to be an unimportant
detail.  It can be confusing to have to remember when to type <tt>duration</tt>
and when to type <tt>duration_type</tt>, and there is no need to require the
client to remember something like that.
</p>

<p>
For example, here is code that I once wrote in testing out the usability of
this facility:
</p>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
void do_until(const std::chrono::<b>time_point</b>&lt;Clock, Duration&gt;&amp; t)
{
    typename Clock::<b>time_point now</b> = Clock::now();
    if (t &gt; now)
    {
        typedef typename std::common_type
        &lt;
            Duration,
            typename std::chrono::system_clock::<b>duration</b>
        &gt;::type CD;
        typedef std::chrono::<b>duration</b>&lt;double, std::nano&gt; ID;

        CD d = t - now;
        ID us = duration_cast&lt;ID&gt;(d);
        if (us &lt; d)
            ++us;
        ...
    }
}
</pre></blockquote>

<p>
I see no rationale to require the client to append <tt>_type</tt> to <em>some</em>
of those declarations.  It seems overly burdensome on the author of <tt>do_until</tt>:
</p>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
void do_until(const std::chrono::<b>time_point</b>&lt;Clock, Duration&gt;&amp; t)
{
    typename Clock::<b>time_point<span style="color:#C80000">_type</span></b> now = Clock::now();
    if (t &gt; now)
    {
        typedef typename std::common_type
        &lt;
            Duration,
            typename std::chrono::system_clock::<b>duration<span style="color:#C80000">_type</span></b>
        &gt;::type CD;
        typedef std::chrono::<b>duration</b>&lt;double, std::nano&gt; ID;

        CD d = t - now;
        ID us = duration_cast&lt;ID&gt;(d);
        if (us &lt; d)
            ++us;
        ...
    }
}
</pre></blockquote>

<p>
Additionally I'm fairly certain that this suggestion hasn't been implemented.
If it had, it would have been discovered that it is incomplete.  <tt>time_point</tt>
also has a nested type (purposefully) named <tt>duration</tt>.
</p>
<blockquote><p>
That is, the current proposed wording would put the WP into an inconsistent state.
</p></blockquote>
<p>
In contrast,
the current WP has been implemented and I've received very favorable feedback
from people using this interface in real-world code.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill agrees that distinct names should be used for distinct kinds of entities.
</p>
<p>
Walter would prefer not to suffix type names,
especially for such well-understood terms as "duration".
</p>
<p>
Howard reminds us that the proposed resolution is incomplete, per his comment
in the issue.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Howard adds:
]</i></p>


<blockquote>
<p>
Not meaning to be argumentative, but we have a decade of positive experience
with the precedent of using the same name for the nested type as an external
class representing an identical concept.
</p>

<blockquote><pre>
template&lt;class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&amp;&gt;
struct <b>iterator</b>
{
    ...
};

template &lt;BidirectionalIterator Iter&gt;
class <b>reverse_iterator</b>
{
    ...
};

template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
    requires NothrowDestructible&lt;T&gt;
class list
{
public:
    typedef <i>implementation-defined</i>     <b>iterator</b>;
    ...
    typedef reverse_iterator&lt;iterator&gt; <b>reverse_iterator</b>;
    ...
};
</pre></blockquote>

<p>
I am aware of <em>zero</em> complaints regarding the use of <tt>iterator</tt>
and <tt>reverse_iterator</tt> as nested types of the containers despite these
names also having related meaning at namespace std scope.
</p>

<p>
Would we really be doing programmers a favor by renaming these nested types?
</p>

<blockquote><pre>
template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
    requires NothrowDestructible&lt;T&gt;
class list
{
public:
    typedef <i>implementation-defined</i>     <b>iterator_type</b>;
    ...
    typedef reverse_iterator&lt;iterator&gt; <b>reverse_iterator_type</b>;
    ...
};
</pre></blockquote>

<p>
I submit that such design contributes to needless verbosity which ends up
reducing readability.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD.  No concensus for changing the WP.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 29 <a href="https://timsong-cpp.github.io/cppwp/time">[time]</a>:
</p>

<blockquote><pre>
...
template &lt;class Clock, class Duration = typename Clock::duration<ins>_type</ins>&gt; class time_point;
...
</pre></blockquote>

<p>
Change 29.3 <a href="https://timsong-cpp.github.io/cppwp/time.clock.req">[time.clock.req]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 45 -- Clock requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>C1::duration<ins>_type</ins></tt></td>
<td><tt>chrono::duration&lt;C1::rep, C1::period&gt;</tt></td>
<td>The native <tt>duration</tt> type of the clock.</td>
</tr>
<tr>
<td><tt>C1::time_point<ins>_type</ins></tt></td>
<td><tt>chrono::time_point&lt;C1&gt;</tt> or <tt>chrono::time_point&lt;C2, C1::duration<ins>_type</ins>&lt;</tt></td>
<td>The native <tt>time_point</tt> type of the clock.   Different clocks may  share a <tt>time_point<ins>_type</ins></tt>
definition if it is valid to 
compare their <tt>time_point<ins>_type</ins></tt>s by 
comparing their respective 
<tt>duration<ins>_type</ins></tt>s. <tt>C1</tt> and <tt>C2</tt> shall 
refer to the same epoch.</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point<ins>_type</ins></tt></td>
<td>Returns a <tt>time_point<ins>_type</ins></tt> object 
representing the current point 
in time.
</td>
</tr>
</table>
</blockquote>

<p>
Change 29.7.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system">[time.clock.system]</a>:
</p>

<blockquote>
<p>
-1- Objects of class <tt>system_clock</tt> represent wall clock time from the system-wide realtime clock.
</p>

<blockquote><pre>
class system_clock { 
public: 
  typedef <i>see below</i> rep; 
  typedef ratio&lt;<i>unspecified</i>, <i>unspecified</i>&gt; period; 
  typedef chrono::duration&lt;rep, period&gt; duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;system_clock&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic = <i>unspecified</i> ; 

  static time_point<ins>_type</ins> now(); 

  // Map to C API 
  static time_t to_time_t (const time_point<ins>_type</ins>&amp; t); 
  static time_point<ins>_type</ins> from_time_t(time_t t); 
};
</pre></blockquote>

<p>
-2- <tt>system_clock::duration<ins>_type</ins>::min() &lt; system_clock::duration<ins>_type</ins>::zero()</tt> shall be <tt>true</tt>.
</p>

<pre>
time_t to_time_t(const time_point<ins>_type</ins>&amp; t);
</pre>

<blockquote><p>
-3- <i>Returns:</i> A <tt>time_t</tt> object that represents the same
point in time as <tt>t</tt> when both values are truncated to the
coarser of the precisions of <tt>time_t</tt> and <tt>time_point<ins>_type</ins></tt>.
</p></blockquote>

<pre>
<tt>time_point<ins>_type</ins></tt> from_time_t(time_t t);
</pre>

<blockquote><p>
-4- <i>Returns:</i> A <tt>time_point<ins>_type</ins></tt> object that represents the same point
in time as <tt>t</tt> when both values are truncated to the coarser of the
precisions of <tt>time_t</tt> and <tt>time_point<ins>_type</ins></tt>.
</p></blockquote>
</blockquote>

<p>
Change 99 [time.clock.monotonic]:
</p>

<blockquote><pre>
class monotonic_clock { 
public: 
  typedef <i>unspecified</i>                                rep; 
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i>&gt;           period; 
  typedef chrono::duration&lt;rep, period&gt;              duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;<i>unspecified</i> , duration<ins>_type</ins>&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic =                   true; 

  static time_point<ins>_type</ins> now();
};
</pre></blockquote>

<p>
Change 29.7.8 <a href="https://timsong-cpp.github.io/cppwp/time.clock.hires">[time.clock.hires]</a>:
</p>

<blockquote><pre>
class high_resolution_clock { 
public: 
  typedef <i>unspecified</i>                                rep; 
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i>&gt;           period; 
  typedef chrono::duration&lt;rep, period&gt;              duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;<i>unspecified</i> , duration<ins>_type</ins>&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic =                   true; 

  static time_point<ins>_type</ins> now();
};
</pre></blockquote>






<hr>
<h3><a name="959" href="959">959.</a> Various threading bugs #9</h3>
<p><b>Section:</b> 33.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
33.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a>: <tt>condition_variable::wait_for</tt>
is required to compute the absolute time by adding the duration value to
<tt>chrono::monotonic_clock::now()</tt>, but <tt>monotonic_clock</tt> is not required to
exist.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Move to open. Associate with LWG <a href="859">859</a> and any other monotonic-clock
related issues.
</p></blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote><p>
I believe that <a href="859">859</a> (currently Ready) addresses this issue, and
that this issue should be marked NAD, solved by <a href="859">859</a> (assuming
it moves to WP).
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave open, but expect to be fixed by N2969 revision that Detlef is writing.
</p></blockquote>

<p><i>[
2009-11-18 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
<tt>condition_variable::wait_for</tt> no longer refers to
<tt>monotonic_clock</tt>, so this issue is moot.
</p>





<hr>
<h3><a name="969" href="969">969.</a> What happened to Library Issue 475?</h3>
<p><b>Section:</b> 27.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2009-01-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Library Issue <a href="475">475</a> has CD1 status, but the non-normative note in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
was removed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>
(27.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a> in both drafts).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Restore the non-normative note. It might need to be expressed in terms of concepts.
</p>





<hr>
<h3><a name="971" href="971">971.</a> Spurious diagnostic conversion function</h3>
<p><b>Section:</b> 19.5.4.5 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.nonmembers">[syserr.errcode.nonmembers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-01-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Anthony Williams raised the question in c++std-lib-22987 "why is there
<tt>std::make_error_code(std::errc)</tt>? What purpose does this serve?"
</p>
<p>
The function <tt>make_error_code(errc e)</tt> is not required, since
<tt>make_error_condition(errc e)</tt> is the function that is needed for <tt>errc</tt>
conversions. <tt>make_error_code(errc e)</tt> appears to be a holdover from my
initial confusion over the distinction between POSIX and operating
systems that conform to the POSIX spec.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote><p>
Recommend Review.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
The designer of the facility (Christopher Kohlhoff)
strongly disagrees that there is an issue here,
and especially disagrees with the proposed resolution.
Bill would prefer to be conservative and not apply this proposed resolution.
Move to Open, and recommend strong consideration for NAD status.
</p></blockquote>

<p><i>[
2009-05-21 Beman adds:
]</i></p>


<blockquote><p>
My mistake. Christopher and Bill are correct and the issue should be
NAD. The function is needed by users.
</p></blockquote>

<p><i>[
2009-07-21 Christopher Kohlhoff adds rationale for <tt>make_error_code</tt>:
]</i></p>


<blockquote>
<p>
Users (and indeed library implementers) may need to use the
<tt>errc</tt> codes in portable code. For example:
</p>

<blockquote><pre>
void do_foo(error_code&amp; ec)
{
#if defined(_WIN32)
  // Windows implementation ...
#elif defined(linux)
  // Linux implementation ...
#else
  // do_foo not supported on this platform
  ec = make_error_code(errc::not_supported);
#endif
}
</pre></blockquote>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to NAD.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change System error support 19.5 <a href="https://timsong-cpp.github.io/cppwp/syserr">[syserr]</a>, Header <tt>&lt;system_error&gt;</tt>
synopsis, as indicated:
</p>

<blockquote><pre>
<del>error_code make_error_code(errc e);</del>
error_condition make_error_condition(errc e);
</pre></blockquote>

<p>
Delete from Class error_code non-member functions
19.5.4.5 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.nonmembers">[syserr.errcode.nonmembers]</a>:
</p>

<blockquote><pre>
<del>error_code make_error_code(errc e);</del>
</pre>
<blockquote><p>
<del><i>Returns:</i> <tt>error_code(static_cast&lt;int&gt;(e),
generic_category)</tt>.</del>
</p></blockquote>
</blockquote>






<hr>
<h3><a name="972" href="972">972.</a> The term "Assignable" undefined but still in use</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Previous versions of the Draft had a table, defining the Assignable 
requirement.  For example 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>
Table 79, "Assignable requirements". But I guess the term "Assignable" 
is outdated by now, because the current Committee Draft provides 
<tt>MoveAssignable</tt>, <tt>CopyAssignable</tt>, and <tt>TriviallyCopyAssignable</tt> concepts 
instead. And as far as I can see, it no longer has a definition of 
<tt>Assignable</tt>. (Please correct me if I'm wrong.) Still the word 
"Assignable" is used in eight places in the Draft, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>.
</p>

<p>
Are all of those instances of "<tt>Assignable</tt>" to be replaced by "<tt>CopyAssignable</tt>"? 
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change Exception Propagation 17.10.7 <a href="https://timsong-cpp.github.io/cppwp/propagation">[propagation]</a>:
</p>
<blockquote><p>
<tt>exception_ptr</tt> shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>,
<tt><ins>Copy</ins>Assignable</tt> and <tt>EqualityComparable</tt>.
</p></blockquote>

<p>
Change Class template reference_wrapper 22.10.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap">[refwrap]</a>:
</p>
<blockquote><p>
<tt>reference_wrapper&lt;T&gt;</tt> is a <tt>CopyConstructible</tt> and <tt><ins>Copy</ins>Assignable</tt> 
wrapper around a reference to an object of type <tt>T</tt>.
</p></blockquote>
<p>
Change Placeholders 22.10.15.5 <a href="https://timsong-cpp.github.io/cppwp/func.bind.place">[func.bind.place]</a>:
</p>
<blockquote><p>
It is implementation defined whether placeholder types are <tt><ins>Copy</ins>Assignable</tt>. 
<tt><ins>Copy</ins>Assignable</tt> placeholders' copy assignment operators shall not throw exceptions.
</p></blockquote>
<p>
Change Class template shared_ptr 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>:
</p>
<blockquote><p>
Specializations of <tt>shared_ptr</tt> shall be <tt>CopyConstructible</tt>, <tt><ins>Copy</ins>Assignable</tt>, and <tt>LessThanComparable</tt>...
</p></blockquote>
<p>
Change Class template weak_ptr 20.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.weak">[util.smartptr.weak]</a>:
</p>
<blockquote><p>
Specializations of <tt>weak_ptr</tt> shall be <tt>CopyConstructible</tt>, <tt><ins>Copy</ins>Assignable</tt>, and <tt>LessThanComparable</tt>...
</p></blockquote>
<p>
Change traits typedefs 23.2.3 <a href="https://timsong-cpp.github.io/cppwp/char.traits.typedefs">[char.traits.typedefs]</a> (note: including deletion of reference to 23.1!):
</p>
<blockquote><p>
<i>Requires:</i> <tt>state_type</tt> shall meet the requirements of <tt><ins>Copy</ins>Assignable</tt><del> 
(23.1)</del>, <tt>CopyConstructible</tt> (20.1.8), and <tt>DefaultConstructible</tt> types.
</p></blockquote>
<p>
Change Class seed_seq 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a> (note again: including deletion of reference to 23.1!):
</p>
<blockquote><p>
In addition to the requirements set forth below, instances of
<tt>seed_seq</tt> shall meet the requirements of <tt>CopyConstructible</tt> (20.1.8) and of <tt><ins>Copy</ins>Assignable</tt><del> (23.1)</del>.
</p></blockquote>

<p>
Note: The proposed resolution of this issue does not deal with the
instance of the term "Assignable" in 99 [auto.ptr], as this is dealt
with more specifically by LWG <a href="973">973</a>, "<tt>auto_ptr</tt> characteristics", submitted
by Maarten Hilferink.
</p>






<hr>
<h3><a name="973" href="973">973.</a> auto_ptr characteristics</h3>
<p><b>Section:</b> 99 [auto.ptr] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Maarten Hilferink <b>Opened:</b> 2009-01-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think that the Note of 99 [auto.ptr], paragraph 3 needs a rewrite 
since "Assignable" is no longer defined as a concept. 
The relationship of <tt>auto_ptr</tt> with the new <tt>CopyAssignable</tt>, <tt>MoveAssignable</tt>,
 and <tt>MoveConstructible</tt> concepts should be clarified.
Furthermore, since the use of <tt>auto_ptr</tt> is depreciated anyway,
 we can also omit a description of its intended use.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the intent of the proposed resolution.
Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 99 [auto.ptr], paragraph 3:
</p>

<blockquote><p>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the ob ject it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same ob ject at
the same time the behavior of the program is undefined. [<i>Note:</i>
The uses of <tt>auto_ptr</tt> include providing temporary
exception-safety for dynamically allocated memory, passing ownership of
dynamically allocated memory to a function, and returning dynamically
allocated memory from a function.
<del><tt>auto_ptr</tt> does not meet the
<tt>CopyConstructible</tt> and <tt>Assignable</tt> requirements for
standard library container elements and thus instantiating a standard
library container with an <tt>auto_ptr</tt> results in undefined
behavior.</del>
<p/>
<ins>Instances of <tt>auto_ptr</tt> shall
meet the <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>
requirements, but do not meet the <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt> requirements.</ins>
-- <i>end note</i>]
</p></blockquote>





<hr>
<h3><a name="977" href="977">977.</a> insert iterators inefficient for expensive to move types</h3>
<p><b>Section:</b> 25.5.2 <a href="https://timsong-cpp.github.io/cppwp/insert.iterators">[insert.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new concepts for the insert iterators mandate an extra copy when
inserting an lvalue:
</p>

<blockquote><pre>
requires CopyConstructible&lt;Cont::value_type&gt;
  back_insert_iterator&lt;Cont&gt;&amp; 
  operator=(const Cont::value_type&amp; value);
</pre>
<blockquote><p>
-1- <i>Effects:</i> <tt>push_back(*container, <b>Cont::value_type(</b>value<b>)</b>);</tt>
</p></blockquote>
</blockquote>

<p>
The reason is to convert <tt>value</tt> into an rvalue because the current
<tt>BackInsertionContainer</tt> concept only handles <tt>push_back</tt>-ing
rvalues:
</p>

<blockquote><pre>
concept BackInsertionContainer&lt;typename C&gt; : Container&lt;C&gt; { 
  void push_back(C&amp;, value_type&amp;&amp;); 
}
</pre></blockquote>

<p>
Without the conversion of <tt>value</tt> to an rvalue, the assignment operator
fails to concept check.
</p>

<p>
A solution is to modify the <tt>BackInsertionContainer</tt> concept so that
the client can pass in the parameter type for <tt>push_back</tt> similar to
what is already done for the <tt>OutputIterator</tt> concept:
</p>

<blockquote><pre>
concept BackInsertionContainer&lt;typename C, typename Value = C::value_type&amp;&amp;&gt;
  : Container&lt;C&gt; { 
     void push_back(C&amp;, Value); 
}
</pre></blockquote>

<p>
This allows the assignment operator to be adjusted appropriately:
</p>

<blockquote><pre>
requires BackInsertionContainer&lt;Cont, Cont::value_type const&amp;&gt; &amp;&amp;
         CopyConstructible&lt;Cont::value_type&gt;
  back_insert_iterator&lt;Cont&gt;&amp; 
  operator=(const Cont::value_type&amp; value);
</pre>
<blockquote><p>
-1- <i>Effects:</i> <tt>push_back(*container, value);</tt>
</p></blockquote>
</blockquote>

<p><i>[
We may want to propagate this fix to other concepts such as <tt>StackLikeContainer</tt>.
]</i></p>


<p><i>[
Solution and wording collaborated on by Doug and Howard.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard notes that "these operations behaved efficiently until concepts were added."
</p>
<p>
Alisdair is uncertain that the proposed resolution is syntactically correct.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD, solved by the removal of concepts.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change  [container.concepts.free]:
</p>

<blockquote>
<pre>
concept FrontInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  void push_front(C&amp;, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom FrontInsertion(C c, <del>value_type</del> <ins>Value</ins> x) { 
    x == (push_front(c, x), front(c)); 
  } 
}
</pre>

<p>...</p>

<pre>
concept BackInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  void push_back(C&amp;, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 
}
</pre>

<p>...</p>

<pre>
concept InsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  iterator insert(C&amp;, const_iterator, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom Insertion(C c, const_iterator position, <del>value_type</del> <ins>Value</ins> v) { 
    v == *insert(c, position, v); 
  } 
}
</pre>

</blockquote>

<p>
Change  [container.concepts.member]:
</p>

<blockquote>
<pre>
auto concept MemberFrontInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  void C::push_front(<del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom MemberFrontInsertion(C c, <del>value_type</del> <ins>Value</ins> x) { 
    x == (c.push_front(x), c.front()); 
  } 
}
</pre>

<p>...</p>

<pre>
auto concept MemberBackInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  void C::push_back(<del>value_type&amp;&amp;</del> <ins>Value</ins>); 
}
</pre>

<p>...</p>

<pre>
auto concept MemberInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  iterator C::insert(const_iterator, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom MemberInsertion(C c, const_iterator position, <del>value_type</del> <ins>Value</ins> v) { 
    v == *c.insert(position, v); 
  } 
}
</pre>
</blockquote>

<p>
Change  [container.concepts.maps]:
</p>

<blockquote>
<pre>
template &lt;MemberFrontInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map FrontInsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;

  void push_front(C&amp; c, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) { c.push_front(static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

<p>...</p>

<pre>
template &lt;MemberBackInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map BackInsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;

  void push_back(C&amp; c, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) { c.push_back(static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

<p>...</p>

<pre>
template &lt;MemberInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map InsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;
  Container&lt;C&gt;::iterator insert(C&amp; c, Container&lt;C&gt;::const_iterator i, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) 
  { return c.insert(i, static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

</blockquote>

<p>
Change 25.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/back.insert.iterator">[back.insert.iterator]</a>:
</p>

<blockquote><pre>
template &lt;BackInsertionContainer Cont&gt; 
class back_insert_iterator {
  ...
  requires <ins>BackInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    back_insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change  [back.insert.iter.op=]:
</p>

<blockquote>
<pre>
requires <ins>BackInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  back_insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote><p>
-1- <i>Effects:</i> <tt>push_back(*container, <del>Cont::value_type(</del>value<del>)</del>);</tt>
</p></blockquote>
</blockquote>

<p>
Change 25.5.2.3 <a href="https://timsong-cpp.github.io/cppwp/front.insert.iterator">[front.insert.iterator]</a>:
</p>

<blockquote><pre>
template &lt;FrontInsertionContainer Cont&gt; 
class front_insert_iterator {
  ...
  requires <ins>FrontInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    front_insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change  [front.insert.iter.op=]:
</p>

<blockquote>
<pre>
requires <ins>FrontInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  front_insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote><p>
-1- <i>Effects:</i> <tt>push_front(*container, <del>Cont::value_type(</del>value<del>)</del>);</tt>
</p></blockquote>
</blockquote>

<p>
Change 25.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/insert.iterator">[insert.iterator]</a>:
</p>

<blockquote><pre>
template &lt;InsertionContainer Cont&gt; 
class insert_iterator {
  ...
  requires <ins>InsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change  [insert.iter.op=]:
</p>

<blockquote>
<pre>
requires <ins>InsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>
iter = insert(*container, iter, <del>Cont::value_type(</del>value<del>)</del>); 
++iter;
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="979" href="979">979.</a> Bad example</h3>
<p><b>Section:</b> 25.5.4 <a href="https://timsong-cpp.github.io/cppwp/move.iterators">[move.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#move.iterators">issues</a> in [move.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.5.4 <a href="https://timsong-cpp.github.io/cppwp/move.iterators">[move.iterators]</a> has an incorrect example:
</p>

<blockquote>
<p>
-2- [<i>Example:</i>
</p>

<blockquote><pre>
set&lt;string&gt; s; 
// populate the set s 
vector&lt;string&gt; v1(s.begin(), s.end());          // copies strings into v1 
vector&lt;string&gt; v2(make_move_iterator(s.begin()), 
                  make_move_iterator(s.end())); // moves strings into v2
</pre></blockquote>

<p>
<i>-- end example</i>]
</p>
</blockquote>

<p>
One can not move from a <tt>set</tt> because the iterators return <tt>const</tt>
references.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed resolution. Move to NAD Editorial.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.5.4 <a href="https://timsong-cpp.github.io/cppwp/move.iterators">[move.iterators]</a>/2:
</p>

<blockquote>
<p>
-2- [<i>Example:</i>
</p>

<blockquote><pre>
<del>set</del><ins>list</ins>&lt;string&gt; s; 
// populate the <del>set</del><ins>list</ins> s 
vector&lt;string&gt; v1(s.begin(), s.end());          // copies strings into v1 
vector&lt;string&gt; v2(make_move_iterator(s.begin()), 
                  make_move_iterator(s.end())); // moves strings into v2
</pre></blockquote>

<p>
<i>-- end example</i>]
</p>
</blockquote>





<hr>
<h3><a name="980" href="980">980.</a> <tt>mutex lock()</tt> missing error conditions</h3>
<p><b>Section:</b> 33.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ion Gazta&ntilde;aga <b>Opened:</b> 2009-02-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
POSIX 2008 adds two return values for <tt>pthread_mutex_xxxlock()</tt>:
<tt>EOWNERDEAD</tt> (<tt>owner_dead</tt>) and <tt>ENOTRECOVERABLE</tt>
(<tt>state_not_recoverable</tt>). In the first case the mutex is locked,
in the second case the mutex is not locked.
</p>

<p>
Throwing an exception in the first case can be incompatible with the use
of Locks, since the <tt>Lock::owns_lock()</tt> will be <tt>false</tt> when the lock is
being destroyed.
</p>

<p>
Consider:
</p>

<blockquote><pre>
//Suppose mutex.lock() throws "owner_dead"
unique_lock ul(&amp;mutex);
//mutex left locked if "owner_dead" is thrown
</pre></blockquote>

<p>
Throwing an exception with <tt>owner_dead</tt> might be also undesirable if
robust-mutex support is added to C++ and the user has the equivalent of
<tt>pthread_mutex_consistent()</tt> to notify the user has fixed the corrupted
data and the mutex state should be marked consistent.
</p>

<ol>
<li>
For <tt>state_not_recoverable</tt> add it to the list of Error conditions:
</li>
<li>
For <tt>owner_dead</tt>, no proposed resolution.
</li>
</ol>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Not a defect. Handling these error conditions is an implementation
detail and must be handled below the C++ interface.
</p></blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add to 33.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>, p12:
</p>

<blockquote>
<p>
-12- <i>Error conditions:</i>
</p>

<ul>
<li>
<tt>operation_not_permitted</tt> -- if the thread does not have the necessary permission to change 
the state of the mutex.
</li>
<li>
<tt>resource_deadlock_would_occur</tt> -- if the current thread already owns the mutex and is able 
to detect it.
</li>
<li>
<tt>device_or_resource_busy</tt> --  if the mutex is already locked and blocking is not possible.
</li>
<li>
<ins><tt>state_not_recoverable</tt> -- if the state protected by the mutex is not recoverable.</ins>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="988" href="988">988.</a> <tt>Reflexivity</tt> meaningless?</h3>
<p><b>Section:</b> 99 [concept.comparison] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.comparison">issues</a> in [concept.comparison].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
99 [concept.comparison] p2:
</p>
<p>
Due to the subtle meaning of <tt>==</tt> inside axioms, the <tt>Reflexivity</tt> axiom does
not do anything as written. It merely states that a value is substitutable
with itself, rather than asserting a property of the <tt>==</tt> operator.
</p>

<p><b>
Original proposed resolution:
</b></p>

<p>
Change the definition of <tt>Reflexivity</tt> in 99 [concept.comparison]:
</p>

<blockquote><pre>
axiom Reflexivity(T a) { <ins>(</ins>a == a<ins>) == true</ins>; }
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: I was wrong.
</p>
<p>
Recommend NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
NAD.
</p>





<hr>
<h3><a name="989" href="989">989.</a> late_check and library</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The example in 6.9p2 shows how late_check blocks inhibit concept_map lookup
inside a constrained context, and so inhibit concept map adaption by users
to meet template requirements.
</p>
<p>
Do we need some text in clause 17 prohibitting use of late_check in library
template definitions unless otherwise documented?
</p>

<p><i>[
Doug adds:
]</i></p>


<blockquote><p>
We need something like this, but it should be a more general statement
about implementations respecting the concept maps provided by the
user. Use of late_check is one way in which implementations can
subvert the concept maps provided by the user, but there are other
ways as well ("pattern-based" overloading, tricks with "auto" concept
maps and defaulted associated type arguments).
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>


<blockquote><p>
Move to Open, pending proposed wording from Alisdair and/or Doug for further review.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="992" href="992">992.</a> Allow implementations to implement C library in the global namespace</h3>
<p><b>Section:</b> 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#contents">issues</a> in [contents].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK-169 [CD1]</b></p>
<p>
This phrasing contradicts later freedom to implement the C standard
library portions in the global namespace as well as std. (17.6.2.3p4)
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
The proposed wording seems to go too far.
Move back to Open.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Howard to add NB reference to the description of this issue.
</p>
<p>
Move to NAD. This comment is informative and not normative by the use of
the word "are" instead of the word "shall."
</p>
<p>
A note linking to Annex D would help clarify the intention, here.
</p>
<p>
Robert to Open a separate issue proposing that the standard C headers be
undeprecated, for the purpose of clarifying the standard.
</p>
</blockquote>

<p><i>[
2009-07-22 Bill modified the proposed wording with a clarifying footnote.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add a footnote to 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>, p2:
</p>

<blockquote>
<p>
-2- All library entities except macros, <tt>operator new</tt> and <tt>operator
delete</tt> are defined within the namespace <tt>std</tt> or namespaces
nested within namespace <tt>std</tt><ins><sup>*</sup></ins>.
</p>

<p><ins>
<sup>*</sup>The C standard library headers 99 [depr.c.headers] also define
names within the global namespace, while the C++ headers for
C library facilities 16.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a> may also define names within
the global namespace.
</ins></p>
</blockquote>






<hr>
<h3><a name="995" href="995">995.</a> Operational Semantics Unclear</h3>
<p><b>Section:</b> 16.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/structure.requirements">[structure.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.requirements">issues</a> in [structure.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As a practical matter there's disagreement on the meaning of <i>operational
semantics</i>.  If the text in 16.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/structure.requirements">[structure.requirements]</a>p4 isn't
clear, it should be clarified.  However, it's not clear whether the
disagreement is merely due to people not being aware of the text.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Agree with the recommended NAD resolution.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.  The text in 16.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/structure.requirements">[structure.requirements]</a> is
perfectly clear.
</p>





<hr>
<h3><a name="996" href="996">996.</a> Move operation not well specified</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-06 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are lots of places in the standard where we talk about "the move
constructor" but where we mean "the move operation," i.e.  <tt>T( move( x ) )</tt>.
</p>
<p>
We also don't account for whether that operation modifies <tt>x</tt> or not, and
we need to.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open, pending proposed wording from Dave for further
review.
</p></blockquote>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Move to NAD.  We define what we expect from a moved-from object in Table 34 [movesconstructible].
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1000" href="1000">1000.</a> adjacent_find is over-constrained</h3>
<p><b>Section:</b> 27.6.10 <a href="https://timsong-cpp.github.io/cppwp/alg.adjacent.find">[alg.adjacent.find]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2009-03-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.adjacent.find">issues</a> in [alg.adjacent.find].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses UK 296</b>
</p>

<p>
<tt>adjacent_find</tt> in C++03 allows an arbitrary predicate, but in C++0x
<tt>EqualityComparable/EquivalenceRelation</tt> is required. This forbids a
number of use cases, including:
</p>
<blockquote>
<table>
<tr>
<td valign="top">
<tt>adjacent_find(begin,&nbsp;end,&nbsp;less&lt;double&gt;)</tt>
</td>
<td>
Find the first
place where a range is not ordered in decreasing order - in use to check
for sorted ranges.
</td>
</tr>
<tr>
<td valign="top">
<tt>adjacent_find(begin,&nbsp;end,&nbsp;DistanceBiggerThan(6)&nbsp;)&nbsp;)</tt>
</td>
<td>
Find the first
place in a range where values differ by more than a given value - in use
to check an algorithm which produces points in space does not generate
points too far apart.
</td>
</tr>
</table>
</blockquote>

<p>
A number of books use predicate which are not equivalence relations in
examples, including "Thinking in C++" and "C++ Primer".
</p>

<p>
Adding the requirement that the predicate is an <tt>EquivalenceRelation</tt>
does not appear to open up any possibility for a more optimised algorithm.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the definition of adjacent_find in the synopsis of 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>
and 27.6.10 <a href="https://timsong-cpp.github.io/cppwp/alg.adjacent.find">[alg.adjacent.find]</a> to:
</p>

<blockquote><pre>
template&lt;ForwardIterator Iter&gt; 
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;Iter::value_type<ins>, Iter::value_type</ins>&gt;
  Iter adjacent_find(Iter first, Iter last);

template&lt;ForwardIterator Iter, <del>EquivalenceRelation</del><ins>Predicate</ins>&lt;auto, Iter::value_type<ins>, Iter::value_type</ins>&gt; Pred&gt; 
  requires CopyConstructible&lt;Pred&gt; 
  Iter adjacent_find(Iter first, Iter last, Pred pred);
</pre></blockquote>





<hr>
<h3><a name="1001" href="1001">1001.</a> Pointers, concepts and headers</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 78</b></p>

<p>
Related to <a href="1063">1063</a>.
</p>

<p>
This is effectively an extension of LWG issue <a href="343">343</a>.
</p>
<p>
We know there is an increasing trend (encouraged by conformance testers and
some users) that each library header should supply no more than required to
satisfy the synopsis in the standard.  This is typically achieved by
breaking larger headers into smaller subsets, and judicious use of forward
declarations.
</p>
<p>
If we apply this policy to C++0x (per
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>)
it will be very surprising for
people using library algorithms over ranges defined by pointers that they
must <tt>#include &lt;iterator_concepts&gt;</tt> for their code to compile again.  That is
because pointers do not satisfy any of the iterator concepts without the
<tt>concept_map</tt> supplied in this header.
</p>
<p>
Therefore, I suggest we should require all library headers that make use of
iterator concepts are specifically required to <tt>#include &lt;iterator_concepts&gt;</tt>.
</p>
<p>
At a minimum, the list of headers would be: (assuming all are constrained by
concepts)
</p>
<blockquote><pre>
algorithm
array
deque
forward_list
initializer_list
iterator
locale
list
map
memory          // if <a href="1029">1029</a> is adopted
memory_concepts
numeric
random
regex
set
string
tuple
unordered_map
unordered_set
utility
vector
</pre></blockquote>

<p><i>[
Ganesh adds:
]</i></p>


<blockquote>
<p>
The same problems exists for <tt>&lt;memory_concepts&gt;</tt> and
<tt>&lt;container_concepts&gt;</tt>.
</p>
<p>
In order to compile <tt>&lt;vector&gt;</tt> you just need the
definitions of the concepts in <tt>&lt;memory_concepts&gt;</tt>, the
concept maps defined there are not necessary. Yet, from the user point
of view, if the concept map template for <tt>AllocatableElement</tt> are
not in scope, <tt>&lt;vector&gt;</tt> is pretty useless. Same for
<tt>&lt;tuple&gt;</tt> and <tt>ConstructibleWithAllocator</tt>.
</p>
<p>
Similarly, <tt>&lt;queue&gt;</tt> is not very useful if the concept map
template for <tt>QueueLikeContainer</tt> is not in scope, although the
definition of concept alone is theoretically sufficient.
</p>
<p>
There's a pattern here: if a concept has concept maps "attached", they
should never be separated.
</p>
</blockquote>

<p><i>[
Beman provided the proposed resolution for the May 2009 mailing. He 
comments:
]</i></p>


<blockquote>

<p>Initially I tried to specify exactly what header should include what other 
headers. This was verbose, error prone, hard to maintain, and appeared to add 
little value compared to just stating the general rule.</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes the proposed wording overconstrains implementers.
Instead of specifying the mechanism,
he prefers a solution that spells out what needs to be declared,
rather than how those declarations are to be provided,
e.g.,
</p>
<blockquote><p>
A C++ header shall provide the names
that are required to be defined in that header.
</p></blockquote>
<p>
Bill suggests approaching the wording from a programmer's perspective.
We may want to consider promising that certain widely-used headers
(e.g., the concept headers) are included when needed by other headers.
He feels, however, there is nothing broken now,
although we may want to consider "something nicer."
</p>
<p>
Move to Open status.
</p>

</blockquote>

<p><i>[
2009-06-16 Beman updated the proposed resolution:
]</i></p>


<blockquote>
  <ul>
    <li>The mechanism is no longer specified, as requested in Batavia.</li>
    <li>The footnote has been removed since it specified mechanism and also did 
    not reflect existing practice.</li>
    <li>A sentence was added that makes it clear that the existing practice is 
    permitted.</li>
  </ul>
</blockquote>

<p><i>[
2009-07-15 Beman updated the proposed resolution:
]</i></p>


<p><i>[
2009-07-17 Beman updated the proposed resolution based on feedback from the LWG in Frankfurt:
]</i></p>


<blockquote>
<ul>
<li>Strike two pieces of text considered unnecessary.</li>
<li>Change &quot;definitions&quot; to &quot;declarations and definitions&quot; in two places.</li>
<li>Wording tightened slightly.</li>
</ul>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Revised Proposed Resolution:
</p>
<p>
A C++ header may include other C++ headers. A C++ header shall provide
the declarations and definitions that appear in its synopsis (3.2
[basic.def.odr]). A C++ header shown in its synopsis as including other
C++ headers shall provide the declarations and definitions that appear
in the synopses of those other headers.
</p>
<p>
Alisdair: Does this address the BSI comment?
<p/>
Beman: There were several overlapping comments. I tried to handle them
all with one resolution.
<p/>
Alisdair: I'd prefer to see this closed as NAD and have this resolution
be the subject of some other, new issue.
<p/>
Move to NAD Concepts. Howard to open a new issue (<a href="1178">1178</a>) in Ready state with the
Proposed Resolution above. Beman will write up a discussion for the new
issue.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>Change 16.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/res.on.headers">[res.on.headers]</a>, Headers, paragraph 1, as indicated:</i></p>

<blockquote>

<p>
A C++ header may include other C++
headers.<del><sup>[footnote]</sup></del> <ins>A C++ header shall provide
the declarations and definitions that appear in its synopsis
(6.3 <a href="https://timsong-cpp.github.io/cppwp/basic.def.odr">[basic.def.odr]</a>). A C++ header shown in its synopsis as including 
other C++ headers shall provide the same declarations and definitions as
if those other headers were included.</ins>
</p>

  <p><del><sup>[footnote]</sup> C++ headers must include a C++ header that contains 
  any needed definition (3.2).</del></p>
</blockquote>






<hr>
<h3><a name="1002" href="1002">1002.</a> Provide bulk include headers</h3>
<p><b>Section:</b> 16.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK-170 [CD1]</b></p>

<p>
One of goals of C++0x is to make language easier to teach and for
'incidental' programmers. The fine-grained headers of the C++ library
are valuable in large scale systems for managing dependencies and
optimising build times, but overcomplicated for simple development and
tutorials. Add additional headers to support the whole library through a
single include statement.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We do not all agree that this is an issue,
but we agree that if it needs solving this is the right way to do it.
Move to Tentatively Ready.
</p></blockquote>

<p><i>[
2009-07-06 Beman notes:
]</i></p>


<blockquote>
<p>
This issue
adds a header <tt>&lt;std&gt;</tt>.
</p>
<p>
There is a paper to be looked at,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>
Aggregation headers, that adds
a header <tt>&lt;std-all&gt;</tt> that is the same thing except it excludes
deprecated headers.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>
also proposes a second aggregation header.
</p>
<p>
Seems like this issue should be held in abeyance until the LWG has had
a chance to look at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>.
</p>
</blockquote>

<p><i>[
2009-07-06 Howard:  I've pulled this issue back to Review.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
No consensus for change.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph in 16.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a> between p4 and p5
</p>
<blockquote><p>
An additional header <tt>&lt;std&gt;</tt> shall have the effect of
supplying the entire standard library.  [<i>Note:</i> for example, it
might be implemented as a file with an <tt>#include</tt> statement for each of the
headers listed in tables 13 and 14. <i>-- end note</i>]
</p></blockquote>





<hr>
<h3><a name="1003" href="1003">1003.</a> Require more useful headers for freestanding implementations</h3>
<p><b>Section:</b> 16.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 23 [CD1]</b></p>

<p>
There is a freestanding implementation including
<tt>&lt;type_traits&gt;</tt>, <tt>&lt;array&gt;</tt>,
<tt>&lt;ratio&gt;</tt>, lately added to Table 13, C++ library headers.
Programmers think them useful and hope that these headers are also added
to Table 15, C++ headers for freestanding implementations, that shows
the set of headers which a freestanding implementation shall include at
least.
</p>

<p><b>Original proposed resolution</b></p>

<p>
Add <tt>&lt;type_traits&gt;</tt>, <tt>&lt;array&gt;</tt>,
<tt>&lt;ratio&gt;</tt> to Table 15.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
 The <tt>&lt;array&gt;</tt> header has far too many dependencies to require for a
free-standing implementation.
</p>
<p>
The <tt>&lt;ratio&gt;</tt> header would be useful, has no dependencies, but is not
strictly necessary.
</p>
<p>
The <tt>&lt;type_traits&gt;</tt> header is fundamentally a core language facility with a
library interface, so should be supported.
</p>

<p>
(it is anticipated the resolution will come via an update to paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>)
(see also LWG <a href="833">833</a>)
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Leave in Review status pending a paper on freestanding implementations
by Martin Tasker.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Move this to NAD.
</p>
<p>
We considered all of the listed headers, and found a compelling case
only for the inclusion of <tt>&lt;type_traits&gt;</tt> in the list of headers required
of a freestanding implementation.
</p>
<p>
See Martin Tasker's paper 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2932.pdf">Fixing Freestanding</a>
which provides the wording to include <tt>&lt;type_traits&gt;</tt> into freestanding
implementations.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>&lt;type_traits&gt;</tt> to Table 15.
</p>





<hr>
<h3><a name="1005" href="1005">1005.</a> <tt>numeric_limits</tt> partial specializations not concept enabled</h3>
<p><b>Section:</b> 17.3.5 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.limits">active issues</a> in [numeric.limits].</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits">issues</a> in [numeric.limits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 26</b></p>

<p>
<tt>numeric_limits</tt> [partial specializations] does not use concept.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Alisdair will provide a solution as part of treatment of axioms and LWG <a href="902">902</a>.
</p></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote><p>
Alisdair recommends NAD as the partial specializations are already
constrained by requirements on the primary template.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
The Working Draft does not in general repeat a primary template's constraints
in any specializations.
Move to NAD.
</p></blockquote>

<p><i>[
2009-05-25 Howard adds:
]</i></p>


<blockquote><p>
A c++std-lib thread starting at c++std-lib-23880 has cast doubt that NAD is the
correct resolution of this issue.  Indeed the discussion also casts doubt that
the current proposed wording is the correct resolution as well.  Personally I'm
inclined to reset the status to Open.  However I'm reverting the status to 
that which it had prior to the Batavia recommendation.  I'm setting back to Review.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 17.3.5 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a>:
</p>

<blockquote><pre>
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;const T&gt;;
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;volatile T&gt;;
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;const volatile T&gt;;
</pre></blockquote>






<hr>
<h3><a name="1007" href="1007">1007.</a> <tt>throw_with_nested</tt> not concept enabled</h3>
<p><b>Section:</b> 17.10.8 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 29</b></p>

<p>
<tt>throw_with_nested</tt> does not use concept.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote><p>
Agreed.
</p></blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Alisdair initially proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf">N2619</a>.
</p>
<p>
We are awaiting an updated paper based on feedback from the San Francisco
review.
</p>





<hr>
<h3><a name="1008" href="1008">1008.</a> <tt>nested_exception</tt> wording unclear</h3>
<p><b>Section:</b> 17.10.8 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 31</b></p>

<p>
It is difficult to understand in which case <tt>nested_exception</tt> is applied.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote><p>
Alisdair will add an example in an update to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf">N2619</a>.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
It doesn't appear that N2619 really addresses this. Alisdair to propose wording.
</p></blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Mark issue 1008 as NAD, the type is adequately described.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
nested_exception is intended to be inherited from by exception classes
that are to be thrown during the handling of another exception, i.e.
when translating from one exception type to another. nested_exception
allows the originally thrown exception to be easily retained in that
scenario.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1009" href="1009">1009.</a> <tt>InputIterator</tt> post-increment dangerous</h3>
<p><b>Section:</b> 25.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.iterators">[iterator.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.iterators">issues</a> in [iterator.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 251</b></p>

<p>
The post-increment operator is dangerous for a general InputIterator.
The multi-pass guarantees that make it meaningful are defined as part of
the ForwardIterator refinement. Any change will affect only constrained
templates that have not yet been written, so should not break existing
user iterators which remain free to add these operations. This change
will also affect the generalised OutputIterator, although there is no
percieved need for the post-increment operator in this case either.
</p>

<p><i>[
2009-07-28 Alisdair adds:
]</i></p>


<blockquote><p>
We still think the issue is relevant, but needs totally rewording in
non-concept language.  We would like to see the issue retained as Open,
rather than deferred as NAD Concepts.  Review status is no longer
appropriate.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD.  Without concepts we do not feel that input iterator post increment
is broken.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.iterators">[iterator.iterators]</a>:
</p>

<blockquote><pre>
concept Iterator&lt;typename X&gt; : Semiregular&lt;X&gt; { 
  MoveConstructible reference = typename X::reference; 
  <del>MoveConstructible postincrement_result;</del>

  <del>requires HasDereference&lt;postincrement_result&gt;;</del>

  reference operator*(X&amp;&amp;); 
  X&amp; operator++(X&amp;); 
  <del>postincrement_result operator++(X&amp;, int);</del>
}
</pre>

<p>...</p>
<pre>
<del>postincrement_result operator++(X&amp; r, int);</del>
</pre>

<blockquote><p>
<del>-3- <i>Effects:</i> equivalent to <tt>{ X tmp = r; ++r; return tmp; }</tt>.</del>
</p></blockquote>

</blockquote>

<p>
Change 25.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>:
</p>

<blockquote>
<pre>
concept InputIterator&lt;typename X&gt; : Iterator&lt;X&gt;, EqualityComparable&lt;X&gt; { 
  ObjectType value_type = typename X::value_type; 
  MoveConstructible pointer = typename X::pointer; 

  SignedIntegralLike difference_type = typename X::difference_type; 

  requires IntegralType&lt;difference_type&gt; 
        &amp;&amp; Convertible&lt;reference, const value_type &amp;&gt;; 
        &amp;&amp; Convertible&lt;pointer, const value_type*&gt;; 

  <del>requires Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;</del>

  pointer operator-&gt;(const X&amp;); 
}
</pre>
</blockquote>

<p>
Change 25.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>:
</p>

<blockquote>
<pre>
auto concept OutputIterator&lt;typename X, typename Value&gt; { 
  requires Iterator&lt;X&gt;; 

  typename reference = Iterator&lt;X&gt;::reference; 
  <del>typename postincrement_result = Iterator&lt;X&gt;::postincrement_result;</del>
  requires SameType&lt;reference, Iterator&lt;X&gt;::reference&gt; 
        <del>&amp;&amp; SameType&lt;postincrement_result, Iterator&lt;X&gt;::postincrement_result&gt;</del>
        <del>&amp;&amp; Convertible&lt;postincrement_result, const X&amp;&gt;</del>
        &amp;&amp; HasAssign&lt;reference, Value&gt; 
        <del>&amp;&amp; HasAssign&lt;HasDereference&lt;postincrement_result&gt;::result_type, Value&gt;</del>;
}
</pre>
</blockquote>

<p>
Change 25.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a>:
</p>

<p><i>[
See <a href="1084">1084</a> which is attempting to change this same area in a compatible
way.
]</i></p>


<blockquote>
<pre>
concept ForwardIterator&lt;typename X&gt; : InputIterator&lt;X&gt;, Regular&lt;X&gt; { 
  <del>requires Convertible&lt;postincrement_result, const X&amp;&gt;;</del>

  <ins>MoveConstructible postincrement_result;</ins>
  <ins>requires HasDereference&lt;postincrement_result&gt;
        &amp;&amp; Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;</ins>

  <ins>postincrement_result operator++(X&amp;, int);</ins>

  axiom MultiPass(X a, X b) { 
    if (a == b) *a == *b; 
    if (a == b) ++a == ++b; 
  } 
}
</pre>

<blockquote>
<p>-4- ...</p>
</blockquote>

<pre>
<ins>postincrement_result operator++(X&amp; r, int);</ins>
</pre>

<blockquote>
<p>
<ins>-5- <i>Effects:</i> equivalent to <tt>{ X tmp = r; ++r; return tmp; }</tt>.</ins>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1010" href="1010">1010.</a> <tt>operator-=</tt> should use default in concept</h3>
<p><b>Section:</b> 25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 263</b></p>

<p>
This requirement on <tt>operator-=</tt> would be better expressed as a default
implementation in the concept, with a matching axiom.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
The proposed resolution should also remove
paragraph 5 and the declaration that precedes it.
Further, we should provide an axiom
that captures the desired semantics.
This may be a broader policy to be applied.
Move to Open.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>:
</p>

<blockquote><pre>
concept RandomAccessIterator&lt;typename X&gt; : BidirectionalIterator&lt;X&gt;, LessThanComparable&lt;X&gt; {
  ...
  X&amp; operator-=(X&amp; <ins>x</ins>, difference_type <ins>n</ins>)<ins> { return x += -n</ins>;<ins> }</ins>
  ...
}
</pre></blockquote>






<hr>
<h3><a name="1013" href="1013">1013.</a> Remove <tt>IsSameType</tt> hold-over constraints</h3>
<p><b>Section:</b> 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 305</b></p>

<p>
The negative requirement on <tt>IsSameType</tt> is a hold-over from an earlier
draught with a variadic template form of <tt>min/max</tt> algorith. It is no
longer necessary.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
We believe this is NAD, but this needs to be reviewed against the
post-remove-concepts draft.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>:
</p>

<blockquote><pre>
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre></blockquote>

<p>
Change 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a>, p1, p9 and p17:
</p>

<blockquote><pre>
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre></blockquote>






<hr>
<h3><a name="1015" href="1015">1015.</a> C++ programs - but not users - need to provide support <tt>concept_map</tt>s</h3>
<p><b>Section:</b> 99 [concept.transform] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.transform">issues</a> in [concept.transform].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 199</b></p>

<p>
The requirement that programs do not supply <tt>concept_maps</tt> should
probably be users do not supply their own <tt>concept_map</tt>
specializations. The program will almost certainly supply
<tt>concept_maps</tt> - the standard itself supplies a specialization
for <tt>RvalueOf</tt> references. Note that the term <i>program</i> is
defined in 6.6 <a href="https://timsong-cpp.github.io/cppwp/basic.link">[basic.link]</a>p1 and makes no account of the
standard library being treated differently to user written code.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
The same problem is present in the words added for the
<tt>LvalueReference/RvalueReference</tt> concepts last meeting.
</p>
<p>
With three subsections requiring the same constraint, I'm wondering if there
is a better way to organise this section.
Possible 20.2.1 -&gt; 20.2.3 belong in the fundamental concepts clause in
 [concept.support]?  While they can be implemented purely as a
library feature without additional compiler support, they are pretty
fundamental and we want the same restriction on user-concept maps as is
mandated there.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the issue,
but believe the wording needs further improvement.
We want to investigate current definitions for nomenclature such as
"user" and "program."
Move to Open pending the recommended investigation.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 99 [concept.transform] p2:
</p>

<blockquote><p>
-2- A <del>program</del> <ins>user</ins> shall not provide concept maps for
any concept in 20.1.1.
</p></blockquote>

<p>
Change  [concept.true] p2:
</p>

<blockquote><p>
-2- <i>Requires:</i> a <del>program</del> <ins>user</ins> shall not
provide a concept map for the <tt>True</tt> concept.
</p></blockquote>

<p>
Change  [concept.classify] p2:
</p>

<blockquote><p>
-2- <i>Requires:</i> a <del>program</del><ins>user</ins> shall not provide concept
maps for any concept in this section.
</p></blockquote>






<hr>
<h3><a name="1016" href="1016">1016.</a> Provide <tt>LessThanComparable</tt> and <tt>EqualityComparable</tt> for <tt>FloatingPointType</tt></h3>
<p><b>Section:</b> 99 [concept.comparison] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.comparison">issues</a> in [concept.comparison].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 33</b></p>

<p>
<tt>LessThanComparable</tt> and <tt>EqualityComparable</tt> don't correspond to NaN. 
</p>

<p><b>Original proposed resolution:</b></p>

<p>
Apply <tt>concept_map</tt> to these concepts at <tt>FloatingPointType</tt>.
</p>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
I don't understand the proposed resolution - there is no such thing as a
'negative' concept_map, and these concepts are auto concepts that match
float/double etc. Also not clear how we are supposed to match values to
concepts.
</p>
<p>
Recommend NAD and treat as a subset of issue <a href="902">902</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>





<hr>
<h3><a name="1017" href="1017">1017.</a> Floating-point types should not satisfy <tt>Regular</tt></h3>
<p><b>Section:</b> 99 [concept.regular] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 66</b></p>

<p>
Application of the <tt>Regular</tt> concept to floating-point types appears to be
controversial (see long discussion on std-lib reflector). 
</p>

<p><b>Original proposed resolution:</b></p>

<p>
State that the <tt>Regular</tt> concept does not apply to floating-point types. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Recommend that we handle the same as JP 33 / <a href="1016">1016</a>.
</p>
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
Recommend Open, and review after resolution of <a href="902">902</a> and revised axiom
feature.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1018" href="1018">1018.</a> Trait specifications should be expressed in terms of concepts</h3>
<p><b>Section:</b> 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 70 [CD1]</b></p>

<p>
Specifications now expressed via narrative text are more accurately and
clearly expressed via executable code.
</p>
<p>
Wherever concepts are available that directly match this section's type
traits, express the traits in terms of the concepts instead of via
narrative text. Where the type traits do not quite match the
corresponding concepts, bring the two into alignment so as to avoid two
nearly-identical notions.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
We think that this is a good idea, but it requires a lot of work. If someone
submits a paper proposing specific changes, we would be happy to review it
at the next meeting.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1020" href="1020">1020.</a> Restore <tt>aligned_union</tt></h3>
<p><b>Section:</b> 21.3.8.7 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 204 [CD1]</b></p>

<p>
It is not possible to create a variant union based on a parameter pack
expansion, e.g. to implement a classic discriminated union template. 
</p>

<p><b>Original proposed resolutuion:</b></p>

<p>
Restore <tt>aligned_union</tt> template that was removed by LWG issue <a href="856">856</a>. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Agree. The need for <tt>aligned_union</tt> is compelling enough to reinstate.
</p></blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote><p>
Paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2843.html">N2843</a>
proposes an extension to the <tt>[[align]]</tt> attribute
that further diminishes the need for this template.  Recommend NAD.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark NAD as suggested.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1022" href="1022">1022.</a> Pointer-safety API has nothing to do with smart pointers</h3>
<p><b>Section:</b> 99 [util.dynamic.safety] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.dynamic.safety">issues</a> in [util.dynamic.safety].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 212 [CD1]</b></p>

<p>
The pointer-safety API is nothing to do with smart pointers, so does not
belong in  [util.smartptr]. In fact it is a set of language
support features are really belongs in clause  [language.support], 
with the contents declared in a header that deals with language-support 
of memory management.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Agree in principle, but not with the proposed resolution. We believe it
belongs either a subsection of either 22 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a> or 
20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a> as part of the general reorganization of 
22 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a>. The declaration should stay in <tt>&lt;memory&gt;</tt>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1023" href="1023">1023.</a> Unclear inheritance relation for <tt>std::function</tt></h3>
<p><b>Section:</b> 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 22 [CD1]</b></p>

<p>Related to issue <a href="1114">1114</a>.</p>

<p>
The conditions for deriving from <tt>std::unary_function</tt> and
<tt>std::binary_function</tt> are unclear: The condition would also be satisfied if
<tt>ArgTypes</tt> were <tt>std::vector&lt;T1&gt;</tt>, because it (arguably)
"contains" <tt>T1</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Agree. <tt>std::reference_wrapper</tt> has the same structure, and we
suggest that <tt>std::function</tt> be presented in the same way as
<tt>std::reference_wrapper</tt>.
</p></blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote><p>
Phrasing should be "publicly and unambiguously derived from" and probably back in 
<tt>reference_wrapper</tt> too.  Updated wording supplied.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed wording.
Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
(no changes to <tt>&lt;functional&gt;</tt> synopsis required)
</p>

<p>
Change synopsis in Class template function 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>:
</p>

<blockquote><pre>
template&lt;Returnable R, CopyConstructible... ArgTypes&gt; 
class function&lt;R(ArgTypes...)&gt; 
  : public unary_function&lt;T1, R&gt;      // <del><i>iff</i> sizeof...(ArgTypes) == 1 <i>and</i></del> <ins><i>see below</i></ins>
                                      <del>// ArgTypes <i>contains</i> T1</del>
  : public binary_function&lt;T1, T2, R&gt; // <del><i>iff</i> sizeof...(ArgTypes) == 2 <i>and</i></del> <ins><i>see below</i></ins>
                                      <del>// ArgTypes <i>contains</i> T1 <i>and</i> T2</del>
{
   ...
</pre></blockquote>

<p>
Add new p1/p2 before 22.10.17.3.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a>:
</p>

<blockquote>
<p><ins>
The template instantiation <tt>function&lt;R(T1)&gt;</tt> shall be publicly and
unambiguously derived from 
<tt>std::unary_function&lt;T1,R&gt;</tt> if and only if the template type parameter
is a function type taking one argument of type <tt>T1</tt> and returning <tt>R</tt>.
</ins></p>

<p><ins>
The template instantiation <tt>function&lt;R(T1,T2)&gt;</tt> shall be publicly and
unambiguously derived from 
<tt>std::binary_function&lt;T1,T2,R&gt;</tt> if and only if the template type
parameter is a function type taking two arguments of type <tt>T1</tt> and <tt>T2</tt> and
returning <tt>R</tt>.
</ins></p>

<pre>
explicit function();
</pre>
</blockquote>






<hr>
<h3><a name="1024" href="1024">1024.</a> <tt>std::function</tt> constructors overly generous</h3>
<p><b>Section:</b> 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 39 [CD1]</b></p>

<p>
There are no requires corresponding to <tt>F</tt> of <tt>std::function</tt>.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote><p>
<a href="1070">1070</a> removes the second constructor.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed resolution.
Move to Tentatively Ready.
If issue <a href="1070">1070</a> is accepted,
the changes to the second constructor
in this issue are moot.
</p></blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Constructors have no definition.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Correct as follows in 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> (class definition)
</p>

<blockquote><pre>
 template&lt;class F, Allocator Alloc&gt;
   <ins>requires ConstructibleWithAllocator&lt;F, Alloc&gt;
     &amp;&amp; call=Callable&lt;F, ArgTypes...&gt;
     &amp;&amp; Convertible&lt;call::result_type, R&gt;</ins>
   function(allocator_arg_t, const Alloc&amp;, F);
 template&lt;class F, Allocator Alloc&gt;
   <ins>requires ConstructibleWithAllocator&lt;F,Alloc&gt;
     &amp;&amp; call=Callable&lt;F, ArgTypes...&gt;
     &amp;&amp; Convertible&lt;call::result_type, R&gt;</ins>
   function(allocator_arg_t, const Alloc&amp;, F&amp;&amp;);
</pre></blockquote>






<hr>
<h3><a name="1025" href="1025">1025.</a> The library should provide more specializations for <tt>std::hash</tt></h3>
<p><b>Section:</b> 22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2020-08-21 17:35:46 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 208 [CD1]</b></p>

<p>
<tt>std::hash</tt> should be implemented for much more of the standard
library. In particular for <tt>pair</tt>, <tt>tuple</tt> and all the
standard containers.
</p>

<p><i>[2020-05-28; LEWG issue reviewing]</i></p>

<p>
At the Kona 2017 LEWG issue processing session, this issue was marked as NAD. The formatting of the 
<a href="http://wiki.edg.com/bin/view/Wg21kona2017/LWGissuesInLEWGStatus">LWGissuesInLEWGStatus page</a> 
ran 1025 into other text. A search of the page yields: 
</p>
<blockquote>
<pre>
1025 20.14.15 [unord.hash] The library should provide more specializations for std::hash

NAD: We don't want to do this before solving LEWG21.
</pre>
</blockquote>
<p>
Status change to Open.
</p>
<p><i>[2020-08-21 Issue processing telecon: follow LEWG recommendation. Status changed: Open &rarr; NAD Future.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1026" href="1026">1026.</a> Smart pointers need to be concept-constrained templates</h3>
<p><b>Section:</b> 20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 209 [CD1]</b></p>

<p>
Smart pointers cannot be used in constrained templates.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We understand that a paper is forthcoming.
</p></blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote><p>
<tt>shared_ptr&lt;T&gt;</tt> and <tt>weak_ptr&lt;T&gt;</tt> support all
types <tt>T</tt> for which <tt>T*</tt> is valid. In other words, a
possible (partial) resolution is to change class <tt>T</tt> to
<tt>PointeeType T</tt> for <tt>shared_ptr</tt>, <tt>weak_ptr</tt> and
possibly <tt>enable_shared_from_this</tt>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1027" href="1027">1027.</a> <tt>std::allocator</tt> needs to be a concept-constrained template</h3>
<p><b>Section:</b> 20.2.10 <a href="https://timsong-cpp.github.io/cppwp/default.allocator">[default.allocator]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#default.allocator">issues</a> in [default.allocator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 213 [CD1]</b></p>

<p>
<tt>std::allocator</tt> should be constrained to simplify its use on constrained
contexts. This library component models allocation from free store via the
new operator so choose constraints to 
match. The Allocator concept allows for a wider variety of allocators that
users may choose to supply if their allocation model does not require
operator new, without impacting the 
requirements of this template. 
</p>

<p>
Suggested direction:
</p>
<p>
The primary allocator template should be constrained to require
<tt>ObjectType&lt;T&gt;</tt> and <tt>FreeStoreAllocatable&lt;T&gt;</tt>.
Further operations to be constrained as required.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Agree as stated. A future paper will address additional related issues.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1028" href="1028">1028.</a> <tt>raw_storage_iterator</tt> needs to be a concept-constrained template</h3>
<p><b>Section:</b> 99 [depr.storage.iterator] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2017-06-15 20:30:48 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.storage.iterator">issues</a> in [depr.storage.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 214 [CD1]</b></p>

<p>
<tt>raw_storage_iterator</tt> needs constraining as an iterator adaptor to be safely
used in constrained templates 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We look forward to a paper on this topic. We recommend no action until a
paper is available.
</p></blockquote>

<p><i>[
Post Summit Alisdair provided wording and rationale.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a> p2
</p>
<p>
Update the synopsis for <tt>&lt;memory&gt;</tt>
</p>
<blockquote><pre>
// 20.7.8, raw storage iterator:
template &lt;<del>class</del> <ins>ForwardIterator</ins> Out<del>put</del>Iter<del>ator</del>, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires OutputIterator&lt; OutIter, T &gt;</ins>
    class raw_storage_iterator;

<ins>template &lt;ForwardIterator OutIter, ObjectType T&gt; 
  requires OutputIterator&lt; OutIter, T &gt;
  concept_map Iterator&lt;raw_storage_iterator&lt; OutIter, T &gt; &gt; { }</ins>
</pre></blockquote>


<p>
 [storage.iterator] p1
</p>
<p>
Replace class template definition with:
</p>
<blockquote><pre>
namespace std { 
  template &lt;<del>class</del> <ins>ForwardIterator</ins> Out<del>put</del>Iter<del>ator</del>, <del>class</del> <ins>ObjectType</ins> T&gt; 
    <ins>requires OutputIterator&lt; OutIter, T &gt;</ins>
  class raw_storage_iterator 
    : public iterator&lt;output_iterator_tag,void,void,void,void&gt; { 
  public: 
    explicit raw_storage_iterator(Out<del>put</del>Iter<del>ator</del> x); 

    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator*(); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator=(const T&amp; element); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator++(); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del> operator++(int); 
  }; 

  <ins>template &lt;ForwardIterator OutIter, ObjectType T&gt; 
    requires OutputIterator&lt; OutIter, T &gt;
    concept_map Iterator&lt;raw_storage_iterator&lt; OutIter, T &gt; &gt; { }</ins>
}
</pre></blockquote>


<p><b>Rationale:</b></p>
<p>
<tt>raw_storage_iterator</tt> has to adapt a <tt>ForwardIterator</tt>,
rather than just an <tt>InputIterator</tt> for two reasons:
</p>

<ol style="list-style-type:lower-roman">
<li>
The initial iterator passed by value is expected to remain valid,
pointing to the initialized region of memory.
</li>
<li>
to avoid breaking the declaration of post-increment operator which would
require some kind of proxy formulation to support generalised InputIterators.
</li>
</ol>






<hr>
<h3><a name="1029" href="1029">1029.</a> Specialized algorithms for memory management need to be concept-constrained templates</h3>
<p><b>Section:</b> 27.11 <a href="https://timsong-cpp.github.io/cppwp/specialized.algorithms">[specialized.algorithms]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#specialized.algorithms">active issues</a> in [specialized.algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 210 [CD1]</b></p>

<p>Related to <a href="582">582</a></p>

<p>
Specialized algorithms for memory management need requirements to be
easily usable in constrained templates.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We look forward to a paper on this topic. We recommend no action until a
paper is available.
</p></blockquote>

<p><i>[
Post Summit Alisdair provided wording.
]</i></p>


<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Daniel adds:
</p>

<blockquote>
<ol>
<li>
I suggest <tt>Size</tt> should require <tt>IntegralLike</tt> and not <tt>UnsignedIntegralLike</tt>,
because otherwise simple int-literals could not be provided as arguments
and it would conflict with other algorithms that only require <tt>IntegralLike</tt>.
</li>
<li>
<p>
The current for-loop-test relies on evaluation in boolean context which is
not provided by <tt>ArithmeticLike</tt> and it's refinements. I propose to change the
corresponding for-loop-headers to:
</p>
<ol style="list-style-type:lower-alpha">
<li>
for <tt>uninitialized_copy_n</tt>: <tt>for ( ; n &gt; Size(0); ++result, ++first, --n) {</tt>
</li>
<li>
for <tt>uninitialized_fill_n</tt>: <tt>for (; n &gt; Size(0); ++first, --n) {</tt>
</li>
</ol>
</li>
</ol>
</blockquote>

<p>
Alisdair adds:
</p>
<blockquote><p>
For the record I agree with Daniel's suggestion.
</p></blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a> p2
</p>
<p>
Update the synopsis for <tt>&lt;memory&gt;</tt>
</p>
<blockquote><pre>
template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
         <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
   <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
   <del>ForwardIterator</del> <ins>OutIter</ins>
   uninitialized_copy(<del>InputIterator</del> <ins>InIter</ins> first, <del>InputIterator</del> <ins>InIter</ins> last, 
                      <del>ForwardIterator</del> <ins>OutIter</ins> result);

template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
          <del>class</del> <ins>IntegralLike</ins> Size,
          <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
  <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
  <del>ForwardIterator</del> <ins>OutIter</ins>
  uninitialized_copy_n(<del>InputIterator</del> <ins>InIter</ins> first, Size n, 
                       <del>ForwardIterator</del> <ins>OutIter</ins> result);

template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>ObjectType</ins> T&gt;
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void uninitialized_fill(<del>ForwardIterator</del> <ins>Iter</ins> first, <del>ForwardIterator</del> <ins>Iter</ins> last, 
                          const T&amp; x);

template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>IntegralLike</ins> Size, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void
  uninitialized_fill_n(<del>ForwardIterator</del> <ins>Iter</ins> first, Size n, const T&amp; x);
</pre></blockquote>

<p>
Update as follows:
</p>

<p>
uninitialized_copy 27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a>
</p>

<blockquote><pre>
template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
         <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
   <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
   <del>ForwardIterator</del> <ins>OutIter</ins>
   uninitialized_copy(<del>InputIterator</del> <ins>InIter</ins> first, <del>InputIterator</del> <ins>InIter</ins> last, 
                      <del>ForwardIterator</del> <ins>OutIter</ins> result);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>
for (; first != last; ++result, ++first)  {
   new (static_cast&lt;void*&gt;(&amp;*result))
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>OutIter</ins>::value_type(*first);
}
</pre></blockquote>

<p>
-2- <i>Returns:</i> <tt>result</tt>
</p>

</blockquote>

<pre>
template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
          <del>class</del> <ins>IntegralLike</ins> Size,
          <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
  <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
  <del>ForwardIterator</del> <ins>OutIter</ins>
  uninitialized_copy_n(<del>InputIterator</del> <ins>InIter</ins> first, Size n, 
                       <del>ForwardIterator</del> <ins>OutIter</ins> result);
</pre>

<blockquote>
<p>
-3- Effects:
</p>
<blockquote><pre>
for ( ; n &gt; <ins>Size(</ins>0<ins>)</ins>; ++result, ++first, --n) {
   new (static_cast&lt;void*&gt;(&amp;*result))
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>OutIter</ins>::value_type(*first);
}
</pre></blockquote>
<p>
-4- <i>Returns:</i> result
</p>
</blockquote>

</blockquote>


<p>
uninitialized_fill 27.11.7 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.fill">[uninitialized.fill]</a>
</p>

<blockquote><pre>
template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>ObjectType</ins> T&gt;
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void uninitialized_fill(<del>ForwardIterator</del> <ins>Iter</ins> first, <del>ForwardIterator</del> <ins>Iter</ins> last, 
                          const T&amp; x);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>
for (; first != last; ++first) {
   new ( static_cast&lt;void*&gt;( &amp;*first) ) 
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>Iter</ins>::value_type(x);
}
</pre></blockquote>
</blockquote>
</blockquote>


<p>
uninitialized_fill_n  [uninitialized.fill.n]
</p>

<blockquote><pre>
template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>IntegralLike</ins> Size, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void
  uninitialized_fill_n(<del>ForwardIterator</del> <ins>Iter</ins> first, Size n, const T&amp; x);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>
for (; n<del>--</del> <ins>&gt; Size(0)</ins>; ++first<ins>, --n</ins>) {
   new ( static_cast&lt;void*&gt;( &amp;*first) ) 
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>Iter</ins>::value_type(x);
}
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="1031" href="1031">1031.</a> Need <tt>shared_ptr</tt> conversion to a <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2018-06-23 21:28:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 78 [CD1]</b></p>

<p>
There is presently no way to convert directly from a <tt>shared_ptr</tt> to a
<tt>unique_ptr</tt>. Add an interface that performs the conversion. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We believe that the shared pointer must use the default
deleter for the conversion to succeed.
</p></blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote><p>
This is basically a request for <tt>shared_ptr&lt;&gt;::release</tt> in
disguise, with all the associated problems. Not a good idea.
</p></blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
<p>
The rationale for the omission of a release() member function from shared_ptr is given in:
<a href="http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm</a>
</p>
<p>
The implementation of such a member is non-trivial (and maybe
impossible), because it would need to account for the deleter.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard sets to Tentatively NAD Future.
]</i></p>


<blockquote>
<p>
I took an online poll and got 3 votes for NAD and 3 for NAD Future.  Personally
I prefer NAD Future as this does refer to an extension that could conceivably be
considered beyond C++0X.
</p>

<p>
However such an extension would need to solve a couple of problems:
</p>

<ol>
<li>What is the interface for such a conversion when the <tt>shared_ptr</tt> does
not have unique ownership?  Throw an exception?  Create a null <tt>unique_ptr</tt>?
Undefined behavior?
</li>

<li>
<p>
How does one handle custom deleters given to the <tt>shared_ptr</tt> constructor?
</p>
<p>
I do not believe it is possible to implement a general answer to this question.
The <tt>shared_ptr</tt> deleter is a run time (or construction time) characteristic.
The <tt>unique_ptr</tt> deleter is a compile time characteristic.  In general one
can not know to what type of <tt>unqiue_ptr</tt> you are converting to.
</p>
<p>
One answer is for the user of the conversion to specify the deleter type and perhaps
throw an exception if the specification turns out to be incorrect.
</p>
<p>
Another answer is for the conversion to only be valid when the underlying deleter
is <tt>default_delete</tt>.  We would probalby need to specify that this is indeed the
underlying deleter of a <tt>shared_ptr</tt> when a custom deleter is not given in
the constructor.
</p>
</li>
</ol>

<p>
At any rate, there are non-trivial design issues which would need to be implemented
and tested in the field for usability prior to standardization.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to NAD Future.
</p></blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>We just removed <tt>std::shared_ptr&lt;&gt;::unique()</tt> because it's misleading at best
(especially in the face of <tt>weak_ptr</tt>). Resolving this is far larger than 
issues-processing &mdash; it would require significant design discussion and 
potentially an ABI break (stashing a mutex in the <tt>shared_ptr</tt> control block).</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1032" href="1032">1032.</a> Tome utility templates need to be concept-constrained</h3>
<p><b>Section:</b> 29 <a href="https://timsong-cpp.github.io/cppwp/time">[time]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#time">issues</a> in [time].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 45 [CD1]</b></p>

<p>
<tt>Rep</tt>, <tt>Period</tt>, <tt>Clock</tt> and <tt>Duration</tt>
don't correspond to concept.
</p>
<blockquote><pre>
template &lt;class Rep, class Period = ratio&lt;1&gt;&gt; class duration; 
template &lt;class Clock, class Duration = typename Clock::duration&gt; class time_point; 
</pre></blockquote>
<p>
Make concept for <tt>Rep</tt>, <tt>Period</tt>, <tt>Clock</tt> and <tt>Duration</tt>.
Fix 29 <a href="https://timsong-cpp.github.io/cppwp/time">[time]</a> and <tt>wait_until</tt>
and <tt>wait_for</tt>'s template parameter at 33 <a href="https://timsong-cpp.github.io/cppwp/thread">[thread]</a>. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We agree that this section needs concepts. We look forward to a paper on
this topic. We recommend no action until a paper is available.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1035" href="1035">1035.</a> <tt>&lt;array&gt;::swap</tt> can invalidate references, pointers, and iterators</h3>
<p><b>Section:</b> 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 226 [CD1]</b></p>

<p>
<tt>&lt;array&gt;</tt> must be added to this list. In particular it
doesn't satisfy: - no <tt>swap()</tt> function invalidates any
references, pointers, or iterators referring to the elements of the
containers being swapped. and probably doesn't satisfy: - no
<tt>swap()</tt> function throws an exception.
</p>
<p>
If <tt>&lt;array&gt;</tt> remains a container, this will have to also
reference <tt>array</tt>, which will then have to say which of these
points it satisfies.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Agree. The proposed resolution is incomplete. Further work required.
</p></blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote><p>
Issue <a href="1099">1099</a> also suggests adding move constructor to this.
</p></blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote><p>
Howard is to draft a note that explains what happens to references.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD.  No consensus for change.
</p></blockquote>



<p><i>[
2009-08-01 Howard provided wording.
]</i></p>


<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph to 24.3.7.4 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a>:
</p>

<blockquote><pre>
template &lt;Swappable T, size_t N&gt; void swap(array&lt;T,N&gt;&amp; x, array&lt;T,N&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>
swap_ranges(x.begin(), x.end(), y.begin());
</pre></blockquote>

<p><ins>
[<i>Note:</i>
Outstanding iterators, references and pointers may be invalidated.
&mdash; <i>end note</i>]
</ins></p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1036" href="1036">1036.</a> Remove iterator specification that is redundant due to concept constraints</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 231 [CD1]</b></p>

<p>
p9-p11 are redundant now that Concepts define what it means to be an
Iterator and guide overload resolution accordingly. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Agree with issue and change to 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>. The
changes required to 23 <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a> will be part of the general
concept support for that clause.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>p9-11. Make sure <tt>std::basic_string</tt>
has constraints similar to
<tt>std::vector</tt> to meet this old guarantee. 
</p>





<hr>
<h3><a name="1042" href="1042">1042.</a> Provide <tt>ContiguousStorage</tt> concept and apply it to corresponding containers</h3>
<p><b>Section:</b> 24.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#sequences">issues</a> in [sequences].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 244 [CD1]</b></p>

<p>
The validity of the expression <tt>&amp;a[n] == &amp;a[0] + n</tt> is contingent on
<tt>operator&amp;</tt> doing the "right thing" (as captured by the <tt>CopyConstructible</tt>
requirements in table 30 in C++2003). However this constraint has been
lost in the Concepts of C++0x. This applies to <tt>vector</tt> and <tt>array</tt> (it
actually applies to <tt>string</tt> also, but that's a different chapter, so I'll
file a separate comment there and cross-reference).
</p>

<p>
Suggested solution:
</p>

<p>
Define a <tt>ContiguousStorage</tt> and apply it to
<tt>vector</tt>, <tt>array</tt> and <tt>string</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Agree with the issue but not the details of the proposed solution. Walter to
provide wording for the new concept.
</p></blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote><p>
Another LWG subgroup wondered if this concept should extend to <tt>complex&lt;T&gt;</tt>, 
and so not be built on the container concept at all?
</p></blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote><p>
Leave Open, pending a post-Concepts Working Draft.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark issue 1042 as NAD, in rationale state that this was solved by removal of concepts.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to <tt>&lt;container_concepts&gt;</tt> synopsis in  [container.concepts]
</p>

<blockquote><pre>
<ins>concept&lt; typename C &gt; ContiguousStorageContainer <i>see below</i>;</ins>
</pre></blockquote>

<p>
Add a new section to the end of  [container.concepts]
</p>

<blockquote>
<p>
23.1.6.x ContiguousStorageContainer concept [container.concepts.contiguous]
</p>

<pre>
concept ContiguousStorageContainer&lt; typename C &gt;
  : Container&lt;C&gt;
{
  value_type* data(C&amp;);

  axiom Contiguity(C&amp; c, size_type i) {
    if( i &lt; size(c) ) {
         addressof( * (data(c) + i) )
      == addressof( * advance(data(c), i) );
    }
  }
}
</pre>

<p>
The <tt>ContiguousStorageContainer</tt> concept describes a container whose elements
are allocated in a single region of memory, and are stored sequentially
without intervening padding other than to meet alignment requirements.
For example, the elements may be stored in a
single array of suitable length.
</p>

<pre>
value_type * data( C&amp; );
</pre>

<blockquote><p>
<i>Returns:</i> a pointer to the first element in the region of storage.
Result is unspecified for an empty container.
</p></blockquote>

</blockquote>

<p>
Change 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> p1:
</p>

<blockquote><p>
-1- The header <tt>&lt;array&gt;</tt> defines a class template for
storing fixed-size sequences of objects. An <tt>array</tt> supports
random access iterators. An instance of <tt>array&lt;T, N&gt;</tt>
stores <tt>N</tt> elements of type <tt>T</tt>, so that <tt>size() ==
N</tt> is an invariant. The elements of an <tt>array</tt> are stored
contiguously, meaning that <del>if <tt>a</tt> is</del> an
<tt>array&lt;T, N&gt;</tt> <del>then it obeys the identity <tt>&amp;a[n]
== &amp;a[0] + n</tt> for all <tt>0 &lt;= n &lt; N</tt></del>
<ins>satisfies the concept <tt>ContiguousStorageContainer&lt; array&lt;T,
N&gt;&gt;</tt></ins>.
</p></blockquote>

<p>
Add to the synopsis in 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>:
</p>

<blockquote><pre>
    ...
    T * data(); 
    const T * data() const; 
  };

  <ins>template&lt; typename T, size_t N &gt;</ins>
    <ins>concept_map ContiguousStorageContainer&lt; array&lt;T, N&gt;&gt; {};</ins>
} 
</pre></blockquote>

<p>
Change 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a> p1:
</p>

<blockquote><p>
A <tt>vector</tt> is a sequence container that supports random access
iterators. In addition, it supports (amortized) constant time insert and
erase operations at the end; insert and erase in the middle take linear
time. Storage management is handled automatically, though hints can be
given to improve efficiency. The elements of a vector are stored
contiguously, meaning that <del>if <tt>v</tt> is</del> a
<tt>vector&lt;T, Alloc&gt;</tt> <ins>(</ins>where <tt>T</tt> is some
type other than <tt>bool</tt><ins>)</ins><del>, then it obeys the
identity <tt>&amp;v[n] == &amp;v[0] + n</tt> for all <tt>0 &lt;= n &lt;
v.size()</tt></del> <ins>satisfies the concept <tt>ContiguousStorageContainer&lt;
vector&lt; T, Alloc&gt;&gt;</tt></ins>.
</p></blockquote>

<p>
Add at the end of the synopsis in 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a> p2:
</p>

<blockquote><pre>
<ins>template&lt; typename T, typename A &gt;
  requires !SameType&lt; T, bool &gt;
  concept_map ContiguousStorageContainer&lt; vector&lt;T, A&gt;&gt; {};</ins>
</pre></blockquote>



<p><b>Rationale:</b></p>
<p>Solved by removal of concepts.</p>





<hr>
<h3><a name="1051" href="1051">1051.</a> Specify subscript operation return types of <tt>reverse_iterator</tt> and <tt>move_iterator</tt></h3>
<p><b>Section:</b> 25.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a>, 25.5.4.6 <a href="https://timsong-cpp.github.io/cppwp/move.iter.elem">[move.iter.elem]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#reverse.iter.elem">active issues</a> in [reverse.iter.elem].</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.elem">issues</a> in [reverse.iter.elem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 279 [CD1]</b></p>

<p>
The reason the return type became unspecified is LWG issue <a href="386">386</a>. This
reasoning no longer applies as there are at least two ways to get the right
return type with the new language facilities added since the previous
standard.
</p>

<p>
Proposal: Specify the return type using either decltype or the Iter concept_map.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Under discussion. This is a general question about all iterator
adapters.
</p>
</blockquote>

<p><i>[
Howard adds post Summit:
]</i></p>


<blockquote><p>
I am requesting test cases to demonstrate a position.
</p></blockquote>

<p><i>[
2009-07-24 Daniel adds:
]</i></p>


<blockquote>
<p>
I recommend NAD. Without concepts we can no longer
restrict this member in a trivial way. Using <tt>decltype</tt> the
declaration would be along the lines of
</p>
<blockquote><pre>
static const Iter&amp; __base(); // not defined
auto operator[](difference_type n) const -&gt; decltype(__base()[-n-1]);
</pre></blockquote>

<p>
but once <tt>reverse_iterator</tt> is instantiated for some given type
<tt>Iter</tt> which cannot form a well-formed expression <tt>__base()[-n-1]</tt>
this would cause an ill-formed function declaration, diagnostic
required, and no silent SFINAE elimination.
</p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to NAD.
</p></blockquote>

<p><i>[
2009-10-22 Daniel adds:
]</i></p>


<blockquote>
<p>
IMO, my original comment regarding ill-formedness of the described
construction is still correct, but I must add that I should weaken my
assertion "Without concepts we can no longer restrict this member in
a trivial way".
</p>

<p>
In fact with the existence of default template arguments for function
templates it is not too hard to implement this like as follows, which
shows that we can indeed simulate to some sense constrained
member functions in C++0x.
</p>

<p>
My example does not really proof that the specification is easy, but
it should be possible. I assume that the implementation would not
be ABI compatible, though.
</p>

<p>
It is now your own decision how to proceed ;-)
</p>

<blockquote><pre>
#include &lt;type_traits&gt;
#include &lt;cstddef&gt;

template&lt;class T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval();

template&lt;class It&gt;
struct reverse_iterator {
    It base;

    typedef std::ptrdiff_t difference_type;

    template&lt;class U = It, class Res =
     decltype(declval&lt;const U&amp;&gt;()[declval&lt;difference_type&gt;()])
    &gt;
    Res operator[](difference_type n) const  {
        return base[-n-1];
    }
};

struct MyIter {
};

int main() {
    reverse_iterator&lt;int*&gt; ri;
    ri[0] = 2;
    reverse_iterator&lt;MyIter&gt; ri2;
}
</pre></blockquote>

<p>
The above declaration could be simplified, but the ideal solution
</p>

<blockquote><pre>
template&lt;class U = It&gt;
  decltype(declval&lt;const U&amp;&gt;()[declval&lt;difference_type&gt;()])
     operator[](difference_type n) const;
</pre></blockquote>

<p>
does not work yet on gcc 4.4.1.
</p>

</blockquote>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1053" href="1053">1053.</a> Unify algorithms with operator and function object variants</h3>
<p><b>Section:</b> 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2017-06-05 20:39:07 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 295 [CD1]</b></p>

<p>
There is a level of redundancy in the library specification for many
algorithms that can be eliminated with the combination of concepts and
default parameters for function templates. Eliminating redundancy simplified
specification and reduces the risk of introducing accidental
inconsistencies.
</p>
<p>
Proposed resolution: Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2743.pdf">N2743</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
NAD, this change would break code that takes the address of an algorithm.
</p>
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Request 'Open'.  The issues in the paper go beyond just reducing
the number of signatures, but cover unifying the idea of the ordering
operation used by algorithms, containers and other library components.  At
least, it takes a first pass at the problem.
</p>

<p>
For me (personally) that was the more important part of the paper, and not
clearly addressed by the Summit resolution.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Too inventive, too late, would really need a paper. Moved to NAD Future.
</p></blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD (NAD-ABI)]</i></p>

<p>Concept specific, might be solved by Ranges. Get it right in STD2 or with the next big ABI break.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1056" href="1056">1056.</a> Must all Engines and Distributions be Streamable?</h3>
<p><b>Section:</b> 28.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Both the concepts <tt>RandomNumberEngine</tt> and <tt>RandomNumberDistribution</tt> have
requirements to be <tt>InputStreamable</tt> and <tt>OutputStreamable</tt>.
</p>
<p>
I have no problems leaving the WP in an inconsistent state on the best-faith
assumption these concepts will be provided later, however disagree with the
proposers that these constraints are not separable, orthogonal to the basic
concepts of generating random number distributions.
</p>
<p>
These constraints should be dropped, and applied to specific algorithms as
needed.
</p>
<p>
If a more refined concept (certainly deemed useful by the proposers) is
proposed there is no objection, but the basic concept should not require
persistence via streaming.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open.
</p></blockquote>

<p><i>[
2009-05-31 Alisdair adds:
]</i></p>


<blockquote>
<p>
Working on constraining the stream iterators, I have a few more observations
to make on the concepts proposed while constraining the random number
facility.
</p>
<p>
While I still believe the concerns are orthogonal, I don't believe the
existing constraints go far enough either!  The goal we want to achieve is
not that a <tt>RandomNumberEngine</tt> / <tt>RandomNumberDistribution</tt> supports the stream
operators, but that it is <tt>Serializable</tt>.  I.e. there is a relationship
between the insert and extract operations that guarantees to restore the
state of the original object.  This implies a coupling of the concepts
together in a broader concept (<tt>Serializable</tt>) with at least one axiom to
assert the semantics.
</p>
<p>
One problem is that <tt>istream</tt> and <tt>ostream</tt> may be fundamentally different
types, although we can hook a relation if we are prepared to drop down to
the <tt>char</tt> type and <tt>char_traits</tt> template parameters.  Doing so ties us to a
form of serialization that demands implementation via the std iostreams
framework, which seems overly prescriptive.  I believe the goal is generally
to support serialization without regard to how it is expressed - although
this is getting even more inventive in terms of concepts we do not have
today.
</p>
</blockquote>

<p><i>[
2009-11-03 Alisdair adds:
]</i></p>


<blockquote>
<p>
I can't find the record in the wiki minutes, but it was agreed at both
Frankfurt and Santa Cruz that this issue is NAD.
</p>
<p>
The agreement in SC was that I would provide you with the rationale (see
below) to include when moving to NAD.
</p>
</blockquote>

<p><i>[
2009-11-03 Howard adds:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.
</p></blockquote>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
The issue suggests a more refined concept should be used if we want to
require streaming, to separate concerns from the basic
<tt>RandomNumberEngine</tt> behaviour.  In Frankfurt it was observed
that <tt>RandomNumberEngine</tt> <em>is</em> that more refined concept,
and the basic concept used in the framework is
<tt>UniformRandomNumberGenerator</tt>, which it refines.
</p>

<p>
We concur, and expect this to have no repurcussions re-writing this
clause now concepts are removed.
</p>





<hr>
<h3><a name="1057" href="1057">1057.</a> <tt>RandomNumberEngineAdaptor</tt></h3>
<p><b>Section:</b> 28.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>RandomNumberEngineAdaptor</tt> concept breaks precedent in the
way the library has been specified by grouping requirements into a
concept that is never actually used in the library.
</p>
<p>
This is undoubtedly a very helpful device for documentation, but we are not
comfortable with the precedent - especially as we have rejected national
body comments on the same grounds.
</p>
<p>
Suggest either removing the concept, or providing an algorithm/type that
requires this concept in their definition (such as a factory function to
create new engines).
</p>
<p>
The preference is to create a single new algorithm and retain the value of
the existing documentation.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Walter points out that it is unlikely that any algorithm would ever
require this concept, but that the concept nonetheless is useful as
documentation, and (via concept maps) as a means of checking specific adapters.
</p>
<p>
Alisdair disagrees as to the concept's value as documentation.
</p>
<p>
Marc points out that the <tt>RandomNumberDistribution</tt>
is also a concept not used elsewhere in the Standard.
</p>
<p>
Pete agrees that a policy of not inventing concepts
that aren't used in the Standard is a good starting point,
but should not be used as a criterion for rejecting a concept.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1058" href="1058">1058.</a> New container issue</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Sequence containers 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>:
</p>

<p>
The return value of new calls added to table 83 are not specified.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add after p6 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>:
</p>

<blockquote>
<p>
-6- ...
</p>
<p><ins>
The iterator returned from <tt>a.insert(p,rv)</tt> points to the copy of <tt>rv</tt>
inserted into <tt>a</tt>.
</ins></p>
<p><ins>
The iterator returned from <tt>a.emplace(p, args)</tt> points to the new
element constructed from <tt>args</tt> inserted into <tt>a</tt>.
</ins></p>
</blockquote>





<hr>
<h3><a name="1059" href="1059">1059.</a> Usage of no longer existing FunctionType concept</h3>
<p><b>Section:</b> 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Due to a deliberate core language decision, the earlier called
"foundation" concept <tt>std::FunctionType</tt> had been removed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2773.pdf">N2773</a>
shortly
before the first "conceptualized" version of the WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>)
had been
prepared. This caused a break of the library, which already used this
concept in the adapted definition of <tt>std::function</tt>
(22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>/2, header <tt>&lt;functional&gt;</tt> synopsis and
22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>).
</p>
<p>
A simple fix would be to either (a) make <tt>std::function</tt>'s primary template
unconstrained or to (b) add constraints based on existing (support) concepts.
A more advanced fix would (c) introduce a new library concept.
</p>
<p>
The big disadvantage of (a) is, that users can define templates which
cause compiler errors during instantiation time because of under-constrainedness
and would thus violate the basic advantage of constrained
code.
</p>
<p>
For (b), the ideal constraints for <tt>std::function</tt>'s template parameter would
be one which excludes everything else but the single provided partial
specialization that matches every "free function" type (i.e. any function
type w/o cv-qualifier-seq and w/o ref-qualifier).
Expressing such a type as as single requirement would be written as
</p>
<blockquote><pre>
template&lt;typename T&gt;
requires ReferentType&lt;T&gt; // Eliminate cv void and function types with cv-qual-seq
                         //   or ref-qual (depending on core issue #749)
      &amp;&amp; PointeeType&lt;T&gt;  // Eliminate reference types
      &amp;&amp; !ObjectType&lt;T&gt;  // Eliminate object types
</pre></blockquote>
<p>
Just for completeness approach (c), which would make sense, if the
library has more reasons to constrain for free function types:
</p>
<blockquote><pre>
auto concept FreeFunctionType&lt;typename T&gt;
  : ReferentType&lt;T&gt;, PointeeType&lt;T&gt;, MemberPointeeType&lt;T&gt;
{
  requires !ObjectType&lt;T&gt;;
}
</pre></blockquote>
<p>
I mention that approach because I expect that free function types belong
to the most natural type categories for every days coders. Potential
candidates in the library are <tt>addressof</tt> and class template <tt>packaged_task</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair would prefer to have a core-supported <tt>FunctionType</tt> concept
in order that any future changes be automatically correct
without need for a library solution to catch up;
he points to type traits as a precedent.
Further, he believes that a published concept can't in the future
be changed.
</p>
<p>
Bill feels this category of entity would change sufficiently slowly
that he would be willing to take the risk.
</p>
<p>
Of the discussed solutions, we tend toward option (c).
We like the idea of having a complete taxonomy of native types,
and perhaps erred in trimming the set.
</p>
<p>
We would like to have this issue reviewed by Core and would like
their feedback.  Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change in 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>/2, Header <tt>&lt;functional&gt;</tt> synopsis:
</p>
<blockquote><pre>
// 20.6.16 polymorphic function wrappers:
class bad_function_call;
template&lt;<del>FunctionType</del><ins>ReferentType F</ins>&gt;
<ins>requires PointeeType&lt;F&gt; &amp;&amp; !ObjectType&lt;F&gt;</ins>
class function; // undefined
</pre></blockquote>
</li>
<li>
<p>
Change in 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>:
</p>
<blockquote><pre>
namespace std {
template&lt;<del>FunctionType</del><ins>ReferentType F</ins>&gt;
<ins>requires PointeeType&lt;F&gt; &amp;&amp; !ObjectType&lt;F&gt;</ins>
class function; // undefined
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1060" href="1060">1060.</a> Embedded nulls in NTBS</h3>
<p><b>Section:</b> 16.3.3.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/byte.strings">[byte.strings]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Definition of null-terminated sequences allow for embedded nulls. This is
surprising, and probably not supportable with the intended use cases.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the issue, but believe this can be handled editorially.
Move to NAD Editorial.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1061" href="1061">1061.</a> Bad indexing for tuple access to pair (Editorial?)</h3>
<p><b>Section:</b> 22.3.4 <a href="https://timsong-cpp.github.io/cppwp/pair.astuple">[pair.astuple]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#pair.astuple">issues</a> in [pair.astuple].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The definition of <tt>get</tt> implies that <tt>get</tt> must return the second element if
given a negative integer.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to NAD Editorial.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
22.3.4 <a href="https://timsong-cpp.github.io/cppwp/pair.astuple">[pair.astuple]</a> p5:
</p>

<blockquote><pre>
template&lt;<del>int</del> <ins>size_t</ins> I, class T1, class T2&gt; 
  requires True&lt;(I &lt; 2)&gt; 
  const P&amp; get(const pair&lt;T1, T2&gt;&amp;);
</pre>
</blockquote>






<hr>
<h3><a name="1062" href="1062">1062.</a> Missing insert_iterator for stacks/queues</h3>
<p><b>Section:</b> 25.5.2 <a href="https://timsong-cpp.github.io/cppwp/insert.iterators">[insert.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It is odd that we have an iterator to insert into a <tt>vector</tt>, but not an
iterator to insert into a <tt>vector</tt> that is adapted as a <tt>stack</tt>. The standard
container adapters all have a common interface to <tt>push</tt> and <tt>pop</tt> so it should
be simple to create an iterator adapter to complete the library support.
</p>

<p>
We should provide an <tt>AdaptedContainer</tt> concept supporting <tt>push</tt> and <tt>pop</tt>
operations. Create a new insert iterator and factory function that inserts
values into the container by calling <tt>push</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Walter recommends NAD Future.
</p>
<p>
Move to Open, and recommend deferring the issue until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-07-29 Howard moves to Tentatively NAD Future.
]</i></p>


<blockquote><p>
A poll on the LWG reflector voted unanimously to move this issue to Tentatively NAD Future.
</p></blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to NAD.  The intent of these adapters are to restrict the interfaces.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1063" href="1063">1063.</a> 03 iterator compatibilty</h3>
<p><b>Section:</b> 99 [iterator.backward] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Which header must a user <tt>#include</tt> to obtain the library-supplied
<tt>concept_maps</tt> declared in this paragraph?
</p>

<p>
This is important information, as existing user code will break if this
header is not included, and we should make a point of mandating this header
is <tt>#include</tt>-d by library headers likely to make use of it, notably
<tt>&lt;algorithm&gt;</tt>.  See issue <a href="1001">1001</a> for more details.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the direction of the proposed resolution.
Move to Tentatively Ready.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
We believe this is NAD Concepts, but this needs to be reviewed against the
post-remove-concepts draft.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>Change  [depr.lib.iterator.primitives], Iterator primitives, as
indicated:</i></p>

<blockquote>
  <p>To simplify the use of iterators and provide backward compatibility with
  previous C++ Standard Libraries,
  the library provides several classes and functions. <ins>Unless otherwise
  specified, these classes and functions shall be defined in header <tt>&lt;iterator&gt;</tt>.</ins></p>
</blockquote>
<p><i>Change 99 [iterator.backward], Iterator backward compatibility, as
indicated:</i></p>
<blockquote>
  <p>The library provides concept maps that allow iterators specified with
  <tt>iterator_traits</tt> to interoperate with
  algorithms that require iterator concepts. <ins>These concept maps shall be
  defined in the same header that defines the iterator.</ins> [<i>Example:</i></p>
</blockquote>





<hr>
<h3><a name="1064" href="1064">1064.</a> Term "object state" should not refer to classes</h3>
<p><b>Section:</b> 99 [defns.obj.state] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#defns.obj.state">issues</a> in [defns.obj.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 152 [CD1]</b></p>

<p>
Object state is using a definition of object (instance of a class) from
outside the standard, rather than the 'region of storage' definiton in
6.7.2 <a href="https://timsong-cpp.github.io/cppwp/intro.object">[intro.object]</a>p1
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
We think we're removing this; See 99 [func.referenceclosure.cons].
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD.  This will not affect user or implementer code
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1067" href="1067">1067.</a> simplified wording for inner_product</h3>
<p><b>Section:</b> 27.10 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.ops">issues</a> in [numeric.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
One of the motivating examples for introducing requirements-aliases was to
simplify the wording of the <tt>inner_product</tt> requirements.  As the paper
adopting the feature and constrained wording for the library went through in
the same meeting, it was not possible to make the change at the time.  The
simpler form should be adopted now though.  Similarly, most the other
numerical algorithms can benefit from a minor cleanup.
</p>
<p>
Note that in each case, the second more generalised form of the algorithm
does not benefit, as there are already named constraints supplied by the
template type parameters.
</p>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
one part of the suggested resolution suggests the removal of the
<tt>MoveConstructible&lt;T&gt;</tt> requirement from
<tt>inner_product</tt>. According to 27.10.5 <a href="https://timsong-cpp.github.io/cppwp/inner.product">[inner.product]</a>
</p>

<blockquote><p>
Computes its result by initializing the accumulator <tt>acc</tt> with the
initial value <tt>init</tt>
</p></blockquote>

<p>
this step requires at least <tt>MoveConstructible</tt>.
</p>

<p>
Therefore I strongly suggest to take this removal back (Note also
that the corresponding overload with a functor argument still has
the same <tt>MoveConstructible&lt;T&gt;</tt> requirement).
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution as amended by Daniel's suggestion
to restore <tt>MoveConstructible</tt>,
reflected in the updated proposed resolution below.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change in 27.10 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a> and 27.10.3 <a href="https://timsong-cpp.github.io/cppwp/accumulate">[accumulate]</a>:
</p>

<blockquote><pre>
template &lt;InputIterator Iter, MoveConstructible T&gt;
 requires <ins>add =</ins> HasPlus&lt;T, Iter::reference&gt;
       &amp;&amp; HasAssign&lt;T, <del>HasPlus&lt;T, Iter::reference&gt;</del> <ins>add</ins>::result_type&gt;
 T accumulate(Iter first, Iter last, T init);
</pre></blockquote>

<p>
Change in 27.10 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a> and 27.10.5 <a href="https://timsong-cpp.github.io/cppwp/inner.product">[inner.product]</a>:
</p>

<blockquote><pre>
template &lt;InputIterator Iter1, InputIterator Iter2, MoveConstructible T&gt;
  requires <ins>mult =</ins> HasMultiply&lt;Iter1::reference, Iter2::reference&gt;
        &amp;&amp; <ins>add =</ins> HasPlus&lt;T, <del>HasMultiply&lt;Iter1::reference, Iter2::reference&gt;</del> <ins>mult</ins>::result_type&gt;
        &amp;&amp; HasAssign&lt; 
             T,
             <del>HasPlus&lt;T,
                     HasMultiply&lt;Iter1::reference, Iter2::reference&gt;::result_type&gt;</del> <ins>add</ins>::result_type&gt;
  T inner_product(Iter1 first1, Iter1 last1, Iter2 first2, T init);
</pre></blockquote>

<p>
Change in 27.10 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a> and 27.10.7 <a href="https://timsong-cpp.github.io/cppwp/partial.sum">[partial.sum]</a>:
</p>

<blockquote><pre>
template &lt;InputIterator InIter, OutputIterator&lt;auto, const InIter::value_type&amp;&gt; OutIter&gt;
  requires <ins>add =</ins> HasPlus&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; HasAssign&lt;InIter::value_type,
                     <del>HasPlus&lt;InIter::value_type, InIter::reference&gt;</del> <ins>add</ins>::result_type&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
  OutIter partial_sum(InIter first, InIter last, OutIter result);
</pre></blockquote>

<p>
Change in 27.10 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a> and 27.10.12 <a href="https://timsong-cpp.github.io/cppwp/adjacent.difference">[adjacent.difference]</a>:
</p>

<blockquote><pre>
template &lt;InputIterator InIter, OutputIterator&lt;auto, const InIter::value_type&amp;&gt; OutIter&gt;
  requires <ins>sub =</ins> HasMinus&lt;InIter::value_type, InIter::value_type&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; OutputIterator&lt;OutIter, <del>HasMinus&lt;InIter::value_type, InIter::value_type&gt;</del> <ins>sub</ins>::result_type&gt;
        &amp;&amp; MoveAssignable&lt;InIter::value_type&gt;
  OutIter adjacent_difference(InIter first, InIter last, OutIter result);
</pre></blockquote>






<hr>
<h3><a name="1068" href="1068">1068.</a> class <tt>random_device</tt> should be movable</h3>
<p><b>Section:</b> 28.5.7 <a href="https://timsong-cpp.github.io/cppwp/rand.device">[rand.device]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.device">issues</a> in [rand.device].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
class <tt>random_device</tt> should be movable.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open, and recommend this issue be deferred until after the next
Committee Draft is issued.
</p></blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Leave open. Walter to provide drafting as part of his planned paper.
</p></blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD.
]</i></p>




<p><b>Rationale:</b></p>
<p>
WP is correct as written.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1069" href="1069">1069.</a> class <tt>seed_seq</tt> should support efficient move operations</h3>
<p><b>Section:</b> 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
class <tt>seed_seq</tt> should support efficient move operations.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open, and recommend this issue be deferred until after the next
Committee Draft is issued.
</p></blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Leave open. Walter to provide drafting as part of his planned paper.
</p></blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
<tt>seed_seq</tt> is explicitly not copyable, so, much like LWG issue
<a href="1068">1068</a>, LWG issue 1069 could be marked NAD to be consistent
with this.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1072" href="1072">1072.</a> Is <tt>std::hash</tt> a constrained template or not?</h3>
<p><b>Section:</b> 22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Is <tt>std::hash</tt> a constrained template or not?
</p>
<p>
According to class template <tt>hash</tt> 22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>, the definition is:
</p>

<blockquote><pre>
template &lt;class T&gt;
struct hash : public std::unary_function&lt;T, std::size_t&gt; {
  std::size_t operator()(T val) const;
};
</pre></blockquote>

<p>
And so unconstrained.
</p>
<p>
According to the <tt>&lt;functional&gt;</tt> synopsis in p2 Function objects
22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a> the template is declared as:
</p>

<blockquote><pre>
template &lt;ReferentType T&gt; struct hash;
</pre></blockquote>

<p>
which would make hash a constrained template.
</p>

<p><i>[
2009-03-22 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair is not certain that Daniel's proposed resolution is sufficient,
and recommends we leave the hash template unconstrained for now.
</p>
<p>
Recommend that the Project Editor make the constrained declaration consistent
with the definition in order to make the Working Paper internally consistent,
and that the issue then be revisited.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
[To the editor: This resolution is merge-compatible to the
resolution of <a href="1078">1078</a>]
</p>

<ol>
<li>
<p>
In 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>/2, header <tt>&lt;functional&gt;</tt> synopsis, change as indicated:
</p>

<blockquote><pre>
// 20.6.17, hash function base template:
template &lt;ReferentType T&gt; struct hash; <ins>// undefined</ins>
</pre></blockquote>
</li>
<li>
<p>
In 22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>/1 change as indicated:
</p>
<blockquote><pre>
namespace std {
 <del>template &lt;class T&gt;
 struct hash : public std::unary_function&lt;T, std::size_t&gt; {
 std::size_t operator()(T val) const;
 };</del>
 <ins>template &lt;ReferentType T&gt; struct hash; // undefined</ins>
}
</pre></blockquote>
</li>
<li>
<p>
In 22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>/2 change as indicated:
</p>

<blockquote><p>
-2-  <ins>For all library-provided specializations, the template
instantiation <tt>hash&lt;T&gt;</tt>
  shall provide a public <tt>operator()</tt> with return type <tt>std::size_t</tt> to
satisfy the concept
  requirement <tt>Callable&lt;const hash&lt;T&gt;, const T&amp;&gt;</tt>. If <tt>T</tt> is an object
type or reference to
  object, <tt>hash&lt;T&gt;</tt> shall be publicly derived from
<tt>std::unary_function&lt;T, std::size_t&gt;</tt>.
  </ins> The return value of <tt>operator()</tt> is unspecified, except that
equal arguments
  shall yield the same result. <tt>operator()</tt> shall not throw exceptions.
</p></blockquote>
</li>
<li>
<p>
In 17.8 <a href="https://timsong-cpp.github.io/cppwp/support.rtti">[support.rtti]</a>/1, header <tt>&lt;typeinfo&gt;</tt> synopsis change as indicated:
</p>
<blockquote><pre>
namespace std {
  class type_info;
  class type_index;
  template &lt;<del>class</del><ins>ReferentType</ins> T&gt; struct hash;
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1074" href="1074">1074.</a> concept map broken by N2840</h3>
<p><b>Section:</b> 99 [allocator.element.concepts] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
p7 Allocator-related element concepts 99 [allocator.element.concepts]
</p>

<p>
The changes to the <tt>AllocatableElement</tt> concept mean this <tt>concept_map</tt>
specialization no longer matches the original concept:
</p>

<blockquote><pre>
template &lt;Allocator Alloc, class T, class ... Args&gt;
  requires HasConstructor&lt;T, Args...&gt;
    concept_map AllocatableElement&lt;Alloc, T, Args&amp;&amp;...&gt; {
      void construct_element(Alloc&amp; a, T* t, Args&amp;&amp;... args) {
        Alloc::rebind&lt;T&gt;(a).construct(t, forward(args)...);
      }
    }
</pre></blockquote>

<p><i>[
2009-03-23 Pablo adds:
]</i></p>


<blockquote><p>
Actually, this is incorrect,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
says. "In section 
99 [allocator.element.concepts] paragraph 8, modify the definition of the
<tt>AllocatableElement</tt> concept and eliminate the related concept map:" but
then neglects to include the red-lined text of the concept map that was
to be eliminated. Pete also missed this, but I caught it he asked me to
review his edits.  Pete's updated WP removes the concept map entirely,
which was the original intent.  The issue is, therefore, moot.  Note, as
per my presentation of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
in summit, <tt>construct()</tt> no longer has a
default implementation.  This regrettable fact was deemed (by David
Abrahams, Doug, and myself) to be preferable to the complexity of
providing a default implementation that would not under-constrain a more
restrictive allocator (like the scoped allocators).
</p></blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>

<blockquote>
<p>
it seems to me that #1074 should be resolved as a NAD, because the
current WP has already removed the previous AllocatableElement concept map.
It introduced auto concept AllocatableElement instead, but as of
99 [allocator.element.concepts]/7 this guy contains now
</p>
<blockquote><pre>
requires FreeStoreAllocatable&lt;T&gt;;
void Alloc::construct(T*, Args&amp;&amp;...);
</pre></blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The affected code is no longer part of the Working Draft.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 99 [allocator.element.concepts]:
</p>

<blockquote><pre>
template &lt;Allocator Alloc, class T, class ... Args&gt;
  requires HasConstructor&lt;T, Args...&gt;
    concept_map AllocatableElement&lt;Alloc, T, Args&amp;&amp;...&gt; {
      void construct_element(<del>Alloc&amp; a,</del> T* t, Args&amp;&amp;... args) {
        Alloc::rebind&lt;T&gt;(a).construct(t, forward(args)...);
      }
    }
</pre></blockquote>






<hr>
<h3><a name="1076" href="1076">1076.</a> unary/binary_negate need constraining and move support</h3>
<p><b>Section:</b> 99 [depr.negators] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-20 <b>Last modified:</b> 2017-06-15 20:52:51 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class templates <tt>unary/binary_negate</tt> need constraining and move support.
</p>
<p>
Ideally these classes would be deprecated, allowing <tt>unary/binary_function</tt> to
also be deprecated.  However, until a generic negate adaptor is introduced
that can negate any <tt>Callable</tt> type, they must be supported so should be
constrained.  Likewise, they should be movable, and support adopting a
move-only predicate type.
</p>
<p>
In order to preserve ABI compatibility, new rvalue overloads are supplied in
preference to changing the existing pass-by-const-ref to pass-by-value.
</p>
<p>
Do not consider the issue of forwarding mutable lvalues at this point,
although remain open to another issue on the topic.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>

<blockquote>
<p>
IMO the currently proposed resolution needs some updates
because it is ill-formed at several places:
</p>

<ol>
<li>
<p>
In concept AdaptableUnaryFunction change
</p>
<blockquote><pre>
typename X::result_type;
typename X::argument_type;
</pre></blockquote>
<p>
to
</p>
<blockquote><pre>
Returnable result_type = typename X::result_type;
typename argument_type = typename X::argument_type;
</pre></blockquote>
<p>
[The replacement "Returnable result_type" instead of "typename
result_type" is non-editorial, but maybe you prefer that as well]
</p>
</li>
<li>
<p>
In concept AdaptableBinaryFunction change
</p>
<blockquote><pre>
typename X::result_type;
typename X::first_argument_type;
typename X::second_argument_type;
</pre></blockquote>
<p>
to
</p>
<blockquote><pre>
Returnable result_type = typename X::result_type;
typename first_argument_type = typename X::first_argument_type;
typename second_argument_type = typename X::second_argument_type;
</pre></blockquote>
<p>
[The replacement "Returnable result_type" instead of "typename
result_type" is non-editorial, but maybe you prefer that as well.]
</p>
</li>

<li>
<p>
In class unary/binary_function
</p>
<ol style="list-style-type:lower-alpha">
<li>
I suggest to change "ReturnType" to "Returnable" in both cases.
</li>
<li>
I think you want to replace the remaining occurrences of "Predicate" by "P"
(in both classes in copy/move from a predicate)
</li>
</ol>
</li>
<li>
<p>
I think you need to change the proposed signatures of not1 and not2, because
they would still remain unconstrained: To make them constrained at least a
single requirement needs to be added to enable requirement implication. This
could be done via a dummy ("requires True&lt;true&gt;") or just explicit as follows:
</p>
<ol style="list-style-type:lower-alpha">
<li>
<blockquote><pre>
template &lt;AdaptableUnaryFunction P&gt;
requires Predicate&lt; P, P::argument_type&gt;
unary_negate&lt;P&gt; not1(const P&amp;&amp; pred);
template &lt;AdaptableUnaryFunction P&gt;
requires Predicate&lt; P, P::argument_type &gt;
unary_negate&lt;P&gt; not1(P&amp;&amp; pred);
</pre>
<blockquote><p>
-3- Returns: unary_negate&lt;P&gt;(pred).
</p></blockquote>
</blockquote>
<p>
[Don't we want a move call for the second overload as in
</p>
<blockquote><pre>
unary_negate&lt;P&gt;(std::move(pred))
</pre></blockquote>
<p>
in the Returns clause ?]
</p>
</li>
<li>
<pre>
template &lt;AdaptableBinaryFunction P&gt;
requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;
binary_negate&lt;P&gt; not2(const P&amp; pred);
template &lt;AdaptableBinaryFunction P&gt;
requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;
binary_negate&lt;P&gt; not2(P&amp;&amp; pred);
</pre>
<p>
-5- Returns: binary_negate&lt;P&gt;(pred).
</p>
<p>
[Don't we want a move call for the second overload as in
</p>
<blockquote><pre>
binary_negate&lt;P&gt;(std::move(pred))
</pre></blockquote>
<p>
in the Returns clause ?]
</p>
</li>
</ol>
</li>
</ol>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
There is concern that complicating the solution
to preserve the ABI seems unnecessary,
since we're not in general preserving the ABI.
</p>
<p>
We would prefer a separate paper consolidating all Clause 20
issues that are for the purpose of providing constrained versions
of the existing facilities.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Leave open pending the potential move constructor paper. Note that
we consider the "constraining" part NAD Concepts.
</p></blockquote>

<p><i>[
2010-01-31 Alisdair removes the current proposed wording from the proposed
wording section because it is based on concepts.  That wording is proposed here:
]</i></p>


<blockquote class="note">
<p>
Add new concepts where appropriate::
</p>

<blockquote><pre>
auto concept AdaptableUnaryFunction&lt; typename X &gt; {
  typename X::result_type;
  typename X::argument_type;
}

auto concept AdaptableBinaryFunction&lt; typename X &gt; {
  typename X::result_type;
  typename X::first_argument_type;
  typename X::second_argument_type;
}
</pre></blockquote>

<p>
Revise as follows:
</p>

<p>
Base  [base] (Only change is constrained Result)
</p>

<blockquote>
<p>
-1-  The following classes are provided to simplify the typedefs of the
argument and result types:
</p>
<pre>
namespace std {
  template &lt;class Arg, <del>class</del> <ins>ReturnType</ins> Result&gt;
  struct unary_function {
     typedef Arg    argument_type;
     typedef Result result_type;
  };

  template &lt;class Arg1, class Arg2, <del>class</del> <ins>ReturnType</ins> Result&gt;
  struct binary_function {
     typedef Arg1   first_argument_type;
     typedef Arg2   second_argument_type;
     typedef Result result_type;
  };
}
</pre></blockquote>

<p>
Negators  [negators]:
</p>

<blockquote>
<p>
-1- Negators <tt>not1</tt> and <tt>not2</tt> take a unary and a binary predicate,
respectively, and return their complements (5.3.1).
</p>

<pre>
template &lt;<del>class</del> <ins>AdaptableUnaryFunction</ins> P<del>redicate</del>&gt;
  <ins>requires Predicate&lt; P, P::argument_type &gt;</ins>
  class unary_negate
    : public unary_function&lt;<del>typename</del> P<del>redicate</del>::argument_type,bool&gt; {
  public:
    <ins>unary_negate(const unary_negate &amp; ) = default;</ins>
    <ins>unary_negate(unary_negate &amp;&amp; );</ins>

    <ins>requires CopyConstructible&lt; P &gt;</ins>
       explicit unary_negate(const Predicate&amp; pred); 
    <ins>requires MoveConstructible&lt; P &gt;
       explicit unary_negate(Predicate &amp;&amp; pred);</ins>

    bool operator()(const <del>typename</del> P<del>redicate</del>::argument_type&amp; x) const;
  };
</pre>
<blockquote><p>
-2 <tt>operator()</tt> returns <tt>!pred(x)</tt>.
</p></blockquote>

<pre>
template &lt;class Predicate&gt;
  unary_negate&lt;Predicate&gt; not1(const Predicate&amp;amp; pred);
<ins>template &lt;class Predicate&gt;
  unary_negate&lt;Predicate&gt; not1(Predicate&amp;&amp; pred);</ins>
</pre>
<blockquote><p>
-3-  <i>Returns:</i> <tt>unary_negate&lt;Predicate&gt;(pred)</tt>.
</p></blockquote>

<pre>
template &lt;<del>class</del> <ins>AdaptableBinaryFunction</ins> P<del>redicate</del> &gt;
  <ins>requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;</ins>
  class binary_negate
    : public binary_function&lt;<del>typename</del> P<del>redicate</del>::first_argument_type,
                              <del>typename</del> P<del>redicate</del>::second_argument_type, bool&gt; {
  public:
    <ins>biary_negate(const binary_negate &amp; ) = default;</ins>
    <ins>binary_negate(binary_negate &amp;&amp; );</ins>

    <ins>requires CopyConstructible&lt; P &gt;</ins>
       explicit binary_negate(const Predicate&amp; pred);
    <ins>requires MoveConstructible&lt; P &gt;
       explicit binary_negate(const Predicate&amp; pred);</ins>

    bool operator()(const <del>typename</del> P<del>redicate</del>::first_argument_type&amp; x,
                    const <del>typename</del> P<del>redicate</del>::second_argument_type&amp; y) const;
  };
</pre>
<blockquote><p>
-4- <tt>operator()</tt> returns <tt>!pred(x,y)</tt>.
</p></blockquote>

<pre>
template &lt;class Predicate&gt;
  binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred);
<ins>template &lt;class Predicate&gt;
  binary_negate&lt;Predicate&gt; not2(Predicate&amp;&amp; pred);</ins>
</pre>

<blockquote><p>
-5- <i>Returns:</i> <tt>binary_negate&lt;Predicate&gt;(pred)</tt>.
</p></blockquote>
</blockquote>

</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Move to NAD Concepts.  The move-semantic part has been addressed by a core language change, 
which implicitly generates appropriate move constructors and move-assignment operators.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1077" href="1077">1077.</a> Nonesense <tt>tuple</tt> declarations</h3>
<p><b>Section:</b> 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-03-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template tuple 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>:
</p>

<blockquote><pre>
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, const UTypes&amp;&gt;...
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
</pre></blockquote>

<p>
Somebody needs to look at this and say what it should be.
</p>

<p><i>[
2009-03-21 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
The resolution looks correct; move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, class <tt>tuple</tt>, change as indicated:
</p>

<blockquote><pre>
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, const UTypes&amp;&gt;...
  <ins>tuple(const pair&lt;UTypes...&gt;&amp;);</ins>
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
  <ins>tuple(pair&lt;UTypes...&gt;&amp;&amp;);</ins>
</pre></blockquote>

<p>
[NB.: The corresponding prototypes do already exist in 22.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>/7+8]
</p>





<hr>
<h3><a name="1078" href="1078">1078.</a> DE-17: Remove class type_index</h3>
<p><b>Section:</b> 22.11 <a href="https://timsong-cpp.github.io/cppwp/type.index">[type.index]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2009-03-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#type.index">issues</a> in [type.index].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 17</b></p>

<p>
DE-17: 
</p>
<p>
The class <tt>type_index</tt> should be removed; it provides no additional
functionality beyond providing appropriate concept maps.
</p>

<p><i>[
2009-03-31 Peter adds:
]</i></p>


<blockquote>
<p>
It is not true, in principle, that <tt>std::type_index</tt> provides no  utility
compared to bare <tt>std::type_info*</tt>.
</p>
<p>
<tt>std::type_index</tt> can avoid the lifetime issues with <tt>type_info</tt> when  the
DLL that has produced the <tt>type_info</tt> object is unloaded. A raw
<tt>type_info*</tt> does not, and cannot, provide any protection in this  case.
A <tt>type_index</tt> can (if the implementor so chooses) because it  can wrap a
smart (counted or even cloning) pointer to the <tt>type_info</tt>  data that is
needed for <tt>name()</tt> and <tt>before()</tt> to work.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Modify the header &lt;typeinfo&gt; synopsis in 
  17.8 <a href="https://timsong-cpp.github.io/cppwp/support.rtti">[support.rtti]</a>p1 as follows:</p>

<blockquote><pre>
namespace std { 
  class type_info; 
  <del>class type_index;</del>
  template &lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;<del>type_index</del><ins>const type_info *</ins>&gt; : public std::unary_function&lt;<del>type_index</del><ins>const type_info *</ins>, size_t&gt; {
    size_t operator()(<del>type_index</del><ins>const type_info *</ins> <del>index</del><ins>t</ins>) const;
  }<ins>;</ins>
  <ins>concept_map LessThanComparable&lt;const type_info *&gt; <i>see below</i></ins>
  class bad_cast; 
  class bad_typeid;
}
</pre></blockquote>

<p>Add the following new subsection</p>
<blockquote>
<p>
<ins>18.7.1.1 Template specialization <code>hash&lt;const type_info *&gt;</code>
[type.info.hash]</ins></p>

<pre>
<ins>size_t operator()(const type_info *x) const;</ins>
</pre>
<ol>
<li><ins><i>Returns</i>: <code>x-&gt;hash_code()</code></ins></li>
</ol>
</blockquote>

 <p>Add the following new subsection</p>
 <blockquote>
<p><ins>18.7.1.2 <code>type_info</code> concept map [type.info.concepts]</ins></p>


<pre>
<ins>concept_map LessThanComparable&lt;const type_info *&gt; {</ins>
  <ins>bool operator&lt;(const type_info *x, const type_info *y) { return x-&gt;before(*y); }</ins>
  <ins>bool operator&lt;=(const type_info *x, const type_info *y) { return !y-&gt;before(*x); }</ins>
  <ins>bool operator&gt;(const type_info *x, const type_info *y) { return y-&gt;before(*x); }</ins>
  <ins>bool operator&gt;=(const type_info *x, const type_info *y) { return !x-&gt;before(*y); }</ins>
<ins>}</ins>
</pre>
<ol>
  <li><ins><i>Note</i>: provides a well-defined ordering among
  <code>type_info const</code> pointers, which makes such pointers
  usable in associative containers (23.4).</ins></li>
</ol>
</blockquote>

<p>Remove section 22.11 <a href="https://timsong-cpp.github.io/cppwp/type.index">[type.index]</a></p>





<hr>
<h3><a name="1080" href="1080">1080.</a> Concept ArithmeticLike should provide explicit boolean  conversion</h3>
<p><b>Section:</b> 99 [concept.arithmetic] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-03-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Astonishingly, the current concept ArithmeticLike as specified in
99 [concept.arithmetic] does not provide explicit conversion
to <tt>bool</tt> although this is a common property of arithmetic types
(7.3.15 <a href="https://timsong-cpp.github.io/cppwp/conv.bool">[conv.bool]</a>). Recent proposals that introduced such types
(integers of arbitrary precision,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2143.pdf">n2143</a>,
decimals
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2732.pdf">n2732</a>
indirectly
via conversion to <tt>long long</tt>) also took care of such a feature.
</p>
<p>
Adding such an explicit conversion associated function would also
partly solve a currently invalid effects clause in library, which bases
on this property, 25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>/2:
</p>
<blockquote><pre>
{ difference_type m = n;
 if (m &gt;= 0) while (m--) ++r;
 else while (m++) --r;
 return r; }
</pre></blockquote>

<p>
Both while-loops take advantage of a contextual conversion to <tt>bool</tt>
(Another problem is that the &gt;= comparison uses the no
longer supported existing implicit conversion from <tt>int</tt> to <tt>IntegralLike</tt>).
</p>

<p><b>Original proposed resolution:</b></p>
<ol>
<li>
<p>
In 99 [concept.arithmetic], add to the list of less refined
concepts one further concept:
</p>

<blockquote><pre>
concept ArithmeticLike&lt;typename T&gt;
  : Regular&lt;T&gt;, LessThanComparable&lt;T&gt;, HasUnaryPlus&lt;T&gt;, HasNegate&lt;T&gt;,
    HasPlus&lt;T, T&gt;, HasMinus&lt;T, T&gt;, HasMultiply&lt;T, T&gt;, HasDivide&lt;T, T&gt;,
    HasPreincrement&lt;T&gt;, HasPostincrement&lt;T&gt;, HasPredecrement&lt;T&gt;,
    HasPostdecrement&lt;T&gt;,
    HasPlusAssign&lt;T, const T&amp;&gt;, HasMinusAssign&lt;T, const T&amp;&gt;,
    HasMultiplyAssign&lt;T, const T&amp;&gt;,
    HasDivideAssign&lt;T, const T&amp;&gt;<ins>, ExplicitlyConvertible&lt;T, bool&gt;</ins> {
</pre></blockquote>
</li>
<li>
<p>
In 25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>/2 change the current effects clause
as indicated [The proposed insertion fixes the problem that the previous
implicit construction from integrals has been changed to an explicit
constructor]:
</p>
<blockquote><pre>
{ difference_type m = n;
 if (m &gt;= <ins>difference_type(</ins>0<ins>)</ins>) while (m--) ++r;
 else while (m++) --r;
 return r; }
</pre></blockquote>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree that arithmetic types ought be convertible to <tt>bool</tt>,
and we therefore agree with the proposed resolution's paragraph 1.
</p>
<p>
We do not agree that the cited effects clause is invalid,
as it expresses intent rather than specific code.
</p>
<p>
Move to Review, pending input from concepts experts.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 99 [concept.arithmetic], add to the list of less refined
concepts one further concept:
</p>

<blockquote><pre>
concept ArithmeticLike&lt;typename T&gt;
  : Regular&lt;T&gt;, LessThanComparable&lt;T&gt;, HasUnaryPlus&lt;T&gt;, HasNegate&lt;T&gt;,
    HasPlus&lt;T, T&gt;, HasMinus&lt;T, T&gt;, HasMultiply&lt;T, T&gt;, HasDivide&lt;T, T&gt;,
    HasPreincrement&lt;T&gt;, HasPostincrement&lt;T&gt;, HasPredecrement&lt;T&gt;,
    HasPostdecrement&lt;T&gt;,
    HasPlusAssign&lt;T, const T&amp;&gt;, HasMinusAssign&lt;T, const T&amp;&gt;,
    HasMultiplyAssign&lt;T, const T&amp;&gt;,
    HasDivideAssign&lt;T, const T&amp;&gt;<ins>, ExplicitlyConvertible&lt;T, bool&gt;</ins> {
</pre></blockquote>





<hr>
<h3><a name="1081" href="1081">1081.</a> <tt>basic_string</tt> needs to be a concept-constrained template</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 216, JP 46, JP 48 [CD1]</b></p>

<p>
All the containers use concepts for their iterator usage, exect for
<tt>basic_string</tt>. This needs fixing.
</p>

<p>
Use concepts for iterator template parameters throughout the chapter.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
NB comments to be handled by Dave Abrahams and Howard Hinnant with
advice from PJP: UK216 (which duplicates) JP46, JP48. JP46 supplies
extensive proposed wording; start there.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1082" href="1082">1082.</a> <tt>codecvt</tt> needs to be a concept-constrained template</h3>
<p><b>Section:</b> 30 <a href="https://timsong-cpp.github.io/cppwp/localization">[localization]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 49 [CD1]</b></p>

<p>
<tt>codecvt</tt> does not use concept. For example, create <tt>CodeConvert</tt>
concept and change as follows.
</p>

<blockquote><pre>
template&lt;CodeConvert Codecvt, class Elem = wchar_t&gt;
  class wstring_convert {
</pre></blockquote>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
To be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1083" href="1083">1083.</a> <tt>InputIterator</tt> and <tt>OutputIterator</tt> template parameters need to be concept constraints</h3>
<p><b>Section:</b> 30 <a href="https://timsong-cpp.github.io/cppwp/localization">[localization]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 52, JP 53 [CD1]</b></p>

<p>
<tt>InputIterator</tt> does not use concept.
</p>

<p>
<tt>OutputIterator</tt> does not use concept.
</p>

<p>
Comments include proposed wording.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
To be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1084" href="1084">1084.</a> Concept <tt>ForwardIterator</tt> should provide default implementation for post-increment</h3>
<p><b>Section:</b> 25.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 250 [CD1]</b></p>

<p>
A default implementation should be supplied for the post-increment
operator to simplify implementation of iterators by users.
</p>

<p>
Copy the Effects clause into the concept description as the default
implementation. Assumes a default value for <tt>postincrement_result</tt>.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
Howard will open an issue.
</p></blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote><p>
This issue cannot currently be resolved as suggested, because
that would render auto-detection of the return type
<tt>postincrement_result</tt> invalid, see  [concept.map.assoc]/4+5. The
best fix would be to add a default type to that associated type, but
unfortunately any default type will prevent auto-deduction of types of
associated functions as quoted above. A corresponding core issue
is in preparation.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>[
This wording assumes the acceptance of UK 251 / <a href="1009">1009</a>.  Both
wordings change the same paragraphs.
]</i></p>


<p>
Change 25.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a>:
</p>

<blockquote>
<pre>
concept ForwardIterator&lt;typename X&gt; : InputIterator&lt;X&gt;, Regular&lt;X&gt; { 

  MoveConstructible postincrement_result;
  requires HasDereference&lt;postincrement_result&gt;
        &amp;&amp; Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;

  postincrement_result operator++(X&amp; r, int)<del>;</del> <ins>{
     X tmp = r;
     ++r;
     return tmp;
  }</ins>

  axiom MultiPass(X a, X b) { 
    if (a == b) *a == *b; 
    if (a == b) ++a == ++b; 
  } 
}
</pre></blockquote>






<hr>
<h3><a name="1085" href="1085">1085.</a> <tt>BidirectionalIterator</tt> concept should provide default implementation for post-decrement</h3>
<p><b>Section:</b> 25.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 258 [CD1]</b></p>

<p>
A default implementation should be supplied for the post-decrement
operator to simplify implementation of iterators by users.
</p>

<p>
Copy the Effects clause into the concept description as the default
implementation. Assumes a default value for <tt>postincrement_result</tt>.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
Howard will open an issue.
</p></blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote><p>
This issue cannot currently be resolved as suggested, because
that would render auto-detection of the return type
<tt>postdecrement_result</tt> invalid, see <a href="1084">1084</a>.
</p></blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change 25.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a>:
</p>

<blockquote>
<pre>
concept BidirectionalIterator&lt;typename X&gt; : ForwardIterator&lt;X&gt; { 
  MoveConstructible postdecrement_result; 
  requires HasDereference&lt;postdecrement_result&gt; 
        &amp;&amp; Convertible&lt;HasDereference&lt;postdecrement_result&gt;::result_type, const value_type&amp;&gt; 
        &amp;&amp; Convertible&lt;postdecrement_result, const X&amp;&gt;; 
  X&amp; operator--(X&amp;); 
  postdecrement_result operator--(X&amp; <ins>r</ins>, int)<del>;</del> <ins>{
     X tmp = r;
     --r;
     return tmp;
  }</ins>
}
</pre></blockquote>






<hr>
<h3><a name="1086" href="1086">1086.</a> Stream iterators need to be concept-constrained templates</h3>
<p><b>Section:</b> 25.6 <a href="https://timsong-cpp.github.io/cppwp/stream.iterators">[stream.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#stream.iterators">issues</a> in [stream.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 284 [CD1]</b></p>

<p>
The stream iterators need constraining with concepts/requrires clauses.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
We agree. To be handled by Howard, Martin and PJ.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1087" href="1087">1087.</a> Incorrect <tt>OutputIterator</tt> concept requirements for <tt>replace</tt> algorithms</h3>
<p><b>Section:</b> 27.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 301 [CD1]</b></p>

<p>
<tt>replace</tt> and <tt>replace_if</tt> have the requirement: <tt>OutputIterator&lt;Iter,
Iter::reference&gt;</tt> Which implies they need to copy some values in the
range the algorithm is iterating over. This is not however the case, the
only thing that happens is <tt>const T&amp;</tt>s might be copied over existing
elements (hence the <tt>OutputIterator&lt;Iter, const T&amp;&gt;</tt>.
</p>

<p>
Remove <tt>OutputIterator&lt;Iter, Iter::reference&gt;</tt> from <tt>replace</tt>
and <tt>replace_if</tt>.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
We agree. To be handled by Howard.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change in  [algorithms.syn] and 27.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a>:
</p>

<blockquote><pre>
template&lt;ForwardIterator Iter, class T&gt; 
  requires <del>OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp;</del> OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;Iter::value_type, T&gt; 
  void replace(Iter first, Iter last, 
               const T&amp; old_value, const T&amp; new_value); 

template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred, class T&gt; 
  requires <del>OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp;</del> OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  void replace_if(Iter first, Iter last,
                  Pred pred, const T&amp; new_value);
</pre></blockquote>





<hr>
<h3><a name="1091" href="1091">1091.</a> Multimap description confusing</h3>
<p><b>Section:</b> 24.4.5.3 <a href="https://timsong-cpp.github.io/cppwp/multimap.modifiers">[multimap.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 246</b></p>
<p>
The content of this sub-clause is purely trying to describe in words the
effect of the requires clauses on these operations, now that we have
Concepts. As such, the description is more confusing than the signature
itself. The semantic for these functions is adequately covered in the
requirements tables in 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>.
</p>

<p><i>[
Beman adds:
]</i></p>


<blockquote><p>
Pete is clearly right that
this one is technical rather than editorial.
</p></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD, solved by removing concepts.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 24.4.5.3 <a href="https://timsong-cpp.github.io/cppwp/multimap.modifiers">[multimap.modifiers]</a> entirely
(but do NOT strike these signatures from the class template definition!).
</p>





<hr>
<h3><a name="1092" href="1092">1092.</a> Class template <tt>integral_constant</tt> should be a  constrained template</h3>
<p><b>Section:</b> 21.3.4 <a href="https://timsong-cpp.github.io/cppwp/meta.help">[meta.help]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A first step to change the type traits predicates to constrained templates is to
constrain their common base template <tt>integral_constant</tt>. This can be done,
without enforcing depending classes to be constrained as well, but not
vice versa
without brute force <tt>late_check</tt> usages. The following proposed resolution depends
on the resolution of LWG issue <a href="1019">1019</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open, pending a paper that looks at constraints
for the entirety of the type traits
and their relationship to the foundation concepts.
We recommend this be deferred
until after the next Committee Draft is issued.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>, Header <tt>&lt;type_traits&gt;</tt>
synopsis change as indicated:
</p>
<blockquote><pre>
namespace std {
// 20.5.3, helper class:
template &lt;<del>class</del><ins>IntegralConstantExpressionType</ins> T, T v&gt; struct integral_constant;
</pre></blockquote>
</li>
<li>
<p>
In 21.3.4 <a href="https://timsong-cpp.github.io/cppwp/meta.help">[meta.help]</a> change as indicated:
</p>
<blockquote><pre>
template &lt;<del>class</del><ins>IntegralConstantExpressionType</ins> T, T v&gt;
struct integral_constant {
  static constexpr T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
  constexpr operator value_type() { return value; }
};
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1096" href="1096">1096.</a> unconstrained rvalue ref parameters</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TODO: Look at all cases of unconstrained rvalue ref parameters and check
that concept req'ts work when <tt>T</tt> deduced as reference.
</p>

<p>
 We found some instances where that was not done correctly and we figure
   the possibility of deducing <tt>T</tt> to be an lvalue reference was probably
   overlooked elsewhere.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open, pending proposed wording from Dave for further review.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1099" href="1099">1099.</a> Various issues</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Notes
</p>
<blockquote>
<p>
[2009-03-21 Sat] p. 535 at the top we need MoveConstructible V1,
MoveConstructible V2 (where V1,V2 are defined on 539).  Also make_tuple
on 550
</p>

<blockquote>
<p>
CD-1 reads:
</p>

<blockquote><pre>
template &lt;MoveConstructible T1, MoveConstructible T2&gt; 
pair&lt;V1, V2&gt; make_pair(T1&amp;&amp;, T2&amp;&amp;); 
</pre></blockquote>

<p>
Actually I'm guessing we need something like <tt>MoveConstructible&lt;V1,T1&gt;</tt>,
i.e. "<tt>V1</tt> can be constructed from an rvalue of type <tt>T1</tt>."
</p>

<p>
Ditto for <tt>make_tuple</tt>
</p>
</blockquote>

<p>
[2009-03-21 Sat] p1183 thread ctor, and in general, we need a way to
talk about "copiable from generalized rvalue ref argument" for cases
where we're going to forward and copy.  
</p>
<blockquote>
<p>
   This issue may well be quite large.  Language in para 4 about "if
   an lvalue" is wrong because types aren't expressions.
</p>

<blockquote>
<p>
Maybe we should define the term "move" so we can just say in the
effects, "<tt>f</tt> is moved into the newly-created thread" or something, and
agree (and ideally document) that saying "<tt>f</tt> is moved" implies 
</p>

<blockquote><pre>
F x(move(f))
</pre></blockquote>

<p>
is required to work.  That would cover both ctors at once.
</p>
</blockquote>

<p>
   p1199, call_once has all the same issues.
</p>
</blockquote>
<p>
[2009-03-21 Sat] p869 InputIterator pointer type should not be required
to be convertible to const value_type*, rather it needs to have a
operator-> of its own that can be used for the value type.
</p>

<blockquote><p>
This one is serious and unrelated to the move issue.
</p></blockquote>

<p>
[2009-03-21 Sat] p818 stack has the same problem with default ctor.
</p>
<p>
[2009-03-21 Sat] p816 priority_queue has the same sorts of problems as queue, only more so
</p>
<blockquote><pre>
   requires MoveConstructible&lt;Cont&gt; 
     explicit priority_queue(const Compare&amp; x = Compare(), Cont&amp;&amp; = Cont()); 
</pre>
<p>
   Don't require MoveConstructible when default constructing Cont.
   Also missing semantics for move ctor.
</p>
</blockquote>
<p>
 [2009-03-21 Sat] Why are Allocators required to be CopyConstructible as
 opposed to MoveConstructible?
</p>
<p>
 [2009-03-21 Sat] p813 queue needs a separate default ctor (Cont needn't
 be MoveConstructible).  No documented semantics for move c'tor.  Or
 *any* of its 7 ctors!
</p>
<p>
 [2009-03-21 Sat] std::array should have constructors for C++0x,
 consequently must consider move construction.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote><p>
This could be done as part of <a href="1035">1035</a>, which already handles
deviation of <tt>std::array</tt> from container tables.
</p></blockquote>

<p>
 [2009-03-21 Sat] p622 all messed up.
</p>
<blockquote>
<p>
   para 8 "implementation-defined" is the wrong term; should be "see
   below" or something.  
<p/>
   para 12 "will be selected" doesn't make any sense because we're not
   talking about actual arg types.
<p/>
   paras 9-13 need to be totally rewritten for concepts.
</p>
</blockquote>

<p>
 [2009-03-21 Sat] Null pointer comparisons (p587) have all become
 unconstrained.  Need to fix that
<p/>
 [2009-03-21 Sat] mem_fun_t etc. definition doesn't match declaration.
  We think CopyConstructible is the right reqt.
<p/>
 make_pair needs Constructible&lt;V1, T1&amp;&amp;&gt; requirements!
<p/>
 make_tuple needs something similar
<p/>
 tuple bug in synopsis:
</p>
<blockquote><pre>
   template &lt;class... UTypes&gt;
   requires Constructible&lt;Types, const UTypes&amp;&gt;...
   template &lt;class... UTypes&gt;
   requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
</pre>
<p>
   Note: removal of MoveConstructible requirements in std::function makes
   these routines unconstrained!
</p>
</blockquote>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote><p>
This part of the issue is already covered by <a href="1077">1077</a>.
</p></blockquote>

<p>
 these unique_ptr constructors are broken [ I think this is covered in "p622 all messed up" ]
</p>
<blockquote><pre>
 unique_ptr(pointer p, implementation-defined d);
 unique_ptr(pointer p, implementation-defined d);
</pre></blockquote>
<p>
 multimap range constructor should not have MoveConstructible&lt;value_type&gt; requirement.
</p>
<blockquote><p>
   same with <tt>insert(..., P&amp;&amp;);</tt> <tt>multiset</tt> has the same issue, as do
   <tt>unordered_multiset</tt> and <tt>unordered_multimap</tt>. Review these!
</p></blockquote>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open, pending proposed wording from Dave for further review.
</p></blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Tentatively NAD.  We are not sure what has been addressed and what hasn't.
Recommend closing unless someone sorts this out into something more readable.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
The issue(s) at hand not adequately communicated.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1101" href="1101">1101.</a> <tt>unique</tt> requirements</h3>
<p><b>Section:</b> 27.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From Message c++std-core-14160 Howard wrote:
</p>

<blockquote><p>
It was the intent of the rvalue reference proposal for unique to only require MoveAssignable:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html#25.2.9%20-%20Unique">N1860</a>.
</p></blockquote>

<p>
And Pete replied:
</p>

<blockquote><p>
That was overridden by the subsequent changes made for concepts in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2573.pdf">N2573</a>,
which reimposed the C++03 requirements.
</p></blockquote>

<p>
My impression is that this overwrite was a simple (unintentional) mistake.
Wording below to correct it.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard notes this issue resolves a discrepancy between the synopsis
and the description.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a>:
</p>

<blockquote><pre>
template&lt;ForwardIterator Iter&gt; 
  requires OutputIterator&lt;Iter, <ins>RvalueOf&lt;</ins>Iter::reference<ins>&gt;::type</ins>&gt; 
        &amp;&amp; EqualityComparable&lt;Iter::value_type&gt; 
  Iter unique(Iter first, Iter last); 

template&lt;ForwardIterator Iter, EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred&gt; 
  requires OutputIterator&lt;Iter, RvalueOf&lt;Iter::reference&gt;::type&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  Iter unique(Iter first, Iter last, Pred pred);
</pre></blockquote>

<p>
Note that the synopsis in  [algorithms.syn] is already correct.
</p>






<hr>
<h3><a name="1105" href="1105">1105.</a> Shouldn't <tt>Range</tt> be an <tt>auto concept</tt></h3>
<p><b>Section:</b> 99 [iterator.concepts.range] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-04-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><i>[
2009-04-26 Herb adds:
]</i></p>


<blockquote>
<p>
Here's a common example: We have many ISV customers who have built lots of
in-house STL-like containers. Imagine that, for the past ten years, the user
has been happily using his <tt>XYZCorpContainer&lt;T&gt;</tt> that has <tt>begin()</tt> and <tt>end()</tt>
and an iterator typedef, and indeed satisfies nearly all of <tt>Container</tt>,
though maybe not quite all just like <tt>valarray</tt>. The user upgrades to a
range-enabled version of a library, and now <tt>lib_algo( xyz.begin(), xyz.end());</tt>
no longer works -- compiler error.
</p>
<p>
Even though <tt>XYZCorpContainer</tt> matches the pre-conceptized version of the
algorithm, and has been working for years, it appears the user has to write
at least this:
</p>
<blockquote><pre>
template&lt;class T&gt; concept_map Range&lt;XYZCorpContainer&lt;T&gt;&gt; {};

template&lt;class T&gt; concept_map Range&lt;const XYZCorpContainer&lt;T&gt;&gt; {};
</pre></blockquote>
<p>
Is that correct?
</p>
<p>
But he may actually have to write this as we do for initializer list:
</p>
<blockquote><pre>
template&lt;class T&gt;
concept_map Range&lt;XYZCorpContainer&lt;T&gt;&gt; {
   typedef T* iterator;
   iterator begin(XYZCorpContainer&lt;T&gt; c) { return c.begin(); }
   iterator end(XYZCorpContainer&lt;T&gt; c) { return c.end(); }
};

template&lt;class T&gt;
concept_map Range&lt;const XYZCorpContainer&lt;T&gt;&gt; {
   typedef T* iterator;
   iterator begin(XYZCorpContainer&lt;T&gt; c) { return c.begin(); }
   iterator end(XYZCorpContainer&lt;T&gt; c) { return c.end(); }
};
</pre></blockquote>

</blockquote>

<p><i>[
2009-04-28 Alisdair adds:
]</i></p>


<blockquote>
<p>
I recommend NAD, although remain concerned about header organisation.
</p>
<p>
A user container will satisfy the <tt>MemberContainer</tt> concept, which IS auto.
There is a concept_map for all <tt>MemberContainers</tt> to <tt>Container</tt>, and then a
further concept_map for all <tt>Container</tt> to <tt>Range</tt>, so the stated problem is not
actually true.  User defined containers will automatically match the <tt>Range</tt>
concept without explicitly declaring a concept_map.
</p>
<p>
The problem is that they should now provide an additional two headers,
<tt>&lt;iterator_concepts&gt;</tt> and <tt>&lt;container_concepts&gt;</tt>.
 The only difference from
making <tt>Range</tt> an auto concept would be this reduces to a single header,
<tt>&lt;iterator_concepts&gt;</tt>.
</p>
<p>
I am strongly in favour of any resolution that tackles the issue of
explicitly requiring concept headers to make these concept maps available.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We observe there is a recent paper by Bjarne that overlaps this issue.
</p>
<p>
Alisdair continues to recommend NAD.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1107" href="1107">1107.</a> constructor <tt>shared_future(unique_future)</tt> by value?</h3>
<p><b>Section:</b> 33.10.8 <a href="https://timsong-cpp.github.io/cppwp/futures.shared.future">[futures.shared.future]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Thomas J. Gritzan <b>Opened:</b> 2009-04-03 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.shared.future">issues</a> in [futures.shared.future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the <tt>shared_future</tt> class definition in  [futures.shared_future]
the move constructor
that constructs a <tt>shared_future</tt> from an <tt>unique_future</tt> receives the
parameter by value. In paragraph 3, the same constructor receives it as
const value.
</p>

<p>
I think that is a mistake and the constructor should take a r-value
reference:
</p>

<blockquote><pre>
shared_future(unique_future&lt;R&gt;&amp;&amp; rhs);
</pre></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
<p/>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07-05 Daniel notes:
]</i></p>


<blockquote><p>
The proposed change has already been incorported into the current working draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in  [futures.shared_future]:
</p>

<blockquote><pre>
shared_future(unique_future&lt;R&gt;<ins>&amp;&amp;</ins> rhs);
</pre></blockquote>

<p>
Change the definition of the constructor in  [futures.shared_future]:
</p>

<blockquote><pre>
shared_future(<del>const</del> unique_future&lt;R&gt;<ins>&amp;&amp;</ins> rhs);
</pre></blockquote>






<hr>
<h3><a name="1109" href="1109">1109.</a> <tt>std::includes</tt> should require <tt>CopyConstructible</tt> predicate</h3>
<p><b>Section:</b> 27.8.7.2 <a href="https://timsong-cpp.github.io/cppwp/includes">[includes]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#includes">issues</a> in [includes].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All the set operation algorithms require a <tt>CopyConstructible</tt> predicate, with
the exception of <tt>std::includes</tt>.  This looks like a typo as much as anything,
given the general library requirement that predicates are copy
constructible, and wording style of other set-like operations.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
We agree with the proposed resolution.
Move to NAD Editorial.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change  [algorithms.syn] and 27.8.7.2 <a href="https://timsong-cpp.github.io/cppwp/includes">[includes]</a>:
</p>

<blockquote><pre>
template&lt;InputIterator Iter1, InputIterator Iter2,
         <del>typename</del> <ins>CopyConstructible</ins> Compare&gt;
  requires Predicate&lt;Compare, Iter1::value_type, Iter2::value_type&gt;
        &amp;&amp; Predicate&lt;Compare, Iter2::value_type, Iter1::value_type&gt;
  bool includes(Iter1 first1, Iter1 last1,
                Iter2 first2, Iter2 last2,
                Compare comp);
</pre></blockquote>





<hr>
<h3><a name="1111" href="1111">1111.</a> associative containers underconstrained</h3>
<p><b>Section:</b> 24.4 <a href="https://timsong-cpp.github.io/cppwp/associative">[associative]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to table 87 (n2857) the expression <tt>X::key_equal</tt> for an unordered
container shall return a value of type <tt>Pred</tt>, where <tt>Pred</tt> is an equivalence
relation.
</p>

<p>
However, all 4 containers constrain <tt>Pred</tt> to be merely a <tt>Predicate</tt>,
and not <tt>EquivalenceRelation</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
For ordered containers, replace 
</p>
<blockquote><pre>
Predicate&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
with 
</p>
<blockquote><pre>
StrictWeakOrder&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>

<p>
For unordered containers, replace 
</p>
<blockquote><pre>
Predicate&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
with 
</p>
<blockquote><pre>
EquivalenceRelation&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
As in the following declarations:
</p>

<blockquote>
<p>
Associative containers 24.4 <a href="https://timsong-cpp.github.io/cppwp/associative">[associative]</a>
</p>
<p>
 1 Headers <tt>&lt;map&gt;</tt> and <tt>&lt;set&gt;</tt>:
</p>
<p>
   Header <tt>&lt;map&gt;</tt> synopsis
</p>
<blockquote><pre>
   namespace std {
     template &lt;ValueType Key, ValueType T,
               <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
             &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class map;

     ...

     template &lt;ValueType Key, ValueType T,
               <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
             &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class multimap;

     ...

   }
</pre></blockquote>

<p>
   Header &lt;set&gt; synopsis
</p>
<blockquote><pre>
   namespace std {
     template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;Key&gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class set;

     ...

     template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;Key&gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class multiset;

     ...

   }
</pre></blockquote>

<p>
 23.4.1p2 Class template map [map]
</p>
<blockquote><pre>
 namespace std {
   template &lt;ValueType Key, ValueType T,
             <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class map {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.2p2 Class template multimap [multimap]
</p>
<blockquote><pre>
 namespace std {
   template &lt;ValueType Key, ValueType T,
             <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class multimap {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.3p2 Class template set [set]
</p>
<blockquote><pre>
 namespace std {
   template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;Key&gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class set {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.4p2 Class template multiset [multiset]
</p>
<blockquote><pre>
 namespace std {
   template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;Key&gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class multiset {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5 Unordered associative containers [unord]
</p>
<p>
 1 Headers &lt;unordered_map&gt; and &lt;unordered_set&gt;:
</p>
<p>
 Header &lt;unordered_map&gt; synopsis
</p>
<blockquote><pre>
 namespace std {
   // 23.5.1, class template unordered_map:
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_map;

   // 23.5.2, class template unordered_multimap:
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_multimap;

   ...
 }
</pre></blockquote>

<p>
 Header &lt;unordered_set&gt; synopsis
</p>
<blockquote><pre>
 namespace std {
   // 23.5.3, class template unordered_set:
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_set;

   // 23.5.4, class template unordered_multiset:
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_multiset;

   ...
 }
</pre></blockquote>

<p>
 23.5.1p3 Class template unordered_map [unord.map]
</p>
<blockquote><pre>
 namespace std {
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_map
   {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5.2p3 Class template unordered_multimap [unord.multimap]
</p>
<blockquote><pre>
 namespace std {
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_multimap
   {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5.3p3 Class template unordered_set [unord.set]
</p>
<blockquote><pre>
 namespace std {
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_set
   {
     ...
   };
 }
</pre></blockquote>
<p>
 23.5.4p3 Class template unordered_multiset [unord.multiset]
</p>
<blockquote><pre>
 namespace std {
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_multiset
   {
     ...
   };
 }
</pre></blockquote>

</blockquote>






<hr>
<h3><a name="1112" href="1112">1112.</a> bitsets and new style for loop</h3>
<p><b>Section:</b> 22.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-06 <b>Last modified:</b> 2018-06-23 21:28:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::bitset</tt> is a homogeneous container-like sequence of bits, yet it does
not model the Range concept so cannot be used with the new for-loop syntax.
It is the only such type in the library that does NOT support the new for
loop.
</p>
<p>
The obvious reason is that bitset does not support iterators.
</p>
<p>
At least two reasonable solutions are available:
</p>
<ol style="list-style-type:lower-roman">
<li>
Add an iterator interface to <tt>bitset</tt>, bringing its interface close to that
of <tt>std::array</tt>
</li>
<li>
Provide an unspecified concept_map for <tt>Range&lt;bitset&gt;</tt>.
</li>
</ol>
<p>
The latter will still need some kind of iterator-like adapter for <tt>bitset</tt>,
but gives implementers greater freedom on the details. E.g. begin/end return
some type that simply invokes <tt>operator[]</tt> on the object it wraps, and
increments its index on <tt>operator++</tt>.  A vendor can settle for <tt>InputIterator</tt>
support, rather than wrapping up a full <tt>RandomAccessIterator</tt>.
</p>
<p>
I have a mild preference for option (ii) as I think it is less work to
specify at this stage of the process, although (i) is probably more useful
in the long run.
</p>
<p>
Hmm, my wording looks a little woolly, as it does not say what the element
type of the range is.  Do I get a range of <tt>bool</tt>, <tt>bitset&lt;N&gt;::reference</tt>, or
something else entirely?
</p>
<p>
I guess most users will assume the behaviour of reference, but expect to
work with <tt>bool</tt>.  <tt>Bool</tt> is OK for read-only traversal, but you really need to
take a reference to a <tt>bitset::reference</tt> if you want to write back.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open.
We further recommend this be deferred until after the next Committee Draft.
</p></blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
<p>
I just stumbled over the <tt>Range concept_map</tt> for <tt>valarray</tt> and this should
probably set the precedent on how to write the wording.
</p>

<p><i>[
Howard: I've replaced the proposed wording with Alisdair's suggestion.
]</i></p>


</blockquote>

<p><i>[
2009-07-24 Daniel modifies the proposed wording for non-concepts.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Mark as Tentatively NAD Future due to the loss of concepts.
</p></blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>There are better APIs for bits coming, and seems to be consensus
in LEWG not to polish bitset any further.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Resolve as NAD</p>


<p><b>Rationale:</b></p>
<p>
All concepts-related text has been removed from the draft.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Modify the section 22.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> <tt>&lt;bitset&gt;</tt> synopsis by adding
the following at the end of the synopsis:
</p>
<blockquote><pre>
<ins>
// XX.X.X bitset range access [bitset.range]
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins>
</pre></blockquote>
</li>
<li>
<p>
Add a new section <ins>"bitset range access" [bitset.range]</ins>
after the current section 22.9.4 <a href="https://timsong-cpp.github.io/cppwp/bitset.operators">[bitset.operators]</a> with the following series of
paragraphs:
</p>
<blockquote>
<p>
<ins>
1.  In the <tt>begin</tt> and <tt>end</tt> function templates that follow, <i>unspecified-1</i>
is a type that meets the requirements of a mutable random access
iterator (25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>) whose <tt>value_type</tt> is <tt>bool</tt> and
whose reference type is <tt>bitset&lt;N&gt;::reference</tt>.
<i>unspecified-2</i> is a type that meets the requirements of a constant
random access iterator (25.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>) whose <tt>value_type</tt>
is <tt>bool</tt> and whose reference type is <tt>bool</tt>.
</ins>
</p>
<pre>
<ins>
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
</ins>
</pre>
<blockquote><p>
<ins>2.  Returns: an iterator referencing the first bit in the bitset.</ins>
</p></blockquote>

<pre><ins>
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins></pre>

<blockquote><p>
<ins>3.  Returns: an iterator referencing one past the last bit in the
bitset.</ins>
</p></blockquote>
</blockquote>
</li>
</ol>












<hr>
<h3><a name="1115" href="1115">1115.</a> <tt>va_copy</tt> missing from Standard macros table</h3>
<p><b>Section:</b> C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Miles Zhao <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In "Table 122 &mdash; Standard macros" of C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a>, which lists the 56 macros
inherited from C library, <tt>va_copy</tt> seems to be missing. But in
"Table 21 &mdash; Header <tt>&lt;cstdarg&gt;</tt> synopsis" (17.14 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>), there is.
</p>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Mark as Tentatively NAD Editorial, if Pete disagrees, Howard
will move to Tentatively Ready
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>va_copy</tt> to Table 122 -- Standard macros in C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a>.
</p>





<hr>
<h3><a name="1119" href="1119">1119.</a> tuple query APIs do not support references</h3>
<p><b>Section:</b> 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>tuple</tt> query APIs <tt>tuple_size</tt> and
<tt>tuple_element</tt> do not support references-to-tuples.  This can be
annoying when a template deduced a parameter type to be a reference,
which must be explicitly stripped with <tt>remove_reference</tt> before calling
these APIs.
</p>
<p>
I am not proposing a resolution at this point, as there is a
combinatorial explosion with lvalue/rvalue references and
cv-qualification (see previous issue) that suggests some higher
refactoring is in order.  This might be something to kick back over to
Core/Evolution.
</p>
<p>
Note that we have the same problem in numeric_limits.
</p>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Move to Open. Alisdair to provide wording.
</p></blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Move to NAD.  This is an extension after the FCD, without a clear motivation.  
May consider as NAD Future if motivating examples come forward.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1120" href="1120">1120.</a> New type trait - <tt>remove_all</tt></h3>
<p><b>Section:</b> 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sometimes it is necessary to remove all qualifiers from a type before
passing on to a further API.  A good example would be calling the
<tt>tuple</tt> query APIs <tt>tuple_size</tt> or <tt>tuple_element</tt>
with a deduced type inside a function template.  If the deduced type is
cv-qualified or a reference then the call will fail.  The solution is to
chain calls to
<tt>remove_cv&lt;remove_reference&lt;T&gt;::type&gt;::type</tt>, and
note that the order matters.
</p>
<p>
Suggest it would be helpful to add a new type trait,
<tt>remove_all</tt>, that removes all top-level qualifiers from a type
i.e. cv-qualification and any references.  Define the term in such a way
that if additional qualifiers are added to the language, then
<tt>remove_all</tt> is defined as stripping those as well.
</p>

<p><i>[
2009-10-14 Daniel adds:
]</i></p>


<blockquote><p>
<tt>remove_all</tt> seems too generic, a possible alternative matching
the current naming style could be <tt>remove_cv_reference</tt> or
<tt>remove_reference_cv</tt>. It should also be considered whether this
trait should also remove 'extents', or pointer 'decorations'. Especially
if the latter situations are considered as well, it might be easier to
chose the name not in terms of what it <em>removes</em> (which might be
a lot), but in terms of it <em>creates</em>. In this case I could think
of e.g. <tt>extract_value_type</tt>.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.
</p></blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>Send a paper to reopen: we'll need to bikeshed names if we decide to
pursue such a design. It'll need to discuss difference between this
and decay, and make choices about array types, and discuss why references
are removed but not pointers.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Resolve as NAD; note that <a href="https://wg21.link/p0550">P0550</a> addresses this</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1121" href="1121">1121.</a> Support for multiple arguments</h3>
<p><b>Section:</b> 21.4.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both add and multiply could sensibly be called with more than two arguments.
The variadic template facility makes such declarations simple, and is likely
to be frequently wrapped by end users if we do not supply the variant
ourselves.
</p>
<p>
We deliberately ignore divide at this point as it is not transitive.
Likewise, subtract places special meaning on the first argument so I do not
suggest extending that immediately.  Both could be supported with analogous
wording to that for add/multiply below.
</p>
<p>
Note that the proposed resolution is potentially incompatible with that
proposed for <a href="921">921</a>, although the addition of the typedef to ratio would be
equally useful.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The consensus of the group when we reviewed this in Santa Cruz was that
<a href="921">921</a> would proceed to Ready as planned, and the
multi-paramater add/multiply templates should be renamed as
<tt>ratio_sum</tt> and <tt>ratio_product</tt> to avoid the problem
mixing template aliases with partial specializations.
</p>

<p>
It was also suggested to close this issue as NAD Future as it does not
correspond directly to any NB comment.  NBs are free to submit a
specific comment (and re-open) in CD2 though.
</p>

<p>
Walter Brown also had concerns on better directing the order of
evaluation to avoid overflows if we do proceed for 0x rather than TR1,
so wording may not be complete yet.
</p>

<p><i>[
Alisdair updates wording.
]</i></p>


<p><i>[
2009-10-30 Howard:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>PR for <tt>ratio_product</tt> is wrong, uses <tt>ratio_add</tt> instead of <tt>ratio_multiply</tt>.
Recommend NAD: Doesn't meet the bar for standardization: hasn't been requested again in 7 years, easy to implement yourself.</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a future standard.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the following type traits to p3 21.4 <a href="https://timsong-cpp.github.io/cppwp/ratio">[ratio]</a>
</p>

<blockquote><pre>
// ratio arithmetic
template &lt;class R1, class R2&gt; struct ratio_add;
template &lt;class R1, class R2&gt; struct ratio_subtract;
template &lt;class R1, class R2&gt; struct ratio_multiply;
template &lt;class R1, class R2&gt; struct ratio_divide;
<ins>template &lt;class R1, class ... RList&gt; struct ratio_sum;</ins>
<ins>template &lt;class R1, class ... RList&gt; struct ratio_product;</ins>
</pre></blockquote>

<p>
after 21.4.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p1: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_sum; // declared, never defined

template &lt;class R1&gt; struct ratio_sum&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_sum&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>

<p>
after 21.4.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p3: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_product; // declared, never defined

template &lt;class R1&gt; struct ratio_product&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_product&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>








<hr>
<h3><a name="1124" href="1124">1124.</a>  Invalid definition of concept RvalueOf</h3>
<p><b>Section:</b> 99 [concept.transform] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.transform">issues</a> in [concept.transform].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group
<a href="http://groups.google.de/group/comp.std.c++/browse_frm/thread/8eb92768a19fb46f">article</a>
points to several defects in the
specification of reference-related concepts.
</p>
<p>
One problem of the concept <tt>RvalueOf</tt> as currently defined in
99 [concept.transform]:
</p>

<blockquote><pre>
concept RvalueOf&lt;typename T&gt; {
 typename type = T&amp;&amp;;
 requires ExplicitlyConvertible&lt;T&amp;,type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;,type&gt;;
}

template&lt;typename T&gt; concept_map RvalueOf&lt;T&amp;&gt; {
 typedef T&amp;&amp; type;
}
</pre></blockquote>

<p>
is that if <tt>T</tt> is an lvalue-reference, the requirement
<tt>Convertible&lt;T&amp;&amp;,type&gt;</tt> isn't satisfied for
lvalue-references, because after reference-collapsing in the concept
definition we have <tt>Convertible&lt;T&amp;,type&gt;</tt> in this case,
which isn't satisfied in the concept map template and also is not the
right constraint either. I think that the reporter is right that
<tt>SameType</tt> requirements should do the job and that we also should
use the new <tt>RvalueReference</tt> concept to specify a best matching
type requirement.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 99 [concept.transform] before p. 4 change as indicated:
</p>

<blockquote><pre>
auto concept RvalueOf&lt;typename T&gt; {
  <del>typename</del><ins>RvalueReference</ins> type = T&amp;&amp;;
  requires <del>ExplicitlyConvertible&lt;T&amp;, type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;, type&gt;</del><ins>SameType&lt;T&amp;, type&amp;&gt;</ins>;
}
</pre></blockquote>





<hr>
<h3><a name="1125" href="1125">1125.</a> ostream_iterator does not work with movable types</h3>
<p><b>Section:</b> 25.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.iterator.ops">[ostream.iterator.ops]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>ostream_iterator</tt> has not been updated to support moveable types, in a
similar manner to the insert iterators.
Note that this is not a problem for <tt>ostreambuf_iterator</tt>, as the types it is
restricted to dealing with do not support extra-efficient moving.
</p>

<p><i>[
2009-11-10 Howard adds:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.  Rationale
added below.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add second <tt>operator=</tt> overload to class <tt>template ostream_iterator</tt>
in 25.6.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.iterator">[ostream.iterator]</a>, para 2:
</p>

<blockquote><pre>
ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(const T&amp; value);
<ins>ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(T&amp;&amp; value);</ins>
</pre></blockquote>

<p>
Add a new paragraph: in 25.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.iterator.ops">[ostream.iterator.ops]</a>:
</p>

<blockquote>
<pre>
ostream_iterator&amp; operator=(T&amp;&amp; value);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i>
</p>
<blockquote><pre>
*out_stream &lt;&lt; std::move(value);
if(delim != 0)
  *out_stream &lt;&lt; delim;
return (*this);
</pre></blockquote>
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Several objections to move forward with this issue were voiced in the thread
starting with c++std-lib-25438.  Among them is that we know of no motivating
use case to make streaming rvalues behave differently than streaming const
lvalues.
</p>





<hr>
<h3><a name="1127" href="1127">1127.</a> rvalue references and iterator traits</h3>
<p><b>Section:</b> 25.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.traits">active issues</a> in [iterator.traits].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.traits">issues</a> in [iterator.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The deprecated support for <tt>iterator_traits</tt> and legacy (unconstrained)
iterators features the (exposition only) concept:
</p>

<blockquote><pre>
concept IsReference&lt;typename T&gt; { } // exposition only
template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&gt; { }
</pre></blockquote>
<p>
Now this looks exactly like the <tt>LvalueReference</tt> concept recently added to
clause 20, so I wonder if we should use that instead?
Then I consider the lack of rvalue-reference support, which means that
<tt>move_iterator</tt> would always flag as merely supporting the <tt>input_iterator_tag</tt>
category.  This suggests we retain the exposition concept, but add a second
concept_map to support rvalue references.
</p>
<p>
I would suggest adding the extra concept_map is the right way forward, but
still wonder if the two exposition-only concepts in this clause might be
worth promoting to clause 20.  That question might better be answered with a
fuller investigation of type_trait/concept unification though.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Iterator traits 25.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> para 4 add:
</p>

<blockquote><pre>
concept IsReference&lt;typename T&gt; { } // exposition only
template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&gt; { }
<ins>template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&amp;&gt; { }</ins>
</pre></blockquote>






<hr>
<h3><a name="1128" href="1128">1128.</a> Missing definition of <tt>iterator_traits&lt;T*&gt;</tt></h3>
<p><b>Section:</b> 25.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.synopsis">active issues</a> in [iterator.synopsis].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in [iterator.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;iterator&gt;</tt> header synopsis declares a partial specialization of
<tt>iterator_traits</tt> to support pointers,  [iterator.syn].  The implication
is that specialization will be described in D10, yet it did not follow the
rest of the deprecated material into this clause.
</p>
<p>
However, this is not as bad as it first seems!
There are partial specializations of <tt>iterator_traits</tt> for types that satisfy
the various Iterator concepts, and there are concept_maps for pointers to
explicitly support the <tt>RandomAccessIterator</tt> concept, so the required
template will be present - just not in the manner advertised.
</p>
<p>
I can see two obvious solutions:
</p>

<ol style="list-style-type:lower-roman">
<li>
Restore the <tt>iterator_traits&lt;T*&gt;</tt> partial specialization in D.10
</li>
<li>
Remove the declaration of <tt>iterator_traits&lt;T*&gt;</tt> from 24.3 synopsis
</li>
</ol>
<p>
I recommend option (ii) in the wording below
</p>
<p>
Option (ii) could be extended to strike all the declarations of deprecated
material from the synopsis, as it is effectively duplicating D.10 anyway.
This is the approach taken for deprecated library components in the 98/03
standards.  This is probably a matter best left to the Editor though.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In  [iterator.syn] strike:
</p>

<blockquote><pre>
<del>template&lt;class T&gt; struct iterator_traits&lt;T*&gt;;</del>
</pre></blockquote>






<hr>
<h3><a name="1132" href="1132">1132.</a> JP-30: nested exceptions</h3>
<p><b>Section:</b> 17.10.8 <a href="https://timsong-cpp.github.io/cppwp/except.nested">[except.nested]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Seiji Hayashida <b>Opened:</b> 2009-06-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 30</b></p>

<p>
C++0x <tt>nested_exception</tt> cannot handle a structured exception well. The
following codes show two types of tree structured exception handling.
</p>
<p>
The first one is based on <tt>nested_exception</tt> in C++0x,
while the second one is based on my library <tt>trickerr.h</tt> (in Japanese).
<a href="http://tricklib.com/cxx/dagger/trickerr.h">http://tricklib.com/cxx/dagger/trickerr.h</a>
</p>
<p>
Assume that Function <tt>A()</tt> calls two sub functions <tt>A_a()</tt> and <tt>A_b()</tt>, both might
throw tree structured exceptions, and <tt>A_b()</tt> must be called even if <tt>A_a()</tt>
throws an exception.
</p>
<p>
List A (code of tree structured exception handling based on nested_exception
in C++0x)
</p>

<blockquote><pre>
void A()
{
    try
    {
        std::vector&lt;exception_ptr&gt; exception_list;
        try
        {
            // A_a() does a similar processing as A().
            A_a();
        }
        catch(...)
        {
            exception_list.push_back(current_exception());
        }

        // ***The processing A() has to do even when A_a() fails. ***
        try
        {
            // A_b() does a similar processing as A().
            A_b();
        }
        catch(...)
        {
            exception_list.push_back(current_exception());
        }
        if (!exception_list.empty())
        {
            throw exception_list;
        }
    }
    catch(...)
    {
        throw_with_nested(A_exception("someone error"));
    }
}
void print_tree_exception(exception_ptr e, const std::string &amp; indent ="")
{
    const char * indent_unit = " ";
    const char * mark = "- ";
    try
    {
        rethow_exception(e);
    }
    catch(const std::vector&lt;exception_ptr&gt; e)
    {
        for(std::vector&lt;exception_ptr&gt;::const_iterator i = e.begin(); i!=e.end(); ++i)
        {
            print_tree_exception(i, indent);
        }
    }
    catch(const std::nested_exception  e)
    {
        print_tree_exception(evil_i(e), indent +indent_unit);
    }
    catch(const std::exception e)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(...)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; "unknown exception" &lt;&lt; std::endl;
    }
}
int main(int, char * [])
{
    try
    {
        A();
    }
    catch()
    {
        print_tree_exception(current_exception());
    }
    return EXIT_SUCCESS;
}
</pre></blockquote>

<p>
List B ( code of tree structured exception handling based on <tt>trickerr.h</tt>. )
"trickerr.h" (in Japanese), refer to:
<a href="http://tricklib.com/cxx/dagger/trickerr.h">http://tricklib.com/cxx/dagger/trickerr.h</a>.
</p>

<blockquote><pre>
void A()
{
    tricklib::error_listener_type error_listener;
    // A_a() is like A(). A_a() can throw tree structured exception.
    A_a();

    // *** It must do process so that A_a() throws exception in A(). ***
    // A_b() is like A(). A_b() can throw tree structured exception.
    A_b();

    if (error_listener.has_error()) // You can write this "if block" in destructor
                                    //  of class derived from error_listener_type.
    {
        throw_error(new A_error("someone error",error_listener.listener_off().extract_pending_error()));
    }
}
void print_tree_error(const tricklib::error_type &amp;a_error, const std::string &amp; indent = "")
{
    const char * indent_unit = " ";
    const char * mark = "- ";

    tricklib::error_type error = a_error;
    while(error)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; error-&gt;message &lt;&lt; std::endl;
        if (error-&gt;children)
        {
            print_tree_error(error-&gt;children, indent +indent_unit);
        }
        error = error-&gt;next;
    }
}
int main(int, char * [])
{
    tricklib::error_thread_power error_thread_power_on; // This object is necessary per thread.

    try
    {
        A();
    }
    catch(error_type error)
    {
        print_tree_error(error);
    }
    catch(...)
    {
        std::cout &lt;&lt; "- unknown exception" &lt;&lt; std::endl;
    }
    return EXIT_SUCCESS;
}
</pre></blockquote>

<p>
Prospect
</p>
<p>
We will focus on the method A() since the other methods, also main(), occur
only once respectively.
</p>

<ul>
<li>
 In the List A above (of the nested exception handling), it is hard to
 find out an active reason to use the nested exception handling at this
 scene. Rather, we can take a simpler description by throwing the entire
 exception_list directly to the top level.
</li>
<li>
 The code in the same example gives us a kind of redundant impression,
 which might have come from the fact that the try-throw-catch framework does
 not assume a tree structured exception handling.
</li>
</ul>

<p>
According to the above observation, we cannot help concluding that it is not
so easy to use the nested_exception handling as a tree structured exception
handling mechanism in a practical sense.
</p>
<p>
This text is based on the web page below (in Japanese).
<a href="http://d.hatena.ne.jp/wraith13/20081231/1230715424">http://d.hatena.ne.jp/wraith13/20081231/1230715424</a>
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD. The committee agrees that <tt>nested_exception</tt> is not a good
match for this usage model. The committee did not see a way of improving
this within the timeframe allowed.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1139" href="1139">1139.</a> Thread support library not concept enabled</h3>
<p><b>Section:</b> 33 <a href="https://timsong-cpp.github.io/cppwp/thread">[thread]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 93, JP 79, UK 333, JP 81</b></p>

<p>
The thread chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1140" href="1140">1140.</a> Numerics library not concept enabled</h3>
<p><b>Section:</b> 28 <a href="https://timsong-cpp.github.io/cppwp/numerics">[numerics]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numerics">issues</a> in [numerics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 84</b></p>

<p>
The numerics chapter is not concept enabled.
</p>

<p>
The portion of this comment dealing with random numbers was resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a>,
which was accepted in Summit.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1141" href="1141">1141.</a> Input/Output library not concept enabled</h3>
<p><b>Section:</b> 31 <a href="https://timsong-cpp.github.io/cppwp/input.output">[input.output]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 85, JP 67, JP 68, JP 69, JP 72, UK 308</b></p>

<p>
The input/output chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1142" href="1142">1142.</a> Regular expressions library not concept enabled</h3>
<p><b>Section:</b> 32 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re">active issues</a> in [re].</p>
<p><b>View all other</b> <a href="lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 86, UK 309, UK 310</b></p>

<p>
The regular expressions chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1148" href="1148">1148.</a> Wrong argument type of I/O stream manipulators <tt>setprecision()</tt>
and <tt>setw()</tt></h3>
<p><b>Section:</b> 31.7 <a href="https://timsong-cpp.github.io/cppwp/iostream.format">[iostream.format]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Marc Steinbach <b>Opened:</b> 2009-06-20 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The header <tt>&lt;iomanip&gt;</tt> synopsis in 31.7 <a href="https://timsong-cpp.github.io/cppwp/iostream.format">[iostream.format]</a> specifies
</p>
<blockquote><pre>
T5 setprecision(int n);
T6 setw(int n);
</pre></blockquote>

<p>
The argument types should be streamsize, as in class <tt>ios_base</tt>
(see 31.5.2 <a href="https://timsong-cpp.github.io/cppwp/ios.base">[ios.base]</a>):
</p>
<blockquote><pre>
streamsize precision() const;
streamsize precision(streamsize prec);
streamsize width() const;
streamsize width(streamsize wide);
</pre></blockquote>

<p>
(Editorial: 'wide' should probably be renamed as 'width', or maybe just 'w'.)
</p>

<p><i>[
2009-07-29 Daniel clarified wording.
]</i></p>


<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
No concensus for this change.  There was some interest in doing the opposite
fix:  Change the <tt>streamsize</tt> in <tt>&lt;ios&gt;</tt> to <tt>int</tt>.
But ultimately there was no concensus for that change either.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 31.7 <a href="https://timsong-cpp.github.io/cppwp/iostream.format">[iostream.format]</a>, header <tt>&lt;iomanip&gt;</tt> synopsis change as indicated:
</p>

<blockquote><pre>
T5 setprecision(<del>int</del><ins>streamsize</ins> n);
T6 setw(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>

<li>
<p>
In 31.7.7 <a href="https://timsong-cpp.github.io/cppwp/std.manip">[std.manip]</a>, just before p. 6 change as indicated:
</p>

<blockquote><pre>
unspecified setprecision(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>

<li>
<p>
In 31.7.7 <a href="https://timsong-cpp.github.io/cppwp/std.manip">[std.manip]</a>, just before p. 7 change as indicated:
</p>

<blockquote><pre>
unspecified setw(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>
</ol>








<hr>
<h3><a name="1149" href="1149">1149.</a> Reformulating NonemptyRange axiom</h3>
<p><b>Section:</b> 99 [rand.concept.urng] <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2009-06-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 99 [rand.concept.urng], we have the following:
</p>
<blockquote><pre>
concept UniformRandomNumberGenerator&lt;typename G&gt; : Callable&lt;G&gt; {
  ...
  axiom NonemptyRange(G&amp; g) {
    G::min() &lt; G::max();
  }
  ...
}
</pre></blockquote>

<p>
Since the parameter <tt>G</tt> is in scope throughout the concept, there is no
need for the axiom to be further parameterized, and so the axiom can be
slightly simplified as:
</p>

<blockquote><pre>
axiom NonemptyRange()  {
  G::min() &lt; G::max();
}
</pre></blockquote>

<p>
We can further reformulate so as to avoid any axiom machinery as:
</p>

<blockquote><pre>
requires True&lt; G::min() &lt; G::max() &gt;;
</pre></blockquote>

<p>
This is not only a simpler statement of the same requirement, but also
forces the requirement to be checked.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote><p>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 99 [rand.concept.urng], replace the <tt>NonemptyRange</tt> axiom by:
</p>

<blockquote><pre>
<del>axiom NonemptyRange(G&amp; g) { 
   G::min() &lt; G::max(); 
}</del>
<ins>requires True&lt; G::min() &lt; G::max() &gt;;</ins>
</pre></blockquote>






<hr>
<h3><a name="1153" href="1153">1153.</a> Standard library needs review for constructors to be
explicit to avoid treatment as initializer-list constructor</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a>, 33 <a href="https://timsong-cpp.github.io/cppwp/thread">[thread]</a>, D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 2</b></p>

<p><b>Description</b></p>
        <p>Marking a constructor with <tt>explicit</tt> has semantics
        even for a constructor with zero or several parameters:
        Such a constructor cannot be used with list-initialization
        in a copy-initialization context, see 12.2.2.8 <a href="https://timsong-cpp.github.io/cppwp/over.match.list">[over.match.list]</a>. The
        standard library apparently has not been reviewed for
        marking non-single-parameter constructors as <tt>explicit</tt>.</p>
<p><b>Suggestion</b></p>
        <p>Consider marking zero-parameter and multi-parameter
        constructors <tt>explicit</tt> in classes that have at least one
        constructor marked <tt>explicit</tt> and that do not have an
        initializer-list constructor.</p>

<p><b>Notes</b></p>
        <p>Robert Klarer to address this one.</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Move to "Open". Robert Klarer has promised to provide wording.
</p></blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
We are unaware of any cases where initializer lists cause problem in this
context, but if problems arise in the future the issue can be reopened.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1154" href="1154">1154.</a> <tt>complex</tt> should accept integral types</h3>
<p><b>Section:</b> 28.4 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 35</b></p>

<p><b>Description</b></p>
        <p>Instantiations of the class
        template <tt>complex&lt;&gt;</tt> have to be allowed for integral
        types, to reflect existing practice and ISO standards
        (LIA-III).</p>
        
<p><b>Suggestion</b></p>

<p><i>[
2009-10-26 Proposed wording in <a href="https://wg21.link/n3002.pdf">N3002</a>.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Future. Rationale added.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend SG6</p>

<p><i>[2017-03-03, Kona]</i></p>

<p>
SG6 suggests this issue is a new feature, not a problem with the existing
standard, and should therefore be closed NAD. However, SG6 invites papers that bring
the proposal up to date with the current standard.
</p>


<p><b>Rationale:</b></p>
<p>
There is no consensus for making this change at this time.
</p>


<p><b>Proposed resolution:</b></p><p>
Adopt <a href="https://wg21.link/n3002.pdf">N3002</a>.
</p>




<hr>
<h3><a name="1155" href="1155">1155.</a> Reference should be to C99</h3>
<p><b>Section:</b> C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 38</b></p>

<p><b>Description</b></p>
        <p>What is ISO/IEC 1990:9899/DAM
        1? My guess is that's a typo for ISO/IEC
        9899/Amd.1:1995 which I'd
        have expected to be referenced here (the tables
        make reference to things
        which were introduced by Amd.1).</p>
<p><b>Suggestion</b></p>
        <p>One need probably a reference
        to the document which introduce <tt>char16_t</tt> and
        <tt>char32_t</tt> in C (ISO/IEC TR 19769:2004?).</p>
<p><b>Notes</b></p>
<p>Create issue. Document in question should be C99, not C90+amendment1. The 
    rest of the section requires careful review for completeness. Example &lt;cstdint&gt; 
    17.4.2 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>. Assign to C liasons.</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Editorial. Already fixed.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1156" href="1156">1156.</a> Constraints on bitmask and enumeration types to be tightened</h3>
<p><b>Section:</b> 16.3.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/enumerated.types">[enumerated.types]</a>, 16.3.3.3.4 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 165</b></p>

<p><b>Description</b></p>
        <p>Constraints on
        bitmask and enumeration types were supposed to be tightened
        up as part of the motivation for the <tt>constexpr</tt> feature -
        see paper
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a>
        for details</p>
<p><b>Suggestion</b></p>
        <p>Adopt wording in line with the motivation
        described in
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a></p>
<p><b>Notes</b></p>
        <p>Robert Klarer to review</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Move to Open. Ping Robert Klarer to provide wording, using N2235 as guidance.
</p></blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD.  Rationale added.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
UK NB did not sufficiently describe how to resolve their comment, and
therefore we cannot make a change for the FCD. If a resolution were
provided in the future, we would be happy to apply it.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1164" href="1164">1164.</a> <tt>promise::swap</tt> should pass by rvalue reference</h3>
<p><b>Section:</b> 33.10.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 341</b></p>

<p><b>Description</b></p>
<p><tt>promise::swap</tt> accepts its parameter by lvalue reference. This is
inconsistent with other types that provide a swap member function,
where those swap functions accept an rvalue reference</p>

<p><b>Suggestion</b></p>
<p>Change <tt>promise::swap</tt> to take an rvalue reference.</p>

<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it. Probably ready as it.</p>  

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote><p>
NAD, by virtue of the changed rvalue rules and swap signatures from Summit.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1167" href="1167">1167.</a> <tt>pair&lt;T,U&gt;</tt> doesn't model <tt>LessThanComparable</tt> in unconstrained code even if
      <tt>T</tt> and <tt>U</tt> do.</h3>
<p><b>Section:</b> 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2009-07-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>LessThanComparable</tt> requires (and provides default
             implementations for) &lt;=,&gt;, and &gt;=.  However, the defaults
             don't take effect in unconstrained code.
</p>
<p>
Still, it's a problem to have types acting one way in
constrained code and another in unconstrained code, except in cases of
syntax adaptation.  It's also inconsistent with the containers, which
supply all those operators.
</p>
<p>
Totally Unbiased
Suggested Resolution:
</p>
<p>
accept the exported concept maps proposal and
                    change the way this stuff is handled to use an
                    explicit exported concept map rather than nested
                    function templates
</p>
<p>
e.g., remove from the body of <tt>std::list</tt>
</p>
<blockquote><pre>
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&lt; (const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&gt; (const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&gt;=(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&lt;=(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
</pre></blockquote>
<p>
and add this concept_map afterwards:
</p>
<blockquote><pre>
template &lt;LessThanComparable T, class Allocator&gt; 
export concept_map LessThanComparable&lt;list&lt;T,Allocator&gt; &gt;
{
    bool operator&lt;(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y);
}
</pre></blockquote>
<p>
do similarly for <tt>std::pair</tt>.  While you're at it, do the same for
<tt>operator==</tt> and <tt>!=</tt> everywhere, and seek out other such opportunities.
</p>
<p>
Alternative Resolution: keep the ugly, complex specification and add the
                       missing operators to <tt>std::pair</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1168" href="1168">1168.</a> Odd wording for bitset equality operators</h3>
<p><b>Section:</b> 22.9.2.3 <a href="https://timsong-cpp.github.io/cppwp/bitset.members">[bitset.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitset.members">issues</a> in [bitset.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following wording seems a little unusual to me:
</p>
<p>
p42/43 22.9.2.3 <a href="https://timsong-cpp.github.io/cppwp/bitset.members">[bitset.members]</a>
</p>

<blockquote>
<pre>
bool operator==(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote><p>
-42- <i>Returns:</i> A nonzero value if the value of each bit in
<tt>*this</tt> equals the value of the corresponding bit in
<tt>rhs</tt>.
</p></blockquote>
<pre>
bool operator!=(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote><p>
-43- <i>Returns:</i> A nonzero value if <tt>!(*this == rhs)</tt>.
</p></blockquote>
</blockquote>

<p>
"A nonzero value" may be well defined as equivalent to the literal '<tt>true</tt>'
for Booleans, but the wording is clumsy.  I suggest replacing "A nonzero value"
with the literal '<tt>true</tt>' (in appropriate font) in each case.
</p>

<p><i>[
2009-07-24 Alisdair recommends NAD Editorial.
]</i></p>


<p><i>[
2009-07-27 Pete adds:
]</i></p>


<blockquote><p>
It's obviously editorial. There's no need for further discussion.
</p></blockquote>

<p><i>[
2009-07-27 Howard sets to NAD Editorial.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 22.9.2.3 <a href="https://timsong-cpp.github.io/cppwp/bitset.members">[bitset.members]</a> p42-43:
</p>

<blockquote>
<pre>
bool operator==(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote><p>
-42- <i>Returns:</i> <del>A nonzero value</del> <ins><tt>true</tt></ins> if the value of each bit in
<tt>*this</tt> equals the value of the corresponding bit in
<tt>rhs</tt>.
</p></blockquote>
<pre>
bool operator!=(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote><p>
-43- <i>Returns:</i> <del>A nonzero value</del> <ins><tt>true</tt></ins> if <tt>!(*this == rhs)</tt>.
</p></blockquote>
</blockquote>






<hr>
<h3><a name="1173" href="1173">1173.</a> "Equivalence" wishy-washiness</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-07-14 <b>Last modified:</b> 2016-11-21 05:09:01 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue: The <tt>CopyConstructible</tt> requirements are wishy-washy.  It requires
that the copy is "equivalent" to the original, but "equivalent" is never
defined.
</p>
<p>
I believe this to be an example of a more general lack of rigor around
copy and assignment, although I haven't done the research to dig up all
the instances.
</p>
<p>
It's a problem because if you don't know what <tt>CopyConstructible</tt> means,
you also don't know what it means to copy a pair of <tt>CopyConstructible</tt>
types.  It doesn't prevent us from writing code, but it is a hole in our
ability to understand the meaning of copy.
</p>
<p>
Furthermore, I'm pretty sure that vector's copy constructor doesn't
require the elements to be <tt>EqualityComparable</tt>, so that table is actually
referring to some ill-defined notion of equivalence when it uses ==.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Move to "Open". Dave is right that this is a big issue. Paper D2987
("Defining Move Special Member Functions", Bjarne Stroustrup and
Lawrence Crowl) touches on this but does not solve it. This issue is
discussed in Elements of Programming.
</p></blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This issue is quite vague, so it is difficult to know if and when it has been resolved.
John Lakos wrote a paper covering this area a while back, and there is a real interest 
in providing some sort of clean-up in the future. We need a more clearly draughted 
issues with an addressable set of concerns, ideally with a paper proposing a resolution, 
but for a future revision of the standard. Move to Tentatively NAD Future.
</p></blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>


<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: Status: NAD</p>
<p>It was said in 2010: "We need a more clearly draughted issue with an addressable 
set of concerns, ideally with a paper proposing a resolution, 
but for a future revision of the standard."</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1176" href="1176">1176.</a> Make <tt>thread</tt> constructor non-variadic</h3>
<p><b>Section:</b> 33.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.constr">[thread.thread.constr]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-07-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The variadic <tt>thread</tt> constructor is causing controversy, e.g.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2901.pdf">N2901</a>.
This issue has been created as a placeholder for this course of action.
</p>

<blockquote><pre>
template &lt;class F<del>, class ...Args</del>&gt; thread(F&amp;&amp; f<del>, Args&amp;&amp;... args</del>);
</pre></blockquote>

<p>
See <a href="929">929</a> for wording which specifies an rvalue-ref signature but
with "decay behavior", but using variadics.
</p>

<p><i>[
2009-11-17 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
The (tentative) concensus of the LWG is to keep the variadic thread constructor.
</p>





<hr>
<h3><a name="1179" href="1179">1179.</a> Probably editorial in [structure.specifications]</h3>
<p><b>Section:</b> 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2009-07-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While reviewing <a href="971">971</a> I noted that 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>/7 says:
</p>

<blockquote><p>
-7- Error conditions specify conditions where a function may fail. The
conditions are listed, together with a suitable explanation, as the <tt>enum
class errc</tt> constants (19.5) that could be used as an argument to
function <tt>make_error_condition</tt> (19.5.3.6).
</p></blockquote>

<p>
This paragraph should mention <tt>make_error_code</tt> or the text "that
could be used as an argument to function <tt>make_error_condition</tt>
(19.5.3.6)" should be deleted.  I believe this is editorial.
</p>

<p><i>[
2009-07-21 Chris adds:
]</i></p>


<blockquote>
<p>
I'm not convinced there's a problem there, because as far as the "Error
conditions" clauses are concerned, make_error_condition() is used by a
user to test for the condition, whereas make_error_code is not. For
example:
</p>

<blockquote><pre>
void foobar(error_code&amp; ec = throws());
</pre></blockquote>

<p>
 Error conditions:
</p>
<blockquote><p>
permission_denied - Insufficient privilege to perform operation.
</p></blockquote>

<p>
When a user writes:
</p>

<blockquote><pre>
error_code ec;
foobar(ec);
if (ec == errc::permission_denied)
   ...
</pre></blockquote>

<p>
the implicit conversion <tt>errc-&gt;error_condition</tt> makes the if-test
equivalent to:
</p>

<blockquote><pre>
if (ec == make_error_condition(errc::permission_denied))
</pre></blockquote>

<p>
On the other hand, if the user had written:
</p>

<blockquote><pre>
if (ec == make_error_code(errc::permission_denied))
</pre></blockquote>

<p>
the test is now checking for a specific error code. The test may
evaluate to <tt>false</tt> even though <tt>foobar()</tt> failed due to the documented
error condition "Insufficient privilege".
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
NAD Editorial.
</p>
<p>
What the WP says right now is literally true: these codes can be used as
an argument to <tt>make_error_condition</tt>. (It is also true that they can be
used as an argument to <tt>make_error_code</tt>, which the WP doesn't say.) Maybe
it would be clearer to just delete "that could be used as an argument to
function <tt>make_error_condition</tt>", since that fact is already implied by
other things that we say. We believe that this is editorial.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1184" href="1184">1184.</a> Feature request: dynamic bitset</h3>
<p><b>Section:</b> 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-29 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Opened at Alisdair's request, steming from <a href="96">96</a>.
Alisdair recommends NAD Future.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  We want a heap allocated bitset, but we don't have one today and
don't have time to add one.
</p></blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>Solution in process: Presented at Olu (Vincent Reverdy) <a href="https://wg21.link/P0237r5">P0237r5</a> 
Value reference pointer and iterator. The reference should be put into the issue.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>This is a feature request, not a defect.</p>
<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1186" href="1186">1186.</a> Forward list could model a stack</h3>
<p><b>Section:</b> 24.6.8 <a href="https://timsong-cpp.github.io/cppwp/stack">[stack]</a> <b>Status:</b> <a href="lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-31 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#stack">issues</a> in [stack].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library template <tt>forward_list</tt> could easily model the idea of a
<tt>stack</tt>, where the operations work on the front of the list rather than
the back.  However, the standard library <tt>stack</tt> adaptor cannot support
this.
</p>

<p>
It would be relatively easy to write a partial specialization for <tt>stack</tt>
to support <tt>forward_list</tt>, but that opens the question of which header to
place it in.  A much better solution would be to add a <tt>concept_map</tt> for
the <tt>StackLikeContainer</tt> concept to the <tt>&lt;forward_list&gt;</tt> header and then
everything just works, including a user's own further uses in a
stack-like context.
</p>

<p>
Therefore while I am submitting the issue now so that it is on record, I
<em>strongly recommend</em> we resolve as "NAD Concepts" as any non-concepts
based solution will be inferior to the final goal, and the feature is
not so compelling it must be supported ahead of the concepts-based
library.
</p>

<p><i>[
2009-11-02 Howard adds:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Concepts after 5 positive votes on c++std-lib.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
Any non-concepts based solution will be inferior to the final goal, and the
feature is not so compelling it must be supported ahead of the concepts-based
library.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1188" href="1188">1188.</a> Unordered containers should have a minimum load factor as well as a maximum</h3>
<p><b>Section:</b> 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 24.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unordered associative containers have a notion of a maximum load factor:
when the number of elements grows large enough, the containers
automatically perform a rehash so that the number of elements per bucket
stays below a user-specified bound. This ensures that the hash table's
performance characteristics don't change dramatically as the size
increases.
</p>

<p>
For similar reasons, Google has found it useful to specify a minimum
load factor: when the number of elements shrinks by a large enough, the
containers automatically perform a rehash so that the number of elements
per bucket stays above a user-specified bound. This is useful for two
reasons. First, it prevents wasting a lot of memory when an unordered
associative container grows temporarily. Second, it prevents amortized
iteration time from being arbitrarily large; consider the case of a hash
table with a billion buckets and only one element. (This was discussed
even before TR1 was published; it was TR issue 6.13, which the LWG
closed as NAD on the grounds that it was a known design feature.
However, the LWG did not consider the approach of a minimum load
factor.)
</p>

<p>
The only interesting question is when shrinking is allowed. In principle
the cleanest solution would be shrinking on erase, just as we grow on
insert. However, that would be a usability problem; it would break a
number of common idioms involving erase. Instead, Google's hash tables
only shrink on insert and rehash.
</p>

<p>
The proposed resolution allows, but does not require, shrinking in
rehash, mostly because a postcondition for rehash that involves the
minimum load factor would be fairly complicated. (It would probably have
to involve a number of special cases and it would probably have to
mention yet another parameter, a minimum bucket count.)
</p>

<p>
The current behavior is equivalent to a minimum load factor of 0. If we
specify that 0 is the default, this change will have no impact on
backward compatibility.
</p>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This seems to a useful extension, but is too late for 0x.

Move to Tentatively NAD Future.
</p></blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Should there be a shrink_to_fit()? Is it too surprising to shrink on insert()? (We understand that shrinking on erase() is not an option.) Maybe make people call rehash(0) to shrink to the min_load_factor? On clear(), the load factor goes to 0 or undefined (0/0), which is likely to violate min_load_factor() min_load_factor(z)'s wording should match max_load_factor(z)'s, e.g. "May change the container’s maximum load factor" Want a paper exploring whether shrink-on-insert has been surprising. From Titus: Google's experience is that maps don't shrink in the way this would help with. NAD, not worth the time. Write a paper if you can demonstrate a need for this.</p>


<p><b>Proposed resolution:</b></p>
<p>
Add two new rows, and change rehash's postcondition in the unordered
associative container requirements table in 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &mdash; Unordered associative container requirements
(in addition to container)</caption>

<tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><ins>
<tt>a.min_load_factor()</tt>
</ins></td>
<td><ins>
<tt>float</tt>
</ins></td>
<td><ins>
Returns a non-negative number that the container attempts to keep the
load factor greater than or equal to. The container automatically
decreases the number of buckets as necessary to keep the load factor
above this number.
</ins></td>
<td><ins>
constant
</ins></td>
</tr>

<tr>
<td><ins><tt>a.min_load_factor(z)</tt></ins></td>
<td><ins><tt>void</tt></ins></td>
<td><ins>Pre: <tt>z</tt> shall be non-negative. Changes the container's minimum
load factor, using <tt>z</tt> as a hint. [<i>Footnote:</i> the minimum
load factor should be significantly smaller than the maximum. 
If <tt>z</tt> is too large, the implementation may reduce it to a more sensible value.]
</ins></td>
<td><ins>
constant
</ins></td>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <ins><tt>a.bucket_count() &gt;= n</tt>, and <tt>a.size() &lt;= a.bucket_count()
* a.max_load_factor()</tt>. [<i>Footnote:</i> It is intentional that the
postcondition does not mention the minimum load factor.
This member function is primarily intended for cases where the user knows
that the container's size will increase soon, in which case the container's
load factor will temporarily fall below <tt>a.min_load_factor()</tt>.]</ins>
<del>
<tt>a.bucket_cout &gt; a.size() / a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</del>
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</table>
</blockquote>

<p>
Add a footnote to 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p12:
</p>

<blockquote>
<p>
The insert members shall not affect the validity of references to
container elements, but may invalidate all iterators to the container.
The erase members shall invalidate only iterators and references to the
erased elements.
</p>

<blockquote><p>
[A consequence of these requirements is that while insert may change the
number of buckets, erase may not. The number of buckets may be reduced
on calls to insert or rehash.]
</p></blockquote>
</blockquote>

<p>
Change paragraph 13:
</p>

<blockquote><p>
The insert members shall not affect the validity of iterators if
<del><tt>(N+n) &lt; z * B</tt></del> <ins><tt>zmin * B &lt;= (N+n) &lt;= zmax * B</tt></ins>,
where <tt>N</tt> is the number of elements in
the container prior to the insert operation, <tt>n</tt> is the number of
elements inserted, <tt>B</tt> is the container's bucket count,
<ins><tt>zmin</tt> is the container's minimum load factor,</ins>
and <tt>z<ins>max</ins></tt> is the container's maximum load factor.
</p></blockquote>

<p>
Add to the <tt>unordered_map</tt> class synopsis in section 24.5.4 <a href="https://timsong-cpp.github.io/cppwp/unord.map">[unord.map]</a>,
the <tt>unordered_multimap</tt> class synopsis
in 24.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap">[unord.multimap]</a>, the <tt>unordered_set</tt> class synopsis in
24.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a>, and the <tt>unordered_multiset</tt> class synopsis
in 24.5.7 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset">[unord.multiset]</a>:
</p>

<blockquote><pre><ins>
float min_load_factor() const;
void min_load_factor(float z);
</ins></pre></blockquote>

<p>
In 24.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a>, 24.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a>, 24.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a>, and
24.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a>, change:
</p>

<blockquote><p>
... <tt>max_load_factor()</tt> returns 1.0 <ins>and
<tt>min_load_factor()</tt> returns 0</ins>.
</p></blockquote>





<hr>
<h3><a name="1190" href="1190">1190.</a> Setting the maximum load factor should return the previous value</h3>
<p><b>Section:</b> 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 24.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The unordered associative container requirements table specifies that
<tt>a.set_max_load_factor(z)</tt> has return type <tt>void</tt>. However, there is a
useful piece of information to return: the previous value. Users who
don't need it can always ignore it.
</p>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
The benefit seems minor, while breaking with the getter/setter idiom these overloads support.

Move to Tentatively NAD.
</p></blockquote>

<p><i>[
Moved to NAD at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In the unordered associative container requirements table, change:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &mdash; Unordered associative container requirements
(in addition to container)</caption>

<tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>a.max_load_factor(z)</tt></td>
<td><tt><del>void</del> <ins>float</ins></tt></td>
<td>Pre: <tt>z</tt> shall be positive. Changes the container's maximum
<del>load</del> load factor, using <tt>z</tt> as a hint.
<ins>Returns: the previous value of
<tt>a.max_load_factor()</tt>.</ins>
</td>
<td>
constant
</td>
</tr>
</table>
</blockquote>

<p>
Change the return type of <tt>set_max_load_factor</tt>
in the class synopses in 24.5.4 <a href="https://timsong-cpp.github.io/cppwp/unord.map">[unord.map]</a>, 24.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap">[unord.multimap]</a>,  24.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a>,
and 24.5.7 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset">[unord.multiset]</a>.
</p>

<p>
If issue <a href="1188">1188</a> is also accepted, make the same changes for
<tt>min_load_factor</tt>.
</p>





<hr>
<h3><a name="1200" href="1200">1200.</a> "surprising" <tt>char_traits&lt;T&gt;::int_type</tt> requirements</h3>
<p><b>Section:</b> 23.2.3 <a href="https://timsong-cpp.github.io/cppwp/char.traits.typedefs">[char.traits.typedefs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-09-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.typedefs">issues</a> in [char.traits.typedefs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The footnote for <tt>int_type</tt> in 23.2.3 <a href="https://timsong-cpp.github.io/cppwp/char.traits.typedefs">[char.traits.typedefs]</a> says that
</p>

<blockquote><p>
If <tt>eof()</tt> can be held in <tt>char_type</tt> then some iostreams implementations 
may give surprising results.
</p></blockquote>

<p>
This implies that <tt>int_type</tt> should be a superset of
<tt>char_type</tt>. However, the requirements for <tt>char16_t</tt> and <tt>char32_t</tt> define
<tt>int_type</tt> to be equal to <tt>int_least16_t</tt> and <tt>int_least32_t</tt> respectively.
<tt>int_least16_t</tt> is likely to be the same size as <tt>char_16_t</tt>, which may lead
to surprising behavior, even if <tt>eof()</tt> is not a valid UTF-16 code unit.
The standard should not prescribe surprising behavior, especially
without saying what it is (it's apparently not undefined, just
surprising). The same applies for 32-bit types.
</p>

<p>
I personally recommend that behavior be undefined if <tt>eof()</tt> is a member
of <tt>char_type</tt>, and another type be chosen for <tt>int_type</tt> (my personal
favorite has always been a <tt>struct {bool eof; char_type c;}</tt>).
Alternatively, the exact results of such a situation should be defined,
at least so far that I/O could be conducted on these types as long as
the code units remain valid. Note that the argument that no one streams
<tt>char16_t</tt> or <tt>char32_t</tt> is not really valid as it would be perfectly
reasonable to use a <tt>basic_stringstream</tt> in conjunction with UTF character
types.
</p>

<p><i>[
2009-10-28 Ganesh provides two possible resolutions and expresses a preference
for the second:
]</i></p>


<blockquote>
<ol>
<li>
<p>
Replace  [char.traits.specializations.char16_t] para 3 with:
</p>

<blockquote><p>
The member <tt>eof()</tt> shall return <del>an implementation-defined
constant that cannot appear as a valid UTF-16 code unit</del>
<ins><tt>UINT_LEAST16_MAX</tt> [<i>Note:</i> this value is guaranteed to
be a permanently reserved UCS-2 code position if <tt>UINT_LEAST16_MAX ==
0xFFFF</tt> and it's not a UCS-2 code position otherwise &mdash; <i>end
note</i>]</ins>.
</p></blockquote>

<p>
Replace  [char.traits.specializations.char32_t] para 3 with:
</p>

<blockquote><p>
The member <tt>eof()</tt> shall return <del>an implementation-defined constant that
cannot appear as a Unicode code point</del>
<ins>
<tt>UINT_LEAST32_MAX</tt> [<i>Note:</i> this value is guaranteed to be a
permanently reserved UCS-4 code position if <tt>UINT_LEAST32_MAX ==
0xFFFFFFFF</tt> and it's not a UCS-4 code position otherwise &mdash; <i>end
note</i>]</ins>.
</p></blockquote>
</li>
<li>
<p>
In  [char.traits.specializations.char16_t], in the
definition of <tt>char_traits&lt;char16_t&gt;</tt> replace the definition of nested
typedef <tt>int_type</tt> with:
</p>

<blockquote><pre>
namespace std {
  template&lt;&gt; struct char_traits&lt;char16_t&gt; {
    typedef char16_t         char_type;
    typedef <del>uint_least16_t</del> <ins>uint_fast16_t</ins> int_type;
     ...
</pre></blockquote>

<p>
Replace  [char.traits.specializations.char16_t] para 3 with:
</p>

<blockquote><p>
The member <tt>eof()</tt> shall return <del>an implementation-defined
constant that cannot appear as a valid UTF-16 code unit</del>
<ins><tt>UINT_FAST16_MAX</tt> [<i>Note:</i> this value is guaranteed to
be a permanently reserved UCS-2 code position if <tt>UINT_FAST16_MAX ==
0xFFFF</tt> and it's not a UCS-2 code position otherwise &mdash; <i>end
note</i>]</ins>.
</p></blockquote>

<p>
In  [char.traits.specializations.char32_t], in the
definition of <tt>char_traits&lt;char32_t&gt;</tt> replace the definition of nested
typedef <tt>int_type</tt> with:
</p>

<blockquote><pre>
namespace std {
  template&lt;&gt; struct char_traits&lt;char32_t&gt; {
    typedef char32_t         char_type;
    typedef <del>uint_least32_t</del> <ins>uint_fast32_t</ins> int_type;
     ...
</pre></blockquote>

<p>
Replace  [char.traits.specializations.char32_t] para 3 with:
</p>

<blockquote><p>
The member <tt>eof()</tt> shall return <del>an implementation-defined constant that
cannot appear as a Unicode code point</del>
<ins>
<tt>UINT_FAST32_MAX</tt> [<i>Note:</i> this value is guaranteed to be a
permanently reserved UCS-4 code position if <tt>UINT_FAST32_MAX ==
0xFFFFFFFF</tt> and it's not a UCS-4 code position otherwise &mdash; <i>end
note</i>]</ins>.
</p></blockquote>
</li>
</ol>
</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This seems an overspecification, and it is not clear what problem is being solved - 
these values can be used portably by using the named functions; there is no need 
for the value itself to be portable.

Move to Tentatively NAD.
</p></blockquote>

<p><i>[
Moved to NAD at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1202" href="1202">1202.</a> <tt>integral_constant</tt> needs a spring clean</h3>
<p><b>Section:</b> 21.3.4 <a href="https://timsong-cpp.github.io/cppwp/meta.help">[meta.help]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>integral_constant</tt> has been inherited
essentially unchanged from TR1:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  static const T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
};
</pre></blockquote>

<p>
In light of 0x language changes there are several things we might
consider changing, notably the form of specification for value.
</p>

<p>
The current form requires a static data member have storage allocated
for it, where we could now implement without this using the new enum
syntax:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  <b>enum : T { value = v };</b>
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
The effective difference between these two implementation is:
</p>

<ol style="list-style-type:lower-roman">
<li>
No requirement to allocate storage for data member (which we hope but do
not guarantee compilers strip today)
</li>

<li>
You can no longer take the address of the constant as
<tt>&amp;integral_constant&lt;T,v&gt;::value;</tt>
</li>
</ol>

<p>
Also note the editorial change to drop the explicit qualification of
<tt>integral_constant</tt> in the <tt>typedef type</tt>.  This makes it quite clear we
mean the current instantiation, and cannot be mistaken for a recursive
metaprogram.
</p>

<p>
Even if we don't mandate this implementation, it would be nice to give
vendors freedom under QoI to choose their preferred representation.
</p>

<p>
The other side of this issue is if we choose to retain the static
constant form.  In that case we should go further and insist on
<tt>constexpr</tt>, much like we did throughout <tt>numeric_limits</tt>:
</p>

<blockquote><pre>
template &lt;class T, T v&gt;
struct integral_constant {
  static <b>constexpr</b> T value = v;
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
[Footnote] It turns out <tt>constexpr</tt> is part of the Tentatively Ready
resolution for <a href="1019">1019</a>.  I don't want to interfere with that issue, but
would like a new issue to consider if the fixed-base enum implementation
should be allowed.
</p>

<p><i>[
2009-09-05 Daniel adds:
]</i></p>


<blockquote>
<p>
I think that the suggested resolution is incomplete and
may have some possible unwanted side-effects. To understand
why, note that <tt>integral_constant</tt> is <em>completely</em> specified
by code in 21.3.4 <a href="https://timsong-cpp.github.io/cppwp/meta.help">[meta.help]</a>. While this is usually considered
as a good thing, let me give a possible user-defined
specialization that would break given the suggested changes:
</p>

<blockquote><pre>
enum NodeColor { Red, Black };

std::integral_constant&lt;NodeColor, Red&gt; red;
</pre></blockquote>

<p>
The reason why that breaks is due to the fact that
current core language rules does only allow integral
types as enum-bases, see 9.7.1 <a href="https://timsong-cpp.github.io/cppwp/dcl.enum">[dcl.enum]</a>/2.
</p>

<p>
So, I think that we cannot leave the implementation the
freedom to decide which way they would like to provide
the implementation, because that is easily user-visible
(I don't speak of addresses, but of instantiation errors),
therefore if applied, this should be either specified or
wording must be added that gives a note about this
freedom of implementation.
</p>

<p>
Another possible disadvantage seems to me that user-expectations
are easy to disappoint if they see a failure
of the test
</p>

<blockquote><pre>
assert(typeid(std::integral_constant&lt;int, 0&gt;::value) == typeid(int));
</pre></blockquote>

<p>
or of
</p>

<blockquote><pre>
static_assert(std::is_same&lt;decltype(std::integral_constant&lt;int, 0&gt;::value), const int&gt;::value, "Bad library");
</pre></blockquote>

</blockquote>

<p><i>[
2010-01-14 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>
<p>
We think that the suggested resolution is incomplete and may have some possible
unwanted side-effects.  (see Daniel's 2009-09-05 comment for details).
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1217" href="1217">1217.</a> Quaternion support</h3>
<p><b>Section:</b> 28.4 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ted Shaneyfelt <b>Opened:</b> 2009-09-26 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Concerning mathematically proper operation of the type:
</p>

<blockquote><pre>
complex&lt;complex&lt;T&gt; &gt;
</pre></blockquote>

<p>
Generally accepted mathematical semantics of such a construct correspond
to quaternions through Cayly-Dickson construct
</p>

<blockquote><pre>
(w+xi) + (y+zi) j
</pre></blockquote>

<p>
The proper implementation seems straightforward by adding a few
declarations like those below. I have included operator definition for
combining real scalars and complex types, as well, which seems
appropriate, as algebra of complex numbers allows mixing complex and
real numbers with operators. It also allows for constructs such as
<tt>complex&lt;double&gt; i=(0,1),  x = 12.34 + 5*i;</tt>
</p>

<p>
Quaternions are often used in areas such as computer graphics, where,
for example, they avoid the problem of Gimbal lock when rotating objects
in 3D space, and can be more efficient than matrix multiplications,
although I am applying them to a different field.
</p>

<pre>
/////////////////////////ALLOW OPERATORS TO COMBINE REAL SCALARS AND COMPLEX VALUES /////////////////////////
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()+a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a+x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()-a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a-x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()*a, x.imag()*a);
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a*x.real(), a*x.imag());
    return result;
}

/////////////////////////PROPERLY IMPLEMENT QUATERNION SEMANTICS/////////////////////////
template&lt;typename T&gt; double normSq(const complex&lt;complex&lt;T&gt; &gt;q) {
    return q.real().real()*q.real().real()
         + q.real().imag()*q.real().imag()
         + q.imag().real()*q.imag().real()
         + q.imag().imag()*q.imag().imag();
}
template&lt;typename T&gt; double norm(const complex&lt;complex&lt;T&gt; &gt;q) {
    return sqrt(normSq(q));
}
/////// Cayley-Dickson Construction
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; conj(const complex&lt;complex&lt;T&gt; &gt; x) {
    complex&lt;complex&lt;T&gt; &gt; result(conj(x.real()),-x.imag());
    return result;
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator*(const complex&lt;complex&lt;T&gt; &gt; ab,const complex&lt;complex&lt;T&gt; &gt; cd) {
    complex&lt;T&gt; re(ab.real()*cd.real()-conj(cd.imag())*ab.imag());
    complex&lt;T&gt; im(cd.imag()*ab.real()+ab.imag()*conj(cd.real()));
    complex&lt;complex&lt;double&gt; &gt; q(re,im);
    return q;
}
//// Quaternion division
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; q,const S a) {
    return q * (1/a);
}
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const S a,const complex&lt;complex&lt;T&gt; &gt; q) {
    return a*conj(q)/normSq(q);
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; n, const complex&lt;complex&lt;T&gt; &gt; d) {
    return n * (conj(d)/normSq(d));
}
</pre>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future. There is no consensus or time to move this into C++0X.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend SG6 - We note that <tt>complex&lt;complex&gt;</tt> is the wrong way to spell this</p>

<p><i>[2017-03-03, Kona]</i></p>

<p>
SG6 suggests this issue is a new feature, not a problem with the existing
standard, and should therefore be closed NAD. However, SG6 invites papers that bring
the proposal up to date with the current standard.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1219" href="1219">1219.</a> unique_lock::lock and resource_deadlock_would_occur</h3>
<p><b>Section:</b> 33.6.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.lock.unique.locking">[thread.lock.unique.locking]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.lock.unique.locking">issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1159">1159</a></p>
<p><b>Discussion:</b></p>



<p>
<tt>unique_lock::lock</tt> and friends raise
"<tt>resource_deadlock_would_occur</tt> -- if the current thread already
owns the mutex (i.e., on entry, <tt>owns</tt> is <tt>true</tt>)."  1)
The current thread owning a mutex is not the same as any particular
<tt>unique_lock::owns</tt> being <tt>true</tt>. 2) There's no need to
raise this exception for a <tt>recursive_mutex</tt> if <tt>owns</tt> is
<tt>false</tt>. 3) If <tt>owns</tt> is true, we need to raise some
exception or the unique_lock will lose track of whether to unlock itself
on destruction, but "deadlock" isn't it. For (3), s/bool owns/int
ownership_level/ would fix it.
</p>

<p><i>[
2009-11-11 Alisdair notes that this issue is very closely related to <a href="1159">1159</a>,
if not a dup.
]</i></p>


<p><i>[
2009-11-14 Moved to Tentatively Dup after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1223" href="1223">1223.</a> condition_variable_any lock matching?</h3>
<p><b>Section:</b> 33.7.5 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <tt>condition_variable_any</tt>, must all lock arguments to concurrent wait calls
"match" in some way, similar to the requirement in
33.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> that <tt>lock.mutex()</tt> returns the same
value for each of the lock arguments supplied by all concurrently
waiting threads (via <tt>wait</tt> or <tt>timed_wait</tt>)?
</p>

<p><i>[
2010-02-12 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
The rationale is that it doesn't matter, and you can't check: the lock types may
be different, or the same and user-defined, so the implementation must provide
internal synchronization anyway.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1224" href="1224">1224.</a> condition_variable_any support for recursive mutexes?</h3>
<p><b>Section:</b> 33.7.5 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <tt>condition_variable_any</tt>, are recursive mutexes allowed? (I think "no")
</p>

<p><i>[
2009-11-17 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
<tt>condition_variable_any::wait</tt> accepts any type of mutex. It calls
<tt>unlock</tt> precisely once on entry and <tt>lock</tt> precisely once on
exit. It is up to the user to ensure that this provides the required
synchronization. Use of a recursive mutex is safe if either its lock count is 1,
so after the single unlock it can be acquired by another thread, or another
mechanism is used to synchronize the data.
</p>





<hr>
<h3><a name="1228" href="1228">1228.</a> User-specialized nothrow type traits</h3>
<p><b>Section:</b> 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to p1 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>:
</p>

<blockquote><p>
The behavior of a program that adds specializations for any of the class
templates defined in this subclause is undefined unless otherwise
specified.
</p></blockquote>

<p>
I believe we should 'otherwise specify' for the nothrow traits, are
these are exactly the use cases where the end user actually has more
information than the compiler.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to Open.  Definitely need to give the users the ability to ensure
that the traits give the right answers. Unsure we want to give them the
ability to say this in more than one way. Believes the noexcept proposal
already gives this.
</p></blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
We believe the solution offered by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html">N3050</a>
is superior.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following comment:
</p>

<blockquote><p>
user specialization permitted to derive from <tt>std::true_type</tt> when the
operation is known not to throw.
</p></blockquote>

<p>
to the following traits in 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> Table 43 Type
property predicates.
</p>

<p><i>[
This may require a new Comments column
]</i></p>


<blockquote><pre>
has_nothrow_default_constructor
has_nothrow_copy_constructor
has_nothrow_assign
</pre></blockquote>





<hr>
<h3><a name="1230" href="1230">1230.</a> <tt>mem_fn</tt> and variadic templates</h3>
<p><b>Section:</b> 22.10.16 <a href="https://timsong-cpp.github.io/cppwp/func.memfn">[func.memfn]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.memfn">issues</a> in [func.memfn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="920">920</a></p>
<p><b>Discussion:</b></p>



<p>
Since we have removed the entry in B <a href="https://timsong-cpp.github.io/cppwp/implimits">[implimits]</a> for the
library-specific limit for number of arguments passed to
<tt>function</tt>/<tt>tuple</tt>/etc. I believe we need to update the
spec for <tt>mem_fn</tt> to reflect this.
</p>

<p>
The "<i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set of
overloaded function templates." no longer holds, as we cannot create an
arbitrary number of such overloads.  I believe we should strike the
remark and add a second signature:
</p>

<blockquote><pre>
template&lt;class R, class T, typename ... ArgTypes&gt;
  unspecified mem_fn(R (T::*pm)(ArgTypes...));
</pre></blockquote>

<p>
I believe we need two signatures as pointer-to-data-member and
pointer-to-member-function-taking-no-args appear to use subtly different
syntax.
</p>

<p><i>[
<a href="920">920</a> as a similar proposed resolution.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Add to 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a> and 22.10.16 <a href="https://timsong-cpp.github.io/cppwp/func.memfn">[func.memfn]</a>:
</p>
<blockquote><pre>
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm)

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...)&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile&amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...)&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile&amp;&amp;);</ins>
</pre></blockquote>

<p>
Strike 22.10.16 <a href="https://timsong-cpp.github.io/cppwp/func.memfn">[func.memfn]</a>, p5:
</p>

<blockquote><p>
<del><i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set
of overloaded function templates.</del>
</p></blockquote>






<hr>
<h3><a name="1232" href="1232">1232.</a> Still <tt>swap</tt>'s with rvalue-references</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-10-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current library contains still rvalue reference-swaps that seem to be
overlooked in the process of switching back to lvalue-ref swaps.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Editor accepts as NAD Editorial.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a>/1 as indicated:
</p>

<blockquote><pre>
template &lt;class T1, class T2&gt;
struct pair {
  ...
  void swap(pair&amp;<del>&amp;</del> p);
};
</pre></blockquote>
</li>

<li>
<p>
Change 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> before p. 17 as indicated:
</p>

<blockquote><pre>
void swap(pair&amp;<del>&amp;</del> p);
</pre></blockquote>

</li>

<li>

<p>
Change 22.3 <a href="https://timsong-cpp.github.io/cppwp/pairs">[pairs]</a> before p. 21 as indicated:
</p>

<blockquote><pre>
template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y);
<del>template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp;&amp; x, pair&lt;T1, T2&gt;&amp; y);</del>
<del>template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 22.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a>/2, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>
// 20.5.2.9, specialized algorithms:
template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
<del>template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a> as indicated:
</p>

<blockquote><pre>
// 20.5.2.3, tuple swap
void swap(tuple&amp;<del>&amp;</del>)
</pre></blockquote>

</li>

<li>
<p>
Change 22.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a> before 1 as indicated:
</p>

<blockquote><pre>
void swap(tuple&amp;<del>&amp;</del> rhs);
</pre></blockquote>

</li>

<li>
<p>
Change 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>/2, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<del>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&amp;&amp;);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a>, as indicated:
</p>

<blockquote><pre>
// 20.7.15.2.2, function modifiers:
void swap(function&amp;<del>&amp;</del>);
template&lt;class F, class A&gt; void assign(F, const A&amp;);

[..]

// 20.7.15.2.7, specialized algorithms:
template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<del>template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;&amp;);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 22.10.17.3.8 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.alg">[func.wrap.func.alg]</a> before 1 as indicated:
</p>

<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
<del>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp;&amp; f2);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>/1 as indicated:
</p>

<blockquote><pre>
// 20.8.12.2.4, modifiers:
void swap(shared_ptr&amp;<del>&amp;</del> r);

[..]

// 20.8.12.2.9, shared_ptr specialized algorithms:
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b);
<del>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp;&amp; a, shared_ptr&lt;T&gt;&amp; b);
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp;&amp; b);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4 <a href="https://timsong-cpp.github.io/cppwp/string.classes">[string.classes]</a>/1, header <tt>&lt;string&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>
// 21.4.8.8: swap
template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);
<del>template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>/1, header <tt>&lt;deque&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>/1, header <tt>&lt;list&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>/1, header <tt>&lt;queue&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Allocator&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>

template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt;
class priority_queue;
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>/1, header <tt>&lt;stack&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp;&amp; x, stack&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>/1, header <tt>&lt;vector&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3.8 <a href="https://timsong-cpp.github.io/cppwp/deque">[deque]</a>/2 as indicated:
</p>

<blockquote><pre>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void swap(deque&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change  [deque.special] as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 99 [forwardlist]/2 as indicated:
</p>

<blockquote><pre>
iterator erase_after(const_iterator position);
iterator erase_after(const_iterator position, iterator last);
void swap(forward_list&lt;T,Allocator&gt;&amp;<del>&amp;</del>);

[..]

// 23.3.3.6 specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change  [forwardlist.spec] as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3.10 <a href="https://timsong-cpp.github.io/cppwp/list">[list]</a>/2 as indicated:
</p>

<blockquote><pre>
iterator erase(const_iterator position);
iterator erase(const_iterator position, const_iterator last);
void swap(list&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change  [list.special] as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.6.6.1 <a href="https://timsong-cpp.github.io/cppwp/queue.defn">[queue.defn]</a> as indicated:
</p>

<blockquote><pre>
void swap(queue&amp;<del>&amp;</del> q) { c.swap(q.c); }

[..]

template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.6.6.6 <a href="https://timsong-cpp.github.io/cppwp/queue.special">[queue.special]</a> as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.6.7 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a>/1 as indicated:
</p>

<blockquote><pre>
void swap(priority_queue&amp;<del>&amp;</del>);

// no equality is provided
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.6.7.5 <a href="https://timsong-cpp.github.io/cppwp/priqueue.special">[priqueue.special]</a> as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.6.8.2 <a href="https://timsong-cpp.github.io/cppwp/stack.defn">[stack.defn]</a> as indicated:
</p>

<blockquote><pre>
void swap(stack&amp;<del>&amp;</del> s) { c.swap(s.c); }

[..]

template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp; x, stack&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp;&amp; x, stack&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp; x, stack&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>


</li>

<li>
<p>
Change 24.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/stack.special">[stack.special]</a> as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp;&amp; x, stack&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a>/2 as indicated:
</p>

<blockquote><pre>
void swap(vector&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> before p. 8 as indicated:
</p>

<blockquote><pre>
void swap(vector&lt;T,Allocator&gt;&amp;<del>&amp;</del> x);
</pre></blockquote>

</li>

<li>
<p>
Change  [vector.special] as indicated:
</p>

<blockquote><pre>
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.3.12 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a>/1 as indicated:
</p>

<blockquote><pre>
iterator erase(const_iterator first, const_iterator last);
void swap(vector&lt;bool,Allocator&gt;&amp;<del>&amp;</del>);
static void swap(reference x, reference y);
</pre></blockquote>

</li>

<li>
<p>
Change 24.4 <a href="https://timsong-cpp.github.io/cppwp/associative">[associative]</a>/1, header <tt>&lt;map&gt;</tt> synopsis as indicated:
</p>

<blockquote><pre>
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>

[..]

template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.4 <a href="https://timsong-cpp.github.io/cppwp/associative">[associative]</a>/1, header <tt>&lt;set&gt;</tt> synopsis as indicated:
</p>

<blockquote><pre>
template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&gt;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(set&lt;Key,T,Compare,Allocator&amp;&amp; x, set&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(set&lt;Key,T,Compare,Allocator&amp; x, set&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>

[..]

template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,T,Compare,Allocator&amp;&amp; x, multiset&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,T,Compare,Allocator&amp; x, multiset&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.4.4 <a href="https://timsong-cpp.github.io/cppwp/map">[map]</a>/2 as indicated:
</p>

<blockquote><pre>
iterator erase(const_iterator first, const_iterator last);
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change  [map.special] as indicated:
</p>

<blockquote><pre>
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.4.5 <a href="https://timsong-cpp.github.io/cppwp/multimap">[multimap]</a>/2 as indicated:
</p>

<blockquote><pre>
iterator erase(const_iterator first, const_iterator last);
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change  [multimap.special] as indicated:
</p>

<blockquote><pre>
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.4.6 <a href="https://timsong-cpp.github.io/cppwp/set">[set]</a>/2 and  [set.special] as indicated: (twice!)
</p>

<blockquote><pre>
// specialized algorithms:
template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&gt;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&amp;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&amp; x, set&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 24.4.7 <a href="https://timsong-cpp.github.io/cppwp/multiset">[multiset]</a>/2 as indicated:
</p>

<blockquote><pre>
iterator erase(const_iterator first, const_iterator last);
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&amp;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change  [multiset.special] as indicated:
</p>

<blockquote><pre>
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>
</ol>





<hr>
<h3><a name="1233" href="1233">1233.</a> Missing <tt>unique_ptr</tt> signatures in synopsis</h3>
<p><b>Section:</b> 20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-10-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Related to <a href="296">296</a>.  Some <tt>unique_ptr</tt> signatures are missing
from the synopsis in 20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a>.
</p>

<p><i>[
2009-11-04 Howard adds:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Editorial.  The editor has adopted the fix.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add in 20.2 <a href="https://timsong-cpp.github.io/cppwp/memory">[memory]</a>, Header <tt>&lt;memory&gt;</tt> synopsis
missing declarations as shown below:
</p>

<blockquote><pre>
// 20.8.11 Class unique_ptr:
template &lt;class X&gt; class default_delete;
<ins>template&lt;class T&gt; struct default_delete&lt;T[]&gt;;</ins>
template &lt;class X, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
<ins>template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;</ins>

<ins>template&lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y);</ins>

<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
</pre></blockquote>





<hr>
<h3><a name="1235" href="1235">1235.</a> Issue with C++0x random number proposal</h3>
<p><b>Section:</b> 28.5.3.6 <a href="https://timsong-cpp.github.io/cppwp/rand.req.dist">[rand.req.dist]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matthias Troyer <b>Opened:</b> 2009-10-12 <b>Last modified:</b> 2019-02-26 17:57:49 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.dist">issues</a> in [rand.req.dist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There exist optimized, vectorized vendor libraries for the creation of
random number generators, such as Intel's MKL [1] and AMD's ACML [2]. In
timing tests we have seen a performance gain of a factor of up to 80
(eighty) compared to a pure C++ implementation (in Boost.Random) when
using these generator to generate a sequence of normally distributed
random numbers. In codes dominated by the generation of random numbers
(we have application codes where random number generation is more than
50% of the CPU time) this factor 80 is very significant.
</p>

<p>
To make use of these vectorized generators, we use a C++ class modeling
the <tt>RandomNumberEngine</tt> concept and forwarding the generation of random
numbers to those optimized generators. For example:
</p>

<blockquote><pre>
namespace mkl {
 class mt19937 {.... };
}
</pre></blockquote>

<p>
For the generation of random variates we also want to dispatch to
optimized vectorized functions in the MKL or ACML libraries. See this
example:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::normal_distribution&lt;double&gt; dist;

double n = dist(eng);
</pre></blockquote>

<p>
Since the variate generation is done through the <tt>operator()</tt> of the
distribution there is no customization point to dispatch to Intel's or
AMD's optimized functions to generate normally distributed numbers based
on the <tt>mt19937</tt> generator. Hence, the performance gain of 80 cannot be
achieved.
</p>

<p>
Contrast this with TR1:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::tr1::normal_distribution&lt;double&gt; dist;
std::tr1::variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; rng(eng,dist);
double n = rng();
</pre></blockquote>

<p>
This - admittedly much uglier from an aestethic point of view - design
allowed optimization by specializing the <tt>variate_generator</tt> template for
<tt>mkl::mt19937</tt>:
</p>

<blockquote><pre>
namespace std { namespace tr1 {

template&lt;&gt;
class variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; { .... };

} }
</pre></blockquote>

<p>
A similar customization point is missing in the C++0x design and
prevents the optimized vectorized version to be used.
</p>

<p>
Suggested resolution:
</p>

<p>
Add a customization point to the distribution concept. Instead of the
<tt>variate_generator</tt> template this can be done through a call to a
free function <tt>generate_variate</tt> found by ADL instead of
<tt>operator()</tt> of the distribution:
</p>

<blockquote><pre>
template &lt;RandomNumberDistribution, class RandomNumberEngine&gt;
typename RandomNumberDistribution ::result_type
generate_variate(RandomNumberDistribution const&amp; dist, RandomNumberEngine&amp; eng);
</pre></blockquote>

<p>
This function can be overloaded for optimized enginges like
<tt>mkl::mt19937</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  No time to add this feature for C++0X.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: The standard has changed enough that the issue doesn't make sense anymore. Write a paper proposing a way to get this performance as changes to the current library.</p>

<p><i>[Kona 2019: Jonathan notes:]</i></p>

<p>Libstdc++ has the following non-standard extensions for more efficient generation of large numbers of random numbers:</p>

<blockquote><pre>
template&lt;typename ForwardIterator, typename UniformRandomNumberGenerator&gt;
void __generate(ForwardIterator, ForwardIterator, 
                UniformRandomNumberGenerator&amp;);

template&lt;typename ForwardIterator, typename UniformRandomNumberGenerator&gt;
void __generate(ForwardIterator, ForwardIterator, 
                UniformRandomNumberGenerator&amp;, const param_type&amp;);

template&lt;typename UniformRandomNumberGenerator&gt;
void __generate(result_type*, result_type*,
                UniformRandomNumberGenerator&amp;, const param_type&amp;);
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1236" href="1236">1236.</a> reserved identifiers in programs not using the library</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-10-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I wasn't sure whether to consider this a library or a language issue,
because the issue is I think it's incorrectly categorized as being part
of the library, so I thought I'd send a message to both of you and let
you sort it out.
</p>

<p>
Most reserved identifiers are treated as unilaterally available to the
implementation, such as to implement language extensions, or provide
macros documenting its functionality. However, the requirements for
reserved identifers are in 16.4.5.3 <a href="https://timsong-cpp.github.io/cppwp/reserved.names">[reserved.names]</a>, which are a
subsection of 16.4.5 <a href="https://timsong-cpp.github.io/cppwp/constraints">[constraints]</a>. 16.4.5.1 <a href="https://timsong-cpp.github.io/cppwp/constraints.overview">[constraints.overview]</a> appears only to apply to "C++ programs
that use the facilities of the C++ standard library", meaning that, in
theory, all implementations are erroneous in having any non-standard
identifiers predefined for programs that do not, at some point, include
a standard library header.
</p>

<p>
Furthermore, it's unclear whether the use of certain identifiers is UB
or results in an ill-formed program. In particular, 16.4.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> uses a "shall not", where  [global.names] says that names are "reserved to the
implementation". 16.4.5.3 <a href="https://timsong-cpp.github.io/cppwp/reserved.names">[reserved.names]</a> seems only to cover the
instance of a name being described as "reserved", so are implementations
required to diagnose a program that performs, as an example, "<tt>#undef
get</tt>"?
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Move to NAD. There may in theory be multiple interpretations possible,
but there's no evidence that this causes any genuine problems or
uncertainty about what implementations are allowed to do. We do not
believe this rises to the level of a defect.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1239" href="1239">1239.</a> Defect report</h3>
<p><b>Section:</b> 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-10-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 43 defines a number of traits that yield true for arrays of class
types with the trait's property, but not arrays of other types with that
property.  For example, <tt>has_trivial_default_constructor</tt>:
</p>

<blockquote><p>
<tt>T</tt> is a trivial type (3.9) or a class type with a trivial default
constructor (12.1) or an array of such a class type.
</p></blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
<p>
An array of a trivial type is a trivial type.
</p>
<p>
Mark as Tentatively NAD Editorial. The wording is OK as is,
since an array of a trivial type is a trivial type, but the wording as
proposed might be clearer.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
The wording is OK as is, since an array of a trivial type is a trivial type.
Project editor may wish to accept the suggested wording as editorial.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change all the traits in question following this pattern:
</p>

<blockquote><p>
<tt>T</tt> is a trivial type (3.9) or a class type with a trivial default
 constructor (12.1)<ins>,</ins> or an array of such a <del>class</del> type.
</p></blockquote>

<p>
i.e., add a comma and delete a "class."
</p>





<hr>
<h3><a name="1242" href="1242">1242.</a> Enable SCARY iterators</h3>
<p><b>Section:</b> 24 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2009-10-21 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See <a href="https://wg21.link/n2980.pdf">N2980</a>.
</p>

<p><i>[
2009-10 Santa Cruz
]</i></p>

<blockquote>
<p>
The paper was lengthy discussed but considerable concern remained to add this feature to C++0x. 
The LWG does not wish to make a change at this time. Strong consensus was found to consider 
it for C++1x, though.
</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend Open: seems to be existing practice now</p>

<p><i>[2018-11 San Diego Thursday night issue processing]</i></p>

<p>Status to NAD; Alisdair to provide rationale.</p>

<p><b>Rationale:</b></p>
Insufficient motivation to make a change now. This is existing practice in the major implementations, and 
they are motivated to do this even if not mandated to do so, because it improves compilation time which 
benefits their users. If the issue submitter feels strongly about this they are invited to write an
updated paper with suggested wording to mandate it.



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1243" href="1243">1243.</a> Missing <tt>operator+= (initializer_list&lt;T&gt;)</tt> for <tt>valarray</tt></h3>
<p><b>Section:</b> 28.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/valarray.cassign">[valarray.cassign]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-10-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#valarray.cassign">issues</a> in [valarray.cassign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 64</b></p>

<p>
During the additions of <tt>initializer_list</tt> overloads
<tt>basic_string</tt> added:
</p>

<blockquote><pre>
basic_string&amp; operator+=(initializer_list&lt;charT&gt;);
</pre></blockquote>

<p>
but
</p>

<blockquote><pre>
valarray&lt;T&gt;&amp; operator+= (initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
was not defined.
</p>

<p><i>[
Daniel adds on opening:
]</i></p>


<blockquote><p>
Recommend NAD. The <tt>operator+=</tt> overload of <tt>basic_string</tt>
behaves as-if calling <tt>append</tt>, which is completely different in
meaning as the existing <tt>operator+=</tt> overloads in
<tt>valarray</tt> which just sum the value or values to the existing
elements. The suggestion to add a corresponding append function to
<tt>valarray</tt> was not considered as appropriate and the request was
withdrawn (c++std-lib-24968).
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD.  Request has been withdrawn by NB.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 28.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/valarray.cassign">[valarray.cassign]</a>:
</p>

<blockquote><pre>
valarray&lt;T&gt;&amp; operator+= (initializer_list&lt;T&gt;);
</pre></blockquote>





<hr>
<h3><a name="1246" href="1246">1246.</a> <tt>vector::resize()</tt> missing efficiency guarantee</h3>
<p><b>Section:</b> 24.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-10-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If <tt>v</tt> is a <tt>vector</tt>, I think repeated calls to
<tt>v.resize( v.size() + 1 )</tt> should be amortized O(1), but it's not
clear that's true from the text of the standard:
</p>

<blockquote><pre>
void resize(size_type sz);
</pre>
<blockquote><p>
<i>Effects:</i> If <tt>sz &lt; size()</tt>, equivalent to <tt>erase(begin() + sz, end());</tt>. If
<tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> default constructed elements to the
sequence.
</p></blockquote>
</blockquote>

<p>
Seems to me if we used <tt>push_back</tt> instead of appends, we might be giving
the guarantee I'd like.  Thoughts?
</p>

<p><i>[
2009-11-10 Howard adds:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.  Rationale added
below.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 24.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>/10, change
</p>

<blockquote><pre>
void resize(size_type sz);
</pre>
<blockquote><p>
<i>Effects:</i> If <tt>sz &lt; size()</tt>, equivalent to <tt>erase(begin() + sz, end());</tt>. If
<tt>size() &lt; sz</tt>, <del>appends <tt>sz - size()</tt> default constructed elements to the
sequence</del>
<ins>equivalent to <tt>sz - size()</tt> consecutive evaluations of <tt>push_back(T())</tt></ins>.
</p></blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p>
The description in terms of <tt>push_back</tt> led some to believe that
one could expect the exact same growth pattern from both <tt>resize</tt> and
<tt>push_back</tt> (e.g.) which could lead to sub-optimal implementations.
Additionally, 24.3.11 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a>, p1 includes a statement that this container
"supports (amortized) constant time insert and erase operations at the end;",
therefore addressing the concern of this issue.
</p>





<hr>
<h3><a name="1251" href="1251">1251.</a> move constructing <tt>basic_stringbuf</tt></h3>
<p><b>Section:</b> 31.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.cons">[stringbuf.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2009-10-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#stringbuf.cons">issues</a> in [stringbuf.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just came across issue <a href="1204">1204</a> -- Global permission to move, which
seems to address the concern raised by the example in c++std-lib-25030.
</p>
<p>
IIUC, the example violates the permission to assume that arguments
bound to rvalue references are unnamed temporaries granted to
implementations by the resolution of issue <a href="1204">1204</a> - Global permission
to move.
</p>

<p>
I.e., the <tt>ostringstream(ostringstream &amp;&amp;rhs)</tt> ctor can leave the <tt>rhs</tt>
pointers pointing to the newly constructed object's buffer just as
long as the dtor doesn't change or invalidate the buffer. The caller
may not make any assumptions about rhs after the move beyond it being
safe to destroy or reassign.
</p>

<p>
So unless I misunderstood something, I still think the <tt>basic_stringbuf</tt>
move ctor is overspecified. Specifically, I think the third sentence
in the Effects clause and the last 6 bullets in the Postconditions
clause can, and IMO should, be stricken.
</p>

<p><i>[
2010-01-31 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
The sense of 1251 appears to be that the <tt>basic_stringbuf</tt> move
constructor offers more guarantees than the minimum.  This is true, and quite
correct.  The additional words guarantee that the internal buffer has genuinely
transferred from one object to another, and further operations on the original
will not affect the buffer of the newly created object.  This is a very
important guarantee, much as we see that a moved-from <tt>unique_ptr</tt> is
guaranteed to be empty.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike from 31.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.cons">[stringbuf.cons]</a>:
</p>

<blockquote><pre>
basic_stringbuf(basic_stringbuf&amp;&amp; rhs);
</pre>
<blockquote>
<p>
<i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. It is
implementation-defined whether the sequence pointers in <tt>*this</tt>
(<tt>eback()</tt>, <tt>gptr()</tt>, <tt>egptr()</tt>, <tt>pbase()</tt>,
<tt>pptr()</tt>, <tt>epptr()</tt>) obtain the values which <tt>rhs</tt>
had. <del>Whether they do or not, <tt>*this</tt> and <tt>rhs</tt> reference
separate buffers (if any at all) after the construction.</del> The openmode,
locale and any other state of <tt>rhs</tt> is also copied.
</p>

<p>
<i>Postconditions:</i> Let <tt>rhs_p</tt> refer to the state of
<tt>rhs</tt> just prior to this construction and let <tt>rhs_a</tt>
referto the state of <tt>rhs</tt> just after this construction.
</p>
<ul>
<li>
<tt>str() == rhs_p.str()</tt>
</li>
<li>
<tt>gptr() - eback() == rhs_p.gptr() - rhs_p.eback()</tt>
</li>
<li>
<tt>egptr() - eback() == rhs_p.egptr() - rhs_p.eback()</tt>
</li>
<li>
<tt>pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()</tt>
</li>
<li>
<tt>epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()</tt>
</li>
<li><del>
if <tt>(eback()) eback() != rhs_a.eback()</tt>
</del></li>
<li><del>
if <tt>(gptr()) gptr() != rhs_a.gptr()</tt>
</del></li>
<li><del>
if <tt>(egptr()) egptr() != rhs_a.egptr()</tt>
</del></li>
<li><del>
if <tt>(pbase()) pbase() != rhs_a.pbase()</tt>
</del></li>
<li><del>
if <tt>(pptr()) pptr() != rhs_a.pptr()</tt>
</del></li>
<li><del>
if <tt>(epptr()) epptr() != rhs_a.epptr()</tt>
</del></li>
</ul>
</blockquote>
</blockquote>






<hr>
<h3><a name="1259" href="1259">1259.</a> Should initializer-list constructors move elements?</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-11-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, <tt>X(il)</tt> is
equivalent to <tt>X(il.begin(), il.end())</tt>. Should it instead be
equivalent to <tt>X(move_iterator(il.begin()),
move_iterator(il.end()))</tt> so that needless copies are not made? This
doesn't seem ideal either - it may make more sense to provide two
overloads for the constructor, one for move and one for copy.
</p>

<p><i>[
2009-11-10 Howard adds:
]</i></p>


<blockquote><p>
I've moved this issue to Tentatively NAD after 5 positive votes on c++std-lib,
and added a rationale below.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
There is no consensus at this time within EWG or CWG to make the
required language changes.  Therefore this is not something that the LWG
can even consider.  Should such language changes be made for a future
standard, no doubt there would need to be an accompanying library impact
survey.
</p>





<hr>
<h3><a name="1263" href="1263">1263.</a> missing <tt>swap</tt> overloads for <tt>regex</tt></h3>
<p><b>Section:</b> 32.3 <a href="https://timsong-cpp.github.io/cppwp/re.syn">[re.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-11-12 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.syn">issues</a> in [re.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses: UK 314</b></p>

<p>
In Message c++std-lib-25529, Alisdair writes:
</p>

<blockquote>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3009.html#UK314">UK comment 314</a>
requests rvalue swap overloads in a couple of places they
were missed.
</p>

<p>
We have in general reverted to the single swap signature taking lvalue
references, which could be seen as the alternative solution to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3009.html#UK314">UK 314</a>,
bringing consistency to the standard &lt;g&gt;
</p>

<p>
Either way, I no longer expect to see any work to resolve this comment -
the work is complete and it should be either marked Rejected, or
Accepted with Modifications (namely, removing all other rvalue swaps!)
</p>
</blockquote>

<p><i>[
Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
We have in general reverted to the single swap signature taking
lvalue references, which could be seen as the alternative solution to
UK 314, bringing consistency to the standard.
</p>





<hr>
<h3><a name="1265" href="1265">1265.</a> <tt>longjmp</tt> and destructors</h3>
<p><b>Section:</b> 17.14 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-11-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.14 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>/4 says that <tt>longjmp</tt> is undefined if
unwinding by the mechanism used by catch and throw would invoke any nontrivial
destructors. However, the text as written is rather vague, in particular when
dealing with <tt>catch(...)</tt>:
</p>

<blockquote><pre>
void foo() {
  jump_buf buf;
  non_trivial_dtor n1; // 1
  if (!setjmp(buf)) {
    non_trivial_dtor n2; // 2
    try {
      longjmp(buf, 1);
    } catch (...) {
    }
  }
}
</pre></blockquote>

<p>
My interpretation of the meaning of 17.14 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>/4 is that
declaration 2, but not 1, would cause the <tt>longjmp</tt> to be undefined
behavior. However,  it's not entirely clear from the text. Arguably, replacing
the <tt>setjmp</tt> and <tt>longjmp</tt> with <tt>catch</tt> would still cause
the destructor for <tt>n1</tt> to be called after the unwinding, which would
lead to undefined behavior. This is clearly not an intended consequence of the
wording. However, it is probably still UB, as <tt>n1</tt> now has
"indeterminate" value, and running its destructor on <tt>foo</tt>'s exit will
cause Bad Things.
</p>

<p>
Declarations 2 has a more interesting issue. The <tt>catch(...)</tt> muddles up
the definition that uses <tt>throw</tt> and <tt>catch</tt> - if
<tt>longjmp()</tt> were indeed a <tt>throw</tt>, control would never return to
the <tt>setjmp</tt>. As such, <tt>n2</tt>'s destructor wouldn't be called
(except by the argument for <tt>n1</tt>, which is that the destructor would be
called later as the frame was left in the normal control flow).
</p>

<p>
I suggest that paragraph 4 of 17.14 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> should be replaced
with the following, or something that reads better but has the same effect:
</p>

<blockquote><p>
The function signature <tt>longjmp(jmp_buf jbuf, int val)</tt> has more
restricted behavior in this International Standard. A call to <tt>longjmp</tt>
has undefined behavior if any non-trivial destructors would be called were the
<tt>longjmp</tt> call replaced with a throw-expression whose nearest matching
handler were a (possibly imaginary) function-try-block on the function
containing the corresponding <tt>setjmp</tt> call.
</p></blockquote>

<p><i>[
2009-11-17 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 17.14 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>/4:
</p>

<blockquote><p>
The function signature <tt>longjmp(jmp_buf jbuf, int val)</tt> has more
restricted behavior in this International Standard. <del>A
<tt>setjmp</tt>/<tt>longjmp</tt> call pair has undefined behavior if replacing
the <tt>setjmp</tt> and <tt>longjmp</tt> by <tt>catch</tt> and <tt>throw</tt>
would invoke any non-trivial destructors for any automatic objects.</del>
<ins>A call to <tt>longjmp</tt> has undefined behavior if any non-trivial
destructors would be called were the <tt>longjmp</tt> call replaced with a
throw-expression whose nearest matching handler were a (possibly imaginary)
function-try-block on the function containing the corresponding <tt>setjmp</tt>
call.</ins>
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
In the given example, it is clear that it is only <tt>n2</tt> and not
<tt>n1</tt> that is destroyed by the <tt>longjmp</tt>.
</p>
<p>
At this late stage in the standards process, we are focusing on issues that
impact users or implementers.  Trying to rewrite complex wording just for the
sake of improved clarity is likely to do more harm than good.
</p>





<hr>
<h3><a name="1282" href="1282">1282.</a> A proposal to add <tt>std::split</tt> algorithm</h3>
<p><b>Section:</b> 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Igor Semenov <b>Opened:</b> 2009-12-07 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol style="list-style-type:upper-roman">

<li>
<p>
Motivation and Scope
</p>
<p>
Splitting strings into parts by some set of delimiters is an often task, but
there is no simple and generalized solution in C++ Standard. Usually C++
developers use <tt>std::basic_stringstream&lt;&gt;</tt> to split string into
parts, but there are several inconvenient restrictions:
</p>

<ul>
<li>
we cannot explicitly assign the set of delimiters;
</li>
<li>
this approach is suitable only for strings, but not for other types of
containers;
</li>
<li>
we have (possible) performance leak due to string instantiation.
</li>
</ul>
</li>

<li>
<p>
Impact on the Standard
</p>
<p>
This algorithm doesn't interfere with any of current standard algorithms.
</p>
</li>

<li>
<p>
Design Decisions
</p>
<p>
This algorithm is implemented in terms of input/output iterators. Also, there is
one additional wrapper for <tt>const CharType *</tt> specified delimiters.
</p>
</li>

<li>
<p>
Example implementation
</p>
<pre>
template&lt; class It, class DelimIt, class OutIt &gt;
void split( It begin, It end, DelimIt d_begin, DelimIt d_end, OutIt out )
{
   while ( begin != end )
   {
       It it = std::find_first_of( begin, end, d_begin, d_end );
       *out++ = std::make_pair( begin, it );
       begin = std::find_first_of( it, end, d_begin, d_end,
           std::not2( std::equal_to&lt; typename It::value_type &gt;() ) );
   }
}

template&lt; class It, class CharType, class OutIt &gt;
void split( It begin, It end, const CharType * delim, OutIt out )
{
   split( begin, end, delim, delim + std::strlen( delim ), out );
}
</pre>
</li>

<li>
<p>
Usage
</p>
<pre>
std::string ss( "word1 word2 word3" );
std::vector&lt; std::pair&lt; std::string::const_iterator, std::string::const_iterator &gt; &gt; v;
split( ss.begin(), ss.end(), " ", std::back_inserter( v ) );

for ( int i = 0; i &lt; v.size(); ++i )
{
   std::cout &lt;&lt; std::string( v[ i ].first, v[ i ].second ) &lt;&lt; std::endl;
}
// word1
// word2
// word3
</pre>
</li>

</ol>

<p><i>[
2010-01-22 Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Paper encouraged. Have papers for this; <a href="https://wg21.link/LEWG259">LEWG259</a>.</p>



<p><b>Rationale:</b></p>
<p>
The LWG is not considering completely new features for standardization at this
time.  We would like to revisit this good suggestion for a future TR and/or
standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 27.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a>:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );

template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre></blockquote>

<p>
Add a new section [alg.split]:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> splits the range <tt>[first, last)</tt> into parts, using any
element of <tt>[delimiter_first, delimiter_last)</tt> as a delimiter. Results
are pushed to output iterator in the form of <tt>std::pair&lt;ForwardIterator1,
ForwardIterator1&gt;</tt>. Each of these pairs specifies a maximal subrange of
<tt>[first, last)</tt> which does not contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

<pre>
template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> split the range <tt>[first, last)</tt> into parts, using any
element of <tt>delimiters</tt> (interpreted as zero-terminated string) as a
delimiter. Results are pushed to output iterator in the form of
<tt>std::pair&lt;ForwardIterator1, ForwardIterator1&gt;</tt>. Each of these
pairs specifies a maximal subrange of <tt>[first, last)</tt> which does not
contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="1289" href="1289">1289.</a> Generic casting requirements for smart pointers</h3>
<p><b>Section:</b> 22.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ion Gazta&ntilde;aga <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 40 &mdash; Allocator requirements,
the following expression is required for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>
<tr>
<td><tt>static_cast&lt;X::pointer&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static_cast&lt;X::pointer&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>
</table>
</blockquote>

<p>
To achieve this expression, a smart pointer writer must introduce an explicit
conversion operator from <tt>smart_ptr&lt;void&gt;</tt> to
<tt>smart_ptr&lt;T&gt;</tt> so that
<tt>static_cast&lt;pointer&gt;(void_ptr)</tt> is a valid expression.
Unfortunately this explicit conversion weakens the safety of a smart pointer
since the following expression (invalid for raw pointers) would become valid:
</p>

<blockquote><pre>
smart_ptr&lt;void&gt; smart_v = ...;
smart_ptr&lt;T&gt; smart_t(smart_v);
</pre></blockquote>

<p>
On the other hand, <tt>shared_ptr</tt> also defines its own casting functions in
20.3.2.2.10 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cast">[util.smartptr.shared.cast]</a>, and although it's unlikely that a
programmer will use <tt>shared_ptr</tt> as <tt>allocator::pointer</tt>, having
two different ways to do the same cast operation does not seem reasonable. A
possible solution would be to replace <tt>static_cast&lt;X::pointer&gt;(w)</tt>
expression with a user customizable (via ADL)
<tt>static_pointer_cast&lt;value_type&gt;(w)</tt>, and establish the
<tt>xxx_pointer_cast</tt> functions introduced by <tt>shared_ptr</tt> as the
recommended generic casting utilities of the standard.
</p>

<p>
Unfortunately, we've experienced problems in Boost when trying to establish
<tt>xxx_pointer_cast</tt> as customization points for generic libraries (<a
href="http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html"
>http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html</a>)
because these casting functions are called with explicit template parameters and
the standard says in 13.10.2 <a href="https://timsong-cpp.github.io/cppwp/temp.arg.explicit">[temp.arg.explicit]</a> p.8 "Explicit template
argument specification":
</p>

<blockquote><p>
8 ...But when a function template with explicit template arguments is used, the
call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call. If no such name is
visible, the call is not syntactically well-formed and argument-dependent lookup
does not apply.
</p></blockquote>

<p>
So we can do this:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_swap(BasePtr p)
{
  //ADL customization point
  swap(p, p);
  //...
}
</pre></blockquote>

<p>
but not the following:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;
  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);
}
</pre></blockquote>

<p>
The solution to make <tt>static_pointer_cast</tt> a customization point is to
add a generic declaration (no definition) of <tt>static_pointer_cast</tt> in a
namespace (like <tt>std</tt>) and apply "<tt>using
std::static_pointer_cast</tt>" declaration to activate ADL:
</p>

<blockquote><pre>
namespace std{

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

}

template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;

  //ADL applies because static_pointer_cast is made
  //  visible according to [temp.arg.explicit]/8
  using std::static_pointer_cast;

  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);

  //...
}
</pre></blockquote>

<p>
A complete solution will need also the definition of
<tt>static_pointer_cast</tt> for raw pointers, and this definition has been
present in Boost (<a
href="http://www.boost.org/boost/pointer_cast.hpp">http://www.boost.org/boost/
pointer_cast.hpp</a>) for years.
</p>

<p><i>[
2010-03-26 Daniel made editorial adjustments to the proposed wording.
]</i></p>


<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>

<blockquote><p>
This is a new feature rather than a defect. 
It can be added later: "this is such a hairy area that people will put up with changes"
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: NAD. Should bring a paper as a proposal for 2020.</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to section 22.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> Utility components, Header
<tt>&lt;utility&gt;</tt> synopsis:
</p>

<blockquote><pre>
// 20.3.X, generic pointer cast functions

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;

//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre></blockquote>

<p>
Add to section 22.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> Utility components, a new subclause
20.3.X Pointer cast utilities [pointer.cast]:
</p>

<blockquote>
<p>
20.3.X Pointer cast utilities [pointer.cast]
</p>

<p>
1 The library defines generic pointer casting function templates so that template code
can explicitly make these names visible and activate argument-dependent lookup
for pointer cast calls.
</p>

<pre>
//Generic declarations
template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;
</pre>

<p>
2 The library also defines overloads of these functions for raw pointers.
</p>

<pre>
//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>static_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>dynamic_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>const_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
#include &lt;utility&gt; //static_pointer_cast
#include &lt;memory&gt;  //pointer_traits

class Base{};
class Derived : public Base{};

template&lt;class BasePtr&gt;
void generic_pointer_code(BasePtr b)
{
   typedef std::pointer_traits&lt;BasePtr&gt;::template
      rebind&lt;Derived&gt; DerivedPtr;

   using std::static_pointer_cast;
   //ADL applies now that static_pointer_cast is visible
   DerivedPtr d = static_pointer_cast&lt;Derived&gt;(b);
}
</pre></blockquote>

<p>
&mdash; <i>end example</i>]
</p>

</blockquote>

<p>
Replace in section 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> Table 40 &mdash; Allocator
requirements, the following table entries for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(w)</tt></td>
<td><tt>X::const_pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(z) == q</tt></td>
<td>&nbsp;</td>
</tr>

</table>
</blockquote>






<hr>
<h3><a name="1296" href="1296">1296.</a> <tt>map</tt> and <tt>multimap value_compare</tt> overspecified</h3>
<p><b>Section:</b> 24.4.4 <a href="https://timsong-cpp.github.io/cppwp/map">[map]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-12-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The container class templates <tt>map</tt> and <tt>multimap</tt> both contain a
nested type called <tt>value_compare</tt>, that is used to compare the
<tt>value_type pair</tt> elements, an adaptor of the user-supplied comparison
function-like object.
</p>

<p>
I believe these types are over-specified, as we require a distinct type for each
template, even though the allocator plays no part in the comparator, and
<tt>map</tt> and <tt>multimap value_compare</tt> classes could easily be shared.
 The benefits are similar to the SCARY iterator proposal (although on a much
smaller scale!) but unlike SCARY, this is not a QoI issue today but actively
prohibited.
</p>

<p>
If the <tt>value_compare</tt> classes were marked 'exposition only', a vendor
would be free to experiment with implementations that do not produce so many
template instantiations with negligible impact on conforming programs.  (There
is a minor risk that programs could no longer portably overload functions taking
<tt>value_compare</tt> types.  This scenario is extremely unlikely outside
conformance suites.)
</p>

<p>
(Note that there are no similar problems for unordered maps, nor any of the set
variants)
</p>

<p><i>[
2010-01-31 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>


<p><b>Rationale:</b></p>
<p>
The <tt>value_compare</tt> specification is an unfortunate bit from the past
that we have to live with.  Fortunately vendors can work around the problems
mentioned in this issue.
</p>




<p><b>Proposed resolution:</b></p>
<p>
p2 24.4.4 <a href="https://timsong-cpp.github.io/cppwp/map">[map]</a>:
Above the declaration of class <tt>value_compare</tt> in the map synopsis, add:
</p>

<blockquote><pre>
template &lt;class Key, class T, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
class map {
public:
  // types:
  ...
  <ins>// exposition only.</ins>
  class value_compare
    : public binary_function&lt;value_type,value_type,bool&gt; {
    ...
</pre></blockquote>



<p>
p2 24.4.5 <a href="https://timsong-cpp.github.io/cppwp/multimap">[multimap]</a>:
Above the declaration of class <tt>value_compare</tt> in the map synopsis, add:
</p>

<blockquote><pre>
template &lt;class Key, class T, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
class multimap {
public:
  // types:
  ...
  <ins>// exposition only.</ins>
  class value_compare
    : public binary_function&lt;value_type,value_type,bool&gt; {
    ...
</pre></blockquote>





<hr>
<h3><a name="1301" href="1301">1301.</a> <tt>clear()</tt> and assignment</h3>
<p><b>Section:</b> 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-01-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I propose that <tt>clear()</tt> be defined to be equivalent to
<tt>erase(begin(),end())</tt> except not using copy or move of elements.
</p>

<blockquote>
<p>
To: C++ libraries mailing list<br/>
Message c++std-lib-26465
</p>

<p>
and specifiying as post: <tt>size()==0</tt> might also not be appropriate
because forward-Lists provide no <tt>size()</tt>, this it should be:
post: <tt>empty()==true</tt>
</p>

<p>
Bjarne Stroustrup schrieb/wrote:
</p>

<blockquote>
<p>
To: C++ libraries mailing list<br/>
Message c++std-lib-26458
</p>

<p>
in table 94 we define <tt>clear()</tt> as:
</p>

<blockquote><pre>
a.clear() void erase(begin(), end())
post: size() == 0
</pre></blockquote>

<p>
Now <tt>erase</tt> requires assignment (<tt>MoveAssignable</tt>) which makes
sense if we have to move an element, but why should that be required from
<tt>clear()</tt> where all elements are destroyed?
</p>
</blockquote>
</blockquote>

<p><i>[
2010-01-23 Alisdiar provides wording.
]</i></p>


<p><i>[
2010-01-30 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-01-30 Daniel opens:
]</i></p>


<blockquote>
<p>
First, I read the newly proposed spec for <tt>clear()</tt> that it does in
general <em>not</em> invalidate a previous past-the-end iterator value, but
<tt>deque</tt> says in 24.3.8.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a> for the semantics of
<tt>erase</tt> that erasures at the end will invalidate the past-the-end
iterator. With removal of a direct binding between <tt>clear()</tt> and
<tt>erase()</tt> there seem to be some fixes necessary. One way to fix that
would be to mention in Table 94 that this "may also invalidate the past-the-end
iterator" and then to mention for all specific containers where this does not
happen, the exception, [1] e.g. in <tt>std::vector</tt>. <tt>std::vector</tt>
has no own specification of <tt>clear()</tt> and one aspect of the closed issue
<a href="1102">1102</a> was to realize just that (indirectly via <tt>erase</tt>). IMO
we should now add an extra specification for <tt>clear()</tt>. Btw.:
<tt>std::vector::erase</tt> reads to me that it would invalidate previous
past-the-end values (and that seems correct in general).
</p>
<p>
Before I will provide explicit wording, I would like to
discuss these points.
</p>

<p>
[1] <tt>std::list</tt> does fortunately specify that clear does not invalidate
the past-the-end iterator.
</p>
</blockquote>

<p><i>[
2010-02-08 Moved to Tentatively NAD Editorial after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved as proposed by LWG <a href="704">704</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/10:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.2.3, and 23.3.6.4) all
container types defined in this Clause meet the following additional
requirements:
</p>

<ul>
<li>
..
</li>

<li>
no <tt>erase()</tt>, <ins><tt>clear()</tt>,</ins> <tt>pop_back()</tt> or
<tt>pop_front()</tt> function throws an exception.
</li>

<li>
...
</li>
</ul>

</blockquote>

<p>
Replace the following words from Table 94 &mdash; Sequence container
requirements (in addition to container) in 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 94 &mdash; Sequence container requirements (in addition to
container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
</tr>

<tr>
<td><tt>a.clear()</tt></td>
<td><tt>void</tt></td>
<td><del><tt>erase(begin(), end())</tt></del><br/>
<ins>Destroys all elements in the container a. Invalidates all references,
pointers, and iterators referring to the elements of <tt>a</tt> and may
invalidate the past-the-end iterator.</ins><br/>
post: <tt><del>size() == 0</del> <ins>a.empty() == true</ins></tt>.  </td>
</tr>
</table>
</blockquote>

<p>
Add a new paragraph after 99 [forwardlist.modifiers]/23:
</p>

<blockquote><pre>
void clear();
</pre>

<blockquote>
<p>
23 <i>Effects:</i> Erases all elements in the range <tt>[begin(),end())</tt>.
</p>
<p><ins>
<i>Remarks:</i> Does not invalidate past-the-end iterators.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1302" href="1302">1302.</a> different <tt>emplace</tt> semantics for sequence and associated containers</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-01-03 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the new naming scheme introduced with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a>
</p>

<blockquote><pre>
vector&lt;T&gt; v;
v.emplace(v.begin(),x,y,z)
</pre></blockquote>

<p>
now has a different semantics than
</p>

<blockquote><pre>
set&lt;T&gt; s;
s.emplace(s.begin(),x,y,z);
</pre></blockquote>

<p>
While the version for <tt>vector</tt>s takes the first argument as position and
the remaining for construction, the version for <tt>set</tt>s takes all
arguments for construction.
</p>

<p>
IMO, this is a serious design mistake for a couple of reasons:
</p>

<ul>
<li>
<p>
First, in principle, all STL member functions should have the same behavior with
the same member function to avoid confusion and allow to write proper generic
code.
</p>
<p>
In fact, when I write the following simple function template:
</p>
<blockquote><pre>
template &lt;typename T&gt;
void doEmplace (T&amp; cont)
{
   cont.emplace(cont.begin(),"nico","josuttis",42);
}
</pre></blockquote>
<p>
the semantics depends on the type of the container.
</p>
</li>
<li>
<p>
In addition, I also guess using the name <tt>emplace_hint()</tt> instead of
<tt>emplace()</tt> for associative containers is a design mistake. According to
my knowledge, it was a design goal of the original STL to provide ONE
<tt>insert</tt> function, which works for ALL containers. This was
<tt>insert(pos,val)</tt>.
</p>
<p>
The trick to declare <tt>pos</tt> as a hint, allowed that we could implement a
generic <tt>insert</tt> for all containers. Now, with the new <tt>emplace</tt>
naming scheme, this trick is gone for the new kind of insertion.
</p>
</li>
</ul>

<p>
I consider this to be a serious design penalty because once this
is specified we can't fix that without breaking backward compatibility.
</p>

<p>
However, we have two choices for a fix:
</p>

<ul>
<li>
rename <tt>emplace_hint(pos,val)</tt> for associative containers back to
<tt>emplace(pos,val)</tt>. However to avoid the overloading problems, we also
have to rename the existing <tt>emplace(val)</tt> functions to something else (I
don't have a good name here at hand).
</li>
<li>
Keep <tt>emplace(val)</tt> for associative containers as it is, but rename
<tt>emplace(pos,val)</tt> for sequence containers and
<tt>emplace_hint(pos,val)</tt> to something like <tt>emplace_at(pos,val)</tt>,
declaring that <tt>pos</tt> is a hint for associative containers.
</li>
</ul>

<p><i>[
2010 Pittsburgh:  Moved to NAD, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
There was no consensus to make this change.
</p>


<p><b>Proposed resolution:</b></p>
<p> In 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, change: </p>
<blockquote> 
  <table border="1">
    <caption>Table 96 &mdash; Associative container requirements (in addition to 
    container)</caption>
    <tr> 
      <th>expression</th>
      <th>Return type</th>
      <th>Assertion/note pre-/post-condition</th>
      <th>Post-condition</th>
    </tr>
    <tr> 
      <td colspan="4">...</td>
    </tr>
    <tr> 
      <td><tt>a_uniq.emplace<ins>_value</ins>(args)</tt></td>
      <td><tt>pair&lt;iterator, bool&gt;</tt></td>
      <td>inserts a T object t constructed with std::forward&lt;Args&gt;(args)...<br/>
        if and only if there is no element in the container with key equivalent 
        to the key of t.<br/>
        The bool component of the returned pair is true if and only if the insertion 
        takes place, and the iterator component of the pair points to the element 
        with key equivalent to the key of t.</td>
      <td>logarithmic</td>
    </tr>
    <tr> 
      <td><tt>a_eq.emplace<ins>_value</ins>(args)</tt></td>
      <td><tt>iterator</tt></td>
      <td>inserts a T object t constructed with std::forward&lt;Args&gt;(args)... 
        and returns the iterator pointing to the newly inserted element.</td>
      <td>logarithmic</td>
    </tr>
    <tr> 
      <td><tt>a.emplace<del>_hint</del>(p,args)</tt></td>
      <td><tt>iterator</tt></td>
      <td>equivalent to
      <tt>a.emplace<ins>_value</ins>(std::forward&lt;Args&gt;(args)...)</tt>.
      Return value is an iterator pointing to the element with the key
      equivalent to the newly inserted element. The const_iterator p is a hint
      pointing to where the search should start. Implementations are permitted
      to ignore the hint.</td> <td>logarithmic in general, but amortized
      constant if the element is inserted right after p</td>
    </tr>
    <tr> 
      <td colspan="4">... </td>
    </tr>
  </table>
  
</blockquote>
<p> In 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, change: </p>
<blockquote>
  <table border="1">
    <caption>Table 98 &mdash; Unordered associative container requirements (in 
    addition to container)</caption>
    <tr> 
      <th>expression</th>
      <th>Return type</th>
      <th>Assertion/note pre-/post-condition</th>
      <th>Post-condition</th>
    </tr>
    <tr> 
      <td colspan="4">...</td>
    </tr>
    <tr> 
      <td><tt>a_uniq.emplace<ins>_value</ins>(args)</tt></td>
      <td><tt>pair&lt;iterator, bool&gt;</tt></td>
      <td>inserts a <tt>T</tt> object <tt>t</tt> constructed with <tt>std::forward&lt;Args&gt;(args)...</tt> if 
        and only if there is no element in the container with key equivalent to 
        the key of <tt>t</tt>. The bool component of the returned pair is true if and only 
        if the insertion takes place, and the iterator component of the pair points 
        to the element with key equivalent to the key of t.</td>
      <td>Average case O(1), worst case O(a_uniq.size()).</td>
    </tr>
    <tr> 
      <td><tt>a_eq.emplace<ins>_value</ins>(args)</tt></td>
      <td><tt>iterator</tt></td>
      <td>inserts a T object t constructed with std::forward&lt;Args&gt;(args)... 
        and returns the iterator pointing to the newly inserted element.</td>
      <td>Average case O(1), worst case O(a_eq.size()).</td>
    </tr>
    <tr> 
      <td><tt>a.emplace<del>_hint</del>(p,args)</tt></td>
      <td><tt>iterator</tt></td>
      <td>equivalent to
      <tt>a.emplace<ins>_value</ins>(std::forward&lt;Args&gt;(args)...)</tt>.
      Return value is an iterator pointing to the element with the key
      equivalent to the newly inserted element. The const_iterator p is a hint
      pointing to where the search should start. Implementations are permitted
      to ignore the hint.</td> <td>Average case O(1), worst case
      O(a.size()).</td>
    </tr>
    <tr> 
      <td colspan="4">... </td>
    </tr>
  </table>
</blockquote>

<p>
In 24.4.4 <a href="https://timsong-cpp.github.io/cppwp/map">[map]</a>, 24.4.6 <a href="https://timsong-cpp.github.io/cppwp/set">[set]</a>, 24.5.4 <a href="https://timsong-cpp.github.io/cppwp/unord.map">[unord.map]</a>, 24.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a>, change:
</p>
<blockquote> 
  <p><i>// modifiers:</i><br/>
    <tt>template &lt;class... Args&gt; pair&lt;iterator, bool&gt; emplace<ins>_value</ins>(Args&amp;&amp;... 
    args);<br/>
    template &lt;class... Args&gt; iterator emplace<del>_hint</del>(const_iterator 
    position, Args&amp;&amp;... args);</tt></p>
</blockquote>

<p>
In 24.4.5 <a href="https://timsong-cpp.github.io/cppwp/multimap">[multimap]</a>, 24.4.7 <a href="https://timsong-cpp.github.io/cppwp/multiset">[multiset]</a>, 24.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap">[unord.multimap]</a>, 24.5.7 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset">[unord.multiset]</a>, change:
</p>
<blockquote> 
  <p><i>// modifiers:<br/></i><tt>template &lt;class... Args&gt; iterator emplace<ins>_value</ins>(Args&amp;&amp;... 
    args);<br/>
    template &lt;class... Args&gt; iterator emplace<del>_hint</del>(const_iterator position, 
    Args&amp;&amp;... args);<br/>
    </tt> </p>
</blockquote>





<hr>
<h3><a name="1308" href="1308">1308.</a> Concerns about <tt>initializer_list</tt> overloads of <tt>min</tt>,
<tt>max</tt>, and <tt>minmax</tt></h3>
<p><b>Section:</b> 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2010-02-02 <b>Last modified:</b> 2017-09-07 13:59:44 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In San Francisco, June 2008, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2722.pdf">N2722</a>
was adopted, replacing the variadic templates <tt>min</tt>, <tt>max</tt>, and
<tt>minmax</tt> by overloads that have an <tt>initializer_list&lt;T&gt;</tt>
parameter. The paper showed benchmark results wherein <tt>initializer_list</tt>
versions of <tt>min</tt> appeared to outperform the corresponding variadic
template. Unfortunately, in October 2009 a very serious error was detected in
the benchmark. (<a href="http://listarchives.isocpp.org/cgi-bin/wg21/message?wg=lib&amp;msg=25210">c++std-lib-25210</a>).
In fact, an <tt>initializer_list&lt;T&gt;</tt> version of <tt>min</tt> often
appears to perform <i>worse</i> than the corresponding variadic template,
especially when <tt>T</tt> has an expensive copy constructor 
(<a href="http://listarchives.isocpp.org/cgi-bin/wg21/message?wg=lib&amp;msg=25253">c++std-lib-25253</a>,
<a href="http://www.xs4all.nl/~nd/dekkerware/issues/n2772_fix">http://www.xs4all.nl/~nd/dekkerware/issues/n2772_fix</a>).
</p>
<p>
IMO, the biggest problem of the <tt>initializer_list</tt> overloads is that they
pass and return <tt>T</tt> objects <i>by value</i>. Which has the following
consequences:
</p>

<ol>
<li>
They require that <tt>T</tt> is <tt>CopyConstructible</tt>. IMO that is too much of a
constraint for a generic, general purpose function like
<tt>std::min&lt;T&gt;</tt>.
</li>
<li>
They potentially throw an exception, even if <tt>T</tt>'s less-than-operator
throws nothing. (And of course, less-than typically throws nothing.)
</li>
<li>
They are inconsistent with C++03 <tt>std::min</tt> and <tt>std::max</tt>.
Consider the subtle difference between <tt>const T&amp; c1 = min(a,b);</tt> and
<tt>const T&amp; c2 = min({a,b});</tt> 
(<a href="http://listarchives.isocpp.org/cgi-bin/wg21/message?wg=lib&amp;msg=25265">c++std-lib-25265</a>)
</li>
<li>
They do not conveniently support use cases that need to have a reference to the
minimum or maximum object <i>itself</i>, rather than just a copy.
</li>
<li>
They potentially perform badly: possibly <i>O(n)</i>, when the arguments
themselves have a size of <i>n</i>.
</li>
</ol>

<p>
In the future, this problem might be solvable by using an
<tt>initializer_list</tt> of <i>const references</i>, instead:
</p>
<blockquote><pre>
const T&amp; min(initializer_list&lt;const T&amp;&gt;);
const T&amp; max(initializer_list&lt;const T&amp;&gt;);
pair&lt;const T&amp;, const T&amp;&gt; minmax(initializer_list&lt;const T&amp;&gt;);
</pre></blockquote>

<p>
It is unlikely that C++0x will support <tt>initializer_list&lt;const T&amp;&gt;</tt>, 
but technically it seems possible to add such a language
feature after C++0x 
(<a href="http://listarchives.isocpp.org/cgi-bin/wg21/message?wg=core&amp;msg=15428">c++std-core-15428</a>).
</p>
<p>
Variadic templates of <tt>min</tt>, <tt>max</tt>, and <tt>minmax</tt>, as
proposed by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2551.pdf">N2551</a>
(Sylvain Pion), do have some other advantages over <tt>initializer_list</tt>
overloads:
</p>
<ol>
<li>
It is likely that those variadic templates can be declared <tt>constexpr</tt>,
now that 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3006.html#991">
CWG issue #991</a> is in drafting status.
</li>
<li>
They provide complete compile-time protection against accidentally passing zero
arguments.
</li>
</ol>

<p>
Unfortunately, the variadic templates of <tt>min</tt>, <tt>max</tt>, and
<tt>minmax</tt> may still need further improvement, before having them in the
Standard Library. Especially the optional <tt>Compare</tt> parameter appears to
be a concern. So for this moment I recommend to keep both versions out of C++0x,
and postpone further discussion until after C++0x.
</p>

<p><i>[
2010 Pittsburgh:  Discussed and the LWG still prefers the initializer list
solution of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>.
]</i></p>




<p><b>Rationale:</b></p><p>
We prefer the solution of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>
which will be reapplied.
</p>

<p><b>Proposed resolution:</b></p>
<p>
Remove both variadic templates and <tt>initializer_list</tt> overloads of
<tt>min</tt>, <tt>max</tt>, and <tt>minmax</tt> from the synopsis in
27.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a> and from 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a>.
</p>

<blockquote>
<p><i>[
Note: This proposed resolution will resolve LWG <a href="915">915</a> as NAD.
]</i></p>

</blockquote>





<hr>
<h3><a name="1313" href="1313">1313.</a> Seed sequence's param function not useful for pure output iterator</h3>
<p><b>Section:</b> 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-02-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Seed sequence requirements (28.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a>) require the
existence of a member function
</p>

<blockquote><pre>
template&lt;typename OutputIterator&gt;
void param(OutputIterator ob);
</pre></blockquote>

<p>
The fact that this function returns <tt>void</tt> instead of the value of
<tt>ob</tt> after accepting the sequence data leads to the same problem as in
issue <a href="865">865</a> - In case of pure output iterators there is no way to
serialize further data into that data sink.
</p>

<p><i>[
2010-02-07 Howard adds:
]</i></p>


<blockquote><p>
At the time this issue was opened, the suggested changes are with respect to an
anticipated draft which does not yet exist.
</p></blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
No technical counterarguments, but it is simply too late in the process
to make this change at this point.
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In Table 109 &mdash; Seed sequence requirements, expression "<tt>r.param(ob)</tt>"
change the<br/>
Return type entry:
</p>

<blockquote><pre>
<del>void</del><ins>OutputIterator</ins>
</pre></blockquote>
</li>

<li>
<p>
In 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a>, class seed_seq synopsis change
</p>

<blockquote><pre>
template&lt;class OutputIterator&gt;
<del>void</del><ins>OutputIterator</ins> param(OutputIterator dest) const;
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="1314" href="1314">1314.</a> <tt>NULL</tt> and <tt>nullptr</tt></h3>
<p><b>Section:</b> 17.2 <a href="https://timsong-cpp.github.io/cppwp/support.types">[support.types]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2010-02-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the 17.2 <a href="https://timsong-cpp.github.io/cppwp/support.types">[support.types]</a>/3 allows <tt>NULL</tt> to be any
null pointer constant. The footnote marks that 0 or 0L might be appropriate.
However, this definition also allows the implementation to define <tt>NULL</tt>
to be <tt>nullptr</tt>. This may lead to overload and conversion issues more
serious than with the C++98 version:
</p>

<blockquote><pre>
void f(void*);
void f(int);

void g()
{
 // calls f(int) if NULL is integral
 // calls f(void*) if NULL is nullptr
 f(NULL);
}
</pre></blockquote>

<p>
Possible resolutions:
</p>
<ul>
<li>
Forbid <tt>NULL</tt> from being <tt>nullptr</tt>
</li>
<li>
Require <tt>NULL</tt> to be <tt>nullptr</tt>
</li>
<li>
Leave it as is
</li>
</ul>

<p>
Making <tt>NULL</tt> <tt>nullptr</tt> would improve code correctness, and
breaking backwards compatibility shouldn't be a huge concern as <tt>NULL</tt>
shouldn't be used except as a null pointer constant anyways.
</p>

<p><i>[
2010-02-10  Chris provided wording.
]</i></p>


<p><i>[
2010 Pittsburgh:  Moved to NAD, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
The LWG discussed the proposed resolution and several other options.  There was
no concensus to make this or any other changes.
</p>


<p><b>Proposed resolution:</b></p>
<p>
17.2 <a href="https://timsong-cpp.github.io/cppwp/support.types">[support.types]</a>
</p>

<blockquote>
<p>
3 The macro <tt>NULL</tt> <ins>is defined to be <tt>nullptr</tt>.</ins> <del>is
an implementation-defined C++ null pointer constant in this International
Standard (4.10).<sup>196</sup></del>
</p>

<p><del>
196) Possible definitions include <tt>0</tt> and <tt>0L</tt>, but not
<tt>(void*)0</tt>.
</del></p>
</blockquote>

<p>
20.2.12 <a href="https://timsong-cpp.github.io/cppwp/c.malloc">[c.malloc]</a>
</p>

<blockquote><p>
7 The contents are the same as the Standard C library header
<tt>&lt;string.h&gt;</tt>, with the change to <tt>memchr()</tt> specified in
21.6 <ins>and the macro <tt>NULL</tt> defined to be <tt>nullptr</tt></ins>.
</p></blockquote>


<p>
 [date.time]
</p>

<blockquote><p>
2 The contents are the same as the Standard C library header
<tt>&lt;time.h&gt;</tt><del>.</del><sup>232</sup> <ins>except the macro
<tt>NULL</tt>, which is defined to be <tt>nullptr</tt>.</ins> The functions
<tt>asctime</tt>, <tt>ctime</tt>, <tt>gmtime</tt>, and <tt>localtime</tt> are
not required to avoid data races (17.6.4.8).
</p></blockquote>


<p>
30.5 <a href="https://timsong-cpp.github.io/cppwp/c.locales">[c.locales]</a>
</p>

<blockquote><p>
2 The contents are the same as the Standard C library header
<tt>&lt;locale.h&gt;</tt> <ins>except the macro <tt>NULL</tt>, which is defined
to be <tt>nullptr</tt></ins>.
</p></blockquote>

<p>
C.7.3.7 <a href="https://timsong-cpp.github.io/cppwp/diff.null">[diff.null]</a>
</p>

<blockquote><p>
1 The macro <tt>NULL</tt>, defined in any of <tt>&lt;clocale&gt;</tt>,
<tt>&lt;cstddef&gt;</tt>, <tt>&lt;cstdio&gt;</tt>, <tt>&lt;cstdlib&gt;</tt>,
<tt>&lt;cstring&gt;</tt>, <tt>&lt;ctime&gt;</tt>, or <tt>&lt;cwchar&gt;</tt>, is
<ins>nullptr</ins> <del>an implementation-defined C++ null pointer constant in
this International Standard (18.2).</del>
</p></blockquote>






<hr>
<h3><a name="1315" href="1315">1315.</a> return type of <tt>async</tt></h3>
<p><b>Section:</b> 33.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-02-09 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both overloads of <tt>async</tt> return <tt>future&lt;typename
F::result_type&gt;</tt> which requires that <tt>F</tt> has a nested type. This
prevents <tt>async</tt> being used with function pointers and makes the example
in 33.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> invalid. I believe this is unintentional.
</p>

<p>
The proposed resolution also addresses editorial issues with the
<tt>launch_policy</tt> function parameter.
</p>

<p>
For the first overload it is not sufficient to return <tt>future&lt;typename
result_of&lt;F(ArgTypes...)&gt;::type&gt;</tt>.  Calling <tt>async(launch::xxx,
foo, bar)</tt> performs argument deduction on both <tt>async</tt> overloads,
which for the first overload attempts to instantiate <tt>result_of&lt;launch(F,
ArgTypes...)&gt;</tt>, which is invalid. SFINAE must be used to prevent that.
</p>

<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-12 Daniel opens:
]</i></p>


<blockquote>
<p>
[..] if <tt>decay&lt;F&gt;::type</tt> is of type <tt>std::launch</tt>.
</p>
<p>
or
</p>
<p>
[..] if <tt>remove_cv&lt;remove_reference&lt;F&gt;::type&gt;::type</tt> is of
type <tt>std::launch</tt>.
</p>

<p>
The latter is the more specific form, but the former is equivalent to
the latter for all cases that can occur here. I suggest to use the
former for simplicity, but expect that implementations can effectively
use the latter.

</p>
</blockquote>

<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Editorial.  Rationale added below.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3058.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 33.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.overview">[futures.overview]</a> paragraph 1:
</p>

<blockquote><pre>
template &lt;class F, class... Args&gt;
  <del>future&lt;typename F::result_type&gt;</del>
  <ins>future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;</ins>
  async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args&gt;
  <del>future&lt;typename F::result_type&gt;</del>
  <ins>future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;</ins>
  async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</pre></blockquote>

<p>
In 33.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> before paragraph 1
</p>

<blockquote><pre>
template &lt;class F, class... Args&gt;
  <del>future&lt;typename F::result_type&gt;</del>
  <ins>future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;</ins>
  async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args&gt;
  <del>future&lt;typename F::result_type&gt;</del>
  <ins>future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;</ins>
  async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>...</p>
<p><ins>
<i>Remarks:</i> The first signature shall not participate in overload resolution
if <tt>decay&lt;F&gt;::type</tt> is <tt>std::launch</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1317" href="1317">1317.</a> make_hash</h3>
<p><b>Section:</b> 22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nicolai M. Josuttis <b>Opened:</b> 2010-02-10 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the library lacks a convenient way to provide a hash function that
can be used with the provided unordered containers to allow the usage of non
trivial element types.
</p>

<p>
While we can easily declare an
</p>

<blockquote><pre>
std::unordered_set&lt;int&gt;
</pre></blockquote>

<p>
or
</p>

<blockquote><pre>
std::unordered_set&lt;std::string&gt;
</pre></blockquote>

<p>
we have no easy way to declare an <tt>unordered_set</tt> for a user defined
type. IMO, this is a big obstacle to use unordered containers in practice. Note
that in Java, the wide usage of <tt>HashMap</tt> is based on the fact that there
is always a default hash function provided.
</p>

<p>
Of course, a default hash function implies the risk to provide poor hash
functions. But often even poor hash functions are good enough.
</p>

<p>
While I really would like to see a default hash function, I don't propose it
here because this would probably introduce a discussion that's too big for this
state of C++0x.
</p>

<p>
However, I strongly suggest at least to provide a convenience variadic template
function <tt>make_hash&lt;&gt;()</tt> to allow an easy definition of a (possibly
poor) hash function.
</p>

<p>
As a consequence for a user-defined type such as
</p>

<blockquote><pre>
class Customer {
   friend class CustomerHash;
   private:
     string firstname;
     string lastname;
     long   no;
   ...
 };
</pre></blockquote>

<p>
would allow to specify:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return make_hash(c.firstname,c.lastname,c.no);
    }
};
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return std::hash&lt;std::string&gt;()(c.firstname) +
              std::hash&lt;std::string&gt;()(c.lastname) +
              std::hash&lt;long&gt;()(c.no);
    }
};
</pre></blockquote>

<p>
Note that, in principle, we can either specify that
</p>

<blockquote><p>
<tt>make_hash</tt> returns the sum of a call of
<tt>std::hash&lt;T&gt;()(x)</tt> for each argument <tt>x</tt> of type
<tt>T</tt>
</p></blockquote>

<p>
or we can specify that
</p>

<blockquote><p>
<tt>make_hash</tt> provides a hash value for each argument, for which a
<tt>std::hash()</tt> function is provided
</p></blockquote>

<p>
with the possible note that the hash value may be poor or only a good hash value
if the ranges of all passed arguments is equally distributed.
</p>

<p>
For my convenience, I propose wording that describes
the concrete implementation.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial, rationale added below.
]</i></p>


<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Feature? Needs a paper. (This is <a href="https://wg21.link/LEWG21">LEWG21</a>)</p>



<p><b>Rationale:</b></p>
<p>
There is no consensus to make this change at this time.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Function objects 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>
in paragraph 2 at the end of the Header <tt>&lt;functional&gt;</tt> synopsis
insert:
</p>

<blockquote><pre>
// convenience functions
template &lt;class T&gt;
  size_t make_hash (const T&amp;);
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp;, const Types&amp;...);
</pre></blockquote>

<p>
In Class template hash 22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>
add:
</p>

<blockquote>
<p>
<b>20.7.16.1 Hash creation functions [hash.creation]</b>
</p>

<pre>
template &lt;class T&gt;
  size_t make_hash (const T&amp; val);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val);</tt>
</p></blockquote>

<pre>
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp; val, const Types&amp;... args);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val) + std::make_hash(args...)</tt>
</p></blockquote>

</blockquote>






<hr>
<h3><a name="1318" href="1318">1318.</a> N2982 removes previous allocator capabilities</h3>
<p><b>Section:</b> 20.2.9.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.types">[allocator.traits.types]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2010-02-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.traits.types">issues</a> in [allocator.traits.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="1375">1375</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-87</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>
says that containers should have a nested typedef that defines their
<tt>reference_type</tt> as <tt>value_type&amp;</tt>; the previous
standard deferred to the allocator to define its
<tt>reference_type</tt>, and containers simply passed the allocator's
typedef on. This change is a mistake. Allocators should define both a
<tt>pointer</tt> type and a <tt>reference</tt> type. That's essential
for their original purpose, which was to make different memory models
transparent. If an allocator defines a <tt>pointer</tt> type that isn't
compatible with a normal pointer it also has to define a corresponding
<tt>reference</tt> type. For example (and please forgive a Windows-ism),
if an allocator's pointer is <tt>T __far*</tt>, then it's
<tt>reference</tt> has to be <tt>T __far&amp;</tt>. Otherwise everything
crashes (under the hood, references are pointers and have to have the
same memory access mechanics). Extensions such as this for more general
memory models were explicitly encouraged by C++03, and the allocator's
<tt>pointer</tt> and <tt>reference</tt> typedefs were the hooks for such
extensions. Removing the allocator's <tt>reference</tt> and
<tt>const_reference</tt> typedefs makes those extensions unimplementable
and breaks existing implementations that rely on those hooks.
</p>

<p><i>[
2010-02-25 Alisdair adds:
]</i></p>


<blockquote>
<p>
<tt>vector&lt;bool&gt;::reference</tt> is a nested class, and not a typedef.  It
should be removed from the list of containers when this change is made.
</p>

<p>
In general, I am uncomfortable placing this reference requirement on each
container, as I would prefer to require:
</p>

<blockquote><pre>
is_same&lt;Container::reference, Container::iterator::reference&gt;
</pre></blockquote>

<p>
This distinction is important, if we intend to support proxy iterators.  The
iterator paper in the pre-Pittsburgh mailing
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3046.html">N3046</a>)
does <em>not</em> make this proposal, but organises clause 24 in such a way this
will be much easier to specify.
</p>

<p>
The changes to clause 20 remain important for all the reasons Pete highlights.
</p>
</blockquote>

<p><i>[
2010 Batavia
]</i></p>


<p>
Removed <tt>vector</tt> from list of templates that should be adjusted as of meeting outcome.
</p>

<p><i>[
2010 post-Batavia
]</i></p>


<p>
Replaced <tt>vector&lt;bool&gt;</tt> reference by <tt>vector</tt> reference because of misinterpreting meeting typo.
Additional corrected numbering in P/R to N3225 wording.
</p>

<p><i>[
2010-12-06 Daniel reopens
]</i></p>


<p>
Unfortunately, the current P/R is defective for several reasons:
</p>
<ol>
<li> Table 43 &mdash; Descriptive variable definitions still contains three
references to <tt>T&amp;</tt>, namely in:
<blockquote>
<table border="1">
<tr>
<td>
<tt>t</tt>
</td>
<td>a value of type <tt>const T&amp;</tt></td>
</tr>
<tr>
<td>
<tt>r</tt>
</td>
<td>a value of type <tt>T&amp;</tt> obtained by the expression <tt>*p</tt></td>
</tr>
<tr>
<td>
<tt>s</tt>
</td>
<td>a value of type <tt>const T&amp;</tt> obtained by the expression <tt>*q</tt>
or by conversion from a value <tt>r</tt></td>
</tr>
</table>
</blockquote>
Especially the second and third items are misses in the 1318 P/R,
e.g. in N2723 or in C++03 these were referring
to <tt>X::reference</tt> and <tt>X::const_reference</tt>, resp.
None of them is referenced anywhere in the allocator requirements
table: <tt>r</tt> and <tt>s</tt> where historically needed to
define the expressions <tt>a.address(r)</tt> and <tt>a.address(s)</tt> which are gone now,
and <tt>t</tt> was needed to define the expression <tt>a.construct(p, t)</tt> which has been
replaced by <tt>a.construct(p,args)</tt>.
<p/>
The easiest fix seems to be to remove all three rows from Table 43.
</li>
<li>
Further-on, the current P/R suggests to replace the the current
definitions of the adaptor classes
<blockquote><pre>
stack
priority_queue
queue
</pre></blockquote>
similar to the other container types, i.e. to define <tt>reference</tt> and
<tt>const_reference</tt> now as
<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::reference reference;
typedef typename allocator_traits&lt;Allocator&gt;::const_reference const_reference;
</pre></blockquote>
This would not only be an ill-formed definition (because there is no name
<tt>Allocator</tt> in scope), but it would also introduce a breakage compared to C++03,
where these definitions where already referring to the definition of the wrapped 
containers. So, the adaptor class templates should be removed from the current list.
</li>
<li>
Then the current P/R wording leads to one further unexpected and unwanted change due to 
the general formular used: <tt>match_result::reference</tt> is currently defined as
<blockquote><pre>
typedef const_reference reference;
</pre></blockquote>
because it is an <em>immutable</em> container (And we had this definition
already in N2723). The application of the rule would change this silently.
</li>
<li>
Finally the suggested wording for the <tt>unordered_</tt> containers is incomplete.
The reason is a current inconsistency between these containers and the rest: While
normally the definition of the pointer types is
<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::pointer pointer;
typedef typename allocator_traits&lt;Allocator&gt;::const_pointer const_pointer;
</pre></blockquote>
for the unordered containers they are
<blockquote><pre>
typedef typename allocator_type::pointer pointer;
typedef typename allocator_type::const_pointer const_pointer;
</pre></blockquote>
These definitions are <em>not</em> equivalent, because allocators are no longer
required to define typedefs <tt>pointer</tt> and <tt>const_pointer</tt>, the
<tt>allocator_traits</tt> were invented as a further indirection to cope
with that. I.e. for the unordered containers we need to bring both the definition
of references <em>and</em> pointers in sync.
</li>
</ol>

<p><i>[
2011-02-23 Daniel updates the proposed wording with support from Pablo
]</i></p>


<p>The update attempts to fix the backward-compatibility problem that we have
introduced by ignoring the C++03 member function overloads <tt>address</tt>
of allocator types in C++0x completely. The resolution attempts to fix that
by adding these functions as optional members of allocators that are considered
first before falling back to <tt>pointer_traits::pointer_to</tt>. This still
allows us to remove the unused symbol <tt>t</tt> from the table, but we adapt
the symbols <tt>r</tt> and <tt>s</tt> to purely refer to the typenames
<tt>reference</tt> and <tt>const_reference</tt>.</p>

<p><i>[2011-03-06 Daniel adapts numbering to N3242]</i></p>


<p><i>[2011-03-11 Daniel removes <tt>noexcept</tt> specifiers from <tt>address</tt> functions]</i></p>


<p><i>[2011-03-12 Further wording improvements by Daniel and Pablo]</i></p>


<p><i>[2011-03-22 Madrid]</i></p>


<p>Closed as NAD, no consensus to make a change</p>



<p><b>Rationale:</b></p><p>No consensus to make a change</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1320" href="1320">1320.</a> Header for <tt>iter_swap</tt></h3>
<p><b>Section:</b> 25.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2017-06-05 20:39:07 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.synopsis">active issues</a> in [iterator.synopsis].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in [iterator.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>iter_swap</tt> function template appears in the
<tt>&lt;algorithm&gt;</tt> header, yet its main use is in building further
algorithms, not calling existing ones. The main clients are implementers of data
structures and their iterators, so it seems most appropriate to place the
template in the <tt>&lt;iterator&gt;</tt> header instead.
</p>

<p>
Note that this is not an issue for implementers of the standard library, as they
rarely use the standard headers directly, designing a more fine-grained set of
headers for their own internal use.  This option is not available to customers
of the standard library.
</p>

<p>
Note that we cannot remove <tt>iter_swap</tt> from <tt>&lt;algorithm&gt;</tt>
without breaking code, but there is no reason we cannot offer the same
declaration via two standard headers.  Alternatively, require
<tt>&lt;algorithm&gt;</tt> to <tt>#include &lt;iterator&gt;</tt>, but
introducing the dependency on the iterator adaptors seems un-necessary.
</p>

<p><i>[
]</i></p>


<p>
Discussed possibly moving to <tt>&lt;utility&gt;</tt> but don't like that. Some not seeing this 
as a defect, and want to keep it in <tt>&lt;algorithm&gt;</tt>. No one seems to feel strongly 
about moving to <tt>&lt;iterator&gt;</tt>.
</p>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>


<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the declaration of <tt>iter_swap</tt> to the <tt>&lt;iterator&gt;</tt>
header synopsis (25.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>), with a note that it is
documented in clause 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>.
</p>

<blockquote><pre>
...
template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);

<ins><i>// documented in 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a></i>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</ins>
</pre></blockquote>






<hr>
<h3><a name="1330" href="1330">1330.</a> Move container requirements into requirements tables</h3>
<p><b>Section:</b> 24.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-03-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Abstract:
</p>
<p>
In general, it seems that in a couple of places container behavior is
not described in requirement tables although it is a general behavior.
</p>

<p>
History:
</p>

<p>
Issue <a href="676">676</a> added move semantics to unordered containers.
For the added insert functions the Editor requested to put their
semantic description into a requirements table rather than describing
them for each container individually. The text however was taken from
the associative containers, where we also have the semantics for each
container described. Also, <a href="1034">1034</a> is to some extend
requesting a clarification of the requirement tables and it turned out
that in other places we have the same problem (e.g. we have no general
requirement for type pointer and const_pointer although each container
has them with issue <a href="1306">1306</a>).
</p>

<p>
From my personal list of functions in requirement tables
and containers, the following types/functions are missing in
requirement tables:
</p>

<ul>
<li>
<tt>pointer</tt>, <tt>const_pointer</tt> in Table 91 (container requirements)
</li>
<li>
<p>
all copy constructors, copy constructors with allocator,
 assignment operators, and insert operators
 with move semantics for associative and unordered containers
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;)
ContType c1(c2&amp;&amp;,alloc)
c1 = c2&amp;&amp;
c.insert(val&amp;&amp;)
c.insert(pos,val&amp;&amp;)
</pre></blockquote>
</li>
</ul>

<p>
As a special case, we lack the following requirements for all sequence
containers BUT array (so special wording or a new container category is
required):
</p>

<ul>
<li>
<p>
constructor with only a size argument
</p>
<blockquote><pre>
ContType c(num)
</pre></blockquote>
</li>
<li>
<p>
copy constructor with allocator and move semantics
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;,alloc)
</pre></blockquote>
</li>
<li>
<p>
all constructors that insert multiple elements with additional allocator
</p>
<blockquote><pre>
ContType c(num, val,alloc)
ContType c(beg, end,alloc)
ContType c(initlist,alloc)
</pre></blockquote>
</li>
<li>
<p>
all resize functiuons:
</p>
<blockquote><pre>
c.resize(num)
c.resize(num,val)
</pre></blockquote>
</li>
</ul>

<p>
Note that we also might have to add additional requirements on other
places for sequence containers because having an allocator requires
additional statements for the treatment of the allocators. E.g. swap for
containers with allocators is not specified in any requirement table.
</p>

<p>
And finally, if we have the requirements in the requirements tables, we
can remove the corresponding descriptions for the individual container.
However, note that sequence container requirements have NO complexity
column, so that we still need container specific descriptions for the
functions listed there.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
While there is consensus that further cleaning up the container requirement
tables would be a good thing, there is no feeling that this <em>must</em>
be done in time for 0x.  The issue remains open, but Deferred.
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Closes as NAD. There are a number of deficiencies in the way the container
requirements tables are presented, and the LWG welcomes further papers that
will help clear up this presentation.
</p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1331" href="1331">1331.</a> incorporate move special member functions into library</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2010-03-10 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Review the library portion of the spec and incorporate the newly added
core feature Move Special Member Functions (N3044).
</p>

<p><b>Rationale:</b></p><p>
2010 Batavia: This has now been done to a large extent.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1348" href="1348">1348.</a> Exception safety of unspecified types</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-64</b></p>
<p>
There are a number of unspecified types used throughout
the library, such as the container iterators. Many of these
unspecified types have restrictions or expectations on
their behaviour in terms of exceptions. Are they permitted
or required to use exception specifications, more
specifically the new <tt>noexcept</tt> specification? For example,
if <tt>vector&lt;T>::iterator</tt> is implemented as a native pointer,
all its operations will have an (effective) <tt>noexcept</tt>
specification. If the implementation uses a class type to
implement this iterator, is it permitted or required to
support that same guarantee?
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Clearly state the requirements for exception
specifications on all unspecified library types. For
example, all container iterator operations should
be conditionally <tt>noexcept</tt>, with the condition
matching the same operation applied to the
allocator's <tt>pointer_type</tt>, a certain subset of which
are already required not to throw.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Discussion:</p>
<p>Alisdair: Probably an NAD Future at least but could be NAD.
<p/>
Daniel K: Approach is not consistent with what we've decided with <tt>noexcept</tt>.
<p/>
Alisdair: Any objection to marking 1348 as NAD?
<p/>
No objections. 
</p>



<p><b>Rationale:</b></p><p>Standard is correct as written</p>
<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1350" href="1350">1350.</a> Implicit contructors accidentally made some library types move-only</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1421">1421</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-15</b></p>
<p>
Due to the new rules about implicit copy and move
constructors some library facilities are now move-only.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Make them copyable again.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1351" href="1351">1351.</a> Replace dynamic exception specifications with <tt>noexcept</tt></h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1344">1344</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses CH-16</b></p>
<p>
Dynamic exception specifications are deprecated.
Deprecated features shouldn't be used in the Standard.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Replace dynamic exception specifications with <tt>noexcept</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1352" href="1352">1352.</a> Apply <tt>noexcept</tt> where library specification says "Throws: Nothing"</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1346">1346</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses CH-17</b></p>
<p>
The introduction of <tt>noexcept</tt> makes "Throws: Nothing" clauses looking strange.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Consider replacing "Throws: Nothing." clause by
the respective noexcept specification.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1358" href="1358">1358.</a> Add <tt>&lt;chrono&gt;</tt> and <tt>&lt;ratio&gt;</tt> to
freestanding implementations</h3>
<p><b>Section:</b> 16.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-55</b></p>
<p>
The <tt>&lt;thread&gt;</tt> header uses <tt>duration</tt> types, found in the
<tt>&lt;chrono&gt;</tt> header, and which rely on the <tt>ratio</tt> types
declared in the <tt>&lt;ratio></tt> header.
</p>

<p><i>[
Extracts from lengthy Rapperswil discussion:
]</i></p>

<p>
There is a concern that this issue is a misunderstanding of the actual
requirements of a free-standing implementation to support the <tt>&lt;thread></tt>
header.  In general, a free-standanding implementation will provide an <em>empty</em>
header, specifically so that a user can test for the absence of the 
<tt>_ _ STDCPP_THREADS _ _</tt> macro.  This idiom as used as there is no portable 
way to test for the lack of a header.
</p>
<p>
At this point, it was suggested the NB comment is trying to solve the wrong problem, 
and that <tt>_ _ STDCPP_THREADS _ _</tt> should be a pre-defined macro in clause 16 
that can be tested before including <tt>&lt;thread&gt;</tt>.  That would remove the 
need to add additional headers to the free-standanding requirements.
</p>
<p>
It is worth noting that Japan requested <tt>&lt;ratio&gt;</tt> as a free-standing header 
in their CD1 comments.  No-one seemed keen to require clocks of a free-standing 
implementation though.
</p>

<p>Detlef volunteers to look at a way to redraft 17.6.1.3 p3.</p> 

<p><i>[
Original resolution proposed by NB comment:
]</i></p>


<blockquote>
<p>
Add the <tt>&lt;chrono&gt;</tt> and <tt>&lt;ratio&gt;</tt> headers to the
freestanding requirements.
</p>
<p>
It might be necessary to address scaled-down
expectations of clock support in a freestanding
environment, much like <tt>&lt;thread&gt;</tt>.
</p>
</blockquote>

<p><i>[2011-02-25: Alberto drafts wording]</i></p>


<p><i>[2011-03-06: Daniel observes:]</i></p>


<p>Accepting the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3256.html">n3256</a> 
would solve this issue.</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Freestanding no longer requires <tt>&lt;thread&gt;</tt> header</p>


<p><b>Rationale:</b></p><p>We are not adding new headers to freestanding at this point.</p>

<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Add a new entry in Table 14 &mdash; C++ library headers:</p>

<blockquote>
<table border="1">
<caption>Table 14 &mdash; C++ library headers</caption>
<tr>
<td style="text-align:center;">&hellip;</td>
</tr>
<tr>
<td><tt>&lt;iterator&gt;</tt></td>
</tr>
<tr>
<td><ins><tt>&lt;library_support&gt;</tt></ins></td>
</tr>
<tr>
<td><tt>&lt;limits&gt;</tt></td>
</tr>
<tr>
<td style="text-align:center;">&hellip;</td>
</tr>
</table>
</blockquote>  
</li>

<li><p>Remove the last row 33.4 <a href="https://timsong-cpp.github.io/cppwp/thread.threads">[thread.threads]</a> <tt>&lt;threads&gt;</tt>
from Table 16 &mdash; C++ headers for freestanding implementations and insert
a new one instead (To the editor: For the actual target Clause please see the comment
in bullet 5 of this proposed resolution):</p>

<blockquote>
<table border="1">
<caption>Table 16 &mdash; C++ headers for freestanding implementations</caption>

<tr>
<th>Subclause</th>
<th>Header(s)</th>
</tr>

<tr>
<td colspan="2" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><del>33.4 <a href="https://timsong-cpp.github.io/cppwp/thread.threads">[thread.threads]</a> Threads</del></td>
<td><del><tt>&lt;thread&gt;</tt></del></td>
</tr>

<tr>
<td><ins>?? Library support</ins></td>
<td><ins><tt>&lt;library_support&gt;</tt></ins></td>
</tr>

</table>

</blockquote>
 </li>
 
 <li><p>Modify paragraph 16.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a> p. 3:</p>
 <blockquote><p>
 3 The supplied version of the header <tt>&lt;cstdlib&gt;</tt> shall declare at least the functions 
 <tt>abort</tt>, <tt>atexit</tt>, <tt>at_quick_exit</tt>, <tt>exit</tt>, and <tt>quick_exit</tt> 
 (18.5). <del>The supplied version of the header <tt>&lt;thread&gt;</tt> shall meet the
same requirements as for a hosted implementation or including it shall have no effect</del>. The 
other headers listed in this table shall meet the same requirements as for a hosted 
implementation. <ins>A program can detect the presence of standard headers not listed in Table
16 using the facilities provided by the <tt>&lt;library_support&gt;</tt> header.</ins>
</p></blockquote>
</li>
 
<li><p>Remove the following line from the header <tt>&lt;thread&gt;</tt> synopsis in 
33.4 <a href="https://timsong-cpp.github.io/cppwp/thread.threads">[thread.threads]</a> p. 1:</p>
<blockquote><pre>
namespace std {
  <del>#define __STDCPP_THREADS__ __cplusplus</del>

  class thread;
  [...]
}
</pre></blockquote>
</li>

<li><p>Add a new section in Clause 18 or 20 (or any other suitable place at
the editor's discretion):</p>

<blockquote>
<p><ins>?? Library support [library.support]</ins></p>
<blockquote><p>
<ins>The header <tt>&lt;library_support&gt;</tt> defines an implementation-defined set 
of macros to allow a program detect the presence of standard headers in freestanding
implementations. [<i>Note</i>: Hosted implementations shall provide all
standard headers, thus shall provide all macros. &mdash; <i>end note</i>]</ins>
</p></blockquote>
<blockquote><p>
<ins>For each standard header listed in Tables 14 (C++ library headers) and 15 (C++ headers for C library facilities)
that is provided by the implementation, <tt>&lt;library_support&gt;</tt> shall define a macro with name 
<code>_ _HAS_<i>XXX</i>_HEADER_ _</code> where <code><i>XXX</i></code> is replaced by the uppercase version of the 
name of the header. Each such macro shall expand to the value <code>_ _cplusplus</code>.
[<i>Example</i>:</ins></p>
<blockquote><pre>
<ins>#include &lt;library_support&gt;

#ifdef _ _HAS_THREADS_HEADER_ _
  #include &lt;threads&gt;
  // code that exploit the presence of threads
#else
  // fallback code that doesn't rely on threads
#endif</ins>
</pre></blockquote>
<p><ins>&mdash; <i>end example</i>]</ins></p>
</blockquote>
<blockquote><p>
<ins>No other standard header shall define macros with a name beginning with <code>_ _HAS_</code>
and ending with <code>_HEADER_ _</code>.</ins>
</p></blockquote>

</blockquote>
</li>
</ol>





<hr>
<h3><a name="1359" href="1359">1359.</a> Add <tt>&lt;tuple&gt;</tt> and <tt>&lt;utility&gt;</tt> to freestanding implementations</h3>
<p><b>Section:</b> 16.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-56</b></p>
<p>
The <tt>&lt;utility&gt;</tt> header provides support for several
important C++ idioms with <tt>move</tt>, <tt>forward</tt> and <tt>swap</tt>.
Likewise, <tt>declval</tt> will be frequently used like a type trait.
In order to complete cycles introduced by <tt>std::pair</tt>, the
<tt>&lt;tuple&gt;</tt> header should also be made available. This is a
similarly primitive set of functionality, with no dependency
of a hosted environment, but does go beyond the minimal
set of functionality otherwise suggested by the
freestanding libraries.
</p>
<p>
Alternatively, split the <tt>move</tt>/<tt>forward</tt>/<tt>swap</tt>/<tt>declval</tt>
functions out of <tt>&lt;utility&gt;</tt> and into a new primitive header,
requiring only that of freestanding implementation.
</p>

<p><i>[
Summary of Rapperswil discusions
]</i></p>

<p>
The preference of the meeting was to extract the rvalue-reference related utilities 
and swap into a freestanding header, but there was no clear preference for a name.  
Howard suggested simply dropping them into <tt>&lt;type_traits&gt;</tt> as both 
these utilities and type traits are used pretty much everywhere in the library 
implementation, it is the most convenient place to keep them (from an implementer's 
perspective).
</p>

<p>
Poll: Two-way: New header for forward, move, swap, move_with_noexcept and declval vs. 
calling out forward, move, swap, move_with_noexcept and declval as freestanding explicitly?

SF new header: 4 WF new header: 3 WF call out as freestanding: 1 SF call out as freestanding: 2

Alisdair: Willing to write up both solutions, give us some time to think on it.

Action: Need an issue and proposed wording for GB 56 - Alisdair to draft both options as in the last poll. 
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<blockquote>
<p>
Add <tt>&lt;utility&gt;</tt> and <tt>&lt;tuple&gt;</tt> to table 15, headers
required for a free-standing implementation.
</p>
</blockquote>

<p><i>[
2010-Batavia:
]</i></p>

<p>
Closed as NAD, reversing the decision at Rapperswil.
</p>
<p>
The consensus was that
any freestanding implementation is going to feel compelled to offer the important
features of <tt>&lt;utility></tt> even if we do not make them a freestanding
requirement; breaking out additional small headers may have additional costs at
compile time, and while the critical <tt>move</tt>-related functions could migrate
to <tt>&lt;type_traits></tt>, the header name is far from appealing; adding the
whole of <tt>&lt;utility></tt> starts to drag in dependencies on <tt>&lt;tuple></tt>
and <tt>&lt;memory></tt>, so we prefer to place the burden of slicing or supporting
this whole header on free-standing vendors.
</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p><p>No consensus for a change at this time.</p>




<hr>
<h3><a name="1361" href="1361">1361.</a> Does use of <tt>std::size_t</tt> in a header imply that typedef name is available to users?</h3>
<p><b>Section:</b> 16.4.3 <a href="https://timsong-cpp.github.io/cppwp/using">[using]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-58</b></p>
<p>
It is not clear whether a library header specified in terms
of a typedef name makes that same typedef name
available for use, or if it simply requires that the specified
type is an alias of the same type, and so the typedef name
cannot be used without including the specific header that
defines it. For example, is the following code required to
be accepted:
</p>
<blockquote><pre>
#include &lt;vector&gt;
std::size_t x = 0;
</pre></blockquote>
<p>
Most often, this question concerns the typedefs defined in
header <tt>&lt;cstddef&gt;</tt>
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a paragraph under 16.4.3 <a href="https://timsong-cpp.github.io/cppwp/using">[using]</a> clarifying whether
or not headers specified in terms of <tt>std::size_t</tt> can
be used to access the typedef <tt>size_t</tt>, or whether
the header <tt>&lt;cstddef&gt;</tt> must be included to reliably
use this name.
</p>
<p><i>[Batavia: NAD - see rationale below]</i></p>




<p><b>Proposed resolution:</b></p>

<p><b>Rationale:</b></p><p>The standard is correct as written.</p>




<hr>
<h3><a name="1369" href="1369">1369.</a> <tt>rethrow_exception</tt> may introduce data races</h3>
<p><b>Section:</b> 17.10.7 <a href="https://timsong-cpp.github.io/cppwp/propagation">[propagation]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-74</b></p>
<p>
One idea for the <tt>exception_ptr</tt> type was that a reference-counted
implementation could simply 'reactivate' the same
exception object in the context of a call to
<tt>rethrow_exception</tt>. Such an implementation would allow
the same exception object to be active in multiple threads
(such as when multiple threads join on a <tt>shared_future</tt>)
and introduce potential data races in any exception
handler that catches exceptions by reference - notably
existing library code written before this capability was
added. <tt>rethrow_exception</tt> should <em>always</em> make a copy
of the target exception object.
</p>

<p><i>[Resolution suggested by NB comment]</i></p>


<p>
Add the following to 18.8.5, [propogation]
</p>
<blockquote><p><ins>
<i>Throws</i>: a copy of the exception object to which <tt>p</tt> refers.
</ins></p></blockquote>

<p><i>[2011-03-15: Anthony drafts wording]</i></p>


<p><i>[2011-03-23 Madrid meeting]</i></p>


<p>No consensus for a change</p>



<p><b>Rationale:</b></p><p>It would break too many existing implementations</p>

<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Alter 14.2 <a href="https://timsong-cpp.github.io/cppwp/except.throw">[except.throw]</a> p. 5 as follows:</p>

<blockquote><p>
5 When the thrown object is a class object, the copy/move constructor and the destructor shall be accessible,
even if the copy/move operation is elided ( [class.copy]). <ins>The copy constructor shall be
accessible, and is odr-used (6.3 <a href="https://timsong-cpp.github.io/cppwp/basic.def.odr">[basic.def.odr]</a>), even if the copy operation is elided, 
or a move constructor used to construct the exception object.</ins>
</p></blockquote>
</li>

<li><p>Alter 17.10.7 <a href="https://timsong-cpp.github.io/cppwp/propagation">[propagation]</a> p. 7 as follows:</p>

<blockquote><pre>
exception_ptr current_exception() noexcept;
</pre><blockquote>
<p>
7 <i>Returns</i>: An <tt>exception_ptr</tt> object that refers to <del>the currently handled exception 
(14.4 <a href="https://timsong-cpp.github.io/cppwp/except.handle">[except.handle]</a>) or</del> a copy of the currently handled exception, or a null <tt>exception_ptr</tt> 
object if no exception is being handled. The referenced object shall remain valid at least as long as there 
is an <tt>exception_ptr</tt> object that refers to it. If the function needs to allocate memory and the 
attempt fails, it returns an <tt>exception_ptr</tt> object that refers to an instance of <tt>bad_alloc</tt>. 
It is unspecified whether the return values of two successive calls to <tt>current_exception</tt> refer to 
the same exception object. [ <i>Note</i>: That is, it is unspecified whether <tt>current_exception</tt> 
creates a new copy each time it is called. &mdash; <i>end note</i> ] If the attempt to copy the current 
exception object throws an exception,<ins> or is otherwise not possible,</ins> the function returns an 
<tt>exception_ptr</tt> object that refers to the thrown exception <ins>if any</ins> or, <del>if this is not possible,</del> 
to an instance of <tt>bad_exception</tt>. [ <i>Note</i>: The copy constructor of the thrown exception 
may also fail, so the implementation is allowed to substitute a <tt>bad_exception</tt> object to avoid 
infinite recursion. &mdash; <i>end note</i> ]
</p>
</blockquote></blockquote>
</li>

<li><p>Alter 17.10.7 <a href="https://timsong-cpp.github.io/cppwp/propagation">[propagation]</a> p. 9 and add a new paragraph after p. 9 as follows:</p>

<blockquote><pre>
[[noreturn]] void rethrow_exception(exception_ptr p);
</pre><blockquote>
<p>
8 <i>Requires</i>: <tt>p</tt> shall not be a null pointer.
<p/>
9 <i>Throws</i>: <ins>a copy of</ins> the exception object to which <tt>p</tt> refers<ins>, or any exception 
thrown by the attempt to copy the exception object to which <tt>p</tt> refers</ins>.
<p/>
<ins>? <i>Synchronization</i>: Calls to <tt>rethrow_exception</tt> on <tt>exception_ptr</tt> objects
that refer to the same exception object shall appear to occur in a single total order. The completion 
of each call shall synchronize with (6.9.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>) the next call in that total order.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="1371" href="1371">1371.</a> Standard exceptions require stronger no-throw guarantees</h3>
<p><b>Section:</b> 19 <a href="https://timsong-cpp.github.io/cppwp/diagnostics">[diagnostics]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-75</b></p>
<p>
None of the exception types defined in clause 19 are
allowed to throw an exception on copy or move
operations, but there is no clear specification that the
operations have an exception specification to prove it.
Note that the implicitly declared constructors, taking the
exception specification from their base class (ultimately
<tt>std::exception</tt>) will implicitly generate a <tt>noexcept</tt>
exception specification if all of their data members
similarly declare <tt>noexcept</tt> operations. As the
representation is unspecified, we cannot assume nonthrowing
operations unless we explicitly state this as a
constraint on the implementation.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a global guarantee that all exception types
defined in clause 19 that rely on implicitly declared
operations have a non-throwing exception
specification on those operations.
</p>

<p><i>[
2010 Batavia:
]</i></p>

<p>
This is addressed by the current words in 18.8.1 [exception], p2
</p>
<blockquote><p>
Each standard library class <tt>T</tt> that derives from class <tt>exception</tt> 
shall have a publicly accessible copy constructor and a publicly accessible copy
assignment operator that do not exit with an exception.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1373" href="1373">1373.</a> Customizable traits should have their own headers</h3>
<p><b>Section:</b> 22.2 <a href="https://timsong-cpp.github.io/cppwp/utility">[utility]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-79</b></p>
<p>
The library provides several traits mechanisms intended a
customization points for users. Typically, they are
declared in headers that are growing quite large. This is
not a problem for standard library vendors, who can
manage their internal file structure to avoid large
dependencies, but can be a problem for end users who
have no option but to include these large headers.
</p>

<p><i>[
2010 Rapperswil
]</i></p>

<p>
There was no enthusiasm for touching <tt>char_traits</tt> or <tt>regex_traits</tt>.
Consensus to move <tt>iterator_traits</tt>, <tt>allocator_traits</tt>
and <tt>pointer_traits</tt> to their own respective headers once wording supplied.
</p>

<p><i>[
2010 Rapperswil
]</i></p>

<p>
After some discussion, consensus is that moving these features into separate
headers does not buy much in practice, as the larger headers will inevitably
be included anyway.  Resolve as NAD.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Move the following traits classes into their own
headers, and require the existing header to
<tt>#include</tt> the traits header to support backwards
compatibility:
</p>
<blockquote><pre>
iterator_traits (plus the iterator tag-types)
allocator_traits
pointer_traits
char_traits
regex_traits
</pre></blockquote>

<p><i>[
2010 Batavia:
]</i></p>

<p>
Closed as NAD with the rationale below.
</p>



<p><b>Rationale:</b></p><p>
This suggest is not a defect, as the likely benefit is small, if any,
compared to the cost of not just implementating the feature, but also
explaining/teaching it.
</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1374" href="1374">1374.</a> Clarify moved-from objects are &quot;toxic&quot;</h3>
<p><b>Section:</b> 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-85</b></p>
<p>
20.2.1 Table 34 "MoveConstructible requirements" says
"Note: rv remains a valid object. Its state is unspecified".
Some components give stronger guarantees. For
example, moved-from <tt>shared_ptr</tt>s are guaranteed <tt>empty</tt>
(20.9.11.2.1/25).
In general, what the standard really should say (preferably
as a global blanket statement) is that moved-from objects
can be destroyed and can be the destination of an
assignment. Anything else is radioactive. For example,
containers can be "emptier than empty". This needs to be
explicit and required generally.
</p>
<p>
Note: The last time that one of us mentioned "emptier
than empty" (i.e. containers missing sentinel nodes, etc.)
the objection was that containers can store sentinel nodes
inside themselves in order to avoid dynamically allocating
them. This is unacceptable because
</p>
<p>
(a) it forces existing implementations (i.e. Dinkumware's, Microsoft's,
IBM's,  etc.) to change for no good reason (i.e. permitting more
operations on moved-from objects), and 
</p>
<p>
(b) it invalidates end-iterators when swapping containers. (The Working
Paper currently permits end-iterator invalidation, which we
consider to be wrong, but that's a separate argument. In
any event, <em>mandating</em> end-iterator invalidation is very
different from permitting it.)
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
State as a general requirement that moved-from
objects can be destroyed and can be the
destination of an assignment. Any other use is
undefined behavior.
</p>


<p><b>Proposed resolution:</b></p>
<p>Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3241.html">N3241</a></p>





<hr>
<h3><a name="1375" href="1375">1375.</a> <tt>reference_type</tt> should not have been removed from the
allocator requirements</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1318">1318</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-87</b></p>
<p>
<tt>reference_type</tt> should not have been removed from the
allocator requirements. Even if it is always the same as
<tt>value_type&amp;</tt>, it is an important customization point for
extensions and future features.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In [allocator.requirements] Table 42 - Allocotor Requirements, 
Add a row (after <tt>value_type</tt>) with columns:
</p>
<blockquote><p>
Expression: <ins><tt>X::reference_type</tt></ins><br/>
Return type: <ins><tt>T&amp;</tt></ins><br/>
Assertion/note...: (empty)<br/>
Default: <ins><tt>T&amp;</tt></ins><br/>
</p></blockquote>
<p>
[allocator.traits]:
</p> 
<blockquote><pre>
namespace std {
  template &lt;class Alloc&gt; struct allocator_traits {
    typedef Alloc allocator_type;
    
    typedef typename Alloc::value_type value_type;

    typedef <i>see below</i>   pointer;
    typedef <i>see below</i>   const_pointer;
    typedef <i>see below</i>   void_pointer;
    typedef <i>see below</i>   const_void_pointer;
    <ins>typedef value_type&amp; reference_type;</ins>
</pre></blockquote>
<p>
Add <tt>reference_type</tt> to
allocator_traits template, defaulted to
value_type&amp;.
</p>





<hr>
<h3><a name="1376" href="1376">1376.</a> Allocator interface is not backward compatible</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-88</b></p>
<p>
Allocator interface is not backward compatible.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
See Appendix 1 - Additional Details
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote><p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3165.pdf">n3165</a> provides an alternative resolution.
</p></blockquote>

<p><i>[
2910 Batavia:
]</i></p>

<p>
Closed as NAD - withdrawn by the submitter.
</p>


<p><b>Proposed resolution:</b></p><p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3165.pdf">n3165</a>
</p>

<p><b>Rationale:</b></p><p>Withdrawn by the submitter.</p>




<hr>
<h3><a name="1395" href="1395">1395.</a> Inconsistent reference links should be unified</h3>
<p><b>Section:</b> 21.3.7 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.rel">active issues</a> in [meta.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-32</b></p>
<p>
Representations of reference link are not unified.
Most reference links to clause (table) number, say X, are
in the form "Clause X" ("Table X") capitalized, and
subsection Y.Y.Y is referenced with its number only in the
form "Y.Y.Y". Whether they are parenthesized or not
depends on the context.
However there are some notations "(Z)" consisting of only
a number Z in parentheses to confer Clause or Table
number Z.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change "(10)" to "(Clause 10)".
</p>





<hr>
<h3><a name="1396" href="1396">1396.</a> <tt>regex</tt> should support allocators</h3>
<p><b>Section:</b> 32.7 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2020-11-09 20:22:58 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="1451">1451</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>
<p>
<tt>std::basic_regex</tt> should have an allocator for all the
reasons that a <tt>std::string</tt> does. For example, I can use
<tt>boost::interprocess</tt> to put a <tt>string</tt> or <tt>vector</tt>
in shared memory, but not a <tt>regex</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Add allocators to regexes
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote><p>
Accepting <a href="https://wg21.link/n3171.pdf">n3171</a> would solve this issue.
</p></blockquote>

<p><i>[2011-03-22 Madrid]</i></p>

<p>Close 1396 as NAD Future.</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend Open: Covered in LEWG9, P0269, which is in wording review.</p>

<p><i>[2020-07-17; status changed to Tentatively NAD in issue processing telecon]</i></p>

<p>
P0269R0 has been superseded by P1294R0.
Requested LEWG to confirm which version they forwarded to LWG.
In any case, this is a feature request, not a defect, and will be dealt with as a proposal not an issue.
</p>
<p><i>[2020-11-09 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Rationale:</b></p><p>No consensus for a change at this time</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1398" href="1398">1398.</a> Users should be able to specialize functors without depending on whole <tt>&lt;functional&gt;</tt> header</h3>
<p><b>Section:</b> 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-96</b></p>
<p>
The function templates <tt>hash</tt>, <tt>less</tt> and <tt>equal_to</tt>
are important customization points for user-defined types to
be supported by several standard containers. These are
accessed through the <tt>&lt;functional&gt;</tt> header which has
grown significantly larger in C++0x, exposing many more
facilities than a user is likely to need through there own
header, simply to declare the necessary specialization.
There should be a smaller header available for users to
make the necessary customization.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Provide a tiny forwarding header for important
functor types in the <tt>&lt;functional&gt;</tt> header that a
user may want to specialize. This should contain
the template declaration for <tt>equal_to</tt>, <tt>hash</tt> and
<tt>less</tt>.
</p>

<p><i>[
Rapperswill summary
]</i></p>

<p>Alisdair: Would recommend NAD unless someone takes the issue. </p>

<p>Daniel: Volunteers to write a paper for this. </p>

<p><i>[
2010-11-07 Daniel provides a paper available on the Batavia document list
]</i></p>


<p><i>[
2010 Batavia:
]</i></p>

<p>
Closed as NAD - the consensus was that forwarding headers such as
<tt>&lt;iosfwd&gt;</tt> do not bring the expected benefits, and are
not widely used (to the surprise of some active users in the room!).
Without real experience reporting a benefit, there is no further interest
in pursuing this issue as an extension - hence NAD rather than NAD Future.
</p>



<p><b>Rationale:</b></p><p>No consensus to make a change</p>

<p><b>Proposed resolution:</b></p>
<p>
See paper &quot;Forwarding <tt>&lt;functional&gt;</tt> functor templates&quot;
on the Batavia LWG document list
</p>





<hr>
<h3><a name="1406" href="1406">1406.</a> Support hashing smart-pointers based on <i>owner</i></h3>
<p><b>Section:</b> 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-5</b></p>
<p>
Hash support based on ownership sharing should be
supplied for <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
For two <tt>shared_ptr</tt> objects <tt>p</tt> and <tt>q</tt>, two distinct
equivalence relations can be defined. One is based on
equivalence of pointer values, which is derived from the
expression <tt>p.get() == q.get()</tt> (hereafter called <i>address based
equivalence relation</i>), the other is based on
equivalence of ownership sharing, which is derived from
the expression <tt>!p.owner_before(q) &amp;&amp; !q.owner_before(p)</tt>
(hereafter called <i>ownership-based equivalence relation</i>).
These two equivalence relations are independent in
general. For example, a <tt>shared_ptr</tt> object created by the
constructor of the signature <tt>shared_ptr(shared_ptr&lt;U>
const &amp;, T *)</tt> could reveal a difference between these two
relations. Therefore, hash support based on each
equivalence relation should be supplied for <tt>shared_ptr</tt>.
However, while the standard library provides the hash
support for address-based one (20.9.11.6 paragraph 2), it
lacks the hash support for ownership-based one. In
addition, associative containers work well in combination
with the <tt>shared_ptr</tt>'s ownership-based comparison but
unordered associative containers don't. This is
inconsistent.
</p>
<p>
For the case of <tt>weak_ptr</tt>, hash support for the ownership based
equivalence relation can be safely defined on
<tt>weak_ptr</tt>s, and even on expired ones. The absence of
hash support for the ownership-based equivalence
relation is fatal, especially for expired <tt>weak_ptr</tt>s. And the
absence of such hash support precludes some quite
effective use-cases, e.g. erasing the <tt>unordered_map</tt> entry
of an expired <tt>weak_ptr</tt> key from a customized deleter
supplied to <tt>shared_ptr</tt>s.
</p>
<p>
Hash support for the ownership-based equivalence
relation cannot be provided by any user-defined manner
because information about ownership sharing is not
available to users at all. Therefore, the only way to provide
ownership-based hash support is to offer it intrusively by
the standard library.
</p>
<p>
As far as we know, such hash support is implementable.
Typical implementation of such hash function could return
the hash value of the pointer of the counter object that is
internally managed by <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
</p>

<p><i>[2010 Rapperswil:]</i></p>

<blockquote>
<p>No consensus to make this change at this time.</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Needs a paper. Feature. Exposing an implementation detail (indirectly observable via hash).</p>



<p><b>Proposed resolution:</b></p>
<p>
Add the following non-static member functions to
<tt>shared_ptr</tt> and <tt>weak_ptr</tt> class template;
</p>
<p>
Update [util.smartptr.shared], 20.9.11.2 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class shared_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
Update [util.smartptr.weak], 20.9.11.3 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class weak_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
These functions satisfy the following
requirements. Let <tt>p</tt> and <tt>q</tt> be objects of either
<tt>shared_ptr</tt> or <tt>weak_ptr</tt>, <tt>H</tt> be a hypothetical
function object type that satisfies the hash
requirements ([hash.requirements], 20.2.4) and <tt>h</tt> be an object of the
type <tt>H</tt>. The expression <tt>p.owner_hash()</tt> behaves
as if it were equivalent to the expression <tt>h(p)</tt>. In
addition, <tt>h(p) == h(q)</tt> must become <tt>true</tt> if <tt>p</tt> and
<tt>q</tt> share ownership.
</p>





<hr>
<h3><a name="1411" href="1411">1411.</a> Add a compile-time flag to detect <tt>monotonic_clock</tt></h3>
<p><b>Section:</b> 99 [time.clock.monotonic] <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1410">1410</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE-20</b></p>
<p>
The library component <tt>monotonic_clock</tt> is conditionally
supported, but no compile-time flag exists that allows
user-code to query its existence. Further-on there exist no
portable means to simulate such a query. (To do so, user
code would be required to add types to namespace
<tt>std::chrono</tt>.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Provide a compile-time flag (preferably a macro)
that can be used to query the existence of
<tt>monotonic_clock</tt>.
</p>





<hr>
<h3><a name="1413" href="1413">1413.</a> Specify whether <tt>high_resolution_clock</tt> is a distinct type or a typedef</h3>
<p><b>Section:</b> 29.7.8 <a href="https://timsong-cpp.github.io/cppwp/time.clock.hires">[time.clock.hires]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-112</b></p>
<p>
What it means for <tt>high_resolution_clock</tt> to be a synonym
is undefined. If it may or may not be a typedef, then
certain classes of programs become unportable.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Require that it be a distinct class type.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
This is not a defect.  Threre are a number of places in the standard where
we allow implentations to choose their preferred technique, the most obvious
example being the <tt>iterator</tt>/<tt>const_iterator</tt> types of <tt>set</tt>.
</p>
<p>
Typically, this means it is not portable to declare function overloads that differ
only in their use of these types.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1415" href="1415">1415.</a> Iterator stability bans the short-string optimization</h3>
<p><b>Section:</b> 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Requirements on iterators swapping allegiance would
disallow the small-string optimization.
</p>
<p><i>[
Resolved in Rapperswil by paper N3108.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add an exclusion for <tt>basic_string</tt> to the sentence
beginning &#8220;Every iterator referring to an
element...&#8221;. Add a sentence to 21.4.6.8/2 saying
that iterators and references to string elements
remain valid, but it is not specified whether they
refer to the same string or the other string.
</p>





<hr>
<h3><a name="1419" href="1419">1419.</a> <tt>forward_list::erase_after</tt> should return an iterator</h3>
<p><b>Section:</b> 99 [forwardlist] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist">issues</a> in [forwardlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-117</b></p>
<p>
<tt>forward_list::erase_after</tt> should return an iterator.
</p>
<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
See Appendix 1 - Additional Details
</p>





<hr>
<h3><a name="1433" href="1433">1433.</a> <tt>random_shuffle</tt> and <tt>shuffle</tt> should have consistent signatures</h3>
<p><b>Section:</b> 27.7.13 <a href="https://timsong-cpp.github.io/cppwp/alg.random.shuffle">[alg.random.shuffle]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.random.shuffle">issues</a> in [alg.random.shuffle].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1432">1432</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-119</b></p>
<p>
The functions <tt>random_shuffle</tt> and <tt>shuffle</tt> both take
arguments providing a source of randomness, but one
take its argument by rvalue reference, and the other
requires an lvalue reference. The technical merits of which
form of argument passing should be settled for this
specific case, and a single preferred form used
consistently.
</p>


<p><b>Proposed resolution:</b></p>
<p>
[DEPENDS ON WHETHER RVALUE OR
LVALUE REFERENCE IS THE PREFERRED
FORM]
</p>





<hr>
<h3><a name="1434" href="1434">1434.</a> For <tt>min/max</tt> functions replace variadic arguments by <tt>initializer_list</tt> argument</h3>
<p><b>Section:</b> 27.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-122</b></p>
<p>
It was the LWG's intent in Pittsburgh that N2772 be applied to the WP.
</p>
<p><i>[
Resolved in Rapperswil by paper N3106.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Apply N2772 to the WP.</p>





<hr>
<h3><a name="1442" href="1442">1442.</a> "happens-before" should be "synchronizes-with"</h3>
<p><b>Section:</b> 33 <a href="https://timsong-cpp.github.io/cppwp/thread">[thread]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="1443">1443</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-9, GB-122</b></p>

<p><i>[CA-9:]</i></p>

<p>
Imposed happens-before edges should be in
synchronizes-with<br/>
Each use of the words "happens-before" should be
replaced with the words "synchronizes-with" in the
following sentences:<br/>
27.2.3p2<br/>
30.3.1.2p6<br/>
30.3.1.5p7<br/>
30.6.4p7<br/>
30.6.9p5<br/>
30.6.10.1p23<br/>
Rationale: Happens-before is defined in 1.10p11 in a way
that (deliberately) does not make it explicitly transitively
closed. Adding edges to happens-before directly, as in
27.2.3p2 etc., does not provide transitivity with
sequenced-before or any other existing happens-before
edge. This lack of transitivity seems to be unintentional.
</p>

<p><i>[GB-122]</i></p>


<p>At various points in the standard new edges are added to
happens-before, for example 27.2.3:2 adds happens-before edges between
writes and reads from a stream:</p>

<p>If one thread makes a library call a that writes a value to a
stream and, as a result, another thread reads this value from the
stream through a library call b such that this does not result in a
data race, then a happens before b.</p>

<p>Happens-before is defined in 1.10:11 in a deliberate way that makes it
not explicitly transitively closed. Adding edges to happens-before
directly, as in 27.2.3:2, does not provide transitivity with
sequenced-before or any other existing happens-before edge. This lack
of transitivity seems to be unintentional. In order to achieve
transitivity we suggest each edge be added to
inter-thread-happens-before as a synchronises-with edge (as per
conversation with Hans Boehm). In the standard, each use of the words
"happens-before" should be replaced with the words "synchronizes-with"
in the following sentences:</p>

<p>27.2.3:2,
30.3.1.2:6,
30.3.1.5:7,
30.6.4:7,
30.6.9:5,
30.6.10.1:23</p>

<p><b>Proposed resolution:</b></p>

<p><i>[Beman provided specific wording for the proposed resolution.]</i></p>


<p>Change 27.2.3 Thread Safety [iostreams.threadsafety] paragraph 2:</p>

<p>If one thread makes a library call <tt>a</tt> that writes a value to a stream 
and, as a result, another thread reads this value from the stream through a library 
call <tt>b</tt> such that this does not result in a data race, then <tt>a</tt> 
<del>happens before</del> <ins>synchronizes with</ins> <tt>b</tt>.</p>

<p>Change 30.3.1.2 thread constructors [thread.thread.constr] paragraph 6:</p>

<p><i>Synchronization:</i> The invocation of the constructor <del>happens 
before</del> <ins>synchronizes with</ins> the invocation of the copy of <tt>f</tt>.</p>

<p>Change 30.3.1.5 thread members [thread.thread.member] paragraph 7:</p>

<p><i>Synchronization:</i> The completion of the thread represented by <tt>*this</tt> 
<del>happens before</del> <ins>synchronizes with</ins> (1.10) <tt>join()</tt> 
<del>returns</del> <ins>returning</ins>. [ Note: Operations on <tt>*this</tt> 
are not synchronized. --end note ]</p>

<p>Change 30.6.4 Associated asynchronous state [futures.state] paragraph 7:</p>

<p>Calls to functions that successfully set the stored result of an associated 
asynchronous state synchronize with (1.10) calls to functions successfully detecting 
the ready state resulting from that setting. The storage of the result (whether normal 
or exceptional) into the associated asynchronous state <del>happens before</del> 
<ins>synchronizes with</ins> (1.10) that state <del>is</del> <ins>being</ins> set to ready.</p>

<p>Change 30.6.9 Function template async [futures.async] paragraph 5:</p>

<p><i>Synchronization:</i> the invocation of <tt>async</tt> <del>happens before</del> 
<ins>synchronizes with</ins> (1.10) the invocation of <tt>f</tt>. [ <i>Note</i>: this
statement applies even when the corresponding future object is moved to another thread. &mdash; <i>end
note</i> ] If the invocation is not deferred, a call to a waiting function on an asynchronous return object
that shares the associated asynchronous state created by this async call shall block until the associated
thread has completed. If the invocation is not deferred, the <tt>join()</tt> on the created thread 
<del>happens before</del> <ins>synchronizes with</ins> (1.10) the first function that successfully 
detects the ready status of the associated asynchronous state returns or before the function that 
gives up the last reference to the associated asynchronous state returns, whichever happens first. 
If the invocation is deferred, the completion of the invocation of the deferred function <del>happens 
before</del> <ins>synchronizes with</ins> the calls to the waiting functions return.</p>

<p>Change 30.6.10.1 packaged_task member functions [futures.task.members] paragraph 23:</p>

<p><i>Synchronization:</i> a successful call to <tt>operator()</tt> synchronizes with (1.10) a call 
to any member function of a <tt>future</tt>, <tt>shared_future</tt>, or <tt>atomic_future</tt> object 
that shares the associated asynchronous state of <tt>*this</tt>. The completion of the invocation 
of the stored task and the storage of the result (whether normal or exceptional) into the associated 
asynchronous state <del>happens before</del> <ins>synchronizes with</ins> (1.10) the state <del>is</del> 
<ins>being</ins> set to ready. [ Note: <tt>operator()</tt> synchronizes and serializes with other 
functions through the associated asynchronous state. &mdash;end note ]</p>






<hr>
<h3><a name="1443" href="1443">1443.</a> Imposed happens-before edges are not made transitive</h3>
<p><b>Section:</b> 33 <a href="https://timsong-cpp.github.io/cppwp/thread">[thread]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1442">1442</a></p>
<p><b>Discussion:</b></p>


<p><b>Addresses GB-122</b></p>

<p>At various points in the standard new edges are added to
happens-before, for example 27.2.3:2 adds happens-before edges between
writes and reads from a stream:</p>

<p>If one thread makes a library call a that writes a value to a
stream and, as a result, another thread reads this value from the
stream through a library call b such that this does not result in a
data race, then a happens before b.</p>

<p>Happens-before is defined in 1.10:11 in a deliberate way that makes it
not explicitly transitively closed. Adding edges to happens-before
directly, as in 27.2.3:2, does not provide transitivity with
sequenced-before or any other existing happens-before edge. This lack
of transitivity seems to be unintentional. In order to achieve
transitivity we suggest each edge be added to
inter-thread-happens-before as a synchronises-with edge (as per
conversation with Hans Boehm). In the standard, each use of the words
"happens-before" should be replaced with the words "synchronizes-with"
in the following sentences:</p>

<p>27.2.3:2,
30.3.1.2:6,
30.3.1.5:7,
30.6.4:7,
30.6.9:5,
30.6.10.1:23</p>


<p><b>Proposed resolution:</b></p>
<p>
Request the concurrency working group to
determine if changes are needed
</p>





<hr>
<h3><a name="1444" href="1444">1444.</a> <tt>OFF_T</tt> is not defined</h3>
<p><b>Section:</b> 31.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/fpos.operations">[fpos.operations]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#fpos.operations">issues</a> in [fpos.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1414">1414</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses GB-123</b></p>
<p>
Several rows in table 124 specify a Return type of
'OFF_T', which does not appear to be a type defined in
this standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Resolve outstanding references to the removed type 'OFF_T'.
</p>





<hr>
<h3><a name="1446" href="1446">1446.</a> Move and swap for I/O streams</h3>
<p><b>Section:</b> 31.7 <a href="https://timsong-cpp.github.io/cppwp/iostream.format">[iostream.format]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-138</b></p>

<p>
For istreams and ostreams, the move-constructor does
not move-construct, the move-assignment operator does
not move-assign, and the swap function does not swap
because these operations do not manage the <tt>rdbuf()</tt>
pointer. Useful applications of these operations are
prevented both by their incorrect semantics and because
they are protected.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
In short: reverse the resolution of issue 900, then
change the semantics to move and swap the
<tt>rdbuf()</tt> pointer. Add a new protected constructor
that takes an rvalue reference to a stream and a
pointer to a streambuf, a new protected <tt>assign()</tt>
operator that takes the same arguments, and a
new protected <tt>partial_swap()</tt> function that doesn't
swap <tt>rdbuf()</tt>.
See Appendix 1 - Additional Details
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote><p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3179.pdf">n3179</a> would solve this issue.
</p></blockquote>

<p><i>[
2010-11 Batavia
]</i></p>

<p>
Closed as NAD.
</p>
<blockquote><p>
The Library Working Group reviewed <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3179.pdf">n3179</a> and 
concluded that this change alone was not sufficient, as it would require changes to some of the derived stream types in the library.  
The preference is to not make such a broad fix, and retain the current semantics. This is closed as NAD rather than NAD future as it 
will be difficult to rename the new functions introduced in the C++0x revision of the standard at a later date.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1451" href="1451">1451.</a> <tt>regex</tt> should support allocators</h3>
<p><b>Section:</b> 32.7 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1396">1396</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-141</b></p>

<p>
<tt>std::basic_regex</tt> should have an allocator for all the
reasons that a <tt>std::string</tt> does. For example, I can use
<tt>boost::interprocess</tt> to put a <tt>string</tt> or <tt>vector</tt> 
in shared memory, but not a regex.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add allocators to regexes; see paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing.
</p>





<hr>
<h3><a name="1452" href="1452">1452.</a> "target sequence" is not defined</h3>
<p><b>Section:</b> 32.9.5 <a href="https://timsong-cpp.github.io/cppwp/re.results.acc">[re.results.acc]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.acc">issues</a> in [re.results.acc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-125</b></p>

<p>The term "target sequence" is not defined (32.9.5 <a href="https://timsong-cpp.github.io/cppwp/re.results.acc">[re.results.acc]</a> p. 2).</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Replace "target sequence" with "string being searched/matched"
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<p>
The proposed resolution looks incomplete to me, there are more normative
usages of the term <em>target sequence</em> in clause 28, e.g.
32.11.2 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter">[re.tokiter]</a> p. 7.
</p>

<p><i>[2011-03-22 Madrid meeting: Moved to NAD]</i></p>




<p><b>Rationale:</b></p><p>Standard is correct as written</p>

<p><b>Proposed resolution:</b></p>
<p>
Wording changes are against N3126. They are intended not to conflict with the wording changes
suggested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a>.
</p>
<p>
Change 32.9.5 <a href="https://timsong-cpp.github.io/cppwp/re.results.acc">[re.results.acc]</a> p. 2 as indicated:
</p>
<blockquote><pre>
difference_type position(size_type sub = 0) const;
</pre><blockquote><p>
2 <em>Returns</em>: The distance from the start of the <del>target sequence</del><ins>string being matched</ins> to <tt>(*this)[sub].first</tt>.
</p></blockquote></blockquote>





<hr>
<h3><a name="1454" href="1454">1454.</a> Ensure C compatibility for atomics</h3>
<p><b>Section:</b> 33.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1455">1455</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses GB-128</b></p>
<p>
WG14 has made some late changes to their specification
of atomics, and care should be taken to ensure that we
retain a common subset of language/library syntax to
declare headers that are portable to both languages.
Ideally, such headers would not require users to define
their own macros, especially not macros that map to
keywords (which remains undefined behaviour)
</p>


<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Depends on result of the review of WG14 work,
which is expected to be out to ballot during the
time wg21 is resolving its own ballot comments.
Liaison may also want to file comments in WG14
to ensure compatibity from both sides.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1456" href="1456">1456.</a> Missing fixed-size <tt>atomic_</tt> typedefs</h3>
<p><b>Section:</b> 33.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-129</b></p>
<p>
Table 143 lists the typedefs for various atomic types
corresponding to the various standard integer typedefs,
such as <tt>atomic_int_least8_t</tt> for <tt>int_least8_t</tt>, and
<tt>atomic_uint_fast64_t</tt> for <tt>uint_fast64_t</tt>. However, there are
no atomic typedefs corresponding to the fixed-size
standard typedefs <tt>int8_t</tt>, <tt>int16_t</tt>, and so forth.
</p>
<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote><p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue.
</p></blockquote>

<p><i>[
2011-02-15 Anthony corrects numbering/naming for N3225, Howard suggests improvement for the position
of '(optional)', Daniel reorders rows in harmony to remaining entries and suggests specific optionality
comments:
]</i></p>


<p><i>[2011-02-16 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>

<p><i>[2011-03-16: Hans reopenes and comments]</i></p>


<p>WG14 briefly discussed LWG 1456. It turns out that they had previously made a conscious decision not to make a 
similar change. If C++ would deviate, this would introduce a C divergence.
<p/>
We should reopen the issue and, in my opinion, probably resolve it as NAD instead.  This is in a part of the standard 
that is there mostly for C compatibility, so introducing divergence here seems to make no sense.
</p>

<p><i>[2011-03-24 Madrid]</i></p>

<p><b>Rationale:</b></p><p>
WG14 does not require these typedefs, and we see no reason to be gratuitously different.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add the following entries to table 143:
</p>
<blockquote>
<table border="1">
<caption>Table 146 &mdash; <tt>atomic</tt> <tt>&lt;inttypes.h&gt;</tt> typedefs</caption>
<tr>
<th>Atomic typedef</th>
<th><tt>&lt;inttypes.h&gt;</tt> type</th>
</tr>
<tr>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>atomic_intmax_t</tt></td>
<td><tt>intmax_t</tt></td>
</tr>
<tr>
<td><tt>atomic_uintmax_t</tt></td>
<td><tt>uintmax_t</tt></td>
</tr>
<tr>
<td><ins><tt>atomic_int8_t&nbsp;</tt>// <em>iff <tt>int8_t</tt> is provided</em></ins></td>
<td><ins><tt>int8_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint8_t&nbsp;</tt>// <em>iff <tt>uint8_t</tt> is provided</em></ins></td>
<td><ins><tt>uint8_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int16_t&nbsp;</tt>// <em>iff <tt>int16_t</tt> is provided</em></ins></td>
<td><ins><tt>int16_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint16_t&nbsp;</tt>// <em>iff <tt>uint16_t</tt> is provided</em></ins></td>
<td><ins><tt>uint16_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int32_t&nbsp;</tt>// <em>iff <tt>int32_t</tt> is provided</em></ins></td>
<td><ins><tt>int32_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint32_t&nbsp;</tt>// <em>iff <tt>uint32_t</tt> is provided</em></ins></td>
<td><ins><tt>uint32_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int64_t&nbsp;</tt>// <em>iff <tt>int64_t</tt> is provided</em></ins></td>
<td><ins><tt>int64_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint64_t&nbsp;</tt>// <em>iff <tt>uint64_t</tt> is provided</em></ins></td>
<td><ins><tt>uint64_t</tt></ins></td>
</tr>
</table>
</blockquote> 





<hr>
<h3><a name="1458" href="1458">1458.</a> Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 33.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1459">1459</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses GB-131</b></p>

<p>
33.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8 states:
</p>
<blockquote><p>
An atomic store shall only store a value that has been computed
from constants and program input values by a finite sequence of
program evaluations, such that each evaluation observes the values
of variables as computed by the last prior assignment in the
sequence.
</p></blockquote>
<p>
... but 6.9.1 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> p.13 states:
</p>
<blockquote><p>
If A is not sequenced before B and B is not sequenced before A,
then A and B are unsequenced. [ <em>Note</em>: The execution of unsequenced
evaluations can overlap. &mdash; <em>end note</em> ]
</p></blockquote>
<p>
Overlapping executions can make it impossible to construct the sequence
described in 33.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8. We are not sure of the intention here and do not
offer a suggestion for change, but note that 33.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8 is the condition
that prevents out-of-thin-air reads.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Request the concurrency working group to
determine if changes are needed. Consider
changing the use of "sequence" in 33.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a>
</p>





<hr>
<h3><a name="1461" href="1461">1461.</a> Rename all <tt>ATOMIC_*</tt> macros as <tt>STD_ATOMIC_*</tt></h3>
<p><b>Section:</b> 33.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-1</b></p>
<p>
All <tt>ATOMIC_</tt>... macros should be prefixed with <tt>STD_</tt> as
in <tt>STD_ATOMIC_</tt>... to indicate they are <tt>STD</tt> macros as
other standard macros. The rationale that they all seem too long seems weak.
</p>

<p><i>[2011-03-06: Daniel adapts suggested wording to N3242 and comments]</i></p>


<p>I suggest to declare this issue as NAD. Reason for this suggestion is, that
C1x is currently going to suggest exactly the same macros as additions to
header <tt>&lt;stdatomic.h&gt;</tt>, therefore C++0x should not define a
whole new set. I'm making this suggestion with the understanding that
C1x is intending to keep in sync in this regard. For example, the most
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf">recent 
draft of C1x</a> does contain the macro <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>
which has recently been removed from the C++ working draft.</p>

<p><i>[2011-03-24]</i></p>

<p><b>Rationale:</b></p><p>
C is not going to change the name of these macros, and it is
important they have the same name for compatibility
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Change sub-clause 33.5.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a> as indicated:</p>
<blockquote><pre>
[..]
// <em>[atomics.lockfree], lock-free property</em>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>unspecified</em>

// <em>[atomics.types.operations.req], operations on atomic types</em>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
[..]
</pre></blockquote>
</li>
<li>
<p>Change 33.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p. 1 as indicated:</p>
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>implementation-defined</em>
</pre><blockquote>
<p>
1 The <tt><ins>STD_</ins>ATOMIC_..._LOCK_FREE</tt> macros indicate the lock-free property of the corresponding atomic types, [..]
</p></blockquote></blockquote>
</li>
<li>
<p>Change 99 [atomics.types.operations.req] p. 6 as indicated:</p>
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
</pre><blockquote><p>
5 <em>Remarks</em>: The macro expands to a token sequence suitable for constant initialization 
an atomic variable of static storage duration of a type that is initialization-compatible
with <i>value</i>. [ <i>Note</i>: This operation may need to initialize locks. &mdash; <i>end note</i> ] 
Concurrent access to the variable being initialized, even via an atomic operation, constitutes 
a data race. [ <em>Example:</em>
</p><blockquote><pre>
atomic&lt;int&gt; v = <ins>STD_</ins>ATOMIC_VAR_INIT(5);
</pre></blockquote>
<p>&mdash; <em>end example</em> ]</p>
</blockquote></blockquote>
</li>
<li>
<p>Change 33.5.10 <a href="https://timsong-cpp.github.io/cppwp/atomics.flag">[atomics.flag]</a> p. 1+4 as indicated:</p>
<blockquote><pre>
namespace std {
  [..]
  #define <ins>STD_</ins>ATOMIC_FLAG_INIT <em>see below</em>
}
</pre><blockquote><p>
[..]
4 The macro <tt><ins>STD_</ins>ATOMIC_FLAG_INIT</tt> shall be defined in such a way that it can be used to initialize an object of
type <tt>atomic_flag</tt> to the clear state. For a static-duration object, that initialization shall be static. It is
unspecified whether an unitialized <tt>atomic_flag</tt> object has an initial state of set or clear. [ <em>Example:</em>
</p><blockquote><pre>
atomic_flag guard = <ins>STD_</ins>ATOMIC_FLAG_INIT;
</pre></blockquote>
<p>&mdash; <em>end example</em> ]</p>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1463" href="1463">1463.</a> Inconsistent value assignment for <tt>atomic_bool</tt></h3>
<p><b>Section:</b> 99 [atomics.types.integral] <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.integral">issues</a> in [atomics.types.integral].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1462">1462</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-157</b></p>

<p>
<tt>atomic_bool</tt> has a <tt>volatile</tt> assignment operator but not a
non-<tt>volatile</tt> operator. The other integral types have both.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a non-volatile assignment operator to <tt>atomic_bool</tt>.
</p>





<hr>
<h3><a name="1470" href="1470">1470.</a> &quot;Same-ness&quot; curiosities</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1474">1474</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-165</b></p>

<p>
According to 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 23:
</p>
<blockquote><p>
&#8220;is the same that same as that of&#8221; is not grammatical (and is not clear)
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1471" href="1471">1471.</a> Default constructor of atomics needs specification</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-168</b></p>

<p>
33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> around p. 4: The definition of the default constructor needs exposition.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Insert a new general prototype description following the current 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 3 as indicated:
</p>
<blockquote><p>
3 [<em>Note</em>: Many operations are volatile-qualified. The “volatile as device register” semantics have not changed
in the standard. This qualification means that volatility is preserved when applying these operations to
volatile objects. It does not mean that operations on non-volatile objects become volatile. Thus, volatile
qualified operations on non-volatile objects may be merged under some conditions. -- <em>end note</em>]
</p></blockquote>
<blockquote><pre>
<ins>A::A() = default;</ins>
</pre><blockquote><p>
<ins>? <em>Effects</em>: Leaves the atomic object in an uninitialized state.
[<em>Note</em>: These semantics ensure compatiblity with <tt>C</tt>. -- <em>end note</em>]</ins>
</p></blockquote></blockquote>
<blockquote><pre>
constexpr A::A(C desired);
[..]
</pre></blockquote>





<hr>
<h3><a name="1472" href="1472">1472.</a> Incorrect semantics of <tt>atomic_init</tt></h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-171</b></p>

<p>
As of 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 7:
<p/>
The <tt>atomic_init</tt> definition "Non-atomically assigns the
value" is not quite correct, as the <tt>atomic_init</tt> purpose is
initialization.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change  33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 7 as indicated:
</p>
<blockquote><pre>
void atomic_init(volatile A *object, C desired);
void atomic_init(A *object, C desired);
</pre><blockquote><p>
7 <em>Effects</em>: <del>Non-atomically assigns the value desired to <tt>*object</tt></del><ins>Initializes <tt>*object</tt> with value
<tt>desired</tt></ins>. Concurrent access from another thread, even via an atomic operation, constitutes a data race.
<ins>[<em>Note</em>: This function should only be applied to objects that have been default constructed. These semantics ensure
compatibility with <tt>C</tt>. &mdash; <em>end note</em>]</ins>
</p></blockquote></blockquote>





<hr>
<h3><a name="1473" href="1473">1473.</a> Incomplete memory order specifications</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-172</b></p>

<p>
As of 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 9, 13, 17, 20:
<p/>
The order specifications are incomplete because the non-<tt>_explicit</tt>
functions do not have such parameters.
<p/>
Add a new sentence: "If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>." Or perhaps: "The non-_explicit
non-member functions shall affect memory as though they were _explicit with
<tt>memory_order_seq_cst</tt>."
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed this, and deemed it NAD according to
33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> paragraph 2, bullet 4. 
</p>

<p><b>Rationale:</b></p><p>The working paper is correct as written.</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 9 as indicated:
<blockquote><pre>
void atomic_store(volatile A* object, C desired);
void atomic_store(A* object, C desired);
void atomic_store_explicit(volatile A *object, C desired, memory_order order);
void atomic_store_explicit(A* object, C desired, memory_order order);
void A::store(C desired, memory_order order = memory_order_seq_cst) volatile;
void A::store(C desired, memory_order order = memory_order_seq_cst);
</pre><blockquote><p>
8 <em>Requires</em>: The order argument shall not be <tt>memory_order_consume</tt>, <tt>memory_order_acquire</tt>, nor
<tt>memory_order_acq_rel</tt>.
<p/>
9 <em>Effects</em>: Atomically replaces the value pointed to by <tt>object</tt> or by this with the value of <tt>desired</tt>.
Memory is affected according to the value of <tt>order</tt>. <ins>If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
<li>Change 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 13 as indicated:
<blockquote><pre>
C atomic_load(const volatile A* object);
C atomic_load(const A* object);
C atomic_load_explicit(const volatile A* object, memory_order);
C atomic_load_explicit(const A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) const volatile;
C A::load(memory_order order = memory_order_seq_cst) const;
</pre><blockquote><p>
12 <em>Requires</em>: The order argument shall not be <tt>memory_order_release</tt> nor <tt>memory_order_acq_rel</tt>.
<p/>
13 <em>Effects</em>: Memory is affected according to the value of <tt>order</tt>. <ins>If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>.</ins>
<p/>
14 <em>Returns</em>: Atomically returns the value pointed to by <tt>object</tt> or by <tt>this</tt>.
</p>
</blockquote></blockquote>
</li>
<li>Change 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 17 as indicated:
<blockquote><pre>
C atomic_exchange(volatile A* object, C desired);
C atomic_exchange(A* object, C desired);
C atomic_exchange_explicit(volatile A* object, C desired, memory_order);
C atomic_exchange_explicit(A* object, C desired, memory_order);
C A::exchange(C desired, memory_order order = memory_order_seq_cst) volatile;
C A::exchange(C desired, memory_order order = memory_order_seq_cst);
</pre><blockquote><p>
17 <em>Effects</em>: Atomically replaces the value pointed to by <tt>object</tt> or by <tt>this</tt> with <tt>desired</tt>. Memory
is affected according to the value of <tt>order</tt>. These operations are atomic read-modify-write operations
(1.10). <ins>If the program does not specify an order, it shall be <tt>memory_order_seq_cst</tt>.</ins>
<p/>
18 <em>Returns</em>: Atomically returns the value pointed to by <tt>object</tt> or by <tt>this</tt> immediately before the effects.
</p>
</blockquote></blockquote>
</li>
<li>Change 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 20 as indicated:
<blockquote><pre>
bool atomic_compare_exchange_weak(volatile A* object, C * expected, C desired);
bool atomic_compare_exchange_weak(A* object, C * expected, C desired);
bool atomic_compare_exchange_strong(volatile A* object, C * expected, C desired);
bool atomic_compare_exchange_strong(A* object, C * expected, C desired);
bool atomic_compare_exchange_weak_explicit(volatile A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_weak_explicit(A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_strong_explicit(volatile A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_strong_explicit(A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order success, memory_order failure) volatile;
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order success, memory_order failure) volatile;
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst) volatile;
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst);
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst) volatile;
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst);
</pre><blockquote><p>
19 <em>Requires</em>: The <tt>failure</tt> argument shall not be <tt>memory_order_release</tt> nor <tt>memory_order_acq_rel</tt>.
The <tt>failure</tt> argument shall be no stronger than the success argument.
<p/>
20 <em>Effects</em>: Atomically, compares the contents of the memory pointed to by <tt>object</tt> or by <tt>this</tt> for equality
with that in <tt>expected</tt>, and if true, replaces the contents of the memory pointed to by <tt>object</tt> or by
<tt>this</tt> with that in <tt>desired</tt>, and if false, updates the contents of the memory in expected with the
contents of the memory pointed to by <tt>object</tt> or by <tt>this</tt>. Further, if the comparison is true, memory
is affected according to the value of <tt>success</tt>, and if the comparison is false, memory is affected
according to the value of <tt>failure</tt>. When only one <tt>memory_order</tt> argument is supplied, the value of
<tt>success</tt> is <tt>order</tt>, and the value of <tt>failure</tt> is <tt>order</tt> except that a value of 
<tt>memory_order_acq_rel</tt> shall be replaced by the value <tt>memory_order_acquire</tt> and a value of 
<tt>memory_order_release</tt> shall be replaced by the value <tt>memory_order_relaxed</tt>. <ins>If 
the program does not specify an order, it shall be <tt>memory_order_seq_cst</tt>.</ins> If the operation returns <tt>true</tt>, 
these operations are atomic read-modify-write operations (1.10). Otherwise, these operations are atomic load operations.
<p/>
[..]
</p>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1475" href="1475">1475.</a> weak compare-and-exchange confusion II</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1474">1474</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-23</b></p>

<p>
33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 23: The first sentence has non-English syntax.
</p>

<p><i>[
Resolution proposed in ballot comment:
]</i></p>


<p>
Change to "The weak compare-and-exchange
operations may fail spuriously, that is, return false
while leaving the contents of memory pointed to
by expected unchanged."
</p>

<p><i>[
Daniel translates NB comment in a proposed resolution
]</i></p>


<p>Change 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p. 23 as indicated:</p>

<blockquote><p>
23 <em>Remark</em>: <del>The weak compare-and-exchange operations may fail spuriously, that is, return false while
leaving the contents of memory pointed to by <tt>expected</tt> before the operation is the same that same
as that of the <tt>object</tt> and the same as that of <tt>expected</tt> after the operation</del><ins>The weak 
compare-and-exchange operations may fail spuriously, that is, return false while leaving the contents of memory 
pointed to by <tt>expected</tt> unchanged.</ins>. [ <em>Note</em>: This spurious failure enables implementation of 
compare-and-exchange on a broader class of machines, e.g., loadlocked store-conditional machines. A consequence of 
spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop.
<p/>
When a compare-and-exchange is in a loop, the weak version will yield better performance on some
platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the
strong one is preferable. &mdash; <em>end note</em> ]
</p></blockquote>

<p><i>[
See <a href="1474">1474</a> for the proposed resolution
]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1476" href="1476">1476.</a> Meaningless specification of spurious failure</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1474">1474</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-177</b></p>

<p>
The first sentence of this paragraph doesn't make sense.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Figure out what it's supposed to say, and say it.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1477" href="1477">1477.</a> weak compare-and-exchange confusion III</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1474">1474</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-135</b></p>

<p>
The first sentence of 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p.23 was changed by n2992 but
now makes no sense: "that is, return <tt>false</tt> while leaving
the contents of memory pointed to by <tt>expected</tt> before the
operation is the same that same as that of the <tt>object</tt> and
the same as that of <tt>expected</tt> after the operation."
There's a minor editorial difference between n2992 ("is
that same as that" vs "is the same that same as that") but
neither version makes sense.
Also, the remark talks about "<tt>object</tt>" which should
probably be "<tt>object</tt> or <tt>this</tt>" to cover the member functions
which have no object parameter.
</p>

<p><i>[
Resolution proposed in ballot comment:
]</i></p>

<p>
Fix the Remark to say whatever was intended.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1483" href="1483">1483.</a> <tt>__STDCPP_THREADS spelling</tt></h3>
<p><b>Section:</b> 33.4 <a href="https://timsong-cpp.github.io/cppwp/thread.threads">[thread.threads]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-23</b></p>

<p>
Predefined macros usually start and end with two
underscores, see 16.8 and FDIS 29124 = WG21 N3060
clause 7. <tt>__STDCPP_THREADS</tt> should blend in.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change the macro name to <tt>__STDCPP_THREADS__</tt>.
</p>





<hr>
<h3><a name="1485" href="1485">1485.</a> Unclear <tt>thread::id</tt> specification</h3>
<p><b>Section:</b> 33.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-184</b></p>
<p>
It is unclear when a <tt>thread::id</tt> ceases to be meaningful.
The sentence "The library may reuse the value of a
<tt>thread::id</tt> of a terminated thread that can no longer be
joined." implies that some terminated threads can be
joined. It says nothing about detached threads.
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Require a unique <tt>thread::id</tt> for every thread that is
(1) detached and not terminated or (2) has an associated <tt>std::thread</tt> 
object.
</p></blockquote>

<p><i>[
2010-11-22 Howard Hinnant observes
]</i></p>


<p>
A thread can either be running or terminated. Additionally a thread can be joined, detached, or neither.  
These combine into the five possible states shown in this table:
</p>

<table border="1">
<tr>
<th></th><th>Running</th><th>Terminated</th>
</tr>
<tr>
<th>Neither joined nor detached</th><td>shall not reuse id</td><td>shall not reuse id</td>
</tr>
<tr>
<th>detached</th><td>shall not reuse id</td><td>may reuse id</td>
</tr>
<tr>
<th>joined</th><td>impossible state</td><td>may reuse id</td>
</tr>
</table>
<p>
Only if a thread is neither joined nor detached can it be joined. Or said differently, if a 
thread has already been joined or detached, then it can not be joined. The sentence:
</p>
<blockquote><p>
The library may reuse the value of a <tt>thread::id</tt> of a terminated thread that can no longer be joined.
</p></blockquote>
<p>
precisely defines the two states shown in the above table where a thread::id may be reused.
</p>
<p>
The following program illustrates all of the possibilities:
</p>
<blockquote><pre>
#include &lt;mutex>
#include &lt;thread>
#include &lt;iostream>
#include &lt;chrono>

std::mutex mut;

void f()
{
   std::lock_guard&lt;std::mutex&gt; _(mut);
   std::cout &lt;&lt; "f id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; " terminating\n";
}

void g()
{
   std::lock_guard&lt;std::mutex&gt; _(mut);
   std::cout &lt;&lt; "g id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; " terminating\n";
}

int main()
{
   std::cout &lt;&lt; "main id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; "\n";
   std::thread t1(f);
   std::thread(g).detach();
   std::this_thread::sleep_for(std::chrono::seconds(1));
   std::cout &lt;&lt; "g's thread::id can be reused here because g has terminated and is detached.\n";
   std::cout &lt;&lt; "f's thread::id can't be reused here because f has terminated but is still joinable.\n";
   std::cout &lt;&lt; "f id = " &lt;&lt; t1.get_id() &lt;&lt; "\n";
   t1.join();
   std::cout &lt;&lt; "f's thread::id can be reused here because f has terminated and is joined.\n";
   std::cout &lt;&lt; "f id = " &lt;&lt; t1.get_id() &lt;&lt; "\n";
}

main id = 0x7fff71197ca0
f id = 0x100381000 terminating
g id = 0x100581000 terminating
g's thread::id can be reused here because g has terminated and is detached.
f's thread::id can't be reused here because f has terminated but is still joinable.
f id = 0x100381000
f's thread::id can be reused here because f has terminated and is joined.
f id = 0x0
</pre></blockquote>

<p><i>[2011-02-11 Reflector discussion]</i></p>

<p>
Moved to Tentatively NAD after 5 votes.
</p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1486" href="1486">1486.</a> Value of <tt>this_thread::get_id()</tt> underspecified for detached thread</h3>
<p><b>Section:</b> 33.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.this">[thread.thread.this]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.this">issues</a> in [thread.thread.this].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-24</b></p>
<p>
What would be the value <tt>this_thread::get_id()</tt> when called from a detached thread?
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add some text to clarify that <tt>get_id()</tt> still returns the same value even after detaching.
</p>

<p><i>[
2010-11-22 Howard Hinnant observes
]</i></p>


<p>
33.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.this">[thread.thread.this]</a>/1 contains the following sentence describing <tt>this_thread::get_id()</tt>:
</p>

<blockquote><p>
... No other thread of execution shall have this id and this thread of execution shall always have this id.
</p></blockquote>

<p>I don't object to adding "even if detached" to this sentence, but it seems unnecessary to me. "Always" means always.</p>

<p><i>[2011-02-11 Reflector discussion]</i></p>

<p>
Moved to Tentatively NAD after 5 votes.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1489" href="1489">1489.</a> <tt>unlock</tt> functions and unlock mutex requirements are inconsistent</h3>
<p><b>Section:</b> 33.6 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex">[thread.mutex]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-26</b></p>

<p>
Specifications of <tt>unlock</tt> member functions and <tt>unlock</tt>
mutex requirements are inconsistent wrt to exceptions and
pre- and postconditions.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
<tt>unlock</tt> should specifiy the precondition that the
current thread "owns the lock", this will make calls
without holding the locks "undefined behavior".
<tt>unlock</tt> in  [mutex.requirements] should either be
<tt>noexcept(true)</tt> or be allowed to throw
<tt>system_error</tt> like <tt>unique_lock::unlock</tt>, or the latter
should be <tt>nothrow(true)</tt> and have the precondition
<tt>owns == true</tt>.
Furthermore <tt>unique_lock</tt>'s postcondition is wrong
in the case of a recursive mutex where <tt>owns</tt>
might stay true, when it is not the last <tt>unlock</tt>
needed to be called.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1495" href="1495">1495.</a> Condition variable <tt>wait_for</tt> return value insufficient</h3>
<p><b>Section:</b> 33.7 <a href="https://timsong-cpp.github.io/cppwp/thread.condition">[thread.condition]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-191</b></p>

<p>
The condition variable <tt>wait_for</tt> returning <tt>cv_status</tt> is insufficient.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Return a duration of timeout remaining instead.
See Appendix 1 of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> - Additional Details, p. 211
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1496" href="1496">1496.</a> <tt>condition_variable</tt> not implementable</h3>
<p><b>Section:</b> 33.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-28</b></p>

<p>
Requiring <tt>wait_until</tt> makes it impossible to implement
<tt>condition_variable</tt> correctly using respective objects
provided by the operating system (i.e. implementing the
native_handle() function) on many platforms (e.g. POSIX,
Windows, MacOS X) or using the same object as for the
condition variable proposed for C.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Remove the <tt>wait_until</tt> functions or make them at least conditionally supported.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1499" href="1499">1499.</a> Condition variables preclude wakeup optimization</h3>
<p><b>Section:</b> 33.7 <a href="https://timsong-cpp.github.io/cppwp/thread.condition">[thread.condition]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-193</b></p>

<p>
Condition variables preclude a wakeup optimization.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote><p>
Change condition_variable to allow such
optimization. See Appendix 1 - Additional Details
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed the issue, and deemed it an extension to be handled after C++0x.
</p>

<p><b>Rationale:</b></p><p>The LWG does not wish to make the change at this time.</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: (N4618 numbering) 30.5.1[thread.condition.condvar] p10.3 allows spurious wakeups. This issue is out of date.</p>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
The approach suggested there raises all sorts of issues about <tt>thread_locals</tt>, etc. It's probably way too late 
to change this anyway, but this would have required a careful paper.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1500" href="1500">1500.</a> Consider removal of <tt>native_handle()</tt></h3>
<p><b>Section:</b> 33.7.5 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvarany">[thread.condition.condvarany]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-32</b></p>

<p>
Given that the lock type can be something the underlying
doesn't know 'native_handle()' is probably
unimplementable on essentially all platforms.
</p>

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Consider the removal of 'native_handle()'.
</p>





<hr>
<h3><a name="1503" href="1503">1503.</a> "associated asynchronous state" must go</h3>
<p><b>Section:</b> 33.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-35</b></p>
<p>
The term "associated asynchronous state" is long, ugly and misleading terminology. When 
introduced we agreed upon that we should come up with a better name. Here it is: 
"liaison state". Since the state is hidden and provides synchronization of a 
<tt>future</tt> with its corresponding <tt>promise</tt>, we believe "liaison state" is 
a much better and shorter name (liaison ~ (typically hidden) relationship)
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Change all occurrences of "associated
asynchronous state" to "liaison state".
</p></blockquote>


<p><b>Proposed resolution:</b></p>
<p>The project editor may supply a more appopriate term, or use "liaison state",
at his own discretion.</p>





<hr>
<h3><a name="1506" href="1506">1506.</a> <tt>set_exception</tt> with a null pointer</h3>
<p><b>Section:</b> 33.10.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-198</b></p>
<p>
<tt>promise::set_exception</tt> can be called with a null pointer,
but none of the descriptions of the <tt>get()</tt> functions for the
three types of futures say what happens for this case.
</p>
<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add the following sentence to the end of
30.6.5/22: The behavior of a program that calls
<tt>set_exception</tt> with a null pointer is undefined.
</p>





<hr>
<h3><a name="1509" href="1509">1509.</a> No restriction on calling <tt>future::get</tt> more than once</h3>
<p><b>Section:</b> 99 [futures.atomic_future] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-202</b></p>
<p>
The note in this paragraph says "unlike <tt>future</tt>, calling <tt>get</tt>
more than once on the same <tt>atomic_future</tt> object is well
defined and produces the result again." There is nothing
in <tt>future</tt> that says anything negative about calling <tt>get</tt>
more than once.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Remove this note, or add words to the
requirements for future that reflect what this note
says.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1510" href="1510">1510.</a> Should be undefined behaviour to call <tt>atomic_future</tt> operations unless <tt>valid()</tt></h3>
<p><b>Section:</b> 99 [futures.atomic_future] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-203</b></p>
<p>
Both <tt>future</tt> and <tt>shared_future</tt> specify that calling most
member functions on an object for which <tt>valid() == false</tt>
produces undefined behavior. There is no such statement
for <tt>atomic_future</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a new paragraph after 99 [futures.atomic_future]/2 with the same words as
 [futures.shared_future]/3.
</p>

<p><i>[
2010-11-02 Daniel translates proposed changes into specific deltas and comments:
]</i></p>


<blockquote><p>
While applying the wording, I notice that  [futures.shared_future]/3 does
speak of the move-assignment operator, and <em>not</em> of the copy-assignment operator.
<tt>atomic_future</tt> obviously needs this to be true for the copy-assignment operator,
but I strongly assume that <tt>shared_future</tt> needs to mention both special member
assignment operators in this paragraph. To keep this consistent, the following P/R also
provides wording to fix the corresponding location for <tt>shared_future</tt>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change  [futures.shared_future]/3 as indicated:
<blockquote><p>
3 The effect of calling any member function other than the destructor<ins>, the 
copy-assignment operator</ins>, the move-assignment operator, or <tt>valid()</tt> 
on a <tt>shared_future</tt> object for which <tt>valid() == false</tt> is undefined.
</p></blockquote>
</li>
<li>Following 99 [futures.atomic_future]/2, add a new paragraph:
<blockquote><p>
<ins>? The effect of calling any member function other than the destructor, the copy-assignment operator, or <tt>valid()</tt>
on a <tt>atomic_future</tt> object for which <tt>valid() == false</tt> is undefined.</ins>
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="1511" href="1511">1511.</a> Synchronize the move-constructor for <tt>atomic_future</tt></h3>
<p><b>Section:</b> 99 [futures.atomic_future] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-204</b></p>
<p>
According to the definition of <tt>atomic_future</tt>, all members
of <tt>atomic_future</tt> are synchronizing except constructors.
However, it would probably be appropriate for a move
constructor to be synchronizing on the source object. If
not, the postconditions on paragraphs 7-8, might not be
satisfied. This may be applicable if a collection of futures
are being doled out to a set of threads that process their
value.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Make the move constructor for atomic future lock
the source
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1512" href="1512">1512.</a> Conflict in specification: block or join?</h3>
<p><b>Section:</b> 33.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-205</b></p>
<p>
33.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> p. 3: The third sentence says 
"If the invocation is not deferred, a call to a waiting function 
on an asynchronous return object that shares the associated asynchronous state
created by this <tt>async</tt> call shall block until the associated
thread has completed." The next sentence says "If the
invocation is not deferred, the <tt>join()</tt> on the created
thread..." Blocking until a thread completes is not
necessarily a join.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Decide whether the requirement is to block until
finished or to call join, and rewrite to match.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2006" href="2006">2006.</a> <tt>emplace</tt> broken for associative containers</h3>
<p><b>Section:</b> 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2010-10-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current definition of <tt>emplace(args)</tt> for associative containers as
described in Table 99 is:
</p>
<blockquote>
<p>
<i>Requires</i>: <tt>T</tt> shall be constructible from <tt>args</tt>.
<p/>
<i>Effects</i>: Inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element
in the container with key equivalent to the key of <tt>t</tt>.  The <tt>bool</tt>
component of the returned <tt>pair</tt> is <tt>true</tt> if and only if the
insertion takes place, and the iterator component of the <tt>pair</tt>
points to the element with key equivalent to the key of <tt>t</tt>.
</p>
</blockquote>
<p>
There is similar language in Table 100 for unordered associative containers.
<p/>
The first issue is editorial: <tt>T</tt> should be <tt>value_type</tt> throughout
both tables.
<p/>
The major issue is that, if the container is <tt>map</tt>, <tt>multimap</tt>,
<tt>unordered_map</tt>, or <tt>unordered_multimap</tt>, then the only way to
construct an object of <tt>value_type</tt> is to supply exactly two arguments
for <tt>Key</tt> and <tt>Value</tt>, a <tt>pair&lt;Key,Value&gt;</tt>, or a
<tt>piecewise_construct_t</tt> followed by two <tt>tuple</tt>s.  The original
<tt>emplace()</tt> proposal would have allowed you to specify a <tt>Key</tt>
value followed by any number of constructor arguments for <tt>Value</tt>.
When we removed the variadic constructor to <tt>pair</tt>, this ability went
away.  I don't think that was deliberate.
<p/>
Fixing this is non-trivial, I think. I think that <tt>emplace()</tt> for <tt>map</tt>
and <tt>multimap</tt> need several overloads: one for each overloaded constructor in
<tt>pair&lt;Key,Value&gt;</tt>, and one for the <tt>emplace(Key, valueargs...)</tt> case.
And it probably needs some SFINAE meta-programming to ensure that the last case
doesn't override any of the other ones.  Alternatively, one could say that
there are exactly two cases: <tt>emplace(args)</tt> where <tt>pair&lt;Key,Value&gt;</tt>
is constructible from <tt>args</tt>, and <tt>emplace(args)</tt> where <tt>Key</tt> is
constructible form the first <tt>arg</tt> and <tt>Value</tt> is constructible from the
rest.
<p/>
Alternatively, the status quo is to use <tt>piecewise_construct_t</tt> if you want to
construct an object.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
N3178 was looked at in session and moved to NAD.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2026" href="2026">2026.</a> <tt>hash</tt> should be <tt>std</tt> qualified for unordered container</h3>
<p><b>Section:</b> 24.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-02-07 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Tom Plum pointed out to me that there's an apparent inconsistency in the <tt>std::</tt> qualification of template names in the unordered containers:
</p>

<blockquote><pre>
 template &lt;class Key,
           class T,
           class Hash = hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
   class unordered_map;
</pre></blockquote>

<p>
Is there a reason that hash is not qualified with <tt>std::</tt>? TR1 also
does not use <tt>std::</tt> here.
</p>

<p><i>[
2011-02-07 Chris Jefferson adds:
]</i></p>

<p>
I assumed (I might be wrong) it is because <tt>hash</tt> is designed to be a
customisation point, like <tt>swap</tt>.
</p>

<p><i>[
2011-02-07 Howard Hinnant adds:
]</i></p>

<p>I think this is incorrect.  We mean <tt>std::hash</tt>, though clients
are free to specialize <tt>std::hash</tt> on user-defined types.  With the
possible exception of <tt>begin</tt>/<tt>end</tt> (which I'm not sure if
we've settled that), <tt>swap</tt> is the only intended customization point (look up a function by ADL) in the <tt>std::</tt> lib.
</p>

<p><i>[
2011-02-24 Chris Jefferson adds:
]</i></p>

<p>I recommend NAD, due to 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a> p3:</p>
<blockquote><p>
Whenever a name <tt>x</tt> defined in the standard library is mentioned, the name <tt>x</tt> is assumed to be fully qualified
as <tt>::std::x</tt>, unless explicitly described otherwise. For example, if the Effects section for library function <tt>F</tt>
is described as calling library function <tt>G</tt>, the function <tt>::std::G</tt> is meant.
</p></blockquote>

<p><i>[2011-02-25 Reflector discussion]</i></p>

<p>
Moved to Tentatively NAD after 5 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2036" href="2036">2036.</a> <tt>istream &gt;&gt; char</tt> and <tt>eofbit</tt></h3>
<p><b>Section:</b> 31.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream">issues</a> in [istream].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The question is:  When a single character is extracted from an <tt>istream</tt> using <tt>operator&gt;&gt;</tt>, 
does <tt>eofbit</tt> get set if this is the last character extracted from the stream?  The current standard is at 
best ambiguous on the subject. 31.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a>/p3 describes all extraction operations with:</p>

<blockquote><p>
3 If <tt>rdbuf()-&gt;sbumpc()</tt> or <tt>rdbuf()-&gt;sgetc()</tt> returns <tt>traits::eof()</tt>, then the input 
function, except as explicitly noted otherwise, completes its actions and does <tt>setstate(eofbit)</tt>, which may 
throw <tt>ios_base::failure</tt> (31.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a>), before returning.
</p></blockquote>

<p>And  [istream::extractors]/p12 in describing <tt>operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp; in, charT&amp; c);</tt> 
offers no further clarification:
</p>

<blockquote><p>
12 <i>Effects</i>: Behaves like a formatted input member (as described in [istream.formatted.reqmts]) of <tt>in</tt>. 
After a <tt>sentry</tt> object is constructed a character is extracted from <tt>in</tt>, if one is available, and 
stored in <tt>c</tt>. Otherwise, the function calls <tt>in.setstate(failbit)</tt>.
</p></blockquote>

<p>I coded it one way in libc++, and g++ coded it another way.  Chris Jefferson noted that some boost code was 
sensitive to the difference and fails for libc++.  Therefore I believe that it is very important that we specify 
this extraction operator in enough detail that both vendors and clients know what behavior is required and expected.
</p>

<p>Here is a brief code example demonstrating the issue:</p>

<blockquote><pre>
#include &lt;sstream&gt;
#include &lt;cassert&gt;

int main()
{
  std::istringstream ss("1");
  char t;
  ss &gt;&gt; t;
  assert(!ss.eof());
};
</pre></blockquote>

<p>For every type capable of reading this istringstream but <tt>char</tt>, <tt>ss.eof()</tt> will be true after the 
extraction (<tt>bool</tt>, <tt>int</tt>, <tt>double</tt>, etc.).  So for consistency's sake we might want to have 
<tt>char</tt> behave the same way as other built-in types.</p>

<p>However Jean-Marc Bourguet offers this counter example code using an interactive stream.  He argues that 
setting <tt>eof</tt> inhibits reading the next line:</p>

<blockquote><pre>
#include &lt;iostream&gt;

int main()
{
 char c;
 std::cin &gt;&gt; std::noskipws;
 std::cout &lt;&lt; "First line: ";
 while (std::cin &gt;&gt; c) {
    if (c == '\n') {
       std::cout &lt;&lt; "Next line: ";
    }
 }
}
</pre></blockquote>

<p>As these two code examples demonstrate, whether or not <tt>eofbit</tt> gets set is an observable difference and it 
is impacting real-world code.  I feel it is critical that we clearly and unambiguously choose one behavior or the other.  
I am proposing wording for both behaviors and ask the LWG to choose one (and only one!).</p>

<p>Wording for setting <tt>eof</tt> bit:</p>

<p>Modify  [istream::extractors]/p12 as follows:</p>

<blockquote><p>
12 <i>Effects</i>: Behaves like a formatted input member (as described in [istream.formatted.reqmts]) of <tt>in</tt>. 
After a <tt>sentry</tt> object is constructed a character is extracted from <tt>in</tt>, if one is available, and 
stored in <tt>c</tt>. <del>Otherwise, the function calls <tt>in.setstate(failbit)</tt>.</del>  <ins>If a character is 
extracted and it is the last character in the pending sequence, the function calls <tt>in.setstate(eofbit)</tt>.  
If a character is not extracted the function calls <tt>in.setstate(failbit | eofbit)</tt>.</ins>
</p></blockquote>

<p>Wording for not setting <tt>eof</tt> bit:</p>

<blockquote><p>
12 <i>Effects</i>: Behaves like a formatted input member (as described in [istream.formatted.reqmts]) of <tt>in</tt>. 
After a <tt>sentry</tt> object is constructed a character is extracted from <tt>in</tt><del>, if one is available, 
and stored in <tt>c</tt>. Otherwise, the function calls <tt>in.setstate(failbit)</tt>.</del> <ins>with 
<tt>in.rdbuf()-&gt;sbumpc()</tt>.  If <tt>traits::eof()</tt> is returned, the function calls 
<tt>in.setstate(failbit | eofbit)</tt>.  Otherwise the return value is converted to type <tt>charT</tt> and stored
in <tt>c</tt>.</ins>
</p></blockquote>

<p><i>[2011-02-27: Jean-Marc Bourguet comments]</i></p>


<p>Just for completeness: it [the counter example] doesn't inhibit to read the next line, it inhibits the prompt 
to be put at the appropriate time.</p>

<p>More information to take into account when deciding:</p>

<ul>
<li><p>if I'm reading correctly the section to get boolean values when <tt>boolalpha</tt> is set, there we mandate 
that <tt>eof</tt> isn't set if trying to read past the end of the pending sequence wasn't needed to determine the result.
</p></li>

<li><p>
see also the behaviour of <tt>getline</tt> (which isn't a formatted input function but won't set <tt>eof</tt> 
if it occurs just after the delimiter)
</p></li>

<li><p>
if I'm reading the C standard correctly <tt>scanf("%c")</tt> wouldn't set <tt>feof</tt> either in that situation.
</p></li>
</ul>

<p><i>[2011-02-28: Martin Sebor comments]</i></p>


<p>[Responds to bullet 1 of Jean-Marc's list]</p>

<p>
Yes, this matches the stdcxx test suite for <tt>num_get</tt> and <tt>time_get</tt>
but not <tt>money_get</tt> when the currency symbol is last. I don't see
where in the locale.money.get.virtuals section we specify whether
<tt>eofbit</tt> is or isn't set and when.
<p/>
IMO, if we try to fix the <tt>char</tt> extractor to be consistent we
should also fix all the others extractors and manipulators that
aren't consistent (including <tt>std::get_money</tt> and <tt>std::get_time</tt>).
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Dietmar convinced Howard, that the standard does already say the right words</p>



<p><b>Rationale:</b></p><p>Reading the last character does not set eofbit and the standard says so already</p>

<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2043" href="2043">2043.</a> <tt>std{in,out,err}</tt> should be usable as field names</h3>
<p><b>Section:</b> 31.13 <a href="https://timsong-cpp.github.io/cppwp/c.files">[c.files]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2011-03-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.files">issues</a> in [c.files].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
People often define structs and classes with fields named <tt>stdin</tt>,
<tt>stdout</tt>, or <tt>stderr</tt>. According to 31.13 <a href="https://timsong-cpp.github.io/cppwp/c.files">[c.files]</a>, 
though, these are macros.
<p/>
glibc defines them to themselves, allowing their non-portable use as
field names, while the Mac OS X libc defines them to either <tt>__stdoutp</tt>
or <tt>(&amp;__sF[1])</tt>, etc depending on <tt>__DARWIN_UNIX03</tt>. It's possible to
allow their use while, as far as I can see, only requiring minor
changes to various libc's, so C++1x should allow it.
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Closed as NAD.  This is an extension request that has been an issue for over 20 years.
Supporting the extension would place a burden on the underlying C library that we may
not be in a position to influence.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>In 31.13 <a href="https://timsong-cpp.github.io/cppwp/c.files">[c.files]</a> add "stderr", "stdin", and "stdout" to a new Values section in Table
134 &mdash; Header <tt>&lt;cstdio&gt;</tt> synopsis:</p>

<blockquote>
<table border="1">
<caption>134 &mdash; Header <tt>&lt;cstdio&gt;</tt> synopsis</caption>

<tr>
<th colspan="6" style="text-align:center;">Type Name(s)</th>
</tr>

<tr>
<th colspan="6" style="text-align:left;">Macros:</th>
</tr>

<tr>
<td><tt>BUFSIZ</tt></td>
<td><tt>FOPEN_MAX</tt></td>
<td><tt>SEEK_CUR</tt></td>
<td><tt>TMP_MAX</tt></td>
<td><tt>_IONBF</tt></td>
<td><tt>stdout</tt></td>
</tr>

<tr>
<td><tt>EOF</tt></td>
<td><tt>L_tmpnam</tt></td>
<td><tt>SEEK_END</tt></td>
<td><tt>_IOFBF</tt></td>
<td><tt>stderr</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>FILENAME_MAX</tt></td>
<td><tt>NULL &lt;cstdio&gt;</tt></td>
<td><tt>SEEK_SET</tt></td>
<td><tt>_IOLBF</tt></td>
<td><tt>stdin</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<th style="text-align:left;">Types:</th>
<td><tt>FILE</tt></td>
<td><tt>fpos_t</tt></td>
<td><tt>size_t &lt;cstdio&gt;</tt></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>

<tr>
<th colspan="6" style="text-align:left;">Functions:</th>
</tr>

<tr>
<td colspan="6" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<th colspan="6" style="text-align:left;"><ins>Values:</ins></th>
</tr>

<tr>
<td><ins><tt>stderr</tt></ins></td>
<td><ins><tt>stdin</tt></ins></td>
<td><ins><tt>stdout</tt></ins></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Add a new paragraph after paragraph 2 as indicated:</p>

<blockquote><p>
2 Calls to the function <tt>tmpnam</tt> with an argument of <tt>NULL</tt> may 
introduce a data race (17.6.5.9) with other calls to <tt>tmpnam</tt> with an 
argument of <tt>NULL</tt>.<br/>
See also: ISO C 7.9, Amendment 1 4.6.2.
<p/>
<ins>? The macros <tt>stderr</tt>, <tt>stdin</tt>, and <tt>stdout</tt> shall 
expand to <tt>stderr</tt>, <tt>stdin</tt>, and <tt>stdout</tt>, respectively. 
[<i>Note:</i> This allows uses of <tt>#ifdef</tt> to detect their presence, 
while allowing code in other scopes to use them as identifiers. &mdash; <i>end note</i>]</ins>
</p></blockquote>
</li>

<li><p>In C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a> add "stderr", "stdin", and "stdout" to 
Table 150 &mdash; Standard values:</p>

<blockquote>
<table border="1">
<caption>Table 150 &mdash; Standard values</caption>

<tr>
<td><tt>CHAR_BIT</tt></td>
<td><tt>FLT_DIG</tt></td>
<td><tt>INT_MIN</tt></td>
<td><tt>MB_LEN_MAX</tt></td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><tt>SHRT_MIN</tt></td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><ins><tt>stderr</tt></ins></td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><ins><tt>stdin</tt></ins></td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><ins><tt>stdout</tt></ins></td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><tt>UCHAR_MAX</tt></td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="2046" href="2046">2046.</a> <tt>shared_future(future&lt;R&gt;&amp;&amp;)</tt> should be allowed to throw</h3>
<p><b>Section:</b> 33.10.8 <a href="https://timsong-cpp.github.io/cppwp/futures.shared.future">[futures.shared.future]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2011-04-04 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.shared.future">issues</a> in [futures.shared.future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Requiring the constructor <tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> not to throw
is a pessimisation of the case where a future is returned from a call to
<tt>async(function,launch::deferred)</tt> and possible other cases.
<p/>
Such a future not dealing with multiple threads only needs to keep (a copy of) the function
to be called it later. However, creating a <tt>shared_future</tt> from that future will require more
infrastructure, like space for the value of type <tt>R</tt>, an <tt>exception_ptr</tt>, and a synchronized
reference counter for the <tt>shared_future</tt>'s instances.
<p/>
Enforcing the constructor <tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> not to throw,
implies that any implementation of <tt>future</tt> will need to pre-allocate space for <tt>shared_future</tt>'s
infrastructure, that also requires an operating system resource for synchronization, regardless
if is ever needed.
<p/>
All this came up when discussing D&#47;N3267 and Concurrency Working Group decided that the constructor
<tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> should be allowed to throw.
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Closed as NAD.  Rationale to follow by email...
</p>


<p><b>Proposed resolution:</b></p>

<p>Apply the proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3269.htm">n3269</a></p>






<hr>
<h3><a name="2060" href="2060">2060.</a> <tt>unique_ptr&lt;T[]&gt;(nullptr_t)</tt> missing <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.3.1.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.runtime">[unique.ptr.runtime]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant, Paolo Carlini <b>Opened:</b> 2011-05-27 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.runtime">issues</a> in [unique.ptr.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis in 20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> specifies:
</p><blockquote><pre>
constexpr unique_ptr(nullptr_t) noexcept
</pre></blockquote><p>
which looks correct to me.  However the corresponding constructor in 20.3.1.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.runtime">[unique.ptr.runtime]</a> is missing <tt>noexcept</tt>:
</p><blockquote><pre>
constexpr unique_ptr(nullptr_t) : unique_ptr() { }
</pre></blockquote>

<p><i>[Bloomington, 2011]</i></p>

<p>
Closed as NAD Editorial.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the synopsis in 20.3.1.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.runtime">[unique.ptr.runtime]</a>:</p>
<blockquote><pre>
namespace std {
  template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt; {
  public:
    typedef see below pointer;
    typedef T element_type;
    typedef D deleter_type;

    // 20.7.1.3.1, constructors
    constexpr unique_ptr() noexcept;
    [&hellip;]
    constexpr unique_ptr(nullptr_t) <ins>noexcept</ins> : unique_ptr() { }
	
    [&hellip;]
  };
}
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2068" href="2068">2068.</a> <tt>std::pair</tt> not C++03-compatible with defaulted copy c'tor</h3>
<p><b>Section:</b> 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-06-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of the copy semantics of the C++03 version of <tt>std::pair</tt>
is defined by the class synopsis in [lib.pairs]:
</p>
<blockquote><pre>
template &lt;class T1, class T2&gt;
struct pair {
  typedef T1 first_type;
  typedef T2 second_type;

  T1 first;
  T2 second;
  pair();
  pair(const T1&amp; x, const T2&amp; y);
  template&lt;class U, class V&gt; pair(const pair&lt;U, V&gt; &amp;p);
};
</pre></blockquote>
<p>
The effect of this specification is, that the copy constructor is compiler-declared
with the proper form depending on the contained member types. In particular, the
instantiation of <tt>pair</tt> is well-formed with an element type that has a
copy constructor with non-const first parameter type like specialzations of <tt>auto_ptr</tt>
or any user-defined type like the following one:
</p>
<blockquote><pre>
struct A {
  A(A&amp;){}
};
</pre></blockquote>
<p>
In contrast to container types which require <tt>CopyConstructible</tt> value types, the C++03 <tt>pair</tt> 
does support these, albeit unusual, element types.
<p/>
The FDIS version of the <tt>std::pair</tt> specification does specify the same semantics by 
defaulting the copy and move constructor in 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a>:
</p>
<blockquote><pre>
template &lt;class T1, class T2&gt;
struct pair {
  typedef T1 first_type;
  typedef T2 second_type;

  T1 first;
  T2 second;
  <span style="color:#C80000">pair(const pair&amp;) = default;</span>
  <span style="color:#C80000">pair(pair&amp;&amp;) = default;</span>
  pair();
  [&hellip;]
};
</pre></blockquote>
<p>
But according to the current core rules this makes the instantiation of e.g. <tt>std::pair&lt;A, int&gt;</tt>
ill-formed, because of the <tt>const</tt> mismatch of the compiler-declared form of the copy constructor
with that of the defaulted declaration.
<p/>
Unfortunately there seems to be no simple library solution for this problem. If the defaulted declarations
were removed, both copy c'tor and move c'tor would be <b>deleted</b>, because there exist user-declared
copy assignment and move assignment operators in the FDIS. But these operations need to be user-defined 
to realize the wanted semantics of these operations for element types that are reference types. If core
rules would not be changed to fix that, I see the following options:
</p>
<ol>
<li>Intentionally decide to break the support for element types with non-const copy c'tors in <tt>pair</tt>.</li>
<li>User-declare both copy and move ctor to at least support the instantiation of the <tt>pair</tt> specializations, 
but this would still not allow to copy them by the copy constructor.</li>
<li>User-declare both the const and non-const copy ctors, the move ctor, and additionally the non-const copy assignment
operator to support the instantiation of the <tt>pair</tt> specializations and of these members. This would 
support all element types as it did in C++03, but all copy&#47;move members would be non-trivial.</li>
<li>Intentionally decide to give up support for element types that are references for <tt>pair</tt>, but
still keep the allocator support with the effect of removing all declarations of the special
copy&#47;move members. User code that needs to use <tt>tuple</tt> instead. But this would be a rather
drastic step requiring further corrections of the draft, e.g. a change of the signature of the algorithm
<tt>minmax</tt> (not the overload with the <tt>initializer_list</tt>) with a different return type.</li>
</ol>
<p>
This problem does <b>not</b> extend as backward-compatibility problem to <tt>tuple</tt>, because the TR1 
specification did explicitly declare copy constructor and copy assignment operator via the &quot;normal&quot; 
form:
</p>
<blockquote><pre>
tuple(const tuple&amp;);
tuple&amp; operator=(const tuple&amp;);
</pre></blockquote>
<p>
</p>

<p><i>[Bloomington, 2011]</i></p>

<p>
Closed as NAD.
</p>

<p>
This is an unfortunate change of behavior between C++03 and C++11, but is consistent with <tt>tuple</tt>.  There is no desire to go to lengths supporting types like <tt>auto_ptr</tt> now that rvalue references are in the language.
</p>

<p>
There may be an issue for Core/EWG to look at, so that some simple <tt>=default</tt> syntax could be used that would do the right thing.  If such a facility became availabile, LWG might revisit this issue.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2073" href="2073">2073.</a> Library exceptions that take string arguments</h3>
<p><b>Section:</b> 19.2 <a href="https://timsong-cpp.github.io/cppwp/std.exceptions">[std.exceptions]</a>, 19.5.8 <a href="https://timsong-cpp.github.io/cppwp/syserr.syserr">[syserr.syserr]</a>, 99 [ios::failure] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Eelis van der Weegen <b>Opened:</b> 2011-08-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#std.exceptions">issues</a> in [std.exceptions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This is an extension issue for LWG to add constructor overloads that take a 
<tt>string</tt> by an rvalue reference in order to move the string into the 
exception.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to NAD.
</p>
<p>
This was discussed during C++11 standardization, and deemed (at the time) to be a conforming
extension that vendors are free to add, but there seemed no need to call it out in the standard.
Since then it has been noted that the rvalue-reference overloads do not give you the move-semantic
guarantee the proposer is thought to be looking for, as in order to meet the requirements that
copy constructors do not throw (for standard exceptions) the exceptions that store strings must
actually store a reference-counted immutable string, rather than an <tt>std::string</tt> internally.
Therefore, an rvalue-reference overload is going to have to allocate memory in exactly the same
way as copying from a <tt>const string&amp;</tt> argument.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2079" href="2079">2079.</a> Required <tt>pow()</tt> overloads</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2011-08-29 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
LWG issue <a href="550">550</a> removed the functions:
</p>
<blockquote><pre>
float       pow(float, int);
double      pow(double, int);
long double pow(long double, int);
</pre></blockquote>
<p>
from header <tt>&lt;cmath&gt;</tt>. This change does not seem to be mentioned in Annex C, C.2.14.
<p/>
Howard:
</p>
<blockquote><p>
N3290 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a>&#47;p11 says:
</p><blockquote>
<p>
Moreover, there shall be additional overloads sufficient to ensure:
</p>
<ol>
<li>If any argument corresponding to a <tt>double</tt> parameter has type <tt>long double</tt>, 
then all arguments corresponding to <tt>double</tt> parameters are effectively cast to 
<tt>long double</tt>.
</li>
<li>Otherwise, if any argument corresponding to a <tt>double</tt> parameter has type <tt>double</tt> 
or an integer type, then all arguments corresponding to <tt>double</tt> parameters are effectively 
cast to <tt>double</tt>.
</li>
<li>Otherwise, all arguments corresponding to <tt>double</tt> parameters are effectively cast to 
<tt>float</tt>.
</li>
</ol>
</blockquote>
<p>
From C99 7.12.7.4 we have:
</p>
<blockquote><pre>
double pow(double, double);
</pre></blockquote>
<p>
28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a>&#47;p11&#47;b2 says that if the client calls <tt>pow(2.0f, 2)</tt>, then the 
<tt>int</tt> for second argument causes the following effective call to be made:
</p>
<blockquote><pre>
pow(static_cast&lt;double&gt;(2.0f), static_cast&lt;double&gt;(2)) -&gt; double
</pre></blockquote>
<p>
The first sentence of p11 implies that this is done by supplying the following additional overload:
</p>
<blockquote><pre>
double pow(float, int);
</pre></blockquote>
<p>
If the client calls <tt>pow(2.0, 2)</tt>, then the same reasoning (b2 again) implies the following 
additional overload:
</p>
<blockquote><pre>
double pow(double, int);
</pre></blockquote>
<p>
If the client calls <tt>pow(2.0l, 2)</tt>, then b1 implies the following additional overload:
</p>
<blockquote><pre>
long double pow(long double, int);
</pre></blockquote>
<p>
In all, p11 implies hundreds (perhaps thousands?) of extra overloads.  All but one of which is a superset 
of the overloads required by C++98&#47;03 (that one being <tt>pow(float, int)</tt> which had its return 
type changed from <tt>float</tt> to <tt>double</tt>).
<p/>
In practice, at least some vendors implement p11 by using templated overloads as opposed to ordinary overloads.
</p></blockquote>

<p>
Steve Clamage:
</p>
<blockquote><p>
Thanks. I didn't see that those extra overloads were actually implied by p11, despite the first sentence. 
Without examples, the point is a bit subtle (at least for me).
</p></blockquote>

<p><i>[2015-05-05 Lenexa: Move to NAD]</i></p>

<p>Billy: I believe this is NAD.</p>
<p>STL: Oh, Steve himself agrees.</p>
<p>Wakely: The issue marked as NAD will be sufficient.</p>
<p>STL: Yes, we should get rid of this.</p>
<p>Billy: I don't see any minutes from Issaquah.</p>
<p>Marshall: Since Steve agrees, does anyone object to marking as NAD?</p>
<p>Nope.</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2082" href="2082">2082.</a> Misleading complexity requirements in <tt>&lt;algorithm&gt;</tt></h3>
<p><b>Section:</b> 27 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-09-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>partition_point()</tt> algorithm is specified with:
</p>
<blockquote><p>
<i>Complexity</i>: <i>O(log(last - first))</i> applications of <tt>pred</tt>.
</p></blockquote>
<p>
While this is correct, it gives the impression that this is a logarithmic algorithm.
But unless random access iterators are used it is not logarithmic because for advancing 
the iterator we have last-first steps, which means that the complexity becomes linear here.
<p/>
Shouldn't we clarify the complexity here to something like:
</p>
<blockquote><p>
<i>Complexity</i>: logarithmic for random-access iterators and linear otherwise
            (in any case <i>O(log(last - first)</i>) applications of <tt>pred</tt>).
</p></blockquote>
<p>
Or should we even require <i>O(log(last - first)</i> for random-access iterators only because 
for other iterators just iterating over all elements, while calling <tt>pred</tt> for each element, 
might often be faster.
</p>

<p>
Daniel Kr&uuml;gler:
</p>
<blockquote><p>
I agree that especially this description is a bit misleading. I'm not
convinced that this is a real defect, because the whole bunch of
templates within <tt>&lt;algorithm&gt;</tt> document the complexity solely of
<em>applications*</em> of predicates, assignment, or swaps, but never the
complexity of traversal operations (e.g. increment or iterator
equality tests). This means, the standard is consistent for this
function template, even though it could say a bit more.
<p/>
I would like to see a wording improvement, but I would rather think that
the complexity of the predicate should be mentioned first (as in other
algorithms) and that a non-normative note could be added for
specifically this algorithm to point out that this does not imply
a logarithmic traversal complexity. The note could give more details,
by explicity pointing out the linear traversal complexity for
non-random-Access iterators.
</p></blockquote>
<p>
Howard Hinnant:
</p>
<blockquote><p>
If we are going to make such improvements, they should be made across the 
board in <tt>&lt;algorithm&gt;</tt>, not to just <tt>partition_point</tt>.  
For example all 4 algorithms in 27.8.4 <a href="https://timsong-cpp.github.io/cppwp/alg.binary.search">[alg.binary.search]</a> have the 
same issue, and have since C++98.
<p/>
<tt>stable_partition</tt> and <tt>inplace_merge</tt> should be inspected as well.
<p/>
Perhaps a new paragraph in 27.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a>, similar to 
p12 would be a better place to address this issue.
</p></blockquote>

<p><i>[2012, Kona]</i></p>

<p>
Move to NAD.
</p>
<p>
There was some concern that the issue, if it were to be addressed, is much larger than
the couple of algorithms called out here, and applies across the whole library.  There
is no interest in looking at this or similar issues without a paper addressing the whole
library.  In fairness to anyone considering writing such a paper, it should be noted
that there was not much interest in such a paper in the group, although no strong opposition
either.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2084" href="2084">2084.</a> <tt>basic_string</tt> use of <tt>charT*</tt></h3>
<p><b>Section:</b> 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2011-09-11 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
For C++11 we gave all of the containers, including basic_string new generalized pointer types:
</p>

<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::pointer       pointer:
typedef typename allocator_traits&lt;Allocator&gt;::const_pointer const_pointer;
</pre></blockquote>

<p>
However, the constructors, assignment, and member functions still traffic exclusively in terms 
of <tt>const charT*</tt>, for example:
</p>

<blockquote><pre>
basic_string(const charT* s, const Allocator&amp; a = Allocator());
</pre></blockquote>

<p>
Was this an oversight? Did we mean instead:
</p>

<blockquote><pre>
basic_string(const_pointer s, const Allocator&amp; a = Allocator());
</pre></blockquote>

<p><b>Rationale:</b></p><p>
It's intentional. <tt>char_traits</tt> assumes that all elements of
a string can be accessed indirect on plain pointers. So <tt>basic_string</tt> 
doesn't support allocators with fancy pointers or references. And we meant 
to do that.
<p/>
Let's take the constructor example you called out:
</p>

<blockquote><pre>
basic_string(const charT* s, const Allocator&amp; a = Allocator());
</pre></blockquote>

<p>
This constructor allows us to create a <tt>basic_string</tt> object from a string literal.  
If we were to change the pointer type, that would no longer be possible.
<p/>
There is no issue here, as the implementation of the constructor must make a 
copy of the string pointed-to by the pointer 's' rather than adopt ownership of 
that buffer. It is that internal copy that must make use of the <tt>allocator::pointer</tt> type.
<p/>
Now what about the return value of '<tt>c_str()</tt>', should that return an <tt>allocator::pointer</tt>?
<p/>
Again, the answer (I believe) is 'no' because this is the function that allows us 
to pass the string's contents to a legacy&#47;OS 'C' API. It is deliberately returning 
a raw pointer for a reason.
<p/>
There was an issue where <tt>vector::data</tt> was changed to return an <tt>allocator::pointer</tt>
to the internal buffer, and this was changed back exactly because this was intended 
to support passing to external APIs.
<p/>
Do we have a use-case where the pointer type of internal data structures of our 
containers (notably <tt>basic_string</tt> and <tt>vector</tt>) need to be exposed through a public API?  
All my current use-cases for <tt>allocator::pointer</tt> are specific to the implementation 
of containers themselves.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2090" href="2090">2090.</a> Minor Overconstraint in Mutex Types</h3>
<p><b>Section:</b> 33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-10-17 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements.mutex">issues</a> in [thread.mutex.requirements.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>&#47;6, fourth bullet requires the 
return type of <tt>m.lock()</tt> to be <tt>void</tt>. 
<p/>
This is over-constrained. The true requirement is that the standard library 
ignores any value that the function returns. Yes, allowing non-void return 
types means that users can't store a pointer to this member function. No, 
that's not the least bit important.
<p/>
[See also the discussion following c++std-lib-31318]
</p>

<p><i>[2012, Kona]</i></p>

<p>
This does not specify a concept; it specifies requirements on the concrete mutex types. 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2107" href="2107">2107.</a> Some iterator category should guarantee the lifetime of references</h3>
<p><b>Section:</b> 25.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2011-11-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Many iterators guarantee that references and pointers returned from
their methods will outlive the iterator itself. Other useful iterators
can't guarantee this, leading to the rule in 25.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> 
p9 that "Destruction of an iterator may invalidate pointers and references 
previously obtained from that iterator."
<p/>
Some algorithms can take advantage of long-lived references by
returning them, while they can adapt to short-lived references by
returning by value instead. However, there doesn't seem to be a way in
the standard to distinguish between these two types of iterators.
<p/>
The <tt>ForwardIterator</tt> requirements come close by saying "If <tt>a</tt> and <tt>b</tt> are
both dereferenceable, then <tt>a == b</tt> if and only if <tt>*a</tt> and <tt>*b</tt> are bound
to the same object." (25.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> p6) However, there are some
subtle ways to satisfy this rule and still return a short-lived reference, meaning 
algorithms can't be guaranteed that <tt>forward_iterator_tag</tt> will imply 
long-lived references.
<p/>
On the other hand, defect <a href="198">198</a>, which added the invalidation wording
to iterator.requirements.general, refers to iterators with short-lived references 
being used as arguments to reverse_iterator, which requires <tt>BidirectionalIterator</tt>s. 
If <tt>ForwardIterator</tt> required long-lived references, this would be impossible.
<p/>
Either <tt>ForwardIterator</tt> should be clarified to require long-lived
references, or a new category should be added that does.
<p/>
See also the discussion around c++std-lib-31477.
<p/>
Daniel: Related to this issue is that when applying <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
we unintentionally lost some forward iterator requirements from C++03, where we 
had the post-conditions <tt>a == X(a)</tt> of <tt>X(a)</tt>, and <tt>u == a</tt> 
of any copy operation from <tt>a</tt> to <tt>u</tt>. This wording must be restored as well.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to NAD.
</p>
<p>
This issue affects only Input Iterators, as all other categories are required to return
a native reference, and are not (currently) allowed to return proxies.  The issue with
Input Iterators is known, and has been present since the original standard.  Any change
in this regard would be an extension requiring a more substantial paper than treatment
as a simple issue.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2113" href="2113">2113.</a> Do library implementers have the freedom to add <tt>final</tt> to non-polymorphic components?</h3>
<p><b>Section:</b> 16.4.6 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-11-30 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#conforming">issues</a> in [conforming].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Related to LWG <a href="2112">2112</a> the question has been raised whether a library implementation <em>may</em> declare
non-polymorphic library components, such as class template <tt>std::vector</tt> or <tt>std::basic_string</tt>,
as <tt>final</tt> class types.
<p/>
This issue is <em>not</em> suggesting to enforce that libraries are required to do that, it is asking
whether libraries should have the freedom to do so.
<p/>
The existing wording in 16.4.6.12 <a href="https://timsong-cpp.github.io/cppwp/derivation">[derivation]</a> does not give a clear permission to do so. In my opinion
this position should be clarified in either direction.
<p/>
Giving implementations this freedom would have both advantages and disadvantages. Several opponents where
worried about breakage of code of existing user implementations. On the other hand such types where not
designed to be used as base classes. Allowing implementations to mark these components as <tt>final</tt>
could allow them to provide compile-modes that are intentionally restrictive to the advantage of user code
that want to be alterted about that. Any implementation that would be concerned about user complaints would 
not take advantage of this feature anyway.
<p/>
If agreement exists that such implementation freedom would be useful, wording like
</p>
<blockquote><p>
An implementation may declare additional non-virtual member function signatures within a class as <tt>final</tt>.
</p></blockquote>
<p>
or
</p>
<blockquote><p>
An implementation may declare additional class without virtual member function signatures as <tt>final</tt>.
</p></blockquote>
<p>
should be added to 16.4.6 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> with corresponding exceptions of these rules (e.g. <tt>iterator</tt>,
<tt>unary_function</tt>, or <tt>pair</tt>).
<p/>
If such freedom should not exist, it seems better to clarify this as well, e.g. by adding around 16.4.6.12 <a href="https://timsong-cpp.github.io/cppwp/derivation">[derivation]</a>:
</p>
<blockquote><p>
An implementation shall not declare any class or any member function signature as <tt>final</tt>.
</p></blockquote>


<p><i>[2012, Kona]</i></p>

<p>
Move to NAD.
</p>
<p>
Unless the library uses the keyword <tt>final</tt> in a specification, the user clearly has
freedom to derive from such a class, and so equally clearly, the library vendor does not have
freedom to add a <tt>final</tt> overrider or class attribute.  Howard observed there may be
some wiggle-room with 'unspecified types' such as those returned from <tt>bind</tt> expressions,
or iterators, but we did not see a need to further clarify the issue.  Note that, for example,
a <tt>vector::iterator</tt> may be implemented as a raw pointer, so users cannot generally
assume the ability to derive from unspecified library types.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2121" href="2121">2121.</a> <tt>app</tt> for string streams</h3>
<p><b>Section:</b> 31.8.5.2 <a href="https://timsong-cpp.github.io/cppwp/stringstream.cons">[stringstream.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2012-01-15 <b>Last modified:</b> 2018-06-07 21:31:22 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This issue was raised while discussing issue <a href="1448">1448</a>.
<p/>
Note the following program:
</p>
<blockquote><pre>
string s("s1: 123456789");
ostringstream s1(s, ios_base::out|ios_base::app);
s1 &lt;&lt; "hello";
cout &lt;&lt; s1.str() &lt;&lt; endl;
</pre></blockquote>
<p>
With g++4.x it prints:
</p>
<blockquote><pre>
s1: 123456789hello
</pre></blockquote>
<p>
With VisualC++10 it prints:
</p>
<blockquote><pre>
hello23456789
</pre></blockquote>
<p>
From my intuitive understanding the flag "app" should result in the output of g++4.x.
I also would read that from  [ios::openmode] claiming:
</p>
<blockquote><p>
<tt>app</tt>&nbsp;&nbsp;&nbsp;seek to end before each write
</p></blockquote>
<p>
However in issue <a href="1448">1448</a> P.J.Plauger comments:
</p>
<blockquote><p>
I think we should say nothing special about <tt>app</tt> at construction time (thus leaving the write pointer at the beginning of the buffer).
Leave implementers wiggle room to ensure subsequent append writes as they see fit, but don't change existing rules for initial seek
position.
</p></blockquote>
<p>
Note that the flag <tt>ate</tt> on both platforms appends "hello" to <tt>s</tt>.
</p>

<p><i>[2018-06; Rapperswil Wednesday evening]</i></p>

<p>
MC: shouldn't this be Open?<br/>
BO: I think we changed it to do the same thing as gcc<br/>
JM: NAD - gcc is right<br/>
ACTION close as NAD, noting that gcc is right 
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2124" href="2124">2124.</a> Seed sequence over-specified</h3>
<p><b>Section:</b> 28.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2012-01-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.seedseq">issues</a> in [rand.req.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The seed sequence requirements described in 28.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> appear to be over-specified. 
All seed sequence types are required to have a <tt>result_type</tt> nested type, a specific set of 
constructors, function members <tt>size()</tt> and <tt>param()</tt>, which are never used by the library. 
In fact, the only library components that actively use seed sequences are the random engines and all the 
engines need is the <tt>generate()</tt> member function. In particular, library components never attempts 
to construct seed sequence objects. These extraneous requirements are clearly written to describe the 
library provided type <tt>seed_seq</tt> type; while it's good that seed_seq has all those constructors and 
members, it's not a compelling reason to require a user-provided seed sequence type to implement all of 
them.
<p/>
Suppose I want to write my own seed sequence class, this should do fine (and actually works as expected with libc++):
</p>
<blockquote><pre>
class my_seed_seq
{
  /* internals */
public:
  my_seed_seq(/* my own parameters */);

  template &lt;class It&gt;
  void generate(It first, It last);
};

my_seed_seq s(/* params */);
std::default_random_engine e(s);
</pre></blockquote>
<p>
The only reason to have these extra members would be to provide some support for generic serializability&#47;persistence 
of seed sequence objects. I believe that would be out of the scope of the random library, so I doubt we will ever need 
those requirements in the future.
<p/>
I therefore propose to remove all requirements from 28.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> except for the presence of the 
<tt>generate()</tt> function.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Tenatively NAD.  (Tentative as issue was not in pre-meeting mailing)
</p>
<p>
The 'overspecification', as such, was a deliberate intent to provide guarantees consumers of the whole
random number framework may rely upon, especially in generic code.  While the standard engines may be
built without relying on these guarantees, this specification is part of a commitment to a broader
framework, and Walter indicated future proposals in preparation for parallel generation of random
numbers that may depend more inimately on these existing requirements.
</p>
<p>
Alisdair noted that the <tt>result_type</tt> typedef was a call-back to how we used to specify
adaptable functors before TR1 <tt>result_of</tt> and the addition of <tt>std::bind</tt> and is
probably not something we should be actively promoting in future libraries.  However, it is too
late to remove this requirement from seed sequences unless we are doing further surgery, as
recommended by this issue.
</p>
<p>
Walter notes that the <tt>result_type</tt> protocol has not been formally deprecated by the
standard.  Alisdair replies that was the intent of deprecating the <tt>bind_1st</tt>/
<tt>unary_function</tt> set of templates in C++11, although we did not say anything about
<tt>result_type</tt> in general.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Edit 28.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> p2 as indicated:</p>

<blockquote><p>
A class <tt>S</tt> satisfies the requirements of a seed sequence if the expressions shown in Table 115 are valid and
have the indicated semantics, and if <tt>S</tt> also satisfies all other requirements of this section 28.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a>. 
In that Table and throughout this section:
</p>
<ol style="list-style-type:lower-alpha">
<li>
<del><tt>T</tt> is the type named by <tt>S</tt>'s associated <tt>result_type</tt>;</del>
</li>
<li>
<tt>q</tt> is a value of <tt>S</tt><del> and <tt>r</tt> is a possibly const value of <tt>S</tt></del>; <ins>and</ins>
</li>
<li>
<del><tt>ib</tt> and <tt>ie</tt> are input iterators with an unsigned integer <tt>value_type</tt> of at least 32 bits;</del>
</li>
<li><tt>rb</tt> and <tt>re</tt> are mutable random access iterators with an unsigned integer <tt>value_type</tt> of at least 32 bits;</li>
<li>
<del><tt>ob</tt> is an output iterator; and</del>
</li>
<li>
<del><tt>il</tt> is a value of <tt>initializer_list&lt;T&gt;</tt>.</del>
</li>
</ol>
</blockquote>
</li>

<li>
<p>Ditto, in Table 115, remove all rows except the one describing <tt>q.generate(rb, re)</tt>:</p>

<table border="1">
<caption>Table 115 &mdash; Seed sequence requirements</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Pre&#47;Post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<del><tt>S::result_type</tt></del>
</td>
<td>
<del><tt>T</tt></del>
</td>
<td>
<del><tt>T</tt> is an unsigned integer<br/>
type (6.8.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>) of at least 32 bits.</del>
</td>
<td>
<del>compile-time</del>
</td>
</tr>

<tr>
<td>
<del><tt>S()</tt></del>
</td>
<td>
&nbsp;
</td>
<td>
<del>Creates a seed sequence with<br/>
the same initial state as all<br/>
other default-constructed seed<br/>
sequences of type <tt>S</tt>.</del>
</td>
<td>
<del>constant</del>
</td>
</tr>

<tr>
<td>
<del><tt>S(ib,ie)</tt></del>
</td>
<td>
&nbsp;
</td>
<td>
<del>Creates a seed sequence having<br/>
internal state that depends on<br/>
some or all of the bits of the<br/>
supplied sequence <tt>[ib, ie)</tt>.</del>
</td>
<td>
<del><tt>&#x1d4aa;(ie - ib)</tt></del>
</td>
</tr>

<tr>
<td>
<del><tt>S(il)</tt></del>
</td>
<td>
&nbsp;
</td>
<td>
<del>Same as <tt>S(il.begin(),<br/>
il.end())</tt>.</del>
</td>
<td>
<del>same as<br/>
<tt>S(il.begin(),<br/>
il.end())</tt></del>
</td>
</tr>

<tr>
<td>
<tt>q.generate(rb,re)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
Does nothing if <tt>rb == re</tt>.<br/>
Otherwise, fills the supplied<br/>
sequence <tt>[rb, re)</tt> with 32-bit<br/>
quantities that depend on the<br/>
sequence supplied to the<br/>
constructor and possibly also<br/>
depend on the history of<br/>
<tt>generate</tt>'s previous<br/>
invocations.
</td>
<td>
<tt>&#x1d4aa;(re - rb)</tt>
</td>
</tr>

<tr>
<td>
<del><tt>r.size()</tt></del>
</td>
<td>
<del><tt>size_t</tt></del>
</td>
<td>
<del>The number of 32-bit units that<br/>
would be copied by a call to<br/>
<tt>r.param</tt>.</del>
</td>
<td>
<del>constant</del>
</td>
</tr>

<tr>
<td>
<del><tt>r.param(ob)</tt></del>
</td>
<td>
<del><tt>void</tt></del>
</td>
<td>
<del>Copies to the given destination
a sequence of 32-bit units that<br/>
can be provided to the<br/>
constructor of a second object<br/>
of type <tt>S</tt>, and that would<br/>
reproduce in that second object<br/>
a state indistinguishable from<br/>
the state of the first object.</del>
</td>
<td>
<del><tt>&#x1d4aa;(r.size())</tt></del>
</td>
</tr>

</table>
 </li>

</ol>






<hr>
<h3><a name="2125" href="2125">2125.</a> <tt>TimedMutex</tt> specification problem</h3>
<p><b>Section:</b> 33.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>, 33.6.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.class">[thread.timedmutex.class]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Pending NAD Editorial</a>
 <b>Submitter:</b> Vicente J. Botet Escriba <b>Opened:</b> 2012-01-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.timedmutex.requirements">issues</a> in [thread.timedmutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Pending NAD Editorial">Pending NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
33.6.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.class">[thread.timedmutex.class]</a> says:
</p>
<blockquote><p>
The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex</tt> requirements (33.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>). 
It shall be a standardlayout class (Clause 11 <a href="https://timsong-cpp.github.io/cppwp/class">[class]</a>).
</p></blockquote>
<p>
Problem here is that 33.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a> does not define a requirement set named &quot;<tt>TimedMutex</tt>&quot;,
it only refers to &quot;<i>timed mutex types</i>&quot;
</p>

<p><i>[See also issue <a href="2126">2126</a>]</i></p>


<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
We have timed mutex type, but it is labeled timed mutex requirements
</p>
<p>
We can make a suggestion, but will send to the editor as it seems purely editorial.
There is a typo, and we don't have the timed mutex but 33.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a> already
says timed mutex type, and we need to reuse that term down in the class to fulfil the mutex requirement.
</p>
<p><i>[To Editor:]</i></p>

<p>
Replace this one with timed mutex type.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2126" href="2126">2126.</a> Several specification problems in regard to mutex requirements</h3>
<p><b>Section:</b> 33.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>, 33.6.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a>, 33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>, 33.6.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.recursive">[thread.mutex.recursive]</a>, 33.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>, 33.6.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.class">[thread.timedmutex.class]</a>, 33.6.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.recursive">[thread.timedmutex.recursive]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Pending NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-01-16 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Pending NAD Editorial">Pending NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
 33.6.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a>&#47;3 says that the class mutex "shall satisfy all the <tt>Mutex</tt> requirements (33.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>)". 
 33.6.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a> is part of 33.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a>, so at the very least, this 
 requirement is recursive. But worse, there is nothing that says what "the <tt>Mutex</tt> requirements" refers to. For example, 
 the "<tt>Lockable</tt> requirements" section starts with "A type <tt>L</tt> meets the <tt>Lockable</tt> requirements if &hellip;". There is no such 
 statement for "the <tt>Mutex</tt> requirements".
<p/>
Organizationally, paragraphs 1-26 in 33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a> should probably be in a subclause with a name. 
(This is actually an ISO requirement, to avoid exactly this kind of ambiguous referencing) Then the first sentence of 
33.6.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.class">[thread.mutex.class]</a>&#47;3 can become a note: "The class mutex meets the requirements of (whatever)", since that 
subclause already says that the mutex types "shall meet the requirements set out in this section."
<p/>
And similarly for 33.6.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.recursive">[thread.mutex.recursive]</a>&#47;2 (<tt>recursive_mutex</tt>).
<p/>
33.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a>, Timed mutex types, also needs the same rearrangement: its introductory 
requirements should be moved into a subclause, and the first sentences of 33.6.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.class">[thread.timedmutex.class]</a>&#47;2 
and 33.6.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.recursive">[thread.timedmutex.recursive]</a>&#47;2 should be turned into notes that refer to this new subclause and 
to the new subclause in 33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>.
</p>

<p><i>[See also issue <a href="2125">2125</a>]</i></p>


<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
Seems no real ambiguity. May need some reorg of text rather then changing the wording.
</p>
<p>
Is there much that needs to be changed? But Pete's suggestion of putting requirement in separate sub section is good.
Should be the direction to editor.
</p>
<p>
Suggest this is an editorial change. Happy with Pete's comments.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2131" href="2131">2131.</a> Member function getline taking a string as parameter</h3>
<p><b>Section:</b> 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Lo&iuml;c Joly <b>Opened:</b> 2012-03-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think the following code should be legal:
</p>
<blockquote><pre>
void f(std::istream&amp; is)
{
  std::string s;
  is.getline(s); // Would be equivalent to std::getline(is, s)
}
</pre></blockquote>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Unanimous that this is a new feature request and not a issue. 
<p/>
Resolution: Tentatively NAD 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change the class template <tt>basic_istream</tt> synopsis, 31.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/istream">[istream]</a>, as indicated</p>
<blockquote><pre>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_istream : virtual public basic_ios&lt;charT,traits&gt; {
  public:
    [&hellip;]
    <i>// 27.7.2.3 Unformatted input:</i>
    [&hellip;]
    basic_istream&lt;charT,traits&gt;&amp; getline(char_type* s, streamsize n);
    basic_istream&lt;charT,traits&gt;&amp; getline(char_type* s, streamsize n,
      char_type delim);
    <ins>template&lt;class Allocator&gt;
    basic_istream&lt;charT,traits&gt;&amp; getline(basic_string&lt;charT,traits,Allocator&gt;&amp; str);
    template&lt;class Allocator&gt;
    basic_istream&lt;charT,traits&gt;&amp; getline(basic_string&lt;charT,traits,Allocator&gt;&amp; str,
      char_type delim);</ins>
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Insert the following two new prototype descriptions after 31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a> paragraph 24:</p>

<blockquote>
<pre>
basic_istream&lt;charT,traits&gt;&amp; getline(char_type* s, streamsize n);
</pre>
<blockquote><p>
-24- <i>Returns</i>: <tt>getline(s,n,widen('\n'))</tt>
</p>
</blockquote>

<pre>
<ins>template&lt;class Allocator&gt;
basic_istream&lt;charT,traits&gt;&amp; getline(basic_string&lt;charT,traits,Allocator&gt;&amp; str);</ins>
</pre>
<blockquote><p>
<ins>-??- <i>Returns</i>: <tt>std::getline(*this, str)</tt></ins>
</p>
</blockquote>

<pre>
<ins>template&lt;class Allocator&gt;
basic_istream&lt;charT,traits&gt;&amp; getline(basic_string&lt;charT,traits,Allocator&gt;&amp; str, char_type delim);</ins>
</pre>
<blockquote><p>
<ins>-??- <i>Returns</i>: <tt>std::getline(*this, str, delim)</tt></ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>






<hr>
<h3><a name="2134" href="2134">2134.</a> Redundant Mutex requirement?</h3>
<p><b>Section:</b> 33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Pending NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-03-05 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements.mutex">issues</a> in [thread.mutex.requirements.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Pending NAD Editorial">Pending NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>&#47;11 says that prior unlock operations <em>synchronize with</em> <tt>m.lock()</tt>.
<p/>
33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>&#47;19 says that if <tt>m.try_lock()</tt> succeeds, prior unlock operations 
<em>synchronize with</em> the operation. 
<p/>
33.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>&#47;25 says that <tt>m.unlock()</tt> <em>synchronizes with</em> subsequent 
successful lock operations. 
<p/>
Does the third requirement add anything to the first two? If not, it should probably be a non-normative note.
</p>

<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
Agree that third note should be non-normative and adds nothing.
</p>
<p>
Seems An Editorial change, but does changing a normative to non-normative wording makes it a non-editorial change?
</p>
<p>
Ask the editor. If not editorial, then we will agree on the fix as removal of the third point,
then we will put it in ready state for Bristol.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2161" href="2161">2161.</a> <tt>const</tt> equivalence of <tt>std::map</tt></h3>
<p><b>Section:</b> 24.4 <a href="https://timsong-cpp.github.io/cppwp/associative">[associative]</a>, 24.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bjarne Stroustrup <b>Opened:</b> 2012-06-18 <b>Last modified:</b> 2016-08-02 17:03:45 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
As described in the reflector discussion c++std-core-21860 consider the following example:
</p>
<blockquote><pre>
map&lt;const int, int&gt; mci{};
map&lt;int, int&gt; mi = mci; // ??
mci[1] = 2;
mi[1] = 2;
</pre></blockquote>
<p>
Should it be required that the marked initialization is well-formed? As a possible solution
this could be realized by an alias template:
</p>
<blockquote><pre>
template &lt;class K, class T&gt;
struct OriginalMap { [&hellip;] };

template &lt;class K, class T&gt;
using ImprovedMap = OriginalMap&lt;const K, T&gt;;
</pre></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>
Recommend NAD.  No other container supports conversion from different
container specializations, so adding support directly might be more
surprising than the omission.
</p>

<p>
We would welcome papers on the convertibility of containers of different
element types directed to the LEWG in the future.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2167" href="2167">2167.</a> Copy assignment requirements of Containers</h3>
<p><b>Section:</b> 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dean Michael Berris <b>Opened:</b> 2012-07-13 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 96 defines the general requirement for copy assignment (row 23, page 704) as:
</p>

<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<tt>r = a</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<tt></tt>
</td>
<td>
post: <tt>r == a.</tt>
</td>
<td>
linear
</td>
</tr>

</table>

<p>
However there is no requirement that <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>.
</p>

<p><i>[2012, Portland: Move to Tentatively NAD]</i></p>

<p>
Howard notes that this may be a difficult requirement for <tt>std::array</tt>
</p>

<p>
We already have this requirement for allocator aware containers, and
<tt>std::array</tt> already adds the appropriate extra requirement.
</p>

<p>
We say the necessary things in the necessary places, but the container requirements
continue to cause confusion in where we sometimes say things.  Consensus is that
this issue remains NAD though.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change Table 96 &mdash; "Container requirements" in 24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>:</p>

<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<tt>r = a</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<ins><i>Requires</i>: <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>.</ins><br/>
post: <tt>r == a.</tt>
</td>
<td>
linear
</td>
</tr>

</table>

</li>
</ol>







<hr>
<h3><a name="2171" href="2171">2171.</a> "swappable" undefined for swapping lvalue and rvalue</h3>
<p><b>Section:</b> 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-07-24 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#swappable.requirements">issues</a> in [swappable.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Paragraph 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> p4 states:
</p>
<blockquote><p>
An rvalue or lvalue <tt>t</tt> is <em>swappable</em> if and only if <tt>t</tt> is swappable with any rvalue or lvalue, 
respectively, of type <tt>T</tt>.
</p></blockquote>
<p>
This paragraph seems to establish two disjoint definitions of "swappable" &mdash; one for lvalues and one 
for rvalues &mdash; with neither definition including the case of swapping an rvalue with an lvalue.
<p/>
Resolution proposal:
<p/>
Delete the word "respectively".
</p>

<p><i>[
2012-10 Portland: Close as NAD
]</i></p>


<p>
The current wording does intentionally specify two families of 'swappable' behaviors, for lvalues
and for rvalues, and not for mixed behavior.  The need to support rvalues is for types like
<tt>vector&lt;bool>::reference</tt>.  Likewise, library types like <tt>string</tt> provide a
<tt>swap</tt> for values, but not a mixed-mode <tt>swap</tt> between lvalues and rvalues, which
were deliberately removed from C++11 after initally being part of the standard.
</p>

<p>
Accepting this resolution would break the library specification, as no current library type would
meet the new requirements.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<p>Change 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> p4 as indicated:</p>

<blockquote><p>
An rvalue or lvalue <tt>t</tt> is <em>swappable</em> if and only if <tt>t</tt> is swappable with any rvalue or 
lvalue <del>, respectively,</del> of type <tt>T</tt>.
</p></blockquote>






<hr>
<h3><a name="2178" href="2178">2178.</a> <tt>Allocator</tt> requirement changes not mentioned Annex C</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Pending NAD Editorial</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2012-08-14 <b>Last modified:</b> 2016-11-21 05:09:01 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Pending NAD Editorial">Pending NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Given that a number of things were removed from the allocator requirements (<tt>reference</tt>, <tt>const_reference</tt>, 
<tt>address()</tt> in 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>), it seems that these incompatible changes should be 
mentioned in Annex C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a>, more specifically in [diff.cpp03].
</p>

<p><i>[
2012-10 Portland: Move to Open 
]</i></p>


<p>
It was clearly pointed out by Bill during the C++11 process that our change to allocator requirements
potentially broke 3rd party user containers written to expect C++03 allocators, or rather, an
allocator written to the minimal requirements of C++11 might not be guaranteed to work with a container
written to the previous rules.  This was a trade-off in making allocaters easier to write by use of
the <tt>allocator_traits</tt> framework.
</p>

<p>
This probably does merit a write-up in Annex C, and we look forward to seeing wording.  Until then,
the best we can do is move the issue to Open.
</p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: JW to provide Annex C wording Status to "Pending NAD Editorial".</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2199" href="2199">2199.</a> unordered containers are required to have an initial max load factor of 1.0</h3>
<p><b>Section:</b> 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-10-09 <b>Last modified:</b> 2016-11-21 05:09:01 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The default constructor, allocator-aware constructor, and range-based constructors
for the unordered containers do not offer a means to control the initial
<tt>max_load_factor</tt>, so the standard mandates the value 1.0.  This seems overly
restrictive, as there is plenty of research suggesting a value between 0.5 and 1.0
is more often optimal for unique-key containers, and perhaps a slightly higher
value might be appropriate for multi-containers.
</p>
<p>
Rather than guess at the appropriate <tt>max_load_factor</tt>, it seems reasonable
that the standard should allow vendors to pick a value at their discretion, with
perhaps a note of advice.  It is less clear whether the default value should be
implementation-defined or unspecified, given the ease of a user determining this
by querying this attribute immediately after construction.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to provide wording.
</p>
<p>
Marshall: It seems to me that what you really want is to be able to pass a max load factor in the
constructor, but that's a different issue.
</p>
<p>
Alisdair agrees in principle, but concerned with adding yet more constructors to these classes.
</p>
<p><i>[2016-11-12, Issaquah]</i></p>

<p>NAD - if someone wants to come back with a paper exploring design alternatives, we can re-open.</p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2201" href="2201">2201.</a> Missing macro entries from C standard library</h3>
<p><b>Section:</b> C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Kevin McCarty <b>Opened:</b> 2012-02-03 <b>Last modified:</b> 2016-11-28 15:34:12 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It seems that in C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a>, Table 150 the following macros from  [c.limits], Table 31 
are missing:
</p>
<blockquote><pre>
LLONG_MIN 
LLONG_MAX
ULLONG_MAX
</pre></blockquote>
<p>
In addition in C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a>, Table 150 the following macros from  [c.limits], Table 32 
are missing:
</p>
<blockquote><pre>
DECIMAL_DIG 
FLT_EVAL_METHOD
</pre></blockquote>
<p>
Furtheron it seems that in C.7 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a>, Table 149/150 further macros are missing as well, e.g. 
<tt>HUGE_VALF</tt>, <tt>INFINITY</tt>, etc.
</p>

<p><i>[2014-02 Issaquah:]</i></p>

<p>
This is an issue, all of C has not been updated for C99, C99 functions are missing, whole section needs to be overhauled.
<p/>
The issue needs to be updated for functions and other missing items and when that happens the issue title is wrong and
needs to be adapted.
</p>

<p><i>[2016-08 Chicago: Zhihao Yuan comments]</i></p>

<p>
We suggest to either:
</p>
<ol>
<li><p>
Having a paper to rewrite C.5 C standard library by striking
the content shared by C and C++ and leave only the
differences;
</p></li>
<li><p>
Having a paper, or a complete proposed wording to fix
the missing names added between C89 and C99.
</p></li>
</ol>
<p>
For 1), some C11 headers being excluded from C++ (such as
<tt>thread.h</tt>) need to be added to this section.
</p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: Thomas will attempt to fix this editorially If he cannot, we will reexamine.</p>

<p><i>[2016-11-16]</i></p>

<p>Resolved as NAD Editorial</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2204" href="2204">2204.</a> <tt>reverse_iterator</tt> should not require a second copy of the base iterator</h3>
<p><b>Section:</b> 25.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2012-10-30 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#reverse.iter.elem">active issues</a> in [reverse.iter.elem].</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.elem">issues</a> in [reverse.iter.elem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This note in  [reverse.iter.op.star]/2:
</p>
<blockquote>
 [ <i>Note</i>: This operation must use an auxiliary member variable rather than a
 temporary variable to avoid returning a reference that persists beyond the
 lifetime of its associated iterator. (See 24.2.) &mdash;<i>end note</i> ]
</blockquote>
<p>
is incorrect because such iterator implementations are ruled out by
25.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a>/6, where it says:
</p>
<blockquote>
 If <tt>a</tt> and <tt>b</tt> are both dereferenceable, then <tt>a == b</tt> if and only if <tt>*a</tt> and
 <tt>*b</tt> are bound to the same object.
</blockquote>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Alisdair: sugested to strike the "exposition only" member.
<p/>
Daniel: we must check that it wouldn't conflict with a previous solution to another issue.
<p/>
Dietmar: This is an issue but the proposing word is not correct. When we have proxies inside the sequence.
<p/>
Solution: NAD thanks to a contrieved example by Dietmar.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike the note,  [reverse.iter.op.star]/2:
</p>

<blockquote>
 <del>[ <i>Note</i>: This operation must use an auxiliary member variable rather than a
 temporary variable to avoid returning a reference that persists beyond the
 lifetime of its associated iterator. (See 24.2.) &mdash;<i>end note</i> ]</del>
</blockquote>






<hr>
<h3><a name="2226" href="2226">2226.</a> <tt>wstring_convert</tt> methods do not take allocator instance</h3>
<p><b>Section:</b> D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Glen Fernandes <b>Opened:</b> 2012-12-14 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.string">active issues</a> in [depr.conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.string">issues</a> in [depr.conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>wstring_convert</tt> class template, described in D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>, does not 
support custom stateful allocators. It only supports custom stateless allocators.
<p/>
The <tt>to_bytes</tt> member function returns <tt>basic_string&lt;char, char_traits&lt;char&gt;, Byte_alloc&gt;</tt>  
but it does not take an instance of <tt>Byte_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
Similarly the <tt>from_bytes</tt> member function returns <tt>basic_string&lt;Elem, char_traits&lt;Elem&gt;, Wide_alloc&gt;</tt>  
but it does not take an instance of <tt>Wide_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
This makes these two member functions and the <tt>wstring_convert</tt> class template not usable when <tt>Wide_alloc</tt> 
or <tt>Byte_alloc</tt> are stateful allocators.
</p>

<p><i>[2013-01-22, Glen provides wording]</i></p>


<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to NAD Future.
</p>
<p>
This is clearly an extension that the LEWG may want to take a look at, once we have more experience
with appropriate use of allocators with the C++11 model.
</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: Does this follow the pattern? Should be discussed as a group. Do we have the experience with 
the C++11 allocator model to know that this is the addition to make?</p>
<p>Should <tt>to_string()</tt> also take an allocator? <tt>substr()</tt>? Any function that returns a string?</p>
<p>This suggests a larger change.</p>

<p><i>[Kona 2019]</i></p>

<p>Jonathan points out: The wstring_convert type is deprecated now.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>In D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>/2 and /6 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>from_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Wide_alloc</tt>:</p>

<blockquote><pre>
wide_string from_bytes(char byte<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *ptr<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const byte_string&amp; str<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *first, const char *last<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> /8 specify that this <tt>Wide_alloc</tt> allocator parameter is used to
construct the <tt>wide_string</tt> object returned from the function:</p>

<p>
-7- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>byte</tt> to a wide string.
The second member function shall convert the null-terminated sequence beginning at <tt>ptr</tt> to a wide
string. The third member function shall convert the sequence stored in <tt>str</tt> to a wide string. The fourth
member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a wide string.
<p/>
-8- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Wide_alloc</tt> allocator parameter is used to construct the <tt>wide_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

<li><p>In D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a>/2 and /12 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>to_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Byte_alloc</tt>:</p>

<blockquote><pre>
byte_string to_bytes(Elem wchar<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *wptr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const wide_string&amp; wstr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *first, const Elem *last<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> /13 specify that this <tt>Byte_alloc</tt> allocator parameter is used to
construct the <tt>byte_string</tt> object returned from the function:</p>

<p>
-12- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>wchar</tt> to a byte string.
The second member function shall convert the null-terminated sequence beginning at <tt>wptr</tt> to a byte
string. The third member function shall convert the sequence stored in <tt>wstr</tt> to a byte string. The
fourth member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a byte string.
<p/>
-13- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Byte_alloc</tt> allocator parameter is used to construct the <tt>byte_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

</ol>





<hr>
<h3><a name="2242" href="2242">2242.</a> <tt>[uninitialized_]copy_n()</tt> defect</h3>
<p><b>Section:</b> 27.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>, 27.11.5 <a href="https://timsong-cpp.github.io/cppwp/uninitialized.copy">[uninitialized.copy]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Parent <b>Opened:</b> 2013-02-14 <b>Last modified:</b> 2017-06-05 20:39:07 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in [alg.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in [alg.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>copy_n()</tt> and <tt>uninitialized_copy_n()</tt> only return the output iterator, and not the input iterator. 
Likely the interface was simply copied from the original STL. Unfortunately the interface in the original STL contains a bug.
<p/>
<tt>copy_n()</tt> and <tt>uninitialized_copy_n()</tt> must return the resulting input iterator as well as the output 
iterator (I would suggest returning a pair). Without this, there is no way to continue reading from an actual input 
iterator &mdash; and if it is really a forward iterator, it will cost <tt>n</tt> increments to get back to where you were.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: refer to LEWG</p>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>Potentially breaks lots of things. 
Cannot overload on return type. Pair, tuple, or struct return? 
New name? Needs paper with a new algorithm (copy_n_works)? 
Not an issue for istream iterators (can get stream and get a new iterator). 
Don’t use this function, use ranges.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>This change has been made in the Ranges TS.</p>
<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2251" href="2251">2251.</a> C++ library should define <tt>ssize_t</tt></h3>
<p><b>Section:</b> 17.2 <a href="https://timsong-cpp.github.io/cppwp/support.types">[support.types]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2013-04-19 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The C++ standard library defines <tt>size_t</tt>, a typedef for an implementation defined unsigned integer type 
that can represent the sizes of objects. The POSIX standard augments this with <tt>ssize_t</tt>, a typedef for a 
signed integer type that corresponds to <tt>size_t</tt>.
<p/>
The <tt>ssize_t</tt> typedef is useful &mdash; useful enough that the C++ standard even refers to it. (In a 
non-normative footnote in 31.2.2 <a href="https://timsong-cpp.github.io/cppwp/stream.types">[stream.types]</a>.)  Also, lots of OS vendors add it to their headers anyway, 
even though it isn't part of the C or C++ standards, because those vendors are trying to define headers that 
conform to multiple standards at once. We should make users' and implementers' lives easier by adding 
<tt>ssize_t</tt> to 17.2 <a href="https://timsong-cpp.github.io/cppwp/support.types">[support.types]</a>.
</p>

<p><i>[2013-09-29, Suggested wording from Jayson Oldfather]</i></p>

<p> 
I decided to use the phrase to describe <tt>ssize_t</tt> below because of the text describing it in the 
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_types.h.html#tag_13_67">POSIX</a> standard. 
In it, it describes <tt>ssize_t</tt> with the value range of <tt>[-1,{SSIZE_MAX}]</tt>.
<tt>SSIZE_MAX</tt> is specified in the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html#tag_13_24">POSIX</a> 
standard as a minimum value of <tt>_POSIX_SSIZE_MAX</tt>. This macro is referenced in the wording below.
</p>

<p><i>[Lenexa 2015-05-05: NAD - no consensus for a change]</i></p>

<p>Billy : ssize_t that was promised to be signed, was based on rsize_t from safe secure C</p>
<p>NM : ssize_t s ptrdif_t</p>
<p>Z : ptrdiff_t is full range, ssize_t has only -1 as negative value</p>
<p>Billy : motivations for ptrdiff_T, ssize_t and rsize_T all fuzzy. - Reads rsize max -</p>
<p>NM : ptrdiff_T not big enough to rep difference of pointers anymore</p>
<p>STL : description incorporates posixisms</p>
<p>Billy : Don't need it</p>
<p>NM : rather remove it from footnote</p>
<p>Z : Name has precise meaning</p>
<p>STL : everyone understands ptrdiff_t is signed counterpart to size_t</p>
<p>Billy : Not in all implementations anymore</p>
<p>DK : footnote says something different from ...</p>
<p>Z/NM : off_t historically tainted</p>
<p>STL : we have a type trait to make signed version of size_t. we should just use that</p>
<p>MC : NAD; is feature request</p>
<p>TP : It's not cstdsef</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Ammend 17.2 <a href="https://timsong-cpp.github.io/cppwp/support.types">[support.types]</a>, Table 30 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 30 &mdash; Header <tt>&lt;cstddef&gt;</tt> synopsis</caption>
<tr>
<th>Type</th>
<th>Name(s)</th>
</tr>

<tr>
<td>
<b>Macros:</b>
</td>
<td>
<tt>NULL offset_t</tt>
</td>
</tr>

<tr>
<td>
<b>Types:</b>
</td>
<td>
<tt>ptrdiff_t <ins>ssize_t</ins> size_t max_align_t nullptr_t</tt>
</td>
</tr>
</table>
</blockquote>

<p>Add the following paragraph to describe <tt>ssize_t</tt></p>
<blockquote><p><ins>
-?- The type <tt>ssize_t</tt> is an implementation-defined signed integer type that shall contain the minimum range 
<tt>[-1, {SSIZE_MAX}]</tt> where <tt>SSIZE_MAX</tt> is specified at a minimum of <tt>_POSIX_SSIZE_MAX</tt>.</ins>
</p></blockquote>
<p>Ammend p7 as follows:</p>
<blockquote><p>
-7- [<i>Note:</i> It is recommended that implementations choose types for <tt>ptrdiff_t<ins>, ssize_t,</ins></tt> and <tt>size_t</tt> whose integer conversion ranks &hellip;</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2253" href="2253">2253.</a> [arrays.ts] <tt>dynarray</tt> should state which container requirements aren't met</h3>
<p><b>Section:</b> 99 [arrays.ts::dynarray.overview] <b>Status:</b> <a href="lwg-active.html#NAD Arrays">NAD Arrays</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-04-23 <b>Last modified:</b> 2016-10-31 21:06:13 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Arrays">NAD Arrays</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: arrays.ts</b></p>

<p>
99 [arrays.ts::dynarray.overview] p2 says:
</p>
<blockquote>
<p>
"Unless otherwise specified, all <tt>dynarray</tt> operations have the same requirements and semantics as specified in
99 [arrays.ts::container.requirements]."
</p>
</blockquote>
<p>
Some differences from 99 [arrays.ts::container.requirements] are not explicitly specified, including at
least the lack of a default constructor, copy assignment and <tt>swap</tt> member.
<p/>
The wording could be similar to 24.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> which says "An array satisfies all of the requirements 
of a container and of a reversible container (99 [arrays.ts::container.requirements]), except that a default constructed 
array object is not empty and that <tt>swap</tt> does not have constant complexity."
</p>

<p><i>[2013-09 Chicago:]</i></p>

<p>
Move to Deferred. This feature will ship after C++14 and should be revisited then.
</p>

<p><i>[2014-06-06 pre-Rapperswil]</i></p>

<p>
This issue has been reopened as arrays-ts.
</p>

<p><i>[2014-06-16 Rapperswil]</i></p>

<p>
Move to Ready
</p>

<p><i>[2014/11 Urbana]</i></p>

<p>
Held at Ready status, pending clarification of Arrays TS
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Add to 99 [arrays.ts::dynarray.overview] p2:</p>
<p>
-2- <ins>A <tt>dynarray</tt> satisfies all of the requirements of a container and of a reversible container 
(99 [arrays.ts::container.requirements]), except for default construction, assignment and <tt>swap</tt>.</ins> Unless 
otherwise specified, all <tt>dynarray</tt> operations have the same requirements and semantics as specified in 
99 [arrays.ts::container.requirements].
</p>
</li>
</ol>






<hr>
<h3><a name="2254" href="2254">2254.</a> [arrays.ts] Is <tt>dynarray</tt> an allocator-aware container?</h3>
<p><b>Section:</b> 99 [arrays.ts::container.requirements.general] <b>Status:</b> <a href="lwg-active.html#NAD Arrays">NAD Arrays</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-04-23 <b>Last modified:</b> 2016-10-31 21:06:13 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Arrays">NAD Arrays</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: arrays.ts</b></p>

<p>
99 [arrays.ts::container.requirements.general] p3 says:
</p>
<blockquote>
<p>
"All of the containers defined in this Clause and in (21.4) except <tt>array</tt> meet the additional requirements 
of an allocator-aware container, as described in Table 99."
</p>
</blockquote>
<p>
Is this true of <tt>dynarray</tt>?  I believe the answer must be no because <tt>dynarray</tt> has no <tt>allocator_type</tt>, 
and morally should be no, so that operations are defined in terms of <tt>std::allocator&lt;T&gt;</tt>, which p13 says
doesn't actually need to be used (which allows the elements to be default-initialized as is intended, rather than 
"default-inserted into the container" using an allocator.)
<p/>
The requirement that "each element is constructed with uses-allocator construction" provides roughly equivalent behaviour 
to the "<em>CopyInsertable into <tt>X</tt></em>" requirements for allocator-aware containers, allowing an allocator to 
control construction of the <tt>dynarray</tt> elements.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Move to Deferred. This feature will ship after C++14 and should be revisited then.
</p>

<p><i>[2014-06-06 pre-Rapperswill]</i></p>

<p>
This issue has been reopened as arrays-ts.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change to 99 [arrays.ts::container.requirements.general] p13:</p>
<p>
-13- All of the containers defined in this Clause and in (21.4) except <tt>array</tt> <ins>and <tt>dynarray</tt></ins> 
meet the additional requirements of an allocator-aware container, as described in Table 99.
</p>
</li>
</ol>






<hr>
<h3><a name="2255" href="2255">2255.</a> [arrays.ts] <tt>dynarray</tt> constructor ambiguity</h3>
<p><b>Section:</b> 99 [arrays.ts::dynarray.cons] <b>Status:</b> <a href="lwg-active.html#NAD Arrays">NAD Arrays</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-04-23 <b>Last modified:</b> 2016-03-08 23:03:34 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Arrays">NAD Arrays</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: arrays.ts</b></p>

<p>
These constructors can interact badly::
</p>
<blockquote><pre>
template&lt;class Alloc&gt;
  dynarray(size_type c, const Alloc&amp; alloc);
dynarray(size_type c, const T&amp; v);
</pre></blockquote>
<p>
Unless the second argument is a value of exactly the type <tt>T</tt> you will get the first constructor, i.e. 
all of these will fail to compile:
</p>
<blockquote><pre>
dynarray&lt;long&gt; dlong(1, 1);   // 1 is not long
dynarray&lt;float&gt; dflt(1, 1.0);  // 1.0 is not float
dynarray&lt;int*&gt; dptr(1, nullptr);  // nullptr is not int*
dynarray&lt;void*&gt; doh(1, 0);  // 0 is not void*
</pre></blockquote>
<p>
The <tt>nullptr</tt> case is particularly annoying, a user trying to do the right thing by saying <tt>nullptr</tt> 
instead of <tt>NULL</tt> still gets the wrong result.
<p/>
The constructor taking an allocator requires that "<tt>Alloc</tt> shall meet the requirements for an Allocator" 
but doesn't actually say "shall not participate in overload resolution unless ..."
<p/>
I believe we have no precedent for using SFINAE to check "the requirements for an Allocator" because it's 
a pretty complicated set of requirements. We could say it shall not participate in overload resolution if <tt>Alloc</tt> 
is implicitly convertible to <tt>value_type</tt>.
<p/>
Alternatively, we could follow the same approach used by other types that can be constructed with an unconstrained 
allocator type and use <tt>std::allocator_arg_t</tt> as the first argument instead of adding an allocator after the 
other arguments.
</p>

<p><i>[2013-09 Chicago:]</i></p>

<p>
Move to Deferred. This feature will ship after C++14 and should be revisited then.
</p>

<p><i>[2014-06-06 pre-Rapperswil]</i></p>

<p>
This issue has been reopened as arrays-ts.
</p>

<p><i>[2014-06-16 Rapperswil]</i></p>

<p>
Move to Ready for alternative A
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<p/>
<blockquote class="note"> 
<ol style="list-style-type:upper-alpha">
<li>
<p>
<em>Either</em> use the correct way to unambiguously call a constructor taking any type of allocator, i.e. change the 
constructors to take <tt>dynarray(std::allocator_arg_t, const Alloc&amp;, ...)</tt> by modifying both the synopsis
99 [arrays.ts::dynarray.overview] p2 and 99 [arrays.ts::dynarray.cons] before p9 like so:</p>

<blockquote><pre>
template &lt;class Alloc&gt;
  dynarray(<ins>allocator_arg_t, const Alloc&amp; a, </ins>size_type c<del>, const Alloc&amp; alloc</del>);
template &lt;class Alloc&gt;
  dynarray(<ins>allocator_arg_t, const Alloc&amp; a, </ins>size_type c, const T&amp; v<del>, const Alloc&amp; alloc</del>);
template &lt;class Alloc&gt;
  dynarray(<ins>allocator_arg_t, const Alloc&amp; a, </ins>const dynarray&amp; d<del>, const Alloc&amp; alloc</del>);
template &lt;class Alloc&gt;
  dynarray(<ins>allocator_arg_t, const Alloc&amp; a, </ins>initializer_list&lt;T&gt;<del>, const Alloc&amp; alloc</del>);
</pre></blockquote>

</li>

<li><p><em>or</em> constrain the problematic constructor by adding a new paragraph to 99 [arrays.ts::dynarray.cons]:</p>
<blockquote><pre>
template &lt;class Alloc&gt;
  dynarray(size_type c, const Alloc&amp; alloc);
template &lt;class Alloc&gt;
  dynarray(size_type c, const T&amp; v, const Alloc&amp; alloc);
template &lt;class Alloc&gt;
  dynarray(const dynarray&amp; d, const Alloc&amp; alloc);
template &lt;class Alloc&gt;
  dynarray(initializer_list&lt;T&gt;, const Alloc&amp; alloc);
</pre><blockquote>
<p>
-9- <i>Requires</i>: <tt>Alloc</tt> shall meet the requirements for an Allocator (16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>).
<p/>
-10- <i>Effects</i>: Equivalent to the preceding constructors except that each element is constructed with uses-allocator
construction (20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>).
<p/>
<ins>-?- <i>Remarks</i>: The first constructor shall not participate in overload resolution unless <tt>Alloc</tt> is not 
implicitly convertible to <tt>T</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2014/11 Urbana]</i></p>

<p>
Held at Ready status, pending clarification of Arrays TS
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Use the correct way to unambiguously call a constructor taking any type of allocator, i.e. change the 
constructors to take <tt>dynarray(std::allocator_arg_t, const Alloc&amp;, ...)</tt> by modifying both the synopsis
99 [arrays.ts::dynarray.overview] p2 and 99 [arrays.ts::dynarray.cons] before p9 like so:</p>

<blockquote><pre>
template &lt;class Alloc&gt;
  dynarray(<ins>allocator_arg_t, const Alloc&amp; a, </ins>size_type c<del>, const Alloc&amp; alloc</del>);
template &lt;class Alloc&gt;
  dynarray(<ins>allocator_arg_t, const Alloc&amp; a, </ins>size_type c, const T&amp; v<del>, const Alloc&amp; alloc</del>);
template &lt;class Alloc&gt;
  dynarray(<ins>allocator_arg_t, const Alloc&amp; a, </ins>const dynarray&amp; d<del>, const Alloc&amp; alloc</del>);
template &lt;class Alloc&gt;
  dynarray(<ins>allocator_arg_t, const Alloc&amp; a, </ins>initializer_list&lt;T&gt;<del>, const Alloc&amp; alloc</del>);
</pre></blockquote>

</li>
</ol>






<hr>
<h3><a name="2256" href="2256">2256.</a> On <tt>vector</tt> iterator invalidation</h3>
<p><b>Section:</b> 24.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2013-04-29 <b>Last modified:</b> 2020-05-08 17:29:04 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
24.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>/p3 says:
</p>
<blockquote><pre>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>
<i>Effects</i>: Invalidates iterators and references at or after the point of the erase.
</p>
</blockquote></blockquote>
<p>
Consider this example:
</p>
<blockquote><pre>
#include &lt;vector&gt;
#include &lt;cassert&gt;

int main()
{
  typedef std::vector&lt;int&gt; C;
  C c = {1, 2, 3, 4};
  C::iterator i = c.begin() + 1;
  C::iterator j = c.end() - 1;
  assert(*i == 2);
  assert(*j == 4);
  c.erase(c.begin());
  <span style="color:#C80000;font-weight:bold">assert(*i == 3); // Why is this not perfectly fine?!</span>
}
</pre></blockquote>
<p>
Why has the iterator <tt>i</tt> been invalidated? It still refers to a perfectly reasonable, fully constructed object. 
If <tt>vector::iterator</tt> were to be implemented as a pointer (which is legal), it is not possible for that last 
line to do anything but run fine.
<p/>
The iterator <tt>j</tt> on the other hand now points at end, and any iterators that may now point beyond <tt>end()</tt>, 
into uninitialized memory, are clearly invalid.
<p/>
But why do we say that an iterator that <em>must</em> point to a valid object is invalid? This looks to me like we 
simply got sloppy in our specification.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
This is related to <a href="2698">2698</a>
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>NAD. "Works as designed"  Also, the example does not work in today's world of <tt>launder</tt>.</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2264" href="2264">2264.</a> [arrays.ts] <tt>std::dynarray</tt> defines its initializer-list constructor in terms of a non-existent constructor</h3>
<p><b>Section:</b> 99 [arrays.ts::dynarray], 99 [arrays.ts::container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD Arrays">NAD Arrays</a>
 <b>Submitter:</b> Povilas Kanapickas <b>Opened:</b> 2013-05-22 <b>Last modified:</b> 2016-03-08 23:03:34 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Arrays">NAD Arrays</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: arrays.ts</b></p>

<p>
<tt>std::dynarray</tt> member listing at 99 [arrays.ts::dynarray.overview] includes this constructor:
</p>

<blockquote><pre>
dynarray(initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
Also, 99 [arrays.ts::dynarray.overview] p. 2 says:
</p>

<blockquote><p>
Unless otherwise specified, all <tt>dynarray</tt> operations have the same requirements and semantics as specified in 23.2.
</p></blockquote>

<p>
The constructor in question isn't mentioned in 99 [arrays.ts::dynarray.cons] or anywhere else. This means requirements from 
99 [arrays.ts::container.requirements] apply. However, Table 100 in 24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> says:
</p>

<blockquote><p>
<tt>X(il)</tt> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Equivalent to <tt>X(il.begin(), il.end())</tt>      
</p></blockquote>

<p>
<tt>std::dynarray</tt> does not provide this constructor.
</p>

<p>
The proposed resolution below adds the missing constructor and a complementary constructor with an allocator parameter. 
The new constructors, differently from the rest of containers, accept iterators that have forward iterator category. This 
is needed because the size requirements must be known in order to allocate appropriately-sized storage.
<p/>
An alternative resolution could be to properly specify the initializer-list constructor.
</p>

<p><i>[2013-09 Chicago:]</i></p>

<p>
Move to Deferred. This feature will ship after C++14 and should be revisited then.
</p>

<p><i>[2014-06-06 pre-Rapperswill]</i></p>

<p>
This issue has been reopened as arrays-ts.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Add the following to the <tt>std::dynarray</tt> synopsis at 99 [arrays.ts::dynarray.overview]:</p>

<blockquote><pre>
namespace std {
  template &lt;class T&gt;
  class dynarray {
    [&hellip;]
    <i>// 23.3.4.2 construct/copy/destroy:</i>
    [&hellip;]
    <ins>template &lt;class ForwardIterator&gt;</ins>
    <ins>dynarray(ForwardIterator first, ForwardIterator last);</ins>
    <ins>template &lt;class ForwardIterator, class Alloc&gt;</ins>
    <ins>dynarray(ForwardIterator first, ForwardIterator last, const Alloc&amp; alloc);</ins>
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Add the following to 99 [arrays.ts::dynarray.cons] after p. 8:</p>

<blockquote><pre>
<ins>template &lt;class ForwardIterator&gt;
dynarray(ForwardIterator first, ForwardIterator last);</ins>
</pre><blockquote>
<p>
<ins>-?-  <i>Requires:</i> <tt>T</tt> shall meet the <tt>CopyConstructible</tt> requirements.</ins>
<p/>
<ins>-?-  <i>Effects:</i> Allocates storage for <tt>distance(first, last)</tt> elements.
The <tt>distance(first, last)</tt> elements of the dynarray are direct-initialized (9.4 <a href="https://timsong-cpp.github.io/cppwp/dcl.init">[dcl.init]</a>) with the 
corresponding elements from the range <tt>[first,last)</tt>. May or may not invoke the global <tt>operator new</tt>.</ins>
<p/>
<ins>-?-  <i>Complexity:</i> <tt>distance(first, last)</tt>.</ins>
<p/>
<ins>-?-  <i>Throws:</i> <tt>std::bad_array_length</tt> when the size requested is larger than implementable, <tt>std::bad_alloc</tt> 
when there is insufficient memory.</ins>
</p>
</blockquote></blockquote>
</li>

<li><p>Add the following to the list of constructors at 99 [arrays.ts::dynarray.cons] before p. 9:</p>

<blockquote><pre>
template &lt;class Alloc&gt;
dynarray(size_type c, const Alloc&amp; alloc);
template &lt;class Alloc&gt;
dynarray(size_type c, const T&amp; v, const Alloc&amp; alloc);
template &lt;class Alloc&gt;
dynarray(const dynarray&amp; d, const Alloc&amp; alloc);
template &lt;class Alloc&gt;
dynarray(initializer_list&lt;T&gt;, const Alloc&amp; alloc);
<ins>template &lt;class ForwardIterator, class Alloc&gt;
dynarray(ForwardIterator first, ForwardIterator last, const Alloc&amp; alloc);</ins>
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="2270" href="2270">2270.</a> Inconsistent <tt>to_string</tt> overloads</h3>
<p><b>Section:</b> 23.4.5 <a href="https://timsong-cpp.github.io/cppwp/string.conversions">[string.conversions]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Raf Schietekat <b>Opened:</b> 2013-07-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.conversions">issues</a> in [string.conversions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For internal consistency, <tt>to_string()</tt> should either list all relevant types (including <tt>bool</tt>, <tt>char</tt>, etc.), 
or only those that are the destination types of integral or floating-point promotion (<tt>float</tt> not being among them).
<p/>
A defensible reason for having (or rather keeping) the <tt>float</tt> overloads anyway could be to exactly mirror the adjacent 
sets of <tt>stoX()</tt> function overloads (even without round-trip fidelity for floating-point numbers).
<p/>
Unfortunately, that reveals a bigger issue than redundant overloads: the glaring and indefensible omission of an overloaded 
function <tt>stoui()</tt>. Adding that is not as trivial as removing redundant overloads, of course, because it requires 
everybody to take action. Still, it is the preferable remedy for the present situation.
<p/>
As far as I can tell from easily accessible information, C++ has already created the precedent with <tt>stoi()</tt>, which 
is not the equivalent of a pair of functions <tt>strtoi()</tt>/<tt>wcstoi()</tt> in C, but it would be if such functions 
existed. The function <tt>atoi()</tt> may look similar, but it does not qualify because it is as different from a 
hypothetical <tt>strtoi()</tt> as <tt>atol()</tt> currently is from <tt>strtol()</tt>, with the latter two both Standard C. 
It is only logical to act on this one-sided precedent by completing the set. Whether or not Standard C leads the way 
(or follows suit) is immaterial, but an invitation could be extended.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
These overloads were very carefully and experimentally determined to be the minimal set, when all (known) promotion and
conversion scenarios were considered.  Removing superfluous-looking overloads is likely to result in ambiguities.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 23.4 <a href="https://timsong-cpp.github.io/cppwp/string.classes">[string.classes]</a>, header <tt>&lt;string&gt;</tt> synopsis, as indicated:</p>

<blockquote><pre>
#include &lt;initializer_list&gt;

namespace std {
  [&hellip;]
  string to_string(int val);
  string to_string(unsigned val);
  string to_string(long val);
  string to_string(unsigned long val);
  string to_string(long long val);
  string to_string(unsigned long long val);
  <del>string to_string(float val);</del>
  string to_string(double val);
  string to_string(long double val);
  [&hellip;]

  [&hellip;]
  wstring to_wstring(int val);
  wstring to_wstring(unsigned val);
  wstring to_wstring(long val);
  wstring to_wstring(unsigned long val);
  wstring to_wstring(long long val);
  wstring to_wstring(unsigned long long val);
  <del>wstring to_wstring(float val);</del>
  wstring to_wstring(double val);
  wstring to_wstring(long double val);
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 23.4.5 <a href="https://timsong-cpp.github.io/cppwp/string.conversions">[string.conversions]</a> p7+14 as indicated:</p>

<blockquote>
<pre>
string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
<del>string to_string(float val);</del>
string to_string(double val);
string to_string(long double val);
</pre>
<blockquote>
<p>
-7- <i>Returns:</i> Each function returns a <tt>string</tt> object holding the character representation of the value of
its argument that would be generated by calling <tt>sprintf(buf, fmt, val)</tt> with a format specifier of
<tt>"%d"</tt>, <tt>"%u"</tt>, <tt>"%ld"</tt>, <tt>"%lu"</tt>, <tt>"%lld"</tt>, <tt>"%llu"</tt>, <del><tt>"%f"</tt>,</del> 
<tt>"%f"</tt>, or <tt>"%Lf"</tt>, respectively, where <tt>buf</tt> designates an internal character buffer of sufficient size.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
<del>wstring to_wstring(float val);</del>
wstring to_wstring(double val);
wstring to_wstring(long double val);
</pre>
<blockquote>
<p>
-14- <i>Returns:</i> Each function returns a <tt>wstring</tt> object holding the character representation of the value of
its argument that would be generated by calling <tt>swprintf(buf, buffsz, fmt, val)</tt> with a format specifier of
<tt>L"%d"</tt>, <tt>L"%u"</tt>, <tt>L"%ld"</tt>, <tt>L"%lu"</tt>, <tt>L"%lld"</tt>, <tt>L"%llu"</tt>, <del><tt>L"%f"</tt>,</del> 
<tt>L"%f"</tt>, or <tt>L"%Lf"</tt>, respectively, where <tt>buf</tt> designates an internal character buffer of sufficient 
size <tt>buffsz</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2277" href="2277">2277.</a> [arrays.ts] <tt>&lt;dynarray&gt;</tt> is missing in 24.7/1</h3>
<p><b>Section:</b> 99 [arrays.ts::iterator.range] <b>Status:</b> <a href="lwg-active.html#NAD Arrays">NAD Arrays</a>
 <b>Submitter:</b> Cassio Neri <b>Opened:</b> 2013-07-31 <b>Last modified:</b> 2016-03-08 23:03:34 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Arrays">NAD Arrays</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: arrays.ts</b></p>

<p>
Section 99 [arrays.ts::iterator.range] p1 specifies header files that, in addition to
<tt>&lt;iterator&gt;</tt>, make available the function templates in 24.7
(<tt>begin</tt>, <tt>end</tt>, etc.) but it fails to mention
<tt>&lt;dynarray&gt;</tt>. This seems to be just an oversight.
</p>

<p><i>[2013-09 Chicago:]</i></p>

<p>
Move to Deferred. This feature will ship after C++14 and should be revisited then. 
</p>

<p><i>[2014-06-06 pre-Rapperswill]</i></p>

<p>
This issue has been reopened as arrays-ts.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 99 [arrays.ts::iterator.range] p1 as indicated:</p>

<blockquote><p>
-1- In addition to being available via inclusion of the <tt>&lt;iterator&gt;</tt> header, the function templates in 24.7 are
available when any of the following headers are included: <tt>&lt;array&gt;</tt>, <tt>&lt;deque&gt;</tt>, 
<ins><tt>&lt;dynarray&gt;</tt>,</ins>
<tt>&lt;forward_list&gt;</tt>, <tt>&lt;list&gt;</tt>, <tt>&lt;map&gt;</tt>, <tt>&lt;regex&gt;</tt>, 
<tt>&lt;set&gt;</tt>, <tt>&lt;string&gt;</tt>, <tt>&lt;unordered_map&gt;</tt>, <tt>&lt;unordered_set&gt;</tt>, 
and <tt>&lt;vector&gt;</tt>.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2279" href="2279">2279.</a> Carefully state effects of <tt>list::splice</tt> function</h3>
<p><b>Section:</b> 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, 99 [forwardlist.ops] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Arseny Klimovsky <b>Opened:</b> 2013-08-15 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think that the effects of <tt>list::splice</tt> function should be stated more carefully.
<p/>
Function transferring a single element is described now in the following way (24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p7):
</p>

<blockquote>
<pre>
void splice(const_iterator position, list&amp; x, const_iterator i);
void splice(const_iterator position, list&amp;&amp; x, const_iterator i);
</pre>
<blockquote>
<p>
<i>Effects:</i> Inserts an element pointed to by <tt>i</tt> from list <tt>x</tt> before position and removes the element from
<tt>x</tt>. The result is unchanged if <tt>position == i</tt> or <tt>position == ++i</tt>. Pointers and references to <tt>*i</tt>
continue to refer to this same element but as a member of <tt>*this</tt>. Iterators to <tt>*i</tt> (including <tt>i</tt> itself)
continue to refer to the same element, but now behave as iterators into <tt>*this</tt>, not into <tt>x</tt>.
</p>
</blockquote>
</blockquote>

<p>
But it is incorrect to talk about <tt>operator==</tt> for iterators that are not from the same container (after acceptance of 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>, 25.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> p2). 
So, the text operates with an undefined behaviour.
</p>

<p>
One is formally allowed to have list implementation where two iterators from different lists return true to <tt>operator==</tt>.
For example, this can only happen to non-dereferenceable iterators, and <tt>position</tt> and <tt>++i</tt> can be 
non-dereferenceable. So, literally according to the standard, it is not allowed in this implementation to transfer 
such elements with <tt>splice</tt> function.
</p>

<p><i>[2013-09 Chicago (late night issues)]</i></p>

<p>
Moved to NAD.
</p>
<p>
The condition under which the <tt>list</tt> is unchanged is not program code, so there is no undefined behavior to protect against.
Rather, the precondition that the evaluation can be performed is implicit if determining when the condition applies.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 99 [forwardlist.ops] p6 as indicated:</p>

<blockquote>
<pre>
void splice_after(const_iterator position, forward_list&amp; x, const_iterator i);
void splice_after(const_iterator position, forward_list&amp;&amp; x, const_iterator i);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Effects:</i> Inserts the element following <tt>i</tt> into <tt>*this</tt>, following <tt>position</tt>, 
and removes it from <tt>x</tt>. The result is unchanged if <ins><tt>&amp;x == this</tt> and the following 
condition is satisfied:</ins> <tt>position == i</tt> or <tt>position == ++i</tt>. Pointers and references to 
<tt>*++i</tt> continue to refer to the same element but as a member of <tt>*this</tt>. Iterators to <tt>*++i</tt> 
continue to refer to the same element, but now behave as iterators into <tt>*this</tt>, not into <tt>x</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 24.3.10.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p7 as indicated:</p>

<blockquote>
<pre>
void splice(const_iterator position, list&amp; x, const_iterator i);
void splice(const_iterator position, list&amp;&amp; x, const_iterator i);
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Inserts an element pointed to by <tt>i</tt> from list <tt>x</tt> before position and removes 
the element from <tt>x</tt>. The result is unchanged if <ins><tt>&amp;x == this</tt> and the following 
condition is satisfied:</ins> <tt>position == i</tt> or <tt>position == ++i</tt>. Pointers and references to 
<tt>*i</tt> continue to refer to this same element but as a member of <tt>*this</tt>. Iterators to <tt>*i</tt> 
(including <tt>i</tt> itself) continue to refer to the same element, but now behave as iterators into <tt>*this</tt>, 
not into <tt>x</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2281" href="2281">2281.</a> C99 cross-reference typo in [using.linkage]</h3>
<p><b>Section:</b> 16.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/using.linkage">[using.linkage]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Chris Sharpe <b>Opened:</b> 2013-08-23 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#using.linkage">issues</a> in [using.linkage].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a footnote at section 16.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/using.linkage">[using.linkage]</a>/2 that reads:
</p>
<blockquote><p>
"The only reliable way to declare an object or function signature from the Standard C library is by including 
the header that declares it, notwithstanding the latitude granted in 7.1.7 of the C Standard."
</p></blockquote>
<p>
There is no section 7.1.7 in the C99 Standard (or C11 final draft). I think the relevant section is:
</p>
<blockquote><p>
"Provided that a library function can be declared without reference to any type defined in a header, it is also 
permissible to declare the function and use it without including its associated header."
</p></blockquote>
<p>
at 7.1.4/2 from C99.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Moved to NAD Editorial.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit footnote 182, 16.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/using.linkage">[using.linkage]</a> as indicated:</p>

<blockquote>
<p>
The only reliable way to declare an object or function signature from the Standard C library is by including the header
that declares it, notwithstanding the latitude granted in <del>7.1.7</del><ins>7.1.4</ins> of the C Standard.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2297" href="2297">2297.</a> [CD] Missing type requirements for <tt>std::exchange</tt></h3>
<p><b>Section:</b> 22.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.exchange">[utility.exchange]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2013-09-22 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.exchange">issues</a> in [utility.exchange].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB 5</b></p>

<p>
The wording describes example code including the call of a move constructor, but there is no requirement 
stated that <tt>T</tt> be move constructible. 
<p/>
We would like to add a new Para 1 before existing paragraph:
</p>
<blockquote><p>
<i>Requires:</i> Type <tt>T</tt> shall be <tt>MoveConstructible</tt> (Table 20) and <tt>MoveAssignable</tt> (Table 22).
</p></blockquote>

<p>
However the <tt>MoveAssignable</tt> concept currently does not cover cases where the source and destination types may differ.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
The requirements are implicit according to 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>p4.  There is no desire to redundantly
repeat a set of requirements.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2302" href="2302">2302.</a> Passing null pointer to placement new</h3>
<p><b>Section:</b> 17.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/new.delete.placement">[new.delete.placement]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Pending NAD</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2013-09-12 <b>Last modified:</b> 2017-09-07 13:59:44 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Pending NAD">Pending NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Based on <a href="http://stackoverflow.com/questions/17571103/passing-null-pointer-to-placement-new">this discussion</a> 
and as discussed in <a href="http://listarchives.isocpp.org/cgi-bin/wg21/message?wg=core&amp;msg=23998">c++std-core-23998</a> and
<a href="http://listarchives.isocpp.org/cgi-bin/wg21/message?wg=lib&amp;msg=34442">c++std-lib-34442</a>, calling placement new currently forces the 
compiler to check if the pointer is null before initializing the object (a non-negligible cost). It seems many people were not 
aware of this and they consider it a user error to pass a null pointer to it.
<p/>
Proposed resolution: for <tt>operator new</tt> and <tt>operator new[]</tt>, add:
</p>
<blockquote><p>
<i>Requires:</i> <tt>ptr</tt> shall not be a null pointer.
</p></blockquote>

<p><i>[2014-02-15 post-Issaquah session : move to Tentatively NAD]</i></p>

<p>
AJM to supply the rationale...
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 17.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/new.delete.placement">[new.delete.placement]</a> as indicated:</p>

<blockquote>
<pre>
void* operator new(std::size_t size, void* ptr) noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <tt>ptr</tt> shall not be a null pointer.</ins>
<p/>
-2- <i>Returns:</i> <tt>ptr</tt>.
<p/>
-3- <i>Remarks:</i> Intentionally performs no other action.
<p/>
-4- [<i>Example:</i> This can be useful for constructing an object at a known address:
</p><blockquote><pre>
void* place = operator new(sizeof(Something));
Something* p = new (place) Something();
</pre></blockquote>
<p>
&mdash; <i>end example</i>]
</p>
</blockquote>
</blockquote>
<blockquote>
<pre>
void* operator new[](std::size_t size, void* ptr) noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <tt>ptr</tt> shall not be a null pointer.</ins>
<p/>
-5- <i>Returns:</i> <tt>ptr</tt>.
<p/>
-6- <i>Remarks:</i> Intentionally performs no other action.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2305" href="2305">2305.</a> [fund.ts] <tt>optional</tt> forwarding construction/assignment</h3>
<p><b>Section:</b> 5.3.1 [fund.ts::optional.object.ctor] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Cassio Neri <b>Opened:</b> 2013-09-23 <b>Last modified:</b> 2015-10-26 20:17:22 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts</b></p>

<p>
Consider:
</p>
<blockquote><pre>
struct foo {
  foo(std::initializer_list&lt;int&gt;&amp;);        // 1
  foo(const std::initializer_list&lt;int&gt;&amp;);  // 2
  foo(std::initializer_list&lt;int&gt;&amp;&amp;);       // 3
  foo(const std::initializer_list&lt;int&gt;&amp;&amp;); // 4
};

std::initializer_list&lt;int&gt; il{0, 1, 2};

foo foo_0{1, 2, 3};                                 // calls 3
foo foo_1{il};                                      // calls 1
foo foo_2((const std::initializer_list&lt;int&gt;&amp;) il);  // calls 2
foo foo_3{(std::initializer_list&lt;int&gt;&amp;&amp;) il};       // calls 3
foo foo_4((const std::initializer_list&lt;int&gt;&amp;&amp;) il); // calls 4
</pre></blockquote>
<p>
Although the constructors of <tt>foo</tt> are unusual (<tt>initializer_list</tt>s are <i>normally</i> passed by
value) users of <tt>optional</tt> could naturally expect perfect forwarding of <tt>initializer_list</tt>s. However,
all lines below end up calling 1.
</p>
<blockquote><pre>
optional&lt;foo&gt; opt0{in_place, {1, 2, 3}};
optional&lt;foo&gt; opt1{in_place, il};                    
optional&lt;foo&gt; opt3{in_place, (const std::initializer_list&lt;int&gt;&amp;) il};
optional&lt;foo&gt; opt2{in_place, (std::initializer_list&lt;int&gt;&amp;&amp;) il};
optional&lt;foo&gt; opt4{in_place, (const std::initializer_list&lt;int&gt;&amp;&amp;) il};

opt0.emplace({1, 2, 3});
opt0.emplace(il);
opt0.emplace((const std::initializer_list&lt;int&gt;&amp;) il);
opt0.emplace((std::initializer_list&lt;int&gt;&amp;&amp;) il);
opt0.emplace((const std::initializer_list&lt;int&gt;&amp;&amp;) il);
</pre></blockquote>
<p>
The constructor
</p>
<blockquote><pre>
template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre></blockquote>
<p>
can handle all constructor calls above, except the one taking <tt>{1, 2, 3}</tt>. Hence, a simple
<ins>modification</ins> of
</p>
<blockquote><pre>
template &lt;class U, class... Args&gt;
constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;<ins>&amp;&amp;</ins> il, Args&amp;&amp;... args);
</pre></blockquote>
<p>
allows perfect forwarding of <tt>std::initializer_list&lt;U&gt;</tt>s to be complete.
</p>

<p><i>[2014-06-06 pre-Rapperswil]</i></p>

<p>
This issue has been reopened as fundamentals-ts.
</p>

<p><i>[2014-06-17, Rapperswil]</i></p>

<p>
Move to NAD
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 5.3.1 [fund.ts::optional.object.ctor] as indicated:</p>

<blockquote><pre>
template &lt;class U, class... Args&gt; 
constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;<ins>&amp;&amp;</ins> il, Args&amp;&amp;... args);
</pre><blockquote>
<p>
-27- <i>Requires</i>: <tt>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;<ins>&amp;</ins>, Args&amp;&amp;...>::value</tt> is <tt>true.</tt>
<p/>
-28- <i>Effects</i>: Initializes the contained value as if constructing an object of type <tt>T</tt> with the arguments
<tt><del>il</del><ins>std::move(il)</ins></tt>, <tt>std::forward&lt;Args&gt;(args)...</tt>.
<p/>
[&hellip;]
<p/>
<del>-31- <i>Remarks</i>: The function shall not participate in overload resolution unless
<tt>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</tt> is <tt>true</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
<li><p>Change 5.3.3 [fund.ts::optional.object.assign] as indicated:</p>

<blockquote><pre>
template &lt;class U, class... Args&gt;
void optional&lt;T&gt;::emplace(initializer_list&lt;U&gt;<ins>&amp;&amp;</ins> il, Args&amp;&amp;... args);
</pre><blockquote>
<p>
-27- <i>Requires</i>: <tt>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;<ins>&amp;</ins>, Args&amp;&amp;...>::value</tt> is <tt>true.</tt>
<p/>
-28- <i>Effects</i>: Calls <tt>*this = nullopt</tt>. Then initializes the contained value as if constructing an object of
type <tt>T</tt> with the arguments <tt><del>il</del><ins>std::move(il)</ins></tt>, <tt>std::forward&lt;Args&gt;(args)...</tt>.
<p/>
[&hellip;]
<p/>
<del>-32- <i>Remarks</i>: This function shall not participate in overload resolution unless
<tt>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...>::value</tt> is <tt>true.</tt></del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2311" href="2311">2311.</a> Allocator requirements should be further minimized</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C++11's minimized allocator requirements are great, but they're still requiring more things from users than absolutely necessary.
</p>
<ul>
<li><p>
They require <tt>X::value_type</tt>, but that can be deduced from <tt>SomeAllocator&lt;T, Args&gt;</tt>.
</p></li>
<li><p>
They require <tt>a1 == a2</tt>, but that could default to <tt>true</tt> as most allocators are stateless.
</p></li>
<li><p>
They require <tt>a1 != a2</tt>, but if we start requiring STL implementations to go through <tt>allocator_traits</tt> 
to provide an <tt>op==</tt> default, we won't need to require <tt>op!=</tt> from users at all. (<tt>std::allocator</tt>, 
of course, would continue to provide <tt>op!=</tt>. Note that this is analogous to <tt>reference</tt>/<tt>const_reference</tt> &mdash; 
<tt>std::allocator</tt> still provides them, but we don't require them from users, and in fact we don't require them to be 
consistent or meaningful if present.)
</p></li>
<li><p>
They require <tt>a == b</tt> and <tt>a != b</tt>. This requirement was not present in C++98/03, it is not necessary 
(<tt>a == b</tt> is always required to be equivalent to rebind-then-compare), and STL implementations don't even need 
to compare allocators of different types directly.
</p></li>
</ul>

<p><i>[2014-02-14 Issaquah: Close as NAD]</i></p>

<p>
Different vendors rely on each of the different elements suggested to be removed.
</p>
<p>
While <tt>value_type</tt> my be deduced as suggested, far too much wording relies on it being available,
and the standard churn is likely to be much harder than presented here.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change in 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 28 &mdash; "Allocator requirements" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::value_type</tt>
</td>
<td>
Identical to <tt>T</tt>
</td>
<td>
&nbsp;
</td>
<td>
<ins>See Note B, below.</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a1 == a2</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
returns <tt>true</tt> only if storage<br/>
allocated from each can be<br/>
deallocated via the other.<br/>
<tt>operator==</tt> shall be reflexive,<br/>
symmetric, and transitive, and<br/>
shall not exit via an exception.<br/>
</td>
<td>
<ins><tt>true</tt></ins>
</td>
</tr>

<tr>
<td>
<del><tt>a1 != a2</tt></del>
</td>
<td>
<del><tt>bool</tt></del>
</td>
<td>
<del>same as <tt>!(a1 == a2)</tt></del>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<del><tt>a == b</tt></del>
</td>
<td>
<del><tt>bool</tt></del>
</td>
<td>
<del>same as <tt>a ==<br/>
Y::rebind&lt;T&gt;::other(b)</tt></del>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<del><tt>a != b</tt></del>
</td>
<td>
<del><tt>bool</tt></del>
</td>
<td>
<del>same as <tt>!(a == b)</tt></del>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X a(b);</tt>
</td>
<td>
&nbsp;
</td>
<td>
Shall not exit via an exception.<br/>
post: <tt>Y(a) == b</tt>, <tt>a == X(b)</tt>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X a(move(b));</tt>
</td>
<td>
&nbsp;
</td>
<td>
Shall not exit via an exception.<br/>
post: <tt>a</tt> equals the prior value of <tt>X(b)</tt>.
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>After 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> p3, add a new paragraph:</p>

<blockquote>
<p>
<ins>Note B: If <tt>Allocator</tt> is a class template instantiation of the form <tt>SomeAllocator&lt;T, Args&gt;</tt>, 
where <tt>Args</tt> is zero or more type arguments, and <tt>Allocator</tt> does not supply a nested type named <tt>value_type</tt>, 
the standard <tt>allocator_traits</tt> template uses <tt>T</tt> in place of <tt>Allocator::value_type</tt> by default. 
For allocator types that are not template instantiations of the above form, no default is provided.</ins>
</p>
</blockquote>
</li>

<li><p>In the example provided in 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>/5, delete as indicated:</p>

<blockquote>
<pre>
template &lt;class Tp&gt;
struct SimpleAllocator {
  <del>typedef Tp value_type;</del>
  SimpleAllocator(ctor args);
  template &lt;class T&gt; SimpleAllocator(const SimpleAllocator&lt;T&gt;&amp; other);
  Tp *allocate(std::size_t n);
  void deallocate(Tp *p, std::size_t n);
};

<del>template &lt;class T, class U&gt;
bool operator==(const SimpleAllocator&lt;T&gt;&amp;, const SimpleAllocator&lt;U&gt;&amp;);
template &lt;class T, class U&gt;
bool operator!=(const SimpleAllocator&lt;T&gt;&amp;, const SimpleAllocator&lt;U&gt;&amp;);</del>
</pre>
</blockquote>

</li>

<li><p>Edit 20.2.9 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits">[allocator.traits]</a>p1, class template <tt>allocator_traits</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Alloc&gt; struct allocator_traits {
    typedef Alloc allocator_type;

    typedef <del>typename Alloc::value_type</del><ins><i>see below</i></ins> value_type;

    [&hellip;]

    static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);

    <ins>static bool equal(const Alloc&amp; a1, const Alloc&amp; a2) noexcept;</ins>
  };
}
</pre></blockquote>
</li>

<li><p>At the beginning of 20.2.9.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.types">[allocator.traits.types]</a>, add a new paragraph:</p>

<blockquote><pre>
<ins>typedef <i>see below</i> value_type;</ins>
</pre><blockquote>
<p>
<ins><i>Type:</i> <tt>Alloc::value_type</tt> if such a type exists; otherwise, <tt>T</tt> if <tt>Alloc</tt> is a class template 
instantiation of the form <tt>Alloc&lt;T, Args&gt;</tt>, where <tt>Args</tt> is zero or more type arguments; otherwise, the program 
is ill-formed.</ins>
</p>
</blockquote></blockquote>
</li>

<li><p>At the end of 20.2.9.3 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.members">[allocator.traits.members]</a>, add a new paragraph:</p>

<blockquote><pre>
<ins>static bool equal(const Alloc&amp; a1, const Alloc&amp; a2) noexcept;</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Returns:</i> <tt>a1 == a2</tt> if that expression is well-formed; otherwise, <tt>true</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2319" href="2319">2319.</a> <tt>basic_string</tt>'s move constructor should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2017-03-21 22:54:52 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In debugging implementations, containers (including <tt>basic_string</tt>) may need to own dynamically allocated helper objects at 
all times, including in their default-constructed and moved-from states. This means that their default constructors and move 
constructors may throw exceptions. Therefore, the Standard should not mark them as <tt>noexcept</tt>. (Other implementations will 
still be permitted to add <tt>noexcept</tt>.)
</p>

<p><i>[2014-02, Issaquah : move to Ready]</i></p>

<p>
The issue discussion was highly controversial: The arguments in favour was that implementations exist that always need to allocate
memory even for the move operations (similar as for some other containers) and that this cleans up an inconsistency between <tt>std::string</tt>
and other container types. Counter arguments were that potentially throwing move operations reduce much of the advantages of move-support,
e.g. in <tt>vector&lt;string&gt;</tt>.
</p>
<p>
straw poll: accept wording in the issue<br/>
SF 4 WF 4 N 0 WA 1 SA 1 
</p>
<p>
straw poll: 14 or 17?<br/>
C++14: 4 C++17: 4 
</p>
<p>
Move to Ready for C++17, as too close to 14 DIS without strong consensus.
</p>
<p>
It was suggested to introduce a special library vocabulary that specifies a "normative encouragement to not throw exceptions" for 
functions like these. 
</p>
<p>
NJ: I offer to write a proposal to add encouragement for not throwing ... "<tt>noexcept</tt> in italics means should not throw" 
</p>

<p><i>[2014/11 Urbana]</i></p>

<p>
Resolved by paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258">N4258</a>
</p>

<p><i>[2015-10]</i></p>

<p>
Richard Smith pointed out that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258">N4258</a>
explicitly decided not to change this call; leaving it as noexcept. In response, I am changing the resolution of
this issue from 'Resolved' to 'NAD'
</p>

<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>/5, class template <tt>basic_string</tt> synopsis, and 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a>/2 
change as indicated:</p>

<blockquote><pre>
basic_string(basic_string&amp;&amp; str) <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>Edit 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a>/17 as indicated:</p>

<blockquote><pre>
basic_string(const basic_string&amp; str, const Allocator&amp; alloc);
basic_string(basic_string&amp;&amp; str, const Allocator&amp; alloc);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<del>-17- <i>Throws:</i> The second form throws nothing if <tt>alloc == str.get_allocator()</tt>.</del>.
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2326" href="2326">2326.</a> <tt>uniform_int_distribution&lt;unsigned char&gt;</tt> should be permitted</h3>
<p><b>Section:</b> 28.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.req.genl">[rand.req.genl]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2017-02-02 00:41:18 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.req.genl">[rand.req.genl]</a>/1 says: "Throughout this subclause 26.5, the effect of instantiating a template [...] that has a 
template type parameter named <tt>IntType</tt> is undefined unless the corresponding template argument is <i>cv</i>-unqualified 
and is one of <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, <tt>long long</tt>, <tt>unsigned short</tt>, <tt>unsigned int</tt>, 
<tt>unsigned long</tt>, or <tt>unsigned long long</tt>."  28.5.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.uni.int">[rand.dist.uni.int]</a> specifies 
<tt>template&lt;class IntType = int> class uniform_int_distribution</tt>, so this forbids 
<tt>uniform_int_distribution&lt;char/signed char/unsigned char&gt;</tt>.
<p/>
I am not aware of anything in <tt>&lt;random&gt;</tt> that works with 16-bit integers but fails with 8-bit integers, so I suspect 
that <tt>IntType</tt> and <tt>UIntType</tt> could simply be extended to permit the <tt>char</tt> family. Alternatively, this 
change could be limited to <tt>uniform_int_distribution</tt> alone, where it is definitely safe. A <tt>&lt;random&gt;</tt> expert 
should decide which change is best.
</p>

<p><i>[2015-04-04 Geoffrey provides wording]</i></p>

<p>
 I think it's time to call the question; it's just silly that we have a random number library with no natural way to generate 
 random bytes. However, I don't think it's sufficient to fix only <tt>uniform_int_distribution</tt>, or even all of <tt>IntType</tt>. 
 At a bare minimum we need to also fix <tt>independent_bits_engine</tt> (arguably the cleanest way of generating a random byte) 
 and that's specified in terms of <tt>UIntType</tt>.
 <p/>
 The wording provided below is equivalent to adding <tt>unsigned char</tt> to item "f" and adding <tt>signed char</tt> and 
 <tt>unsigned char</tt> to item "e". That means it still excludes <tt>char</tt>, but I'm OK with that. If you want to generate 
 a 1-byte number, you should probably pick a signedess, and if you want to generate a raw byte, the "true" raw byte type is 
 <tt>unsigned char</tt>. This also excludes extended integral types and wide char types, which seem like nice-to-haves at best. 
 I have no objection to supporting any of those types; I just picked this to simplify the wording and hopefully maximize consensus. 
 Note that if we want to broaden <tt>IntType</tt> to permit any integral type, we'll need to decide if we want to exclude <tt>bool</tt>.
<p/>
For reference, <tt>IntType</tt> is used as a parameter of the following templates:
</p>
<blockquote>
<pre>
uniform_int_distribution
binomial_distribution
geometric_distribution
negative_binomial_distribution
poisson_distribution
discrete_distribution
</pre>
</blockquote>
<p>
and <tt>UIntType</tt> is used as a parameter of the following templates:
</p>
<blockquote>
<pre>
linear_congruential_engine
mersenne_twister_engine
subtract_with_carry_engine
independent_bits_engine
</pre>
</blockquote>

<p><i>[2015-9-11, Telecon]</i></p>

<p>Walter feels very strongly that this is not a defect, but a feature request.</p>
<p>In a previous telecon, Aaron offered to write a paper proposing this.</p>
<p>Jonathan offered to help.</p>

<p>Closing as NAD</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change in 28.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.req.genl">[rand.req.genl]</a> p1 as indicated:</p>

<p>
-1- Throughout this subclause 26.5, the effect of instantiating a template:
</p>
<ol style="list-style-type:lower-alpha;" start="4">
<li><p>[&hellip;]</p></li>
<li><p>that has a template type parameter named <tt>IntType</tt> is undefined unless the corresponding template
argument is cv-unqualified and is <ins>a standard integer type (6.8.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>)</ins><del>one of 
<tt>short</tt>, <tt>int</tt>, <tt>long</tt>, <tt>long long</tt>, <tt>unsigned short</tt>, <tt>unsigned int</tt>, 
<tt>unsigned long</tt>, or <tt>unsigned long long</tt></del>.</p></li>
<li><p>that has a template type parameter named <tt>UIntType</tt> is undefined unless the corresponding template
argument is cv-unqualified and is <ins>a standard unsigned integer type (6.8.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>)</ins><del>one 
of <tt>unsigned short</tt>, <tt>unsigned int</tt>, <tt>unsigned long</tt>, or <tt>unsigned long long</tt></del>.</p></li>
</ol>
</li>
</ol>





<hr>
<h3><a name="2327" href="2327">2327.</a> Non-power-of-two URNGs should be forbidden</h3>
<p><b>Section:</b> 28.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/rand.req.urng">[rand.req.urng]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.urng">issues</a> in [rand.req.urng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/rand.req.urng">[rand.req.urng]</a> allows URNGs with non-power-of-two (NPOT) ranges, like <tt>[0, 1729]</tt>. This is unnecessarily permissive 
(I cannot imagine a realistic source of randomness that would generate such a range) and has real costs for implementers, as 
<tt>uniform_int_distribution</tt> must be prepared to accept such URNGs. The most efficient way to accumulate randomness is to 
concatenate random bits, so NPOT randomness is not just useless, it is actively harmful (to avoid bias, if a URNG generates a 
random number outside of a power-of-two range, the number must be discarded).
<p/>
Forbidding NPOT URNGs wouldn't affect users, and would simplify Standard Library implementations. It would be nice to require 
<tt>min()</tt> to be <tt>0</tt>, but this is not necessary; it is simple for implementations to say <tt>g() - G::min()</tt> and 
this will optimize away if <tt>min()</tt> is <tt>0</tt>. (It is vaguely plausible for a URNG to have a nonzero minimum; I can 
imagine something that simply masks off low-order bits without shifting the rest downwards.) What is important is for the entire 
range to have a power-of-two width; <tt>[1729, 1984]</tt> is acceptable as its size is 256.
</p>

<p><i>[2013-10-12: Howard presents a counterexample]</i></p>


<p>
Consider:
</p>
<blockquote><pre>
#include &lt;random&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

template &lt;class Int&gt;
bool is_power_2m1(Int i)
{
  return (i &amp; (i + 1)) == 0;
}

template &lt;class URNG&gt;
void test(const std::string&amp; urng)
{
  using namespace std;
  typename URNG::result_type rng = URNG::max() - URNG::min();
  if (!is_power_2m1(rng))
  {
    cout &lt;&lt; hex;
    cout &lt;&lt; urng &lt;&lt; " : min = " &lt;&lt; URNG::min() &lt;&lt; ", max = " &lt;&lt; URNG::max()
         &lt;&lt; ", max-min = " &lt;&lt; rng &lt;&lt; '\n';
  }
};

int main()
{
    using namespace std;
    test&lt;minstd_rand0&gt;("minstd_rand0");
    test&lt;minstd_rand&gt;("minstd_rand");
    test&lt;mt19937&gt;("mt19937");
    test&lt;mt19937_64&gt;("mt19937_64");
    test&lt;ranlux24_base&gt;("ranlux24_base");
    test&lt;ranlux48_base&gt;("ranlux48_base");
    test&lt;ranlux24&gt;("ranlux24");
    test&lt;ranlux48&gt;("ranlux48");
    test&lt;knuth_b&gt;("knuth_b");
}
</pre></blockquote>

<p>
Which for me outputs:
</p>

<blockquote><pre>
minstd_rand0 : min = 1, max = 7ffffffe, max-min = 7ffffffd
minstd_rand : min = 1, max = 7ffffffe, max-min = 7ffffffd
knuth_b : min = 1, max = 7ffffffe, max-min = 7ffffffd
</pre></blockquote>

<p>
We do not want to outlaw these three URNG's, and the proposed wording would do that.
</p>

<p><i>[Issaquah 2014-02-10: Moved to NAD]</i></p>

<p>
STL withdraws the issue, non-power-of-2 URNGs are used in the field, it is too late to consider removing them.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Add a new paragraph at the end of 28.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/rand.req.urng">[rand.req.urng]</a> as indicated:</p>

<blockquote>
<p>
-3- The following relation shall hold: <tt>G::min() &lt; G::max()</tt>.
<p/>
<ins>-?- <tt>G::max() - G::min()</tt> shall be 2<sup><tt>n</tt></sup> - 1 for some <tt>n &gt; 0</tt>.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2335" href="2335">2335.</a> <tt>array&lt;array&lt;int, 3&gt;, 4&gt;</tt> should be layout-compatible with <tt>int[4][3]</tt></h3>
<p><b>Section:</b> 24.3.7 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2013-10-04 <b>Last modified:</b> 2020-11-09 20:22:58 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to replace some uses of C arrays with <tt>std::array</tt>, we need it
to be possible to cast from a <tt>std::array&lt;&gt;</tt> to an equivalent C array.
Core wording doesn't appear to be in quite the right state to allow
casting, but if we specify that appropriate types are
layout-compatible, we can at least write:
</p>
<blockquote><pre>
union {
  array&lt;array&lt;array&lt;int, 2&gt;, 3&gt;, 4&gt; arr;
  int carr[4][3][2];
};
</pre></blockquote>
<p>
to view memory as the other type: C++14 CD [class.mem]p18.
</p>
I believe it's sufficient to add "<tt>array&lt;T, N&gt;</tt> shall be
layout-compatible (6.8 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>) with <tt>T[N]</tt>." to 
24.3.7.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>, but we might also need some extension to 
11.4 <a href="https://timsong-cpp.github.io/cppwp/class.mem">[class.mem]</a> to address the possibility of layout-compatibility 
between struct and array types.
<p>
I checked that libc++ on MacOS already implements this, although it
would be good for someone else to double-check; I haven't checked any
other standard libraries.
</p>

<p><i>[2020-02-14, Prague]</i></p>

<p>
LWG discussions and decision for NAD. 
</p>
<p><i>[2020-11-09 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Rationale:</b></p>
The desire to use <tt>std::array</tt> like this seems like an "XY problem". The goal 
should be "replace C arrays" not "replace C arrays with <tt>std::array</tt>", because 
<tt>std::array</tt> is not suitable here. There are superior solutions being proposed, 
and will be available in a future version of C++ (e.g. using <tt>mdspan</tt> as a 
multi-dimensional view on an array).


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2337" href="2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.3.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2017-07-17 23:27:54 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a>/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.3.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.3.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a>/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.3.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2345" href="2345">2345.</a> <tt>integer_sequence</tt> should have a self-typedef <tt>::type</tt></h3>
<p><b>Section:</b> 21.2.2 <a href="https://timsong-cpp.github.io/cppwp/intseq.intseq">[intseq.intseq]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-11-01 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.3.4 <a href="https://timsong-cpp.github.io/cppwp/meta.help">[meta.help]</a> says that <tt>integral_constant&lt;T, v&gt;</tt> provides <tt>::value_type</tt> (for <tt>T</tt>) 
and <tt>::type</tt> (for itself).
<p/>
21.2.2 <a href="https://timsong-cpp.github.io/cppwp/intseq.intseq">[intseq.intseq]</a> says that <tt>integer_sequence&lt;T, I...&gt;</tt> provides <tt>::value_type</tt> (for <tt>T</tt>), 
but nothing for itself.
<p/>
Self-typedefs can be useful when users create chains of derived classes, then want to get the Standard base type.  
This is especially relevant to <tt>integer_sequence</tt>, as variadic templates encourage recursive inheritance.
</p>

<p><i>[2014-02-13 Issaquah: Close as NAD]</i></p>

<p>
AJM: My own implementation used a different alias for types representing parameter packs, and specifically
did <em>not</em> define <tt>type</tt>.  I tried it both ways, and found bugs more quickly when <tt>type</tt> was
not defined.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Edit 21.2.2 <a href="https://timsong-cpp.github.io/cppwp/intseq.intseq">[intseq.intseq]</a> as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class T, T... I&gt;
  struct integer_sequence {
    typedef T value_type;
    <ins>typedef integer_sequence&lt;T, I...&gt; type;</ins>
    static constexpr size_t size() noexcept { return sizeof...(I); }
  };
}
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="2347" href="2347">2347.</a> <tt>reverse_iterator::operator[]</tt> calls const version of <tt>current[]</tt></h3>
<p><b>Section:</b> 25.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Timo Bingmann <b>Opened:</b> 2013-11-11 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#reverse.iter.elem">active issues</a> in [reverse.iter.elem].</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.elem">issues</a> in [reverse.iter.elem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently <tt>reverse_iterator::operator[]()</tt> returns "<tt>current[-n-1]</tt>" and has
an "<em>unspecified</em>" return type.
<p/>
When <tt>Iterator</tt> is a mutable random access iterator, the expression
"<tt>current[-n-1]</tt>" calls "<tt>Iterator::operator[] const</tt>", which returns a
const reference. This const reference cannot be converted back to a
mutable reference.
<p/>
This issue is related to the "<em>unspecified</em>" return value of
<tt>reverse_iterator::operator[]</tt>, see defect <a href="386">386</a>.
<p/>
The -1 is due to "current" pointing one item beyond the
<tt>reverse_iterator</tt>'s real current value.
<p/>
The current libstdc++ implementation reads "<tt>*(current + n)</tt>" for
<tt>reverse_iterator::operator[]</tt>.
<p/>
This copied <tt>current</tt>, advances (backwards) via <tt>operator+</tt> and
dereferences. It bypasses the issues due to <tt>reverse_iterator::operator[]</tt>
being const by copying the iterator.
</p>

<p><i>[2014-02-13 Issaquah : close as NAD]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Edit 25.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a>, class template <tt>reverse_iterator</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Iterator&gt;
  class reverse_iterator : public
  iterator&lt;typename iterator_traits&lt;Iterator&gt;::iterator_category,
    typename iterator_traits&lt;Iterator&gt;::value_type,
    typename iterator_traits&lt;Iterator&gt;::difference_type,
    typename iterator_traits&lt;Iterator&gt;::pointer,
    typename iterator_traits&lt;Iterator&gt;::reference> {
  public:
    [&hellip;]
    <del><em>unspecified</em></del><ins>reference</ins> operator[](difference_type n) const;
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Edit  [reverse.iter.opindex] as indicated:</p>

<blockquote><pre>
<del><em>unspecified</em></del><ins>reference</ins> operator[](
  typename reverse_iterator&lt;Iterator&gt;::difference_type n) const;
</pre><blockquote>
<p>
-1- <i>Returns:</i> <tt><del>current[-n-1]</del><ins>*(current + n)</ins></tt>.
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2351" href="2351">2351.</a> Does <tt>.seed()</tt> completely reset state of engine?</h3>
<p><b>Section:</b> 28.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With regard to Random number engine class templates 28.5.4 <a href="https://timsong-cpp.github.io/cppwp/rand.eng">[rand.eng]</a>,
the Standard can be read in two different ways: when the member function
</p>
<blockquote><pre>
.seed(result_type s = default_seed)
</pre></blockquote>
<p>
is invoked, is all associated state (such as carry) reset to the same
state that would have been created by the constructor
</p>
<blockquote><pre>
explicit <em>engine-type</em>(result_type s = default_seed)
</pre></blockquote>
<p>
or is the exact state unspecified?
<p/>
Implementations differ.
</p>

<p><i>[2014-02-13, Issaquah]</i></p>

<p>
Walter Brown says that Table 117 makes this very clear, and that the answer is "Yes"
<p/>
Suggested resolution: NAD
</p>

<p><i>[2015-05-05 Lenexa: Move to NAD]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Suggested resolution: NAD
</p>





<hr>
<h3><a name="2352" href="2352">2352.</a> Is a default-constructed <tt>std::seed_seq</tt> intended to produce a predictable <tt>.generate()</tt>?</h3>
<p><b>Section:</b> 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2022-08-24 18:54:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With respect to class <tt>seed_seq</tt> 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/rand.util.seedseq">[rand.util.seedseq]</a>, is a default-constructed 
<tt>std::seed_seq</tt> intended to produce a predictable <tt>.generate()</tt> sequence?
<p/>
Implementations differ.
</p>

<p><i>[2014-02-10]</i></p>

<p>Priority set to 2</p>

<p><i>[2022-08-24 Status changed: New &rarr; NAD.]</i></p>

<p>
Discussed in LWG telecon.
The default constructor effects are clear. Implementations agree.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2355" href="2355">2355.</a> <tt>"s"</tt> UDL suffix should be reserved for a compile-time string library type</h3>
<p><b>Section:</b> 23.4.7 <a href="https://timsong-cpp.github.io/cppwp/basic.string.literals">[basic.string.literals]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Michael Price <b>Opened:</b> 2014-01-18 <b>Last modified:</b> 2016-01-28 10:19:27 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current draft uses the <tt>"s"</tt> UDL suffix as a UDL for <tt>basic_string&lt;charT&gt;</tt> (23.4.7 <a href="https://timsong-cpp.github.io/cppwp/basic.string.literals">[basic.string.literals]</a>). 
In light of EWG active issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3682.html#66">66</a> (concerning N3599), 
the <tt>"s"</tt> suffix (when applied to character string literals) should be reserved for a compile-time string library type.
</p>

<p><i>[Issaquah 2014-10-12: Move to NAD]</i></p>


<p>We discussed leaving the <tt>s</tt> UDL suffix for <tt>string_view</tt> in Portland, and voted strongly in favor of using it for <tt>std::string</tt>.
<tt>string</tt> is also an extremely widely used type, and the difference is observable in type deduction cases.
In addition, a compile-time string is likely to cost significant compile time, which we don't want to make the default with <tt>s</tt>.</p>
<table>
  <caption>Mark 2355 as NAD?</caption>
  <tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
  <tr><td>8</td> <td>4</td><td>0</td><td>2</td><td>0</td></tr>
</table>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2372" href="2372">2372.</a> Assignment from int to <tt>std::string</tt></h3>
<p><b>Section:</b> 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrzej Krzemie&#324;ski <b>Opened:</b> 2014-03-13 <b>Last modified:</b> 2018-06-23 17:54:13 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code works in C++:
</p>
<blockquote><pre>
int i = 300;
std::string threeHundred;
threeHundred = i;
</pre></blockquote>
<p>
"Works" == "Compiles and doesn't have an undefined behavior". But it may not be obvious and in fact misleading what it does. 
This assignment converts an <tt>int</tt> to <tt>char</tt> and then uses <tt>string</tt>'s assignment from <tt>char</tt>. While 
the assignment from <tt>char</tt> can be considered a feature, being able to assign from an int looks like a safety gap. Someone 
may believe C++ works like "dynamically typed" languages and expect a lexical conversion to take place.
<p/>
Ideally the assignment from <tt>char</tt> could be deprecated and later removed, but as a less intrusive alternative one could 
consider adding a SFINAEd deleted function template:
</p>
<blockquote><pre>
template &lt;typename IntT&gt; // enable if is_integral&lt;IntT&gt;::value
basic_string&amp; operator=(IntT) = delete;
</pre></blockquote>

<p><i>[Lenexa 2015-06-06: Move to LEWG]</i></p>

<p>RS: <tt>std::string x('0' + n);</tt> broken by this.</p>
<p>MC: This is an extension, move to LEWG.</p>
<p>Move to LEWG, consensus.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>To 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, class template <tt>basic_string</tt> synopsis, add as indicated:</p>

<blockquote><pre>
basic_string&amp; operator=(const basic_string&amp; str);
basic_string&amp; operator=(basic_string&amp;&amp; str) noexcept;
basic_string&amp; operator=(const charT* s);
basic_string&amp; operator=(charT c);
<ins>template &lt;class IntT&gt; basic_string&amp; operator=(IntT i) = delete;</ins>
basic_string&amp; operator=(initializer_list&lt;charT&gt;);
</pre></blockquote>
</li>

<li><p>Add after 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> p26 as indicated:</p>

<blockquote>
<pre>
basic_string&amp; operator=(charT c);
</pre>
<blockquote>
<p>
-26- <i>Returns</i>: <tt>*this = basic_string(1,c)</tt>.
</p>
</blockquote>

<pre>
<ins>template &lt;class IntT&gt; basic_string&amp; operator=(IntT i) = delete;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks</i>: This signature shall not participate in overload resolution unless <tt>is_integral&lt;T&gt;::value</tt> is 
<tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[LEWG: 2016-03, Jacksonville]</i></p>

<p>
<tt>is_integral&lt;T&gt;::value</tt> &rarr; <tt>is_arithmetic&lt;<i>tmpl-arg</i>&gt;::value</tt>
<p/>
This needs a paper; close the issue
<p/>
We don't think the breakage is acceptable.
<p/>
Guidance to author: Look for a way to encourage a warning; discomfort with calling that "deprecation".
<p/>
Consider <tt>+=</tt> and <tt>push_back</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This should be addressed by a paper addressed to LEWG.
</p>





<hr>
<h3><a name="2373" href="2373">2373.</a> Make new entities and names in namespace <tt>std</tt> conforming extensions</h3>
<p><b>Section:</b> 16.4.6 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Chandler Carruth <b>Opened:</b> 2014-03-22 <b>Last modified:</b> 2015-05-22 19:00:31 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#conforming">issues</a> in [conforming].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Technically, right now, it is not a conforming extension to add a new function to namespace <tt>std</tt>. Doing so could cause 
unqualified lookup on the name of that function in the presence of a using directive to find a different function. This seems 
an unreasonable restriction on library vendors providing conforming extensions, as such a using directive seems inherently risky 
in unqualified name lookup.
</p>
<p>
16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> implies that adding overloads to a method <em>is</em> a conforming extension, and within some 
limits the same is true for global functions due to 16.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a>.
<p/>
It would likely be useful to specify that other new entities are valid conforming extensions, or preclude them where they pose 
serious compatibility problems.
</p>

<p><i>[Lenexa 2015-05-06: Move to NAD]</i></p>

<p>JY: It's a design question, move to LEWG?</p>
<p>AM: NAD: extensions led to us being unable to use the names hash_map, leading to unordered_map etc. Will result in collisions between members.</p>
<p>MC: Agrees, implementations that extend std:: must use __ugly_names for this reason.</p>
<p>JY: I would not oppose NAD.</p>
<p>Move to NAD, consensus.</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2379" href="2379">2379.</a> Obtaining native handle of the current thread</h3>
<p><b>Section:</b> 33.2.3 <a href="https://timsong-cpp.github.io/cppwp/thread.req.native">[thread.req.native]</a>, 33.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.this">[thread.thread.this]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2014-03-31 <b>Last modified:</b> 2015-10-21 05:22:23 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class <tt>thread</tt> contains an implementation-defined type <tt>thread::native_handle_type</tt>, and an implementation-defined 
function <tt>thread::native_handle()</tt> that returns a value of that type. The presence and semantics of those members is 
implementation-defined; the intention is that they can be used for interoperability with libraries that rely on operating system 
specific features. (Posix libraries that accept arguments of type <tt>pthread_t</tt>, for example.)
<p/>
Unfortunately, there appears to be no native handle support for the equivalent of <tt>pthread_self()</tt>. We can use 
<tt>this_thread::get_id()</tt> to obtain the <tt>thread::id</tt> of the current thread, but there is no mechanism for converting 
a <tt>thread::id</tt> to a <tt>thread::native_handle</tt>.
<p/>
<em>Proposed wording:</em>
<p/>
In 33.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.this">[thread.thread.this]</a> add:
</p>
<blockquote><pre>
thread::native_handle_type native_handle(); <i>// See 30.2.3</i>
</pre></blockquote>
<p>
 to the <tt>this_thread</tt> namespace synopsis.
<p/>
<em>Rationale:</em>
<p/>
Informally, we could address this issue either by adding a new function in <tt>this_thread</tt> or by providing a mechanism for converting 
between <tt>thread::id</tt> and <tt>thread::native_handle</tt>. I propose the former because it seems more localized, and doesn't involve 
saying anything more about implementation defined native functionality than we currently do.
<p/>
It's intentional that the proposed resolution adds a declaration of <tt>native_handle()</tt> without adding a paragraph explaining what 
it does. This is because everything about <tt>native_handle()</tt> is implementation-defined. The standard does the same thing in 
33.4.3.6 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.member">[thread.thread.member]</a>. 
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>

<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
Strong "don't care" reaction from SG1, after pointing out that this only matters in non-portable code, which can call pthread_self() or the like anyway, but the change also doesn't add any non-trivial implementation requirements.  This defused initial strong opinions on both sides.  Since this is essentially a feature request, we did not have sufficient consensus to proceed at this point.  There was a feeling we should reconsider after making more sense out of the much more general TLS issues we have been discussing.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 33.2.3 <a href="https://timsong-cpp.github.io/cppwp/thread.req.native">[thread.req.native]</a> p1 as indicated:</p>

<blockquote>
<p>
-1- <del>Several classes described in this Clause have members</del><ins>This Clause includes several members named</ins> 
<tt>native_handle_type</tt> and <tt>native_handle</tt>. The presence of these members and their semantics is 
implementation-defined. [&hellip;]
</p>
</blockquote>
</li>

<li><p>In 33.4 <a href="https://timsong-cpp.github.io/cppwp/thread.threads">[thread.threads]</a>, header <tt>&lt;thread&gt;</tt> synopsis, add:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  namespace this_thread {
    thread::id get_id() noexcept;
    <ins>thread::native_handle_type native_handle();</ins>
    [&hellip;]
  }
}
</pre>
</blockquote>
</li>

<li><p>In 33.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.this">[thread.thread.this]</a> add:</p>
<blockquote>
<pre>
namespace std {
  namespace this_thread {
    thread::id get_id() noexcept;
    <ins>thread::native_handle_type native_handle(); <i>// See 33.2.3 <a href="https://timsong-cpp.github.io/cppwp/thread.req.native">[thread.req.native]</a></i></ins>
    [&hellip;]
  }
}
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2382" href="2382">2382.</a> Unclear order of container update versus object destruction on removing an object</h3>
<p><b>Section:</b> 16.4.6.9 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a> <b>Status:</b> <a href="lwg-active.html#NAD">Pending NAD</a>
 <b>Submitter:</b> Peter Kasting <b>Opened:</b> 2014-05-06 <b>Last modified:</b> 2014-11-04 10:26:50 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#reentrancy">issues</a> in [reentrancy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Pending NAD">Pending NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard does not seem to discuss reentrant access to a container during removal of an element, 
leaving it unclear whether a removed object is destroyed before or after it is removed from the container.  
For example, the behavior of the following code seems to be unspecified:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;

struct T;
typedef std::map&lt;int, std::shared_ptr&lt;T&gt;&gt; TMap;

struct T {
  T(TMap* t_map, int index) : t_map(t_map), index(index) {}
  ~T() {
    std::cout &lt;&lt; "Object " &lt;&lt; index &lt;&lt; " is ";
    if (t_map->count(index))
      std::cout &lt;&lt; "destroyed before being removed from the map" &lt;&lt; std::endl;
    else
      std::cout &lt;&lt; "removed from the map before being destroyed" &lt;&lt; std::endl;
  }

  static void AddToMap(TMap* map, int index) {
    (*map)[index] = std::make_shared&lt;T&gt;(map, index);
  }

  TMap* t_map;
  int index;
};

int main()
{
  TMap t_map;
  T::AddToMap(&amp;t_map, 0);
  T::AddToMap(&amp;t_map, 1);
  t_map.erase(1);
  t_map.erase(0);
}
</pre></blockquote>
<p>
The output of this program in Visual Studio 2013 is:
</p>
<blockquote><pre>
Object 1 is removed from the map before being destroyed
Object 0 is destroyed before being removed from the map
</pre></blockquote>
<p>
The core issue here is whether an object removed from a container should be destroyed before or after 
it is removed from the container. The current standard seems to be silent on this issue. 
The above output demonstrates that the behavior is actually inconsistent. (It's difficult to fully 
describe Visual Studio's behavior; for example, changing <tt>main()</tt> in the above example to the following:)
</p>
<blockquote><pre>
int main()
{
  TMap t_map;
  T::AddToMap(&amp;t_map, 0);
  T::AddToMap(&amp;t_map, 1);
  T::AddToMap(&amp;t_map, 2);
  T::AddToMap(&amp;t_map, 3);
  t_map.erase(3);
  t_map.clear();
}
</pre></blockquote>
<p>
(...gives this output:)
</p>
<blockquote><pre>
Object 3 is removed from the map before being destroyed
Object 2 is destroyed before being removed from the map
Object 1 is destroyed before being removed from the map
Object 0 is removed from the map before being destroyed
</pre></blockquote>
<p>
In my opinion, the standard should explicitly describe when objects are destroyed as part of removal from a container. 
To me, it makes the most sense to say that objects should be removed from the container before they are destroyed.
</p>
<p><i>[2014-05-07, Jeffrey Yasskin comments]</i></p>

<p>
I think there are two main points here beyond this writeup:
</p>
<ol>
<li><p>We can't make recursive use of a standard library container valid
in all cases.</p></li>
<li><p>If recursion through especially <tt>erase()</tt> is undefined behavior,
that's pretty scary for existing large applications with code in
destructors. Of course, "scary" doesn't mean we have to define the
behavior.</p></li>
</ol>
<p>
I'll add a third: The language in 16.4.6.9 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a> nearly makes this
undefined behavior already. I think any fix is probably going to live
there, and extend the current "implementation-defined" on recursive
reentrancy for individual functions to recursive reentrancy on class
instances. I'm not sure exactly how to word that.
</p>

<p><i>[2014-06 Rapperswil]</i></p>

<p>
STL: We need more wording about how container methods can be reentrency.
<p/>
Jeffrey: The title for this issue is confusing, what we really want is "reentrancy for objects".
<p/>
Alisdair: Should we then close 2382 as NAD with a link to the new issue? 
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2386" href="2386">2386.</a> <tt>function::operator=</tt> handles allocators incorrectly</h3>
<p><b>Section:</b> 22.10.17.3.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-05-23 <b>Last modified:</b> 2015-05-05 19:15:38 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <i>Effects</i> clauses for the assignment operator for class template <tt>function</tt> are
written as code that constructs a temporary <tt>function</tt> and then swaps it with <tt>*this</tt>.
The intention appears to be that assignment should have the strong exception 
guarantee, i.e., <tt>*this</tt> is not modified if an exception is thrown. However, the current 
description is incorrect when <tt>*this</tt> was constructed using an allocator.
<p/>
Part of the problem is the under-specification of <tt>swap</tt>, which does not state the 
allocator requirements or allocator postconditions. If <tt>swap</tt> behaves like the rest of the 
standard library, swapping function objects constructed with different allocators 
would be undefined behavior. Alternatively <tt>swap</tt> could exchange the allocators, 
though I would argue against this specification.
<p/>
For either specification of <tt>swap</tt>, the current <i>Effects</i> clauses for <tt>operator=</tt> are
incorrect. If <tt>swap</tt> does not exchange the allocators, then <tt>operator=</tt> would have 
undefined behavior, which is clearly not desired. If <tt>swap</tt> does exchange the allocators, 
then <tt>operator=</tt> would always leave the left-hand side (lhs) of the assignment with a 
default allocator. The latter would be surprising behavior, as the allocator instance is 
normally unchanged for the lifetime of an object (for good reason), and is certainly not 
reset to default arbitrarily.
<p/>
The desired behavior is that assignment would leave the allocator of the lhs
unchanged. The way to achieve this behavior is to construct the temporary <tt>function</tt> 
using the original allocator. Unfortunately, we cannot describe the desired behavior in 
pure code, because there is no way to name the type-erased value of the allocator. 
(N3916 would improve this situation for the Library Fundamentals TS, but even with 
those changes, there is no way to recover the original type of the allocator.) The PR 
below, therefore, uses pseudo-code, inventing a fictitious <tt><i>ALLOCATOR_OF</i>(f)</tt> 
expression that evaluates to the actual allocator type, even if that allocator was type 
erased. I have implemented this PR successfully.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 22.10.17.3.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> as indicated:</p>

<blockquote>
<p>
<ins>In the following descriptions, <tt><i>ALLOCATOR_OF</i>(f)</tt> is a copy of the allocator specified in the 
construction of <tt>function</tt> <tt>f</tt>, or <tt>allocator&lt;char&gt;()</tt> if no allocator was specified.</ins>
</p>
<pre>
function&amp; operator=(const function&amp; f);
</pre>
<blockquote>
<p>
-12- <i>Effects</i>: <tt>function(<ins>allocator_arg, <i>ALLOCATOR_OF</i>(*this),</ins> f).swap(*this);</tt>
<p/>
-13- <i>Returns</i>: <tt>*this</tt>
</p>
</blockquote>
<pre>
function&amp; operator=(function&amp;&amp; f);
</pre>
<blockquote>
<p>
-14- <i>Effects</i>: <del>Replaces the target of <tt>*this</tt> with the target of <tt>f</tt>.</del><ins><tt>function(allocator_arg,
<i>ALLOCATOR_OF</i>(*this), std::move(f)).swap(*this);</tt></ins>
<p/>
-15- <i>Returns</i>: <tt>*this</tt>
</p>
</blockquote>
<pre>
function&amp; operator=(nullptr_t);
</pre>
<blockquote>
<p>
-16- <i>Effects</i>: If <tt>*this != nullptr</tt>, destroys the target of <tt>this</tt>.
<p/>
-17- <i>Postconditions</i>: <tt>!(*this)</tt>. <ins>The allocator is unchanged.</ins>
<p/>
-18- <i>Returns</i>: <tt>*this</tt>
<p/>
<ins>-?- <i>Throws</i>: Nothing.</ins>
</p>
</blockquote>
<pre>
template&lt;class F&gt; function&amp; operator=(F&amp;&amp; f);
</pre>
<blockquote>
<p>
-19- <i>Effects</i>: <tt>function(<ins>allocator_arg, <i>ALLOCATOR_OF</i>(*this),</ins> std::forward&lt;F&gt;(f)).swap(*this);</tt>
<p/>
-20- <i>Returns</i>: <tt>*this</tt>
<p/>
-21- <i>Remarks</i>: This assignment operator shall not participate in overload resolution unless 
<tt>declval&lt;typename decay&lt;F&gt;::type&amp;&gt;()</tt> is <tt>Callable</tt> (20.9.11.2) for argument types 
<tt>ArgTypes...</tt> and return type <tt>R</tt>.
</p>
</blockquote>
<pre>
template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt; f);
</pre>
<blockquote>
<p>
-22- <i>Effects</i>: <tt>function(<ins>allocator_arg, <i>ALLOCATOR_OF</i>(*this),</ins> f).swap(*this);</tt>
<p/>
-23- <i>Returns</i>: <tt>*this</tt>
</p>
</blockquote>

</blockquote>
</li>

</ol>

</blockquote>

<p><i>[2015-05, Lenexa]</i></p>

<p>
STL: think this is NAD, don't think this is implementable or even should be.<br/>
STL: think this issue should be dealt with the same as 2370, don't think this should be done ever.<br/>
STL: NAD because there is nothing broken here.<br/>
STL: already fixed <tt>operator= noexcept</tt> so <i>Throws</i> nothing is not needed<br/>
STL: nothing to salvage here<br/>
MC: consensus for NAD 
</p>


<p><b>Proposed resolution:</b></p>
<p>
There was consensus by the committee that the issue does not constitute as defect.
</p>





<hr>
<h3><a name="2388" href="2388">2388.</a> Handling self-assignment in the proposed library function <tt>std::exchange</tt></h3>
<p><b>Section:</b> 22.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.exchange">[utility.exchange]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nick Calus <b>Opened:</b> 2014-05-09 <b>Last modified:</b> 2015-05-05 20:05:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.exchange">issues</a> in [utility.exchange].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3668.html">N3668</a>, the addition of a template function 
<tt>std::exchange</tt> had been proposed. In the rationale provided by the paper, we find the following:
</p>
<blockquote>
<p>
I chose the name for symmetry with <tt>atomic_exchange</tt>, since they behave the same except for this function not being atomic.
</p>
</blockquote>
<p>
and:
</p>
<blockquote>
<p>
Atomic objects provide an <tt>atomic_exchange</tt> function ([atomics.types.operations.req]p18) that <em>assigns a new value to the object 
and returns the old value</em>. This operation is also useful on non-atomic objects, and this paper proposes adding it to the library.
<p/>
But the specified semantics of <tt>std::exchange</tt> is defined as follows:
</p>
</blockquote>
<blockquote><pre>
template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);
</pre>
<blockquote>
<p>
<i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
T old_val = std::move(obj);
obj = std::forward&lt;U&gt;(new_val);
return old_val;
</pre>
</blockquote>
</blockquote>
</blockquote>
<p>
When looking at the post-condition of the <tt>std::exchange</tt> function, one would expect the return value to be the old value 
of <tt>obj</tt> and also that <tt>obj</tt> now contains the value of <tt>new_value</tt>.
This post-condition is violated when <tt>obj</tt> is a reference to the same object as <tt>new_value</tt> and type <tt>T</tt> 
has move semantics.
<p/>
Given it's specification, it is clear that <tt>std::exchange</tt> is meant to be used with types that have move semantics.
Therefore, the post-condition is violated for self-assignments.
<p/>
Suppose the following situation:
<p/>
You have a vector of objects. The objects implement move semantics and are emptied when moved from.
You provide a function that allows you to replace an object at a specific index by a new object (provided by reference as 
an argument to your function). When replacing an object, your function calls a member-function <tt>do_something_fancy</tt> 
on the old object.
</p>
<blockquote><pre>
void your_function(int i, X&amp; new_val) {
  std::exchange(vec[i], new_val).do_something_fancy();
}
</pre></blockquote>
<p>
Your function gets called with a given index and the corresponding element of said vector. (by coincidence or by purpose, it 
doesn't really matter)
</p>
<blockquote><pre>
your_function(5, vec[5]);
</pre></blockquote>
<p>
This will cause the object at <tt>vec[5]</tt> to be in an empty state.
If this object would not implement move semantics, assignment performance is potentially worse, but at least it 
is not in an empty (to my business logic, invalid) state.
<p/>
So to me, the current reference implementation of <tt>std::exchange</tt> does not have the behavior it is expected to have.
</p>

<p><i>[2014-12-18 Telecon]</i></p>

<p>
MC: does this resolution solve the problem?
<p/>
JW: and is the cost of the extra construction and move acceptable?
<p/>
AM: not all moves are cheap
<p/>
VV: seems like a design change
<p/>
JW: maybe this should be rolled into my unwritten paper on self-swap, so we deal with them consistently
<p/>
VV: we should update the issue saying something like that and maybe NAD Future
<p/>
MC: instead, add Requires clause saying the arguments are not the same.
<p/>
JW: interesting, that can even be checked in a debug mode assertion
<p/>
MC: ACTION: send alternative P/R that we can consider
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 22.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.exchange">[utility.exchange]</a> as indicated:</p>
<blockquote><pre>
template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<ins>T tmp = std::forward&lt;U&gt;(new_val);</ins>
T old_val = std::move(obj);
obj = <del>std::forward&lt;U&gt;(new_val)</del><ins>std::move(tmp)</ins>;
return old_val;
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p>
<strong>Previous resolution from Marshall [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Change 22.2.3 <a href="https://timsong-cpp.github.io/cppwp/utility.exchange">[utility.exchange]</a> as indicated:</p>
<blockquote><pre>
template &lt;class T, class U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>obj</tt> and <tt>new_val</tt> shall not refer to the same object.</ins>
<p/>
-1- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
T old_val = std::move(obj);
obj = std::forward&lt;U&gt;(new_val);
return old_val;
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-03-30, Marshall provides alternative wording]</i></p>


<p><i>[2015-05, Lenexa]</i></p>

<p>
MC: self <tt>exchange</tt> does not work<br/>
MC: PR is just to add requires<br/>
STL: what if the new thing is a subobject, isn't that just as bad, any aliasing<br/>
STL: don't know that we need to do anything here if we aren't changing the implementation<br/>
NM: should remove the requires<br/>
MC: so NAD<br/>
STL: could add note<br/>
NM: remove requires<br/>
DK: requires isn't already there<br/>
RL: no note?<br/>
STL: no note, NAD, burden for next person that asks about aliasing<br/>
DK: what do we do for <tt>swap</tt>?<br/>
STL: self <tt>swap</tt> has always been noop, <tt>exchange</tt> could do something bad because it clears out<br/>
MC: alright, NAD it is<br/>
</p>



<p><b>Proposed resolution:</b></p>
The current specification is clear about the implications described by the issue example and is as intended.





<hr>
<h3><a name="2402" href="2402">2402.</a> <tt>basic_string(const basic_string&amp; str, size_type pos, size_type n = npos)</tt> shouldn't use <tt>Allocator()</tt></h3>
<p><b>Section:</b> 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-06-14 <b>Last modified:</b> 2016-03-07 05:48:12 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> p3 specifies:
</p>
<blockquote>
<pre>
basic_string(const basic_string&amp; str, size_type pos, size_type n = npos, const Allocator&amp; a = Allocator());
</pre>
<p>
But this implies that <tt>basic_string(str, pos)</tt> and <tt>basic_string(str, pos, n)</tt> use <tt>Allocator()</tt> 
instead of getting an allocator from <tt>str</tt>.
<p/>
23.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.require">[string.require]</a> p3 says "The <tt>Allocator</tt> object used shall be obtained as described in 23.2.1."  
24.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p8 says "Copy constructors for these container types obtain an allocator 
by calling <tt>allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction</tt> on the allocator 
belonging to the container being copied.", but this isn't exactly a copy constructor. Then it talks about move constructors 
(which this definitely isn't), and finally says that "All other constructors for these container types take a 
<tt>const allocator_type&amp;</tt> argument. [&hellip;] A copy of this allocator is used for any memory allocation performed".
</p>
</blockquote>

<p><i>[2015-05-06 Lenexa: move to Open]</i></p>

<p>STL: there an allocator right there in str, why default-construct one</p>
<p>STL: my fix, which may not be right, splits out functions with and without allocators</p>
<p>JW: there are other ways to propagate the allocator from str to the new object</p>
<p>PJP: hard to get motivated about this one</p>
<p>JW: I think this is not a copy operation, this is init'ing a string from a range of characters which happens to originate in a string. It makes it inconsistent with the similar ctor taking a const char pointer, and if we had a std::string_view we wouldn't even have this ctor, and it wouldn't be possible to propagate the allocator.</p>
<p>STL: but people with stateful allocators want it to propagate</p>
<p>JW: I think the people using stateful allocators will alter the default behaviour of select_on_container_copy_construction so that it doesn't propagate, but will return a default-constructed one (to ensure a stateful allocator referring to a stack buffer doesn't leak to a region where the stack buffer has gone). So for those people, your proposed change does nothing, it changes one default-constructed allocator to a call to select_on_container_copy_construction which returns a default-constructed allocator. For other people who have different stateful allocators they can still provide the right allocator (whatever that may be) by passing it in.</p>
<p>STL: OK, that's convincing.</p>
<p>PJP: I agree with Jonathan</p>
<p>JW: would like to run both our arguments by Pablo in case I'm totally misrepresenting the expected users of allocator-traits stuff</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>Everyone thinks this seems right.</p>
<p>STL: It'd be really weird if you copy from a string with a stateful allocator and you'd just default-construct a new allocator.</p>
<p>EF: We definitely need this for polymorphic allocators.</p>
<p>TK: Whether you think this is kind of copy-constructor or a constructor from raw string data, the new form in the PR is more flexible. You can still get the default-constructed allocator if you want, but conversely, getting the select_on_container_copy is really hard to type in the old form.</p>
<p>JW has objections (written in the issue) but won't block "Review" status.</p>
<p>Move to Review, hopefully to be made ready at a telecon.</p>

<p><i>[2015-11-22, Pablo comments]</i></p>

<p>
I like the direction of the PR, but it is incomplete. Consider the following (assuming the PR):
</p>
<blockquote><pre>
typedef basic_string&lt;char, char_traits&lt;char&gt;, A&lt;char&gt;&gt; stringA;
vector&lt;stringA, scoped_allocator_adaptor&lt;A&lt;stringA&gt;&gt;&gt; vs;
stringA s;

vs.emplace_back(s, 2);  // Ill-formed
</pre></blockquote>
<p>
The problem is that uses-allocator construction requires that we be able to pass an allocator to the constructor 
<tt>stringA(s, 2, allocator)</tt>, but no such constructor exists. I think this defect already exists, but we should 
fix it a the same time that we fix 2402. So, I would say we need a third constructor:
</p>
<blockquote><pre>
basic_string(const basic_string&amp; str, size_type pos, const Allocator&amp; a);
</pre></blockquote>

<p><i>[2016-01-05, Pablo comments]</i></p>

<p>
I've reconsidered and I think that the issue as stated, is NAD. I do not like the PR <em>at all</em>. In fact, I think it reverses 
a previous fix and it could break existing code.
<p/>
There are two patterns that are at work here:
</p>
<ol>
<li><p>Every constructor needs a version with and without an allocator argument (possibly through the use of default arguments).</p></li>
<li><p>Every constructor except the copy constructor for which an allocator is not provided uses a default-constructed allocator.</p></li>
</ol>
<p>
The constructors in question are not copy constructors. I do not think it is compelling that the allocator should come 
from its argument any more than it should come from any other object that happens to supply characters for a string 
constructor.

<p><i>[2016-03 Jacksonville]</i></p>

Closed as NAD, noting that <a href="2583">2583</a> is a related issue.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> p5, class template <tt>basic_string</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 21.4.2, construct/copy/destroy:</i>
[&hellip;]
basic_string(basic_string&amp;&amp; str) noexcept;
<ins>basic_string(const basic_string&amp; str, size_type pos, size_type n = npos);</ins>
basic_string(const basic_string&amp; str, size_type pos, size_type n<del> = npos</del>,
            const Allocator&amp; a<del> = Allocator()</del>);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> around p3 as indicated:</p>

<blockquote>
<pre>
<ins>basic_string(const basic_string&amp; str, 
             size_type pos, size_type n = npos);</ins>
basic_string(const basic_string&amp; str, 
             size_type pos, size_type n<del> = npos</del>,
             const Allocator&amp; a<del> = Allocator()</del>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-5- <i>Effects</i>: Constructs an object of class <tt>basic_string</tt> and determines the effective length <tt>rlen</tt> of the
initial string value as the smaller of <tt>n</tt> and <tt>str.size() - pos</tt>, as indicated in Table 65. <ins>The first constructor 
obtains an allocator by calling <tt>allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction</tt> on the 
allocator belonging to <tt>str</tt>.</ins>
<p/>
Table 65 &mdash; <ins><tt>basic_string(const basic_string&amp;, size_type, size_type)</tt> and</ins>
<tt>basic_string(const basic_string&amp;, size_type, size_type, const Allocator&amp;)</tt> effects
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
The existing wording is intended.
</p>





<hr>
<h3><a name="2405" href="2405">2405.</a> <tt>rotate()</tt>'s return value is incorrect when <tt>middle == first</tt></h3>
<p><b>Section:</b> 27.7.11 <a href="https://timsong-cpp.github.io/cppwp/alg.rotate">[alg.rotate]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-06-14 <b>Last modified:</b> 2014-06-17 08:47:43 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.rotate">issues</a> in [alg.rotate].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When LWG <a href="488">488</a> was resolved, the intention was to return "where the subrange <tt>[first, middle)</tt> starts after 
the rotate is performed". However, this wasn't achieved in one case.
<p/>
When <tt>middle == last</tt>, <tt>rotate()</tt> does nothing and returns <tt>first</tt>. This is good.
<p/>
When <tt>middle == first</tt>, <tt>rotate()</tt> does nothing and returns <tt>last</tt>. This is bad. In addition to being 
inconsistent with the other do-nothing case, it prevents <tt>rotate()</tt> from providing the useful guarantee that LWG 
<a href="488">488</a> wanted: when <tt>[first, last)</tt> is non-empty, <tt>rotate()</tt>'s return value should always be 
dereferenceable to get the originally-first element.
<p/>
Howard Hinnant:
<p/>
As the author of LWG <a href="488">488</a> I can assure everyone that the edge cases the proposed resolution specifies were 
not specified by accident. <tt>rotate(i, i, j)</tt> should return <tt>j</tt> and <tt>rotate(i, j, j)</tt> should return <tt>i</tt>.  
Doing otherwise will break working code. These return values were motivated by the uses of <tt>rotate</tt> in the implementation 
of algorithms such as <tt>stable_partition</tt> and <tt>inplace_merge</tt>. The results of these edge cases were not chosen lightly.
<p/>
Also a good read:
<p/>
<a href="http://www.cs.rpi.edu/~musser/gsd/notes-on-programming-2006-10-13.pdf">notes-on-programming-2006-10-13</a>
<p/>
Summary: NAD.
</p>

<p><i>[2014-06-16 Rapperswill]</i></p>

<p>
Closed as NAD.
</p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 27.7.11 <a href="https://timsong-cpp.github.io/cppwp/alg.rotate">[alg.rotate]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- <i>Returns</i>: <ins>If <tt>middle == first</tt>, returns <tt>first</tt>. Otherwise, returns</ins> <tt>first + (last - middle)</tt>.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2417" href="2417">2417.</a> [fund.ts.v2] <tt>std::experimental::optional::operator&lt;</tt> and <tt>LessThanComparable</tt> requirement</h3>
<p><b>Section:</b> 5.7 [fund.ts.v2::optional.relops], 5.9 [fund.ts.v2::optional.comp_with_t] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-06-20 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
Currently, <tt>std::experimental::optional::operator==</tt> imposes the <tt>EqualityComparable</tt> requirement which provides
two guarantees: It ensures that <tt>operator!=</tt> can rely on the equivalence-relation property and more importantly, that
the <tt>BooleanTestable</tt> requirements suggested by issue <a href="2114">2114</a> are automatically implied.
<p/>
<tt>std::experimental::optional::operator&lt;</tt> doesn't provide a <tt>LessThanComparable</tt> requirement, but there was quite
an historic set of changes involved with that family of types: As of <a href="https://wg21.link/n3527.html">N3527</a>
this operator was defined in terms of <tt>operator&lt;</tt> of the contained type <tt>T</tt> and imposed the <tt>LessThanComparable</tt>
requirement. In the final acceptance step of <tt>optional</tt> by the committee, the definition was expressed in terms of <tt>std::less</tt>
and the <tt>LessThanComparable</tt> requirement had been removed.
<p/>
The inconsistency between <tt>operator==</tt> and <tt>operator&lt;</tt> should be removed. One possible course of action would be
to add the <tt>LessThanComparable</tt> to <tt>std::experimental::optional::operator&lt;</tt>. The <tt>EqualityComparable</tt> requirement
of <tt>operator==</tt> could also be removed, but in that case both operators would at least need to require the <tt>BooleanTestable</tt>
requirements (see <a href="2114">2114</a>) for the result type of <tt>T</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>.
<p/>
Arguably, corresponding operators for <tt>pair</tt> and <tt>tuple</tt> do not impose <tt>LessThanComparable</tt> (nor
<tt>EqualityComparable</tt>), albeit the definition of the "derived" relation functions depend on properties ensured by
<tt>LessThanComparable</tt>. According to the <a href="https://www.sgi.com/tech/stl/pair.html">SGI definition</a>, the intention was
to imposed both <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt>. If this is not intended, the standard should clarify
this position.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
VV, DK, JY discuss why and when <tt>LessThanComparable</tt> was removed. AM: Move to LEWG. Please tell LWG when you look at it.
</p>

<p><i>[2016-11-08, Issaquah]</i></p>

<p>Not adopted during NB comment resolution</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: We've done a lot of work getting the C++17 semantics we want in this area; we're not going to change
them 3 days from DIS or change the TSv2 behavior to be different from '17.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2429" href="2429">2429.</a> <tt>std::basic_ostringstream</tt> is missing an allocator-extended constructor</h3>
<p><b>Section:</b> 31.8.4 <a href="https://timsong-cpp.github.io/cppwp/ostringstream">[ostringstream]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Markus Kemp <b>Opened:</b> 2014-09-03 <b>Last modified:</b> 2017-03-21 22:54:52 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostringstream">issues</a> in [ostringstream].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I initially brought this issue up on <a href="http://stackoverflow.com/questions/23955828/how-to-use-basic-ostringstream-with-stateful-custom-allocator-c11">Stack Overflow</a>, 
where I was then told to make a topic about this problem on <a href="https://groups.google.com/a/isocpp.org/d/msg/std-discussion/kAQFOWz47m0/cOXSHa5Iwg4J">std-discussion</a>, 
where I was then in turn asked to report the issue.
<p/>
The problem: The <tt>std::basic_ostringstream</tt> class template can be instantiated with an allocator type, but none of the 
constructors provided accept an allocator argument, which means it's impossible to use <tt>std::basic_ostringstream</tt> with 
stateful allocators. The C++ Standard Library Defect Report List seems to already mention a similar issue (<a href="2210">2210</a>).
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Closed as NAD</p>
<p>
This is not a rejection of the suggestion, but an observation that simply adding an allocator-aware
constructor is only part of the problem.  <tt>stringstream</tt> returns the <tt>string</tt> assembled
in its buffer by value, as the result of a call to <tt>str</tt>, and typically this will not use the
same allocator as would be supplied at construction.
</p>
<p>
The appropriate way to make progress on this issue, if motivated, is to submit a paper to LEWG
addressing the larger design concerns in addition to 'just' adding an (optional) allocator to
the constructors.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2430" href="2430">2430.</a> Heterogeneous container lookup should be enabled using meta-function instead of nested type</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2014-07-14 <b>Last modified:</b> 2018-06-23 21:28:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the heterogeneous lookup in associative container are
enabled by presence of <tt>is_transparent</tt> nested type in the comparator
type (24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>). This complicates the definition
of call wrapper types that want to define <tt>is_transparent</tt> if they wrap
a callable type that defines <tt>is_transparent</tt>, and requires the target
to be a complete type in cases where an incomplete type would otherwise be ok.
<p/>
Another problem is that users cannot add the <tt>is_transparent</tt> member to
a third-party comparison type that they do not control, even if they
know it supports heterogeneous comparisons.
<p/>
If the associative containers used a trait instead of checking for an
<tt>is_transparent</tt> member type then it would avoid the requirement for
complete types, and would allow customization of the trait without
modifying the comparator type. This would also be consistent with the
traits <tt>is_placeholder</tt> and <tt>is_bind_expression</tt>.
<p/>
For backward compatibility with the existing design, the default
implementation of the <tt>is_transparent</tt> trait could depend on the
presence of the <tt>is_transparent</tt> nested type.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Move to LEWG</p>
<p>
Request for a new metafunction should first be responded to by LEWG.
</p>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>In all discussions of heterogeneous lookup, the entire set of those 
discussions has been different integer types or string_view vs string. 
There actually hasn't been an example, that we are aware of, besides those two. 
-- Could always wrap the third-party type with the comparator? 
-- Could benefit from a motivating example. -- is_transparent&lt;&gt;, what does it mean?</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>	The advantages of changing the API now are not sufficiently clear. 
We invite a paper presenting motivating examples and more details of the 
proposed change, but at present consider this Not A Defect.</p>
<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2446" href="2446">2446.</a> Unspecialized <tt>std::tuple_size</tt> should be defined</h3>
<p><b>Section:</b> 22.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2014-10-10 <b>Last modified:</b> 2018-06-23 21:28:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.general">issues</a> in [tuple.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a> paragraph 2, the unspecialized <tt>std::tuple_size</tt> is undefined. It would 
be a lot more useful with SFINAE if it were defined as an empty struct; that way, it can be used with <tt>enable_if</tt> 
for determining whether or not it is valid to use <tt>tuple_size</tt>, <tt>tuple_element</tt> and get on the 
corresponding data structure.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Moved to LEWG 42.</p>
<p>
This request goes beyond simply making an API respond well to SFINAE, but coupling that with an
implication for other tuple APIs.  The proper place for such design discussions is LEWG.
</p>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>We believe there are other ways to achieve the same results (at least for 
all of the use cases we could see). We invite Nevin to provide more details / 
motivations if this is necessary, not just helpful in a limited number of cases.
If the dr is raised, variant_size should be considered for the same change as well.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>It's unclear what benefit this change would have, but making it complete would
have very undesirable interactions with structured bindings. The current Core
wording for structured bindings depends on tuple_size being an incomplete type.
</p>
<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol>
<li><p>Change 22.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.general">[tuple.general]</a> p2, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated</p>
<blockquote>
<pre>
[&hellip;]
// <i>20.4.2.5, tuple helper classes</i>:
template &lt;class T&gt; class tuple_size; <del>// undefined</del>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a> as indicated</p>
<blockquote>
<pre>
[&hellip;]
template &lt;class T&gt; struct tuple_size <ins>{ }</ins>;
[&hellip;]
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2449" href="2449">2449.</a> <tt>vector::insert</tt> invalidates <tt>end()</tt>?</h3>
<p><b>Section:</b> 24.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2014-10-21 <b>Last modified:</b> 2017-03-14 03:14:09 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
this issue is based on the discussion <a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/oYvKscnl280/discussion">here</a>.
<p/>
24.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> says about <tt>vector::insert</tt>: "If no reallocation happens, all the iterators and references 
before the insertion point remain valid." This doesn't seem to guarantee anything about the iterator <em>at</em> the point of insertion.
<p/>
The question comes from people asking if the following is valid, assuming a sufficient call to <tt>reserve()</tt> was done first:
</p>
<blockquote><pre>
v.insert(v.end(), v.begin(), v.end());
</pre></blockquote>
<p>
It could fail for an implementation using a sentinel for the end of the vector, but I don't know of any (it would be quite 
inconvenient). And for any implementation using a simple position as iterator (pointer (possibly in a wrapper), or base+offset), 
this is needlessly restrictive. The fact that this alternative:
</p>
<blockquote><pre>
v.insert(v.end(), &amp;v[0], &amp;v[0]+v.size())
</pre></blockquote>
<p>
is arguably valid (again assuming a large enough <tt>reserve()</tt>) makes it a bit confusing that the first version isn't 
(24.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> has a precondition that iterator arguments to <tt>insert()</tt> do not point into the sequence, 
but <tt>vector::insert</tt> is more refined and seems to give enough guarantees that it cannot fail).
<p/>
Then we might as well say that <tt>vector</tt> iterators act as positions, and that after a reallocation-free operation an 
iterator points to the same position, whatever may be there now&hellip;
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>NAD. The problem description is incorrect; it is a violation of table entry 87 a.insert(p, i, j) - "i and j are not iterators into a".</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2474" href="2474">2474.</a> <tt>&lt;cmath&gt;</tt> functions unfriendly to <tt>integral_constant</tt> arguments</h3>
<p><b>Section:</b> 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matheus Izvekov <b>Opened:</b> 2015-02-13 <b>Last modified:</b> 2015-12-17 07:02:38 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Using numeric wrappers with <tt>&lt;cmath&gt;</tt> functions is currently troublesome.
Code such as: "<tt>std::exp2(std::integral_constant&lt;int, 5&gt;{})</tt>" will fail to 
compile because of ambiguity.
<p/>
Arguments which are implicitly convertible to an arithmetic type should be accepted whenever
the latter would be accepted.
<p/>
David Krauss pointed out that some issue may present itself with numeric libraries which provide <tt>&lt;cmath&gt;</tt> 
equivalents in their own namespace which are not more specialized than the ones provided in <tt>&lt;cmath&gt;</tt>. 
If the changes proposed are implemented, then cases where the user brings those into scope through ADL might become ambiguous.
<p/>
It's hard to assess how much breakage this would cause in the wild, and how much work it would take to fix. 
Should this be determined to be a problem, it's possible to make the new behaviour optional, and disabled by 
default for all user-defined types.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: This should be NAD, NAD-future and NAD-go-away. Users can already solve this using Walter's call syntax.</p>
<p>VV: I don't personally have this problem, but the proposed resolution seems frightening to me.</p>
<p>VV: There's a related issue, 2294, and also 2192.</p>
<p>STL: 2086 is about user-defined types in &lt;cmath&gt;, fixed in C++14. The PR for 2474 wants to undo the fix.</p>
<p>Link to <a href="2086">2086</a> and NAD.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li>
<p>Change 28.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> p11 b2 as indicated:</p>
<blockquote>
<p>
-11- Moreover, there shall be additional overloads sufficient to ensure:
</p>
<ol>
<li><p>[&hellip;]</p></li>
<li><p>Otherwise, if any arithmetic argument corresponding to a <tt>double</tt> parameter has type <tt>double</tt> or 
<del>an integer type</del><ins>a type which is not floating-point, but which is implicitly convertible to <tt>double</tt></ins>, 
then all arithmetic arguments corresponding to <tt>double</tt> parameters are effectively cast to <tt>double</tt>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2535" href="2535">2535.</a> Inconsistency between <tt>ostream::write</tt> and <tt>ostream::operator&lt;&lt;</tt></h3>
<p><b>Section:</b> 23.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/string.io">[string.io]</a>, 31.7.6.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.unformatted">[ostream.unformatted]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2015-09-10 <b>Last modified:</b> 2016-07-13 19:26:53 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following program:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;

template &lt;class CharT&gt;
class testbuf : public std::basic_streambuf&lt;CharT&gt; 
{
public:
  testbuf() {}

protected:
  virtual std::streamsize xsputn(const CharT *s, std::streamsize n)
  {
    std::cout &lt;&lt; "xsputn('" &lt;&lt; s &lt;&lt; "', " &lt;&lt; n &lt;&lt; ")\n";
    return n;
  }
};

int main () 
{
  testbuf&lt;char&gt; sb;
  std::ostream os (&amp;sb);
  
  std::string s1{"abc"};
  os.write(s1.data(), s1.size());
  
  os.write(s1.data(), 0);
  
  std::string s2{"def"};
  os &lt;&lt; s2;
  
  std::string s3{""};
  os &lt;&lt; s3;
  
  os &lt;&lt; "";
}
</pre></blockquote>
<p>
What should it print?
<p/>
libc++:
</p>
<blockquote><pre>
xsputn('abc', 3)
xsputn('def', 3)
</pre></blockquote>
<p>
libstdc++:
</p>
<blockquote><pre>
xsputn('abc', 3)
xsputn('abc', 0)
xsputn('def', 3)
xsputn('', 0)
xsputn('', 0)
</pre></blockquote>
<p>
VS:
</p>
<blockquote><pre>
xsputn('abc', 3)
xsputn('def', 3)
xsputn('', 0)
xsputn('', 0)
</pre></blockquote>
<p>
23.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/string.io">[string.io]</a>/5 seems to say that an implementation is required to call <tt>sputn</tt> (which calls <tt>xsputn</tt>) 
even if there's nothing to output (in the case of <tt>ostream::operator&lt;&lt;(basic_string)</tt>).
<p/>
31.7.6.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.unformatted">[ostream.unformatted]</a>/5.1 implies that it's OK to not call <tt>sputn</tt> if there's nothing to output 
(in the case of <tt>ostream::write</tt>)
<p/>
Backstory: A user has a <tt>ostream</tt> with a subclass of <tt>basic_streambuf</tt>. it creates an output file on first write. 
Sometimes, he calls <tt>ostream::write(p, 0)</tt>, and expects this to create the file. This doesn't work in libc++, and then 
he pointed out the inconsistency between <tt>operator&lt;&lt;</tt> and <tt>write</tt>.
<p/>
For reference to a bug report <a href="https://llvm.org/bugs/show_bug.cgi?id=24437">see here</a>.
<p/>
There are two obvious possible resolutions:
</p>
<ol style="list-style-type: none">
<li><p>a) require all output functions to call <tt>sputn</tt>, even if there are no characters to output. In practice, this 
reduces to "string-like" things which are empty (<tt>string</tt>, <tt>string_view</tt>, <tt>char*</tt>, etc), and 
<tt>write(ptr, len)</tt>.</p></li>
<li><p>b) remove the requirement that <tt>ostream::operator&lt;&lt;</tt> call <tt>sputn</tt> when there are no characters 
to output.</p></li>
</ol>

<p><i>[06-2016 Oulu, Saturday morning]</i></p>

<p>MC: Problem is this program produces different outputs on different platforms. The issue is what happens when you write 0 bytes: do you have to call xsputn? This affects a real customer.</p>
<p>NJ: Why is this a problem? Why not QOI?</p>
<p>DKu: I don’t think it’s a problem.</p>
<p>MC: Making your own streambuf is an explicit customization point.</p>
<p>DKu: But you should expect different numbers of calls.</p>
<p>NJ: They may even split the input, and call xsputn more than once for an input.</p>
<p>MC: Do we actually say that anywhere?</p>
<p>DKu: I think so.</p>
<p>MC: If you can find that, I’d be OK with NAD. The other thing that bothers me is that in one case it says you’re required to call sputn even if there’s no input, but the other wording doesn’t contain that requirement.</p>
<p>DKu: The first wording says “as if by”, which may give wiggle room to not call it.</p>
<p>DKu: In the second wording, sputc will never call sputn; it puts character into buffer, and calls overflow if the buffer is full. sputn is strictly an optimization.</p>
<p>MC: OK, I’m convinced this could be NAD, that the standard simply gives no guarantees about this. Are we OK with this lack of precision and implementation variance, or does the spec need to be more precise?</p>
<p>DKu: If you look at [ostream]/p2, it deliberately doesn’t specify how the functions are called. Even if sputn is called, no guarantee that xsputn is called at all: if there’s space in the buffer, the implementation may just put the characters in the buffer. This flexibility makes user implementations nicer, so I think this is definitely NAD</p>
<p>BD: This stuff is incredibly chewed-over. There used to always be a group working on this stuff; it’s hard to believe there’s anything in here that’s not deliberate, so you can’t change it with this small group; you need to talk to all the implementers.</p>
<p>MC: Any objections to NAD?</p>
<p>no objections.</p>

Closing as NAD.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2538" href="2538">2538.</a> [parallel.ts] Requirements on data race behavior of iterators and swap should be clarified</h3>
<p><b>Section:</b> 99 [parallel.ts::parallel.alg.general.exec] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Robert Geva <b>Opened:</b> 2015-09-22 <b>Last modified:</b> 2015-10-21 05:22:23 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: parallel.ts</b></p>
<p>
Parallel algorithms as of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4352.html">N4352</a> in general 
need to assume that iterator operations and <tt>swap</tt> have the expected data race behavior.  
For example, <tt>sort</tt> would not work if the exchange operation were thread-unsafe and, for example, always updated a single 
unprotected global counter, independent of the objects being swapped. A parallel <tt>sort</tt> has to be able to assume that disjoint 
pairs of objects can be swapped concurrently, i.e. that elemental functions have the same sort of thread-safety behavior that 
we generally promise for the standard library versions. I don't see that assumption stated anywhere.
<p/>
We should then probably also be clearer that the 99 [parallel.ts::parallel.alg.general.exec] ordering rules are further 
constrained by algorithm correctness requirements, and by the requirement not to introduce data races when elemental functions 
satisfy their thread-safety expectations. 
<p/>
It's tempting to generally add basic thread-safety requirements to various library requirements clauses. But that adds backwards 
compatibility issues for single-threaded code.
<p/>
Most probably this applies to other operations as well. We do state in [parallel.alg.general.user]:
</p>
<blockquote class="note"><p>
Function objects passed into parallel algorithms as objects of type <tt>BinaryPredicate</tt>, <tt>Compare</tt>, and 
<tt>BinaryOperation</tt> shall not directly or indirectly modify objects via their arguments.
</p></blockquote>
<p>
But that only seems to cover the easy cases.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2552" href="2552">2552.</a> <tt>priority_queue</tt> doesn't work with move-only types</h3>
<p><b>Section:</b> 24.6.7 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2015-10-27 <b>Last modified:</b> 2016-02-07 20:24:45 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#priority.queue">issues</a> in [priority.queue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Suppose we want to remove and process the topmost element of a <tt>priority_queue&lt;T&gt;</tt>. For a copyable type we might write
</p>
<blockquote><pre>
auto tmp = q.top();
q.pop();
</pre></blockquote>
<p>
but of course that doesn't work if <tt>T</tt> is move-only. Nothing of that sort can work, since moving out of <tt>top()</tt> 
would make the subsequent call to <tt>pop()</tt> fail.
<p/>
Currently, <tt>pop()</tt> is defined to perform
</p>
<blockquote><pre>
pop_heap(c.begin(), c.end(), comp);
c.pop_back();
</pre></blockquote>
<p>
so the removed value continues to exist between the first and second lines but there isn't any access to it. The sort of 
primitive that would allow consuming and removing the topmost element would be some variation on this, e.g.
</p>
<blockquote><pre>
pop_heap(c.begin(), c.end(), comp);
auto tmp = move(c.back());
c.pop_back();
return tmp;
</pre></blockquote>

<p><i>[2016-02, Issues Telecon]</i></p>

<p>
This should be addressed by a paper addressed to LEWG.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2553" href="2553">2553.</a> [fund.ts.v2] <tt>basic_string_view</tt> substring constructor</h3>
<p><b>Section:</b> 7.3 [fund.ts.v2::string.view.cons] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Evan Teran <b>Opened:</b> 2015-10-29 <b>Last modified:</b> 2018-06-23 17:54:13 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
<tt>string_view</tt> can be tremendously useful for dealing with sub-strings without copying. However, the 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3921.html">current proposal</a> for <tt>basic_string_view</tt>, 
has no constructor which provides a direct way of creating a view of a sub-string of a <tt>basic_string</tt>. 
Instead, we construct a view of the whole <tt>basic_string</tt>, and then as a second step create a sub-string, 
for example using <tt>substr</tt>. To simplify what I believe to be a common use case, I suggest adding an additional constructor.
<p/>
The proposed wording for this is as follows:
</p>
<blockquote>
<pre>
template &lt;class Allocator&gt;
basic_string_view(const basic_string&lt;charT, traits, Allocator&gt;&amp; str, size_type pos, size_type count = npos);
</pre>
<blockquote>
<p>
<i>Throws</i>: <tt>out_of_range</tt> if <tt>pos &gt;= str.size()</tt>.
<p/>
<i>Effects</i>: Determines the effective length <tt>rlen</tt> of the string to reference as the smaller of <tt>count</tt> and 
<tt>size() - pos</tt>.
<p/>
<i>Postcondition</i>:
</p>
<blockquote>
<table border="1">
<tr>
<td>
<tt>data_ = str.data() + pos</tt>
</td>
<td>
<tt>size_ = rlen</tt>
</td>
</tr>
</table>
</blockquote>
</blockquote>
</blockquote>
<p>
In other words, the result is as if constructed via: <tt>basic_string_view(basic_string_view(str).substr(pos, count));</tt>
<p/>
An example implementation could look like this:
</p>
<blockquote><pre>
template &lt;class Allocator&gt;
basic_string_view(const basic_string&lt;charT, traits, Allocator&gt;&amp; str, size_type pos, size_type count = npos) 
  : data_(nullptr), size_(0) 
{
  basic_string_view(str).substr(pos, count).swap(*this);
}
</pre></blockquote>
<p>
Note that while we have a default parameter for <tt>count</tt>, <tt>pos</tt> does not. I believe that it is best to have 
this as a separate overload, as opposed to default parameters on the current constructor for two reasons:
</p>
<ol>
<li><p>The current constructor taking a <tt>basic_string</tt> does not throw, this overload can throw if <tt>pos &gt;= str.size()</tt>.</p></li>
<li><p>This constructor performs slightly more work, it is not necessary to impose this extra work on the basic case of 
constructing a view of a whole string.</p></li>
</ol>
<p>
This has been briefly discussed in the <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/ZtYnPdK9vIY">isocpp forums</a>. 
There were no obvious objections to this small improvement. Additionally, another reason to consider this addition is 
to provide a more consistent interface. With raw strings, we have the ability to construct a <tt>basic_string_view</tt> 
which is a sub-string. For example:
</p>
<blockquote><pre>
const char* s = "hello world";
auto v = string_view(s + 6);
</pre></blockquote>
<p>
But there is no constructor which easily does the same when starting with a <tt>basic_string</tt>.
<p/>
Finally, As a example, consider the following (trivial) code:
</p>
<blockquote><pre>
void print_string(string_view v) {
  std::cout &lt;&lt; v &lt;&lt; '\n';
}

int main() {
  std::string s = "hello world"; // for example, we want to print the sub-string "world", without copies

  // current method:
  print_substring(string_view(s).substr(6));

  // suggested method:
  print_substring(string_view(s, 6);
}
</pre></blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Insert between 7.3 [fund.ts.v2::string.view.cons] p5 and p6 the following sequence of paragraphs:</p>

<blockquote>
<pre>
<ins>template &lt;class Allocator&gt;
basic_string_view(const basic_string&lt;charT, traits, Allocator&gt;&amp; str, size_type pos, size_type count = npos);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Throws</i>: <tt>out_of_range</tt> if <tt>pos &gt;= str.size()</tt>.</ins>
<p/>
<ins>-?- <i>Effects</i>: Determines the effective length <tt>rlen</tt> of the string to reference as the smaller of <tt>count</tt> and 
<tt>size() - pos</tt>.</ins>
<p/>
<ins>-?- <i>Postcondition</i>: Constructs a <tt>basic_string_view</tt>, with the postconditions in Table ?</ins>
</p>
<blockquote>
<table border="1">
<caption><ins>Table ? &mdash; <tt>basic_string_view(const basic_string&lt;charT, traits, Allocator&gt;&amp;, size_type, size_type)</tt> effects</ins></caption>
<tr>
<th><ins>Element</ins></th>
<th><ins>Value</ins></th>
</tr>

<tr>
<td>
<ins><tt>data_</tt></ins>
</td>
<td>
<ins><tt>str.data() + pos</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>size_</tt></ins>
</td>
<td>
<ins><tt>rlen</tt></ins>
</td>
</tr>

</table>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2016-03, Jacksonville]</i></p>

Change status to "LEWG"

<p>
LEWG: Do we want this constructor?
<p/>
SF F N A  SA
<p/>
0  3 2 13 1
</p>


<p><b>Proposed resolution:</b></p>
<p>
Not a defect. The LWG believes this missing feature is not sufficiently serious to constitute a defect.
</p>





<hr>
<h3><a name="2563" href="2563">2563.</a> LWG 2259 relaxes requirements, perhaps unintentionally</h3>
<p><b>Section:</b> 16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-11-29 <b>Last modified:</b> 2018-11-12 05:21:03 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in [member.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The combination of 16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>, paragraphs 2 and 3 that LWG 
<a href="2259">2259</a> does seems to drop a requirement that any call behaves as if 
no overloads were added. Paragraph 3 used to say
"A call to a member function signature described in the C ++ standard
library behaves as if the implementation
declares no additional member function signatures."
whereas the new wording says
"provided that any call to the member function that would select an
overload from the set of declarations described in this standard
behaves as if that overload were selected."
<p/>
This can be read as meaning that if there's no default constructor
specified, like for instance for <tt>std::ostream</tt>, an implementation is free to
add it. It can also be read as meaning that an implementation is free to
add any overloads that wouldn't change the overload resolution result
of any call expression that would select a specified overload. That's
vastly different from allowing extensions that add new functions rather
than new overloads.
<p/>
Was this relaxation intentional?
</p>
<p><i>[2016-04, Issues Telecon]</i></p>

<p>
Ville provides a motivating example.
</p>

<p>
<blockquote>
<pre>
#include &lt;iostream&gt;

class my_stream : std::ostream
{
};

int main()
{
    my_stream ms;
}
</pre>
</blockquote>
</p>

<p>This example is accepted by libstdc++, msvc rejects it, and clang+libc++
segfault on melpon.org/wandbox o_O. An earlier clang+libc++ just accepts
it. I don't think the implementation divergence is caused by the acceptance
of the referred-to <a href="2259">2259</a>, but it certainly seems to increasingly bless
the implementation divergence.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
This is related to issue <a href="2695">2695</a>.
</p>

<p><i>[2018-08 Batavia Monday issue discussion]</i></p>

<p>Ville to provide wording.</p>
<p><i>[2018-08 Batavia Monday issue discussion]</i></p>

<p>Ville recommends NAD; because closing this would outlaw conforming extensions.</p>

<p><i>[2018-11 San Diego Thursday night issue processing]</i></p>

<p>Status to NAD</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2580" href="2580">2580.</a> Who is definitive: <tt>operator=</tt> or <tt>assign</tt>?</h3>
<p><b>Section:</b> 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a>, 23.4.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a>, 32.7.3 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-01-05 <b>Last modified:</b> 2016-11-12 20:15:11 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two "containers" in the standard who have member functions named <tt>assign</tt> that take parameters of the 
type of the container (as opposed to iterators, pointers, what have you).
<p/>
In <tt>string</tt>'s case, we define <tt>assign</tt> in terms of <tt>operator=</tt>.
In <tt>regex</tt>'s case, we define <tt>operator=</tt> in terms of <tt>assign</tt>.
<p/>
We should pick a style and use use it.
<p/>
In 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a>, we have:
</p>
<blockquote>
<pre>
basic_string&amp; operator=(const basic_string&amp; str);
</pre>
<blockquote>
<p>
-17- <i>Effects</i>: If <tt>*this</tt> and <tt>str</tt> are not the same object, modifies <tt>*this</tt> as shown in Table 70. 
<p/>
-18- If <tt>*this</tt> and <tt>str</tt> are the same object, the member has no effect.
<p/>
-19- <i>Returns</i>: <tt>*this</tt>
</p>
</blockquote>
<pre>
basic_string&amp; operator=(basic_string&amp;&amp; str)
  noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value || 
           allocator_traits&lt;Allocator&gt;::is_always_equal::value);
</pre>
<blockquote>
<p>
-20- <i>Effects</i>: Move assigns as a sequence container (23.2), except that iterators, pointers and references may be invalidated.
<p/>
-21- <i>Returns</i>: <tt>*this</tt>
</p>
</blockquote>
</blockquote>
<p>
In 23.4.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a>, we have:
</p>
<blockquote>
<pre>
basic_string&amp; assign(const basic_string&amp; str);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Equivalent to <tt>assign(str, 0, npos)</tt>. 
<p/>
-2- <i>Returns</i>: <tt>*this</tt>.
</p>
</blockquote>
<pre>
basic_string&amp; assign(basic_string&amp;&amp; str) 
  noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
           allocator_traits&lt;Allocator&gt;::is_always_equal::value);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to <tt>*this = std::move(str)</tt>.
<p/>
-3- <i>Returns</i>: <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
<p>
Marshall says: There is another issue <a href="2579">2579</a> here, to change /1 to be similar to /2.
<p/>
In 32.7.3 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a>, we have:
</p>
<blockquote>
<pre>
basic_regex&amp; operator=(const basic_regex&amp; e);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: returns <tt>assign(e)</tt>.
</p>
</blockquote>
<pre>
basic_regex&amp; operator=(basic_regex&amp;&amp; e) noexcept;
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: returns <tt>assign(std::move(e))</tt>.
</p>
</blockquote>
</blockquote>
<p>
<em>and</em>
</p> 
<blockquote>
<pre>
basic_regex&amp; assign(const basic_regex&amp; that);
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: copies <tt>that</tt> into <tt>*this</tt> and returns <tt>*this</tt>.
<p/>
-8- <i>Postconditions</i>: <tt>flags()</tt> and <tt>mark_count()</tt> return <tt>that.flags()</tt> and 
<tt>that.mark_count()</tt>, respectively.
</p>
</blockquote>
<pre>
basic_regex&amp; assign(basic_regex&amp;&amp; that) noexcept;
</pre>
<blockquote>
<p>
-9- <i>Effects</i>: move assigns from <tt>that</tt> into <tt>*this</tt> and returns <tt>*this</tt>.
<p/>
-10- <i>Postconditions</i>: <tt>flags()</tt> and <tt>mark_count()</tt> return the values that <tt>that.flags()</tt> and 
<tt>that.mark_count()</tt>, respectively, had before assignment. <tt>that</tt> is in a valid state with unspecified value.
</p>
</blockquote>
</blockquote>

<p><i>[2016-02, Issues Telecon]</i></p>

<p>
Marshall to see if this can be dealt with editorially. Change Regex so that assign is in terms of op=
</p>

<p><i>[2016-02]</i></p>

<p>
Changed <tt>basic_regex</tt> to match <tt>string</tt> as an editorial change. Closing as NAD
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2600" href="2600">2600.</a> <tt>ios_base</tt> must store inaccessible iostate flags</h3>
<p><b>Section:</b> 31.5.2.6 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2019-02-26 17:49:57 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
DR <a href="41">41</a>, "Ios_base needs <tt>clear()</tt>, <tt>exceptions()</tt>" stopped short of providing the interface 
suggested in its title, but it did require the underlying state to be stored in <tt>ios_base</tt>. Because <tt>rdstate()</tt> 
is also missing, <tt>ios_base</tt> manipulators relying on <tt>iword</tt> and <tt>pword</tt> cannot detect failure. 
The only safe alternative is to manipulate a derived class, which must be a template.
<p/>
libc++ already provides the interface as a nonconforming extension. libstdc++ implements the internal state but leaves 
it frustratingly inaccessible, as specified. Any conforming implementation should be able to provide the interface 
without ABI problems.
</p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
This is really a request for an (feature) API. Passing to LEWG.
</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend NAD: iostreams aren't used in this way enough to spend committee time on it. However, a paper could change our minds.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2604" href="2604">2604.</a> [filesys.ts] [PDTS] Need definition of dot and dot-dot</h3>
<p><b>Section:</b> 4.14 [filesys.ts::fs.def.parent] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> CH-3 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>The concept of a parent directory for dot or dotdot exists, but the definition doesn't apply.</p>

<p>Suggested action:</p>

<p>Remove the paragraph. This concept does not apply to dot and dot-dot. Add a definition for dot and dot-dot.</p>

<p><i>[2014-02-07, Beman Dawes comments]</i></p>

<p>Suggest it is editorial and should be passed to the project editor.</p>

  <p><i>[
    2014-02-11 Issaquah: Beman to provide wording for review next meeting. Also see related issue 5.
  ]</i></p>


  <p><i>[22 May 2014 Beman Dawes comments:]</i></p>

  <blockquote>
    <p>I've now reviewed this issue carefully and believe it is NAD. "parent" is used in four places in the WP,
    and so deserves a definition. The current definition is copied word-for-word and in its entirety from the
    POSIX definition. I believe strongly that the File System TS needs to stay in alignment with POSIX on
    this matter,
    and that the best way to do that is simply to use the POSIX wording.</p>
  </blockquote>

  <p><i>[17 Jun 2014 Rapperswil LWG closes as NAD. No concensus for change.]</i></p>

  


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2610" href="2610">2610.</a> [filesys.ts] [PDTS] Apparently inconsistent return types from several functions</h3>
<p><b>Section:</b> 6 [filesys.ts::fs.filesystem.synopsis] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> FI-4 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.filesystem.synopsis">issues</a> in [filesys.ts::fs.filesystem.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
It is unclear why <tt>copy</tt>, <tt>copy_file</tt> and <tt>copy_symlink</tt> have different return types,
and why the attribute-version of <tt>create_directory</tt> has a different return type than the
<tt>create_directory</tt> that takes no attributes. The status/error reporting in these functions
seems inconsistent.
<p/>
Resolution:
<p/>
Make the status/error reporting consistent or add a note explaining why it's different.
</p>

  <p><i>[
    2014-02-11 Issaquah: NAD. LWG/SG-3 reviewed each function and return type, and found that since they
    have different functionality different return types are warranted. <tt>create_directory</tt> has
    an inconsistent return type between the synopsis and the description.
    This has subsequently been corrected editorially.
  ]</i></p>





<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2611" href="2611">2611.</a> [filesys.ts] [PDTS] Lack of <tt>relative()</tt> operation function</h3>
<p><b>Section:</b> 6 [filesys.ts::fs.filesystem.synopsis], 15 [filesys.ts::fs.op.funcs] <b>Status:</b> <a href="lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> GB-1 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.filesystem.synopsis">issues</a> in [filesys.ts::fs.filesystem.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
There is no <tt>relative()</tt> operation, to complement both <tt>absolute()</tt>
 and <tt>canonical()</tt>
</p>
<p>
The TS introduces relative paths. 
</p>

<ul>
  <li>
    <p>
      They are defined in section 4.18
      relative path [fs.def.relative-path]
    </p> </li>
  <li>
    <p>
      A decomposition method

      <tt>relative_path()</tt>
      is described in section 8.4.9 path decomposition [path.decompose]
    </p> 
  </li>
  <li>
  <p>
  
  Two query methods to determine if a path 
  either <tt>has_relative_path()</tt> or 
  <tt>is_relative()</tt> described in 8.4.10 path query [path.query] </p>
</li>
</ul>
<p>
However there is no way to create a relative path as a path relative to another. 
Methods are provided to create absolute and canonical paths.
</p>
<p>

In section 15.1 Absolute [fs.op.absolute]:</p>
<p>
path absolute(const 
path&amp; 
p,
const 
path&amp; 
base=current_path());</p>
<p>

and in section 15.2 Canonical [fs.op.canonical]</p>
<p>

path canonical(const 
path&amp; 
p,
const 
path&amp; 
base = 
current_path());</p>
<p>

path canonical(const 
path&amp; 
p, 
error_code&amp; 
ec);</p>
<p>

path canonical(const 
path&amp; 
p,
const 
path&amp; 
base, 
error_code&amp; 
ec);</p>
<p>
By providing a 
operations to achieve absolute and canonical paths there is no impediment to 
providing a similar operation 

relative() 
that
attempts to return a new path relative to 
some base path.</p>
<p>

For example:</p>
<p>

path relative(const 
path&amp; 
p,
const 
path&amp; 
to = 
current_path());</p>
<p>

path relative(const 
path&amp; 
p, 
error_code&amp; 
ec);</p>
<p>

path relative(const 
path&amp; 
p,
const 
path&amp; 
to, 
error_code&amp; 
ec);
</p>
<p>
This would return a path, if possible, that is relative to 
<code>to</code>. The implementation can make use of 
<code>absolute()</code> and <code>canonical()</code> 
to determine the relative path, if it exists.
</p>
<p>
The File System TS is 
based on the 
<a href="http://www.boost.org/doc/libs/1_55_0/libs/filesystem/doc/index.htm">

<u>&#8203;</u></a><a href="http://www.boost.org/doc/libs/1_55_0/libs/filesystem/doc/index.htm">boost::filesystem 
library</a> and it too suffers from this anomaly. There are open tickets for this in 
<a href="https://svn.boost.org/"><u>&#8203;</u></a><a href="https://svn.boost.org/">Boost Trac</a>:</p>
<ul>
  <li>
  <p>  
  <a href="https://svn.boost.org/trac/boost/ticket/5897">
  <u>&#8203;</u></a><a href="https://svn.boost.org/trac/boost/ticket/5897">#5897 
  Make path relative function</a>
  </p>
</li>
  <li>
  <p>  
  <a href="https://svn.boost.org/trac/boost/ticket/1976">
  <u>&#8203;</u></a><a href="https://svn.boost.org/trac/boost/ticket/1976">#1976 
  Inverse function for complete</a>
  </p>
</li>
</ul>
<p>
and it is the subject of several posts on StackOverflow for example:
</p>
<ul>
  <li>
  <p>  
  <a href="http://stackoverflow.com/questions/10167382/boostfilesystem-get-relative-path">
  <u>&#8203;</u></a><a href="http://stackoverflow.com/questions/10167382/boostfilesystem-get-relative-path">http://stackoverflow.com/questions/10167382/boostfilesystem-get-relative-path</a>
  </p>
</li>
  <li>
  <p>  
  <a href="http://stackoverflow.com/questions/5772992/get-relative-path-from-two-absolute-paths">
  <u>&#8203;</u></a><a href="http://stackoverflow.com/questions/5772992/get-relative-path-from-two-absolute-paths">http://stackoverflow.com/questions/5772992/get-relative-path-from-two-absolute-paths</a>
  </p>
</li>
</ul>
<p>
Other languages typically provide a similar function. For example python 
provides:
</p>
<p>
os.path.relpath(path[, start])
</p>
<p>
Return a relative filepath to path either from the current directory or from an optional 
start directory. This is a path computation: the filesystem is not accessed to confirm 
the existence or nature of path or start. start defaults to os.curdir.
</p>

<p><i>[2014-02-07, Beman Dawes comments]</i></p>


<p>A <code>relative()</code> function is useful and much requested.
I've seen such a function provided by users and have written it myself in app code.
It is one of those things I've been meaning to do for years, and have just never gotten around to.
</p>
  <p>That said, my mild preference is to treat this as "NAD, Future" for File System TS1,
  but treat it as a priority for TS2.</p>

  <p><i>[
    2014-02-11 Issaquah
  ]</i></p>

<p>
 The LWG/SG-3 voted strongly in favor of adding this functionality, and doing so in
    this TS. That implies quite a bit of work before the next meeting to validate that the proposed interface
    works as desired for various platforms. There was general agreement not to hold FS STS1 if this functionality
    isn't ready when the rest of the TS is ready.
</p>

<p><i>[2014-05-19 Beman Dawes supplied wording.]</i></p>
 
<p>The design benefited from discussions with Jamie Allsop, who was
the source of the original NB comment.
Thanks to Bjorn Reese for corrections and suggestions.  Although there was also discussion and experimentation with additional
relative functions that took into account symlinks and normalization, these are not proposed here since even the proponents
of such functions were unsure of appropriate semantics.
</p>
  <p><i>[2014-06-17 Rapperswil LWG closes as NAD, Future.]</i></p>
 
<p>Although there is strong concensus for eventually
  providing both lexical and existence based flavors of relative() functionality, discussion of the many possible
  design choices led to the conclusion that more research and actual user experience is necessary before
  moving forward. Interested parties should submit papers.
</p>

  <p>
    <b>Original proposed resolution:</b>
  </p>
<ol>
<li>
<p>Modify header <tt>&lt;filesystem&gt;</tt> synopsis, 6 [fs.filesystem.synopsis],
by adding the operational functions after <tt>canonical</tt>:</p>
<blockquote><pre>
path relative(const path&amp; p, const path&amp; to = current_path());
path relative(const path&amp; p, error_code&amp; ec);
path relative(const path&amp; p, const path&amp; to, error_code&amp; ec);
</pre></blockquote>
</li>
<li><p>Insert the section:</p>
<blockquote><p>
15.3 Relative [fs.op.relative]
</p>
<pre>
path relative(const path&amp; p, const path&amp; to = current_path());
path relative(const path&amp; p, error_code&amp; ec);
path relative(const path&amp; p, const path&amp; to, error_code&amp; ec);</pre>
<blockquote>
<p><i>Overview</i>: Return a relative path of p to the current directory or from an optional to path.</p>
<p><i>Returns</i>: A relative path such that <tt>canonical(to)/relative(p,to) == canonical(p)</tt>,
otherwise <tt>path()</tt>. If <tt>canonical(to) == canonical(p)</tt> the path <tt>path(".")</tt> is returned. For the
overload without a <tt>to</tt> argument, <tt>to</tt> is <tt>current_path()</tt>. Signatures with argument <tt>ec</tt> return
<tt>path()</tt> if an error occurs.
</p>
<p>
<i>Throws</i>: As specified in Error reporting.</p>
<p>
<i>Remarks</i>: <tt>!exists(p) or !exists(to) or !is_directory(to)</tt> is an error.
</p>
</blockquote></blockquote>
<p>
and bump all following sections up by 0.1. Update the contents and any cross-references
accordingly.
</p>
</li>
</ol>
<p>
Question: Should Returns be specified in terms of equivalence? For example:
<tt>equivalent( canonical(to)/relative(p,to), canonical(p) )</tt>
</p>
<p>
Question: Should <tt>canonical(to) == canonical(p)</tt> return <tt>path(".")</tt> or <tt>path()</tt>? Why?
</p>
<p>

Question: Should <tt>to</tt> be spelled <tt>start</tt>?</p>

 
<p><b>Proposed resolution:</b></p>

  <p>
    <i>
      To 6 Header &lt;experimental/filesystem&gt; synopsis [fs.filesystem.synopsis],
      add:
    </i>
  </p>
  <blockquote>
    <span style="background-color: #D7EEFF">path lexically_relative(const path&amp; p, const path&amp; base);</span>
  </blockquote>

  <p>
    <i>At the end of 8.6 path non-member functions [path.non-member], add </i>
  </p>
  <blockquote>

    <h4>
      8.6.3  <code>path</code>
      <span style="text-decoration: none">lexically_relative</span> function [path.lexically.relative]
    </h4>
    <span style="background-color: #D7EEFF">path lexically_relative(const path&amp; p, const path&amp; base);</span>
    <blockquote>
      <p>
        Creates a path from the trailing elements of <code>p</code> that are
        lexically relative to <code>base</code>, which must be a prefix of <code>p</code>.
      </p>
      <p>
        <i>Effects:</i> If the number of elements in [<code>
          p.begin(),
          p.end()
        </code>) is less than or equal to the number of elements in [<code>
          base.begin(),
          base.end()
        </code>), or if any element in [<code>base.begin(), base.end()</code>)
        is not equal to the corresponding element in [<code>p.begin(), p.end()</code>),
        throw an exception of type <code>filesystem_error</code>.
      </p>
      <p>
        <i>Remarks: </i>Equality or inequality are determined by <code>
          path::operator==
        </code> or <code>path::operator!=</code> respectively.
      </p>
      <p>
        <i>Returns: </i>An object of class <code>path</code> containing the first element of <code>p</code> that does not have a
        corresponding element in <code>base,</code> followed by the subsequent elements
        of <code>p</code> appended as if by <code>path::operator/=</code>.
      </p>
      <p>
        <i>Throws:</i> <code>filesystem_error</code>.
      </p>
      <p>
        [<i>Note:</i> Behavior is determined by the
        lexical value of the elements of <code>p</code> and <code>base</code> - the
        external file system is not accessed. The&nbsp;case where an element of <code>
          base
        </code>
        is not equal to corresponding element of <code>p</code> is treated as an error to avoid returning an incorrect result
        in the event of symlinks.&nbsp; <i>--end note</i>]
      </p>
    </blockquote>
    <p>
      <i>
        <span style="background-color: #CCCCCC">
          A possible implementation would
          be:
        </span>
      </i>
    </p>
    <blockquote>
      <pre>
        <span style="background-color: #CCCCCC">
auto mm = std::mismatch( p.begin(), p.end(), base.begin(), base.end());
if (mm.first == p.end() || mm.second != base.end())
{
throw filesystem_error(
&quot;p does not begin with base, so can not be made relative to base&quot;,
p, base,
error_code(errc::invalid_argument, generic_category()));
}
path tmp(*mm.first++);
for (; mm.first != p.end(); ++mm.first)
tmp /= *mm.first;
return tmp;</span></pre>

    </blockquote>

  </blockquote>







<hr>
<h3><a name="2612" href="2612">2612.</a> [filesys.ts] [PDTS] <tt>uintmax_t</tt> too small for large file sizes</h3>
<p><b>Section:</b> 6 [filesys.ts::fs.filesystem.synopsis], 15.14 [filesys.ts::fs.op.file_size] <b>Status:</b> <a href="lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> CH-8 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.filesystem.synopsis">issues</a> in [filesys.ts::fs.filesystem.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p><tt>uintmax_t</tt> is specified to hold at least 64 bit. This is not enough for sizes
beyond 4 [sic] exabytes.</p>

<p>Specify whether an implementation must provide a <tt>uintmax_t</tt> that can hold the maximum
possible space and file size values.</p>

  <p>
    <i>[2014-02-06: Jeffery Yasskin points out 64-bits unsigned actually has a maximum value of "16 exabytes, not 4"]</i>
  </p>

  <p>
    <i>[2014-02-07: Beman Dawes suggests: This should be NAD. Such ultra-large files are the province
    of enterprise-wide filesystems such as requested by IBM and others for a follow-on SG3 TS. That would be
    the best vehicle to address this concern IMO.]</i>
  </p>

  <p><i>[
    2014-02-11 Issaquah: NAD Future.
  ]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2613" href="2613">2613.</a> [filesys.ts] [PDTS] Missing actual error conditions thrown</h3>
<p><b>Section:</b> 7 [filesys.ts::fs.err.report] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> CH 9 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.err.report">issues</a> in [filesys.ts::fs.err.report].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
    <p>
      The specification of the actual error conditions for the functions that specify
      Throws: As specified in Error reporting. is missing.
    </p>

    <p>Add those specifications.</p>

    <p><i>[2014-02-07, Beman Dawes comments]</i></p>


    <p>
      The actual error codes, and thus the error conditions, are determined by the operating system,
      and thus operating system dependent.
    </p>

    <p><i>[2014-02-11 Issaquah]</i></p>

    <p/>There is no consensus for a change. LWG/SG3 requested a separate issue be opened to clarify
    7 [fs.err.report]. See issue 55.

  

<p><b>Proposed resolution:</b></p>








<hr>
<h3><a name="2617" href="2617">2617.</a> [filesys.ts] [PDTS] <tt>path</tt> member <tt>swap()</tt> unnecessary</h3>
<p><b>Section:</b> 8.4.5 [filesys.ts::path.modifiers] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> CH-12 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>As we have move semantics, member <tt>swap</tt> functions shouldn't be necessary any more.</p>
  
  <p><i>[2014-02-12 LWG/SG-3 Issaquah ]</i></p>

  <p/>No consensus for change. STL pointed out that swap should be noexcept and will submit a separate issue.
  


<p><b>Proposed resolution:</b></p>
<p>Remove <tt>swap()</tt>.</p>





<hr>
<h3><a name="2623" href="2623">2623.</a> [filesys.ts] [PDTS] Request for <tt>create_regular_file()</tt> and/or <tt>touch()</tt></h3>
<p><b>Section:</b> 15 [filesys.ts::fs.op.funcs] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> CH-14 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.op.funcs">issues</a> in [filesys.ts::fs.op.funcs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
Since <tt>create_symlink()</tt>, <tt>create_hardlink()</tt>, and <tt>create_directory()</tt> exist, there's
no reason not to have a <tt>create_regular_file()</tt> function.
</p>
<p>
Consider adding a function <tt>create_regular_file()</tt> with the behaviour of the POSIX <tt>touch</tt>
command.
</p>

<p><i>[Beman comments]</i></p>

<p> 
<tt>create_regular_file()</tt> and <tt>touch()</tt> should be different functions since
their behavior would differ if the file already exists; touch() updates the last write
date.
</p>

<p>I have often wanted <tt>create_regular_file()</tt> but never got around to adding it.</p>

<p>While <tt>touch</tt> is quite useful from the command line, I'm less sure of its usefulness as
a library function. It is trivial for a user to implement.</p>

<p>Whether or not it is appropriate to add operational functions this late in the PDTS
process is questionable.</p>
  
  <p><i>[2014-02-13 LWG/SG-3 Issaquah: No consensus for change at this time.]</i></p>
 
  


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2626" href="2626">2626.</a> [filesys.ts] [PDTS] Equivalence is a volatile property</h3>
<p><b>Section:</b> 15.13 [filesys.ts::fs.op.equivalent] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> CH-16 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>Equivalence is a volatile property.</p>

<p>Consider adding a note that equivalence cannot be determined race-free.</p>

<p><i>[2014-02-13 LWG/SG-3 Issaquah: No consensus for change. Section 2.1 description of races is sufficient.]</i></p>

  


<p><b>Proposed resolution:</b></p>
  





<hr>
<h3><a name="2628" href="2628">2628.</a> [filesys.ts] [PDTS] Possible <tt>last_write_time()</tt> postcondition?</h3>
<p><b>Section:</b> 15.25 [filesys.ts::fs.op.last_write_time] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> GB-15 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.op.last_write_time">issues</a> in [filesys.ts::fs.op.last_write_time].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>The constraint on <tt>last_write_time</tt> is too weak: It is noted that the postcondition
of <tt>last_write_time(p) == new_time</tt> is not specified since it might not hold for file
systems with coarse time granularity.
<p/>
However, might it be possible to have a postcondition that <tt>last_write_time(p) &lt;= new_time</tt> ?</p>

<p>Add postcondition: <tt>last_write_time(p) &lt;= new_time</tt></p>

  <p><i>[2014-02-09, Beman Dawes comments:]</i></p>

  <p/>That assumes the file system rounds down. We don't know which direction a file system rounds. Nice try, but
  this one looks NAD to me.
  
<p><i>[2014-02-13 LWG/SG-3 Issaquah: No consensus for change.]</i></p>
 



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2630" href="2630">2630.</a> [filesys.ts] [PDTS] <tt>remove()</tt> must avoid race</h3>
<p><b>Section:</b> 15.28 [filesys.ts::fs.op.remove] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> CH-17 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-10 20:02:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>The specification can be read to require the existence test. As this introduces a
race, the existence test must not happen.</p>
<p>Change to: "Effects: <tt>p</tt> is removed as if by POSIX <tt>remove()</tt>."</p>

<p><i>[2014-02-13 LWG/SG-3 Issaquah: Insufficient consensus for change. Vote for NAD: 9 0 0 2 1.]</i></p>
  
  


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wiki.edg.com/twiki/pub/Wg21issaquah/SG3/working-draft.html">SG3 working draft</a>.</p>

<ol><li><p>Change 15.28 [filesys.ts::fs.op.remove] as indicated:</p>

<blockquote><p>
<i>Effects</i>: <del>If <tt>exists(symlink_status(p,ec))</tt>, it</del><ins><tt>p</tt></ins> is removed as if by POSIX <tt>remove()</tt>.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2631" href="2631">2631.</a> [filesys.ts] [PDTS] POSIX guarantees atomicity for <tt>rename()</tt></h3>
<p><b>Section:</b> 15.30 [filesys.ts::fs.op.rename] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> CH-18 <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-12 18:42:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>POSIX guarantees some kind of atomicity for <tt>rename()</tt>.</p>

<p>Clarify that POSIX' <tt>rename()</tt> guarantee "If the <tt>rename()</tt> function fails for any
reason other than [EIO], any file named by new shall be unaffected." holds for C++ as well.</p>

  <p><i>[2014-02-10 Beman Dawes]</i></p>


  <p/>Section 2.1, POSIX conformance, [fs.conform.9945] specifies the POSIX conformance requirements for TS
  implementations in carefully crafted and specific detail. Repeating a portion of the POSIX standard's
  specification for a particular TS function would do great harm as it would bring into question all of
  the portions of the POSIX specification for the function that were not repeated.
  
  <p/>Furthermore, all the caveats and other details of the 2.1 specification would have to be analyzed
  and possibly appended; it ties the hands of implementors if they are not given latitude to deviate as needed
  when working with non-POSIX operating systems.
  
  <p/>I strongly recommend NAD for this issue.
  
  <p><i>[2014-02-13 LWG/SG-3 Issaquah: No consensus for change.]</i></p>

  


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2638" href="2638">2638.</a> [filesys.ts] [PDTS] Make certain functions <tt>noexcept</tt> and drop <tt>error_code</tt> version</h3>
<p><b>Section:</b> 12.3 [filesys.ts::directory_entry.obs], 15.12 [filesys.ts::fs.op.exists], 15.16 [filesys.ts::fs.op.is_block_file], 15.17 [filesys.ts::fs.op.is_char_file], 15.18 [filesys.ts::fs.op.is_directory], 15.19 [filesys.ts::fs.op.is_empty], 15.20 [filesys.ts::fs.op.is_fifo], 15.21 [filesys.ts::fs.op.is_other], 15.22 [filesys.ts::fs.op.is_regular_file], 15.23 [filesys.ts::fs.op.is_socket], 15.24 [filesys.ts::fs.op.is_symlink], 15.33 [filesys.ts::fs.op.status], 15.35 [filesys.ts::fs.op.symlink_status], 99 [filesys.ts::fs.op.unique_path] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2014-01-30 <b>Last modified:</b> 2016-08-12 18:42:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::directory_entry.obs">issues</a> in [filesys.ts::directory_entry.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
<tt>exists(const path&amp;)</tt> should be <tt>noexcept</tt> (drop <tt>error_code</tt> version).<br/>
<tt>is_*(const path&amp;)</tt> should be <tt>noexcept</tt> (drop <tt>error_code</tt> version).<br/>
<tt>status(const path&amp;)</tt> should be <tt>noexcept</tt> (drop <tt>error_code</tt> version).<br/>
<tt>symlink_status(const path&amp;)</tt> should be <tt>noexcept</tt> (drop <tt>error_code</tt> version).<br/>
<tt>file_status::status()</tt> should be <tt>noexcept</tt> (drop <tt>error_code</tt> version).<br/>
<tt>file_status::symlink_status()</tt> should be <tt>noexcept</tt> (drop <tt>error_code</tt> version).<br/>
<tt>unique_path(const path&amp;)</tt> should be <tt>noexcept</tt> (drop <tt>error_code</tt> version).
</p>

<p><i>[2014-02-08: Daniel comments]</i></p>

<p>
<tt>unique_path(const path&amp;)</tt> cannot be declared as <tt>noexcept</tt>, because it returns an object
during whose construction a memory allocation request may fail, see the rationale provided in <a href="2637">2637</a>.
<p/>
<tt>exists(const path&amp;)</tt> and the <tt>is_*(const path&amp;)</tt> functions cannot be <tt>noexcept</tt>, because 
they are specified in terms of <tt>status(const path&amp;)</tt>, which again may throw an exception, which is explicitly 
described in the Effects (<tt>filesystem_error</tt>), because the non-throwing function (<tt>status(const path&amp;, error_code&amp;)</tt>) 
may fail to satisfy the request.
<p/>
<tt>symlink_status(const path&amp;)</tt> may throw an exception for similar reasons that <tt>status(const path&amp;)</tt>
could fail.
<p/>
The reference to <tt>file_status::status()/symlink_status()</tt> looks like a typo to me (there are no such functions
in <tt>file_status</tt>), presumably <tt>directory_entry::status()/symlink_status()</tt> was meant. In this case I see 
no reason how these could be marked as <tt>noexcept</tt>, because these functions all may fail and may throw an exception.
<p/>
Based on this interpretation of the issue discussion I recommend to resolve this issue as NAD.
</p>

<p><i>[Beman Dawes 2014-02-27]</i></p>


  <p/>Issues <a href="2637">2637</a>,
  <a href="2638">2638</a>,
  <a href="2641">2641</a>,
  and <a href="2649">2649</a> are concerned with signatures which should or should not
  be <tt>noexcept</tt>. I will provide unified proposed wording for these issues, possibly in a separate paper.
  
  <p><i>[17 Jun 2014 Rapperswil LWG closes as NAD. Working paper correct as written.]</i></p>

  


<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2639" href="2639">2639.</a> [filesys.ts] [PDTS] <tt>permissions()</tt> is missing from synopsis</h3>
<p><b>Section:</b> 6 [filesys.ts::fs.filesystem.synopsis] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2014-01-30 <b>Last modified:</b> 2016-08-12 18:42:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.filesystem.synopsis">issues</a> in [filesys.ts::fs.filesystem.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>permissions function is missing from the summary list.</p>


<p><b>Proposed resolution:</b></p>
<p>
  <i>[2014-02-07: Beman Dawes comments: Fixed as Editorial.]</i>
</p>





<hr>
<h3><a name="2642" href="2642">2642.</a> [filesys.ts] 
[PDTS] <tt>class path</tt> should have defaulted constructors/destructor/assignments.
</h3>
<p><b>Section:</b> 8 [filesys.ts::class.path] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2014-01-30 <b>Last modified:</b> 2016-08-12 18:42:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::class.path">issues</a> in [filesys.ts::class.path].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
<tt>class path</tt> should have defaulted constructors/destructor/assignments.
</p>

<p><i>[2014-02-26 Beman Dawes comments]</i></p>


<p/>Suggest NAD. Earlier versions did have defaulted constructors/destructor/assignments,
but they were removed at the request of Alberto Ganesh Barbati (c++std-filesys January 8, 2013):

<blockquote>
<p/>Speaking of <tt>=default</tt>, we have to be careful not over-constrain the specification.
I mean, if we just specify the intended meaning of those function with proper wording,
the implementation is allowed to use <tt>=default</tt> in case it provides an equivalent behaviour,
but if we put <tt>=default</tt> in the specification, the implementation is required to use it.
However, we have to remember that "for exposition only" data members may not be an
exhaustive list and that 17.5.2.3/2 allows implementations to provide an equivalent
behaviour using different members for which "default" construction/copy/assignment
may not be appropriate.

<p/><tt>=default</tt> is what we want for tuple, atomics, etc. It might be appropriate for
simple types like file_status, but, for more complex types like <tt>path</tt> itself,
I'd remove it and add proper wording.
</blockquote>
  <p><i>[17 Jun 2014 Rapperswil LWG closes as NAD. Ganesh's analysis is correct. WP correct as written.]</i></p>



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2643" href="2643">2643.</a> [filesys.ts] [PDTS] <tt>path::compare(const string&amp;)</tt> should be <tt>path::compare(const string_type&amp;)</tt></h3>
<p><b>Section:</b> 8 [filesys.ts::class.path] <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2014-01-30 <b>Last modified:</b> 2016-08-12 18:42:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::class.path">issues</a> in [filesys.ts::class.path].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
<tt>path::compare(const string&amp;)</tt> should be <tt>path::compare(const string_type&amp;)</tt>.
</p>

<p><i>[2014-02-08 Daniel comments]</i></p>


<p>
This issue is a duplicate of <a href="2650">2650</a>. The suggested wording of that issue would resolve this issue here as well.
</p>
  
  <p><i>[2014-02-13 LWG/SG-3 Issaquah: Agrees with Daniel.]</i></p>




<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2646" href="2646">2646.</a> [filesys.ts] [PDTS] Do we really need <tt>generic*</tt>?</h3>
<p><b>Section:</b> 8.4.7 [filesys.ts::path.generic.obs] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2014-01-30 <b>Last modified:</b> 2016-08-12 18:42:15 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>Do we really need <tt>generic*</tt>?</p>

<p><i>[2014-02-08 Daniel comments]</i></p>

<p>
These functions should exist for more than one reason.
<p/>
First, the <i>generic pathname format</i> is a well-defined concept for the <tt>path</tt> specification
and defining just a single way into a <tt>path</tt> but not out of it looks like an incomplete design.
<p/>
More importantly, the existence of these functions have demonstrated to be quite useful in practice,
because the <i>generic pathname format</i> concept is popular for many tools such as <tt>maven</tt>
or the some configuration files for the Eclipse IDE do understand this syntax uniformly on all platforms
and it allows to generate or modify such files using C++ code based on <tt>filesystem::path</tt>. The
practical problem of the non-portable root-names doesn't matter in such contexts, because the
serialized path names are in general relative names or depend on initial parts that are determined
by properties or environment variables.
<p/>
In other words: I'm recommending NAD for this issue.
</p>
  
<p><i>[2014-02-13 LWG/SG-3 Issaquah: Withdrawn by submitter.]</i></p>




<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2651" href="2651">2651.</a> [filesys.ts] [PDTS] <tt>directory_iterator</tt>, <tt>recursive_directory_iterator</tt>, <tt>pointer</tt>/<tt>reference</tt> typedefs wrong</h3>
<p><b>Section:</b> 13 [filesys.ts::class.directory_iterator], 14 [filesys.ts::class.rec.dir.itr] <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-02-03 <b>Last modified:</b> 2016-08-11 20:23:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::class.directory_iterator">issues</a> in [filesys.ts::class.directory_iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
<tt>directory_iterator</tt> and <tt>recursive_directory_iterator</tt> are constant iterators, but their
<tt>pointer</tt>/<tt>reference</tt> typedefs are wrong (<tt>std::iterator</tt> defaults to providing modifiable
ones).</p>

<p><i>[2014-02-08 Daniel comments]</i></p>

<p>
I noticed the same problem when trying to resolve <a href="2652">2652</a>. The currently suggested wording for that
issue should fix the here mentioned problem as well.
<p/>
I recommend to solve this issue as "Resolved by the proposed wording for <a href="2652">2652</a>".
</p>
  <p><i>[2014-02-13 LWG/SG-3 Issaquah: Daniel's resolution accepted.]</i></p>



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2654" href="2654">2654.</a> [filesys.ts] [PDTS] Concerns with security and testability</h3>
<p><b>Section:</b> 1 [filesys.ts::fs.scope] <b>Status:</b> <a href="lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Google <b>Opened:</b> 2014-01-20 <b>Last modified:</b> 2016-08-11 20:23:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.scope">issues</a> in [filesys.ts::fs.scope].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
  <p>We have two primary concerns with the interface as specified: </p>
  <p>
    (a) its interface repeats the mistake of V7 Unix in 1979 by exposing access
    checking (and similarly file creation) independently from opening and mutating
    the file, and
  </p>
  <p>
    (b) it provides no realistic means of testing a software library which uses
    the standard interface for accessing the filesystem under fault scenarios.
  </p>
  <p>
    Due to the extent of (a), TOCTTOU [1] security vulnerabilities are
    guaranteed, if not during access checking[2], during other common operations
    such as temporary file creation[3].
  </p>
  <p>
    Due to (b) it is impossible to portably test libraries using the proposed
    interface against critical correctness and security edge cases.
  </p>
  <p>
    [1]: TOCTTOU: Time-of-check-to-time-of-use.&nbsp;
    <a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5388162">Operating system integrity in OS/VS2</a>
  </p>
      <p>[2]: <a href="http://www.csl.sri.com/users/ddean/papers/usenix04.pdf">Fixing Races for Fun and Profit: How to use access(2)</a></p>
      <p>[3]: <a href="http://www.cs.ucdavis.edu/research/tech-reports/1995/CSE-95-10.pdf">Checking for Race Conditions in File Accesses</a></p>

  <p/>
  
  <i>[Beman Dawes: 10 Feb 2014: Suggested response: NAD, Future]</i>

  <blockquote>
    <p/>We share your concerns and look forward to receiving specific proposals to address them.
    Whether they will addressed by a revision of TS 18822 or a new TS will be decided as proposals progress
    through the committee process. See <a href="http://isocpp.org/std/submit-a-proposal">How To Submit a Proposal</a>.
  </blockquote>
  <p><i>[17 Jun 2014 Rapperswil LWG agrees NAD, Future with rationale as stated above.]</i></p>




<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2659" href="2659">2659.</a> [filesys.ts] [PDTS] Invalid expressions for bitmask types</h3>
<p><b>Section:</b> 10 [filesys.ts::fs.enum] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-03-01 <b>Last modified:</b> 2016-08-11 20:23:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p/><code>copy_options</code> is declared as <code>enum class</code> type that is a bismask type, but the 
specification repeatedly uses expressions that are invalid for scoped 
enums, such as:

<blockquote>

<p/><code>!(options)</code>

</blockquote>

<p/>because there is no contextual conversion to bool, not even the || operator in:

<blockquote>
<p/><code>((options &amp; copy_options::recursive) || !(options)) </code>
</blockquote>

<p/>Affected are basically all formulations in the form:

<blockquote>

<p/>&quot;if <code>options &amp; copy_options::create_symlinks</code> [..]&quot;

</blockquote>

<p/>because all rely on contextual conversion to bool. The only other specifically 
mention scoped enumeration in the standard that is also a bit mask type is the 
<code>launch</code> enum and 
the wording there always uses forms such as:

<blockquote>

<p/>&quot;if <code>policy &amp; launch::deferred</code> is non-zero&quot;

</blockquote>

<p/>which better acknowledges the fact that the obtained values does not necessarily 
undergo an implicit conversion.

<p/>I think the current wording in the file system spec. must be changed, especially for 
invalid expressions of the form:

<blockquote>

<p/><code>((options &amp; copy_options::recursive) || !(options)) </code>
</blockquote>

<p/>A similar problem arises in the usage of the bitmask type <code>perms</code> for the 
expression:

<blockquote>

<p/><code>((prms &amp; add_perms) &amp;&amp; (prms &amp; remove_perms)) </code>
</blockquote>

<p/>The only way how to describe this with a scoped enum is the lengthier form

<blockquote>

<p/><code>((prms &amp; perms::add_perms) != perms::none &amp;&amp; (prms &amp; perms::remove_perms) != 
perms::none) </code>
</blockquote>

<p/>thus fixing several problems:

<ul>
  <li>The unscoped access to <code>add_perms</code> and <code>remove_perms</code> is incorrect</li>
  <li>The result of &amp; is the bitmask type again and cannot be implicitly 
  converted to bool</li>
</ul>

  <p><i>[20 May 2014 Beman Dawes provides proposed wording. Fixing invalid C++ is editorial, but treating
  this as an issue ensures more people review the proposed changes.]</i></p>


  <p><i>[17 Jun 2014 Rapperswil LWG requests issue be handled as editorial.]</i></p>




<p><b>Proposed resolution:</b></p>
  <p>
    <i>Change 15.3 Copy [fs.op.copy]:</i>
  </p>

  <blockquote>

    <blockquote>
      <p>
        Before the first use of <code>f</code> and <code>t</code>:
      </p>

      <ul>
        <li>
          If <code>
            (options &amp; copy_options::create_symlinks) <ins>
              !=
              copy_options::none
            </ins> || (options &amp; copy_options::skip_symlinks) <ins>
              !=
              copy_options::none</ins></code>, then <code>
            auto f =
            symlink_status(from)
          </code> and if needed <code>auto t = symlink_status(to)</code>.
        </li>
        <li>
          Otherwise, <code>auto f = status(from)</code> and if needed <code>
            auto
            t = status(to)
          </code>.
        </li>
      </ul>
      <p>
        Report an error as specified in
        Error reporting (7)
        if:
      </p>

      <ul>
        <li>
          <code>!exists(f)</code>, or
        </li>
        <li>
          <code>equivalent(from, to)</code>, or
        </li>
        <li>
          <code>is_other(f) || is_other(t)</code>, or
        </li>
        <li>
          <code>is_directory(f) &amp;&amp; is_regular_file(t)</code>.
        </li>
      </ul>
      <p>
        If <code>is_symlink(f)</code>, then:
      </p>

      <ul>
        <li>
          If <code>
            <ins>(</ins>options &amp; copy_options::skip_symlinks<ins>) !=
              copy_options::none</ins></code>, then return.
        </li>
        <li>
          Otherwise if <code>!exists(t)</code>, then <code>
            copy_symlink(from,
            to, options)
          </code>.
        </li>
        <li>
          Otherwise report an error as specified in
          Error reporting (7).
        </li>
      </ul>
      <p>
        Otherwise if <code>is_regular_file(f)</code>, then:
      </p>

      <ul>
        <li>
          If <code>
            <ins>(</ins>options &amp; copy_options::directories_only<ins>) !=
              copy_options::none</ins></code>, then return.
        </li>
        <li>
          Otherwise if <code>
            <ins>(</ins>options &amp; copy_options::create_symlinks<ins>
              ) !=
              copy_options::none</ins></code>, then
          create a symbolic link to the source file.
        </li>
        <li>
          Otherwise if <code>
            <ins>(</ins>options &amp; copy_options::create_hard_links<ins>) !=
              copy_options::none</ins></code>,
          then create a hard link to the source file.
        </li>
        <li>
          Otherwise if <code>is_directory(t)</code>, then <code>
            copy_file(from, to/from.filename(),
            options)
          </code>.
        </li>
        <li>
          Otherwise, <code>copy_file(from, to, options)</code>.
        </li>
      </ul>
    </blockquote>
  </blockquote>
  <blockquote>
    <blockquote>
      <p>
        Otherwise if <code>
          is_directory(f) &amp;&amp; ((options &amp;
          copy_options::recursive)<ins> != copy_options::none</ins> || <del>!(</del>options <ins>
            ==
            copy_options::none</ins><del>)</del>)
        </code>
        then:
      </p>

      <ul>
        <li>
          If&nbsp; <code>!exists(t)</code>, then <code>
            create_directory(to,
            from)
          </code>.
        </li>
        <li>
          Then, iterate over the files in <code>from</code>, as if by <code>
            for
            (directory_entry&amp; x : directory_iterator(from))
          </code>, and for each
          iteration <code>
            copy(x.path(), to/x.path().filename(), options |
            copy_options::<i>unspecified</i>)
          </code>.
        </li>
      </ul>

    </blockquote>

  </blockquote>

  <p>
    <i>Change 15.4 Copy file [fs.op.copy_file]:</i>
  </p>
  <blockquote>
    <p>
      If&nbsp; <code>exists(to) &amp;&amp;</code> <code>
        <del>!</del>(options &amp; (copy_options::skip_existing
        | copy_options::overwrite_existing | copy_options::update_existing)) <ins>
          ==
          copy_options::none
        </ins>
      </code> report a
      file already exists error as specified in
      Error reporting (7).
    </p>
    <p>
      If <code>
        !exists(to) || (options &amp; copy_options::overwrite_existing)<ins>
          != copy_options::none
        </ins> || ((options &amp; copy_options::update_existing)<ins>
          != copy_options::none
        </ins>
        &amp;&amp; last_write_time(from) &gt; last_write_time(to)) || <del>!</del>(options &amp;
        (copy_options::skip_existing
        | copy_options::overwrite_existing | copy_options::update_existing))<ins> == copy_options::none</ins>
      </code>
      copy the contents and attributes of the file <code>from</code> resolves to
      the file <code>to</code> resolves to.
    </p>
  </blockquote>

  <p>
    <i>Change 15.26 Permissions  [fs.op.permissions]:</i>
  </p>
  <blockquote>
    <p>
      <i>Requires:</i> <code>!((prms &amp; <ins>perms::</ins>add_perms) <ins>!= perms::none</ins> &amp;&amp; (prms &amp; <ins>perms::</ins>remove_perms) <ins>!= perms::none</ins>)</code>.
    </p>
  </blockquote>






<hr>
<h3><a name="2661" href="2661">2661.</a> [filesys.ts] Surprising <tt>equivalent()</tt> behavior if neither file exists</h3>
<p><b>Section:</b> 6 [filesys.ts::fs.filesystem.synopsis] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2014-04-12 <b>Last modified:</b> 2016-08-11 20:14:16 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesys.ts::fs.filesystem.synopsis">issues</a> in [filesys.ts::fs.filesystem.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: filesys.ts</b></p>
<p>
  <code>
    bool equivalent(const path&amp; p1, const path&amp; p2);
  </code> has always thrown a exception if neither file exists,
   with rationale that if they don't exist, it isn't possible to tell
   if two paths are equivalent. Dave Abrahams has reported that this
   is counter-intuitive and hard to teach.
</p>
  <p>An alternative if neither path exists would be to return true
  if they are lexically equal (operator==), otherwise return false.</p>
  <p>This was not a national body comment, and Dave is the only one
  I can recall ever complaining about the current behavior. On the
  other hand, any complaint from Dave deserves serious consideration.</p>

  <p><i>[17 Jun 2014 Rapperswil LWG considers this NAD. Mixing lexical and existence based
  behavior is not desirable.]</i></p>




<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2666" href="2666">2666.</a> Bitmask operations should use bitmask terms</h3>
<p><b>Section:</b> 31.12 <a href="https://timsong-cpp.github.io/cppwp/filesystems">[filesystems]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-06-30 <b>Last modified:</b> 2017-06-15 20:52:51 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#filesystems">issues</a> in [filesystems].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>C++14 17.5.2.1.3 Bitmask types [bitmask.types] paragraph 4 specifies:</p>
  <blockquote>
    <p/>The following terms apply to objects and values of bitmask types:
    <ul>
      <li>To <i>set</i> a value <i>Y</i> in an object <i>X</i> is to evaluate the expression <i>X |= Y.</i></li>
      <li>To <i>clear</i> a value Y in an object <i>X</i> is to evaluate the expression <i>X &amp;= ~Y</i>.</li>
      <li>The value Y <i>is set</i> in the object <i>X</i> if the expression <i>X &amp; Y</i> is nonzero.</li>
    </ul>
  </blockquote>
  <p/>The TS should use these forms where applicable throughout the document.

<p><i>[2016-02, Jacksonville]</i></p>

<p>This is an editoral change.</p>

<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2668" href="2668">2668.</a> <code>path::operator+=</code> is defined, but not <code>operator+</code></h3>
<p><b>Section:</b> 31.12.6 <a href="https://timsong-cpp.github.io/cppwp/fs.class.path">[fs.class.path]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2017-03-19 19:35:20 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.class.path">issues</a> in [fs.class.path].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>This doesn't seem to be in Boost.Filesystem, so maybe it isn't needed,
but since <code>path += path2</code> works then it seems reasonable to expect
<code>path1 + path2</code> to work as well.</p>

  <p><i>[04 Jul 2014 Beman Dawes comments:]</i></p>

  <blockquote>
    <p>The 12 overloads required by <code>basic_string operator+</code> scared me off,
    and I never came back to the issue.</p>  
  </blockquote>

  <p><i>[22 Nov 2015 Beman supplies proposed resolution wording.]</i></p>

 
<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: JW is no longer convinced that this is a good idea.</p>


<p><b>Proposed resolution:</b></p>
<p>NAD, Future.</p>
  <blockquote>
  <p>It is not necessary to provide every possible string operation for class
  <code>path</code> because it is always possible to convert to a string,
  perform the operation, and convert back to a path. The most commonly needed string
  operations are provided for class <code>path</code> as a convenience, but every added
  function comes at the cost of increased interface complexity. In this case, the cost
  is judged to outweigh the convenience.</p>
  
  <p>Future changes to the language, such as concepts, and changes to the library, such as
  <code>basic_string_view</code>, may allow reduction of the complexity of the class path
  interface. The LWG may wish to reconsider this issue at that time.</p>
  </blockquote>





<hr>
<h3><a name="2692" href="2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 16.3.3.3.4 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2017-07-17 23:27:54 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2700" href="2700">2700.</a> <tt>resource_adaptor</tt> went missing</h3>
<p><b>Section:</b> 20.4 <a href="https://timsong-cpp.github.io/cppwp/mem.res">[mem.res]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-05-04 <b>Last modified:</b> 2016-11-26 14:34:13 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.res">issues</a> in [mem.res].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The alias template <tt>std::experimental::resource_adaptor</tt> is an important
part of the polymorphic memory resources framework, but was not
adopted into the WP along with the rest of LFTSv1. This seems to be an
accidental omission. It was present in P0220R0, but absent in P0220R1.
There was no discussion of leaving it out in Jacksonville, it is one
of the "core features" discussed and intended for adoption.
</p>

<p><i>[Oulu, 2016-06]</i></p>

<p>Tuesday night: This was not an accidental omission.</p>
<p><tt>std::experimental::resource_adaptor</tt> will remain in the 
LFTS and we shall continue to gain implementation experience.</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Add section 8.7 from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a> 
(LFTSv2 DTS) into the WP.</p>
</li>
</ol>





<hr>
<h3><a name="2701" href="2701">2701.</a> Unclear requirement in [memory.resource.private]</h3>
<p><b>Section:</b> 20.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/mem.res.private">[mem.res.private]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-05-04 <b>Last modified:</b> 2017-06-15 20:52:51 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.res.private">issues</a> in [mem.res.private].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
 [memory.resource.private] says:
</p>
<blockquote><pre>
virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: Alignment shall be a power of two.
</p>
</blockquote>
</blockquote>
<p>
Is that supposed to be a requirement on the alignment specified by the
<tt>alignment</tt> parameter? If so the word "Alignment" should not be
capitalized and in text font.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
The resolution should reference [basic.align].  Jonathan to update the wording.
</p>
<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to NAD Editorial. Will change "Alignment" to <tt>alignment</tt> and add a reference to [basic.align]</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Modify  [memory.resource.private] paragraph 1 as shown:</p>

<blockquote><pre>
virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: <del>Alignment</del><ins>The alignment specified by
<code>alignment</code></ins> shall be a power of two.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2717" href="2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 20.5.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2017-07-17 23:27:54 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in [allocator.adaptor.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 20.5.4 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.members">[allocator.adaptor.members]</a> p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





<hr>
<h3><a name="2761" href="2761">2761.</a> <tt>directory_entry</tt> comparisons are members</h3>
<p><b>Section:</b> 31.12.10.4 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.entry.obs">[fs.dir.entry.obs]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-08-03 <b>Last modified:</b> 2017-03-19 19:35:20 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.dir.entry.obs">issues</a> in [fs.dir.entry.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The comparison operators for <tt>directory_entry</tt> are member functions
(31.12.10.4 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.entry.obs">[fs.dir.entry.obs]</a>).
<p/>
That means that a <tt>directory_entry</tt> can be compared with a <tt>path</tt>,
but a <tt>path</tt> cannot be compared with a <tt>directory_entry</tt>, because
the left-hand side is not subject to conversions. This seems
unfortunate.
<p/>
Note that the comparisons for <tt>path</tt> are non-members (31.12.6.8 <a href="https://timsong-cpp.github.io/cppwp/fs.path.nonmember">[fs.path.nonmember]</a>).
<p/>
The meta-p/r is to turn the <tt>directory_entry</tt> comparisons into non-member functions.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed PM: Priority 2</p>

<p><i>[2016-10-05 Ville provides concrete wording]</i></p>


<p><i>[2016-10 Telecon]</i></p>

<p>This (comparing a <tt>path</tt> with a <tt>directory_entry</tt>) works today w/o any changes. Closing as NAD.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In  [fs.class.directory_entry] synopsis, edit as follows:</p>

<blockquote>
<pre>
namespace std::filesystem {
class directory_entry {
public:
  [&hellip;]
  <del>bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
  bool operator==(const directory_entry&amp; rhs) const noexcept;
  bool operator!=(const directory_entry&amp; rhs) const noexcept;
  bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;
  bool operator&gt; (const directory_entry&amp; rhs) const noexcept;
  bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;</del>

private:
  path pathobject; // exposition only
};
<ins>
bool operator&lt; (const directory_entry&amp; lhs, const directory_entry&amp; rhs) noexcept;
bool operator==(const directory_entry&amp; lhs, const directory_entry&amp; rhs) noexcept;
bool operator!=(const directory_entry&amp; lhs, const directory_entry&amp; rhs) noexcept;
bool operator&lt;=(const directory_entry&amp; lhs, const directory_entry&amp; rhs) noexcept;
bool operator&gt; (const directory_entry&amp; lhs, const directory_entry&amp; rhs) noexcept;
bool operator&gt;=(const directory_entry&amp; lhs, const directory_entry&amp; rhs) noexcept;
</ins>
}
</pre>
</blockquote>
</li>

<li><p>In 31.12.10.4 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.entry.obs">[fs.dir.entry.obs]</a>/6-11, edit as follows:</p>

<blockquote>
<pre>
bool operator==(<ins>const directory_entry&amp; lhs,</ins> const directory_entry&amp; rhs) <del>const</del> noexcept;
</pre>
<blockquote>
<p>
-6- <i>Returns:</i> <tt><del>pathobject</del><ins>lhs.path()</ins> == rhs.<del>pathobject</del><ins>path()</ins></tt>.
</p>
</blockquote>
<pre>
bool operator!=(<ins>const directory_entry&amp; lhs,</ins> const directory_entry&amp; rhs) <del>const</del> noexcept;
</pre>
<blockquote>
<p>
-7- <i>Returns:</i>: <tt><del>pathobject</del><ins>lhs.path()</ins> != rhs.<del>pathobject</del><ins>path()</ins></tt>.
</p>
</blockquote>
<pre>
bool operator&lt; (<ins>const directory_entry&amp; lhs,</ins> const directory_entry&amp; rhs) <del>const</del> noexcept;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i>: <tt><del>pathobject</del><ins>lhs.path()</ins> &lt; rhs.<del>pathobject</del><ins>path()</ins></tt>.
</p>
</blockquote>
<pre>
bool operator&lt;&lt;=(<ins>const directory_entry&amp; lhs,</ins> const directory_entry&amp; rhs) <del>const</del> noexcept;
</pre>
<blockquote>
<p>
-9- <i>Returns:</i>: <tt><del>pathobject</del><ins>lhs.path()</ins> &lt;= rhs.<del>pathobject</del><ins>path()</ins></tt>.
</p>
</blockquote>
<pre>
bool operator&gt; (<ins>const directory_entry&amp; lhs,</ins> const directory_entry&amp; rhs) <del>const</del> noexcept;
</pre>
<blockquote>
<p>
-10- <i>Returns:</i>: <tt><del>pathobject</del><ins>lhs.path()</ins> > rhs.<del>pathobject</del><ins>path()</ins></tt>.
</p>
</blockquote>
<pre>
bool operator&gt;=(<ins>const directory_entry&amp; lhs,</ins> const directory_entry&amp; rhs) <del>const</del> noexcept;
</pre>
<blockquote>
<p>
-11- <i>Returns:</i>: <tt><del>pathobject</del><ins>lhs.path()</ins> &gt;= rhs.<del>pathobject</del><ins>path()</ins></tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2764" href="2764">2764.</a> Are <code>&lt;cstddint&gt;</code> macros optional?</h3>
<p><b>Section:</b> 17.4.2 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-08-10 <b>Last modified:</b> 2017-03-21 22:54:52 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Are the macros <code>INT[8, 16, 32, 64]_MAX</code> etc. optional?
<p/>
The entire <code>&lt;cstddint&gt;</code> header is specified to have all types and macros "defined the same as in C". 
But C is also unclear about this: the fixed-width types like <code>int32_t</code> are optional in C and in C++. 
The corresponding macro <code>INT32_MAX</code> is defined in terms of an expression of the same type as the 
"corresponding type converted according to the integral promotions". But if the "corresponding type" does not exist, 
then surely the macro too cannot exist? It seems that the macros should also be optional.
<p/>
Suggested resolution: See e.g. <a href="https://github.com/cplusplus/draft/pull/843">here</a>, or equivalent wording 
to the effect that the macros <code>INT*_MAX</code> etc are defined if and only if the corresponding integer type is 
defined.
<p/>
(Note that the types <code>intptr_t</code> and <code>uintptr_t</code> are also optional.)
</p>

<p><i>[2016-08-11, Richard comments]</i></p>

<p>
C allows other values for <code>N</code> in addition to 8, 16, 32, 64, whereas it appears that C++ does not. 
Is the difference intentional?
</p>

<p><i>[2016-09-09 Issues Resolution Telecon]</i></p>

<p>We need to answer Richard's question before making this ready</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Close as a duplicate of <a href="2820">2820</a> per Thomas' request.</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2772" href="2772">2772.</a> Inconsistency in the <tt>insert(node)</tt> interface</h3>
<p><b>Section:</b> 24.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 24.4.2 <a href="https://timsong-cpp.github.io/cppwp/associative.map.syn">[associative.map.syn]</a>, 24.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.syn">[unord.map.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2016-09-06 <b>Last modified:</b> 2018-01-28 19:43:07 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++17 the interface of the unique <tt>map</tt> was extended to include following function:
</p>
<blockquote><pre>
pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; k, Args&amp;&amp;... args); //and move version
iterator try_emplace(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args); //and move version
iterator insert(const_iterator hint, node_type&amp;&amp; nh)
insert_return_type insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
All of the functions share a common property, that they are performing basically no-operation in case when element 
with given key (part of node) is already stored in the map. However there is major difference in their interface. 
The first three functions:
</p>
<blockquote><pre>
pair&lt;iterator, bool&gt; try_emplace(key_type&amp;&amp; k, Args&amp;&amp;... args); //and copy version
iterator try_emplace(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args); //and copy version
iterator insert(const_iterator hint, node_type&amp;&amp; nh)
</pre></blockquote>
<p>
are guaranteeing that the value of the arguments (<tt>k, nh, args...</tt>) will not be changed if the map already 
contains a key with given value, so the programmer is free to reuse it for their own purpose.
<p/>
However, the interface of the fourth function is a bit different:
</p>
<blockquote><pre>
insert_return_type insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
The <tt>insert_return_type</tt> is an unspecified type that contains:
</p>
<blockquote><pre>
bool inserted;
X::iterator position;
X::node_type node;
</pre></blockquote>
<p>
As  we can see, the <tt>insert</tt> function is returning a <tt>node</tt>. This difference is actually
misleading, as the programmer may start to wonder, why the function returns a <tt>node</tt> handle, 
instead of being guaranteed that the argument will not be modified (as other functions do). Most reasonable 
explanation is that, this function actually return a handle to a different <tt>node</tt>, that one passed 
as the argument, i.e. this function replaces an existing node with the <tt>nh</tt> argument and returns the
handle to the old <tt>node</tt>. However, this function actually has the same semantics as the other <tt>insert</tt> 
function and returns a <tt>node</tt> that was passed as argument.
<p/>
In addition, this design makes the interface of the <tt>insert</tt> function for the map inconsistent. Value 
inserting functions are returning <tt>pair&lt;iterator, bool&gt;</tt> while node inserting function is 
returning an unspecified type with guaranteed set of members.
<p/>
The only potential benefit of this signature is that it could potentially allow programmer to use 
decomposition declaration, so instead of:
</p>
<blockquote><pre>
auto nh = node_provider();
if (map.insert(std::move(nh)).second)
  handle_node_in_other_way(std::move(nh));
</pre></blockquote>
<p>
The user would be able to write:
</p>
<blockquote><pre>
if (auto [it, ins, nh] = map.insert(node_provider); ins)
   handle_node_in_other_way(std::move(nh));
</pre></blockquote>
<p>
However, the <tt>insert_return_type</tt> is not currently required to work with decomposition declaration, so 
this is only "potential" benefit that could be added in future.
<p/>
Furthermore, this change is preventing a user to use structured binding with combination with <tt>insert</tt> 
in generic code:
</p>
<blockquote><pre>
template&lt;typename UniqMap, typename Elem&gt;
void log_duplicate_insertion(UniqMap&amp; map, Elem&amp;&amp; elem)
{
  if (auto [it, ins] = map.insert(std::forward&lt;Elem&gt;(elem)); !ins)
    std::cout &lt;&lt; "attempt to insert duplicate for " &lt;&lt; *it;
}
</pre></blockquote>
<p>
Currently, <tt>log_duplicate_insertion</tt> will not work with <tt>node_handle_type</tt>.
<p/>
So, I am proposing to change the interface of the <tt>insert(node_handle)</tt> function for associative containers 
with unique keys, to be consistent with the other <tt>insert</tt> operation and <tt>try_emplace</tt> function. I.e. 
change the signature to:
</p>
<blockquote><pre>
std::pair&lt;iterator, bool&gt; insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
and provide the guarantee that <tt>nh</tt> will be unchanged if an element was not inserted.
</p>

<p><i>[2016-09-06, Howard comments]</i></p>

<p>
This is related to LWG <a href="839">839</a>.
</p>

<p><i>[2018-1-26 issues processing telecon]</i></p>

<p>Status to 'NAD'; this is "specified as designed". This was considered during the design, but not accepted.</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2775" href="2775">2775.</a> <tt>reverse_iterator</tt> is does not compile for fancy pointers</h3>
<p><b>Section:</b> 25.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-09-23 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#reverse.iter.elem">active issues</a> in [reverse.iter.elem].</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.elem">issues</a> in [reverse.iter.elem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="1052">1052</a></p>
<p><b>Discussion:</b></p>

<p>
<tt>std::reverse_iterator&lt;Iterator&gt;::operator-&gt;()</tt> is specified to call <tt>addressof(operator*())</tt>,
but it returns <tt>iterator_traits&lt;Iterator&gt;::pointer</tt>, which may be a fancy pointer type from which no
conversion from <tt>T*</tt> is possible. It should instead delegate to the underlying iterator's <tt>operator-&gt;()</tt>.
</p>

<p><i>[Issues processing Telecon 2016-10-7]</i></p>

<p>Set status to Duplicate</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify  [reverse.iter.opref] as indicated:</p>
<blockquote>
<pre>
constexpr pointer operator-&gt;() const;
</pre>
<blockquote>
<p>
-1- <del><i>Returns:</i> <tt>addressof(operator*())</tt>.</del><ins><i>Effects:</i> If <tt>Iterator</tt>
is a pointer type, as if by:</ins>
</p>
<blockquote><pre>
<ins>Iterator tmp = current;
return --tmp;</ins>
</pre></blockquote>
<p>
<ins>Otherwise, as if by:</ins>
</p>
<blockquote><pre>
<ins>Iterator tmp = current;
--tmp;
return tmp.operator-&gt;();</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2822" href="2822">2822.</a> Resolution for LWG 2742 introduces ambiguities</h3>
<p><b>Section:</b> 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-11-15 <b>Last modified:</b> 2017-01-30 17:56:50 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new constructor added for LWG <a href="2742">2742</a> causes an ambiguity when attempting to construct from a (non-const) <tt>char*</tt>
</p>
<blockquote><pre>
char s[] = "whoops"; 
std::string str(s, 2, 4);
</pre></blockquote>
<p>
This is the same problem discussed in <a href="2758">2758</a>, and the fix is the same: disable that new constructor if <tt>T</tt> 
is convertible to <tt>const_pointer</tt>, so that the old constructor is used instead.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify the new <tt>basic_string(const T&amp; t, size_type pos, size_type n, const Allocator&amp; a = Allocator());</tt> 
constructor in 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> as shown:</p>

<blockquote>
<pre>
template&lt;class T&gt;
basic_string(const T&amp; t, size_type pos, size_type n, const Allocator&amp; a = Allocator());
</pre>
<blockquote>
<p>
-?- <i>Effects:</i> Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> and 
then behaves the same as:
</p>
<blockquote><pre>
basic_string(sv.substr(pos, n), a)
</pre></blockquote>
<p>
-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt> <ins>and 
<tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-12-21, Jonathan comments and reommends NAD]</i></p>

<p>
Tim Song pointed out that this constructor isn't ambiguous, and I can
no longer reproduce the errors I was getting, so I think this issue
should be resolved NAD. The code snippet in the issue discussion
compiles OK without the proposed change.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>NAD</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2828" href="2828">2828.</a> Clarify <tt>&lt;cstdalign&gt;</tt> (following adoption of P0063r3)</h3>
<p><b>Section:</b> 21.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-11-20 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Oulu, we adopted <a href="https://wg21.link/p0063r3">P0063r3</a> to base C++ on C11. C11 is the first version 
of C that defines a header <tt>&lt;stdalign.h&gt;</tt>. However, C++11 (!) already seems to have defined headers 
<tt>&lt;cstdalign&gt;</tt> and <tt>&lt;stdalign.h&gt;</tt>, even though C99 does not have <tt>&lt;stdalign.h&gt;</tt>.
<p/>
This appears to be the consequence of the partial application of N3093 from 2010, which proposes both to add 
<tt>&lt;cstdalign&gt;</tt> and to rebase C++ onto C11. However, the latter part didn't happen, leaving the header 
dangling without a sensible specification.
<p/>
I suggest two actions:
</p>
<ol style="list-style-type: none">
<li>1) Recognize that C++11 and C++14 are defective in mentioning <tt>&lt;cstdalign&gt;</tt> and <tt>&lt;stdalign.h&gt;</tt>.</li>

<li>2a) Consequently, P0063r3 is <em>adding</em> <tt>&lt;cstdalign&gt;</tt> as a new feature; I would like to revert that 
decision and not add this header. Instead, P0063r3 should <em>only</em> add <tt>&lt;stdalign.h&gt;</tt> (which should 
be done in Annex D) for compatibility with C.</li>

<li>2b) If we do not want to un-add <tt>&lt;cstdalign&gt;</tt>, we should at least put the specification of <tt>&lt;cstdalign&gt;</tt> into Annex D.</li>
</ol>
<p>
Moreover, I would like to ask LWG for editorial dispensation to move the specifications of <tt>&lt;ccomplex&gt;</tt>, 
<tt>&lt;ctgmath&gt;</tt> and <tt>&lt;cstdbool&gt;</tt> wholly into Annex D, too, since these are now deprecated features that are not otherwise referred to or needed by the main text. An example change is available 
<a href="https://github.com/cplusplus/draft/pull/1054">on github</a>, which incorporates solution 2b. 
Wording for solution 2a can be produced on request.
</p>
<p><i>[2017-01-27 Telecon]</i></p>

<p>NAD Editorial; Thomas will make the editorial changes (option 2B)</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2852" href="2852">2852.</a> Specifications of <tt>operator==</tt> for <tt>std::basic_string</tt>s and <tt>std::basic_string_view</tt>s are
difficult to conform to</h3>
<p><b>Section:</b> 23.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/string.cmp">[string.cmp]</a>, 23.4.3.8.4 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ahti Lepp&auml;nen <b>Opened:</b> 2017-01-09 <b>Last modified:</b> 2021-06-06 18:38:24 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently (<a href="https://wg21.link/n4618">N4618</a>, 2016-11-28) the specification of <tt>operator==</tt>
for <tt>std::basic_string</tt> and <tt>std::basic_string_view</tt> objects is clearly defined, but when
interpreted as written, it may lead to comparison of strings of different sizes being a &#x1d4aa;(n) operation
instead of a simple size check. Actual implementations in standard libraries vary so that in practice the
programmers can't rely neither on having the literal version of the standard specification nor reasonable
performance characteristics.
<p/>
The definition for <tt>basic_string operator==</tt> in N4618 is as follows:
</p>
<blockquote>
<p>
 [string.operator==]
</p>
<pre>
bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,
                const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt>lhs.compare(rhs) == 0</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<p>
23.4.3.8.4 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a>
</p>
<pre>
int compare(const basic_string&amp; str) const noexcept;
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Equivalent to: <tt>return compare(basic_string_view&lt;charT, traits&gt;(str));</tt>
</p>
</blockquote>
</blockquote>

<blockquote>
<p>
23.4.3.8.4 <a href="https://timsong-cpp.github.io/cppwp/string.compare">[string.compare]</a>
</p>
<pre>
int compare(basic_string_view&lt;charT, traits&gt; sv) const noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Determines the effective length <tt>rlen</tt> of the strings to compare as the smaller of
<tt>size()</tt> and <tt>sv.size()</tt>. The function then compares the two strings by calling <tt>traits::compare(data(),
sv.data(), rlen)</tt>.
<p/>
-2- <i>Returns:</i> The nonzero result if the result of the comparison is nonzero. Otherwise, returns a value as
indicated in Table 63.
</p>
</blockquote>
<blockquote>
<table border="1">
<caption>Table 63 &mdash; <tt>compare()</tt> results</caption>
<tr>
<th>Condition</th>
<th>Return Value</th>
</tr>

<tr>
<td><tt>size() &lt; sv.size()</tt></td>
<td><tt>&lt; 0</tt></td>
</tr>

<tr>
<td><tt>size() == sv.size()</tt></td>
<td><tt>0</tt></td>
</tr>

<tr>
<td><tt>size() &gt; sv.size()</tt></td>
<td><tt>&gt; 0</tt></td>
</tr>
</table>

</blockquote>
</blockquote>
<p>
From these it seems that <tt>compare()</tt> of strings of different sizes can't return zero and <tt>operator==</tt>
will return <tt>false</tt>. However some implementations do not seem to call <tt>traits::compare()</tt> for
<tt>basic_string</tt>s of different sizes even when the traits and it's <tt>compare()</tt> are user-defined. And those
that call, make the <tt>operator==</tt> a worst case &#x1d4aa;(n) operation even for strings of different sizes.
<p/>
This defect report does not propose a wording, but on a general level the wording should allow standard library
implementers to write a standard conforming <tt>operator==</tt> for <tt>basic_string</tt> and <tt>basic_string_view</tt>
(others?) in such a way that it's performance characteristics are reasonable and the programmers can rely on having
a consistent behaviour across implementations. Perhaps the key issue here is that <tt>operator==</tt> is defined
through <tt>compare() == 0</tt>: while it returns the intended result, for some inputs it does computations that
are not needed by <tt>operator==</tt>. There are also related specifications that may need to be revised, for example
<tt>operator!=</tt> for <tt>basic_string_view</tt>s is defined in 23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a> as
</p>
<blockquote>
<p>
<i>Returns:</i> <tt>lhs.compare(rhs) != 0</tt>
</p>
</blockquote>

<p><i>[2017-01-26, Jonathan Wakely comments and provides proposed resolution]</i></p>

<p>
As mentioned above, some implementations do not make a call to <tt>Traits::compare</tt> if the string lengths are not equal,
even though in general this is an observable side effect. Some implementations only perform that optimisation for
<tt>std::string</tt> and <tt>std::wstring</tt>, where we know that calls to <tt>std::char_traits&lt;char&gt;::compare</tt>
and <tt>std::char_traits&lt;wchar_t&gt;::compare</tt> are not observable.
<p/>
My reading is that the <i>Returns:</i> element describes the value that must be returned, not the precise steps that must be
taken to calculate that value. If we intended to specify the precise steps that must be taken then we could say that using
"<i>Effects:</i> Equivalent to [&hellip;]", but we don't do that.
<p/>
I would prefer this issue to be closed NAD with the rationale that my reading is correct and comparing the lengths to avoid
calling <tt>Traits::compare</tt> is already permitted. But if my reading is wrong we need to permit this obvious optimisation.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2</p>

<p><i>[2017-02-04, Ahti Lepp&auml;nen comments and recommends NAD]</i></p>

<p>
While there seems to be varying interpretations of the standards wording, given the comments in this defect report and
definitions in  [structure.specification] (N4618):
</p>
<blockquote><p>
<i>Effects:</i> the actions performed by the function
<p/>
<i>Returns:</i> a description of the value(s) returned by the function
</p>
</blockquote>
<p>
I fail to see that the specification of <tt>operator==</tt> "<i>Returns:</i> <tt>lhs.compare(rhs) == 0</tt>" would require call
to <tt>compare()</tt> and no longer consider the report valid.
</p>

<p><i>[2016-07, Toronto Saturday afternoon issues processing]</i></p>

<p>Status to NAD; we accept Jonathan's reasoning. Note that several implementations do this today.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4618">N4618</a>.</p>

<ol style="list-style-type:upper-alpha">
<li><p>Preferred: NAD</p></li>
<li><p>Alternative:</p>

<ol>
<li><p>Modify  [string.operator==] p1 as shown:</p>
<blockquote>
<pre>
template&lt;class charT, class traits, class Allocator&gt;
  bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,
                  const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <tt><ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.view.comparison">[string.view.comparison]</a> as shown:</p>
<blockquote>
<p>
[<i>Example:</i> A sample conforming implementation for <tt>operator==</tt> would be:
</p>
<pre>
template&lt;class T&gt; using __identity = decay_t&lt;T&gt;;
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept {
    return <ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0;
  }
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            __identity&lt;basic_string_view&lt;charT, traits&gt;&gt; rhs) noexcept {
    return <ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0;
  }
template&lt;class charT, class traits&gt;
  constexpr bool operator==(__identity&lt;basic_string_view&lt;charT, traits&gt;&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept {
    return <ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0;
  }
</pre>
<p>
&mdash; <i>end example</i>]
</p>
<pre>
template&lt;class charT, class traits&gt;
  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;
</pre>
<blockquote>
<p>
-2- <i>Returns:</i> <tt><ins>lhs.size() == rhs.size() &amp;&amp;</ins> lhs.compare(rhs) == 0</tt>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <tt><ins>lhs.size() != rhs.size() ||</ins> lhs.compare(rhs) != 0</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>

</li>
</ol>





<hr>
<h3><a name="2854" href="2854">2854.</a> <tt>wstring_convert</tt> provides no indication of incomplete input or output</h3>
<p><b>Section:</b> D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.conversions.string">[depr.conversions.string]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> PowerGamer <b>Opened:</b> 2017-01-08 <b>Last modified:</b> 2017-06-05 20:39:07 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.string">active issues</a> in [depr.conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.string">issues</a> in [depr.conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Example:
</p>
<blockquote><pre>
// Input UTF-16 string is incomplete - only first half of
// UTF-16 surrogate pair L"\xD843\xDEF9":
wchar_t in_utf16[] = L"\xD843";

std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt; cvt;
auto out_utf8 = cvt.to_bytes(in_utf16); // No error.
</pre></blockquote>
<p>
There is no indication that input was incomplete (the value returned
by <tt>cvt.state()</tt> is not documented and so cannot be examined by user for
that purpose). As such the user will not know that more input data
should be provided in additional call to <tt>cvt.to_bytes()</tt>.
<p/>
The output can be incomplete too: MSVC2017 implementation (which as
far as I can tell is standard conforming) produces <tt>"\xF0"</tt> in <tt>out_utf8</tt>.
Again, no indication of incomplete output produced is provided by
<tt>std::wstring_convert</tt>.
<p/>
IMO it makes <tt>std::wstring_convert</tt> in its current state completely
useless (it cannot be relied upon to either produce complete and valid
UTF sequence or throw an error in all situations).
<p/>
Imagine a file has UTF16 encoded text. You want to read all the data
from a file at once and convert it into UTF8 using
<tt>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt;</tt>.
<p/>
Now, if a file contains completely <em>invalid</em> UTF16 (for example,
forbidden or incorrectly encoded Unicode code points) you will get an
exception from <tt>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt;</tt>.
<p/>
But if a file contains <em>incomplete</em> (but in all other regards <em>valid</em>)
UTF16 (for ex. file ends with only the first half of a valid surrogate
pair) you will <em>neither</em> get an error exception from
<tt>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt;</tt> <em>nor</em> any
indication that the input provided to 
<tt>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt;</tt> was incomplete.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; send to LEWG</p>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>


<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>This facility has a number of known problems, including poor error handling.
The feature has been deprecated, and the plan is to replace it with better
facilities with a better API.</p>
<p>Resolve as NAD</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2860" href="2860">2860.</a> <tt>launder</tt> and base class subobjects</h3>
<p><b>Section:</b> 17.7.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2017-01-31 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.launder">issues</a> in [ptr.launder].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is an apparent oversight in the wording for <tt>launder</tt> that allows it to return base class 
subobjects which differ in their polymorphic behaviour between calls to <tt>launder</tt>.
</p>
<p>
This can be fixed by restricting <tt>launder</tt> from returning pointers to base class subobjects:
</p>
<ol>
<li><p>always, or</p></li>
<li><p>only for polymorphic class types.</p></li>
</ol>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 2. This was discussed in EWG (via a paper). Assign this (and <a href="2859">2859</a>) to Core.</p>

<p><i>[2017-08-14, CWG telecon note]</i></p>

<p>
Core recommends NAD after discussion in EWG.
<p/>
Hubert Tong summarizes the outcome of that discussion as follows:
</p>
<blockquote>
<tt>launder</tt> does not provide positive confirmation of the dynamic type of the object; it is intended that 
<tt>launder</tt> can be used to induce a devirtualization barrier even when the static type of the (sub)object 
to which the returned pointer refers is apparently consistent with prior accesses related to the source pointer.
</blockquote>

<p><i>[2020-02 Status to NAD on Thursday night in Prague.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4618">N4618</a>.</p>

<ol style="list-style-type: none">
<li><p>Option 1:</p>

<ol>
<li><p>Modify 17.7.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T&gt; constexpr T* launder(T* p) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>p</tt> represents the address <tt><i>A</i></tt> of a byte in memory. An object <tt><i>X</i></tt> 
that is within its lifetime (6.7.3 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>) and whose type is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to <tt>T</tt> 
is located at the address <tt><i>A</i></tt>. <ins><tt><i>X</i></tt> shall either be a most derived object, or 
pointer-interconvertible with a most derived object that is within its lifetime.</ins> All bytes of storage that would be 
reachable through the result are reachable through <tt>p</tt> (see below).
</p>
</blockquote>
</blockquote>
</li>

</ol>

</li>
<li><p>Option 2:</p>

<ol>
<li><p>Modify 17.7.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T&gt; constexpr T* launder(T* p) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>p</tt> represents the address <tt><i>A</i></tt> of a byte in memory. An object <tt><i>X</i></tt> 
that is within its lifetime (6.7.3 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>) and whose type is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to <tt>T</tt> 
is located at the address <tt><i>A</i></tt>. <ins>If <tt>T</tt> is a polymorphic class type, then <tt><i>X</i></tt> shall 
be a most derived object.</ins> All bytes of storage that would be reachable through the result are reachable through 
<tt>p</tt> (see below).
</p>
</blockquote>
</blockquote>
</li>

</ol>

</li>
</ol>





<hr>
<h3><a name="2865" href="2865">2865.</a> Resolve all open Library issues for C++17</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-03-12 23:05:20 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses FI 2</b></p>

<p>All open Library Issues should be resolved.</p>

<p>
Proposed change:
</p>
<p>
As LWG sees fit.
</p>

<p><i>[2017-03-12, post-Kona]</i></p>

<p>Closing as NAD; this issue was opened by an over-zealous LWG chair.</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2871" href="2871">2871.</a> User specializations of type traits should be ill-formed</h3>
<p><b>Section:</b> 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in [meta.type.synop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in [meta.type.synop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 10</b></p>

<p>A user specialization of any type trait should produce 
an ill-formed program, not merely one whose behavior is unspecified.
See also the related comment re 22.12.3 <a href="https://timsong-cpp.github.io/cppwp/execpol.type">[execpol.type]</a>.</p>

<p>
Proposed change:
</p>
<p>
Reword the paragraph as follows:
</p>
<blockquote>
<p>
Unless otherwise specified, a program that adds 
specializations for any of the templates defined in 
this subclause is ill-formed; no diagnostic required.
</p>
</blockquote>

<p>
See also <a href="2909">2909</a>
</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>NAD; what the standard says is that this is "undefined", not "unspecified".</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> as indicated:</p>
<blockquote>
<p>
-1- <del>The behavior of a program that adds specializations for any of the templates defined in this subclause is
undefined unless otherwise specified</del><ins>Unless otherwise specified, a program that adds 
specializations for any of the templates defined in this subclause is ill-formed; no diagnostic required</ins>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2886" href="2886">2886.</a> Keep the <tt>empty()</tt> functions in <tt>any</tt></h3>
<p><b>Section:</b> 22.7.4.5 <a href="https://timsong-cpp.github.io/cppwp/any.observers">[any.observers]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 7</b>

<p>The proposal <a href="https://wg21.link/p0032">p0032</a> has multiple problems: 1) it turns member function <tt>.empty()</tt> 
into <tt>.has_value()</tt>, negating the logic. Refactoring e.g. existing uses of <tt>std::experimental::any</tt> to use 
<tt>std::any</tt> thus involve non-trivial refactorings that are error- prone and can't be done via simple search-and-replace 
if there are containers in the same source files for which <tt>.empty()</tt> is used (based on the implementation experience 
of making the change in libstdc++ and refactoring the testsuite). Whilst <tt>any</tt> is not a container, the library is failing 
to go towards a direction where there would be a generic way to query for emptiness. 2) The use of function references for 
tag types makes the interface hard to use. The tag types do not have value semantics like every other tag type has, the tag 
types are hard to construct, and present surprises for certain kinds of overload sets. Furthermore, any attempts to decay the 
tag types produces a really surprising effect &mdash; as opposed to what the other tag types do, which is that the result of 
decaying them is the tag type itself, decaying these new tag types results in a pointer to function.</p>

<p>Proposed change: Keep the <tt>.empty()</tt> functions (and introduce them to all the types that are supposed to have a 
homogeneous interface), and make the tag types be regular tag types that are not references to functions.</p>

<p><i>[2017-02-03, Marshall notes]</i></p>

<p><a href="https://wg21.link/p0504r0">P0504R0</a> (adopted in Issaquah) removed use of function references for tag types</p>

<p><i>[
2017-06-26 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2891" href="2891">2891.</a> Relax library requirements on <tt>volatile</tt> types</h3>
<p><b>Section:</b> 16.4.6 <a href="https://timsong-cpp.github.io/cppwp/conforming">[conforming]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-15 23:15:19 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#conforming">issues</a> in [conforming].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 35</b>

<p>Most implementations have poor testing and support for instantiating standard library templates with <tt>volatile</tt>-qualified 
types. We should grant a library-freedom to conforming implementations so that support for <tt>volatile</tt> (and <tt>const volatile</tt>)
qualified types in standard library templates is not required unless explicitly specified &mdash; and mandate such support for all 
templates in the <tt>&lt;type_traits&gt;</tt> header. Additional support is already specified in most places we would be interested 
(e.g., tuple API). We may want to additionally guarantee support through forwarding references.</p>
<p>Proposed change: add a new 17.6.5.x Volatile Qualified Types [res.on.volatile.type] describing the intended level of support for 
<tt>volatile</tt> qualifiers.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>This is not a defect, but a feature request (and a large one). Papers welcome, but closing as NAD</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2892" href="2892">2892.</a> Relax the prohibition on libraries adding <tt>constexpr</tt></h3>
<p><b>Section:</b> 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#constexpr.functions">issues</a> in [constexpr.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 38</b>

<p>Relax the prohibition on libraries adding <tt>constexpr</tt>; this was a constraint requested by library implementers when 
<tt>constexpr</tt> was new, and those same implementers now feel unduly constrained.</p>
<p>Proposed change: Rewrite the whole sub-clause to support libraries adding <tt>constexpr</tt> in a compatible manner, 
much like the freedom to add a <tt>noexcept</tt> specification.</p>

<p><i>[2017-02-20, Marshall adds wording]</i></p>

<p>The simplest change would be to strike the sentence "An implementation shall not [&hellip;] explicitly required". However, 
people seem to want a definite permission here, so I have provided one.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Priority 1</p>

<p><i>[2018-06 Rapperswil Thursday issues processing]</i></p>

<p>This is a feature request; not a defect. We've had two cross-group meetings over this, and there is no consensus for changing this. Closing as NAD.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4640">N4640</a>.</p>

<ol>
<li><p>Modify 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:</p>
<blockquote>
<p>This International Standard explicitly requires that certain standard library functions are constexpr (7.1.5). <ins>An 
implementation may declare additional standard library function signatures as constexpr</ins><del>An implementation shall 
not declare any standard library function signature as constexpr except for those where it is explicitly required</del>. 
Within any header that provides any non-defining declarations of constexpr functions or constructors an implementation 
shall provide corresponding definitions.</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2893" href="2893">2893.</a> Parsing Hexadecimally in P0067R4</h3>
<p><b>Section:</b> 22 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utilities">issues</a> in [utilities].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 45</b>

<p>If <a href="https://wg21.link/p0067r4">P0067R4</a> is applied consider how to parse hexadecimally:</p>
<blockquote>
<p><tt>to_chars(beg, end, 42, 16);</tt> 16 for hex</p>
<p><tt>to_chars(beg, end, 4.2, true);</tt> true means hex</p>
<p><tt>to_chars(beg, end, 4.2, chars_format::hex);</tt></p>
<p><tt>to_chars(beg, end, 4.2, chars_format::hex, 2);</tt></p>
</blockquote>

<p>That is: We have 3 different formats to specify hex depending on value types and whether to use precision.
Which application programmer should remember this?</p>

<p>May be even worse (I am not sure):</p>
<blockquote><tt>to_chars(beg, end, 4.2, 16);</tt></blockquote>
<p>would silently convert 4.2 to 4 and</p>
<blockquote><tt>to_chars(beg, end, 4, chars_format::hex);</tt></blockquote>
<p>would silently convert 4 to 4.000000.</p>

<p>Proposed change: The various options should be harmonized, possibly by use of an extended enum approach, having the values:
dec, hex, scientific, fixed, general
with dec (new!) as default for integral values and general for floats</p>

<p><i>[2017-02-23, Jens Maurer comments]</i></p>

<p>
This issue is NAD; the facility was redesigned with these considerations
in mind before it went into the working draft.
</p>

<p><i>[
2017-06-26 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>







<hr>
<h3><a name="2896" href="2896">2896.</a> The contents of <tt>&lt;codecvt&gt;</tt> are underspecified</h3>
<p><b>Section:</b> D.22 <a href="https://timsong-cpp.github.io/cppwp/depr.locale.stdcvt">[depr.locale.stdcvt]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Great Britain <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-04-22 20:23:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.locale.stdcvt">issues</a> in [depr.locale.stdcvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses GB 57</b>

<p>The contents of <tt>&lt;codecvt&gt;</tt> are underspecified, and will take a reasonable amount of work to identify and correct all of the issues. There appears to be a general feeling that this is not the best way to address unicode transcoding in the first place, and this library component should be retired to Annex D, along side <tt>&lt;strstream&gt;</tt>, until a suitable replacement is standardized</p>

<p>Proposed change: Deprecate and move the whole of clause  [locale.stdcvt] to Annex D.</p>

<p><i>[2017-02-03, Daniel comments]</i></p>

<p>
This issue unintentionally became added a second time, it should be considered as a pure duplicate of LWG <a href="2869">2869</a>. 
By a wit of fortuity, both issues can also be transformed into each other by transposing the last two digits of the issue numbers.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This issue is a duplicate of LWG <a href="2869">2869</a>.
</p>






<hr>
<h3><a name="2898" href="2898">2898.</a> Prefer not to use member typedefs as constructor parameters</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-06-02 05:40:10 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 106</b>

<p>Review the whole library for constructors using member typedefs to name constructor parameters rather than template 
type parameters, as this inhibits class template deduction. e.g., the <tt>unique_lock</tt> explicit constructor 
taking the <tt>mutex_type</tt> typedef would be better served naming <tt>Mutex</tt> directly, to preserve support for deduction.</p>
<p>Proposed change: Review each constructor of each library class template, and revise specification of parameter types as needed.</p>

<p><i>[2017-03-03, Kona Friday morning]</i></p>

<p>This is no longer true; core has fixed this</p>
<p>Setting to NAD</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2902" href="2902">2902.</a> <tt>variant</tt> should only support complete types</h3>
<p><b>Section:</b> 22.6.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.variant">issues</a> in [variant.variant].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 114</b>

<p><tt>variant</tt> needs to know the size of an object in order to compute the size of its internal buffer, so 
require that any <i>cv</i>-qualified object type in <tt>Types...</tt> be a complete type.</p>
<p>Proposed change: Add 'complete' in p2</p>

<p><i>[2017-07-01, Daniel comments]</i></p>

<p>
I recommend to close this issue as NAD: According to 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> p2 plus bullet (2.5):
</p>
<blockquote>
<p>
-2- In particular, the effects are undefined in the following cases:
</p>
<ol style="list-style-type: none">
<li><p>&mdash; [&hellip;]</p></li>
<li><p>(2.5) &mdash; if an incomplete type (6.9) is used as a template argument when instantiating a template component,
unless specifically allowed for that component.</p></li>
</ol>
</blockquote>
<p>
In other words: The standard currently already requires type completeness for all types in <tt>Types...</tt> of
<tt>std::variant&lt;Types...&gt;</tt>, we therefore should not repeat that again (Note that other templates &mdash; such as 
<tt>shared_ptr</tt> &mdash; <em>grant</em> type <b>in</b>completeness allowance for that reason).
<p/>
The criteria for the alternative resolution form <a href="lwg-active.html#Resolved">Resolved</a> do not apply for this case, 
because the quoted constraint do exist since C++98 (see 17.4.3.6 [lib.res.on.functions] p2 b5), so the issue was not 
even an issue at the point of the submission.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/N4618">N4618</a>.</p>
<ol>
<li><p>Edit 22.6.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>/2 as indicated:</p>
<blockquote>
All types in <tt>Types...</tt> shall be (possibly <i>cv</i>-qualified)<ins> complete</ins> object types that are not arrays.
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2017-07-06 Moved to Tentatively NAD after 5 positive votes on c++std-lib.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
The lack of the explicit constraint in 22.6.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> is not a defect, because the general requirements in 
16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> p2 already impose the requested type completeness constraints.
</p>





<hr>
<h3><a name="2907" href="2907">2907.</a> Semantics for destroying the deleter and the control-block of a <tt>shared_ptr</tt> are unclear</h3>
<p><b>Section:</b> 20.3.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-15 23:15:19 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.dest">issues</a> in [util.smartptr.shared.dest].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 134</b>

<p>The semantics for destroying the deleter and the control-block are unclear. In particular, it is not clear that we 
guarantee a lack of race conditions destroying the control-block and deleter. Possible race-free implementations might 
destroy the deleter after running <tt>d(p)</tt>, and before giving up the weak reference held by this <tt>shared_ptr</tt>; 
running the destructor for <tt>d</tt> only when the last <tt>weak_ptr</tt> is destroyed, potentially at a much later date, 
but ensuring that <tt>d(p)</tt> completes before the <tt>shared_ptr</tt> gives up its weak reference; making a copy of 
<tt>d</tt> in the destructor before manipulating the weak count, and then using this copy to run <tt>d(p)</tt>, even while 
the control-block could be concurrently reclaimed with an expiring <tt>weak_ptr</tt> in another thread. Note that this 
may be related to LWG <a href="2751">2751</a>. (Also, see the note in 20.11.2.2.10 p1 [util.smartptr.getdeleter])</p>

<p>Proposed change: Clarify that the <tt>shared_ptr</tt> weak ownership of the control block is released at the end of the 
destructor, and not as the destructor begins. Otherwise, the deleter might be destroyed even before the destructor gets to 
move a copy to call safely.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>NAD; Alisdair to provide rationale</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2909" href="2909">2909.</a> User specializations of <tt>is_execution_policy</tt> should be ill-formed</h3>
<p><b>Section:</b> 22.12.3 <a href="https://timsong-cpp.github.io/cppwp/execpol.type">[execpol.type]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-16 20:45:12 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 14</b>

<p>A user specialization of any <tt>is_execution_policy</tt> should produce an ill-formed program, not merely one whose behavior is unspecified. See also the related comment re [meta.type.synop] (20.15.2). (US 10)</p>
<p>Proposed change: Reword the paragraph as follows:</p>
<blockquote><p>Unless otherwise specified, a program that adds specializations for <tt>is_execution_policy</tt> is ill-formed; 
no diagnostic required.</p></blockquote>

See also LWG <a href="2871">2871</a>.

<p><i>[2017-03-03, Kona Friday AM]</i></p>

<p>Jonathan: This breaks all known implementations of parallel algorithms, since they use custom execution policies.</p>
<p>Alisdair to check with SG1 to see if that's what they meant.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>NAD; what the standard says is that this is "undefined", not "unspecified".</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2910" href="2910">2910.</a> Template deduction and <tt>integral_constant</tt></h3>
<p><b>Section:</b> 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in [meta.type.synop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in [meta.type.synop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 142</b>

<p>An alias template using the new template template auto deduction would make <tt>integral_constant</tt> slightly easier to use.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Duplicate of <a href="2922">2922</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Add to the synopsis of <tt>&lt;type_traits&gt;</tt>:</p>
<blockquote><pre>
<ins>template &lt;auto N&gt;
using integer_constant = integral_constant&lt;decltype(N), N&gt;;</ins>
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="2916" href="2916">2916.</a> Insert iterators should each have an instantiation guide to initialize from a container</h3>
<p><b>Section:</b> 25.5.2 <a href="https://timsong-cpp.github.io/cppwp/insert.iterators">[insert.iterators]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 151</b>

<p>The three insert iterators should each have an instantiation guide to initialize from a container.</p>
<p>Proposed change:</p>
<p>
Add to the <tt>&lt;iterator&gt;</tt> header synopsis:
</p>
<blockquote><pre>
template &lt;class Container&gt;
back_insert_iterator(Container&amp;) -&gt; back_insert_iterator&lt;Container&gt;;
template &lt;class Container&gt;
front_insert_iterator(Container&amp;) -&gt; back_insert_iterator&lt;Container&gt;;
template &lt;class Container&gt;
insert_iterator(Container&amp;, typename Container::iterator) -&gt; insert_iterator&lt;Container&gt;;
</pre></blockquote>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>After the core changes in Kona, these guides are no longer necessary; the implicit ones are sufficient.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4618">N4618</a>.</p>
<ol>
<li><p>Add to the synopsis of <tt>&lt;iterator&gt;</tt>:</p>
<blockquote><pre><ins>
template &lt;class Container&gt; back_insert_iterator(Container&amp;) -&gt; back_insert_iterator&lt;Container&gt;;
template &lt;class Container&gt; front_insert_iterator(Container&amp;) -&gt; back_insert_iterator&lt;Container&gt;;
template &lt;class Container&gt; insert_iterator(Container&amp;, typename Container::iterator) -&gt; insert_iterator&lt;Container&gt;;
</ins></pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2930" href="2930">2930.</a> Are implementations allowed to split non-member functions into several overloads?</h3>
<p><b>Section:</b> 16.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Morwenn <b>Opened:</b> 2017-02-04 <b>Last modified:</b> 2017-03-14 03:14:09 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#global.functions">issues</a> in [global.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> makes it clear that standard library implementers are allowed to "replace a 
member function with default arguments with two or more member functions with equivalent behavior". However, it is 
unclear when reading 16.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> whether implementers are allowed to perform the same transformation 
for non-member functions. 16.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> p3 mentions that "an implementation shall not declare a 
non-member function signature with additional default arguments", but does not explicitly forbid to replace a function 
with default arguments with more functions with equivalent behavior.
<p/>
The standard should make it clear whether such a transformation is conforming or not, probably through a note 
[global.functions].
<p/>
Link to the <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/nOtuY0aXReE">Standard Discussion forum</a>.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>We believe that [member.functions]p2 is clear.</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3><a name="2967" href="2967">2967.</a> <tt>std::equal</tt> on empty ranges</h3>
<p><b>Section:</b> 27.6.13 <a href="https://timsong-cpp.github.io/cppwp/alg.equal">[alg.equal]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2017-05-26 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.equal">issues</a> in [alg.equal].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The description of the <tt>std::equal()</tt> algorithm in the standard doesn't
make clear what the result of it is on empty ranges:
</p>
<blockquote><pre>
std::equal(first, first, second) ; // what does this return?
</pre></blockquote>
<p>
It should IMHO return true (two empty ranges are always equal).
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Closing as NAD; the existing wording covers empty sequences</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.</p>

<ol>
<li>
<p>Edit 27.6.13 <a href="https://timsong-cpp.github.io/cppwp/alg.equal">[alg.equal]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The current wording presented below uses two times the unusual phrase "[&hellip;] return [&hellip;]" 
instead of "[&hellip;] return<b>s</b> [&hellip;]". The project editor is kindly asked to consider to replace these unusual 
wording forms by the usual one. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class InputIterator1, class InputIterator2&gt;
  bool equal(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2);
[&hellip;]
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> If <tt>last2</tt> was not given in the argument list, it denotes <tt>first2 + (last1 - first1)</tt> below.
<p/>
-2- <i>Returns:</i> <ins>If <tt>[first1, last1)</tt> and <tt>[first2, last2)</tt> are both empty, returns <tt>true</tt>.</ins> If 
<tt>last1 - first1 != last2 - first2</tt>, return <tt>false</tt>. Otherwise return <tt>true</tt> if for every iterator 
<tt>i</tt> in the range <tt>[first1, last1)</tt> the following corresponding conditions hold: 
<tt>*i == *(first2 + (i - first1)), pred(*i, *(first2 + (i - first1))) != false</tt>. Otherwise, returns <tt>false</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2971" href="2971">2971.</a> <tt>variant</tt> should require <tt>Destructible</tt> types</h3>
<p><b>Section:</b> 22.6.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2017-05-31 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.variant">issues</a> in [variant.variant].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The state of a <tt>variant</tt> is not specified if an exception is thrown during
the destruction of the active alternative. Exceptions should not be
allowed to escape during destruction of an object used as a <tt>variant</tt>
alternative. Otherwise, it should be specified that the <tt>variant</tt> object
might not hold a value.
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>NAD; [res.on.functions]/2 already gives us this guarantee.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.</p>

<ol>
<li>
<p>Edit 22.6.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> as indicated:</p>

<blockquote>
<p>
-2- All types in <tt>Types...</tt> shall be (possibly cv-qualified) object types that are not arrays<ins>, and 
shall satisfy the requirements of <tt>Destructible</tt> (Table 27)</ins>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2992" href="2992">2992.</a> <tt>system_category()</tt> and <tt>error_code::error_code()</tt> should be <tt>constexpr</tt></h3>
<p><b>Section:</b> 19.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.objects">[syserr.errcat.objects]</a>, 19.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.constructors">[syserr.errcode.constructors]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2017-06-27 <b>Last modified:</b> 2017-07-12 01:58:24 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#syserr.errcat.objects">issues</a> in [syserr.errcat.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The default constructor of <tt>error_code</tt> should be <tt>constexpr</tt> to enable constant initialization; 
as a practical matter, there are reports that it regularly shows up in profiles because clearing error codes 
is so frequent.
<p/>
Suggested resolution:
</p>
<ul>
<li><p>add <tt>constexpr</tt> to the declaration of <tt>system_category()</tt> in [syserr.errcat.overview] 
and [syserr.errcat.objects];</p></li>
<li><p>optionally, add <tt>constexpr</tt> to the declaration of <tt>generic_category()</tt> in the same two sections;</p></li>
<li><p>add <tt>constexpr</tt> to the default constructor of <tt>error_code</tt> in [syserr.errcode.overview] and [syserr.errcode.constructors];</p></li>
<li><p>optionally, add <tt>constexpr</tt> to the <tt>error_code(int val, const error_category&amp; cat)</tt> 
constructor in the same two sections;</p></li>
<li><p>optionally, add <tt>constexpr</tt> to <tt>error_code::assign</tt>;</p></li>
<li><p>optionally, add <tt>constexpr</tt> to <tt>error_code::clear</tt>;</p></li>
<li><p>optionally, add <tt>constexpr</tt> to <tt>error_code::value</tt>;</p></li>
<li><p>optionally, add <tt>constexpr</tt> to <tt>error_code::category</tt>.</p></li>
</ul>
<p>
There was an objection that <tt>system_category()</tt> can't be made <tt>constexpr</tt> because it needs to 
"immortalize" the object so that it's not destroyed at process shutdown or module unload, in order for 
the <tt>error_code</tt> facility to remain usable. However, the <a href="https://wandbox.org/permlink/pwliJ6sw6I4LBtlE">following 
proof of concept</a> shows how to achieve this and still make the function <tt>constexpr</tt>:
</p>
<blockquote><pre>
#include &lt;new&gt;

template&lt;class _Ty&gt;
  union _Immortalizer
  { // constructs _Ty, never destroys
  constexpr _Immortalizer(): __ty()
  {
  }

  ~_Immortalizer() noexcept {}
  _Immortalizer(const _Immortalizer&amp;) = delete;
  _Immortalizer&amp; operator=(const _Immortalizer&amp;) = delete;

  _Ty __ty;
};

struct error_category
{
  virtual ~error_category() = default;
};

struct system_category_impl : public error_category
{
};

[[clang::require_constant_initialization]] static const _Immortalizer&lt;system_category_impl&gt; _System_category;

constexpr error_category const&amp; system_category() noexcept
{
  return _System_category.__ty;
}

struct error_code
{
  int val_;
  const error_category* cat_;

  constexpr error_code() noexcept : val_(0), cat_(&amp;system_category()) {}

  constexpr int value() const noexcept { return val_; }
  constexpr error_category const&amp; category() const noexcept { return *cat_; }
};

constexpr error_code s_code;

static_assert(s_code.value() == 0);
static_assert(&amp;s_code.category() == &amp;system_category());
</pre></blockquote>

<p><i>[2017-07 Toronto Tuesday PM issue prioritization]</i></p>

<p>NAD; This is a feature request; needs a paper.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 19.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.overview">[syserr.errcat.overview]</a>, class <tt>error_category</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class error_category {
public:
  constexpr error_category() noexcept;
  virtual ~error_category();
  error_category(const error_category&amp;) = delete;
  error_category&amp; operator=(const error_category&amp;) = delete;
  virtual const char* name() const noexcept = 0;
  virtual error_condition default_error_condition(int ev) const noexcept;
  virtual bool equivalent(int code, const error_condition&amp; condition) const noexcept;
  virtual bool equivalent(const error_code&amp; code, int condition) const noexcept;
  virtual string message(int ev) const = 0;

  bool operator==(const error_category&amp; rhs) const noexcept;
  bool operator!=(const error_category&amp; rhs) const noexcept;
  bool operator&lt;(const error_category&amp; rhs) const noexcept;
};

<ins>constexpr</ins> const error_category&amp; generic_category() noexcept;
<ins>constexpr</ins> const error_category&amp; system_category() noexcept;
</pre>
</blockquote>
</li>

<li><p>Edit 19.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.objects">[syserr.errcat.objects]</a> as indicated:</p>

<blockquote>
<pre>
<ins>constexpr</ins> const error_category&amp; generic_category() noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
<ins>constexpr</ins> const error_category&amp; system_category() noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 19.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.overview">[syserr.errcode.overview]</a>, class <tt>error_code</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class error_code {
public:
  // 19.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.constructors">[syserr.errcode.constructors]</a>, constructors
  <ins>constexpr</ins> error_code() noexcept;
  <ins>constexpr</ins> error_code(int val, const error_category&amp; cat) noexcept;
  template &lt;class ErrorCodeEnum&gt;
  error_code(ErrorCodeEnum e) noexcept;
  
  // 19.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.modifiers">[syserr.errcode.modifiers]</a>, modifiers
  <ins>constexpr</ins> void assign(int val, const error_category&amp; cat) noexcept;
  template &lt;class ErrorCodeEnum&gt;
  error_code&amp; operator=(ErrorCodeEnum e) noexcept;
  <ins>constexpr</ins> void clear() noexcept;
  
  // 19.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.observers">[syserr.errcode.observers]</a>, observers
  <ins>constexpr</ins> int value() const noexcept;
  <ins>constexpr</ins> const error_category&amp; category() const noexcept;
  error_condition default_error_condition() const noexcept;
  string message() const;
  explicit operator bool() const noexcept;
  
private:
  int val_; // exposition only
  const error_category* cat_; // exposition only
};</pre>
</blockquote>
</li>

<li><p>Edit 19.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.constructors">[syserr.errcode.constructors]</a> as indicated:</p>

<blockquote>
<pre>
<ins>constexpr</ins> error_code() noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
<ins>constexpr</ins> error_code(int val, const error_category&amp; cat) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 19.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.modifiers">[syserr.errcode.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
<ins>constexpr</ins> void assign(int val, const error_category&amp; cat) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
<ins>constexpr</ins> void clear() noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 19.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.observers">[syserr.errcode.observers]</a> as indicated:</p>

<blockquote>
<pre>
<ins>constexpr</ins> int value() const noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
<ins>constexpr</ins> const error_category&amp; category() const noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3016" href="3016">3016.</a> <tt>optional</tt> and over-aligned types</h3>
<p><b>Section:</b> 22.5.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-09-04 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.optional">issues</a> in [optional.optional].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG issue <a href="2555">2555</a> added "It is implementation-defined whether over-aligned types are supported (C++14 &sect;3.11)."
to the specification of <tt>std::experimental::optional</tt> in LFTS, however that issue wasn't moved until <tt>optional</tt> had 
already been merged to the IS working paper, so it isn't present in the specification of <tt>std::optional</tt>. Should the 
same rule be added for <tt>std::optional</tt> as well?
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 3; Casey to provide rationale for closing as NAD.</p>

<p>2018-11 Closed as NAD with the adoption of <a href="https://wg21.link/P0899R1">P0899R1</a></p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Edit 22.5.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> p1 as indicated:</p>
<blockquote>
<p>
[&hellip;] The contained value shall be allocated in a region of the <tt>optional&lt;T&gt;</tt> storage suitably aligned 
for the type <tt>T</tt>. <ins>It is implementation-defined whether over-aligned types are supported 
(6.7.6 <a href="https://timsong-cpp.github.io/cppwp/basic.align">[basic.align]</a>).</ins> When an object of type <tt>optional&lt;T&gt;</tt> is contextually converted to 
<tt>bool</tt>, the conversion returns <tt>true</tt> if the object contains a value; otherwise the conversion returns 
<tt>false</tt>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3033" href="3033">3033.</a> <tt>basic_string</tt> move ctor is underspecified</h3>
<p><b>Section:</b> 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2017-11-09 <b>Last modified:</b> 2017-11-29 03:09:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard has a hole in the specification of <tt>basic_string</tt>'s move constructor that seems not only be editorial.
In 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> p2:
</p>
<blockquote><pre>
basic_string(const basic_string&amp; str);
basic_string(basic_string&amp;&amp; str) noexcept;
</pre><blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>basic_string</tt> as indicated in Table 56. In the second form, 
<tt>str</tt> is left in a valid state with an unspecified value.
</p>
</blockquote>
</blockquote>
<p>
refers to Table 56, but that table only speaks about copy-ctor. According to Pablo, move and copy differ in what they do.
Move ctor of <tt>basic_string</tt> needs separate table (entry) to describe what happens.
</p>
<p><i>[28-Nov-2017 After discussion on the ML, closing as NAD Editorial]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3068" href="3068">3068.</a> Forbid assigning an rvalue <tt>basic_string</tt> to <tt>basic_string_view</tt></h3>
<p><b>Section:</b> 23.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Antony Polukhin <b>Opened:</b> 2018-02-19 <b>Last modified:</b> 2022-08-24 18:54:27 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view.template">issues</a> in [string.view.template].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is known that we cannot disable move construction of
<tt>basic_string_view</tt> from rvalues of <tt>basic_string</tt>, because it breaks a
valid use case:
</p>
<blockquote><pre>
string foo();
void bar(string_view );
bar(foo());
</pre></blockquote>
<p>
Though it is still possible to disable an absolutely wrong case of
assigning an rvalue <tt>basic_string</tt> to <tt>basic_string_view</tt>:
</p>
<blockquote><pre>
string_view sw = "Hello";
sw = foo();
</pre></blockquote>
<p>
Some tests that make sure that other use cases are not affected are available 
<a href="https://raw.githubusercontent.com/apolukhin/apolukhin.github.io/master/papers/misc/safer_string_view_tests.cpp">here</a>
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 2; status to LEWG</p>

<p><i>[2020-05-28; LEWG issue reviewing]</i></p>

<p>
LEWG issue processing voted to reject 3068 as NAD. Status change to Open.
</p>
<blockquote>
<pre>
SF F N A SA
15 5 1 0 0
</pre>
</blockquote>

<p><i>[2022-08-24 Status changed: Open &rarr; NAD.]</i></p>

<p>
LWG telecon: close based on LEWG direction.
"This makes string_view depend on basic_string."
"Request a paper with implementation if someone really wants this."
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li><p>Change 23.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a>, class template <tt>basic_string_view</tt> synopsis, 
as indicated:</p>
<blockquote>
<pre>
[&hellip;]
<i>// 23.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.cons">[string.view.cons]</a>, construction and assignment</i>
constexpr basic_string_view() noexcept;
constexpr basic_string_view(const basic_string_view&amp;) noexcept = default;
constexpr basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;
<ins>template &lt;class A&gt;
basic_string_view&amp; operator=(const basic_string&lt;charT, traits, A&gt;&amp;&amp;) = delete;</ins>
constexpr basic_string_view(const charT* str);
constexpr basic_string_view(const charT* str, size_type len);
[&hellip;]
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3106" href="3106">3106.</a> <tt>nothrow</tt> should be <tt>inline constexpr</tt> rather that <tt>extern const</tt></h3>
<p><b>Section:</b> 17.7.2 <a href="https://timsong-cpp.github.io/cppwp/new.syn">[new.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Antony Polukhin <b>Opened:</b> 2018-04-25 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::nothrow</tt> in [new.syn] is declared as '<tt>extern const nothrow_t nothrow;</tt>'. Unfortunately 
this declaration requires linking with Standard Library (which does not work well on GCC with <tt>-nostdlib</tt> flag).
Moreover the declaration differs from other Standard Library tags that are '<tt>inline constexpr</tt>'.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 2</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Tentatively NAD - if we had a status 'Wont Fix' that would be correct.</p>
<p>This is an ABI break for most implementations, and people can define their 
own variable of type <tt>std::nothrow_t</tt> if they want a constexpr one.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4741">N4741</a>.
</p>

<ol>
<li>
<p>Edit 17.7.2 <a href="https://timsong-cpp.github.io/cppwp/new.syn">[new.syn]</a> as indicated:</p>
<blockquote>
<pre>
struct nothrow_t { explicit nothrow_t() = default; };
<del>extern const</del><ins>inline constexpr</ins> nothrow_t nothrow;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3138" href="3138">3138.</a> There is no such thing as <i>assertion-level</i></h3>
<p><b>Section:</b> 99 [support.contract.cviol] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-07-10 <b>Last modified:</b> 2019-08-05 16:05:14 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.contract.cviol">issues</a> in [support.contract.cviol].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>contract_violation</tt> has an <tt>assertion_level</tt> member 
function that is specified to return text "describing the <i>assertion-level</i>
of the violated contract". There is, however, no <i>assertion-level</i> in
 [dcl.attr.contract], only <i>contract-level</i>.
<p/>
By itself, this can probably be handled editorially as a typo, but we may want to 
reconsider the name of the function, which currently mirrors the (incorrect) name 
of the nonterminal.
</p>

<p><i>[2018-11 Reflector prioritization]</i></p>

<p>Set Priority to 2</p>

<p><i>[Post Cologne Mailing]</i></p>

<p>Contracts were removed from the C++20 draft in Cologne; closing as NAD.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3139" href="3139">3139.</a> <tt>contract_violation</tt>'s special member functions</h3>
<p><b>Section:</b> 99 [support.contract.cviol] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2018-07-10 <b>Last modified:</b> 2019-08-05 16:05:14 UTC</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.contract.cviol">issues</a> in [support.contract.cviol].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>contract_violation</tt> is currently defined as:
</p>
<blockquote>
<pre>
class contract_violation {
public:
  uint_least32_t line_number() const noexcept;
  string_view file_name() const noexcept;
  string_view function_name() const noexcept;
  string_view comment() const noexcept;
  string_view assertion_level() const noexcept;
};
</pre>
</blockquote>
<p>
which implies a full set of defaulted special member functions with entirely 
unclear semantics, and can arguably be read to imply that it is an aggregate.
<p/>
It seems unlikely that we meant for users to default construct or copy
<tt>contract_violation</tt> objects, but if we did want to do that, we need to 
at least specify the behavior of a default constructed <tt>contract_violation</tt>
object and how copying and moving work with respect to the lifetime of the 
strings referenced by the <tt>string_view</tt>s returned by its member functions.
</p>

<p><i>[2018-11 Reflector prioritization]</i></p>

<p>Set Priority to 1</p>

<p><i>[2019 Cologne Wednesday night]</i></p>

<p><tt>= delete</tt> for copy/move assignment; Status to 'Open'; Daniel to provide wording</p>

<p><i>[Post Cologne Mailing]</i></p>

<p>Contracts were removed from the C++20 draft in Cologne; closing as NAD.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3163" href="3163">3163.</a> [networking.ts] Buffer sequence iterator equivalency</h3>
<p><b>Section:</b> 16.2 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts">[networking.ts::buffer.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Vinnie Falco <b>Opened:</b> 2018-10-07 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#networking.ts::buffer.reqmts">issues</a> in [networking.ts::buffer.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses: networking.ts</b>
<p>
Buffer sequence iterators in [networking.ts] differ from the current
standard iterator requirements in that the value returned upon
dereferencing is not required to be a reference type. This change is
vital for allowing authors to create useful, lazily-evaluated views
which meet the requirements of buffer sequences. Unfortunately the
updated language is incompatible with the standard iterator requirements
for equality testing, because the addresses of value types returned by
buffer sequence iterators may not be stable. The change proposed in
this defect report defines a new metric for buffer sequence iterator
equality.
</p>

<p>11-2018 Status to NAD after discussion on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the <a href="https://wg21.link/n4734">N4734</a>.</p>

<ol>
<li>
<p>Modify 16.2.1 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.mutablebuffersequence">[networking.ts::buffer.reqmts.mutablebuffersequence]</a>, Table 12 
"MutableBufferSequence requirements", as indicated:</p>
<blockquote>

<table border="1">
<caption>Table 12 &mdash; MutableBufferSequence requirements</caption>
<tr style="text-align:center">
<th>expression</th>
<th>return type</th>
<th>assertion/note<br/>pre/post-condition</th>
</tr>
<tr>
<td>
<tt>net::buffer_sequence_begin(x)<br/>
net::buffer_sequence_end(x)</tt>
</td>
<td>
An iterator type whose <tt>reference</tt> type<br/> 
is convertible to <tt>mutable_buffer</tt> and which<br/> 
satisfies all the requirements for bidirectional<br/> 
iterators (C++ 2014 [bidirectional.iterators]) except that:<br/>
<ol style="list-style-type:lower-alpha">
<li>there is no requirement that <tt>operator-&gt;</tt> is provided, and</li>
<li>there is no requirement that <tt>reference</tt><br/> 
 be a reference type<del>.</del><ins>, and</ins></li>
<li><ins>for iterators <tt>a</tt> and <tt>b</tt><br/> 
there is no requirement that <tt>a == b</tt> if and<br/> 
only if <tt>*a</tt> and <tt>*b</tt> are bound to the<br/>
same object, and</ins></li>
<li><ins>
  <tt>a == b</tt> if and only if<br/>
  <tt>distance(buffer_sequence_begin(x), a) == distance(buffer_sequence_begin(x), b)</tt>
</ins></li>
</ol>
</td>
<td>
[&hellip;]
</td>
</tr>
</table>

</blockquote>
</li>

<li>
<p>Modify 16.2.2 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.constbuffersequence">[networking.ts::buffer.reqmts.constbuffersequence]</a>, Table 13
"ConstBufferSequence requirements", as indicated:</p>
<blockquote>

<table border="1">
<caption>Table 13 &mdash; ConstBufferSequence requirements</caption>
<tr style="text-align:center">
<th>expression</th>
<th>return type</th>
<th>assertion/note<br/>pre/post-condition</th>
</tr>
<tr>
<td>
<tt>net::buffer_sequence_begin(x)<br/>
net::buffer_sequence_end(x)</tt>
</td>
<td>
An iterator type whose <tt>reference</tt> type is convertible to<br/>
<tt>const_buffer</tt> and which satisfies all the requirements for<br/>
bidirectional iterators (C++ 2014 [bidirectional.iterators]) except that:<br/>
<ol style="list-style-type:lower-alpha">
<li>there is no requirement that <tt>operator-&gt;</tt> is provided, and</li>
<li>there is no requirement that <tt>reference</tt> be a reference<br/>
  type<del>.</del><ins>, and</ins></li>
<li><ins>for iterators <tt>a</tt> and <tt>b</tt> there is no<br/> 
  requirement that <tt>a == b</tt> if and only if <tt>*a</tt> and<br/> 
  <tt>*b</tt> are bound to the same object, and</ins></li>
<li><ins>
  <tt>a == b</tt> if and only if<br/>
  <tt>distance(buffer_sequence_begin(x), a) == distance(buffer_sequence_begin(x), b)</tt>
</ins></li>
</ol>

</td>
<td>
[&hellip;]
</td>
</tr>
</table>

</blockquote>
</li>
</ol>





<hr>
<h3><a name="3164" href="3164">3164.</a> Unhelpful "shall not participate" constraints for <tt>unique_ptr</tt> with reference deleter</h3>
<p><b>Section:</b> 20.3.1.3.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-10-09 <b>Last modified:</b> 2018-11-27 04:34:19 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.ctor">issues</a> in [unique.ptr.single.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[unique.ptr.single.ctor] defines these constructors:
</p>
<blockquote><pre>
unique_ptr(pointer p, const D&amp; d) noexcept;
unique_ptr(pointer p, remove_reference_t&lt;D&gt;&amp;&amp; d) noexcept;
</pre></blockquote>
<p>
and p13 says:
</p>
<blockquote>
<p>
<i>Remarks:</i> If <tt>D</tt> is a reference type, the second constructor is defined
as deleted. These constructors shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;D, decltype(d)&gt;</tt> is true.
</p>
</blockquote>
<p>
The first sentence in the <i>Remarks</i> has no effect. If <tt>D</tt> is a reference
type <tt>A&amp;</tt>, then for the second constructor the condition is
<tt>is_constructible&lt;A&amp;, A&amp;&amp;&gt;</tt> which is <tt>false</tt>. So the 
second constructor never participates in overload resolution for reference deleters, and
so it's irrelevant whether it's deleted or not.
<p/>
We should either strike that sentence, or adjust the <tt>is_constructible</tt>
constraint so that the deleted constructor participates in overload
resolution for deleters of reference type. That way trying to
initialize a deleter of reference type from an rvalue will resolve to
the deleted function as intended.
<p/>
I think we can just change the "shall not participate" condition to only apply to 
non-reference deleters. For reference deleters the condition is always true for the 
first constructor, because <tt>is_constructible&lt;A&amp;, A&amp;&gt;</tt> is 
<tt>true</tt>, and always <tt>false</tt> for the second constructor (but we want 
it to be true so the deleted constructor is used). So for both constructors, the 
"shall not participate" isn't useful when <tt>D</tt> is a reference type.
</p>

<p>11-2018 Status to NAD after discussion on the reflector.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4778">N4778</a>.</p>

<ol>
<li><p>Change 20.3.1.3.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a> as indicated:</p>
<blockquote><pre>
unique_ptr(pointer p, const D&amp; d) noexcept;
unique_ptr(pointer p, remove_reference_t&lt;D&gt;&amp;&amp; d) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-11- <i>Remarks:</i> If <tt>D</tt> is a reference type, the second constructor is defined as deleted. 
<ins>If <tt>D</tt> is not a reference type, t</ins><del>T</del>hese constructors shall not participate 
in overload resolution unless <tt>is_constructible_v&lt;D, decltype(d)&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="3165" href="3165">3165.</a> All <tt>starts_with()</tt> overloads should be called "<tt>begins_with</tt>"</h3>
<p><b>Section:</b> 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, 23.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2018-10-22 <b>Last modified:</b> 2020-08-21 20:26:35 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Throughout the standard library, the opposite of the verb "to end" is "to begin", not to "to start". In this 
respect, all the overloads of <tt>std::basic_string::starts_with</tt> and <tt>std::basic_string_view::starts_with</tt> 
are named inconsistently. These calls were added in <a href="https://wg21.link/p0457r2">P0457R2</a>, which refers 
to analogous functions in Java, Python, Qt, LLVM, WebKit, all of which use the term "start". But, in our opinion, 
the C++ standard library should first be consistent with itself. 
</p>

<p><i>[2018-11: Referred to LEWG after reflector discussion.]</i></p>


<p><i>[2020-05-28; LEWG issue reviewing]</i></p>

<p>
LEWG issue processing voted to reject 3165 as NAD. Status change to Open.
</p>
<blockquote>
<pre>
Reject LWG3165 as NAD

SF F N A SA
21 1 0 1  0
</pre>
</blockquote>

<p><i>[2020-08-21; Issue processing telecon: moved to NAD based on LEWG recommendation]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4778">N4778</a>.</p>

<ol>
<li><p>Change 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, class template <tt>basic_string</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
bool <ins>begin</ins><del>start</del>s_with(basic_string_view&lt;charT, traits&gt; x) const noexcept;
bool <ins>begin</ins><del>start</del>s_with(charT x) const noexcept;
bool <ins>begin</ins><del>start</del>s_with(const charT* x) const;
</pre>
</blockquote>
</li>

<li><p>Change 23.4.3.8.5 <a href="https://timsong-cpp.github.io/cppwp/string.starts.with">[string.starts.with]</a> as indicated</p>
<blockquote>
<pre>
bool <ins>begin</ins><del>start</del>s_with(basic_string_view&lt;charT, traits&gt; x) const noexcept;
bool <ins>begin</ins><del>start</del>s_with(charT x) const noexcept;
bool <ins>begin</ins><del>start</del>s_with(const charT* x) const;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to:
</p>
<pre>
return basic_string_view&lt;charT, traits&gt;(data(), size()).<ins>begin</ins><del>start</del>s_with(x);
</pre>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a>, class template <tt>basic_string_view</tt> synopsis, as indicated:</p>
<blockquote>
<pre>
constexpr bool <ins>begin</ins><del>start</del>s_with(basic_string_view x) const noexcept;
constexpr bool <ins>begin</ins><del>start</del>s_with(charT x) const noexcept;
constexpr bool <ins>begin</ins><del>start</del>s_with(const charT* x) const;
</pre>
</blockquote>
</li>

<li><p>Change 23.3.3.8 <a href="https://timsong-cpp.github.io/cppwp/string.view.ops">[string.view.ops]</a> as indicated:</p>
<blockquote>
<pre>
constexpr bool <ins>begin</ins><del>start</del>s_with(basic_string_view x) const noexcept;
</pre>
<blockquote>
<p>
-20- <i>Effects:</i> Equivalent to: <tt>return compare(0, npos, x) == 0;</tt>
</p>
</blockquote>
<pre>
constexpr bool <ins>begin</ins><del>start</del>s_with(charT x) const noexcept;
</pre>
<blockquote>
<p>
-21- <i>Effects:</i> Equivalent to: <tt>return <ins>begin</ins><del>start</del>s_with(basic_string_view(&amp;x, 1));</tt>
</p>
</blockquote>
<pre>
constexpr bool <ins>begin</ins><del>start</del>s_with(const charT* x) const;
</pre>
<blockquote>
<p>
-22- <i>Effects:</i> Equivalent to: <tt>return <ins>begin</ins><del>start</del>s_with(basic_string_view(x));</tt>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="3181" href="3181">3181.</a> <tt>split_view::outer_iterator</tt> converting constructor is misconstrained</h3>
<p><b>Section:</b> 99 [range.split.outer] <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2019-01-05 <b>Last modified:</b> 2019-01-20 16:20:00 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.split.outer">issues</a> in [range.split.outer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The constraints on <tt>split_view::outer_iterator</tt>'s converting constructor:
<blockquote>
<pre>
constexpr outer_iterator(outer_iterator&lt;!Const&gt; i)
  requires Const &amp;&amp; ConvertibleTo&lt;iterator_t&lt;V&gt;, iterator_t&lt;const V&gt;&gt;;
</pre>
</blockquote>
are problematic. Since <tt>const V</tt> doesn't depend on a template parameter
of <tt>outer_iterator</tt>, compilers want to expand
<tt>iterator_t&lt;const V&gt;</tt> when <tt>outer_iterator</tt> is instantiated
- regardless of the value of <tt>Const</tt> - which can result in a hard error
when <tt>iterator_t&lt;const V&gt;</tt> is ill-formed. The constraint should
instead use <tt>iterator_t&lt;Base&gt;</tt>, as do the similar converting
constructors for the other range adaptor iterator and sentinel types.
</p>

<p><i>[2019-01-20 Reflector prioritization]</i></p>

<p>Set status to NAD</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<ol>
<li><p>Change 99 [range.split.outer] as follows:</p>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;class V, class Pattern&gt;
  template&lt;bool Const&gt;
  struct split_view&lt;V, Pattern&gt;::outer_iterator {
    [&hellip;]
    constexpr outer_iterator(outer_iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; ConvertibleTo&lt;iterator_t&lt;V&gt;, iterator_t&lt;<del>const V</del><ins>Base</ins>&gt;&gt;;
    [&hellip;]
  };
}
</pre>
<p>
[&hellip;]
</p>
<pre>
constexpr outer_iterator(outer_iterator&lt;!Const&gt; i)
  requires Const &amp;&amp; ConvertibleTo&lt;iterator_t&lt;V&gt;, iterator_t&lt;<del>const V</del><ins>Base</ins>&gt;&gt;;
</pre>
<p>
-4- <i>Effects:</i> Initializes <tt>parent_</tt> with <tt>i.parent_</tt> and
<tt>current_</tt> with <tt>std::move(i.current_)</tt>.
</p><p>
[&hellip;]
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3207" href="3207">3207.</a> <tt>N</tt> in <tt>ssize(const T (&amp;)[N])</tt> should be <tt>size_t</tt></h3>
<p><b>Section:</b> 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2019-05-23 <b>Last modified:</b> 2020-11-09 20:22:58 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>N</tt> in <tt>ssize(const T (&amp;)[N])</tt> is specified to be of type <tt>ptrdiff_t</tt>.  
It should be <tt>size_t</tt> to be consistent with the rest of the standard library, such as the
array overloads for all other range access functions, the <tt>swap</tt> overload for arrays, and
other function template overloads for arrays. (Note: the return type of this function should still 
be <tt>ptrdiff_t</tt>.)
</p>

<p><i>[2019-06-12 Tentatively NAD after reflector discussion]</i></p>

<p><i>[2020-11-09 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 25.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, <del>ptrdiff</del><ins>size</ins>_t N&gt; constexpr ptrdiff_t ssize(const T (&amp;array)[N]) noexcept;
</pre>
<blockquote>
<p>
-19- <i>Returns:</i> <tt><ins>static_cast&lt;ptrdiff_t&gt;(</ins>N<ins>)</ins></tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3271" href="3271">3271.</a> Parsing functions should save and restore stream format state</h3>
<p><b>Section:</b> 29.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2019-09-02 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.parse">issues</a> in [time.parse].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>from_stream</tt> overloads may need to set various formatting state and flags of the <tt>basic_istream</tt> 
to implement the parsing functionality. Such settings must not persist beyond the parsing functions. Thus 
these functions need to save and restore any settings on the <tt>basic_istream</tt> they may need to change.
</p>

<p><i>[2019-10 Priority set to 3 after reflector discussion]</i></p>


<p><i>[2020-02, Prague; Close as NAD]</i></p>


LWG reviewed the issue and decided no change is needed.
Unless specified to change the flags, it's assumed that the stream flags are
unchanged by any input function.


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The modification of 29.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> p1 is intended to be non-conflictingly 
mergeable with the change suggested by LWG <a href="3269">3269</a> at the same paragraph.]
</p>
</blockquote>

<ol>
<li><p>Modify 29.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> as indicated:</p>

<blockquote>
<p> 
-1- Each parse overload specified in this subclause calls <tt>from_stream</tt> unqualified, 
so as to enable argument dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>).
<ins>In the following paragraphs, let <tt>is</tt> denote an object of type 
<tt>basic_istream&lt;charT, traits&gt;</tt>, where <tt>charT</tt> and
<tt>traits</tt> are template parameters in that context.</ins>
<p/>
[&hellip;]
<p/>
-10- All <tt>from_stream</tt> overloads behave as unformatted input functions, except that they have an 
unspecified effect on the value returned by subsequent calls to <tt>basic_istream&lt;&gt;::gcount()</tt>.
<ins>Any changes made to <tt>is.fill()</tt>, <tt>is.width()</tt> or <tt>is.flags()</tt> are undone 
prior to an returning or exceptional execution ([thread.once.callonce]).</ins> 
Each overload takes a format string containing ordinary characters and flags which have special meaning. 
Each flag begins with a <tt>%</tt>. Some flags can be modified by <tt>E</tt> or <tt>O</tt>. During parsing 
each flag interprets characters as parts of date and time types according to Table [tab:time.parse.spec]. 
Some flags can be modified by a width parameter given as a positive decimal integer called out as 
<tt><i>N</i></tt> below which governs how many characters are parsed from the stream in interpreting the 
flag. All characters in the format string that are not represented in Table [tab:time.parse.spec], except 
for white space, are parsed unchanged from the stream. A white space character matches zero or more white
space characters in the input stream.
</p>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="3298" href="3298">3298.</a> Range adaptors introduced by P1035 do not require <tt>viewable_range</tt></h3>
<p><b>Section:</b> 26.7.11.2 <a href="https://timsong-cpp.github.io/cppwp/range.take.while.view">[range.take.while.view]</a>, 26.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a>, 26.7.13.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while.view">[range.drop.while.view]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Di Bella <b>Opened:</b> 2019-09-24 <b>Last modified:</b> 2020-09-06 13:52:31 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.take.while.view">issues</a> in [range.take.while.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After adoption of <a href="https://wg21.link/p1035">P1035</a> range adaptor closure is described 
to take a <tt>viewable_range</tt> as input, and return a view as output. The deduction-guides 
for <tt>take_while_view</tt>, <tt>drop_view</tt>, and <tt>drop_while_view</tt> do not currently 
impose the <tt>viewable_range</tt> requirement.
</p>

<p><i>[2020-02 Status to NAD on Thursday morning in Prague.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 26.7.11.2 <a href="https://timsong-cpp.github.io/cppwp/range.take.while.view">[range.take.while.view]</a>, class template <tt>take_while_view</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;<del>class</del><ins>input_range</ins> R, class Pred&gt;
    <ins>requires viewable_range&lt;R&gt; &amp;&amp; 
        indirect_unary_predicate&lt;const Pred, iterator_t&lt;R&gt;&gt;</ins>
      take_while_view(R&amp;&amp;, Pred) -&gt; take_while_view&lt;all_view&lt;R&gt;, Pred&gt;;
}
</pre>
</blockquote>
</li>

<li><p>Modify 26.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a>, class template <tt>drop_view</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;<del>class</del><ins>input_range</ins> R&gt;
    <ins>requires viewable_range&lt;R&gt;</ins>
      drop_view(R&amp;&amp;, range_difference_t&lt;R&gt;) -&gt; drop_view&lt;all_view&lt;R&gt;&gt;;
}
</pre>
</blockquote>
</li>

<li><p>Modify 26.7.13.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while.view">[range.drop.while.view]</a>, class template <tt>drop_while_view</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;<del>class</del><ins>input_range</ins> R, class Pred&gt;
    <ins>requires viewable_range&lt;R&gt; &amp;&amp; 
        indirect_unary_predicate&lt;const Pred, iterator_t&lt;R&gt;&gt;</ins>
      drop_while_view(R&amp;&amp;, Pred) -&gt; drop_while_view&lt;all_view&lt;R&gt;, Pred&gt;;
}
</pre>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3311" href="3311">3311.</a> <tt>basic_string::operator=(charT c)</tt> should be constrained</h3>
<p><b>Section:</b> 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Russia <b>Opened:</b> 2019-11-04 <b>Last modified:</b> 2019-11-16 12:41:07 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses RU 013</b></p>

<p>
Because of the implicit conversion of arithmetic types it is error prone to use the
<tt>basic_string::operator=(charT c)</tt>:
</p>
<blockquote><pre>
double d = 3.14;
std::string s;
s = d; // Compiles
</pre></blockquote>
<p>
Make sure that the program is ill-formed if an implicit conversion from arithmetic type happens while
assigning to <tt>std::basic_string</tt>. Or at least make sure that the program is ill-formed if an 
implicit conversion from floating point type happens while assigning to <tt>std::basic_string</tt>.
</p>

<p><i>[2019-11 Status to Duplicate during Tuesday morning issue processing in Belfast.]</i></p>

<p>Duplicate of <a href="2372">2372</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4835">N4835</a>.</p>

<ol>
<li><p>Modify 23.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a> p3, class template <tt>basic_string</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
constexpr basic_string&amp; operator=(<del>char</del>T c);
</pre>
</blockquote>
</li>

<li><p>Modify 23.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> as indicated:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
constexpr basic_string&amp; operator=(<del>char</del>T c);
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i> <tt>is_same_v&lt;T, charT&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-30- <i>Effects:</i> Equivalent to:
<blockquote><pre>
return *this = basic_string_view&lt;charT, traits&gt;(addressof(c), 1);
</pre></blockquote>
</p>
</blockquote>
</blockquote>

</li>
</ol>




<hr>
<h3><a name="3312" href="3312">3312.</a> <tt>polymorphic_allocator::allocate_object</tt> and <tt>new_object</tt> should be <tt>[[nodiscard]]</tt></h3>
<p><b>Section:</b> 20.4.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class">[mem.poly.allocator.class]</a> <b>Status:</b> <a href="lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2019-11-04 <b>Last modified:</b> 2019-11-16 12:41:07 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.poly.allocator.class">issues</a> in [mem.poly.allocator.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 217</b></p>

<p>
Add <tt>[[nodiscard]]</tt> in front of the return type for <tt>allocate_object</tt> and <tt>new_object</tt> in class
declaration and in member-function description for <tt>polymorphic_allocator</tt> template.
</p>

<p><i>[Daniel comments]</i></p>

<p>
This issue is related to LWG <a href="3304">3304</a>.
</p>

<p><i>[2019-11 Status to Duplicate during Tuesday morning issue processing in Belfast.]</i></p>

<p>Duplicate of <a href="3304">3304</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4835">N4835</a>.</p>

<ol>
<li><p>Modify 20.4.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class">[mem.poly.allocator.class]</a> p2, class template <tt>polymorphic_allocator</tt> synopsis, 
as indicated:</p>

<blockquote>
<pre>
<i>// 20.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a>, member functions</i>
[[nodiscard]] Tp* allocate(size_t n);
void deallocate(Tp* p, size_t n);

void* allocate_bytes(size_t nbytes, size_t alignment = alignof(max_align_t));
void deallocate_bytes(void* p, size_t nbytes, size_t alignment = alignof(max_align_t));
template&lt;class T&gt; <ins>[[nodiscard]]</ins> T* allocate_object(size_t n = 1);
template&lt;class T&gt; void deallocate_object(T* p, size_t n = 1);
template&lt;class T, class... CtorArgs&gt; <ins>[[nodiscard]]</ins> T* new_object(CtorArgs&amp;&amp;... ctor_args);
template&lt;class T&gt; void delete_object(T* p);
</pre>
</blockquote>
</li>

<li><p>Modify 20.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  <ins>[[nodiscard]]</ins> T* allocate_object(size_t n = 1);
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Allocates memory suitable for holding an array of <tt>n</tt> objects of type <tt>T</tt>, as follows:
<ol style="list-style-type: none">
<li><p>(8.1) &mdash; if <tt>SIZE_MAX / sizeof(T) &lt; n</tt>, throws <tt>length_error</tt>,</p></li>
<li><p>(8.2) &mdash; otherwise equivalent to:</p>
<blockquote><pre>
return static_cast&lt;T*&gt;(allocate_bytes(n*sizeof(T), alignof(T)));
</pre></blockquote>
</li>
</ol>
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class T, class CtorArgs...&gt;
  <ins>[[nodiscard]]</ins> T* new_object(CtorArgs&amp;&amp;... ctor_args);
</pre>
<blockquote>
<p>
-11- <i>Effects:</i> Allocates and constructs an object of type <tt>T</tt>, as follows.
Equivalent to:
<blockquote><pre>
T* p = allocate_object&lt;T&gt;();
try {
  construct(p, std::forward&lt;CtorArgs&gt;(ctor_args)...);
} catch (...) {
  deallocate_object(p);
  throw;
}
return p;
</pre></blockquote>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3333" href="3333">3333.</a> <tt>ranges::cbegin/ranges::cend</tt>, (and maybe <tt>ranges::crbegin/ranges::crend</tt>) are under-specified to allow rvalue-arrays</h3>
<p><b>Section:</b> 26.3.4 <a href="https://timsong-cpp.github.io/cppwp/range.access.cbegin">[range.access.cbegin]</a>, 26.3.5 <a href="https://timsong-cpp.github.io/cppwp/range.access.cend">[range.access.cend]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Di Bella <b>Opened:</b> 2019-11-06 <b>Last modified:</b> 2020-02-13 12:32:11 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following should be ill-formed, but is not, likely due to decay-to-pointer or reference collapsing.
</p>
<blockquote><pre>
double x[321];
ranges::cbegin(std::move(x)); <i>// should be ill-formed</i>
ranges::cend(std::move(x));   <i>// should be ill-formed</i>
</pre></blockquote>
<p>
This might be a problem for <tt>ranges::crbegin</tt> and <tt>ranges::crend</tt>, but I haven't implemented 
any of <tt>rbegin</tt>, <tt>rend</tt>, <tt>crbegin</tt>, and <tt>crend</tt> to confirm as much.
</p>
<p><i>[2020-02 Status to NAD on Thursday morning in Prague.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4835">N4835</a>.</p>

<ol>
<li><p>Change 26.3.4 <a href="https://timsong-cpp.github.io/cppwp/range.access.cbegin">[range.access.cbegin]</a> as indicated:</p>

<blockquote>
<p>
-1- The name <tt>ranges::cbegin</tt> denotes a customization point object (16.3.3.3.6 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a>). 
<ins>If t</ins><del>T</del>he expression <tt>ranges::<del>c</del>begin(E)</tt> for some subexpression 
<tt>E</tt> of type <tt>T</tt> <ins>is well-formed, then the expression <tt>ranges::cbegin(E)</tt></ins> 
is expression-equivalent to:
<ol style="list-style-type: none">
  <li><p>(1.1) &mdash; <tt>ranges::begin(static_cast&lt;const T&amp;&gt;(E))</tt> if <tt>E</tt> is an lvalue.</p></li>
  <li><p>(1.2) &mdash; Otherwise, <tt>ranges::begin(static_cast&lt;const T&amp;&amp;&gt;(E))</tt>.</p></li>
</ol>
</p>
</blockquote>
</li>

<li><p>Change 26.3.5 <a href="https://timsong-cpp.github.io/cppwp/range.access.cend">[range.access.cend]</a> as indicated:</p>

<blockquote>
<p>
-1- The name <tt>ranges::cend</tt> denotes a customization point object (16.3.3.3.6 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a>). 
<ins>If t</ins><del>T</del>he expression <tt>ranges::<del>c</del>end(E)</tt> for some subexpression 
<tt>E</tt> of type <tt>T</tt> <ins>is well-formed, then the expression <tt>ranges::cend(E)</tt></ins> 
is expression-equivalent to:
<ol style="list-style-type: none">
  <li><p>(1.1) &mdash; <tt>ranges::end(static_cast&lt;const T&amp;&gt;(E))</tt> if <tt>E</tt> is an lvalue.</p></li>
  <li><p>(1.2) &mdash; Otherwise, <tt>ranges::end(static_cast&lt;const T&amp;&amp;&gt;(E))</tt>.</p></li>
</ol>
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3365" href="3365">3365.</a> Rename <i>ref-is-glvalue</i> to <i>deref-is-ref</i></h3>
<p><b>Section:</b> 26.7.14.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2020-01-07 <b>Last modified:</b> 2020-11-09 20:22:58 UTC</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.iterator">active issues</a> in [range.join.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.iterator">issues</a> in [range.join.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The name of <i>join_view::iterator::ref-is-glvalue</i>, defined as 
<tt>is_reference_v&lt;range_reference_t&lt;Base&gt;&gt;</tt>, doesn't take into account 
the fact that it may also be true because <tt>range_reference_t&lt;Base&gt;</tt>
is an rvalue (e.g. for <tt>move_iterator&lt;int&gt;</tt>).</p>

<p>We suggest renaming it to <i>deref-is-ref</i>.</p>

<p><i>[2020-01-14 Status set to Tentatively NAD after five positive votes on the reflector. 
This issue was based on a misunderstanding by the submitter which had been cleared up in an 
<a href="https://github.com/cplusplus/draft/issues/3610">related editorial issue</a>.]</i></p>

<p><i>[2020-11-09 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>Rename all occurrences referring to the symbol 
<i>join_view::iterator::ref-is-glvalue</i> to <i>deref-is-ref</i>.</p>





<hr>
<h3><a name="3394" href="3394">3394.</a> <tt>ranges::basic_istream_view::<i>iterator</i></tt> has an empty <tt>iterator_traits</tt></h3>
<p><b>Section:</b> 26.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Patrick Palka <b>Opened:</b> 2020-02-09 <b>Last modified:</b> 2020-11-09 20:22:58 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.istream.iterator">issues</a> in [range.istream.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Every instantiation of <tt>ranges::basic_istream_view::<i>iterator</i></tt> has an empty
<tt>iterator_traits</tt>, i.e. the type
</p>
<blockquote><pre>
iterator_traits&lt;ranges::basic_istream_view&lt;Val, CharT, Traits&gt;::iterator&gt;
</pre></blockquote>
<p>
has no members.
<p/>
This happens because <tt>basic_istream_view::<i>iterator</i></tt> neither models
<tt><i>cpp17-iterator</i></tt> (since this concept requires copyability, which this
iterator is by design not) nor does it define all four of the member
types <tt>difference_type</tt>, <tt>value_type</tt>, <tt>reference</tt>, and 
<tt>iterator_category</tt> (it is missing <tt>reference</tt>). Therefore by 
25.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> p3, this iterator's specialization of 
<tt>iterator_traits</tt> will be empty if generated from the 
<tt>iterator_traits</tt> primary template.
<p/>
Since <tt>basic_istream_view::iterator</tt> is indeed an iterator, its
<tt>iterator_traits</tt> should certainly not be empty. The simplest solution
here is to define the member type <tt>reference</tt> in the definition of
<tt>basic_istream_view::iterator</tt>, which will enable its <tt>iterator_traits</tt>
specialization to be appropriately populated from the primary template.
</p>

<p><i>[2020-02-10; Jonathan comments]</i></p>

<p>
Jonathan and Casey have concerns about the proposed resolution. Casey: The wording makes it look
as if this iterator is supposed to be an <tt><i>cpp17-input-iterator</i></tt>.
<p/>
See also LWG <a href="3283">3283</a> and  <a href="3289">3289</a>.
</p>

<p><i>[2020-02 Prioritized as P2 Monday morning in Prague]</i></p>


<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 26.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a>, class template 
<tt>basic_istream_view::<i>iterator</i></tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;class Val, class CharT, class Traits&gt;
  class basic_istream_view&lt;Val, CharT, Traits&gt;::<i>iterator</i> { <i>// exposition only</i>
  public:
    using iterator_category = input_iterator_tag;
    using difference_type = ptrdiff_t;
    using value_type = Val;
    <ins>using reference = Val&amp;;</ins>

    <i>iterator</i>() = default;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2020-02-13, Prague]</i></p>

<p>
LWG decided for NAD: The <tt>ranges::basic_istream_view::iterator</tt> is a move-only type 
and thus cannot meet the <i>Cpp17</i> requirements (even <tt>output_iterator_tag</tt>), as such it should not 
specialize <tt>iterator_traits</tt>, to avoid misleading results when it is passed to new algorithms.
<p/>
A related issue, LWG <a href="3397">3397</a>, is supposed to take care for a problem with the definition of the
<tt>iterator_category</tt> member type of this template.
</p>
<p><i>[2020-11-09 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3399" href="3399">3399.</a> <tt>basic_syncbuf::emit()</tt> + Qt's <tt>#define emit</tt> = Big Bada-Boom</h3>
<p><b>Section:</b> 31.11.2.1 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.overview">[syncstream.syncbuf.overview]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Marc Mutz <b>Opened:</b> 2019-02-14 <b>Last modified:</b> 2020-11-09 20:22:58 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#syncstream.syncbuf.overview">issues</a> in [syncstream.syncbuf.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current IS contains a function called <tt>emit()</tt> (in <tt>basic_syncbuf</tt>, added by <a href="https://wg21.link/p0053">P0053</a>).
<p/>
<tt>emit</tt> is a macro in pervasive use in every <a href="https://doc.qt.io/qt-5/signalsandslots.html#a-small-example">Qt program</a>. 
<tt>#include</tt>'ing <tt>&lt;osyncstream&gt;</tt> after any Qt header would break, because <tt>emit</tt> was <tt>#define</tt>'d 
to nothing by the Qt headers.
<p/>
It is understood that the committee cannot check every 3rd-party library out there that chooses (badly, as I’d readily concur) to 
<tt>#define</tt> a macro of all-lowercase letters, but the <tt>min</tt>/<tt>max</tt> issue in the Windows headers caused so much 
pain for our users, that we probably should avoid a breakage here, for the benefit of our users that have to work Qt.
<p/>
It also doesn’t seem like <tt>emit()</tt> is a particularly mandatory name for the syncbuf function. Since it returns <tt>bool</tt>, 
it could just as easily be called <tt>try_emit()</tt> and the issue would be solved.
<p/>
Suggested approach:
<p/>
In <tt>basic_syncbuf</tt>, rename <tt>bool emit()</tt> to <tt>bool try_emit()</tt>. In <tt>basic_osyncstream</tt>, where the function 
doesn't return <tt>bool</tt>, but sets the stream's <tt>failbit</tt>, rename <tt>void emit()</tt> to <tt>void emit_or_fail()</tt>.
</p>

<p><i>[2020-02-14, Prague]</i></p>

<p>
The issue was send to LEWG, who made the following poll:
</p>
<blockquote>
<p>
We're open to renaming <tt>osyncstream::emit()</tt> (and related).
</p>
<blockquote><pre>
SF F N A SA
1  1 5 8 20
</pre></blockquote>
</blockquote>
<p><i>[2020-11-09 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4849">N4849</a>.</p>

<ol>
<li><p>Modify 31.7.6.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.manip">[ostream.manip]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp; flush_emit(basic_ostream&lt;charT, traits&gt;&amp; os);
</pre>
<blockquote>
<p>
-12- <i>Effects:</i> Calls <tt>os.flush()</tt>. Then, if <tt>os.rdbuf()</tt> is a <tt>basic_syncbuf&lt;charT, traits, Allocator&gt;*</tt>,
called <tt>buf</tt> for the purpose of exposition, calls <tt>buf-&gt;<ins>try_</ins>emit()</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 31.11.2.1 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.overview">[syncstream.syncbuf.overview]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 31.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.members">[syncstream.syncbuf.members]</a>, member functions</i>
bool <ins>try_</ins>emit();
streambuf_type* get_wrapped() const noexcept;
[&hellip;]
</pre>
<blockquote>
<p>
-1- Class template <tt>basic_syncbuf</tt> stores character data written to it, known as the associated output, into
internal buffers allocated using the object's allocator. The associated output is transferred to the wrapped
stream buffer object <tt>*wrapped</tt> when <tt><ins>try_</ins>emit()</tt> is called or when the <tt>basic_syncbuf</tt> 
object is destroyed. Such transfers are atomic with respect to transfers by other <tt>basic_syncbuf</tt> objects 
with the same wrapped stream buffer object.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 31.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.cons">[syncstream.syncbuf.cons]</a> as indicated:</p>

<blockquote>
<pre>
~basic_syncbuf();
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Calls <tt><ins>try_</ins>emit()</tt>.
<p/>
-8- <i>Throws:</i> Nothing. If an exception is thrown from <tt><ins>try_</ins>emit()</tt>, the destructor catches and ignores that
exception.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 31.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.assign">[syncstream.syncbuf.assign]</a> as indicated:</p>

<blockquote>
<pre>
basic_syncbuf&amp; operator=(basic_syncbuf&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <tt><ins>try_</ins>emit()</tt> then move assigns from <tt>rhs</tt>. After the move assignment <tt>*this</tt> 
has the observable state it would have had if it had been move constructed from <tt>rhs</tt> (31.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.cons">[syncstream.syncbuf.cons]</a>).
</p>
</blockquote>
</blockquote>
</li>

<li><p>Replace in 31.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.members">[syncstream.syncbuf.members]</a> all occurrences of <tt>emit()</tt> by <tt>try_emit()</tt> (five occurrences)</p>
</li>

<li><p>Replace in 31.11.2.5 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.virtuals">[syncstream.syncbuf.virtuals]</a> all occurrences of <tt>emit()</tt> by <tt>try_emit()</tt> (three occurrences)</p>
</li>

<li><p>Modify 31.11.3.1 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.overview">[syncstream.osyncstream.overview]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 31.11.3.3 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.members">[syncstream.osyncstream.members]</a>, member functions</i>
void emit<ins>_or_fail</ins>();
streambuf_type* get_wrapped() const noexcept;
[&hellip;]
</pre>
<blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Replace in 31.11.3.2 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.cons">[syncstream.osyncstream.cons]</a> all occurrences of <tt>emit()</tt> by <tt>emit_or_fail()</tt> (three occurrences)</p>
</li>

<li><p>Replace in  [syncstream.osyncstream.assign] all occurrences of <tt>emit()</tt> by <tt>emit_or_fail()</tt> (two occurrences)</p>
</li>

<li><p>Replace in 31.11.3.3 <a href="https://timsong-cpp.github.io/cppwp/syncstream.osyncstream.members">[syncstream.osyncstream.members]</a> all occurrences of <tt>emit()</tt> by <tt>emit_or_fail()</tt> (six occurrences)</p>
</li>

</ol>




<hr>
<h3><a name="3415" href="3415">3415.</a> <tt>back_insert_iterator</tt> fails when a container is also its value type</h3>
<p><b>Section:</b> 25.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/back.insert.iterator">[back.insert.iterator]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2020-03-03 <b>Last modified:</b> 2020-07-17 22:37:26 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#back.insert.iterator">issues</a> in [back.insert.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

struct example_container 
{
  using value_type = std::back_insert_iterator&lt;example_container&gt;;
  void push_back(const value_type&amp;) {}
};

int main() 
{
  std::vector&lt;std::back_insert_iterator&lt;example_container&gt;&gt; v;
  example_container ex;
  std::copy(v.begin(), v.end(), std::back_inserter(ex));
}
</pre></blockquote>
<p>
This example is out-of-contract in the current standard because it creates 
<tt>back_insert_iterator&lt;<em>incomplete</em>&gt;</tt>, as per 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a>/2. 
However, it might be something we are considering for future iterators and proxy reference types. 
In practice, the "Ill-formed, no diagnostic required" the user is likely to get is an ambiguity between 
what <tt>back_insert_iterator</tt>'s copy assignment operator, and its "push back assigning operator". 
We could resolve this by changing the return type of <tt>operator*</tt> to a proxy in the same way 
<tt>istream_iterator</tt> does, though that might be ABI breaking for some implementations.
<p/>
We should consider having a standing LWG/LEWG policy that iterators are not their own proxy 
<tt>operator*</tt> type if we intend to leave the door open to more incomplete type support in 
the standard library.
</p>

<p><i>[2020-07-17; Status changed to NAD in telecon]</i></p>

<p>
We reviewed the reflector discussion and were not motivated to support this.
There were concerns that adding incomplete type support elsewhere in containers
has caused us regrettable problems, and we're not sure we could get this right
even if we wanted to support it.
</p>


<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="3440" href="3440">3440.</a> Aggregate-paren-init breaks direct-initializing a <tt>tuple</tt> or <tt>optional</tt> from <tt>{<i>aggregate-member-value</i>}</tt></h3>
<p><b>Section:</b> 22.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>, 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2020-05-01 <b>Last modified:</b> 2020-11-09 20:22:58 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For reference, see <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94890">this gcc bug report</a>.
<p/>
Constructing a <tt>tuple</tt> or <tt>optional</tt> from an element value of an aggregate
is broken in C++20. <tt>tuple&lt;c&gt; t({val});</tt> and <tt>optional&lt;c&gt; t({val});</tt>
invoked a non-forwarding constructor before, but now the perfect-forwarding converting
constructors are a match, because the element is constructible from <tt>{val}</tt>. But
it's not convertible, so overload resolution chooses the explicit constructor, and the
initialization fails.
<p/>
Tim Song explains the overload resolution in <a href="https://lists.isocpp.org/lib/2020/05/16131.php">
this reflector discussion</a>.
<p/>
Now that we understand that C++17 called the non-forwarding conversion constructor,
and C++20 tries to use the forwarding conversion constructor, we have the solution.
SFINAE away the forwarding conversion constructor when it would convert an aggregate.
<p/>
This also means that <tt>tuple&lt;c&gt; t(0);</tt> won't work, which is unfortunate
because <tt>tuple&lt;c&gt;/optional&lt;c&gt;</tt> no longer mirrors what <tt>c</tt> can do.
That's okay; in this LWG issue, we first restore feature parity with C++17, and later,
as an extension, enable such initializations so that <tt>tuple</tt>/<tt>optional</tt>
mirrors what <tt>c</tt> can do in C++20.
<p/>
The proposed wording below has been implemented and tested.
</p>

<p><i>[2020-05-09; Reflector prioritization]</i></p>

<p>
Set priority to 2 after reflector discussions.
</p>

<p><i>[2020-06-11; LWG Telecon: Status changed: New &rarr; LEWG.]</i></p>

<p>
Ask LEWG if it's desirable to make <tt>({val})</tt> work again.
Tomasz would prefer it to be explicit e.g. via <tt>std::in_place</tt>.
</p>

<p><i>[2020-06-23; LEWG Telecon]</i></p>

<p>
POLL: Make <tt>({val})</tt> work again, at the risk of non-transparency of tuple constructors and further complicating 
the tuple and optional overload set.
</p>
<pre>
SF F N A SA
0  5 6 9 0
</pre>
<p>
No consensus for change. Close as Not a defect.
</p>
<p><i>[2020-11-09 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li><p>Modify 22.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... UTypes&gt; constexpr explicit(<i>see below</i>) tuple(UTypes&amp;&amp;... u);
</pre>
<blockquote>
<p>
-11- <i>Constraints:</i> <tt>sizeof...(Types)</tt> equals <tt>sizeof...(UTypes)</tt> and
<tt>sizeof...(Types) &ge; 1</tt> and <tt>is_constructible_v&lt;T<sub><i>i</i></sub>, U<sub><i>i</i></sub>&gt;</tt>
is <tt>true</tt> for all <tt><i>i</i></tt> <ins>and <tt>conjunction_v&lt;is_aggregate&lt;remove_reference_t&lt;T<sub><i>i</i></sub>&gt;&gt;,
negation&lt;is_same&lt;remove_reference_t&lt;T<sub><i>i</i></sub>&gt;, remove_reference_t&lt;U<sub><i>i</i></sub>&gt;&gt;&gt;&gt;</tt> is
<tt>false</tt> for all <tt><i>i</i></tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = T&gt; constexpr explicit(<i>see below</i>) optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-22- <i>Constraints:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt>,
<tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, in_place_t&gt;</tt> is <tt>false</tt>, <del>and</del>
<tt>is_same_v&lt;remove_cvref_t&lt;U&gt;, optional&gt;</tt> is <tt>false</tt><ins>, and
<tt>conjunction_v&lt;is_aggregate&lt;T&gt;, negation&lt;is_same&lt;T,
remove_reference_t&lt;U&gt;&gt;&gt;&gt;</tt> is <tt>false</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3468" href="3468">3468.</a> Transparent lookups in unordered containers are inconsistent</h3>
<p><b>Section:</b> 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2020-07-23 <b>Last modified:</b> 2020-08-21 17:36:45 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++14, we added "transparent lookups" into the ordered associative containers. This was sold as an 
efficiency concern, as removing the need to create temporary objects just to compare against.
<p/>
However, people found clever ways to use this. One of them, in fact, was in the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3465.pdf">original paper</a>, and was the subject 
of a question on <a href="https://stackoverflow.com/questions/40502357/map-or-set-with-transparent-comparator-and-non-unique-elements-in-heterogeneous">Stack Overflow</a>.
<p/>
This all works because the elements in the ordered associative containers are, well, ordered.
<p/>
For C++20, we added this facility to the unordered containers.
<p/>
Consider the following code:
</p>
<blockquote><pre>
#include &lt;unordered_set&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

struct DumbHash // put everything in the same bucket
{
  using is_transparent = void;

  template&lt;typename T&gt;
  size_t operator()(const T&amp;) const { return 0; }
};

struct CompareEQ 
{
  using is_transparent = void;

  bool operator()(const std::string&amp; lhs, const std::string&amp; rhs) const
  { return lhs == rhs; }

  bool operator()(const std::string&amp; lhs, char rhs) const
  { return !lhs.empty() &amp;&amp; (lhs[0] == rhs); }

  bool operator()(char lhs, const std::string&amp; rhs) const
  { return !rhs.empty() &amp;&amp; (lhs == rhs[0]); }
};

int main () 
{
  const char* one[] = {"a", "b",  "c", "d",  "e", "bb"};
  const char* two[] = {"b", "e",  "d", "bb", "c", "a"};
  const char* thr[] = {"b", "bb", "a", "c",  "d", "e"};

  typedef std::unordered_set&lt;std::string, DumbHash, CompareEQ&gt; MS;
  MS m1{std::begin(one), std::end(one)};
  MS m2{std::begin(two), std::end(two)};
  MS m3{std::begin(thr), std::end(thr)};

  for (const auto&amp; s: m1) 
    std::cout &lt;&lt; s &lt;&lt; ' '; 
  std::cout &lt;&lt; std::endl;
  for (const auto&amp; s: m2) 
    std::cout &lt;&lt; s &lt;&lt; ' '; 
  std::cout &lt;&lt; std::endl;
  for (const auto&amp; s: m3) 
    std::cout &lt;&lt; s &lt;&lt; ' '; 
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; "m1:" &lt;&lt; m1.count('b') &lt;&lt; ' ';
  std::cout &lt;&lt; "m2:" &lt;&lt; m2.count('b') &lt;&lt; ' ';
  std::cout &lt;&lt; "m3:" &lt;&lt; m3.count('b');
}
</pre></blockquote>
<p>
When I run this program on my Mac, I get the following output:
</p>
<blockquote><pre>
bb e d c b a
a c bb d e b
e d c a bb b
m1:1 m2:1 m3:2
</pre></blockquote>
<p>
(This is using unreleased code, but I have confirmed this with VS2019's <tt>unordered_multiset</tt>.)
<p/>
This is clearly bad; three containers, containing the same elements, doing the same lookups, giving different 
results. This also applies to the transparent versions of <tt>find</tt>, <tt>equal_range</tt>, and <tt>contains</tt>.
<p/>
The problem is that the elements in the unordered containers are only partially ordered; i.e, all the elements 
that are equal (according to the non-transparent version of the comparison predicate) are adjacent in the 
container, but are unordered relative to the other elements in the container.
<p/>
My recommendation is to declare this all UB.
<p/>
Suggested resolution:
<p/>
Add a precondition to all of the transparent lookup functions for the unordered containers forbidding stuff like this. 
This should probably go in 24.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, maybe at the end of Table [tab:container.hash.req].
</p>
<blockquote><p>
<i>Precondition:</i> The value being searched matches at most one unique key in the container.
</p></blockquote>
<p><i>[2020-08-21 Issue processing telecon: NAD based on reflector discussion. Status changed: New &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3558" href="3558">3558.</a> <tt>elements_view::<i>sentinel</i></tt>'s first <tt>operator-</tt> has wrong return type</h3>
<p><b>Section:</b> 26.7.22.4 <a href="https://timsong-cpp.github.io/cppwp/range.elements.sentinel">[range.elements.sentinel]</a> <b>Status:</b> <a href="lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2021-05-28 <b>Last modified:</b> 2021-06-07 17:01:00 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Because the iterator type of the first <tt>operator-</tt> is <tt>const <i>iterator</i>&lt;OtherConst&gt;&amp;</tt>, its 
return type should be <tt>range_difference_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;</tt>.
</p>
<p><i>[2021-06-07 Fixed by editorial issue
<a href="https://github.com/cplusplus/draft/pull/4603">#4603</a>.
Status changed: New &rarr; NAD Editorial.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4885">N4885</a>.
</p>

<ol>
<li><p>Modify 26.7.22.4 <a href="https://timsong-cpp.github.io/cppwp/range.elements.sentinel">[range.elements.sentinel]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
    [&hellip;]
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;<del><i>Base</i></del><ins><i>maybe-const</i>&lt;OtherConst, V&gt;</ins>&gt;
      operator-(const <i>iterator</i>&lt;OtherConst&gt;&amp; x, const <i>sentinel</i>&amp; y);
    
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;
      operator-(const <i>sentinel</i>&amp; x, const <i>iterator</i>&lt;OtherConst&gt;&amp; y);
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
template&lt;bool OtherConst&gt;
  requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
friend constexpr range_difference_t&lt;<del><i>Base</i></del><ins><i>maybe-const</i>&lt;OtherConst, V&gt;</ins>&gt;
  operator-(const <i>iterator</i>&lt;OtherConst&gt;&amp; x, const <i>sentinel</i>&amp; y);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to: <tt>return x.<i>current_</i> - y.<i>end_</i>;</tt>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="3562" href="3562">3562.</a> Superseding <tt>nullopt_t</tt>'s requirement to not be <i>DefaultConstructible</i></h3>
<p><b>Section:</b> 22.5.4 <a href="https://timsong-cpp.github.io/cppwp/optional.nullopt">[optional.nullopt]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Friberg <b>Opened:</b> 2021-06-04 <b>Last modified:</b> 2021-06-14 14:05:04 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.nullopt">issues</a> in [optional.nullopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.5.4 <a href="https://timsong-cpp.github.io/cppwp/optional.nullopt">[optional.nullopt]</a> p2 requires that <tt>nullopt_t</tt> shall not have a default constructor 
([&hellip;] or an initializer-list constructor, and shall not be an aggregate). However, after the final 
resolution of LWG issue <a href="2510">2510</a> and <a href="https://wg21.link/cwg1518">CWG 1518</a> it seems 
as if the following synopsis would suffice:
</p>
<blockquote><pre>
struct nullopt_t { explicit nullopt_t() = default; };
</pre></blockquote>
<p>
Which would also be consistent with other tag types.
<p/>
22.5.4 <a href="https://timsong-cpp.github.io/cppwp/optional.nullopt">[optional.nullopt]</a> p2 in its current form was written prior to the final resolution of LWG issue 
<a href="2510">2510</a> and <a href="https://wg21.link/cwg1518">CWG 1518</a>, and is arguably based on using an 
earlier proposed approach for tag types which was later superseded.
<p/>
<b>Details:</b>
<p/>
<a href="https://wg21.link/P0032R3">P0032R3</a> was part of introducing <tt>optional</tt> and contained a discussion around the 
<tt>nullopt_t</tt> type, tag types in general, and the <i>DefaultConstructible</i> requirement. Particularly, 
from section 'Not assignable from <tt>{}</tt>':
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
To re-enforce this design, there is an pending issue 2510-Tag types should not be DefaultConstructible Core issue 2510.
</p></blockquote>
<p>
At the time of <a href="https://wg21.link/P0032R3">P0032R3</a>, the resolution of LWG issue <a href="2510">2510</a> was indeed for all tag types
to not be <i>DefaultConstructible</i>, but this resolution was later superseded as part of the resolution of 
CWG issue <a href="https://wg21.link/cwg1518">CWG 1518</a>, which in turn reverted parts of the resolution of 
CWG issue <a href="https://wg21.link/cwg1630">CWG 1630</a> (which "went too far in allowing use of explicit 
constructors for default initialization").
<p/>
The final resolution for CWG 1518 (<a href="https://wg21.link/P0398R0">P0398R0</a>) lead to the requirement for aggregate classes to not 
have any explicit [user-declared] constructors, and LWG <a href="2510">2510</a> was resolved accordingly by making all 
tag types have explicit user-declared (constexpr) default constructors.
<p/>
However, the spec of <tt>nullopt_t</tt> never changed after these events or as part of updating other tag types, 
and it is still explicitly required to not be <i>DefaultConstructible</i> (nor have a initialization-list constructor) 
and to not be an aggregate, whereas the implementation of it is otherwise unspecified.
<p/>
We may note that we still see some compiler variance on the topic of CWG issues 1518 &amp; 1630, see this
<a href="https://godbolt.org/z/Tf96s4Krf">godbolt link</a>.
</p>
<p><i>[2021-06-14 Reflector poll:
Current wording prevents an implicit conversion sequence from <code>{}</code>.
Status changed: New &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4885">N4885</a>.
</p>

<ol>
<li><p>Modify 22.5.2 <a href="https://timsong-cpp.github.io/cppwp/optional.syn">[optional.syn]</a>, header <tt>&lt;optional&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]

<i>// 22.5.4 <a href="https://timsong-cpp.github.io/cppwp/optional.nullopt">[optional.nullopt]</a>, no-value state indicator</i>
struct nullopt_t{<del><i>see below</i></del> <ins>explicit nullopt_t() = default;</ins> };
inline constexpr nullopt_t nullopt<ins>{}</ins><del>(<i>unspecified</i>)</del>;

[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.4 <a href="https://timsong-cpp.github.io/cppwp/optional.nullopt">[optional.nullopt]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
struct nullopt_t{<del><i>see below</i></del> <ins>explicit nullopt_t() = default;</ins> };
inline constexpr nullopt_t nullopt<ins>{}</ins><del>(<i>unspecified</i>)</del>;
</pre>
</blockquote>
<p>
-1- The struct <tt>nullopt_t</tt> is an empty class type used as a unique type to indicate the state 
of not containing a value for <tt>optional</tt> objects. In particular, <tt>optional&lt;T&gt;</tt> 
has a constructor with <tt>nullopt_t</tt> as a single argument; this indicates that an optional object 
not containing a value shall be constructed.
<p/>
<del>-2- Type <tt>nullopt_t</tt> shall not have a default constructor or an initializer-list constructor, 
and shall not be an aggregate.</del>
</p>
</blockquote>
</li>

</ol>




<hr>
<h3><a name="3579" href="3579">3579.</a> Complexity guarantees for <tt>resize()</tt> and <tt>append()</tt> functions across the library</h3>
<p><b>Section:</b> 23.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a>, 24.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a>, 24.3.10.3 <a href="https://timsong-cpp.github.io/cppwp/list.capacity">[list.capacity]</a>, 24.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>, 24.3.9.5 <a href="https://timsong-cpp.github.io/cppwp/forward.list.modifiers">[forward.list.modifiers]</a>, 28.6.2.8 <a href="https://timsong-cpp.github.io/cppwp/valarray.members">[valarray.members]</a>, 23.4.3.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a>, 31.12.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/fs.path.append">[fs.path.append]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Louis Dionne <b>Opened:</b> 2021-08-11 <b>Last modified:</b> 2022-08-23 13:55:25 UTC</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.capacity">issues</a> in [string.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue requests to clarify the complexity requirements for <tt>resize</tt> and <tt>append</tt> 
member functions across the library. Currently, none of them have complexity requirements associated to them, 
which means that implementations are free to use a geometric growth approach or not. A geometric growth 
approach (like what's required by <tt>push_back</tt>) implies that calling <tt>resize/append</tt> with 
successively larger sizes will have amortized <tt>&#x1d4aa;(<i>N</i>)</tt> complexity, whereas using a 
<tt>resize</tt>-exactly approach makes that pattern <tt>&#x1d4aa;(<i>N</i><sup>2</sup>)</tt>.
<p/>
I believe the Standard should either specify that those member functions are required to have behavior that 
is consistent with <tt>push_back</tt>, or explicitly mention that implementations are allowed to use whatever 
growth strategy they want. If we do the former, users could start relying on this guarantee in a portable manner. 
If we do the latter, it would make it clear to users that they should not rely on the amortized 
<tt>&#x1d4aa;(<i>N</i>)</tt> guarantee if they want their code to be portable.
<p/>
The following classes have a <tt>resize()</tt> member function and also a <tt>push_back()</tt> member function:
</p>
<ul>
<li><p>23.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a></p></li>
<li><p>24.3.8.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a></p></li>
<li><p>24.3.10.3 <a href="https://timsong-cpp.github.io/cppwp/list.capacity">[list.capacity]</a></p></li>
<li><p>24.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a></p></li>
</ul>
<p>
The following classes have a <tt>resize()</tt> member function but do not support <tt>push_back()</tt>:
</p>
<ul>
<li><p>24.3.9.5 <a href="https://timsong-cpp.github.io/cppwp/forward.list.modifiers">[forward.list.modifiers]</a></p></li>
<li><p>28.6.2.8 <a href="https://timsong-cpp.github.io/cppwp/valarray.members">[valarray.members]</a></p></li>
</ul>
<p>
The following classes have an <tt>append()</tt> member function:
</p>
<ul>
<li><p>23.4.3.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a></p></li>
<li><p>31.12.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/fs.path.append">[fs.path.append]</a></p></li>
</ul>
<p>
None of them specify a complexity requirement. I think we should update all of them to describe 
what is expected or permitted in an implementation.
</p>

<p><i>[2021-08-20; Reflector poll]</i></p>

<p>
Set priority to 3 and status to "LEWG" after reflector poll.
</p>

<p><i>[2022-02-22 LEWG telecon;  Status changed: LEWG &rarr; Tentatively NAD.]</i></p>

<p>
A paper would be needed.
Such a paper would need to include discussion on whether
<code>allocate_at_least</code> (new for C++23) has an impact.
</p>

<p><i>[2022-08-23 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3588" href="3588">3588.</a> Strike out purposeless UB involving the deleter in members functions of <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.3.1.3.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.general">[unique.ptr.single.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2021-09-07 <b>Last modified:</b> 2021-09-20 11:18:00 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This originated from the editorial issues <a href="https://github.com/cplusplus/draft/pull/4871">#4871</a> 
and <a href="https://github.com/cplusplus/draft/pull/4872">#4872</a>.
<p/>
Several member functions of <tt>unique_ptr</tt> are <tt>noexcept</tt>, and yet, they have the precondition 
that an expression involving the deleter does not exit via an exception. There's nothing an implementation 
or user can take advantage of in presence of this UB. Since the behavior otherwise would be a call to 
<tt>std::terminate</tt>, these preconditions should be striked out.
<p/>
Note that although <tt>~unique_ptr()</tt> is not <tt>noexcept</tt>, 16.4.6.13 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a> p3 
specifies it to behave as if it were.
</p>
<p><i>[2021-09-20 Status changed: New &rarr; NAD.]</i></p>

<p>
The current specification allows the compiler to omit noexcept-enforcement.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 20.3.1.3.2 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.ctor">[unique.ptr.single.ctor]</a> as indicated:</p>

<blockquote>
<pre>
constexpr unique_ptr() noexcept;
constexpr unique_ptr(nullptr_t) noexcept;
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- <i>Preconditions:</i> <tt>D</tt> meets the <i>Cpp17DefaultConstructible</i> requirements (Table 27)<del>, 
and that construction does not throw an exception</del>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
explicit unique_ptr(pointer p) noexcept;
</pre>
<blockquote>
<p>
-5- <i>Constraints:</i> [&hellip;]
<p/>
-6- <i>Mandates:</i> [&hellip;]
<p/>
-7- <i>Preconditions:</i> <tt>D</tt> meets the <i>Cpp17DefaultConstructible</i> requirements (Table 27)<del>, 
and that construction does not throw an exception</del>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
unique_ptr(pointer p, const D&amp; d) noexcept;
unique_ptr(pointer p, remove_reference_t&lt;D&gt;&amp;&amp; d) noexcept;
</pre>
<blockquote>
<p>
-10- <i>Constraints:</i> [&hellip;]
<p/>
-11- <i>Mandates:</i> [&hellip;]
<p/>
-12- <i>Preconditions:</i> For the first constructor, if <tt>D</tt> is not a reference type, <tt>D</tt> 
meets the <i>Cpp17CopyConstructible</i> requirements <del>and such construction does not exit via an exception</del>. 
For the second constructor, if <tt>D</tt> is not a reference type, <tt>D</tt> meets the <i>Cpp17MoveConstructible</i> 
requirements <del>and such construction does not exit via an exception</del>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
unique_ptr(unique_ptr&amp;&amp; u) noexcept;
</pre>
<blockquote>
<p>
-17- <i>Constraints:</i> [&hellip;]
<p/>
-18- <i>Preconditions:</i> If <tt>D</tt> is not a reference type, <tt>D</tt> meets the <i>Cpp17MoveConstructible</i> 
requirements (Table 28). <del>Construction of the deleter from an rvalue of type <tt>D</tt> does not throw an exception.</del>
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class E&gt; unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
</pre>
<blockquote>
<p>
-21- <i>Constraints:</i> [&hellip;]
<p/>
-22- <i>Preconditions:</i> If <tt>E</tt> is not a reference type, construction of the deleter from an rvalue of type 
<tt>E</tt> is well-formed <del>and does not throw an exception</del>. Otherwise, <tt>E</tt> is a reference type and 
construction of the deleter from an lvalue of type <tt>E</tt> is well-formed <del>and does not throw an exception</del>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.3.1.3.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.dtor">[unique.ptr.single.dtor]</a> as indicated:</p>

<blockquote>
<pre>
~unique_ptr();
</pre>
<blockquote>
<p>
-1- <i>Preconditions:</i> The expression <tt>get_deleter()(get())</tt> is well-formed<del>,</del>
<ins>and</ins> has well-defined behavior<del>, and does not throw exceptions</del>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.3.1.3.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.asgn">[unique.ptr.single.asgn]</a> as indicated:</p>

<blockquote>
<pre>
unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Constraints:</i> [&hellip;]
<p/>
-2- <i>Preconditions:</i> If <tt>D</tt> is not a reference type, <tt>D</tt> meets the 
<i>Cpp17MoveAssignable</i> requirements (Table 30) <del>and assignment of the deleter from an 
rvalue of type <tt>D</tt> does not throw an exception</del>. Otherwise, <tt>D</tt> is a
reference type; <tt>remove_reference_t&lt;D&gt;</tt> meets the <i>Cpp17CopyAssignable</i> 
requirements <del>and assignment of the deleter from an lvalue of type <tt>D</tt> does not 
throw an exception</del>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
</pre>
<blockquote>
<p>
-6- <i>Constraints:</i> [&hellip;]
<p/>
-7- <i>Preconditions:</i> If <tt>E</tt> is not a reference type, assignment of the deleter from an rvalue 
of type <tt>E</tt> is well-formed <del>and does not throw an exception</del>. Otherwise, <tt>E</tt> is a 
reference type and assignment of the deleter from an lvalue of type <tt>E</tt> is well-formed <del>and 
does not throw an exception</del>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.3.1.3.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
void reset(pointer p = pointer()) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Preconditions:</i> The expression <tt>get_deleter()(get())</tt> is well-formed<del>,</del> 
<ins>and</ins> has well-defined behavior<del>, and does not throw exceptions</del>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
void swap(unique_ptr&amp; u) noexcept;
</pre>
<blockquote>
<p>
-6- <i>Preconditions:</i> <tt>get_deleter()</tt> is swappable (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>) <del>and 
does not throw an exception under <tt>swap</tt></del>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3596" href="3596">3596.</a> <tt>ranges::starts_with</tt> and <tt>ranges::ends_with</tt> are underspecified</h3>
<p><b>Section:</b> 27.6.16 <a href="https://timsong-cpp.github.io/cppwp/alg.starts.with">[alg.starts.with]</a>, 27.6.17 <a href="https://timsong-cpp.github.io/cppwp/alg.ends.with">[alg.ends.with]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Michael Schellenberger Costa <b>Opened:</b> 2021-09-17 <b>Last modified:</b> 2021-09-24 17:58:46 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When implementing C++23 new <tt>ranges::starts_with</tt> and <tt>ranges::ends_with</tt> 
<a href="https://github.com/microsoft/STL/pull/1997">for MSVC</a> we came around some issues regarding infinite ranges.
<p/>
In short, there is no possible answers to <tt>ends_with</tt>, if the second range is infinite. Similarly, there 
is no meaningful answer to <tt>starts_with</tt> if both ranges are infinite.
<p/>
We should constraint both algorithms to forbid those corner cases (preferred resolution), or explicitly specify a 
given return value for those (The reasonable choice would be "<tt>return false;</tt>")
</p>
<p><i>[2021-09-24 infinite ranges are invalid by [iterator.requirements.general] p10, so undefined by p12. Might be nice to relax this in future, but needs a paper. Status changed: New &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3611" href="3611">3611.</a> Should <tt>compare_exchange</tt> be allowed to modify the <tt>expected</tt> value on success?</h3>
<p><b>Section:</b> 33.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-09-29 <b>Last modified:</b> 2022-08-23 13:55:25 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently a <tt>compare_exchange</tt> will only update the <tt>expected</tt> parameter if the
<tt>compare_exchange</tt> fails. This precludes unconditionally clearing the padding bits of the
<tt>expected</tt> object prior to doing the <tt>compare_exchange</tt>, which complicates the
implementation by requiring additional work (e.g. making a copy of the <tt>expected</tt> value
and clearing the copy's padding, then copying it back to expected only if the <tt>compare_exchange</tt> fails).
<p/>
We should consider whether we want to allow modifications to <tt>expected</tt> in the success case,
if such modifications only affect padding bits (i.e. do not alter the value). If we want to allow it,
we need to say so explicitly. The current wording does not permit modifications in the success case,
and any such modification could create a data race if another thread is reading the same memory location
(if it knows a priori that a <tt>compare_exchange_strong</tt> would succeed and so not write to that location).
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll. Send to SG1.
</p>
<p>
This is <a href="2426">2426</a> again,
but the new requirement to clear padding bits changes things.
</p>

<p><i>[2022-07-06; Move to "Open" following SG1 feedback]</i></p>

<p>
Allow compare_exchange to modify the expected value on success?
<table>
<tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>5</td><td>4</td></tr>
</table>
</p>

<p><i>[2022-07-14; Move to "Tentatively NAD" following reflector poll]</i></p>


<p><i>[2022-08-23 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="3652" href="3652">3652.</a> Can we relax the preconditions of <tt>longjmp</tt>?</h3>
<p><b>Section:</b> 17.14.3 <a href="https://timsong-cpp.github.io/cppwp/csetjmp.syn">[csetjmp.syn]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-12-15 <b>Last modified:</b> 2022-01-30 17:02:00 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
IMO the UB in 17.14.3 <a href="https://timsong-cpp.github.io/cppwp/csetjmp.syn">[csetjmp.syn]</a>/2 is because of the design that "every destructor call 
for an object shall be in effect when the lifetime of that object ends". A similar requirement is 
in 6.7.3 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>/5, but it's more relaxed than the requirement for <tt>setjmp</tt>/<tt>longjmp</tt>.
It seems better to harmonize the requirements in 6.7.3 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>/5 and 
17.14.3 <a href="https://timsong-cpp.github.io/cppwp/csetjmp.syn">[csetjmp.syn]</a>/2, which allows <tt>longjmp</tt> to skip non-trivial but no-op destructor calls. 
Given that Microsoft UCRT's <tt>longjmp</tt> can sometimes (but not always) call destructors, 
IMO we should say that it's unspecified whether <tt>longjmp</tt> calls destructor for any object 
whose lifetime ends.
</p>
<p><i>[2022-01-30
Duplicate of <a href="https://wg21.link/cwg2361">CWG 2361</a>.
Status changed: New &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>. 
</p>

<ol>
<li><p>Modify 17.14.3 <a href="https://timsong-cpp.github.io/cppwp/csetjmp.syn">[csetjmp.syn]</a> as indicated:</p>

<blockquote>
<p>
-2- The function signature <tt>longjmp(jmp_buf jbuf, int val)</tt> has more restricted behavior 
in this document. <del>A <tt>setjmp</tt>/<tt>longjmp</tt> call pair has undefined behavior 
i</del><ins>I</ins>f replacing the <tt>setjmp</tt> and <tt>longjmp</tt> <ins>in a 
<tt>setjmp</tt>/<tt>longjmp</tt> call pair</ins> by <tt>catch</tt> and <tt>throw</tt> would invoke any 
<del>non-trivial</del> destructors for any objects with automatic storage duration<ins>, it is 
unspecified whether the destructor is invoked for each such object. The behavior is undefined if the 
program depends on the side effects produced by any such unspecified destructor calls</ins>. A 
call to <tt>setjmp</tt> or <tt>longjmp</tt> has undefined behavior if invoked in a suspension 
context of a coroutine (7.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/expr.await">[expr.await]</a>).
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3667" href="3667">3667.</a> <tt>std::cout &lt;&lt; &amp;X::f</tt> prints <tt>1</tt></h3>
<p><b>Section:</b> 31.7.6.3 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted">[ostream.formatted]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2022-01-31 <b>Last modified:</b> 2022-08-23 13:55:25 UTC</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
At present, the program
</p>
<blockquote><pre>
#include &lt;iostream&gt;

struct X
{
  void f() {}
};

int main()
{
  std::cout &lt;&lt; &amp;X::f;
}
</pre></blockquote>
<p>
prints <tt>1</tt>. That's because member pointers implicitly convert
to <tt>bool</tt>, and there's <tt>operator&lt;&lt;</tt> overload for <tt>bool</tt> in
31.7.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.arithmetic">[ostream.inserters.arithmetic]</a>.
<p/>
This behavior is rarely useful. In C++20, we added deleted
overloads to prevent a similar counter-intuitive output for
the case in which e.g. <tt>L"str"</tt> is output to <tt>std::cout</tt>,
which used to print the pointer value using the <tt>operator&lt;&lt;</tt>
overload for <tt>const void*</tt>.
<p/>
We should similarly consider adding a deleted overload for member pointers.
</p>

<p><i>[2022-03-04; Reflector poll; Status changed: New &rarr; Tentatively NAD]</i></p>

<p>
 Needs a paper to LEWG if anything should change here.
</p>
<p><i>[2022-08-23 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>
<li><p>Modify 31.7.6.2.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.general">[ostream.general]</a>, class template <tt>basic_ostream</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  
  template&lt;class traits&gt;
    basic_ostream&lt;wchar_t, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;wchar_t, traits&gt;&amp;, const char16_t*) = delete;
  template&lt;class traits&gt;
    basic_ostream&lt;wchar_t, traits&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;wchar_t, traits&gt;&amp;, const char32_t*) = delete;
      
  <ins>template&lt;class charT, class traits, class T, class C&gt;
    basic_ostream&lt;charT, traits&gt;&amp; 
      operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;, T C::*) = delete;</ins>
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="3695" href="3695">3695.</a> The standard-layout property of char-like types serves for nothing</h3>
<p><b>Section:</b> 23.1 <a href="https://timsong-cpp.github.io/cppwp/strings.general">[strings.general]</a> <b>Status:</b> <a href="lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-05-07 <b>Last modified:</b> 2022-08-23 13:55:25 UTC</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#strings.general">issues</a> in [strings.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently char-like types are defined as non-array trivial and standard-layout types (23.1 <a href="https://timsong-cpp.github.io/cppwp/strings.general">[strings.general]</a>). 
However, as far as I know, there is no actual operation specified in the standard or used in implementations 
requiring a char-like type to be standard-layout (unlike the triviality, which is related to <tt>charT()</tt>, etc.). 
Implementations are merely <tt>static_assert</tt>-ing the standard-layout property of element types.
<p/>
As the standard library almost never requires a user-provided type to be standard-layout now (other suspicious 
exceptions are program-defined specializations of <tt>std::atomic&lt;T*&gt;</tt>), I think char-like types should 
just be non-array trivial types.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Six votes for NAD.
Changing this would require a proposal through LEWG.
</p>

<p><i>[2022-08-23 Status changed: Tentatively NAD &rarr; NAD.]</i></p>



<p><b>Proposed resolution:</b></p>





</body>
</html>
