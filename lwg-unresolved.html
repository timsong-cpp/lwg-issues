<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>C++ Standard Library Unresolved Issues</title>
<style>
  p {text-align:justify}
  li {text-align:justify}
  pre code.backtick::before { content: "`" }
  pre code.backtick::after { content: "`" }
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table.issues-index { border: 1px solid; border-collapse: collapse; }
  table.issues-index th { text-align: center; padding: 4px; border: 1px solid; }
  table.issues-index td { padding: 4px; border: 1px solid; }
  table.issues-index td:nth-child(1) { text-align: right; }
  table.issues-index td:nth-child(2) { text-align: left; }
  table.issues-index td:nth-child(3) { text-align: left; }
  table.issues-index td:nth-child(4) { text-align: left; }
  table.issues-index td:nth-child(5) { text-align: center; }
  table.issues-index td:nth-child(6) { text-align: center; }
  table.issues-index td:nth-child(7) { text-align: left; }
  table.issues-index td:nth-child(5) span.no-pr { color: red; }
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<p>Revised 2025-10-12
</p><h2>Unresolved Issues</h2>
<hr>
<h3 id="423"><a href="423">423</a>. Effects of negative <code>streamsize</code> in iostreams</h3>
<p><b>Section:</b> 31 <a href="https://timsong-cpp.github.io/cppwp/input.output">[input.output]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2018-12-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A third party test suite tries to exercise <code>istream::ignore(N)</code> with a negative value of 
<code>N</code> and expects that the implementation will treat <code>N</code> as if it were <code>0</code>. Our 
implementation asserts that (<code>N &gt;= 0</code>) holds and aborts the test.
</p>

<p>
I can't find anything in section 27 that prohibits such values but I don't
see what the effects of such calls should be, either (this applies to
a number of unformatted input functions as well as some member functions
of the <code>basic_streambuf</code> template).
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is related to LWG <a href="255" title="Why do basic_streambuf&lt;&gt;::pbump() and gbump() take an int? (Status: NAD)">255</a>.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend Open: We agree that we should require <code>N &gt;= 0</code> for the selected functions</p>

<p><i>[2018-12-04 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p id="res-423"><b>Proposed resolution:</b></p>
<p>
I propose that we add to each function in clause 27 that takes an argument, say <code>N</code>, of type 
<code>streamsize</code> a <i>Requires</i> clause saying that "<code>N &gt;= 0</code>." The intent is to allow 
negative streamsize values in calls to <code>precision()</code> and <code>width()</code> but disallow it in 
calls to <code>streambuf::sgetn()</code>, <code>istream::ignore()</code>, or <code>ostream::write()</code>.
</p>

<p><i>[Kona: The LWG agreed that this is probably what we want. However, we
  need a review to find all places where functions in clause 27 take
  arguments of type <code>streamsize</code> that shouldn't be allowed to go
  negative. Martin will do that review.]</i></p>






<hr>
<h3 id="484"><a href="484">484</a>. Convertible to <code>T</code></h3>
<p><b>Section:</b> 24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-09-16 <b>Last modified:</b> 2023-06-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#input.iterators">active issues</a> in [input.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>From comp.std.c++:</p>

<p>
I note that given an input iterator a for type <code>T</code>, 
then <code>*a</code> only has to be "convertable to <code>T</code>", 
not actually of type <code>T</code>.
</p>

<p>Firstly, I can't seem to find an exact definition of "convertable to <code>T</code>". 
While I assume it is the obvious definition (an implicit conversion), I 
can't find an exact definition. Is there one?</p>

<p>Slightly more worryingly, there doesn't seem to be any restriction on 
the this type, other than it is "convertable to <code>T</code>". Consider two input 
iterators <code>a</code> and <code>b</code>. I would personally assume that most people would 
expect <code>*a==*b</code> would perform <code>T(*a)==T(*b)</code>, however it doesn't seem that 
the standard requires that, and that whatever type <code>*a</code> is (call it <code>U</code>) 
could have == defined on it with totally different symantics and still 
be a valid inputer iterator.</p>

<p>Is this a correct reading? When using input iterators should I write 
<code>T(*a)</code> all over the place to be sure that the object I'm using is the 
class I expect?</p>

<p>This is especially a nuisance for operations that are defined to be
  "convertible to <code>bool</code>".  (This is probably allowed so that
  implementations could return say an <code>int</code> and avoid an unnecessary
  conversion. However all implementations I have seen simply return a
  <code>bool</code> anyway.  Typical implementations of STL algorithms just write
  things like <code>while(a!=b &amp;&amp; *a!=0)</code>.  But strictly
  speaking, there are lots of types that are convertible to <code>T</code> but
  that also overload the appropriate operators so this doesn't behave
  as expected.</p>

<p>If we want to make code like this legal (which most people seem to
  expect), then we'll need to tighten up what we mean by "convertible
  to <code>T</code>".</p>

<p><i>[Lillehammer: The first part is NAD, since "convertible" is
 well-defined in core. The second part is basically about pathological
 overloads. It's a minor problem but a real one. So leave open for
 now, hope we solve it as part of iterator redesign.]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair. No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD Future. We agree there's an issue, but there is no
proposed solution at this time and this will be solved by concepts in
the future.
</p></blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>Has been clarified by 14. By design. Ranges might make it go away. 
Current wording for input iterators is more constrained.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Move to Open. This is very similar to <a href="2962" title="Iterators of Containers of move-only types do not model InputIterator (Status: Open)">2962</a>, possibly a duplicate.</p>
<p>Marshall to research</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Priority 2; same as <a href="2962" title="Iterators of Containers of move-only types do not model InputIterator (Status: Open)">2962</a>.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Solved by <a href="https://wg21.link/N2758" title=" Iterator Concepts for the C++0x Standard Library (Revision 5)">N2758</a>.
</p></blockquote>

</blockquote>

<p><i>[2023-06; Varna]</i></p>

<p>
During LWG discussion of this issue it was decided to reduce the priority to 3.
<p/>
Furthermore, the still presented "Solved by" comment has been recognized as being
no longer true, since the referred to pre-C++11 concept paper wording <a href="https://wg21.link/N2758" title=" Iterator Concepts for the C++0x Standard Library (Revision 5)">N2758</a> is no longer part
of the working paper.
<p/>
It also has been observed, that the "convertible to <code>bool</code>" part has since been resolved
by <a href="https://wg21.link/P1964" title=" Wording for boolean-testable">P1964</a> and the follow-up paper <a href="https://wg21.link/P2167" title=" Improved Proposed Wording for LWG 2114 (contextually convertible to bool)">P2167</a>.
<p/>
Also LWG <a href="3105" title="T1 is convertible to T2 (Status: New)">3105</a> has a lot of overlap with this issue.
</p>


<p id="res-484"><b>Proposed resolution:</b></p>





<hr>
<h3 id="523"><a href="523">523</a>. regex case-insensitive character ranges are unimplementable as specified</h3>
<p><b>Section:</b> 28.6 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2005-07-01 <b>Last modified:</b> 2020-07-17</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re">active issues</a> in [re].</p>
<p><b>View all other</b> <a href="lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A problem with TR1 regex is currently being discussed on the Boost 
developers list. It involves the handling of case-insensitive matching 
of character ranges such as [Z-a]. The proper behavior (according to the 
ECMAScript standard) is unimplementable given the current specification 
of the TR1 <code>regex_traits&lt;&gt;</code> class template. John Maddock, the author of 
the TR1 regex proposal, agrees there is a problem. The full discussion 
can be found at http://lists.boost.org/boost/2005/06/28850.php (first 
message copied below). We don't have any recommendations as yet.
</p>
<p>
-- Begin original message --
</p>
<p>
The situation of interest is described in the ECMAScript specification
(ECMA-262), section 15.10.2.15:
</p>
<p>
"Even if the pattern ignores case, the case of the two ends of a range
is significant in determining which characters belong to the range.
Thus, for example, the pattern /[E-F]/i matches only the letters E, F,
e, and f, while the pattern /[E-f]/i matches all upper and lower-case
ASCII letters as well as the symbols [, \, ], ^, _, and `."
</p>
<p>
A more interesting case is what should happen when doing a
case-insensitive match on a range such as [Z-a]. It should match z, Z,
a, A and the symbols [, \, ], ^, _, and `. This is not what happens with
Boost.Regex (it throws an exception from the regex constructor).
</p>
<p>
The tough pill to swallow is that, given the specification in TR1, I
don't think there is any effective way to handle this situation.
According to the spec, case-insensitivity is handled with
<code>regex_traits&lt;&gt;::translate_nocase(CharT)</code> &mdash; two characters are equivalent
if they compare equal after both are sent through the <code>translate_nocase</code>
function. But I don't see any way of using this translation function to
make character ranges case-insensitive. Consider the difficulty of
detecting whether "z" is in the range [Z-a]. Applying the transformation
to "z" has no effect (it is essentially <code>std::tolower</code>). And we're not
allowed to apply the transformation to the ends of the range, because as
ECMA-262 says, "the case of the two ends of a range is significant."
</p>
<p>
So AFAICT, TR1 regex is just broken, as is Boost.Regex. One possible fix
is to redefine translate_nocase to return a string_type containing all
the characters that should compare equal to the specified character. But
this function is hard to implement for Unicode, and it doesn't play nice
with the existing ctype facet. What a mess!
</p>
<p>
-- End original message --
</p>

<p><i>[
John Maddock adds:
]</i></p>


<p>
One small correction, I have since found that ICU's regex package does 
implement this correctly, using a similar mechanism to the current 
TR1.Regex.
</p>
<p>
Given an expression [c1-c2] that is compiled as case insensitive it:
</p>
<p>
Enumerates every character in the range c1 to c2 and converts it to it's 
case folded equivalent.  That case folded character is then used a key to a 
table of equivalence classes, and each member of the class is added to the 
list of possible matches supported by the character-class.  This second step 
isn't possible with our current traits class design, but isn't necessary if 
the input text is also converted to a case-folded equivalent on the fly.
</p>
<p>
ICU applies similar brute force mechanisms to character classes such as 
[[:lower:]] and [[:word:]], however these are at least cached, so the impact 
is less noticeable in this case.
</p>
<p>
Quick and dirty performance comparisons show that expressions such as 
"[X-\\x{fff0}]+" are indeed very slow to compile with ICU (about 200 times 
slower than a "normal" expression).  For an application that uses a lot of 
regexes this could have a noticeable performance impact.  ICU also has an 
advantage in that it knows the range of valid characters codes: code points 
outside that range are assumed not to require enumeration, as they can not 
be part of any equivalence class.  I presume that if we want the TR1.Regex 
to work with arbitrarily large character sets enumeration really does become 
impractical.
</p>
<p>
Finally note that Unicode has:
</p>
<p>
Three cases (upper, lower and title).
One to many, and many to one case transformations.
Character that have context sensitive case translations - for example an 
uppercase sigma has two different lowercase forms  - the form chosen depends 
on context(is it end of a word or not), a caseless match for an upper case 
sigma should match either of the lower case forms, which is why case folding 
is often approximated by tolower(toupper(c)).
</p>
<p>
Probably we need some way to enumerate character equivalence classes, 
including digraphs (either as a result or an input), and some way to tell 
whether the next character pair is a valid digraph in the current locale.
</p>
<p>
Hoping this doesn't make this even more complex that it was already,
</p>

<p><i>[
Portland: Alisdair: Detect as invalid, throw an exception.
Pete: Possible general problem with case insensitive ranges.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We agree that this is a problem, but we do not know the answer.
</p>
<p>
We are going to declare this NAD until existing practice leads us in some direction.
</p>
<p>
No objection to NAD Future.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend Open: Tim Shen proposes: forbid use of case-insensitive ranges with regex traits other than 
<code>std::regex_traits&lt;{char, wchar_t, char16_t, char32_t}&gt;</code> when regex_constants::collate is specified.</p>

<p><i>[2020-07-17; Priority set to 4 in telecon]</i></p>



<p id="res-523"><b>Proposed resolution:</b></p>





<hr>
<h3 id="532"><a href="532">532</a>. Tuple comparison</h3>
<p><b>Section:</b> 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, 99 [tr.tuple.rel] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2005-11-29 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="348" title="Minor issue with std::pair operator&lt; (Status: Dup)">348</a></p>
<p><b>Discussion:</b></p>
<p>
Where possible, <code>tuple</code> comparison operators &lt;,&lt;=,=&gt;, and &gt; ought to be
defined in terms of <code>std::less</code> rather than <code>operator&lt;</code>, in order to
support comparison of tuples of pointers.  
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
If we solve this for <code>tuple</code> we would have to solve it for <code>pair</code>
algorithms, etc.  It is too late to do that at this time.  Move to NAD Future.
</p>
</blockquote>



<p id="res-532"><b>Proposed resolution:</b></p>
<p>
change 6.1.3.5/5 from:
</p>

<blockquote><p>
  Returns: The result of a lexicographical comparison between t and
  u. The result is defined as: (bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) ||
  (!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for
  some tuple r is a tuple containing all but the first element of
  r. For any two zero-length tuples e and f, e &lt; f returns false.
</p></blockquote>

<p>
to:
</p>

<blockquote>
<p>
  Returns: The result of a lexicographical comparison between t and
  u. For any two zero-length tuples e and f, e &lt; f returns false.
  Otherwise, the result is defined as: cmp( get&lt;0&gt;(t), get&lt;0&gt;(u)) ||
  (!cmp(get&lt;0&gt;(u), get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for some
  tuple r is a tuple containing all but the first element of r, and
  cmp(x,y) is an unspecified function template defined as follows.
</p>
<p>
  Where T is the type of x and U is the type of y:
</p>

<p>
     if T and U are pointer types and T is convertible to U, returns
     less&lt;U&gt;()(x,y)
</p>

<p>
     otherwise, if T and U are pointer types, returns less&lt;T&gt;()(x,y)
</p>

<p>
     otherwise, returns (bool)(x &lt; y)
</p>
</blockquote>

<p><i>[
Berlin: This issue is much bigger than just tuple (pair, containers,
algorithms). Dietmar will survey and work up proposed wording.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Recommend NAD.  This will be fixed with the next revision of concepts.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</p></blockquote>





<hr>
<h3 id="617"><a href="617">617</a>. <code>std::array</code> is a sequence that doesn't satisfy the sequence requirements?</h3>
<p><b>Section:</b> 23.3.3 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-30 <b>Last modified:</b> 2022-11-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>&lt;array&gt;</code> header is given under 23.3 <a href="https://timsong-cpp.github.io/cppwp/sequences">[sequences]</a>.
23.3.3 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>/paragraph 3 says:
</p>
<blockquote><p>
"Unless otherwise specified, all array operations are as described in
23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>".
</p></blockquote>
<p>
However, <code>array</code> isn't mentioned at all in section 23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>.
In particular, Table 82 "Sequence requirements" lists several operations (insert, erase, clear) 
that <code>std::array</code> does not have in 23.3.3 <a href="https://timsong-cpp.github.io/cppwp/array">[array]</a>.
</p>
<p>
Also, Table 83 "Optional sequence operations" lists several operations that 
<code>std::array</code> does have, but array isn't mentioned.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The real issue seems to be different than what is described here.
Non-normative text says that <code>std::array</code> is a sequence container, but
there is disagreement about what that really means. There are two
possible interpretations:
</p>
<ol>
<li>
a sequence container is one that satisfies all sequence container requirements
</li>
<li>
a sequence container is one that satisfies some of the sequence
container requirements. Any operation that the container supports is
specified by one or more sequence container requirements, unless that
operation is specifically singled out and defined alongside the
description of the container itself.
</li>
</ol>
<p>
Move to Tentatively NAD.
</p>
</blockquote>

<p><i>[
2009-07-15 Lo&iuml;c Joly adds:
]</i></p>


<blockquote>
<p>
The section 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>/1 states that array is a sequence. 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>/3
introduces table 83, named Sequence container requirements. This seems
to me to be defining the requirements for all sequences. However, array
does not follow all of this requirements (this can be read in the array
specific section, for the standard is currently inconsistent).
</p>

<p>
Proposed resolution 1 (minimal change): 
</p>
<blockquote>
<p>
Say that array is a container, that in addition follows only some of the
sequence requirements, as described in the array section:
</p>

<blockquote><p>
The library provides <del>five</del> <ins>three</ins> basic kinds of sequence containers: <del><code>array</code></del>,
<code>vector</code>, 
<del><code>forward_list</code></del>, <code>list</code>, and <code>deque</code>. <ins>In addition, <code>array</code>
and <code>forward_list</code> follows some of the requirements 
of sequences, as described in their respective sections.</ins>
</p></blockquote>

</blockquote>

<p>
Proposed resolution 2 (most descriptive description, no full wording provided): 
</p>
<blockquote><p>
Introduce the notion of a Fixed Size Sequence, with it requirement table
that would be a subset of the current Sequence container. array would be
the only Fixed Size Sequence (but dynarray is in the queue for TR2).
Sequence requirements would now be requirements in addition to Fixed
Size Sequence requirements (it is currently in addition to container).
</p></blockquote>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
Move to NAD Editorial
</p></blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
This will require a lot of reorganization. Editor doesn't think this is really
an issue, since the description of array can be considered as overriding
what's specified about sequences. Move to NAD.
</p></blockquote>

<p><i>[2022-10-27; Hubert Tong comments and requests to reopen]</i></p>

<p>
This issue appears to be unresolved (should not be NAD).
<p/>
As noted in 23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> paragraph 3, <code>array</code> 
does not meet 23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a> paragraph 10. This means that 
<code>array</code> does not meet the container requirements, never mind the requirements 
for sequence containers or contiguous containers.
<p/>
However, there is wording that claims the opposite.
<p/>
23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> paragraph 1:
</p>
<blockquote><p>
In addition, <code>array</code> is provided as a sequence container which provides limited sequence operations 
because it has a fixed number of elements.
</p></blockquote>
<p>
(Perhaps the above should be worded with "except".)
<p/>
23.3.1 <a href="https://timsong-cpp.github.io/cppwp/sequences.general">[sequences.general]</a> paragraph 1:
</p>
<blockquote><p>
The headers <code>&lt;array&gt;</code> [&hellip;] define class templates that meet the requirements for sequence containers.
</p></blockquote>
<p>
23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> paragraph 1:
</p>
<blockquote><p>
[&hellip;] An <code>array</code> is a contiguous container (23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>).
</p></blockquote>
<p>
In <a href="https://github.com/cplusplus/draft/issues/5916#issuecomment-1291327657">this comment</a>, 
Casey suggests that the requirements be changed so that <code>array</code> does meet the requirements.
</p>

<p><i>[Kona 2022-11-12; Set Priority to 3]</i></p>



<p id="res-617"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="936"><a href="936">936</a>. Mutex type overspecified</h3>
<p><b>Section:</b> 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-05 <b>Last modified:</b> 2017-03-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="961" title="Various threading bugs #11 (Status: LEWG)">961</a></p>
<p><b>Discussion:</b></p>



<p>
32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> describes the requirements for a type to be
a "Mutex type". A Mutex type can be used as the template argument for
the <code>Lock</code> type that's passed to <code>condition_variable_any::wait</code> (although
<code>Lock</code> seems like the wrong name here, since <code>Lock</code> is given a different
formal meaning in 32.6.5 <a href="https://timsong-cpp.github.io/cppwp/thread.lock">[thread.lock]</a>) and, although the WD doesn't quite say
so, as the template argument for <code>lock_guard</code> and <code>unique_lock</code>.
</p>

<p>
The requirements for a Mutex type include:
</p>

<ul>
<li>
<code>m.lock()</code> shall be well-formed and have [described] semantics, including a return type of <code>void</code>.
</li>
<li>
<code>m.try_lock()</code> shall be well-formed and have [described] semantics, including a return type of <code>bool</code>.
</li>
<li>
<code>m.unlock()</code> shall be well-formed and have [described] semantics, including a return type of <code>void</code>.
</li>
</ul>

<p>
Also, a Mutex type "shall not be copyable nor movable".
</p>

<p>
The latter requirement seems completely irrelevant, and the three
requirements on return types are tighter than they need to be. For
example, there's no reason that <code>lock_guard</code> can't be instantiated with a
type that's copyable. The rule is, in fact, that <code>lock_guard</code>, etc. won't
try to copy objects of that type. That's a constraint on locks, not on
mutexes. Similarly, the requirements for <code>void</code> return types are
unnecessary; the rule is, in fact, that <code>lock_guard</code>, etc. won't use any
returned value. And with the return type of <code>bool</code>, the requirement should
be that the return type is convertible to <code>bool</code>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Move to open. Related to conceptualization and should probably be tackled as part of that.
</p>
<ul>
<li>
The intention is not only to place a constraint on what types such as
<code>lock_guard</code> may do with mutex types, but on what any code, including user
code, may do with mutex types. Thus the constraints as they are apply to
the mutex types themselves, not the current users of mutex types in the
standard.
</li>
<li>
This is a low priority issue; the wording as it is may be overly
restrictive but this may not be a real issue.
</li>
</ul>
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Section 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> conflates the
requirements on a generic Mutex type (including user-supplied mutexes)
with the requirements placed on the standard-supplied mutex types in an
attempt to group everything together and save space.
</p>
<p>
When applying concepts to chapter 30, I suggest that the concepts
<code>Lockable</code> and <code>TimedLockable</code> embody the requirements for
*use* of a mutex type as required by
<code>unique_lock/lock_guard/condition_variable_any</code>. These should be
relaxed as Pete describes in the issue. The existing words in 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> are requirements on all of
<code>std::mutex</code>, <code>std::timed_mutex</code>,
<code>std::recursive_mutex</code> and <code>std::recursive_timed_mutex</code>,
and should be rephrased as such.
</p>
</blockquote>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1: Agreement that we need a paper.
</p>


<p id="res-936"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="961"><a href="961">961</a>. Various threading bugs #11</h3>
<p><b>Section:</b> 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2017-03-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="936" title="Mutex type overspecified (Status: LEWG)">936</a></p>
<p><b>Discussion:</b></p>
<p>
32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> describes required member
functions of mutex types, and requires that they throw exceptions under
certain circumstances. This is overspecified. User-defined types can
abort on such errors without affecting the operation of templates
supplied by standard-library.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
Move to open. Related to conceptualization and should probably be
tackled as part of that.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Would be OK to leave it as is for time constraints, could loosen later.
</p>

<p>
Mark as NAD Future.
</p>
</blockquote>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1: Agreement that we need a paper.
</p>


<p id="res-961"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="1102"><a href="1102">1102</a>. <code>std::vector</code>'s reallocation policy still unclear</h3>
<p><b>Section:</b> 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-04-20 <b>Last modified:</b> 2020-07-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have the impression that even the wording of current draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
does insufficiently express the intent of <code>vector</code>'s
reallocation strategy. This has produced not too old library
implementations which release memory in the <code>clear()</code> function
and even modern articles about C++ programming cultivate
the belief that <code>clear</code> is allowed to do exactly this. A typical
example is something like this:
</p>

<blockquote><pre>
const int buf_size = ...;
std::vector&lt;T&gt; buf(buf_size);
for (int i = 0; i &lt; some_condition; ++i) {
  buf.resize(buf_size);
  write_or_read_data(buf.data());
  buf.clear(); // Ensure that the next round get's 'zeroed' elements
}
</pre></blockquote>
<p>
where still the myth is ubiquitous that <code>buf</code> might be
allowed to reallocate it's memory <b>inside</b> the <code>for</code> loop.
</p>
<p>
IMO the problem is due to the fact, that
</p>

<ol style="list-style-type:lower-alpha">
<li>
the actual memory-reallocation stability of <code>std::vector</code>
is explained in 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>/3 and /6 which
are describing just the effects of the <code>reserve</code>
function, but in many examples (like above) there
is no explicit call to <code>reserve</code> involved. Further-more
23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>/6 does only mention <em>insertions</em>
and never mentions the consequences of erasing elements.
</li>
<li>
<p>
the effects clause of <code>std::vector</code>'s <code>erase</code> overloads in
23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>/4 is silent about capacity changes. This
easily causes a misunderstanding, because the counter
parting insert functions described in 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>/2
explicitly say, that
</p>
<blockquote><p>
Causes reallocation if the new size is greater than the
old capacity. If no reallocation happens, all the iterators
and references before the insertion point remain valid.
</p></blockquote>
<p>
It requires a complex argumentation chain about four
different places in the standard to provide the &mdash; possibly
weak &mdash; proof that calling <code>clear()</code> also does <em>never</em> change
the capacity of the <code>std::vector</code> container. Since <code>std::vector</code>
is the de-facto replacement of C99's dynamic arrays this
type is near to a built-in type and it's specification should
be clear enough that usual programmers can trust their
own reading.
</p>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes paragraph 1 of the proposed resolution is unnecessary
because it is already implied (even if tortuously) by the current wording.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD. Rationale: there is no consensus to clarify the standard,
general consensus that the standard is correct as written.
</p></blockquote>

<p><i>[2020-05-08; Reopen after reflector discussions]</i></p>

<p>
"correct as written" has been disputed.
</p>

<p><i>[2020-07-17; Priority set to 3 in telecon]</i></p>



<p id="res-1102"><b>Proposed resolution:</b></p>
<p><i>[
This is a minimum version. I also
suggest that the wording explaining the allocation strategy
of <code>std::vector</code> in 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>/3 and /6 is moved into
a separate sub paragraph of 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> <em>before</em>
any of the prototype's are discussed, but I cannot provide
reasonable wording changes now.
]</i></p>


<ol>
<li>
<p>
Change 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>/6 as follows:
</p>
<blockquote><p>
It is guaranteed that no reallocation takes place during
insertions <ins>or erasures</ins> that happen after a call
to <code>reserve()</code> until the time when an insertion would make
the size of the vector greater than the value of <code>capacity()</code>.
</p></blockquote>
</li>
<li>
<p>
Change 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>/4 as follows:
</p>
<blockquote><p>
<i>Effects:</i> <ins>The capacity shall remain unchanged and no reallocation shall
happen.</ins>
Invalidates iterators and references at or after the point
of the erase.
</p></blockquote>
</li>
</ol>





<hr>
<h3 id="1175"><a href="1175">1175</a>. <code>unordered</code> complexity</h3>
<p><b>Section:</b> 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <code>unordered_*</code> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
Actually, it is proportional to <code>n</code>, but there are no invocations of
<code>value_type</code> constructors or other <code>value_type</code> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote><p>
<i>Complexity:</i> exactly <code>n</code> calls to construct <code>value_type</code>
from <code>InputIterator::value_type</code> (where <code>n = distance(f,l)</code>).
The number of calls to <code>key_equal::operator()</code> is proportional to
<code>n</code> in the average case and <code>n*n</code> in the worst case.
</p></blockquote>

<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at 
both the clause 23 requirements tables and the constructor description of each unordered container to be sure.
</p>
<p>
Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.
</p>
<p>
Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[2011-02-26: Daniel provides wording]</i></p>


<p>I strongly suggest to clean-up the differences between requirement tables and individual
specifications. In the usual way, the most specific specifications wins, which is in this
case the wrong one. In regard to the concern expressed about missing <code>DefaultConstructible</code>
requirements of the value type I disagree: The function argument <code>n</code> is no size-control
parameter, but only some effective capacity parameter: No elements will be value-initialized
by these constructors. The necessary requirement for the value type, <code>EmplaceConstructible</code>
into <code>*this</code>, is already listed in Table 103 &mdash; Unordered associative container requirements.
Another part of the proposed resolution is the fact that there is an inconsistency of the
complexity counting when both a range <strong>and</strong> a bucket count is involved compared
to constructions where only bucket counts are provided: E.g. the construction <code>X a(n);</code>
has a complexity of <code>n</code> bucket allocations, but this part of the work is omitted for
<code>X a(i, j, n);</code>, even though it is considerable larger (in the average case) for 
<code>n &#8811; distance(i, j)</code>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The proposed wording looks good.  Move to Review.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Fix up some presentation issues with the wording, combining the big-O expressions into single
expressions rather than the sum of two separate big-Os.
</p>
<p>
Strike "constant or linear", prefer "linear in the number of buckets".
This allows for number of buckets being larger than requested <code>n</code> as well.
</p>
<p>
Default <code>n</code> to "unspecified" rather than "implementation-defined".  It seems an un-necessary
burden asking vendors to document a quantity that is easily determined through the public API of
these classes.
</p>
<p>
Replace <code>distance(f,l)</code> with "number of elements in the range <code>[f,l)</code>"
</p>
<p>
Retain in Review with the updated wording
</p>

<p><i>[2012, Portland: Move to Open]</i></p>

<p>
The wording still does not call out Pablo's original concern, that the element constructor is called
no more than <code>N</code> times, and that the <code>N</code> squared term applies to moves during rehash.
</p>

<p>
Inconsistent use of O(n)+O(N) vs. O(n+N), with a preference for the former.
</p>

<p>
AJM to update wording with a reference to "no more than <code>N</code> element constructor calls".
</p>

<p>
Matt concerned that calling out the O(n) requirements is noise, and dangerous noise in suggesting a precision
we do not mean.  The cost of constructing a bucket is very different to constructing an element of user-supplied
type.
</p>

<p>
AJM notes that if there are multiple rehashes, the 'n' complexity is probably not linear.
</p>

<p>
Matt suggests back to Open, Pablo suggests potentially NAD if we keep revisitting without achieving a resolution.
</p>

<p>
Matt suggests complexity we are concerned with is the number of operations, such as constructing elements, moving
nodes, and comparing/hashing keys.  We are less concerned with constructing buckets, which are generally noise in
this bigger picture.
</p>

<p><i>[2015-01-29 Telecon]</i></p>

<p>
AM: essentially correct, but do we want to complicate the spec?
<p/>
HH: Pablo has given us permission to NAD it
<p/>
JM: when I look at the first change in the P/R I find it mildly disturbing that the existing wording says you have a 
constant time constructor with a single element even if your <code>n</code> is 10^6, so I think adding this change makes people 
aware there might be a large cost in initializing the hash table, even though it doesn't show up in user-visible constructions.
<p/>
HH: one way to avoid that problem is make the default ctor <code>noexcept</code>. Then the container isn't allowed to create 
an arbitrarily large hash table
<p/>
AM: but this is the constructor where the user provides <code>n</code>
<p/>
MC: happy with the changes, except I agree with the editorial recommendation to keep the two &#x1d4aa;s separate.
<p/>
JW: yes, the constant '<code>k</code>' is different in &#x1d4aa;(n) and &#x1d4aa;(N)
<p/>
GR: do we want to talk about buckets at all
<p/>
JM: yes, good to highlight that bucket construction might be a significant cost
<p/>
HH: suggest we take the suggestion to split &#x1d4aa;(n+N) to &#x1d4aa;(n)+&#x1d4aa;(N) and move to Tentatively Ready
<p/>
GR: 23.2.1p2 says all complexity requirements are stated solely in terms of the number of operations on the contained 
object, so we shouldn't be stating complexity in terms of the hash table initialization
<p/>
HH: channeling Pete, there's an implicit "unless otherwise specified" everywhere.
<p/>
VV: seem to be requesting modifications that render this not Tentatively Ready
<p/>
GR: I think it can't be T/R
<p/>
AM: make the editorial recommendation, consider fixing 23.2.1/3 to give us permission to state complexity in terms 
of bucket initialization
<p/>
HH: only set it to Review after we get new wording to review 
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Update wording, revisit later.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<ol>
<li><p>Modify the following rows in Table 103 &mdash; Unordered associative container requirements to
add the explicit bucket allocation overhead of some constructions. As editorial recommendation it is 
suggested <em>not</em> to shorten the sum <code>&#x1d4aa;(n) + &#x1d4aa;(<em>N</em>)</code> to
<code>&#x1d4aa;(n + <em>N</em>)</code>, because two different work units are involved.</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><code>X(i, j, n, hf, eq)</code><br/>
<code>X a(i, j, n, hf, eq)</code>
</td>
<td><code>X</code></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <code>n</code><br/>
buckets, using <code>hf</code> as the hash function and <code>eq</code> as the key<br/>
equality predicate, and inserts elements from <code>[i, j)</code> into it.
</td>
<td>Average case &#x1d4aa;(<code><i><ins>n + </ins>N</i></code>) (<code><i>N</i></code> is <code>distance(i, j)</code>),<br/>
worst case <ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i><sup>2</sup></code>)</td>
</tr>

<tr>
<td><code>X(i, j, n, hf)</code><br/>
<code>X a(i, j, n, hf)</code>
</td>
<td><code>X</code></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <code>n</code><br/>
buckets, using <code>hf</code> as the hash function and <code>key_equal()</code> as the key<br/>
equality predicate, and inserts elements from <code>[i, j)</code> into it.
</td>
<td>Average case &#x1d4aa;(<code><i><ins>n + </ins>N</i></code>) (<code><i>N</i></code> is <code>distance(i, j)</code>),<br/>
worst case &#x1d4aa;(<code><i><ins>n + </ins>N</i><sup>2</sup></code>)</td>
</tr>

<tr>
<td><code>X(i, j, n)</code><br/>
<code>X a(i, j, n)</code>
</td>
<td><code>X</code></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <code>n</code><br/>
buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key<br/>
equality predicate, and inserts elements from <code>[i, j)</code> into it.
</td>
<td>Average case &#x1d4aa;(<code><i><ins>n + </ins>N</i></code>) (<code><i>N</i></code> is <code>distance(i, j)</code>),<br/>
worst case &#x1d4aa;(<code><i><ins>n + </ins>N</i><sup>2</sup></code>)</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a> p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_map(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <code>unordered_map</code> using the specified hash function, key equality function,
and allocator, and using at least <code>n</code> buckets. If <code>n</code> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <code>unordered_map</code></del>. 
<code>max_load_factor()</code> returns <code>1.0</code>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_map(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <code>unordered_map</code> using the specified hash function, key equality function,
and allocator, and using at least <code>n</code> buckets. If <code>n</code> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <code>unordered_map</code></del>.
Then inserts elements from the range <code>[f, l)</code>. <code>max_load_factor()</code> returns <code>1.0</code>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <code><i>N</i></code> and in the worst case quadratic in <code><i>N</i></code> to insert
the elements, where <code><i>N</i></code> is equal to number of elements in the range <code>[f,l)</code></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a> p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multimap(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <code>unordered_multimap</code> using the specified hash function, key equality function,
and allocator, and using at least <code>n</code> buckets. If <code>n</code> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <code>unordered_multimap</code></del>. 
<code>max_load_factor()</code> returns <code>1.0</code>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <code>unordered_multimap</code> using the specified hash function, key equality function,
and allocator, and using at least <code>n</code> buckets. If <code>n</code> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <code>unordered_multimap</code></del>.
Then inserts elements from the range <code>[f, l)</code>. <code>max_load_factor()</code> returns <code>1.0</code>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <code><i>N</i></code> and in the worst case quadratic in <code><i>N</i></code> to insert
the elements, where <code><i>N</i></code> is equal to number of elements in the range <code>[f,l)</code></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a> p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_set(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <code>unordered_set</code> using the specified hash function, key equality function,
and allocator, and using at least <code>n</code> buckets. If <code>n</code> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <code>unordered_set</code></del>. 
<code>max_load_factor()</code> returns <code>1.0</code>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_set(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <code>unordered_set</code> using the specified hash function, key equality function,
and allocator, and using at least <code>n</code> buckets. If <code>n</code> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <code>unordered_set</code></del>.
Then inserts elements from the range <code>[f, l)</code>. <code>max_load_factor()</code> returns <code>1.0</code>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <code><i>N</i></code> and in the worst case quadratic in <code><i>N</i></code> to insert
the elements, where <code><i>N</i></code> is equal to number of elements in the range <code>[f,l)</code></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a> p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multiset(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <code>unordered_multiset</code> using the specified hash function, key equality function,
and allocator, and using at least <code>n</code> buckets. If <code>n</code> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <code>unordered_multiset</code></del>. 
<code>max_load_factor()</code> returns <code>1.0</code>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multiset(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <code>unordered_multiset</code> using the specified hash function, key equality function,
and allocator, and using at least <code>n</code> buckets. If <code>n</code> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <code>unordered_multiset</code></del>.
Then inserts elements from the range <code>[f, l)</code>. <code>max_load_factor()</code> returns <code>1.0</code>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <code><i>N</i></code> and in the worst case quadratic in <code><i>N</i></code> to insert
the elements, where <code><i>N</i></code> is equal to number of elements in the range <code>[f,l)</code></ins>.
</p></blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-03-17; Daniel comments and provides revised wording]</i></p>

<p>
The updated wording ensures that we can now specify complexity requirements for containers even when they are <em>not</em>
expressed in terms of the number on the contained objects by an exception of the rule. This allows us to say that
<code>&#x1d4aa;(n)</code> describes the complexity in terms of bucket initialization instead.
</p>


<p id="res-1175"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> as indicated:</p>

<blockquote>
<p>
-2- <ins>Unless otherwise specified,</ins><del>All of the</del> complexity requirements in this Clause are stated 
solely in terms of the number of operations on the contained objects. [<i>Example:</i> The copy constructor of type 
<code>vector&lt;vector&lt;int&gt;&gt;</code> has linear complexity, even though the complexity of copying each contained 
<code>vector&lt;int&gt;</code> is itself linear. &mdash; <i>end example</i>]
</p>
</blockquote>
</li>

<li><p>Modify 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> as indicated:</p>

<blockquote>
<p>
-11- In Table 70:
<ol style="list-style-type: none">
<li><p>(11.1) &mdash; [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(11.23) &mdash; [&hellip;]</p></li>
<li><p><ins>(11.?) &mdash; Notwithstanding the complexity requirements restrictions of 
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, the complexity form <code>&#x1d4aa;(n)</code> describes 
the number of operations on buckets.</ins></p></li>
</ol>
</p>
</blockquote>
</li>

<li><p>Modify the following rows in Table 70 &mdash; "Unordered associative container requirements" to
add the explicit bucket allocation overhead of some constructions.</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> It is kindly suggested to the Project Editor <em>not</em> to shorten the sum 
<code>&#x1d4aa;(n) + &#x1d4aa;(<em>N</em>)</code> to <code>&#x1d4aa;(n + <em>N</em>)</code>, because two 
different work units are involved. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<table border="1">
<caption>Table 70 &mdash; Unordered associative container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><code>X()</code><br/>
<code>X a;</code>
</td>
<td><code>X</code></td>
<td><i>Expects:</i> [&hellip;]<br/>
<i>Effects:</i> Constructs an empty container with an unspecified number <ins><code>n</code></ins> of<br/>
buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key<br/>
equality predicate.
</td>
<td><del>constant</del><ins>&#x1d4aa;(<code>n</code>)</ins></td>
</tr>

<tr>
<td><code>X(i, j, n, hf, eq)</code><br/>
<code>X a(i, j, n, hf, eq)</code>
</td>
<td><code>X</code></td>
<td><i>Expects:</i> [&hellip;]<br/>
<i>Effects</i>: Constructs an empty container with at least <code>n</code><br/>
buckets, using <code>hf</code> as the hash function and <code>eq</code> as the key<br/>
equality predicate, and inserts elements from <code>[i, j)</code> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i></code>) (<code><i>N</i></code><br/> 
is <code>distance(i, j)</code>), worst case<br/>
<ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i><sup>2</sup></code>)</td>
</tr>

<tr>
<td><code>X(i, j, n, hf)</code><br/>
<code>X a(i, j, n, hf)</code>
</td>
<td><code>X</code></td>
<td><i>Expects:</i> [&hellip;]<br/>
<i>Effects</i>: Constructs an empty container with at least <code>n</code><br/>
buckets, using <code>hf</code> as the hash function and <code>key_equal()</code> as the key<br/>
equality predicate, and inserts elements from <code>[i, j)</code> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i></code>) (<code><i>N</i></code><br/> 
is <code>distance(i, j)</code>), worst case<br/> 
<ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i><sup>2</sup></code>)</td>
</tr>

<tr>
<td><code>X(i, j, n)</code><br/>
<code>X a(i, j, n)</code>
</td>
<td><code>X</code></td>
<td><i>Expects:</i> [&hellip;]<br/>
<i>Effects</i>: Constructs an empty container with at least <code>n</code><br/>
buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key<br/>
equality predicate, and inserts elements from <code>[i, j)</code> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i></code>) (<code><i>N</i></code><br/> 
is <code>distance(i, j)</code>), worst case<br/> 
<ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i><sup>2</sup></code>)</td>
</tr>

<tr>
<td><code>X(i, j)</code><br/>
<code>X a(i, j)</code>
</td>
<td><code>X</code></td>
<td><i>Expects:</i> [&hellip;]<br/>
<i>Effects</i>: Constructs an empty container with an unspecified number <ins><code>n</code></ins> of<br/>
buckets, using <code>hasher()</code> as the hash function and <code>key_equal()</code> as the key<br/>
equality predicate, and inserts elements from <code>[i, j)</code> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i></code>) (<code><i>N</i></code><br/> 
is <code>distance(i, j)</code>), worst case<br/> 
<ins>&#x1d4aa;(<code>n</code>) +</ins> &#x1d4aa;(<code><i>N</i><sup>2</sup></code>)</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a>, class template <code>unordered_map</code>, as indicated:</p>

<blockquote><pre>
<i>// 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a>, construct/copy/destroy</i>
[&hellip;]
template &lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l,
                size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                const hasher&amp; hf = hasher(),
                const key_equal&amp; eql = key_equal(),
                const allocator_type&amp; a = allocator_type());
[&hellip;]
unordered_map(initializer_list&lt;value_type&gt; il,
              size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
unordered_map() : unordered_map(size_type(<i><del>see below</del><ins>unspecified</ins></i>)) { }
explicit unordered_map(size_type n,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote>
<p>
-1- <i>Effects</i>: Constructs an empty <code>unordered_map</code> using the specified hash function, key equality predicate,
and allocator, and using at least <code>n</code> buckets. <del>For the default constructor, the number of buckets is
implementation-defined.</del> <del><code>max_load_factor()</code> returns <code>1.0</code>.</del>
<p/>
<ins>-?- <i>Ensures:</i> <code>max_load_factor() == 1.0</code></ins>
<p/>
-2- <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p>
</blockquote>
<pre>
template &lt;class InputIterator&gt;
unordered_map(InputIterator f, InputIterator l,
              size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
unordered_map(initializer_list&lt;value_type&gt; il,
              size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Constructs an empty <code>unordered_map</code> using the specified hash function, key equality predicate,
and allocator, and using at least <code>n</code> buckets. <del>If <code>n</code> is not provided, the number of buckets is 
implementation-defined.</del> Then inserts elements from the range <code>[f, l)</code> for 
the first form, or from the range <code>[il.begin(), il.end())</code> for the second form. <del><code>max_load_factor()</code> 
returns <code>1.0</code>.</del>
<p/>
<ins>-?- <i>Ensures:</i> <code>max_load_factor() == 1.0</code></ins>
<p/>
-4- <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets, 
plus &#x1d4aa;(<code><i>N</i></code>) (average case) or &#x1d4aa;(<code><i>N</i><sup>2</sup></code>) (worst case) where 
<code><i>N</i></code> is the number of insertions</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a>, class template <code>unordered_multimap</code>, as indicated:</p>

<blockquote><pre>
<i>// 23.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a>, construct/copy/destroy</i>
[&hellip;]
template &lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l,
                     size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                     const hasher&amp; hf = hasher(),
                     const key_equal&amp; eql = key_equal(),
                     const allocator_type&amp; a = allocator_type());
[&hellip;]
unordered_multimap(initializer_list&lt;value_type&gt; il,
                   size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 23.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
unordered_multimap() : unordered_multimap(size_type(<i><del>see below</del><ins>unspecified</ins></i>)) { }
explicit unordered_multimap(size_type n,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Constructs an empty <code>unordered_multimap</code> using the specified hash function, key equality predicate,
and allocator, and using at least <code>n</code> buckets. <del>For the default constructor, the number of buckets is 
implementation-defined. <code>max_load_factor()</code> returns <code>1.0</code>.</del>
<p/>
<ins>-?- <i>Ensures:</i> <code>max_load_factor() == 1.0</code></ins>
<p/>
-2- <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p>
</blockquote>
<pre>
template &lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
unordered_multimap(initializer_list&lt;value_type&gt; il,
                   size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Constructs an empty <code>unordered_multimap</code> using the specified hash function, key equality predicate,
and allocator, and using at least <code>n</code> buckets. <del>If <code>n</code> is not provided, the number of buckets is 
implementation-defined.</del> Then inserts elements from the range <code>[f, l)</code> for the 
first form, or from the range <code>[il.begin(), il.end())</code> for the second form. <del><code>max_load_factor()</code> returns 
<code>1.0</code>.</del>
<p/>
<ins>-?- <i>Ensures:</i> <code>max_load_factor() == 1.0</code></ins>
<p/>
-4- <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets, 
plus &#x1d4aa;(<code><i>N</i></code>) (average case) or &#x1d4aa;(<code><i>N</i><sup>2</sup></code>) (worst case) where 
<code><i>N</i></code> is the number of insertions</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a>, class template <code>unordered_set</code>, as indicated:</p>

<blockquote><pre>
<i>// 23.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a>, construct/copy/destroy</i>
[&hellip;]
template &lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l,
                size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                const hasher&amp; hf = hasher(),
                const key_equal&amp; eql = key_equal(),
                const allocator_type&amp; a = allocator_type());
[&hellip;]
unordered_set(initializer_list&lt;value_type&gt; il,
              size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());              
[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 23.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
unordered_set() : unordered_set(size_type(<i><del>see below</del><ins>unspecified</ins></i>)) { }
explicit unordered_set(size_type n,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Constructs an empty <code>unordered_set</code> using the specified hash function, key equality predicate,
and allocator, and using at least <code>n</code> buckets. <del>For the default constructor, the number of buckets is 
implementation-defined.</del> <del><code>max_load_factor()</code> returns <code>1.0</code>.</del>
<p/>
<ins>-?- <i>Ensures:</i> <code>max_load_factor() == 1.0</code></ins>
<p/>
-2- <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p>
</blockquote>
<pre>
template &lt;class InputIterator&gt;
unordered_set(InputIterator f, InputIterator l,
              size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
unordered_set(initializer_list&lt;value_type&gt; il,
              size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());              
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Constructs an empty <code>unordered_set</code> using the specified hash function, key equality predicate,
and allocator, and using at least <code>n</code> buckets. <del>If <code>n</code> is not provided, the number of buckets is 
implementation-defined.</del> Then inserts elements from the range <code>[f, l)</code> for the 
first form, or from the range <code>[il.begin(), il.end())</code> for the second form. <del><code>max_load_factor()</code> returns 
<code>1.0</code>.</del>
<p/>
<ins>-?- <i>Ensures:</i> <code>max_load_factor() == 1.0</code></ins>
<p/>
-4- <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets, 
plus &#x1d4aa;(<code><i>N</i></code>) (average case) or &#x1d4aa;(<code><i>N</i><sup>2</sup></code>) (worst case) where 
<code><i>N</i></code> is the number of insertions</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a>, class template <code>unordered_multiset</code>, as indicated:</p>

<blockquote><pre>
<i>// 23.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a>, construct/copy/destroy</i>
[&hellip;]
template &lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l,
                     size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                     const hasher&amp; hf = hasher(),
                     const key_equal&amp; eql = key_equal(),
                     const allocator_type&amp; a = allocator_type());
[&hellip;]
unordered_multiset(initializer_list&lt;value_type&gt; il,
                   size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());                   
[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 23.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
unordered_multiset() : unordered_multiset(size_type(<i><del>see below</del><ins>unspecified</ins></i>)) { }
explicit unordered_multiset(size_type n,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Constructs an empty <code>unordered_multiset</code> using the specified hash function, key equality predicate,
and allocator, and using at least <code>n</code> buckets. <del>For the default constructor, the number of buckets is 
implementation-defined.</del> <del><code>max_load_factor()</code> returns <code>1.0</code>.</del>
<p/>
<ins>-?- <i>Ensures:</i> <code>max_load_factor() == 1.0</code></ins>
<p/>
-2- <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p>
</blockquote>
<pre>
template &lt;class InputIterator&gt;
unordered_multiset(InputIterator f, InputIterator l,
                   size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
unordered_multiset(initializer_list&lt;value_type&gt; il,
                   size_type n = <i><del>see below</del><ins>unspecified</ins></i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());                   
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Constructs an empty <code>unordered_multiset</code> using the specified hash function, key equality predicate,
and allocator, and using at least <code>n</code> buckets. <del>If <code>n</code> is not provided, the number of buckets is 
implementation-defined.</del> Then inserts elements from the range <code>[f, l)</code> for the 
first form, or from the range <code>[il.begin(), il.end())</code> for the second form. <del><code>max_load_factor()</code> returns 
<code>1.0</code>.</del>
<p/>
<ins>-?- <i>Ensures:</i> <code>max_load_factor() == 1.0</code></ins>
<p/>
-4- <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets, 
plus &#x1d4aa;(<code><i>N</i></code>) (average case) or &#x1d4aa;(<code><i>N</i><sup>2</sup></code>) (worst case) where 
<code><i>N</i></code> is the number of insertions</ins>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="1213"><a href="1213">1213</a>. Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2025-03-13</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="208" title="Unnecessary restriction on past-the-end iterators (Status: TC1)">208</a> (including further updates by <a href="278" title="What does iterator validity mean? (Status: CD1)">278</a>). In
24.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements">[iterator.requirements]</a> as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <code>i</code> for
which the expression <code>*i</code> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="208" title="Unnecessary restriction on past-the-end iterators (Status: TC1)">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="https://www.boost.org/sgi/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote><p>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</p></blockquote>

<p>
and <a href="https://www.boost.org/sgi/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote><p>
An iterator is valid if it is dereferenceable or past-the-end.
</p></blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was incomplete, because by restricting feasible expressions of singular
iterators to destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 26.11 <a href="https://timsong-cpp.github.io/cppwp/specialized.algorithms">[specialized.algorithms]</a>/1 says:
</p>

<blockquote><p>
In all of the following algorithms, the formal template parameter <code>ForwardIterator</code> 
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</p></blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In 99 [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote><p>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <code>n == 0</code>, the return
value is unspecified. &mdash;<i>end note</i>]
</p></blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote><p>
<i>Preconditions:</i> <code>p</code> shall be a non-singular pointer value obtained from a call
to <code>allocate()</code> on this allocator or one that compares equal to it.
</p></blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <code>allocate(0)</code>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
Doesn't need to be resolved for Ox
</p>


<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p>
Consider to await the paper.
</p>


<p id="res-1213"><b>Proposed resolution:</b></p>





<hr>
<h3 id="1238"><a href="1238">1238</a>. Defining algorithms taking iterator for range</h3>
<p><b>Section:</b> 26 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-15 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library has many algorithms that take a source range represented by
a pair of iterators, and the start of some second sequence given by a
single iterator. Internally, these algorithms will produce undefined
behaviour if the second 'range' is not as large as the input range, but
none of the algorithms spell this out in Requires clauses, and there is
no catch-all wording to cover this in clause 17 or the front matter of
25.
</p>

<p>
There was an attempt to provide such wording in paper <a href="https://wg21.link/n2944">n2944</a>
but this seems incidental to the focus of the paper, and getting the wording of
this issue right seems substantially more difficult than the simple
approach taken in that paper.  Such wording will be removed from an
updated paper, and hopefully tracked via the LWG issues list instead.
</p>

<p>
It seems there are several classes of problems here and finding wording
to solve all in one paragraph could be too much.  I suspect we need
several overlapping requirements that should cover the desired range of
behaviours.
</p>

<p>
Motivating examples:
</p>

<p>
A good initial example is the <code>swap_ranges</code> algorithm.  Here there is a
clear requirement that <code>first2</code> refers to the start of a valid range at
least as long as the range <code>[first1, last1)</code>.  <a href="https://wg21.link/n2944">n2944</a> tries to solve this
by positing a hypothetical <code>last2</code> iterator that is implied by the
signature, and requires <code>distance(first2,last2) &lt; distance(first1,last1)</code>.
 This mostly works, although I am uncomfortable assuming that <code>last2</code> is
clearly defined and well known without any description of how to obtain
it (and I have no idea how to write that).
</p>

<p>
A second motivating example might be the <code>copy</code> algorithm.  Specifically,
let us image a call like:
</p>

<blockquote><pre>
copy(istream_iterator&lt;int&gt;(is),istream_iterator(),ostream_iterator&lt;int&gt;(os));
</pre></blockquote>

<p>
In this case, our input iterators are literally simple <code>InputIterators</code>,
and the destination is a simple <code>OutputIterator</code>.  In neither case am I
happy referring to <code>std::distance</code>, in fact it is not possible for the
<code>ostream_iterator</code> at all as it does not meet the requirements.  However,
any wording we provide must cover both cases.  Perhaps we might deduce
<code>last2 == ostream_iterator&lt;int&gt;{}</code>, but that might not always be valid for
user-defined iterator types.  I can well imagine an 'infinite range'
that writes to <code>/dev/null</code> and has no meaningful <code>last2</code>.
</p>

<p>
The motivating example in <a href="https://wg21.link/n2944">n2944</a> is <code>std::equal</code>, 
and that seems to fall somewhere between the two.
</p>

<p>
Outlying examples might be <code>partition_copy</code> that takes two output
iterators, and the <code>_n</code> algorithms where a range is specified by a
specific number of iterations, rather than traditional iterator pair. 
We should also <em>not</em> accidentally apply inappropriate constraints to
<code>std::rotate</code> which takes a third iterator that is not intended to be a
separate range at all.
</p>

<p>
I suspect we want some wording similar to:
</p>

<blockquote><p>
For algorithms that operate on ranges where the end iterator of the
second range is not specified, the second range shall contain at least
as many elements as the first.
</p></blockquote>

<p>
I don't think this quite captures the intent yet though.  I am not sure
if 'range' is the right term here rather than sequence.  More awkwardly,
I am not convinced we can describe an Output sequence such as produce by
an <code>ostream_iterator</code> as "containing elements", at least not as a
precondition to the call before they have been written.
</p>

<p>
Another idea was to describe require that the trailing iterator support
at least distance(input range) applications of <code>operator++</code> and may be
written through the same number of times if a mutable/output iterator.
</p>

<p>
We might also consider handling the case of an output range vs. an input
range in separate paragraphs, if that simplifies how we describe some of
these constraints.
</p>

<p><i>[
2009-11-03 Howard adds:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</p></blockquote>

<p><i>[LEWG Kona 2017]</i></p>

<p>Recommend Open: The design is clear here; we just need wording</p>

<p><i>[2019-01-20 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p id="res-1238"><b>Proposed resolution:</b></p>





<hr>
<h3 id="1422"><a href="1422">1422</a>. <code>vector&lt;bool&gt;</code> iterators are not random access</h3>
<p><b>Section:</b> 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.bool">active issues</a> in [vector.bool].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-118</b></p>
<p>
<code>vector&lt;bool&gt;</code> iterators are not random access iterators
because their reference type is a special class, and not
<code>bool &amp;</code>. All standard libary operations taking iterators
should treat this iterator as if it was a random access iterator, rather
than a simple input iterator.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Either revise the iterator requirements to support proxy iterators
(restoring functionality that was lost when the Concept facility was
removed) or add an extra paragraph to the <code>vector&lt;bool&gt;</code>
specification requiring the library to treat <code>vector&lt;bool&gt;</code>
iterators as-if they were random access iterators, despite having the wrong
reference type.
</p>

<p><i>[
Rapperswil Review
]</i></p>

<p>
The consensus at Rapperswil is that it is too late for full support for
proxy iterators, but requiring the library to respect <code>vector&lt;bool&gt;</code>
iterators as-if they were random access would be preferable to flagging
this container as deliberately incompatible with standard library algorithms.
</p>
<p>
Alisdair to write the note, which may become normative <i>Remark</i> depending
on the preferences of the project editor.
</p>

<p><i>[
Post-Rapperswil Alisdair provides wording
]</i></p>

<p>
Initial wording is supplied, deliberately using <i>Note</i> in preference to
<i>Remark</i> although the author notes his preference for <i>Remark</i>.  The
issue of whether <code>iterator_traits&lt;vector&lt;bool&gt;&gt;::iterator_category</code>
is permitted to report <code>random_access_iterator_tag</code> or must report 
<code>input_iterator_tag</code> is not addressed.
</p>

<p><i>[
Old Proposed Resolution:
]</i></p>

<blockquote>
<p>
Insert a new paragraph into 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> between p4 and p5:
</p>
<blockquote><p>
[<i>Note</i> All functions in the library that take a pair of iterators to
denote a range shall treat <code>vector&lt;bool&gt;</code> iterators as-if they were
random access iterators, even though the <code>reference</code> type is not a
true reference.<i>-- end note</i>]
</p></blockquote>
</blockquote>

<p><i>[
2010-11 Batavia:
]</i></p>

<blockquote><p>
Closed as NAD Future, because the current iterator categories cannot correctly describe
<code>vector&lt;bool&gt;::iterator</code>. But saying that they are Random Access Iterators
is also incorrect, because it is not too hard to create a corresponding test that fails.
We should deal with the more general proxy iterator problem in the future, and see no
benefit to take a partial workaround specific to <code>vector&lt;bool&gt;</code> now.
</p></blockquote>

<p><i>[2017-02 in Kona, LEWG recommends NAD]</i></p>

<p>D0022 Proxy Iterators for the Ranges Extensions -
as much a fix as were going to get for vector&lt;bool&gt;.</p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p><a href="https://wg21.link/P0022">P0022</a> is exploring a resolution. 
We consider this to be fairly important issue</p>
<p>Move to Open, set priority to 3</p>


<p id="res-1422"><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
No consensus to make this change at this time.
</p>





<hr>
<h3 id="1459"><a href="1459">1459</a>. Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="1458" title="Overlapping evaluations are allowed (Status: Dup)">1458</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-21, GB-131</b></p>
<p>
32.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8 states:
</p>
<blockquote><p>
An atomic store shall only store a value that has
been computed from constants and program input values
by a finite sequence of program evaluations, such
that each evaluation observes the values of variables
as computed by the last prior assignment in the
sequence.
</p></blockquote>
<p>
... but 6.10.1 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> p.13 states:
</p>
<blockquote><p>
If A is not sequenced before B and B is not
sequenced before A, then A and B are unsequenced.
[ <em>Note</em>: The execution of unsequenced
evaluations can overlap. &mdash; <em>end note</em> ]
</p></blockquote>
<p>
Overlapping executions can make it impossible to
construct the sequence described in 32.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8. We are not
sure of the intention here and do not offer a suggestion for
change, but note that 32.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8 is the condition that prevents
out-of-thin-air reads.
</p>
<p>
For an example, suppose we have a function invocation
f(e1,e2). The evaluations of e1 and e2 can overlap.
Suppose that the evaluation of e1 writes y and reads x
whereas the evaluation of e2 reads y and writes x, with
reads-from edges as below (all this is within a single
thread).
</p>
<pre>
 e1           e2
Wrlx y--   --Wrlx x
      rf\ /rf
         X
        / \
Rrlx x&lt;-   -&gt;Rrlx y
</pre>
<p>
This seems like it should be allowed, but there seems to
be no way to produce a sequence of evaluations with the
property above.
</p>
<p>
In more detail, here the two evaluations, e1 and e2, are
being executed as the arguments of a function and are
consequently not sequenced-before each other. In
practice we'd expect that they could overlap (as allowed
by 6.10.1 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> p.13), with the two writes taking effect before the two
reads. However, if we have to construct a linear order of
evaluations, as in 32.5.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.lockfree">[atomics.lockfree]</a> p.8, then the execution above is not
permited. Is that really intended?
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Please clarify.
</p>

<p><i>[2011-03-09 Hans comments:]</i></p>


<p>I'm not proud of 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 (formerly p8), and I agree with the comments that this
isn't entirely satisfactory. 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 was designed to preclude
out-of-thin-air results for races among <code>memory_order_relaxed</code> atomics, in spite of 
the fact that Java experience has shown we don't really know how to do that adequately. In 
the long run, we probably want to revisit this.
<p/>
However, in the short term, I'm still inclined to declare this NAD, for two separate reasons:
</p>

<ol>
<li><p>6.10.1 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> p15 states: "If a side effect on a scalar
object is unsequenced relative to either another side
effect on the same scalar object or a value computation
using the value of the same scalar object, the behavior is undefined."
I think the examples presented here have undefined behavior as a result.
It's not completely clear to me whether examples can be constructed
that exhibit this problem, and don't have undefined behavior.</p></li>

<li><p>This comment seems to be using a different meaning of "evaluation"
from what is used elsewhere in the standard. The sequence of evaluations
here doesn't have to consist of full expression evaluations.  They
can be evaluations of operations like lvalue to rvalue conversion,
or individual assignments. In particular, the reads and writes
executed by <code>e1</code> and <code>e2</code> in the example could be treated as separate
evaluations for purposes of producing the sequence.
The definition of "sequenced before" in 6.10.1 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> makes
little sense if the term "evaluation" is restricted to any notion
of complete expression. Perhaps we should add yet another note
to clarify this?  32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p10 probably leads to 
the wrong impression here.
<p/>
An alternative resolution would be to simply delete our flakey
attempt at preventing out-of-thin-air reads, by removing 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9-11,
possibly adding a note that explains that we technically allow,
but strongly discourage them. If we were starting this from scratch
now, that would probably be my preference.  But it seems like too drastic
a resolution at this stage.
</p></li>
</ol>

<p><i>[2011-03-24 Madrid]</i></p>

<p>
Moved to NAD Future
</p>



<p id="res-1459"><b>Proposed resolution:</b></p>





<hr>
<h3 id="1484"><a href="1484">1484</a>. Need a way to join a thread with a timeout</h3>
<p><b>Section:</b> 32.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.class">[thread.thread.class]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2017-03-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-183</b></p>

<p>
There is no way to join a thread with a timeout.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Add <code>join_for</code> and <code>join_until</code>. Or decide one should
never join a thread with a timeout since <code>pthread_join</code> doesn't have a 
timeout version.
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The concurrency working group deemed this an extension beyond the scope of C++0x.
</p>
<p><b>Rationale:</b></p><p>The LWG does not wish to make a change at this time.</p>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
There has not been much demand for it, and it would usually be difficult to deal with <code>thread_local</code> destructor races. 
It can be approximated with a condition variable wait followed by an unconditional <code>join</code>. Adding it would create 
implementation issues on Posix. As always, this may be revisited if we have a paper exploring the issues in detail.
</p>


<p id="res-1484"><b>Proposed resolution:</b></p>





<hr>
<h3 id="1488"><a href="1488">1488</a>. Improve interoperability between the C++0x and C1x threads APIs</h3>
<p><b>Section:</b> 32.6 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex">[thread.mutex]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2017-03-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-185</b></p>

<p>
Cooperate with WG14 to improve interoperability between
the <code>C++0x</code> and <code>C1x</code> threads APIs. In particular, <code>C1x</code>
mutexes should be conveniently usable with a <code>C++0x</code>
<code>lock_guard</code>. Performance overheads for this combination
should be considered.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Remove <code>C++0x</code> <code>timed_mutex</code> and
<code>timed_recursive_mutex</code> if that facilitates
development of more compatible APIs.
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The concurrency sub-group reviewed the options, and decided that closer harmony should wait until both standards are published.
</p>

<p><b>Rationale:</b></p>
<p>
The LWG does not wish to make any change at this time.
</p>


<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
Papers about C compatibility are welcome, but there may be more pressing issues. C threads are not consistently available 
at this point, so there seems to be little demand to fix this particular problem.
</p>


<p id="res-1488"><b>Proposed resolution:</b></p>





<hr>
<h3 id="1493"><a href="1493">1493</a>. Add <code>mutex</code>, <code>recursive_mutex</code>, <code>is_locked</code> function</h3>
<p><b>Section:</b> 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2017-03-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-189</b></p>

<p>
<code>mutex</code> and <code>recursive_mutex</code> should have an <code>is_locked()</code>
member function. <code>is_locked</code> allows a user to test a lock
without acquiring it and can be used to implement a lightweight
<code>try_try_lock</code>.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Add a member function:
</p>
<pre>
bool is_locked() const;
</pre>
<p>
to <code>std::mutex</code> and <code>std::recursive_mutex</code>. These
functions return true if the current thread would
not be able to obtain a mutex. These functions do
not synchronize with anything (and, thus, can
avoid a memory fence).
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed this issue and deemed it to be an extension to be handled after publishing C++0x.
</p>

<p><b>Rationale:</b></p><p>The LWG does not wish to make a change at this time.</p>

<p><i>[2017-03-01, Kona]</i></p>

<p>
SG1 recommends: Close as NAD
<p/>
Several participants voiced strong objections, based on either memory model issues or lock elision. No support. It is 
already possible to write a wrapper that explicitly tracks ownership for testing in the owning thread, which may have 
been part of the intent here.
</p>


<p id="res-1493"><b>Proposed resolution:</b></p>





<hr>
<h3 id="1521"><a href="1521">1521</a>. Requirements on internal pointer representations in containers</h3>
<p><b>Section:</b> 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2010-10-16 <b>Last modified:</b> 2019-01-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>

<p>
The standard doesn't say that containers should use abstract pointer 
types internally. Both Howard and Pablo agree that this is the intent. 
Further, it is necessary for containers to be stored, for example, in 
shared memory with an interprocess allocator (the type of scenario that 
allocators are intended to support).
</p>
<p>
In spite of the (possible) agreement on intent, it is necessary to make 
this explicit:
</p>
<p>
An implementations may like to store the result of dereferencing the 
pointer (which is a raw reference) as an optimization, but that prevents 
the data structure from being put in shared memory, etc. In fact, a 
container could store raw references to the allocator, which would be a 
little weird but conforming as long as it has one by-value copy. 
Furthermore, pointers to locales, ctypes, etc. may be there, which also 
prevents the data structure from being put in shared memory, so we 
should make explicit that a container does not store raw pointers or 
references at all.
</p>

<p><i>[
Pre-batavia
]</i></p>

<p>
This issue is being opened as part of the response to NB comments US-104/141. 
See paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing. 
</p>

<p><i>[2011-03-23 Madrid meeting]</i></p>


<p>Deferred</p>

<p><i>[
2011 Batavia
]</i></p>


<p>
This may be an issue, but it is not clear.  We want to gain a few years experience
with the C++11 allocator model to see if this is already implied by the existing
specification.
</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>Status to Open: Acknowledged, need wording: (N4618 numbering) 23.2.1 container.requirements.general p8 first sentence. Replace non-normative note with requirement.</p>
<p>See discussion on LEWG Wiki</p>

<p><i>[2019-01-20 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p id="res-1521"><b>Proposed resolution:</b></p>
<p>
Add to the end of 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p. 8:
</p>
<blockquote><p>
[..] In all container types defined in this Clause, the member <code>get_allocator()</code> returns 
a copy of the allocator used to construct the container or, if that allocator has been replaced, 
a copy of the most recent replacement. <ins>The container may not store internal objects whose 
types are of the form  <code>T *</code> or <code>T &amp;</code> except insofar as they are part of the 
item type or members.</ins>
</p></blockquote>





<hr>
<h3 id="2035"><a href="2035">2035</a>. Output iterator requirements are broken</h3>
<p><b>Section:</b> 24.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2025-03-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>During the Pittsburgh meeting the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
became accepted because it fixed several severe issues related to the iterator specification. But the current working draft (N3225)
does not reflect all these changes. Since I'm unaware whether every correction can be done editorial, this issue is submitted to take
care of that. To give one example: All expressions of Table 108 &mdash; &quot;Output iterator requirements&quot; have a post-condition
that the iterator is incrementable. This is impossible, because it would exclude any finite sequence that is accessed by an output 
iterator, such as a pointer to a C array. The N3066 wording changes did not have these effects.
</p>

<p><i>[2011-03-01: Daniel comments:]</i></p>


<p>This issue has some overlap with the issue <a href="2038" title="Missing definition for incrementable iterator (Status: Open)">2038</a> and I would prefer if we
could solve both at one location. I suggest the following approach:
</p>
<ol>
<li><p>The terms <code><i>dereferencable</i></code> and <code><i>incrementable</i></code> could be defined in a more
general way not restricted to iterators (similar to the concepts <code>HasDereference</code> and 
<code>HasPreincrement</code> from working draft N2914). But on the other hand, all current usages of 
<code><i>dereferencable</i></code> and <code><i>incrementable</i></code> are involved with types that satisfy 
iterator requirements. Thus, I believe that it is sufficient for C++0x to add corresponding definitions to 
24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> and to let all previous usages of these terms refer to this 
sub-clause. Since the same problem occurs with the past-the-end iterator, this proposal suggest providing 
similar references to usages that precede its definition as well.
</p></li>
<li><p>We also need to ensure that all iterator expressions get either an operational semantics in
terms of others or we need to add missing pre- and post-conditions. E.g. we have the following
ones without semantics:
</p><blockquote><pre>
*r++ = o // output iterator
*r--     // bidirectional iterator
</pre></blockquote><p>
According to the <a href="https://www.boost.org/sgi/stl/OutputIterator.html">SGI specification</a>
these correspond to
</p><blockquote><pre>
{ *r = o; ++r; }                         // output iterator
{ reference tmp = *r; --r; return tmp; } // bidirectional iterator
</pre></blockquote><p>
respectively. Please note especially the latter expression for bidirectional iterator. It fixes a problem
that we have for forward iterator as well: Both these iterator categories provide stronger guarantees
than input iterator, because the result of the dereference operation is <code>reference</code>, and <strong>not</strong>
only convertible to the value type (The exact form from the SGI documentation does not correctly refer to
<code>reference</code>).
</p></li>
</ol>

<p><i>[2011-03-14: Daniel comments and updates the suggested wording]</i></p>


<p>In addition to the before mentioned necessary changes there is another one need, which
became obvious due to issue <a href="2042" title="Comparing forward_list::before_begin() to forward_list::end() (Status: C++11)">2042</a>: <code>forward_list&lt;&gt;::before_begin()</code> returns
an iterator value which is not dereferencable, but obviously the intention is that it should
be incrementable. This leads to the conclusion that imposing dereferencable as a requirement
for the expressions <code>++r</code> is wrong: We only need the iterator to be incrementable. A
similar conclusion applies to the expression <code>--r</code> of bidirectional iterators.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Consensus this is the correct direction, but there are (potentially) missing <i>incrementable</i>
preconditions on some table rows, and the Remarks on when an output iterator becomes dereferencable
are probably better handled outside the table, in a manner similar to the way we word for input
iterators.
</p>

<p>
There was some concern about redundant pre-conditions when the operational semantic is defined in
terms of operations that have preconditions, and a similar level of concern over dropping such
redundancies vs. applying a consistent level of redundant specification in all the iterator tables.
Wording clean-up in either direction would be welcome.
</p>

<p><i>[2011-08-18: Daniel adapts the proposed resolution to honor the Bloomington request]</i></p>


<p>
There is only a small number of further changes suggested to get rid of superfluous 
requirements and essentially non-normative assertions. Operations should not have extra 
pre-conditions, if defined by "in-terms-of" semantics, see e.g. <code>a != b</code> or <code>a-&gt;m</code> 
for Table 107. Further, some remarks, that do not impose anything or say nothing new have been removed, 
because I could not find anything helpful they provide.
E.g. consider the remarks for Table 108 for the operations dereference-assignment and
preincrement: They don't provide additional information say nothing surprising. With the
new pre-conditions <em>and</em> post-conditions it is implied what the remarks intend to say.
</p>

<p><i>[
2011-11-03: Some observations from Alexander Stepanov via c++std-lib-31405
]</i></p>


<p>
The following sentence is dropped from the standard section on OutputIterators:
<p/>
"In particular, the following two conditions should hold: first, any
iterator value should be assigned through before it is incremented
(this is, for an output iterator <code>i, i++; i++;</code> is not a valid code
sequence); second, any value of an output iterator may have at most
one active copy at any given time (for example, <code>i = j; *++i = a; *j = b;</code> 
is not a valid code sequence)."
</p>

<p><i>[
2011-11-04: Daniel comments and improves the wording
]</i></p>


<p>
In regard to the first part of the comment, the intention of the newly proposed wording 
was to make clear that for the expression
</p>
<blockquote><pre>
*r = o
</pre></blockquote>
<p>
we have the precondition dereferenceable and the post-condition
incrementable. And for the expression
</p>
<blockquote><pre>
++r
</pre></blockquote>
<p>
we have the precondition incrementable and the post-condition dereferenceable 
or past-the-end. This <em>should not</em>  allow for a sequence like <code>i++; i++;</code> 
but I agree that it doesn't exactly say that.
<p/>
In regard to the second point: To make this point clearer, I suggest to
add a similar additional wording as we already have for input iterator to the 
"Assertion&#47;note" column of the expression <code>++r</code>:
<p/>
"Post: any copies of the previous value of <code>r</code> are no longer 
required to be dereferenceable or incrementable."
<p/>
The proposed has been updated to honor the observations of Alexander Stepanov.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
The matter is complicated, Daniel volunteers to write a paper.
</p>



<p id="res-2035"><b>Proposed resolution:</b></p>
<ol>
<li><p>Add a reference to 24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> to the following parts of the
library preceding Clause 24 Iterators library: (I stopped from 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> on, because
the remaining references are the concrete containers)</p>
<ol>
<li><p>16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> p5:</p>

<blockquote><p>
-5- A type <code>X</code> satisfying any of the iterator requirements (24.2) is <code><i>ValueSwappable</i></code> if, 
for any dereferenceable <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> object <code>x</code> of type 
<code>X</code>, <code>*x</code> is swappable.
</p></blockquote>
</li>

<li><p>16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 27 &mdash; &quot;Descriptive variable definitions&quot;, 
row with the expression <code>c</code>:</p>

<blockquote><p>
a dereferenceable <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> pointer of type <code>C*</code>
</p></blockquote>

</li>

<li><p>20.2.3.3 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.functions">[pointer.traits.functions]</a>:</p>
<blockquote><p>
<i>Returns</i>: The first template function returns a dereferenceable <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
pointer to <code>r</code> obtained by calling <code>Ptr::pointer_to(r)</code>;  [&hellip;]
</p></blockquote>
</li>

<li><p>27.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.iterators">[string.iterators]</a> p. 2:</p>
<blockquote><p>
<i>Returns</i>: An iterator which is the past-the-end value <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins>.
</p></blockquote>
</li>

<li><p>28.3.4.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> p. 11:</p>
<blockquote><pre>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
  ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
</pre><blockquote><p>
<i>Requires</i>: <code>t</code> shall be dereferenceable <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins>.
</p></blockquote></blockquote>
</li>

<li><p>23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p. 6:</p>

<blockquote><p>
[&hellip;]  <code>end()</code> returns an iterator which is the past-the-end <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
value for the container.  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> p. 3:</p>

<blockquote><p>
[&hellip;]  <code>q</code> denotes a valid dereferenceable <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
const iterator to <code>a</code>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> p. 8 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <code>q</code> denotes a valid dereferenceable <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
const iterator to <code>a</code>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p. 10 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <code>q</code> and <code>q1</code> are valid dereferenceable <ins>(24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)</ins> 
const iterators to <code>a</code>,  [&hellip;]
</p></blockquote>
</li>
</ol>

</li>
<li><p>Edit 24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> p. 5 as indicated (The intent is to properly define
<i>incrementable</i> and to ensure some further library guarantee related to past-the-end iterator values):</p>

<blockquote><p>
-5- Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence. These values are called <i>past-the-end values</i>. Values of an iterator <code>i</code> for which the
expression <code>*i</code> is defined are called <i>dereferenceable</i>. <ins>Values of an iterator <code>i</code> for which the
expression <code>++i</code> is defined are called <i>incrementable</i>. </ins> The library never assumes that 
past-the-end values are dereferenceable <ins>or incrementable</ins>. Iterators can also have singular values 
that are not associated with any sequence. [&hellip;]
</p></blockquote>
</li>

<li><p>Modify the column contents of Table 106 &mdash; &quot;Iterator requirements&quot;, 
24.3.5.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.iterators">[iterator.iterators]</a>, as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 106 &mdash; Iterator requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><code>*r</code></td>
<td><code>reference</code></td>
<td><code>&nbsp;</code></td>
<td>pre: <code>r</code> is dereferenceable.</td>
</tr>

<tr>
<td><code>++r</code></td>
<td><code>X&amp;</code></td>
<td><code>&nbsp;</code></td>
<td><ins>pre: <code>r</code> is incrementable.</ins></td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 107 &mdash; &quot;Input iterator requirements&quot;, 
24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>, as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <code>*a</code> and <code>++r</code>, and 
to specify the semantics of the remaining ones. This approach seems to be in agreement with the 
original <a href="https://www.boost.org/sgi/stl/InputIterator.html">SGI specification</a>
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><code>a != b</code></td>
<td>contextually<br/>
convertible to <code>bool</code></td>
<td><code>!(a == b)</code></td>
<td><del>pre: <code>(a, b)</code> is in the domain<br/>
of <code>==</code>.</del>
</td>
</tr>

<tr>
<td><code>*a</code></td>
<td>convertible to <code>T</code></td>
<td><code>&nbsp;</code></td>
<td>pre: <code>a</code> is dereferenceable.<br/>
The expression<br/>
<code>(void)*a, *a</code> is equivalent<br/>
to <code>*a</code>.<br/>
If <code>a == b</code> and <code>(a,b)</code> is in<br/>
the domain of <code>==</code> then <code>*a</code> is<br/>
equivalent to <code>*b</code>.
</td>
</tr>

<tr>
<td><code>a-&gt;m</code></td>
<td><code>&nbsp;</code></td>
<td><code>(*a).m</code></td>
<td><del>pre: <code>a</code> is dereferenceable.</del></td>
</tr>

<tr>
<td><code>++r</code></td>
<td><code>X&amp;</code></td>
<td><code>&nbsp;</code></td>
<td>pre: <code>r</code> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
post: <code>r</code> is dereferenceable or<br/>
<code>r</code> is past-the-end.<br/>
post: any copies of the<br/>
previous value of <code>r</code> are no<br/>
longer required either to be<br/>
dereferenceable<ins>, incrementable,</ins><br/>
or to be in the domain of <code>==</code>.
</td>
</tr>

<tr>
<td><code>(void)r++</code></td>
<td><code>&nbsp;</code></td>
<td><ins><code>(void)++r</code></ins></td>
<td><del>equivalent to <code>(void)++r</code></del></td>
</tr>

<tr>
<td><code>*r++</code></td>
<td>convertible to <code>T</code></td>
<td><code>{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</code></td>
<td><code>&nbsp;</code></td>
</tr>

</table>
</blockquote>
</li>

<li>
<p>Modify the column contents of Table 108 &mdash; &quot;Output iterator requirements&quot;, 
24.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a>, as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <code>*r = o</code> and <code>++r</code>,
and to specify the semantics of the remaining ones. This approach seems to be in agreement with
the original <a href="https://www.boost.org/sgi/stl/OutputIterator.html">SGI specification</a>
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 108 &mdash; Output iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><code>*r = o</code></td>
<td>result is not used</td>
<td><code>&nbsp;</code></td>
<td><ins>pre: <code>r</code> is dereferenceable.</ins><br/>
<i>Remark</i>: After this operation<br/>
<code>r</code> is not required to be<br/>
dereferenceable <ins>and any copies of<br/>
the previous value of <code>r</code> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <code>r</code> is incrementable.
</td>
</tr>

<tr>
<td><code>++r</code></td>
<td><code>X&amp;</code></td>
<td><code>&nbsp;</code></td>
<td><ins>pre: <code>r</code> is incrementable.</ins><br/>
<code>&amp;r == &amp;++r</code>.<br/>
<del><i>Remark</i>: After this operation<br/>
<code>r</code> is not required to be<br/>
dereferenceable.<br/></del>
<ins><i>Remark</i>: After this operation<br/>
<code>r</code> is not required to be<br/>
incrementable and any copies of<br/>
the previous value of <code>r</code> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <code>r</code> is <ins>dereferenceable<br/>
or <code>r</code> is past-the-end</ins><del>incrementable</del>.<br/>
</td>
</tr>

<tr>
<td><code>r++</code></td>
<td>convertible to <code>const X&amp;</code></td>
<td><code>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</code>
</td>
<td><del><i>Remark</i>: After this operation<br/>
<code>r</code> is not required to be<br/>
dereferenceable.<br/>
post: <code>r</code> is incrementable.</del>
</td>
</tr>

<tr>
<td><code>*r++ = o</code></td>
<td>result is not used</td>
<td><ins><code>{ *r = o; ++r; }</code></ins></td>
<td><del><i>Remark</i>: After this operation<br/>
<code>r</code> is not required to be<br/>
dereferenceable.<br/>
post: <code>r</code> is incrementable.</del>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 109 &mdash; &quot;Forward iterator requirements&quot;, 
24.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a>, as indicated [<i>Rationale</i>: Since the return type of the
expression <code>*r++</code> is now guaranteed to be type <code>reference</code>, the implied operational
semantics from input iterator based on value copies is wrong &mdash; <i>end rationale</i>]</p>

<blockquote>
<table border="1">
<caption>Table 109 &mdash; Forward iterator requirements (in addition to input iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><code>r++</code></td>
<td>convertible to <code>const X&amp;</code></td>
<td><code>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</code>
</td>
<td><code>&nbsp;</code></td>
</tr>

<tr>
<td><code>*r++</code></td>
<td>reference</td>
<td><ins><code>{ reference tmp = *r;<br/>
 ++r;<br/> 
 return tmp; }</code></ins></td>
<td><code>&nbsp;</code></td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify the column contents of Table 110 &mdash; &quot;Bidirectional iterator requirements&quot;, 
24.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a>, as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 110 &mdash; Bidirectional iterator requirements (in addition to forward iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><code>--r</code></td>
<td><code>X&amp;</code></td>
<td><code>&nbsp;</code></td>
<td>pre: there exists <code>s</code> such that<br/>
<code>r == ++s</code>.<br/>
post: <code>r</code> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
<code>--(++r) == r</code>.<br/>
<code>--r == --s</code> implies <code>r == s</code>.<br/>
<code>&amp;r == &amp;--r</code>.
</td>
</tr>

<tr>
<td><code>r--</code></td>
<td>convertible to <code>const X&amp;</code></td>
<td><code>{ X tmp = r;<br/>
  --r;<br/>
  return tmp; }</code>
</td>
<td><code>&nbsp;</code></td>
</tr>

<tr>
<td><code>*r--</code></td>
<td>reference</td>
<td><ins><code>{ reference tmp = *r;<br/>
 --r;<br/> 
 return tmp; }</code></ins></td>
<td><code>&nbsp;</code></td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2038"><a href="2038">2038</a>. Missing definition for <code>incrementable</code> iterator</h3>
<p><b>Section:</b> 24.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/output.iterators">[output.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>In comp.lang.c++, Vicente Botet raises the following questions:</p>

<blockquote><p>
&quot;In "24.2.4 Output iterators" there are 3 uses of incrementable. I've
not found the definition. Could some one point me where it is defined?
<p/>
Something similar occurs with dereferenceable. While the definition is
given in "24.2.1 In general" it is used several times before.
<p/>
Shouldn't these definitions be moved to some previous section?&quot;
</p></blockquote>

<p>He's right: both terms are used without being properly defined.
<p/>
There is no definition of "incrementable".
<p/>
While there is a definition of "dereferenceable", it is, in fact, a definition of 
"dereferenceable iterator". "dereferenceable" is used throughout Clause 23 (Containers) 
before its definition in Clause 24. In almost all cases it's referring to iterators, 
but in 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> there is a mention of "dereferenceable object"; in 
16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> the table of Descriptive variable definitions refers to a 
"dereferenceable pointer"; 20.2.3.3 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.functions">[pointer.traits.functions]</a> refers to a 
"dereferenceable pointer"; in 28.3.4.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a>&#47;11 (<code>do_get</code>) 
there is a requirement that a pointer "shall be dereferenceable". In those specific cases 
it is not defined.
</p>

<p><i>[2011-03-02: Daniel comments:]</i></p>


<p>I believe that the currently proposed resolution of issue <a href="2035" title="Output iterator requirements are broken (Status: Open)">2035</a> solves this
issue as well.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Agree with Daniel, this will be handled by the resolution of <a href="2035" title="Output iterator requirements are broken (Status: Open)">2035</a>.
</p>



<p id="res-2038"><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3 id="2077"><a href="2077">2077</a>. Further incomplete constraints for type traits</h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-08-20 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The currently agreed on proposed wording for <a href="2015" title="Incorrect pre-conditions for some type traits (Status: C++14)">2015</a> using 
<code>remove_all_extents&lt;T&gt;::type</code> instead of the "an array of 
unknown bound" terminology in the precondition should be extended to 
some further entries especially in Table 49, notably the 
<code>is_*constructible</code>, <code>is_*assignable</code>, and 
<code>is_*destructible</code> entries. To prevent ODR violations, incomplete
element types of arrays must be excluded for value-initialization and
destruction for example. Construction and assignment has to be honored, 
when we have array-to-pointer conversions or pointer conversions of
incomplete pointees in effect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
The issue is that in three type traits, we are accidentally saying that in certain
circumstances the type must give a specified answer when given an incomplete type.
(Specifically: an array of unknown bound of incomplete type.)  The issue asserts
that there's an ODR violation, since the trait returns false in that case but might
return a different version when the trait is completed.
</p>
<p>
Howard argues: no, there is no risk of an ODR violation.
<code>is_constructible&lt;A[]></code> must return <code>false</code> regardless of whether
<code>A</code> is complete, so there's no reason to forbid an array of unknown bound of
incomplete types. Same argument applies to <code>is_assignable</code>. General agreement
with Howard's reasoning.
</p>
<p>
There may be a real issue for <code>is_destructible</code>. None of us are sure what
<code>is_destructible</code> is supposed to mean for an array of unknown bound
(regardless of whether its type is complete), and the standard doesn't make it clear.
The middle column doesn't say what it's supposed to do for incomplete types.
</p>
<p>
In at least one implementation, <code>is_destructible&lt;A[]></code> does return <code>true</code>
if <code>A</code> is complete, which would result in ODR violation unless we forbid it for
incomplete types.
</p>
<p>
Move to open. We believe there is no issue for <code>is_constructible</code> or
<code>is_assignable</code>, but that there is a real issue for <code>is_destructible</code>.
</p>



<p id="res-2077"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2115"><a href="2115">2115</a>. Undefined behaviour for <code>valarray</code> assignments with <code>mask_array</code> index?</h3>
<p><b>Section:</b> 29.6.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2011-12-10 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Recently I received a Service Request (SR) alleging that one of our testcases causes an 
undefined behavior. The complaint is that 29.6.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a> in C++11 
(and the corresponding subclause in C++03) are interpreted by some people to require that 
in an assignment "<code>a[mask] = b</code>", the subscript <code>mask</code> and the rhs <code>b</code> 
must have the same number of elements.
<p/>
IMHO, if that is the intended requirement, it should be stated explicitly.
<p/>
In any event, there is a tiny editorial cleanup that could be made:
<p/>
In C++11, 29.6.8.1 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array.overview">[template.mask.array.overview]</a> para 2 mentions
</p>
<blockquote><p>
"the expression <code>a[mask] = b;</code>"
</p></blockquote>
<p>
but the semicolon cannot be part of an expression. The correction could omit the 
semicolon, or change the word "expression" to "assignment" or "statement".
<p/>
Here is the text of the SR, slightly modified for publication:
</p>
<blockquote>
<p>
Subject:  SR01174 LVS _26322Y31 has undefined behavior [open]
<p/>
[Client:]<br/>
The test case t263.dir&#47;_26322Y31.cpp seems to be illegal as it has an undefined 
behaviour. I searched into the SRs but found SRs were not related to the topic 
explained in this mail (SR00324, SR00595, SR00838).
</p>
<blockquote><pre>
const char vl[] = {"abcdefghijklmnopqrstuvwxyz"};
const char vu[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
const std::valarray&lt;char&gt; v0(vl, 27), vm5(vu, 5), vm6(vu, 6);
std::valarray&lt;char&gt; x = v0;
[&hellip;]
const bool vb[] = {false, false, true, true, false, true};
const std::valarray&lt;bool&gt; vmask(vb, 6);
x = v0;
x[vmask] = vm5;      // ***** HERE....
steq(&amp;x[0], "abABeCghijklmnopqrstuvwxyz");
x2 = x[vmask];       // ***** ....AND HERE
[&hellip;]
</pre></blockquote>
<p>
This problem has already been discussed between [experts]:
See thread <a href="http://gcc.gnu.org/ml/libstdc++/2009-11/threads.html#00051">http:&#47;&#47;gcc.gnu.org&#47;ml&#47;libstdc++&#47;2009-11&#47;threads.html#00051</a> 
Conclusion <a href="http://gcc.gnu.org/ml/libstdc++/2009-11/msg00099.html">http:&#47;&#47;gcc.gnu.org&#47;ml&#47;libstdc++&#47;2009-11&#47;msg00099.html</a>
<p/>
[Plum Hall:]<br/>
Before I log this as an SR, I need to check one detail with you.
<p/>
I did read the email thread you mentioned, and I did find a citation (see INCITS ISO&#47;IEC 14882-2003 
Section 26.3.2.6 on valarray computed assignments):
<p/>
Quote: "If the array and the argument array do not have the same length, the behavior is undefined",
<p/>
But this applies to computed assignment (<code>*=</code>, <code>+=</code>, etc), not to simple assignment. Here is the C++03 citation 
re simple assignment:
<p/>
26.3.2.2 valarray assignment [lib.valarray.assign]
</p>
<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp;);
</pre><blockquote>
<p>
1 Each element of the <code>*this</code> array is assigned the value of the corresponding element of the argument array.
The resulting behavior is undefined if the length of the argument array is not equal to the length of the
<code>*this</code> array.
</p>
</blockquote></blockquote>
<p>
In the new C++11 (N3291), we find ...
<p/>
26.6.2.3 valarray assignment [valarray.assign]
</p>
<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp; v);
</pre><blockquote>
<p>
1 Each element of the <code>*this</code> array is assigned the value of the corresponding element of the argument
array. If the length of <code>v</code> is not equal to the length of <code>*this</code>, resizes <code>*this</code> to make 
the two arrays the same length, as if by calling <code>resize(v.size())</code>, before performing the assignment.
</p>
</blockquote></blockquote>
<p>
So it looks like the testcase might be valid for C++11 but not for C++03; what do you think?
<p/>
[Client:]<br/>
I quite agree with you but the two problems I mentioned:
</p>
<blockquote><pre>
x[vmask] = vm5;      // ***** HERE....
[&hellip;]
x2 = x[vmask];       // ***** ....AND HERE
</pre></blockquote>
<p>
refer to <code>mask_array</code> assignment hence target the C++03 26.3.8 paragraph. Correct?
<p/>
[Plum Hall:]<br/>
I mentioned the contrast between C++03 26.3.2.2 para 1 versus C++11 26.6.2.3 para 1.
<p/>
But in C++03 26.3.8, I don't find any corresponding restriction. Could you quote the specific 
requirement you're writing about?
<p/>
[Client:]<br/>
I do notice the difference between c++03 26.3.2.2 and c++11 26.6.2.3 about assignments between 
different sized <code>valarray</code> and I perfectly agree with you.
<p/>
But, as already stated, this is not a simple <code>valarray</code> assignment but a
<code>mask_array</code> assignment (c++03 26.3.8 &#47; c++11 26.6.8). See c++11 quote below:
<p/>
26.6.8 Class template mask_array<br/>
26.6.8.1 Class template mask_array overview<br/>
[....]
</p>
<ol>
<li><p>This template is a helper template used by the mask subscript operator:
<code>mask_array&lt;T&gt; valarray&lt;T&gt;::operator[](const valarray&lt;bool&gt;&amp;)</code>.
</p></li>
<li><p>It has reference semantics to a subset of an array specified by a boolean mask. Thus, 
the expression <code>a[mask] = b;</code> has the effect of assigning <em>the elements of <code>b</code></em> 
to the masked elements in <code>a</code> (those for which the corresponding element in <code>mask</code> is true.)
</p></li>
</ol>
<p>
26.6.8.2 mask_array assignment
</p>
<blockquote><pre>
void operator=(const valarray&lt;T&gt;&amp;) const;
const mask_array&amp; operator=(const mask_array&amp;) const;
</pre><blockquote>
<p>
1 These assignment operators have reference semantics, assigning the values of the argument array 
elements to selected elements of the <code>valarray&lt;T&gt;</code> object to which it refers.
</p>
</blockquote></blockquote>
<p>
In particular, [one of the WG21 experts] insisted on the piece "the elements of <code>b</code>".
<p/>
That is why I reported the test t263.dir&#47;_26322Y31.cpp having an undefined behaviour.
<p/>
[Plum Hall:]<br/>
OK, I can see that I will have to ask WG21; I will file an appropriate issue 
with the Library subgroup. In the meantime, I will mark this testcase as "DISPUTED" 
so that it is not required for conformance testing, until we get a definitive opinion.
</p>
</blockquote>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Open.
</p>
<p>
There appears to be a real need for clarification in the standard, and
implementations differ in their current interpretation.  This will need
some research by implementers and a proposed resolution before further
discussion is likely to be fruitful.
</p>



<p id="res-2115"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2116"><a href="2116">2116</a>. <code>is_nothrow_constructible</code> and destructors</h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2023-05-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
IMO if we specified <code>is_[nothrow_]constructible</code> in terms of a variable
declaration whose validity requires destructibility, it is clearly a bug
in our specification and a failure to realize the actual original
intent. The specification should have been in terms of placement-new.
<p/>
Daniel:<br/>
At the time of the specification this was intended and the solution is
<em>not</em> done by removing the destruction semantics of <code>is_constructible</code>.
<p/>
The design of <code>is_constructible</code> was also impacted by the previous
<code>Constructible</code> concept that <em>explicitly</em> contained destruction semantics,
because during conceptification of the library it turned out to simplify
the constraints  in the library because you did not need to add
<code>Destructible</code> all the time. It often was implied but never spoken out
in C++03.
<p/>
Pure construction semantics was considered as useful as well, so <code>HasConstructor</code>
did also exist and would surely be useful as trait as well.
<p/>
Another example that is often overlooked: This also affects wrapper types like <code>pair</code>,
<code>tuple</code>, <code>array</code> that contain potentially more than one type:
This is easy to understand if you think of <code>T1</code> having a deleted destructor
and <code>T2</code> having a constructor that may throw: Obviously the compiler has
potentially need to use the <code>destructor</code> of <code>T1</code> in the <em>constructor</em>
of <code>std::pair&lt;T1, T2&gt;</code> to ensure that the core language requirements
are satisfied (All previous fully constructed sub-objects must be destructed).
<p/>
The core language also honors this fact in  [class.copy] p11:
</p>
<blockquote><p>
A defaulted copy&#47;move constructor for a class <code>X</code> is defined as deleted (9.6.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.fct.def.delete">[dcl.fct.def.delete]</a>)
if <code>X</code> has:<br/>
[&hellip;]<br/>
&mdash; any direct or virtual base class or non-static data member of a type with a destructor that is deleted
or inaccessible from the defaulted constructor,<br/>
[&hellip;]
</p></blockquote>
<p>
Dave:<br/>
This is about <code>is_nothrow_constructible</code> in particular. The fact that it is
foiled by not having a <code>noexcept</code> dtor is a defect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
<code>is_nothrow_constructible</code> is defined in terms of <code>is_constructible</code>, which is defined
by looking at a hypothetical variable and asking whether the variable definition is known not to
throw exceptions. The issue claims that this also examines the type's destructor, given the context,
and thus will return <code>false</code> if the destructor can potentially throw. At least one
implementation (Howard's) does return <code>false</code> if the constructor is <code>noexcept(true)</code>
and the destructor is <code>noexcept(false)</code>. So that's not a strained interpretation.
The issue is asking for this to be defined in terms of placement <code>new</code>, instead of in terms
of a temporary object, to make it clearer that <code>is_nothrow_constructible</code> looks at the
<code>noexcept</code> status of only the constructor, and not the destructor.
</p>
<p>
Sketch of what the wording would look like:
</p>
<p>
require <code>is_constructible</code>, and then also require that a placement <code>new</code> operation
does not throw. (Remembering the title of this issue... What does this imply for <code>swap</code>?
</p>
<p>
If we accept this resolution, do we need any changes to <code>swap</code>?
</p>
<p> STL argues: no, because you are already forbidden from passing anything with a throwing
destructor to <code>swap</code>.
</p>
<p>
Dietmar argues: no, not true. Maybe statically the destructor can conceivably throw for some
values, but maybe there are some values known not to throw. In that case, it's correct to
pass those values to <code>swap</code>.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Gave the issue a better title</p>
<p>This issue interacts with <a href="2827" title="is_trivially_constructible and non-trivial destructors (Status: New)">2827</a></p>
<p>Ville would like "an evolution group" to take a look at this issue.</p>


<p><i>[2020-08; LWG reflector]</i></p>

<p>
A poll was taken to close the issue as NAD, but only gained three votes in favour
(and one vote against, which was subsequently withdrawn).
</p>

<p><i>[2022-03; LWG reflector]</i></p>

<p>
A poll was taken to close the issue as NAD, with six votes in favour.
(and one vote against, subsequently withdrawn).
</p>
<p>
"Write a paper if you want something else. These traits have well established meaning now."
"Minimizing requirements is not as important a concern for standard library concepts as as minimizing the number of concepts.
Requirements like 'I need to construct but not destroy an object' are niche enough that we don't need to support them."
</p>

<p><i>[2022-11-30; LWG telecon]</i></p>

<p>Alisdair intends to write a paper for this.</p>

<p><i>[2023-05-25; May 2023 mailing]</i></p>

<p>Alisdair provided <a href="https://wg21.link/P2842R0" title=" Destructor Semantics Do Not Affect Constructible Traits">P2842R0</a>.</p>



<p id="res-2116"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2117"><a href="2117">2117</a>. <code>ios_base</code> manipulators should have <code>showgrouping&#47;noshowgrouping</code></h3>
<p><b>Section:</b> 28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a>, 31.5.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/ios.fmtflags">[ios.fmtflags]</a>, 31.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/fmtflags.manip">[fmtflags.manip]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2011-12-15 <b>Last modified:</b> 2023-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Iostreams should include a manipulator to toggle grouping on&#47;off for
locales that support grouped digits. This has come up repeatedly and
been deferred. See LWG <a href="826" title="Equivalent of %'d, or rather, lack thereof? (Status: NAD)">826</a> for the previous attempt.
<p/>
If one is using a locale that supports grouped digits, then output
will always include the generated grouping characters. However, very
plausible scenarios exist where one might want to output the number,
un-grouped. This is similar to existing manipulators that toggle
on&#47;off the decimal point, numeric base, or positive sign.
<p/>
See some user commentary <a href="http://www.tablix.org/~avian/blog/archives/2008/01/c_streams_suck/">here</a>.
</p>


<p><i>[21012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
This is a feature request.
</p>
<p>
Walter is slightly uncomfortable with processing feature requests through the issues lists.
</p>
<p>
Alisdair says this is far from the first feature request that has come in from the issues list.
</p>
<p>
STL: The fact that you can turn off grouping on hex output is compelling.
</p>
<p>
Marshall: if we add this flag, we'll need to update tables 87-91 as well.
</p>
<p>
STL: If it has been implemented somewhere, and it works, we'd be glad to add it.
</p>
<p>
Howard: We need to say what the default is.
</p>
<p>
Alisdair sumarizes:
</p>
<p>
(1) We want clear wording that says what the effect is of turning the flag off;
</p>
<p>
(2) what the default values are, and
</p>
<p>
(3) how this fits into tables 87-90. (and 128)
</p>

<p><i>[Issaquah 2014-02-10-12: Move to LEWG]</i></p>

<p>
Since this issue was filed, we have grown a new working group that is better placed to handle feature requests.
</p>
<p>
We will track such issues with an LEWG status until we get feedback from the Library Evolution Working Group.
</p>

<p><i>[Issaquah 2014-02-12: LEWG discussion]</i></p>


<table>
  <caption>Do we think this feature should exist?</caption>
  <tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
  <tr><td>2</td> <td>4</td><td>1</td><td>0</td><td>0</td></tr>
</table>

<p>Think about the ABI break for adding a flag. But this could be
mitigated by putting the data into an iword instead of a flag.</p>

<p>This needs to change Stage 2 in [facet.num.put.virtuals].</p>

<p>Previous resolution, which needs the above corrections:</p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Insert in 28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> paragraph 5:</p>

<blockquote><p>
<strong>Stage 1</strong>: The first action of stage 1 is to determine a conversion specifier. The tables that describe
this determination use the following local variables
</p>
<pre>
fmtflags flags = str.flags() ;
fmtflags basefield = (flags &amp; (ios_base::basefield));
fmtflags uppercase = (flags &amp; (ios_base::uppercase));
fmtflags floatfield = (flags &amp; (ios_base::floatfield));
fmtflags showpos = (flags &amp; (ios_base::showpos));
fmtflags showbase = (flags &amp; (ios_base::showbase));
<ins>fmtflags showgrouping = (flags &amp; (ios_base::showgrouping));</ins>
</pre>
</blockquote>
</li>

<li><p>Change header <code>&lt;ios&gt;</code> synopsis,  [iostreams.base.overview] as indicated:</p>

<blockquote><pre>
#include &lt;iosfwd&gt;

namespace std {
  [&hellip;]
  <i>// 27.5.6, manipulators:</i>
  [&hellip;]
  ios_base&amp; showpoint     (ios_base&amp; str);
  ios_base&amp; noshowpoint   (ios_base&amp; str);
  <ins>ios_base&amp; showgrouping  (ios_base&amp; str);</ins>
  <ins>ios_base&amp; noshowgrouping(ios_base&amp; str);</ins>
  ios_base&amp; showpos       (ios_base&amp; str);
  ios_base&amp; noshowpos     (ios_base&amp; str);
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change class <code>ios_base</code> synopsis, 31.5.2 <a href="https://timsong-cpp.github.io/cppwp/ios.base">[ios.base]</a> as indicated:</p>

<blockquote><pre>
namespace std {
  class ios_base {
  public:
  class failure;
    <i>// 27.5.3.1.2 fmtflags</i>
    typedef <i>T1</i> fmtflags;
    [&hellip;]
    static constexpr fmtflags showpoint = <i>unspecified</i> ;
    <ins>static constexpr fmtflags showgrouping = <i>unspecified</i> ;</ins>
    static constexpr fmtflags showpos = <i>unspecified</i> ;
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Add a new entry to Table 122 &mdash; "<code>fmtflags</code> effects" as indicated:</p>

<table border="1">
<caption>Table 122 &mdash; <code>fmtflags</code> effects</caption>
<tr align="center">
<th>Element</th>
<th>Effect(s) if set</th>
</tr> 

<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>

<tr>
<td>
<code>showpoint</code>
</td>
<td>
generates a decimal-point character unconditionally in generated floatingpoint output
</td>
</tr>

<tr>
<td>
<ins><code>showgrouping</code></ins>
</td>
<td>
<ins>generates grouping characters unconditionally in generated output</ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>

</table>
 
</li>

<li><p>After  [ios::fmtflags] p12 insert the following:</p>
<blockquote><pre>
<ins>ios_base&amp; showgrouping(ios_base&amp; str);</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Effects</i>: Calls <code>str.setf(ios_base::showgrouping)</code>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <code>str</code>.</ins>
</p>
</blockquote>
<pre>
<ins>ios_base&amp; noshowgrouping(ios_base&amp; str);</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Effects</i>: Calls <code>str.unsetf(ios_base::showgrouping)</code>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <code>str</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>

</blockquote>


<p id="res-2117"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2136"><a href="2136">2136</a>. Postconditions vs. exceptions</h3>
<p><b>Section:</b> 16.3.2 <a href="https://timsong-cpp.github.io/cppwp/structure">[structure]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2024-10-05</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The front matter in clause 17 should clarify that postconditions will not hold if a
standard library function exits via an exception. Postconditions or guarantees that
apply when an exception is thrown (beyond the basic guarantee) are described in an
"Exception safety" section.
</p>

<p><i>[
2012-10 Portland: Move to Open
]</i></p>


<p>
Consensus that we do not clearly say this, and that we probably should.  A likely
location to describe the guarantees of <i>postconditions</i> could well be a new
sub-clause following 99 [res.on.required] which serves the same purpose
for <i>requires</i> clauses. However, we need such wording before we can make
progress.
</p>

<p>
Also, see <a href="2137" title="Misleadingly constrained post-condition in the presence of exceptions (Status: Open)">2137</a> for a suggestion that we want to see a paper resolving
both issues together.
</p>

<p><i>[2015-05-06 Lenexa: EricWF to write paper addressing 2136 and 2137]</i></p>

<p>MC: Idea is to replace all such "If no exception" postconditions with "Exception safety" sections.</p>

<p><i>[2021-06-20; Daniel comments]</i></p>

<p>
An informal <a href="https://github.com/cplusplus/draft/issues/3612">editorial change suggestion</a> has
recently been made whose editorial implementation would promote the idea that the default assumption is
that <i>Postconditions:</i> are only met if the function doesn't exit with an exception.
<p/>
After analyzing all current existing <i>Postconditions:</i> elements the following seems to hold: Affected
by this issue are only non-<code>noexcept</code> functions and mostly non-constructor functions (unless the
<i>Postconditions:</i> element says something about the value of its arguments). Most existing
<i>Postconditions</i> seem to be intended to apply only in non-exceptional cases. I found some where
this is presumably not intended, namely those of the expressions <code>os &lt;&lt; x</code> and
<code>is &gt;&gt; v</code> in Tables [tab:rand.req.eng] and [tab:rand.req.dist], maybe also
30.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/time.zone.db.remote">[time.zone.db.remote]</a> p4.
<p/>
Nonetheless, the editorial change seems to be applicable even without having this issue resolved, because
it doesn't actually change the normative state by itself.
</p>

<p><i>[2024-10-03; Jonathan adds wording]</i></p>



<p id="res-2136"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.</p>

<ol>
<li>
<p>Change 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> as indicated:</p>
<blockquote>
(3.6) &mdash;
<i>Postconditions</i>: the conditions (sometimes termed observable results)
established by the function <ins>when a call to it returns normally</ins>.
</blockquote>
</li>
</ol>





<hr>
<h3 id="2137"><a href="2137">2137</a>. Misleadingly constrained post-condition in the presence of exceptions</h3>
<p><b>Section:</b> 28.6.7.3 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2024-10-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex.assign">issues</a> in [re.regex.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The post-conditions of <code>basic_regex&lt;&gt;::assign</code> 28.6.7.3 <a href="https://timsong-cpp.github.io/cppwp/re.regex.assign">[re.regex.assign]</a> p16 say:
</p>
<blockquote><p>
<span style="color:#C80000;font-weight:bold">If no exception is thrown,</span> <code>flags()</code> returns
<code>f</code> and <code>mark_count()</code> returns the number of marked sub-expressions within the expression.
</p></blockquote>
<p>
The default expectation in the library is that post-conditions only hold, if there is no failure
(see also <a href="2136" title="Postconditions vs. exceptions (Status: Open)">2136</a>), therefore the initial condition should be removed to prevent any
misunderstanding.
</p>

<p><i>[
2012-10 Portland: Move to Open
]</i></p>


<p>
A favorable resolution clearly depends on a favorable resolution to <a href="2136" title="Postconditions vs. exceptions (Status: Open)">2136</a>.
There is also a concern that this is just one example of where we would want to apply
such a wording clean-up, and which is really needed to resolve both this issue and
<a href="2136" title="Postconditions vs. exceptions (Status: Open)">2136</a> is a paper providing the clause 17 wording that gives the guarantee
for <i>postcondition</i> paragraphs, and then reviews clauses 18-30 to apply that
guarantee consistently.  We do not want to pick up these issues piecemeal, as we risk
opening many issues in an ongoing process.
</p>

<p><i>[2015-05-06 Lenexa: EricWF to write paper addressing 2136 and 2137]</i></p>


<p><i>[2024-10-03; Jonathan comments]</i></p>

<p>
I could find no other cases in the entire standard where we say something
like this in a <i>Postconditions</i>: element.
31.6.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/streambuf.virt.pback">[streambuf.virt.pback]</a> p2 says
"<i>Postconditions</i>: On return, the constraints of [...]"
which is probably redundant (postconditions are always "on return").
</p>


<p id="res-2137"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<blockquote><pre>
template &lt;class string_traits, class A&gt;
  basic_regex&amp; assign(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
    flag_type f = regex_constants::ECMAScript);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Effects</i>: Assigns the regular expression contained in the string <code>s</code>, interpreted according
the flags specified in <code>f</code>. If an exception is thrown, <code>*this</code> is unchanged.
<p/>
-16- <i>Postconditions</i>: <del>If no exception is thrown,</del> <code>flags()</code> returns <code>f</code> and
<code>mark_count()</code> returns the number of marked sub-expressions within the expression.
</p>
</blockquote>
</blockquote>






<hr>
<h3 id="2146"><a href="2146">2146</a>. Are reference types <code>CopyConstructible</code>&#47;<code>MoveConstructible</code>&#47;<code>CopyAssignable</code>&#47;<code>MoveAssignable</code>&#47;<code>Destructible</code>?</h3>
<p><b>Section:</b> 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-03-23 <b>Last modified:</b> 2024-12-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> p1
</p>
<blockquote><p>
The template definitions in the C++ standard library refer to various named requirements whose details are set out in 
tables 17-24. In these tables, <code>T</code> is an object or reference type to be supplied by a C++ program instantiating 
a template; <code>a</code>, <code>b</code>, and <code>c</code> are values of type (possibly <code>const</code>) <code>T</code>; <code>s</code> 
and <code>t</code> are modifiable lvalues of type <code>T</code>; <code>u</code> denotes an identifier; <code>rv</code> is an rvalue of 
type <code>T</code>; and <code>v</code> is an lvalue of type (possibly <code>const</code>) <code>T</code> or an rvalue of type <code>const T</code>.
</p></blockquote>
<p>
Is it really intended that <code>T</code> may be a reference type? If so, what should <code>a</code>, <code>b</code>, <code>c</code>, 
<code>s</code>, <code>t</code>, <code>u</code>, <code>rv</code>, and <code>v</code> mean? For example, are "<code>int &amp;</code>" and 
"<code>int &amp;&amp;</code>" <code>MoveConstructible</code>?
<p/>
As far as I understand, we can explicitly specify template arguments for <code>std::swap</code> and <code>std::for_each</code>. 
Can we use reference types there?
</p>
<ol>
<li>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main()
{
  int x = 1;
  int y = 2;
  std::swap&lt;<span style="color:#C80000;font-weight:bold">int &amp;&amp;</span>&gt;(x, y); // <em>undefined?</em>
  std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;
}
</pre></blockquote>
</li>
<li>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;

struct F
{
  void operator()(int n)
  {
    std::cout &lt;&lt; n &lt;&lt; std::endl;
    ++count;
  }
  int count;
} f;

int main()
{
  int arr[] = { 1, 2, 3 };
  auto&amp;&amp; result = std::for_each&lt;int *, <span style="color:#C80000;font-weight:bold">F &amp;&amp;</span>&gt;( // <em>undefined?</em>
    std::begin(arr),
    std::end(arr),
    std::move(f));
  std::cout &lt;&lt; "count: " &lt;&lt; result.count &lt;&lt; std::endl;
}
</pre></blockquote>
</li>
</ol>
<p>
Are these forms of usage well-defined?
<p/>
Let's also consider the following constructor of <code>std::thread</code>:
</p>
<blockquote><pre>
template &lt;class F, class ...Args&gt;
explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre><blockquote>
<p>
<i>Requires</i>: <code>F</code> and each <code>Ti</code> in <code>Args</code> shall satisfy the <code>MoveConstructible</code> requirements.
</p>
</blockquote></blockquote>
<p>
When the first argument of this constructor is an lvalue (e.g. a name of a global function), template argument for <code>F</code> 
is deduced to be lvalue reference type. What should "<code>MoveConstructible</code>" mean with regard to an lvalue reference 
type? Maybe the wording should say that <code>std::decay&lt;F&gt;::type</code> and each <code>std::decay&lt;Ti&gt;::type</code> (where 
<code>Ti</code> is an arbitrary item in <code>Args</code>) shall satisfy the <code>MoveConstructible</code> requirements?
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>Moved to Open.</p>
<p>The questions raised by the issue are real, and should have a clear answer.</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: std::thread needs to be fixed, and anything behaving like it needs to be fixed, rather than reference types. std::bind gets this right. We need to survey this. GR: That doesn't sound small to me. STL: Seach for CopyConstructible etc. It may be a long change, but not a hard one.</p>
<p>MC: It seems that we don't have a PR. Does anyone have one? Is anyone interested in doing a survey?</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>Casey volunteers to make a survey</p>

<p><i>[2016-06, Oulu]</i></p>

<p>
During an independent survey performed by Daniel as part of the analysis of LWG <a href="2716" title="Specification of shuffle and sample disallows lvalue URNGs (Status: C++17)">2716</a>,
some overlap was found between these two issues. Daniel suggested to take responsibility for surveying
LWG <a href="2146" title="Are reference types CopyConstructible&#47;MoveConstructible&#47;CopyAssignable&#47;MoveAssignable&#47;Destructible? (Status: Open)">2146</a> and opined that the P/R of LWG <a href="2716" title="Specification of shuffle and sample disallows lvalue URNGs (Status: C++17)">2716</a> should restrict to forwarding 
references, where the deduction to lvalue references can happen without providing an explicit template
argument just by providing an lvalue function argument.
</p>

<p><i>[2018-06, Rapperwsil]</i></p>

<p>Jonathan says that this will be covered by his Omnibus requirements paper.</p>

<p><i>[2019 Cologne Wednesday night]</i></p>

<p>Daniel will start working on this again; Marshall to provide rationale why some of the examples are not well-formed.</p>

<p><i>[2020-10-02; Issue processing telecon: change from P2 to P3]</i></p>

<p>
For the examples given in the original report, the <code>for_each</code>
case is now banned, because 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> p15
forbids explicit template argument lists. <code>std::thread</code>'s constructor
has also been fixed to describe the requirements on <code>decay_t&lt;T&gt;</code>
instead of <code>T</code>.
</p>
<p>
We believe we're more careful these days about using <code>remove_cvref</code>
or <code>decay</code> as needed, but there are still places where we incorrectly
state requirements in terms of types that might be references.
The <code>swap</code> case still needs solving. Still need a survey.
</p>

<p><i>[2024-03-15; LWG <a href="4047" title="Explicitly specifying template arguments for std::swap should not be supported (Status: New)">4047</a> addresses the <code>swap</code> part]</i></p>


<p><i>[2024-12-04; Daniel comments]</i></p>

<p>
The mentioned requirement sets have been renamed a while ago to:
</p>
<ul>
<li><p><i>Cpp17CopyConstructible</i></p></li>
<li><p><i>Cpp17MoveConstructible</i></p></li>
<li><p><i>Cpp17CopyAssignable</i></p></li>
<li><p><i>Cpp17MoveAssignable</i></p></li>
<li><p><i>Cpp17Destructible</i></p></li>
</ul>



<p id="res-2146"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2152"><a href="2152">2152</a>. Instances of standard container types are not swappable</h3>
<p><b>Section:</b> 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>, 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#swappable.requirements">issues</a> in [swappable.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sub-clause 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> defines two notions of swappability: a binary version defining
when two objects are <em>swappable with</em> one another, and a unary notion defining whether an object is 
<em>swappable</em> (without qualification), with the latter definition requiring that the object satisfy the 
former with respect to all values of the same type.
<p/>
Let <code>T</code> be a container type based on a non-propagating allocator whose instances do not necessarily 
compare equal. Then sub-clause 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p7 implies that no object <code>t</code> 
of type <code>T</code> is swappable (by the unary definition).
<p/>
Throughout the standard it is the unary definition of "swappable" that is listed as a requirement (with the 
exceptions of 22.2.2 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a> p4, 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> p31, 22.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a> p2, 
26.7.3 <a href="https://timsong-cpp.github.io/cppwp/alg.swap">[alg.swap]</a> p2, and 26.7.3 <a href="https://timsong-cpp.github.io/cppwp/alg.swap">[alg.swap]</a> p6, which use the binary definition). This renders 
many of the mutating sequence algorithms of sub-clause 26.7 <a href="https://timsong-cpp.github.io/cppwp/alg.modifying.operations">[alg.modifying.operations]</a>, for example, 
inapplicable to sequences of standard container types, even where every element of the sequence is swappable 
with every other.
<p/>
Note that this concern extends beyond standard containers to all future allocator-based types.
<p/>
Resolution proposal:
<p/>
I see two distinct straightforward solutions:
</p>
<ol style="list-style-type:lower-roman">
<li>Modify the requirements of algorithms from sub-clause 26.7 <a href="https://timsong-cpp.github.io/cppwp/alg.modifying.operations">[alg.modifying.operations]</a>, and all other
places that reference the unary "swappable" definition, to instead use the binary "swappable with" definition 
(over a domain appropriate to the context). The unary definition of "swappable" could then be removed from the 
standard.
</li>
<li>Modify sub-clause 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> such that objects of standard container types 
are "swappable" by the unary definition.
</li>
</ol>
<p>
I favor the latter solution, for reasons detailed in the following issue.
</p>

<p><i>[
2012-10 Portland: Move to Open 
]</i></p>


<p>
The issue is broader than containers with stateful allocotors, although they are the most obvious
example contained within the standard itself.  The basic problem is that once you have a stateful
allocator, that does not <code>propagate_on_swap</code>, then whether two objects of this type can be
swapped with well defined behavior is a run-time property (the allocators compare equal) rather
than a simple compile-time property that can be deduced from the type.  Strictly speaking, any
type where the nature of swap is a runtime property does not meet the <code>swappable</code>
requirements of C++11, although typical sequences of such types are going to have elements that
are all <code>swappable with</code> any other element in the sequence (using our other term of art
for specifying requirements) as the common case is a container of elements who all share the
same allocator.
</p>

<p>
The heart of the problem is that the <code>swappable</code> requirments demand that any two objects
of the same type be <code>swappable with</code> each other, so if any two such objects would not
be <code>swappable with</code> each other, then the whole type is never <code>swappable</code>.  Many
algorithms in clause 25 are specified in terms of <code>swappable</code> which is essentially an
overspecification as all they actually need is that any element in the sequence is <code>swappable
with</code> any other element in the sequence.
</p>

<p>
At this point Howard joins the discussion and points out that the intent of introducing the
two swap-related terms was to support <code>vector&lt;bool&gt;::reference</code> types, and we are
reading something into the wording that was never intended.  Consuses is that regardless of
the intent, that is what the words today say.
</p>

<p>
There is some support to see a paper reviewing the whole of clause 25 for this issue, and
other select clauses as may be necessary.
</p>

<p>
There was some consideration to introducing a note into the front of clause 25 to indicate
<code>swappable</code> requirements in the clause should be interpreted to allow such awkward
types, but ultimately no real enthusiasm for introducing a <code>swappable for clause 25</code>
requirement term, especially if it confusingly had the same name as a term used with a
subtly different meaning through the rest of the standard.
</p>

<p>
There was no enthusiasm for the alternate resolution of requiring containers with unequal
allocators that do not propagate provide a well-defined swap behavior, as it is not
believed to be possible without giving <code>swap</code> linear complexity for such values,
and even then would require adding the constraint that the container element types are
CopyConstructible.
</p>

<p>
Final conclusion: move to open pending a paper from a party with a strong interest in
stateful allocators.
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Alisdair says that his paper <a href="https://wg21.link/P0178">P0178</a> addresses this.
</p>

<p><i>[2016-06 Oulu]</i></p>

<p><a href="https://wg21.link/P0178">P0178</a> reviewed, and sent back to LEWG for confirmation.</p>
<p>Thursday Morning: A joint LWG/LEWG meeting declined to adopt <a href="https://wg21.link/P0178">P0178</a>.</p>

<p><i>[2017-02 in Kona, LEWG responds]</i></p>

<p>Note in the issue that this is tracked <a href="https://issues.isocpp.org/show_bug.cgi?id=152">here</a></p>

<p><i>[2017-06-02 Issues Telecon]</i></p>

<p>Leave as LEWG; priority 3</p>


<p id="res-2152"><b>Proposed resolution:</b></p>
<p>
Apply <a href="https://wg21.link/P0178">P0178</a>.
</p>





<hr>
<h3 id="2153"><a href="2153">2153</a>. Narrowing of the non-member <code>swap</code> contract</h3>
<p><b>Section:</b> 22.2.2 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a>, 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>, 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2020-10-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.swap">issues</a> in [utility.swap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sub-clause 22.2.2 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a> defines a non-member 'swap' function with defined behavior for
all <code>MoveConstructible</code> and <code>MoveAssignable</code> types. It does not guarantee
constant-time complexity or <code>noexcept</code> in general, however this definition does
render all objects of <code>MoveConstructible</code> and <code>MoveAssignable</code> type swappable
(by the unary definition of sub-clause 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>) in the absence of 
specializations or overloads.
<p/>
The overload of the non-member <code>swap</code> function defined in Table 96, however,
defines semantics incompatible with the generic non-member <code>swap</code> function,
since it is defined to call a member <code>swap</code> function whose semantics are
undefined for some values of <code>MoveConstructible</code> and <code>MoveAssignable</code> types.
<p/>
The obvious (perhaps naive) interpretation of sub-clause 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> is as a guide to
the "right" semantics to provide for a non-member <code>swap</code> function (called in
the context defined by 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a> p3) in order to provide interoperable
user-defined types for generic programming. The standard container types don't follow these guidelines.
<p/>
More generally, the design in the standard represents a classic example of "contract narrowing". It 
is entirely reasonable for the contract of a particular <code>swap</code> overload to provide <em>more</em> 
guarantees, such as constant-time execution and <code>noexcept</code>, than are provided by the <code>swap</code> 
that is provided for any <code>MoveConstructible</code> and <code>MoveAssignable</code> types, but it is <em>not</em> 
reasonable for such an overload to fail to live up to the guarantees it provides for general types when 
it is applied to more specific types. Such an overload or specialization in generic programming is akin 
to an override of an inherited virtual function in OO programming: violating a superclass contract in a
subclass may be legal from the point of view of the language, but it is poor design and can easily lead 
to errors. While we cannot prevent user code from providing overloads that violate the more general 
<code>swap</code> contract, we can avoid doing so within the library itself.
<p/>
My proposed resolution is to draw a sharp distinction between member <code>swap</code> functions, which provide 
optimal performance but idiosyncratic contracts, and non-member <code>swap</code> functions, which should always 
fulfill at least the contract of 22.2.2 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a> and thus render objects swappable. The member 
<code>swap</code> for containers with non-propagating allocators, for example, would offer constant-time
guarantees and <code>noexcept</code> but would only offer defined behavior for values with allocators that compare 
equal; non-member <code>swap</code> would test allocator equality and then dispatch to either member <code>swap</code> or 
<code>std::swap</code> depending on the result, providing defined behavior for all values (and rendering the type
"swappable"), but offering neither the constant-time nor the <code>noexcept</code> guarantees.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This topic deserves more attention than can be given in the telecon, and there is no proposed resolution.
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Alisdair says that his paper <a href="https://wg21.link/P0178">P0178</a> addresses this.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Send to LEWG</p>

<p><i>[2016-06 Oulu]</i></p>

<p><a href="https://wg21.link/P0178">P0178</a> reviewed, and sent back to LEWG for confirmation.</p>
<p>Thursday Morning: A joint LWG/LEWG meeting declined to adopt <a href="https://wg21.link/P0178">P0178</a>.</p>


<p><i>[2020-10-02; remove P0178 as Proposed Resolution]</i></p>


<p id="res-2153"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2157"><a href="2157">2157</a>. How does <code>std::array&lt;T,0&gt;</code> initialization work when <code>T</code> is not default-constructible?</h3>
<p><b>Section:</b> 23.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daryle Walker <b>Opened:</b> 2012-05-08 <b>Last modified:</b> 2021-03-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array.zero">active issues</a> in [array.zero].</p>
<p><b>View all other</b> <a href="lwg-index.html#array.zero">issues</a> in [array.zero].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Objects of <code>std::array&lt;T, N&gt;</code> are supposed to be initialized with aggregate initialization (when 
not the destination of a copy or move). This clearly works when <code>N</code> is positive. What happens when <code>N</code> 
is zero?  To continue using an (inner) set of braces for initialization, a <code>std::array&lt;T, 0&gt;</code> implementation 
must have an array member of at least one element, and let default initialization take care of those secret elements.  
This cannot work when <code>T</code> has a set of constructors and the default constructor is deleted from that set.
Solution: Add a new paragraph in 23.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a>:
</p>
<blockquote>
<p>
The unspecified internal structure of array for this case shall allow initializations like:
</p>
<blockquote><pre>
array&lt;T, 0&gt; a = { };
</pre></blockquote>
<p>
and said initializations must be valid even when <code>T</code> is not default-constructible.
</p>
</blockquote>

<p><i>[2012, Portland: Move to Open]</i></p>

<p>
Some discussion to understand the issue, which is that implementations currently have freedom to implement
an empty <code>array</code> by holding a dummy element, and so might not support value initialization, which is
surprising when trying to construct an empty container. However, this is not mandated, it is an unspecified
implementation detail.
</p>

<p>
Jeffrey points out that the implication of 23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> is that this initialization syntax
must be supported by empty <code>array</code> objects already. This is a surprising inference that was not
obvious to the room, but consensus is that the reading is accurate, so the proposed resolution is not necessary,
although the increased clarity may be useful.
</p>

<p>
Further observation is that the same clause effectively implies that <code>T</code> must always be DefaultConstructible,
regardless of <code>N</code> for the same reasons - as an <i>initializer-list</i> may not supply enough values, and the
remaining elements must all be value initialized.
</p>

<p>
Concern that we are dancing angels on the head of pin, and that relying on such subtle implications in wording is
not helpful. We need a clarification of the text in this area, and await wording.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
DK: What was the outcome of Portland? AM: Initially we thought we already had the intended behaviour. 
We concluded that <code>T</code> must always be <code>DefaultConstructible</code>, but I'm not sure why. GR: It's p2 in 
<code>std::array</code>, "up to <code>N</code>". AM: That wording already implies that "<code>{}</code>" has to work when <code>N</code> 
is zero. But the wording of p2 needs to be fixed to make clear that it does <em>not</em> imply that <code>T</code> must be 
<code>DefaultConstructible</code>.
<p/>
Conclusion: Update wording, revisit later. 
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>MC: How important is this? Can you not just use default construction for empty arrays? </p>
<p>TK: It needs to degenerate properly from a pack. STL agrees.</p> 
<p>JW: Yes, this is important, and we have to make it work.</p>
<p>MC: I hate the words "initialization like". </p>
<p>JW: I'll reword this.</p>
<p>WEB: Can I ask that once JW has reworded this we move it to Review rather than Open? </p>
<p>MC: We'll try to review it in a telecon and hopefully get it to tentatively ready.</p>
<p>STL: Double braces must also work: <code>array&lt;T, 0&gt; a = {{}};</code>.</p>
<p>Jonathan to reword.</p>

<p><i>[2018-03-14 Wednesday evening issues processing]</i></p>

<p>Jens suggested that we remove the requirement that <code>begin() == end() == </code><i>unique-value</i>, 
specifically the unique value part.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n3376">N3376</a>.</p>

<p>Add the following new paragraph between the current 23.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> p1 and p2:</p>

<blockquote>
<p>
-1- <code>array</code> shall provide support for the special case <code>N == 0</code>.
<p/>
<ins>-?- The unspecified internal structure of <code>array</code> for this case shall allow initializations like:</ins>
</p>
<blockquote><pre>
<ins>array&lt;T, 0&gt; a = { };</ins>
</pre></blockquote>
<p>
<ins>and said initializations must be valid even when <code>T</code> is not default-constructible.</ins>
<p/>
-2- In the case that <code>N == 0</code>, <code>begin() == end() ==</code> unique value. The return value of 
<code>data()</code> is unspecified.
<p/>
-3- The effect of calling <code>front()</code> or <code>back()</code> for a zero-sized array is undefined.
<p/>
-4- Member function <code>swap()</code> shall have a <em>noexcept-specification</em> which is equivalent to 
<code>noexcept(true)</code>.
</p>
</blockquote>
</blockquote>

<p><i>[2018-06-14, Jonathan Wakely comments and provides revised wording]</i></p>

<p>
The new wording does not address the 2018-03-14 suggestion from Jens to remove the unique value. It wasn't
clear to me that there was consensus to make that change, and it would be a change in behaviour not just a 
clarification of the existing wording.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4750">N4750</a>.
</p>

<p>Modify 23.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>array</code> <del>shall</del> provide<ins>s</ins> support for the special case <ins>of a zero-sized <code>array</code> 
that is always empty, i.e.</ins> <code>N == 0</code><ins>, with the properties described in this subclause</ins>.
<p/>
<ins>-?- A zero-sized <code>array</code> type is an aggregate that meets the <code>DefaultConstructible</code> (Table 22) and 
<code>CopyConstructible</code> (Table 24) requirements. There is a single element of the aggregate, of an unspecified 
<code>DefaultConstructible</code> type. [<i>Note:</i> This allows initialization of the form <code>array&lt;T, 0&gt; a = {{}};</code>. 
There is no requirement for <code>T</code> to be <code>DefaultConstructible</code>. &mdash; <i>end note</i>]</ins>
<p/>
-2- <del>In the case that <code>N == 0</code>, <code>begin() == end() ==</code> unique value</del><ins><code>begin()</code> and 
<code>end()</code> return non-dereferenceable iterators such that <code>begin() == end()</code> and <code>a.begin() != b.begin()</code> 
where <code>a</code> and <code>b</code> are distinct objects of the same zero-sized <code>array</code> type</ins>. The return value 
of <code>data()</code> is unspecified.
<p/>
-3- The effect of calling <code>front()</code> or <code>back()</code> for a zero-sized array is undefined.
<p/>
-4- Member function <code>swap()</code> <del>shall have</del><ins>has constant complexity and</ins> a non-throwing exception specification.
</p>
</blockquote>
</blockquote>

<p><i>[2018-08-30, Jonathan revises wording following feedback from Daniel Kruegler and Tim Song.]</i></p>

<p>
Daniel noted that it's undefined to compare iterators from different containers,
so <code>a.begin() != b.begin()</code> can't be used. That means whether the iterators
from different containers are unique is unobservable anyway.
We can say they don't share the same underlying sequence, which tells users they can't compare them
and tells implementors they can't return value-initialized iterators.
<br/>
Tim noted that it's not sufficient to say the unspecified type in a zero-sized array is DefaultConstructible,
it also needs to be constructible from <code>= {}</code>. Also, a zero-sized array should be CopyAssignable.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.
</p>

<p>Modify 23.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>array</code> <del>shall</del> provide<ins>s</ins> support for the special case <ins>of a zero-sized <code>array</code> 
that is always empty, i.e.</ins> <code>N == 0</code><ins>, with the properties described in this subclause</ins>.
<p/>
<ins>-?- A zero-sized <code>array</code> type is an aggregate that meets the <i>Cpp17DefaultConstructible</i> (Table 24) and 
<i>Cpp17CopyConstructible</i> (Table 26) and <i>Cpp17CopyAssignable</i> (Table 28) requirements. There is a single element 
of the aggregate, of an unspecified <i>Cpp17DefaultConstructible</i> type that is copy-list-initializable from an empty list.
[<i>Note:</i> This allows initialization of the form <code>array&lt;T, 0&gt; a = {{}};</code>. There is no requirement for 
<code>T</code> to be <i>Cpp17DefaultConstructible</i>. &mdash; <i>end note</i>]</ins>
<p/>
-2- <del>In the case that <code>N == 0</code>, <code>begin() == end() ==</code> unique value</del><ins><code>begin()</code> and <code>end()</code> 
return non-dereferenceable iterators such that <code>begin() == end()</code>. When <code>a</code> and <code>b</code> are distinct objects 
of the same zero-sized <code>array</code> type, <code>a.begin()</code> and <code>b.begin()</code> are not iterators over the same 
underlying sequence. [<i>Note:</i> Therefore <code>begin()</code> does not return a value-initialized iterator &mdash; 
<i>end note]</i></ins>. The return value of <code>data()</code> is unspecified.
<p/>
-3- The effect of calling <code>front()</code> or <code>back()</code> for a zero-sized array is undefined.
<p/>
-4- Member function <code>swap()</code> <del>shall have</del><ins>has constant complexity and</ins> a non-throwing exception specification.
</p>
</blockquote></blockquote>

<p><i>[2021-03-14; Johel Ernesto Guerrero Pe&ntilde;a comments and provides improved wording]</i></p>

<p>
The currently proposed wording specifies:
</p>
<blockquote><p>
There is a single element of the aggregate, of an unspecified <i>Cpp17DefaultConstructible</i> 
type that is copy-list-initializable from an empty list.
</p></blockquote>
<p>
This doesn't specify which expressions involving zero-sized array specializations are constant expressions. 
23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> p4 specifies <code>array&lt;T, 0&gt;</code> to be a structural type when <code>T</code> 
is a structural type. This requires that its single element, let's call it <i>single-element</i>, be a 
structural type. But that says nothing about which of the special member functions of <i>single-element</i> 
are constant expressions. By being a structural type, <i>single-element</i> is permitted to be implemented 
as a literal class type. To meet this requirement, <i>single-element</i> can be implemented to have one 
constexpr constructor that is not a copy or move constructor (6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.types.general">[basic.types.general]</a> p10), so 
its default constructor needn't be constexpr. This is unlike non-zero-sized array specializations, which 
inherit these properties from <code>T</code>. Furthermore, this permits an implementation of <i>single-element</i> 
whose default constructor stores the result of <code>std::source_location::current()</code> in a data member 
(as exemplified in the specification for <code>current</code>). <i>Cpp17DefaultConstructible</i> doesn't 
require the default constructor to produce equal values. The simplest way to solve these issues and any other 
that might arise from future changes and oversights would be to specify <i>single-element</i> as an empty 
aggregate type. Then the wording from 23.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/array.cons">[array.cons]</a> p1 makes it clear that all the special 
member functions are constant expressions. It would also mean that the default constructor produces 
template-argument-equivalent values.
</p>


<p id="res-2157"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<p>Modify 23.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> as indicated:</p>

<ol>
<li>
<blockquote>
<p>
-1- <code>array</code> <del>shall</del> provide<ins>s</ins> support for the special case <ins>of a zero-sized <code>array</code> 
that is always empty, i.e.</ins> <code>N == 0</code><ins>, with the properties described in this subclause</ins>.
<p/>
<ins>-?- A zero-sized <code>array</code> type is an aggregate that meets the <i>Cpp17DefaultConstructible</i> 
(Table 29 [tab:cpp17.defaultconstructible]) and <i>Cpp17CopyConstructible</i> (Table 31 [tab:cpp17.copyconstructible]) 
and <i>Cpp17CopyAssignable</i> (Table 33 [tab:cpp17.copyassignable]) requirements. There is a single element 
of the aggregate, of an unspecified empty aggregate type. [<i>Note:</i> This allows initialization of the form 
<code>array&lt;T, 0&gt; a = {{}};</code>. There is no requirement for <code>T</code> to be <i>Cpp17DefaultConstructible</i>. 
&mdash; <i>end note</i>]</ins>
<p/>
-2- <del>In the case that <code>N == 0</code>, <code>begin() == end() ==</code> unique value</del><ins><code>begin()</code> and 
<code>end()</code> return non-dereferenceable iterators such that <code>begin() == end()</code>. When <code>a</code> and <code>b</code> 
are distinct objects of the same zero-sized <code>array</code> type, <code>a.begin()</code> and <code>b.begin()</code> are not iterators 
over the same underlying sequence. [<i>Note:</i> Therefore <code>begin()</code> does not return a value-initialized iterator 
&mdash; <i>end note</i>].</ins>. The return value of <code>data()</code> is unspecified.
<p/>
-3- The effect of calling <code>front()</code> or <code>back()</code> for a zero-sized array is undefined.
<p/>
-4- Member function <code>swap()</code> <del>shall have</del><ins>has constant complexity and</ins> a non-throwing exception 
specification.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="2158"><a href="2158">2158</a>. Conditional copy&#47;move in <code>std::vector</code></h3>
<p><b>Section:</b> 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-05-08 <b>Last modified:</b> 2022-11-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
There are various operations on <code>std::vector</code> that can cause elements of the vector to be 
moved from one location to another. A move operation can use either rvalue or const lvalue as 
argument; the choice depends on the value of <code>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;
is_copy_constructible&lt;T&gt;::value</code>, where <code>T</code> is the element type. Thus, some operations 
on <code>std::vector</code> (e.g. 'resize' with single parameter, 'reserve', 'emplace_back') should have 
conditional requirements. For example, let's consider the requirement for 'reserve' in N3376 &ndash; 
23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>&#47;2:
</p>
<blockquote><p>
<i>Requires</i>: <code>T</code> shall be <code>MoveInsertable</code> into <code>*this</code>.
</p></blockquote>
<p>
This requirement is not sufficient if an implementation is free to select copy constructor when 
<code>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value</code> 
evaluates to true. Unfortunately, <code>is_copy_constructible</code> cannot reliably determine whether 
<code>T</code> is really copy-constructible. A class may contain public non-deleted copy constructor whose 
definition does not exist or cannot be instantiated successfully (e.g., 
<code>std::vector&lt;std::unique_ptr&lt;int&gt;&gt;</code> has copy constructor, but this type is not 
copy-constructible). Thus, the actual requirements should be:
</p>
<ul>
<li><p>
if <code>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value</code> 
then <code>T</code> shall be <code>CopyInsertable</code> into <code>*this</code>;
</p></li>
<li><p>
otherwise <code>T</code> shall be <code>MoveInsertable</code> into <code>*this</code>.
</p></li>
</ul>
<p>
Maybe it would be useful to introduce a new name for such conditional requirement (in addition to 
"<code>CopyInsertable</code>" and "<code>MoveInsertable</code>").
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>
The problem does not appear to be as severe as described. The <code>MoveInsertable</code>
requirements are consistently correct, but an issue may arise on the
exception-safety guarantees when we check for
<code>is_copy_constructible_v&lt;T&gt;</code>.  The problem, as described, is
typically for templates that appear to have a copy constructor, but one that
fails to compile once instantiated, and so gives a misleading result for the
trait.
</p>
<p>
In general, users should not provide such types, and the standard would not
serve users well by trying to address support for such types.  However, the
standard should not be providing such types either, such as
<code>vector&lt;unique_ptr&lt;T&gt;&gt;</code>.  A possible resolution would be
to tighten the constraints in Table 80 &mdash; Container Requirements, so that if
the Requirements for the copy constructor/assingment operator of a container
are not satisfied, that operation shall be deleted.
</p>
<p>
A futher problem highlighted by this approach is that there are no constraints on
the copy-assignment operator, so that <code>vector&lt;unique_ptr&lt;T&gt;&gt;</code>
should be <code>CopyAssignable</code>! However, we can lift the equivalent constraints from
the Allocator-aware container requirements.
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Fri PM: Move to Open</p>

<p><i>[2017-11 Albuquerque Saturday issues processing]</i></p>

<p>There's a bunch of uses of "shall" here that are incorrect. Also, CopyInsertable contains some semantic requirements, 
which can't be checked at compile time, so 'ill-formed' is not possible for detecting that.</p>

<p><i>[2018-06 Rapperswil Wednesday issues processing]</i></p>

<p>Daniel to provide updated wording.</p>

<p><i>[2018-06-12, Daniel provides revised wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4606">N4606</a>.
</p>

<p>
<table border="1">
<caption> 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> Table 80 &mdash; Container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><code>X(a)</code></td>
  <td></td>
  <td></td>
  <td>
    <i>Requires:</i> <code>T</code> is <code>CopyInsertable</code> into
    <code>X</code> (see below)<del>.</del><ins>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <code>a == X(a)</code>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td><code>X u(a)</code><br/><code>X u = a;</code></td>
  <td></td>
  <td></td>
  <td>
    <i>Requires:</i> <code>T</code> is <code>CopyInsertable</code> into
    <code>X</code> (see below)<del>.</del><ins>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <code>u == a</code>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
</tr>
<tr>
  <td><code>r = a</code></td>
  <td><code>X&amp;</code></td>
  <td></td>
  <td>
    <ins><i>Requires:</i> <code>T</code> is <code>CopyInsertable</code> into <code>X</code>
    and <code>CopyAssignable</code>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <code>r == a</code>.</td>
  <td>linear</td>
</tr>
</table>
</p>

<p>
<table border="1">
<caption> 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> Table 83 &mdash; Allocator-aware container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><code>a = t</code></td>
  <td><code>X&amp;</code></td>
  <td></td>
  <td>
    <i>Requires:</i> <code>T</code> is <code>CopyInsertable</code> into <code>X</code> and
    <code>CopyAssignable</code><del>.</del><ins>, otherwise this  expression shall
    be ill-formed</ins><br/>
    post: <code>r == a</code>.</td>
  <td>linear</td>
</tr>
</table>
</p>
</blockquote>

<p><i>[2018-08-23 Batavia Issues processing. Priority to 3]</i></p>

<p>Changed <code>CopyInsertable</code> -&gt; <code>Cpp17CopyInsertable</code> in the resolution.</p>
<p>Tim says that the wording is not quite right &mdash; it imposes additional requirements.</p>


<p><i>[2022-11-06; Daniel comments]</i></p>

<p>
This issue has considerable overlap with LWG <a href="3758" title="Element-relocating operations of std::vector and std::deque 
should conditionally require Cpp17CopyInsertable in their preconditions (Status: New)">3758</a>.
</p>


<p id="res-2158"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4750">N4750</a>.
</p>

<blockquote class="note">
<p>
The revised wording below uses the new <i>Mandates:</i> element introduced by
adopting <a href="https://wg21.link/p0788r3">P0788R3</a> at the Rapperswil meeting 2018 
and which will become a new term of art with Jonathan's omnibus paper throughout the
Standard Library.
</p>
</blockquote>

<p>
<table border="1">
<caption> 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> Table 77 &mdash; Container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><code>X(a)</code></td>
  <td></td>
  <td></td>
  <td>
    <ins><i>Mandates:</i> Syntactic requirements of <code>T</code><br/> 
    is <code>Cpp17CopyInsertable</code> into <code>X</code> (see below).</ins><br/>
    <i>Requires:</i> <code>T</code> is <code>Cpp17CopyInsertable</code> into
    <code>X</code> <del>(see below)</del>.<br/>
    post: <code>a == X(a)</code>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td><code>X u(a)</code><br/><code>X u = a;</code></td>
  <td></td>
  <td></td>
  <td>
    <ins><i>Mandates:</i> Syntactic requirements of <code>T</code><br/> 
    is <code>Cpp17CopyInsertable</code> into <code>X</code> (see below).</ins><br/>
    <i>Requires:</i> <code>T</code> is <code>Cpp17CopyInsertable</code> into
    <code>X</code> <del>(see below)</del>.<br/>
    post: <code>u == a</code>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
</tr>
<tr>
  <td><code>r = a</code></td>
  <td><code>X&amp;</code></td>
  <td></td>
  <td>
    <ins><i>Mandates:</i> Syntactic requirements of <code>T</code><br/> 
    is <code>Cpp17CopyInsertable</code> into <code>X</code> (see below) and
    <code>CopyAssignable</code>.<br/></ins>
    <ins><i>Requires:</i> <code>T</code> is <code>Cpp17CopyInsertable</code> into <code>X</code>
    and <code>CopyAssignable</code>.</ins><br/>
    post: <code>r == a</code>.</td>
  <td>linear</td>
</tr>
</table>
</p>

<p>
<table border="1">
<caption> 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> Table 80 &mdash; Allocator-aware container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><code>a = t</code></td>
  <td><code>X&amp;</code></td>
  <td></td>
  <td>
    <ins><i>Mandates:</i> Syntactic requirements of <code>T</code> is<br/> 
    <code>Cpp17CopyInsertable</code> into <code>X</code> and <code>CopyAssignable</code>.<br/></ins>
    <i>Requires:</i> <code>T</code> is <code>Cpp17CopyInsertable</code> into <code>X</code> and
    <code>CopyAssignable</code>.<br/>
    post: <code>r == a</code>.</td>
  <td>linear</td>
</tr>
</table>
</p>






<hr>
<h3 id="2173"><a href="2173">2173</a>. The meaning of <code>operator +</code> in the description of the algorithms</h3>
<p><b>Section:</b> 26 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-08-01 <b>Last modified:</b> 2018-06-12</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 26.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a>/12,
</p>
<blockquote><p>
In the description of the algorithms operators <code>+</code> and <code>-</code> are used for some of the iterator categories 
for which they do not have to be defined. In these cases the semantics of <code>a+n</code> is the same as that of
</p>
<blockquote><pre>
X tmp = a;
advance(tmp, n);
return tmp;
</pre></blockquote>
</blockquote>
<p>
There are several places where such operator <code>+</code> is applied to an output iterator &mdash; for example, see the 
description of <code>std::copy</code>:
</p>
<blockquote><pre>
template&lt;class InputIterator, class OutputIterator&gt;
OutputIterator copy(InputIterator first, InputIterator last,
                    OutputIterator result);
</pre>
<blockquote><p>
-1- <i>Effects</i>: Copies elements in the range <code>[first,last)</code> into the range <code>[result,result + (last -
first))</code> starting from <code>first</code> and proceeding to <code>last</code>. For each non-negative integer 
<code>n &lt; (last - first)</code>, performs <code>*(result + n) = *(first + n)</code>.
</p></blockquote></blockquote>
<p>
<code>std::advance</code> is not supposed to be applicable to output iterators, so we need a different method of description.
<p/>
See also message <a href="http://listarchives.isocpp.org/cgi-bin/wg21/message?wg=lib&amp;msg=32908">c++std-lib-32908</a>.
</p>

<p><i>[2014-06-07 Daniel comments and provides wording]</i></p>

<p>
The specification for output iterators is somewhat tricky, because here a sequence of increments is required to
be combined with intervening <em>assignments</em> to the dereferenced iterator. I tried to respect this
fact by using a conceptual assignment operation as part of the specification.
<p/>
Another problem in the provided as-if-code is the question which requirements are imposed on <code>n</code>. Unfortunately,
the corresponding function <code>advance</code> is completely underspecified in this regard, so I couldn't borrow wording
from it. We cannot even assume here that <code>n</code> is the difference type of the iterator, because for output iterators there is
no requirements for this associated type to be defined. The presented wording attempts to minimize assumptions, but still
can be considered as controversial. 
</p>

<p><i>[2018-06 Rapperswil Wednesday issues processing]</i></p>

<p>Status to Open</p>


<p id="res-2173"><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 26.1 <a href="https://timsong-cpp.github.io/cppwp/algorithms.general">[algorithms.general]</a> around p12 as indicated:</p>

<blockquote>
<p>
-12- In the description of the algorithms operators <code>+</code> and <code>-</code> are used for some of the iterator categories for which
they do not have to be defined. In these cases the semantics of <code>a+n</code> is the same as that of
</p>
<blockquote>
<pre>
X tmp = a;
advance(tmp, n);
return tmp;
</pre>
</blockquote>
<p>
<ins>when <code>X</code> meets the input iterator requirements (24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>), otherwise it is the same as that of</ins>
</p>
<blockquote>
<pre>
<ins>X tmp = a;
for (auto i = n; i; ++tmp, (void) --i) 
  *tmp = <i>Expr</i>(i); 
return tmp;</ins>
</pre>
</blockquote>
<p>
<ins>where <code><i>Expr</i>(i)</code> denotes the <code>(n-i)</code><sup>th</sup> expression that is assigned to for the corresponding algorithm;</ins> and that of <code>b-a</code> is the same as of
</p>
<blockquote>
<pre>
return distance(a, b);
</pre>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2189"><a href="2189">2189</a>. Throwing <code>swap</code> breaks unordered containers' state</h3>
<p><b>Section:</b> 23.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/unord.req.except">[unord.req.except]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-09-23 <b>Last modified:</b> 2019-07-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The hash functor and key-comparison functor of unordered containers are allowed to throw on <code>swap</code>.
</p>
<p>
23.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/unord.req.except">[unord.req.except]</a>p3 "For unordered associative containers, no <code>swap</code> function throws
an exception unless that exception is thrown by the swap of the container's Hash or Pred object (if any)."
</p>
<p>
In such a case we must offer the basic exception safety guarantee, where both objects are left in valid
but unspecified states, and no resources are leaked.  This yields a corrupt, un-usable container if the
first <code>swap</code> succeeds, but the second fails by throwing, as the functors form a matched pair.
</p>
<p>
So our basic scenario is first, swap the allocators if the allocators propagate on swap, according to
<code>allocator_traits</code>.  Next we swap the pointers to our internal hash table data structures, so that
they match the allocators that allocated them.  (Typically, this operation cannot throw).  Now our containers
are back in a safely destructible state if an exception follows.
</p>
<p>
Next, let's say we swap the hash functor, and that throws.  We have a corrupt data structure, in that the
buckets are not correctly indexed by the correct functors, lookups will give unpredicatable results etc.
We can safely restore a usable state by forcibly clearing each container - which does not leak resources
and leaves us with two (empty but) usable containers.
</p>
<p>
Now let us assume that the hasher swap succeeds.  Next we swap the equality comparator functor, and this
too could throw. The important point to bear in mind is that these two functors form an important pairing
- two objects that compare equal by the equality functor must also hash to the same value.  If we swap
one without the other, we most likely leave the container in an unusable state, even if we clear out all
elements.
</p>
<p>
1. A colleague pointed out that the solution for this is to dynamically allocate the two functors, and then
we need only swap pointers, which is not a throwing operation.  And if we don't want to allocate on default
construction (a common QoI request), we might consider moving to a dynamically allocated functors whenever
<code>swap</code> is called, or on first insertion.  Of course, allocating memory in <code>swap</code> is a whole
new can of worms, but this does not really sound like the design we had intended.
</p>

<p>
2. The simplest option is to say that we do not support hasher or equality functors that throw on ADL
<code>swap</code>.  Note that the requirement is simply to not throw, rather than to be explicitly
marked as <code>noexcept</code>.  Throwing functors are allowed, so long as we never use values that
would actually manifest a throw when used in an unordered container.
</p>

<p>
Pablo went on to give me several more options, to be sure we have a full set to consider:
</p>
<p>
3. Disallow one or the other functor from throwing.  In that case, the 
possibly-throwing functor must be swapped first, then the other functor, 
the allocator, and the data pointer(s) afterwards (in any order -- there 
was a TC that allocator assignment and swap may not throw if the 
corresponding propagation trait is true.). Of course, the question 
becomes: which functor is allowed to throw and which one is not?
</p>
<p>
4. Require that any successful functor <code>swap</code> be reliably reversible.  
This is very inventive.  I know of no other place in the standard where 
such a requirement is stated, though I have occasionally wanted such a 
guarantee.
</p>
<p>
5. Allow a failed swap to leave the containers in a state where future 
insertions may fail for reasons other than is currently allowed.  
Specifically, if the hash and equality functors are out of sync, all 
insertions will fail.  Presumably some "incompletely swapped" exception 
would be thrown.  This is "slightly" inventive, although people have been 
discussing "radioactive" states for a while.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>

<p><i>[2019 Cologne Wednesday night]</i></p>

<p>Billy to write resolution for option #2. This may require a paper.</p>


<p id="res-2189"><b>Proposed resolution:</b></p>






<hr>
<h3 id="2198"><a href="2198">2198</a>. <code>max_load_factor(z)</code> makes no strong guarantees, but bans useful behavior</h3>
<p><b>Section:</b> 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-10-09 <b>Last modified:</b> 2016-12-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The user cannot specify a <code>max_load_factor</code> for their unordered container
at construction, it must be supplied after the event, when the container is
potentially not empty.  The contract for this method is deliberately vague, not
guaranteeing to use the value supplied by the user, and any value actually used
will be used as a ceiling that the container will <i>attempt</i> to respect.
</p>
<p>
The only guarantee we have is that, if user requests a <code>max_load_factor</code>
that is less than the current <code>load_factor</code>, then the operation will take
constant time, thus outlawing an implementation that chooses to rehash and so
preserve as a class invariant that <code>load_factor &lt; max_load_factor</code>.
</p>
<p>
Reasonable options conforming to the standard include ignoring the user's request
if the requested value is too low, or deferring the rehash to the next <code>insert</code>
operation and allowing the container to have a strange state (wrt <code>max_load_factor</code>)
until then - and there is still the question of rehashing if the next <code>insert</code>
is for a duplicate key in a unique container.
</p>
<p>
Given the deliberate vagueness of the current wording, to support a range of reasonable
(but not <i>perfect</i>) behaviors, it is not clear why the equally reasonable rehash
to restore the constraint should be outlawed.  It is not thought that this is a performance
critical operation, where users will be repeatedly setting low load factors on populated
containers, in a tight or (less unlikely) an instant response scenario.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to provide wording.
</p>
<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: Howard to provide wording</p>

<p><i>[2016-11-17 Howard provided wording.]</i></p>


<blockquote>
<p>
The provided wording is consistent with LWG discussion in Issaquah.  An implementation
of the proposed wording would be setting <code>max_load_factor()</code> to
<code>max(z, load_factor())</code>.  This preserves the container invariant:
</p>
<blockquote><pre>
load_factor() &lt;= max_load_factor()
</pre></blockquote>
<p>
And it preserves the existing behavior that no rehash is done by this operation.
</p>
<p>
If it is desired to change the <code>max_load_factor()</code> to something smaller than
the current <code>load_factor()</code> that can be done by <i>first reducing</i> the
current <code>load_factor()</code> by either increasing <code>bucket_count()</code> (via
<code>rehash</code> or <code>reserve</code>), or decreasing <code>size()</code> (e.g.
<code>erase</code>), <i>and then</i> changing <code>max_load_factor()</code>.
</p>

<p>
This resolution reaffirms that <code>load_factor() &lt;= max_load_factor()</code> is a
container invariant which can <i>never</i> be violated.
</p>
</blockquote>

<p><i>[2016-11-27, Nico comments]</i></p>

<p>
Current implementations behave differently. 
<p/>
In regard to the sentence
<blockquote>
"The only guarantee we have is that, if user requests a <code>max_load_factor</code>
that is less than the current <code>load_factor</code>, then the operation will take
constant time, thus outlawing an implementation that chooses to rehash
and so preserve as a class invariant that <code>load_factor &lt; max_load_factor</code>."
</blockquote>
Note that the current spec says that there is constant complexity
<em>without</em> any precondition. So, rehashing to keep the invariant would
violate the spec (which is probably not be the intention).
<p/>
This issue is related to LWG <a href="2199" title="unordered containers are required to have an initial max load factor of 1.0 (Status: NAD)">2199</a>.
</p>


<p id="res-2198"><b>Proposed resolution:</b></p>

<p>
Modify Table 87 as follows:
</p>

<table border="1">
<caption>Table 87 &mdash; Unordered associative container requirements</caption>

<tr>
<th>
Expression
</th>
<th>
Return type
</th>
<th>
Assertion/note pre-/post-condition
</th>
<th>
Complexity
</th>
</tr>

<tr>
<td>
<code>a.max_load_factor(z)</code>
</td>
<td>
<code>void</code>
</td>
<td>
<p>
Pre: <code>z</code> shall be positive.  May change the container's maximum
load factor, uing <code>z</code> as a hint.
</p>
<p>
<ins>Post: <code>a.load_factor() &lt;= a.max_load_factor()</code></ins>
</p>
<p>
<ins><i>Note:</i> <code>a.load_factor()</code> is not modified by this operation.</ins>
</p>
</td>
<td>
Constant
</td>
</tr>

</table>






<hr>
<h3 id="2202"><a href="2202">2202</a>. Missing allocator support by <code>async</code></h3>
<p><b>Section:</b> 32.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2012-10-19 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>Discussion:</b></p>

<p>
<code>promise</code>, <code>packaged_task</code>, and <code>async</code> are the only
places where a shared state is actually supposed to be allocated. Accordingly,
<code>promise</code> and <code>packaged_task</code> are "allocator-aware". But
function template <code>async</code> provides no way to provide an allocator.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Matt: deprecate async 
<p/>
Nico: read my paper 
<p/>
Alisdair: defer issues to wait for polymorphic allocators 
<p/>
Alisdair: defer, active topic of research Deferred 
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
We want whatever status approximates: "will not fix; we're working on a replacement facility and don't want to add features to a broken one"
</p>


<p id="res-2202"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2206"><a href="2206">2206</a>. Inaccuracy in <code>initializer_list</code> constructor requirements</h3>
<p><b>Section:</b> 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, 29.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-21 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> p3, we have "<code>il</code> designates an object of type
<code>initializer_list&lt;value_type&gt;</code>", and then several functions that take
'<code>il</code>' as an argument. However, an expression like <code>{1, 2, 'a'}</code> is <em>not</em>
an object of type <code>initializer_list&lt;int&gt;</code> unless it's used to initialize
an explicitly-typed variable of that type. I believe we want:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v;
v = {1, 2, 'a'};
</pre></blockquote>
<p>
to compile portably, so we should say something different when defining '<code>il</code>'. The 
same phrasing happens in 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>, and 
29.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a>.
<p/>
This may just be an editorial issue because the actual class synopses declare the functions 
to take <code>initializer_list&lt;exact_type&gt;</code>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This is definitely not NAD
</p>
<p>
Should copy the suggested wording as the proposed resolution.
</p>

<p><i>[2019-03-26; Daniel comments and provides wording]</i></p>

<p>
The 2013-03-15 comment is confusing, since it recommends to "copy the suggested wording as the proposed resolution". 
I couldn't find such wording in the issue nor in the associated wiki, so I provided that wording out of myself.
The tricky part is to define which kind of <i>braced-init-list</i> we want to allow. As Tim Song pointed out, we
still need the existing support for <code>std::initializer_list&lt;value_type&gt;</code> as well, because otherwise
existing semantics based on expressions such as <code>li.begin()</code> won't work anymore.
The below suggested wording restricts supported <i>braced-init-list</i>s to every initializer list that can be used 
to copy-list-initialize an object of type <code>std::initializer_list&lt;value_type&gt;</code> by saying:
</p>
<blockquote><p>
"<code>bil</code> designates any <i>braced-init-list</i> suitable to copy-list-initialize an object of type 
<code>initializer_list&lt;value_type&gt;</code> (9.5.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>)"
</p></blockquote>
<p>
As a drive-by fix, the provided wording adds another initialization "expression" that makes the construction 
of the form
</p>
<blockquote><pre>
std::vector&lt;int&gt; v = {1, 2, 'a'};
</pre></blockquote>
<p>
valid (We just miss a copy-initialization case).
</p>


<p id="res-2206"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> We need to special-case the "expression" <code>X u = bil;</code> below,
because for empty <i>braced-init-list</i> the effects are those of calling the default 
constructor. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<ol>
<li><p>Modify 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote>
<p>
-3- In Tables 66 and 67, [&hellip;] <code>il</code> designates a<del>n object</del><ins>value</ins> of type 
<code>initializer_list&lt;value_type&gt;</code>, <ins><code>bil</code> designates any <i>braced-init-list</i> 
suitable to copy-list-initialize an object of type <code>initializer_list&lt;value_type&gt;</code> 
(9.5.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>),</ins> [&hellip;]
</p>
</blockquote>

</li>

<li><p>Modify Table 66 &mdash; "Sequence container requirements (in addition to container)" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 66 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>X(il)</code><br/>
<ins><code>X u = il;</code></ins>
</td>
<td><code></code></td>
<td>
Equivalent to <code>X(il.begin(), il.end())</code><br/>
<ins>or <code>X u(il.begin(), il.end());</code>, respectively</ins>
</td>
</tr>
<tr>
<td>
<ins><code>X(bil)</code></ins>
</td>
<td><code></code></td>
<td>
<ins>Equivalent to <code>X(initializer_list&lt;value_type&gt;(bil))</code></ins>
</td>
</tr>
<tr>
<td>
<ins><code>X u = bil;</code></ins>
</td>
<td><code></code></td>
<td>
<ins>If <code>bil</code> is empty, equivalent to <code>X u;</code>, otherwise<br/>
equivalent to <code>X u = initializer_list&lt;value_type&gt;(bil);</code></ins>
</td>
</tr>
<tr>
<td>
<code>a = il</code>
</td>
<td><code>X&amp;</code></td>
<td>
[&hellip;]
</td>
</tr>
<tr>
<td>
<ins><code>a = bil</code></ins>
</td>
<td><ins><code>X&amp;</code></ins></td>
<td>
<ins>Equivalent to <code>a = initializer_list&lt;value_type&gt;(bil)</code></ins>
</td>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a.insert(p, il)</code>
</td>
<td><code>iterator</code></td>
<td>
[&hellip;]
</td>
</tr>
<tr>
<td>
<ins><code>a.insert(p, bil)</code></ins>
</td>
<td><ins><code>iterator</code></ins></td>
<td>
<ins>Equivalent to <code>a.insert(p, initializer_list&lt;value_type&gt;(bil))</code></ins>
</td>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a.assign(il)</code>
</td>
<td><code>void</code></td>
<td>
[&hellip;]
</td>
</tr>
<tr>
<td>
<ins><code>a.assign(bil)</code></ins>
</td>
<td><ins><code>void</code></ins></td>
<td>
<ins>Equivalent to <code>a.assign(initializer_list&lt;value_type&gt;(bil))</code></ins>
</td>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> as indicated:</p>

<blockquote>
<p>
-8- In Table 69, [&hellip;] <code>il</code> designates a<del>n object</del><ins>value</ins> of type 
<code>initializer_list&lt;value_type&gt;</code>, <ins><code>bil</code> designates any <i>braced-init-list</i> 
suitable to copy-list-initialize an object of type <code>initializer_list&lt;value_type&gt;</code> 
(9.5.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>),</ins> [&hellip;]
</p>
</blockquote>

</li>

<li><p>Modify Table 69 &mdash; "Associative container requirements (in addition to container)" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 69 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>X(il)</code><br/>
<ins><code>X u = il;</code></ins>
</td>
<td><code></code></td>
<td>
same as <code>X(il.begin(), il.end())</code><br/>
<ins>or <code>X u(il.begin(), il.end());</code>, respectively</ins>
</td>
<td>
same as <code>X(il.begin(), il.end())</code><br/>
<ins>or <code>X u(il.begin(), il.end());</code>, respectively</ins>
</td>
</tr>
<tr>
<td>
<ins><code>X(bil)</code></ins>
</td>
<td><code></code></td>
<td>
<ins>Equivalent to <code>X(initializer_list&lt;value_type&gt;(bil))</code></ins>
</td>
<td></td>
</tr>
<tr>
<td>
<ins><code>X u = bil;</code></ins>
</td>
<td><code></code></td>
<td>
<ins>If <code>bil</code> is empty, equivalent to <code>X u;</code>, otherwise<br/>
equivalent to <code>X u = initializer_list&lt;value_type&gt;(bil);</code></ins>
</td>
<td></td>
</tr>
<tr>
<td>
<code>X(il,c)</code>
</td>
<td><code></code></td>
<td>
same as <code>X(il.begin(), il.end(), c)</code>
</td>
<td>
same as <code>X(il.begin(), il.end(), c)</code>
</td>
</tr>
<tr>
<td>
<ins><code>X(bil, c)</code></ins>
</td>
<td><code></code></td>
<td>
<ins>Equivalent to <code>X(initializer_list&lt;value_type&gt;(bil), c)</code></ins>
</td>
<td></td>
</tr>
<tr>
<td>
<code>a = il</code>
</td>
<td><code>X&amp;</code></td>
<td>
[&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>
<tr>
<td>
<ins><code>a = bil</code></ins>
</td>
<td><ins><code>X&amp;</code></ins></td>
<td>
<ins>Equivalent to <code>a = initializer_list&lt;value_type&gt;(bil)</code></ins>
</td>
<td></td>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a.insert(il)</code>
</td>
<td><code>void</code></td>
<td>
equivalent to <code>a.insert(il.begin(), il.end())</code>
</td>
<td></td>
</tr>
<tr>
<td>
<ins><code>a.insert(bil)</code></ins>
</td>
<td><ins><code>void</code></ins></td>
<td>
<ins>Equivalent to <code>a.insert(initializer_list&lt;value_type&gt;(bil))</code></ins>
</td>
<td></td>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a.assign(il)</code>
</td>
<td><code>void</code></td>
<td>
[&hellip;]
</td>
</tr>
<tr>
<td>
<ins><code>a.assign(bil)</code></ins>
</td>
<td><ins><code>void</code></ins></td>
<td>
<ins>Equivalent to <code>a.assign(initializer_list&lt;value_type&gt;(bil))</code></ins>
</td>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p11's bullet list as indicated:</p>

<blockquote>
<p>
-11- In Table 70:
</p>
<ol style="list-style-type: none">
<li><p>(11.1) &mdash; [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(11.14) &mdash; <code>il</code> denotes a value of type <code>initializer_list&lt;value_type&gt;</code>,</p></li>
<li><p><ins>(11.?) &mdash; <code>bil</code> denotes any <i>braced-init-list</i> suitable to copy-list-initialize 
an object of type <code>initializer_list&lt;value_type&gt;</code> (9.5.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>), </ins></p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>

</li>

<li><p>Modify Table 70 &mdash; "Unordered associative container requirements (in addition to container)" as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> There is a preexisting issue with Table 70, that there is no symbol <code>u</code> specified
("<code>u</code> denotes the name of a variable being declared"), so existing initialization forms with a named
variable are currently always written as "<code>X a[&hellip;]</code>" where <code>a</code> is defined as "<code>a</code> denotes a 
value of type <code>X</code>", the wording below follows this existing practice but the author of this wording would 
like to kindly ask the Project Editor to introduce said symbol <code>u</code> and apply it to all existing and new such 
named initialization forms instead. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<table border="1">
<caption>Table 70 &mdash; Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>X(il)</code><br/>
<ins><code>X a = il;</code></ins>
</td>
<td><code>X</code></td>
<td>
Same as <code>X(il.begin(), il.end())</code><br/>
<ins>or <code>X a(il.begin(), il.end());</code>, respectively</ins>
</td>
<td>
Same as <code>X(il.begin(), il.end())</code><br/>
<ins>or <code>X a(il.begin(), il.end());</code>, respectively</ins>
</td>
</tr>
<tr>
<td>
<ins><code>X(bil)</code></ins>
</td>
<td><ins><code>X</code></ins></td>
<td>
<ins>Equivalent to <code>X(initializer_list&lt;value_type&gt;(bil))</code></ins>
</td>
<td></td>
</tr>
<tr>
<td>
<ins><code>X a = bil;</code></ins>
</td>
<td><ins><code>X</code></ins></td>
<td>
<ins>If <code>bil</code> is empty, equivalent to <code>X a;</code>, otherwise<br/>
equivalent to <code>X a = initializer_list&lt;value_type&gt;(bil);</code></ins>
</td>
<td></td>
</tr>
<tr>
<td>
<code>X(il, n)</code>
</td>
<td><code>X</code></td>
<td>
Same as <code>X(il.begin(), il.end(), n)</code>
</td>
<td>
Same as <code>X(il.begin(), il.end(), n)</code>
</td>
</tr>
<tr>
<td>
<ins><code>X(bil, n)</code></ins>
</td>
<td><ins><code>X</code></ins></td>
<td>
<ins>Equivalent to <code>X(initializer_list&lt;value_type&gt;(bil), n)</code></ins>
</td>
<td></td>
</tr>
<tr>
<td>
<code>X(il, n, hf)</code>
</td>
<td><code>X</code></td>
<td>
Same as <code>X(il.begin(), il.end(), n, hf)</code>
</td>
<td>
Same as <code>X(il.begin(), il.end(), n, hf)</code>
</td>
</tr>
<tr>
<td>
<ins><code>X(bil, n, hf)</code></ins>
</td>
<td><ins><code>X</code></ins></td>
<td>
<ins>Equivalent to <code>X(initializer_list&lt;value_type&gt;(bil), n, hf)</code></ins>
</td>
<td></td>
</tr>
<tr>
<td>
<code>X(il, n, hf, eq)</code>
</td>
<td><code>X</code></td>
<td>
Same as <code>X(il.begin(), il.end(), n, hf, eq)</code>
</td>
<td>
Same as <code>X(il.begin(), il.end(), n, hf, eq)</code>
</td>
</tr>
<tr>
<td>
<ins><code>X(bil, n, hf, eq)</code></ins>
</td>
<td><ins><code>X</code></ins></td>
<td>
<ins>Equivalent to <code>X(initializer_list&lt;value_type&gt;(bil), n, hf, eq)</code></ins>
</td>
<td></td>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a = il</code>
</td>
<td><code>X&amp;</code></td>
<td>
[&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>
<tr>
<td>
<ins><code>a = bil</code></ins>
</td>
<td><ins><code>X&amp;</code></ins></td>
<td>
<ins>Equivalent to <code>a = initializer_list&lt;value_type&gt;(bil)</code></ins>
</td>
<td></td>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a.insert(il)</code>
</td>
<td><code>void</code></td>
<td>
Same as <code>a.insert(il.begin(), il.end())</code>.
</td>
<td>
Same as <code>a.insert(il.begin(), il.end())</code>.
</td>
</tr>
<tr>
<td>
<ins><code>a.insert(bil)</code></ins>
</td>
<td><ins><code>void</code></ins></td>
<td>
<ins>Equivalent to <code>a.insert(initializer_list&lt;value_type&gt;(bil))</code></ins>
</td>
<td></td>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify 29.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> p2's bullet list as indicated:</p>

<blockquote>
<p>
-2- A class <code>S</code> satisfies the requirements of a seed sequence if the expressions shown in Table 82 are 
valid and have the indicated semantics, and [&hellip;] In that Table and throughout this subclause:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p><ins>(2.?) &mdash; <code>u</code> denotes the name of a variable being declared,</ins></p></li>
<li><p>[&hellip;]</p></li>
<li><p>(2.6) &mdash; <code>il</code> is a value of <code>initializer_list&lt;T&gt;</code><del>.</del><ins>;</ins></p></li>
<li><p><ins>(2.?) &mdash; <code>bil</code> denotes any <i>braced-init-list</i> suitable to 
copy-list-initialize an object of type <code>initializer_list&lt;T&gt;</code> 
(9.5.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>).</ins></p></li>
</ol>
</blockquote>

</li>

<li><p>Modify Table 82 &mdash; "Seed sequence requirements" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 82 &mdash; Seed sequence requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Pre&#47;post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>S(il)</code><br/>
<ins><code>S u = il;</code></ins>
</td>
<td></td>
<td>
Same as <code>S(il.begin(), il.end())</code><br/>
<ins>or <code>S u(il.begin(), il.end());</code>, respectively</ins>
</td>
<td>
same as <code>S(il.begin(), il.end())</code><br/>
<ins>or <code>S u(il.begin(), il.end());</code>, respectively</ins>
</td>
</tr>
<tr>
<td>
<ins><code>S(bil)</code></ins>
</td>
<td></td>
<td>
<ins>Equivalent to <code>S(initializer_list&lt;T&gt;(bil))</code></ins>
</td>
<td></td>
</tr>
<tr>
<td>
<ins><code>S u = bil;</code></ins>
</td>
<td></td>
<td>
<ins>If <code>bil</code> is empty, equivalent to <code>S u;</code>, otherwise<br/>
equivalent to <code>S u = initializer_list&lt;T&gt;(bil);</code></ins>
</td>
<td></td>
</tr>
<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>

</li>

</ol>





<hr>
<h3 id="2214"><a href="2214">2214</a>. Clarify <code>basic_ios::init</code> call restrictions</h3>
<p><b>Section:</b> 31.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andrey Semashev <b>Opened:</b> 2012-11-09 <b>Last modified:</b> 2021-07-31</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is an ambiguity in how <code>std::basic_ios::init</code> method (31.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a>)
can be used in the derived class. The Standard only specify the state of the <code>basic_ios</code>
object after the call completes. However, in <code>basic_ios</code> default constructor description
(31.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a>) there is this sentence:
</p>
<blockquote><p>
<i>Effects</i>: Constructs an object of class <code>basic_ios</code> (31.5.2.8 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a>)
leaving its member objects uninitialized. The object shall be initialized by calling <code>basic_ios::init</code>
before its first use or before it is destroyed, whichever comes first; otherwise the behavior is undefined.
</p></blockquote>
<p>
This restriction hints that <code>basic_ios::init</code> should be called exactly
once before the object can be used or destroyed, because <code>basic_ios::init</code>
may not know whether it was called before or not (i.e. whether its members are actually
uninitialized or are initialized by the previous call to <code>basic_ios::init</code>). There
is no such restriction in the <code>basic_ios::init</code> preconditions so it is not clear whether it is
allowed to call <code>basic_ios::init</code> multiple times or not.
<p/>
This problem has already affected publicly available implementations.
For example, Microsoft Visual C++ STL introduces a memory leak if
<code>basic_ios::init</code> is called multiple times, while GCC 4.7 and STLPort
reinitialize the <code>basic_ios</code> object correctly without memory leak or any
other undesired effects. There was a discussion of this issue on Boost
<a href="http://article.gmane.org/gmane.comp.lib.boost.devel/235659">developers mailing list</a>,
and there is a <a href="https://sourceforge.net/apps/trac/boost-log/ticket/2#comment:4">test case
that reproduces the problem</a>. The test case is actually a bug report for my Boost.Log library,
which attempts to cache <code>basic_ostream</code>-derived objects internally to avoid expensive construction
and destruction. My stream objects allowed resetting the stream buffer pointers the stream
is attached to, without requiring to destroy and construct the stream.
<p/>
My personal view of the problem and proposed resolution follows.
<p/>
While apparently the intent of <code>basic_ios::init</code> is to provide a way to
initialize <code>basic_ios</code> after default construction, I see no reason to
forbid it from being called multiple times to reinitialize the stream.
Furthermore, it is possible to implement a conforming <code>basic_ios</code> that
does not have this restriction.
<p/>
The quoted above section of the Standard that describes the effects of
the default constructor is misleading. The Standard does not mandate
any data members of <code>basic_ios</code> or <code>ios_base</code> (31.5.2 <a href="https://timsong-cpp.github.io/cppwp/ios.base">[ios.base]</a>), which
it derives from. This means that the implementation is allowed to use
non-POD data members with default constructors that initialize the
members with particular default values. For example, in the case of
Microsoft Visual C++ STL the leaked memory is an <code>std::locale</code> instance
that is dynamically allocated during <code>basic_ios::init</code>, a raw pointer to
which is stored within ios_base. It is possible to store e.g. an
<code>unique_ptr</code> instead of a raw pointer as a member of <code>ios_base</code>, the smart
pointer will default initialize the underlying raw pointer on default
construction and automatically destroy the allocated object upon being
reset or destroyed, which would eliminate the leak and allow
<code>basic_ios::init</code> to be called multiple times. This leads to conclusion
that the default constructor of <code>basic_ios</code> cannot leave "its member
objects uninitialized" but instead performs default initialization of
the member objects, which would mean the same thing in case of POD types.
<p/>
However, I feel that restricting <code>ios_base</code> and <code>basic_ios</code> members to
non-POD types is not acceptable. Since multiple calls to <code>basic_ios::init</code> are
not forbidden by the Standard, I propose to correct the <code>basic_ios</code> default
constructor description so that it is allowed to destroy <code>basic_ios</code> object
without calling <code>basic_ios::init</code>. This would imply that any raw members of
<code>basic_ios</code> and <code>ios_base</code> should be initialized to values suitable for
destruction (essentially, this means only initializing raw pointers to NULL). The new
wording could look like this:
</p>
<blockquote><p>
<i>Effects</i>: Constructs an object of class <code>basic_ios</code> (31.5.2.8 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a>)
initializing its member objects to unspecified state, only suitable for <code>basic_ios</code> destruction.
The object shall be initialized by calling <code>basic_ios::init</code> before its first use; otherwise
the behavior is undefined.
</p></blockquote>
<p>
This would remove the hint that <code>basic_ios::init</code> must be called exactly
once. Also, this would remove the requirement for <code>basic_ios::init</code> to
be called at all before the destruction. This is also an important issue because
the derived stream constructor may throw an exception before it manages to call
<code>basic_ios::init</code> (for example, if the streambuf constructor throws), and
in this case the <code>basic_ios</code> destructor has undefined behavior.
<p/>
To my mind, the described modification is sufficient to resolve the issue. But to
emphasize the possibility to call <code>basic_ios::init</code> multiple times, a remark
or a footnote for <code>basic_ios::init</code> postconditions could be added to explicitly
state the semantics of calling it multiple times. The note could read as follows:
</p>
<blockquote><p>
The function can be called multiple times during the object lifetime. Each subsequent
call reinitializes the object to the described in postconditions initial state.
</p></blockquote>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Alisdair: The current wording is unclear but the proposed resolution is wrong
<p/>
Solution: Clarify that <code>init</code> must be called once and only once. Move then to review.
</p>

<p><i>[2021-07-29 Tim comments]</i></p>

<p>
The requirement that "<code>init</code> must be called once and only once" conflicts
with the disposition of LWG <a href="135" title="basic_iostream doubly initialized (Status: NAD)">135</a>.
</p>


<p id="res-2214"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 31.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/basic.ios.cons">[basic.ios.cons]</a> as indicated:</p>
<blockquote><pre>
basic_ios();
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Constructs an object of class <code>basic_ios</code> (31.5.2.8 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a>)
<del>leaving its member objects uninitialized</del><ins>initializing its member objects to unspecified state,
only suitable for <code>basic_ios</code> destruction</ins>. The object shall be initialized by calling
<code>basic_ios::init</code> before its first use <del>or before it is destroyed, whichever comes first</del>;
otherwise the behavior is undefined.
</p>
</blockquote>
<pre>
void init(basic_streambuf&lt;charT,traits&gt;* sb);
</pre><blockquote>
<p>
<i>Postconditions</i>: The postconditions of this function are indicated in Table 128.
<p/>
<ins>-?- <i>Remarks</i>: The function can be called multiple times during the object lifetime. Each subsequent
call reinitializes the object to the described in postconditions initial state.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="2215"><a href="2215">2215</a>. (unordered) associative container functors should be <code>CopyConstructible</code></h3>
<p><b>Section:</b> 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-11-14 <b>Last modified:</b> 2015-10-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on the functors used to arrange elements in the various associative and
unordered containers are given by a set of expressions in tables 102 &mdash; Associative container
requirements, and 103 &mdash; Unordered associative container requirements.  In keeping with Library
convention these expressions make the minimal requirements necessary on their types.  For
example, we have the following 3 row extracts for the unordered containers:
</p>
<table>
<tr>
  <td>
    <b>Expression</b>
  </td>
  <td>
    <b>Assertion/note pre-/post-condition</b>
  </td>
</tr>

<tr>
  <td>
<pre>
<code>X(n, hf, eq)</code>
<code>X a(n, hf, eq)</code>
</pre>
  </td>
  <td>
    <i>Requires:</i> <code>hasher</code> and <code>key_equal</code> are <code>CopyConstructible</code>.
 </td>
</tr>

<tr>
  <td>
<pre>
<code>X(n, hf)</code>
<code>X a(n, hf)</code>
</pre>
  </td>
  <td>
    <i>Requires:</i> <code>hasher</code> is <code>CopyConstructible</code> and 
                  <code>key_equal</code> is <code>DefaultConstructible</code>.
 </td>
</tr>

<tr>
  <td>
<pre>
<code>X(n)</code>
<code>X a(n)</code>
</pre>
  </td>
  <td>
    <i>Requires:</i> <code>hasher</code> and <code>key_equal</code> are <code>DefaultConstructible</code>.
 </td>
</tr>
</table>

<p>
However, the signature for each class template requires that the functors must effectively be
<code>CopyConstructible</code> for each of these expressions:
</p>

<blockquote><pre>
template &lt;class Key,
          class T,
          class Hash  = hash&lt;Key>,
          class Pred  = std::equal_to&lt;Key>,
          class Allocator = std::allocator&lt;std::pair&lt;const Key, T> > >
class unordered_map
{
  <i>...</i>

  <i>// construct/destroy/copy</i>
  explicit unordered_map(size_type n = <i>see below</i>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());

  <i>...</i>
}
</pre></blockquote>

<p>
The letter of the standard can be honored as long as implementors recognize
their freedom to split this one signature into multiple overloads, so that
the documented default arguments (requiring a <code>CopyConstructible</code> functor)
are not actually passed as default arguments.
</p>
<p>
As we look into the requirements for the copy constructor and copy-assignment
operator, the requirements are even more vague, as the explicit requirements on
the functors are not called out, other than saying that the functors are copied.
</p>
<p>
Must the functors be <code>CopyAssignable</code>? Or is <code>CopyConstructible</code>
sufficient in this case?  Do we require that the functors be <code>Swappable</code>
so that the copy-swap idiom can be deployed here?  Note that a type that is both
<code>CopyConstructible</code> and <code>CopyAssignable</code> is still not guaranteed to
be <code>Swappable</code> as the user may delete the <code>swap</code> function for their
type in their own namespace, which would be found via ADL.
</p>
<p>
Some clean-up of the requirements table looks necessary, to at least document the
assignment behavior.  In addition, we should have clear guidance on whether these
functors should always be <code>CopyConstructible</code>, as suggested by the class
template definitions, or if the requirement tables are correct and we should
explicitly split up the constructors in the (unordered) associative containers
to no longer use default (function) arguments to obtain their defaulted functors.
</p>
<p>
I recommend the simplest solution would be to always require that the functors
for (unordered) associative containers be <code>CopyConstructible</code>, above the
requirements tables themselves, so that the issue need not be addressed within
the tables.  I suggest that the assignment operators for these containers add
the requirement that the functors be <code>Swappable</code>, rather than forwarding
the corresponding <code>Assignable</code> requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to propose wording.
</p>

<p><i>[2014-06-08, Daniel comments]</i></p>

<p>
The area of this issue partially overlaps what LWG <a href="2227" title="Stateful comparison objects in associative containers (Status: Open)">2227</a> addresses.
</p>

<p><i>[2015-10-20, Daniel comments]</i></p>

<p>
The revised resolution of LWG <a href="2227" title="Stateful comparison objects in associative containers (Status: Open)">2227</a> should resolve this issue as well. It follows the recommendations
of the submitter to require <code>CopyConstructible</code> requirements for the function objects owned by containers,
but it does not impose any further fundamental requirements.
</p>


<p id="res-2215"><b>Proposed resolution:</b></p>
<p>
See the resolution of LWG <a href="2227" title="Stateful comparison objects in associative containers (Status: Open)">2227</a>.
</p>





<hr>
<h3 id="2216"><a href="2216">2216</a>. <code>regex_replace(basic_string)</code> allocator handling</h3>
<p><b>Section:</b> 28.6.10.4 <a href="https://timsong-cpp.github.io/cppwp/re.alg.replace">[re.alg.replace]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-11-26 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<blockquote><pre>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
      const basic_regex&lt;charT, traits&gt;&amp; e,
      const charT* fmt,
      regex_constants::match_flag_type flags = 
	    regex_constants::match_default);
</pre></blockquote>
<p>
and friends are documented as
</p>
<blockquote><p>
Constructs an empty string result of type <code>basic_string&lt;charT, ST, SA&gt;</code>
and calls <code>regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags)</code>.
</p></blockquote>
<p>
This appears to require the result to have a default-constructed
allocator, which isn't even possible for all allocator types. I
suspect the allocator should be copied from 's' instead. Possibly
there should be an additional defaulted argument to override the
allocator of the result.
</p>



<p id="res-2216"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2220"><a href="2220">2220</a>. Under-specification of <code>operator==</code> for <code>regex_token_iterator</code></h3>
<p><b>Section:</b> 28.6.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.comp">[re.tokiter.comp]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-11-21 <b>Last modified:</b> 2024-10-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Consider the following example:
</p>
<blockquote><pre>
std::string str0("x");
std::regex rg0("a");
std::regex_token_iterator it0(str0.begin(), str0.end(), rg0, -1); // points at "x" in str0
std::string str1("x");
std::regex rg1("b");
std::regex_token_iterator it1(str1.begin(), str1.end(), rg1, -1); // points at "x" in str1
</pre></blockquote>
<p>
28.6.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.comp">[re.tokiter.comp]</a> p1 says that <code>it0.operator==(it1)</code> returns true "if
<code>*this</code> and <code>right</code> are both suffix iterators and <code>suffix == right.suffix</code>"; both
conditions are satisfied in this example. It does not say that they must both be iterators
into the same sequence, nor does it say (as general iterator requirements do) that they must
both be in the domain of <code>==</code> in order for the comparison to be meaningful. It's a
simple statement: they're equal if the strings they point at compare equal. Given this being
a valid comparison, the obtained result of "true" looks odd.
<p/>
The problem is that for iterator values prior to the suffix iterator, equality means the same
regular expression and the same matched sequence (both uses of "same" refer to identity, not equality);
for the suffix iterator, equality means that the matched sequences compare equal.
</p>

<p><i>[2014-02-10]</i></p>

<p>Priority set to 2</p>

<p><i>[2018-08-20 Casey adds a proposed resolution]</i></p>

<p>Priority changed to 3.</p>
Marshall notes that iterator comparisons typically require the iterators to
denote elements of the same sequence.

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ul>
<li><p>Modify 28.6.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.comp">[re.tokiter.comp]</a> as follows:</p>
<blockquote>
<pre>
bool operator==(const regex_token_iterator&amp; right) const;
</pre>
<p>
<ins>-?- <i>Expects:</i> <code>*this</code> and <code>right</code> are both
end-of-sequence iterators or both have the same underlying sequence.</ins>
</p><p>
-1- <i>Returns:</i> <code>true</code> if <code>*this</code> and <code>right</code> are both
end-of-sequence iterators, or if [&hellip;]
</p>
<pre>
bool operator!=(const regex_token_iterator&amp; right) const;
</pre>
<p>
<ins>-?- <i>Expects:</i> <code>*this</code> and <code>right</code> are both
end-of-sequence iterators or both have the same underlying sequence.</ins>
</p><p>
-2- <i>Returns:</i> <code>!(*this == right)</code>.
</p>
</blockquote>
</li>
</ul>
</blockquote>

<p><i>[2018-08-23 Casey revises the P/R in response to LWG feedback]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ul>
<li><p>Modify 28.6.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.comp">[re.tokiter.comp]</a> as follows:</p>
<blockquote>
<pre>
bool operator==(const regex_token_iterator&amp; right) const;
</pre>
<p>
<ins>-?- <i>Expects:</i> At least one of <code>*this</code> and <code>right</code> is an
end-of-sequence iterator, or both <code>*this</code> and <code>right</code> have the
same underlying sequence.</ins>
</p><p>
-1- <i>Returns:</i> <code>true</code> if <code>*this</code> and <code>right</code> are both
end-of-sequence iterators, or if [&hellip;]
</p>
<pre>
bool operator!=(const regex_token_iterator&amp; right) const;
</pre>
<p>
<ins>-?- <i>Expects:</i> At least one of <code>*this</code> and <code>right</code> is an
end-of-sequence iterator, or both <code>*this</code> and <code>right</code> have the
same underlying sequence.</ins>
</p><p>
-2- <i>Returns:</i> <code>!(*this == right)</code>.
</p>
</blockquote>
</li>
</ul>
</blockquote>

<p><i>[2024-10-03; Jonathan rebases the wording on the latest WP]</i></p>




<p id="res-2220"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.</p>

<ul>
<li><p>Modify 28.6.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/re.tokiter.comp">[re.tokiter.comp]</a> as follows:</p>
<blockquote>
<pre>
bool operator==(const regex_token_iterator&amp; right) const;
</pre>
<p>
<ins>-?- <i>Preconditions:</i>
At least one of <code>*this</code> and <code>right</code> is an end-of-sequence iterator,
or <code>*this</code> and <code>right</code> have the same underlying sequence.</ins>
</p><p>
-1- <i>Returns:</i> <code>true</code> if <code>*this</code> and <code>right</code> are both
end-of-sequence iterators,
or if <code class='backtick'>*this</code> and <code class='backtick'>right</code> are both suffix iterators and <code class='backtick'>suffix == right.suffix</code>;
otherwise returns <code class='backtick'>false</code> if <code class='backtick'>*this</code> or <code class='backtick'>right</code> is an end-of-sequence iterator
or a suffix iterator.
Otherwise returns <code class='backtick'>true</code> if <code class='backtick'>position == right.position</code>, <code class='backtick'>N == right.N</code>,
and <code class='backtick'>subs == right.subs</code>.
Otherwise returns <code class='backtick'>false</code>.
</p>
</blockquote>
</li>
</ul>






<hr>
<h3 id="2227"><a href="2227">2227</a>. Stateful comparison objects in associative containers</h3>
<p><b>Section:</b> 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2012-12-19 <b>Last modified:</b> 2019-04-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 102 in 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>/8 states on expression <code>a.key_comp()</code> that it 
"returns the comparison object out of which a was constructed". At the same time, 
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/8 states (starting in the third line) that 
"...Any <code>Compare</code>, <code>Pred</code>, or <code>Hash</code> objects belonging to <code>a</code> and <code>b</code> 
shall be swappable and <em>shall be exchanged</em> by unqualified calls to non-member swap...". This is 
problematic for any compliant implementation, since once swapped the container cannot return the comparison 
object out of which it was constructed unless incurring in storing an otherwise needless object.
<p/>
The simple solution is to correct that statement in Table 102, but I believe this is part of a larger problem 
of underspecified behavior: The new standard has made an effort in regards to allocators and now fully 
specifies what happens to stateful allocator objects. It has even specified what happens to stateful <code>hasher</code> 
and <code>key_equal</code> members of unordered containers (they propagate), but it says nothing about stateful 
comparison objects of (ordered) associative containers, except for the statement in 
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/8 referred above and only related to <code>swap</code>.
<p/>
For example, it is unclear to me what is specified to happen on an assignment: should the comparison object 
be copied/moved along with the elements, or should the left-hand side object keep its own?
Maybe this has been intentionally left unspecified with the purpose of compatibility with C++98, which I 
understand it specified that comparison objects were kept for the entire life of the container (like allocators) 
&mdash; an unfortunate choice. But anyway, the segment of 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> quoted 
above seems to break any possible backwards compatibility with C++98 in this regard.
<p/>
Therefore, taking into consideration consistency with how this is dealed with for unordered associative 
containers, I propose that Table 102 is modified as follows:
</p>
<ul>
<li>
<p>
The row for expression <code>a.key_comp()</code> is changed so that its "assertion/note pre-/post-condition" reads 
"Returns <code>a</code>'s comparison object."
</p>
</li>

<li>
<p>
A new row is added at the appropriate location (which I believe would be after "X(il)" row), with:
</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td>
<code>X(b)<br/>
X a(b)</code>
</td>
<td>
<code>X</code>
</td>
<td>
Copy constructor. In addition to<br/>
the requirements of Table 96, copies<br/>
the comparison object.
</td>
<td>
Linear in <code>b.size()</code>
</td>
</tr>

<tr>
<td>
<code>a = b</code>
</td>
<td>
<code>X&amp;</code>
</td>
<td>
Copy assignment operator. In addition to<br/>
the requirements of Table 96, copies the<br/>
comparison object.
</td>
<td>
Linear in <code>a.size()</code> and <code>b.size()</code>
</td>
</tr>

</table>
</blockquote>

</li>
</ul>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Review.
</p>

<p><i>[2013-04-18, Bristol]</i></p>
 
<p>
STL: can't believe we don't specify this already. this is totally necessary
<p/>
Alisdair: how does it do this? copy construction? assignment?
<p/>
Also need it for move.
<p/>
STL: we already specify this for constructing from a comparator, not during copy construction though.
<p/>
Jonathan: don't like wording, should say "<code>key_compare</code> is <code>CopyConstructible</code>. Uses <code>b.key_comp()</code> 
as a comparison object."
<p/>
STL: we get it right for unordered!
<p/>
Jonathan: can't wordsmith this now, but I think implementations do the right thing.
<p/>
Alisdair: not sure what right thing is for moves. Also we say nothing about propagating allocators to functors.
</p>
<p>
Moved to Open.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
TK: There's no need for fine-grained propagate/not-propagate control. If you don't want to propagate the predicate, you can 
simply construct or insert from an iterator range.
<p/>
VV: libstdc++ already implements the resolution of this issue.
<p/>
GR: There are a couple of other problems. We don't specify move constructor and move assignment for maps. Those are just general.
<p/>
TK: General container requirements already describe the semantics for {copy,move}-{construction,assignment}, so it doesn't 
seem that there's room for choice in <code>std::map</code> assignments. <code>unordered_map</code> is different, though.
<p/>
[Note: Check what general container requirements say about container equality.]
<p/>
DK will draft wording. The decision is to unambiguously make all {copy,move}-{construction,assignment} operations endow the 
LHS with the exact state of the RHS, including all predicates and hash function states.
<p/>
Conclusion: Update wording, revisit later. 
</p>

<p><i>[2015-05-06 Lenexa: Waiting for updated wording]</i></p>


<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Change Table 102 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>X(il)</code>
</td>
<td>
<code></code>
</td>
<td>
Same as <code>X(il.begin(), il.end())</code>.
</td>
<td>
same as <code>X(il.begin(), il.end())</code>.
</td>
</tr>

<tr>
<td>
<ins><code>X(b)<br/>
X a(b)</code></ins>
</td>
<td>
<code></code>
</td>
<td>
<ins>Copy constructor. In addition to<br/>
the requirements of Table 96, copies<br/>
the comparison object.</ins>
</td>
<td>
<ins>Linear in <code>b.size()</code></ins>
</td>
</tr>

<tr>
<td>
<ins><code>a = b</code></ins>
</td>
<td>
<ins><code>X&amp;</code></ins>
</td>
<td>
<ins>Copy assignment operator. In addition to<br/>
the requirements of Table 96, copies the<br/>
comparison object.</ins>
</td>
<td>
<ins>Linear in <code>a.size()</code> and <code>b.size()</code></ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>a.key_comp()</code>
</td>
<td>
<code>X::key_compare</code>
</td>
<td>
<del>r</del><ins>R</ins>eturns <del>the</del><ins><code>a</code>'s</ins> comparison object<br/>
<del>out of which a was constructed.</del>
</td>
<td>
constant
</td>
</tr>


</table>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2015-10-19 Daniel comments and provides alternative wording]</i></p>

<p>
The current standard is especially unclear in regard to what effects move operations of unordered/associative
containers should have. We have one example that is standardized exactly in this way by looking at 
23.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/priqueue.cons.alloc">[priqueue.cons.alloc]</a> p7:
</p>
<blockquote>
<pre>
template &lt;class Alloc&gt; priority_queue(priority_queue&amp;&amp; q, const Alloc&amp; a);
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Initializes <code>c</code> with <code>std::move(q.c)</code> as the first argument and <code>a</code> as 
the second argument, and initializes <code>comp</code> with <code>std::move(q.comp)</code>
</p>
</blockquote>
</blockquote>
<p>
A similarly comparable example are the move-operations of <code>std::unique_ptr</code> in regard to the deleter 
(when this is no a reference), which also respect move-capabilities of that function object.
<p/>
We have wording from C++98 for associative containers (but <em>not</em> for unordered containers!) that was never
adjusted to C++11 move-semantics in 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> p12:
</p>
<blockquote><p>
When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.
</p></blockquote>
<p>
The second sentence of this wording is problematic for several reasons:
</p>
<ol>
<li><p>It only talks about copy operations, not about move operations, except that the term "assignment" without
leading "copy" is a bit ambigious (albeit it seems clear in the complete context).</p></li>
<li><p>It is not really clear how to interpret "as if that comparison object had been
passed to the target container in its constructor" for an assignment operation. A possible but not conclusive
interpretation could be that this is wording supporting a "copy-via-swap" idiom.</p></li>
<li><p>There does not exist similar wording for unordered containers, except that Table 102 provides entries for
copy construction and copy assignment of the containers whose wording just talks of "copies" in either case.</p></li>
</ol>
<p>
Existing implementations differ already:
</p>
<ol>
<li><p>Visual Studio 2015 uses copy construction and copy assignment for the two copy operations but uses swap operations
for the move operations.</p></li>
<li><p>GCC's libstdc++ performs copy construction and copy assignment for the two copy operations and for the two
move operations, respectively</p></li>
<li><p>clang++'s libc++ performs copy/move construction and copy/move assignment for the corresponding
four copy/move operations</p></li>
</ol>
<p>
The alternative wording provided below attempts to clarify that container copy/move operations perform the corresponding
copy/move operations on the owned function objects.
<p/>
In addition the wording also resolves LWG <a href="2215" title="(unordered) associative container functors should be CopyConstructible (Status: Open)">2215</a>: I believe that the current
wording should require that container function objects should meet the <code>CopyConstructible</code> requirements. Adding
this general requirement also fixes the underspecified requirements of the accessor functions <code>key_comp()</code> and
<code>value_comp()</code>.
<p/>
I don't think that a general requirement for <code>Swappable</code> is needed, only the member <code>swap</code> function currently requires this.
Nonetheless the wording below does <em>support</em> stateful functors that are <em>also</em> moveable or move-assignable,
therefore the specified semantics in terms of move operations.
<p/>
I should add the following warning, though: If this proposed wording would be accepted, there is a little chance of
code breakage, because the current wording <em>can</em> be read that in general there is no requirement that the
container functors are <code>CopyConstructible</code>. The following code example is accepted by gcc + libstd++:
</p>
<blockquote><pre>
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

struct Cmp {
  Cmp() = default;
  Cmp(const Cmp&amp;) = delete;
  Cmp(Cmp&amp;&amp;) = delete;
  Cmp&amp; operator=(const Cmp&amp;) = delete;
  Cmp&amp; operator=(Cmp&amp;&amp;) = delete;
  template&lt;class T&gt;
  bool operator()(const T&amp; x, const T&amp; y) const
  {
    return x &lt; y;
  }
};

typedef std::map&lt;int, int, Cmp&gt; MyMap;

int main() {
  MyMap m;
  std::cout &lt;&lt; (m.find(12) == m.end()) &lt;&lt; std::endl;
}
</pre></blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4527.</p>

<ol>
<li><p>Change 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> p8 as indicated:</p>

<blockquote><p>
-8- In Table 101, <code>X</code> denotes an associative container class, <code>a</code> denotes a value of type <code>X</code>, 
<ins><code>b</code> denotes a possibly <code>const</code> value of type <code>X</code>, <code>rv</code> denotes a non-<code>const</code> rvalue of 
type <code>X</code>,</ins> <code>u</code> denotes the name of a variable being declared, [&hellip;]
</p></blockquote>
</li>

<li><p>Change Table 101 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 101 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>X::key_compare</code>
</td>
<td>
<code>Compare</code>
</td>
<td>
<ins><i>Requires</i>: <code>Compare</code> is <code>CopyConstructible</code>.</ins><br/>
defaults to <code>less&lt;key_type&gt;</code>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<code>X(c)<br/>
X u(c);</code>
</td>
<td>
<code></code>
</td>
<td>
<del><i>Requires:</i> <code>key_compare</code> is <code>CopyConstructible</code>.<br/></del> 
<i>Effects</i>: Constructs an empty container.<br/> 
Uses a copy of <code>c</code> as a comparison object.
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>X(i,j,c)<br/>
X u(i,j,c);</code>
</td>
<td>
<code></code>
</td>
<td>
<i>Requires:</i> <del><code>key_compare</code> is <code>CopyConstructible</code>.<br/></del> 
<code>value_type</code> is <code>EmplaceConstructible</code> into <code>X</code> from <code>*i</code>.<br/>
<i>Effects</i>: Constructs an empty container and inserts elements<br/>
from the range <code>[i, j)</code> into it; uses <code>c</code> as a comparison object.
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>X(il)</code>
</td>
<td>
<code></code>
</td>
<td>
Same as <code>X(il.begin(), il.end())</code>.
</td>
<td>
same as <code>X(il.begin(), il.end())</code>.
</td>
</tr>

<tr>
<td>
<ins><code>X(b)<br/>
X a(b)</code></ins>
</td>
<td>
<code></code>
</td>
<td>
<ins>(In addition to the requirements of Table 95)<br/>
<i>Effects:</i> Copy constructs the comparison object of <code>a</code> from<br/> 
the comparison object of <code>b</code>.</ins>
</td>
<td>
<ins>Linear in <code>b.size()</code></ins>
</td>
</tr>

<tr>
<td>
<ins><code>X(rv)<br/>
X a(rv)</code></ins>
</td>
<td>
<code></code>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Effects:</i> Move constructs the comparison object of <code>a</code> from<br/> 
the comparison object of <code>rv</code>.</ins>
</td>
<td>
<ins>constant</ins>
</td>
</tr>

<tr>
<td>
<ins><code>a = b</code></ins>
</td>
<td>
<ins><code>X&amp;</code></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <code>key_compare</code> is <code>CopyAssignable</code>.<br/> 
<i>Effects:</i> Copy assigns the comparison object of <code>b</code><br/>
to the comparison object of <code>a</code>.</ins>
</td>
<td>
<ins>Linear in <code>a.size()</code> and <code>b.size()</code></ins>
</td>
</tr>

<tr>
<td>
<ins><code>a = rv</code></ins>
</td>
<td>
<ins><code>X&amp;</code></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <code>key_compare</code> is <code>MoveAssignable</code>.<br/> 
<i>Effects:</i> Move assigns from the comparison object of <code>rv</code><br/>
to the comparison object of <code>a</code>.</ins>
</td>
<td>
<ins>Linear</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>a.key_comp()</code>
</td>
<td>
<code>X::key_compare</code>
</td>
<td>
<del>r</del><ins>R</ins>eturns <del>the</del><ins><code>a</code>'s</ins> comparison object<br/>
<del>out of which a was constructed.</del>
</td>
<td>
constant
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a> p12 as indicated:</p>

<blockquote><p>
-12- When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. <del>When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.</del>
</p></blockquote>
</li>


<li><p>Change 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> p11 as indicated:</p>

<blockquote><p>
-11- In Table 102: <code>X</code> denotes an unordered associative container class, <code>a</code> denotes a value of type <code>X</code>, 
<code>b</code> denotes a possibly <code>const</code> value of type <code>X</code>, <ins><code>rv</code> denotes a non-<code>const</code> rvalue 
of type <code>X</code>,</ins> [&hellip;]
</p></blockquote>
</li>

<li><p>Change Table 102 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>X::hasher</code>
</td>
<td>
<code>Hash</code>
</td>
<td>
<ins><i>Requires</i>: <code>Hash</code> is <code>CopyConstructible</code>.<br/></ins>
<code>Hash</code> shall be a unary function object type<br/> 
such that the expression <code>hf(k)</code> has type <code>std::size_t</code>.
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<code>X::key_equal</code>
</td>
<td>
<code>Pred</code>
</td>
<td>
<ins><i>Requires</i>: <code>Pred</code> is <code>CopyConstructible</code>.<br/></ins>
<code>Pred</code> shall be a binary predicate that takes<br/> 
two arguments of type <code>Key</code>.<br/> 
<code>Pred</code> is an equivalence relation.
</td>
<td>
compile time
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>X(n, hf, eq)<br/>
X a(n, hf, eq)</code>
</td>
<td>
<code>X</code>
</td>
<td>
<del><i>Requires</i>: <code>hasher</code> and <code>key_equal</code> are <code>CopyConstructible</code>.<br/></del>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<code>X(n, hf)<br/>
X a(n, hf)</code>
</td>
<td>
<code>X</code>
</td>
<td>
<i>Requires</i>: <del><code>hasher</code> is <code>CopyConstructible</code> and<br/></del>
<code>key_equal</code> is <code>DefaultConstructible</code>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>X(i, j, n, hf, eq)<br/>
X a(i, j, n, hf, eq)</code>
</td>
<td>
<code>X</code>
</td>
<td>
<i>Requires</i>: <del><code>hasher</code> and <code>key_equal</code> are <code>CopyConstructible</code>.<br/></del>
<code>value_type</code> is <code>EmplaceConstructible</code> into <code>X</code> from <code>*i</code>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<code>X(i, j, n, hf)<br/>
X a(i, j, n, hf)</code>
</td>
<td>
<code>X</code>
</td>
<td>
<i>Requires</i>: <del><code>hasher</code> is <code>CopyConstructible</code> and<br/></del>
<code>key_equal</code> is <code>DefaultConstructible</code>.<br/> 
<code>value_type</code> is <code>EmplaceConstructible</code> into <code>X</code> from <code>*i</code>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>X(b)<br/>
X a(b)</code>
</td>
<td>
<code>X</code>
</td>
<td>
<del>Copy constructor. In addition<br/>
to the requirements of Table 95,<br/>
copies the hash function,<br/>
predicate, and maximum load<br/>
factor.</del>
<ins>(In addition to the requirements of Table 95)<br/>
<i>Effects:</i> Copy constructs the hash function, predicate, and maximum load factor<br/> 
of <code>a</code> from the corresponding objects of <code>b</code>.</ins>
</td>
<td>
Average case linear in<br/> 
<code>b.size()</code>,<br/>
worst case quadratic.
</td>
</tr>

<tr>
<td>
<ins><code>X(rv)<br/>
X a(rv)</code></ins>
</td>
<td>
<ins><code>X</code></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Effects:</i> Move constructs the hash function, predicate, and maximum load factor<br/> 
of <code>a</code> from the corresponding objects of <code>rv</code>.</ins>
</td>
<td>
<ins>constant</ins>
</td>
</tr>

<tr>
<td>
<code>a = b</code>
</td>
<td>
<code>X&amp;</code>
</td>
<td>
<del>Copy assignment operator. In<br/>
addition to the requirements of<br/>
Table 95, copies the hash<br/>
function, predicate, and<br/>
maximum load factor.</del>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <code>hasher</code> and <code>key_equal</code> are <code>CopyAssignable</code>.<br/> 
<i>Effects:</i> Copy assigns the hash function, predicate, and maximum load factor<br/> 
of <code>b</code> to the corresponding objects of <code>a</code>.</ins>
</td>
<td>
Average case linear in<br/> 
<code>b.size()</code>,<br/>
worst case quadratic.
</td>
</tr>

<tr>
<td>
<ins><code>a = rv</code></ins>
</td>
<td>
<ins><code>X&amp;</code></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <code>hasher</code> and <code>key_equal</code> are <code>MoveAssignable</code>.<br/> 
<i>Effects:</i> Move assigns the hash function, predicate, and maximum load factor<br/> 
from <code>rv</code> to the corresponding objects of <code>a</code>.</ins>
</td>
<td>
<ins>Linear</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2016-08-07]</i></p>

<p>
Daniel removes the previously proposed wording to work on revised wording.
</p>

<p><i>[2019-04-22, Billy comments]</i></p>

<p>
In addition to the <i>Cpp17CopyConstructible</i> discussion going on there, I think we need to require that 
calling the comparison function when <code>Compare</code> itself is <code>const</code> needs to produce the same answer 
as if <code>Compare</code> is non-<code>const</code>.
</p>


<p id="res-2227"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2236"><a href="2236">2236</a>. <code>kill_dependency</code> unconditionally noexcept</h3>
<p><b>Section:</b> 32.5.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>, 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-01-19 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.syn">active issues</a> in [atomics.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.syn">issues</a> in [atomics.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The "magic" <code>kill_dependency</code> function is a function without any constraints on the template parameter <code>T</code> 
and is specified as
</p>

<blockquote><pre>
template &lt;class T&gt;
T kill_dependency(T y) noexcept;
</pre><blockquote>
<p>
-14- <i>Effects</i>: The argument does not carry a dependency to the return value (1.10).
<p/>
-15- <i>Returns</i>: <code>y</code>.
</p>
</blockquote></blockquote>

<p>
I wonder whether the unconditional <code>noexcept</code> is really intended here:
Assume we have some type <code>U</code> that has a potentially throwing move
constructor (or it has a potentially throwing copy constructor and no
move constructor), for any "normal" function template with the same
signature and the same effects (modulo the dependency magic) this
would mean that it cannot safely be declared <code>noexcept</code> because of the
return statement being part of the complete function call affected by
<code>noexcept</code> (The by-value function argument is irrelevant in this
context). In other words it seems that a function call such as
</p>

<blockquote><pre>
struct S {
  ...
  S(const S&amp; r) { if(<em>some condition</em>) throw Something(); }
  ...
};

int main() {
  S s1 = ...;
  S s2 = std::kill_dependency(s1);
}
</pre></blockquote>

<p>
would be required to call <code>std::terminate</code> if the copy constructor of <code>S</code> throws during the return 
of <code>std::kill_dependency</code>.
<p/>
To require copy elision for this already magic function would look like a low-hanging fruit to solve this problem, 
but this case is not covered by current copy elision rules see 12.8 p31 b1:
<p/>
"&mdash; in a return statement in a function with a class return type, when the expression is the name of a non-volatile 
automatic object (other than a function or catch-clause parameter) with the same <em>cv</em>-unqualified type as the 
function return type, the copy/move operation can be omitted by constructing the automatic object directly into the
function's return value".
<p/>
Some options come into my mind:
</p>
<ol>
<li><p>
Make the exception-specification a constrained one in regard via <code>std::is_nothrow_move_constructible</code>:
</p>

<blockquote><pre>
template &lt;class T&gt;
T kill_dependency(T y) noexcept(<em>see below</em>);
</pre></blockquote>

<p>
This is similar to the approach taken for function templates such as <code>std::swap</code>.
</p>
</li>

<li><p>
Use perfect forwarding (This needs further wording to correct the effects):
</p>

<blockquote><pre>
template &lt;class T&gt;
T&amp;&amp; kill_dependency(T&amp;&amp; y) noexcept;
</pre></blockquote>
</li>

<li><p>
Impose constraints on the template arguments in regard to throwing exceptions while copying/moving.
</p></li>

<li><p>
Keep the state as it is but possibly add a note about a call of <code>std::terminate</code> in above scenario.
</p></li>
</ol>

<p>
A second problem is that the current wording is not clear whether it is well-defined to call the function with
types that are reference types, such as in the following example:
</p>

<blockquote><pre>
#include &lt;atomic&gt;

int main()
{
  int a = 12;
  int&amp; b = std::kill_dependency&lt;int&amp;&gt;(a);
}
</pre></blockquote>

<p>
It is unclear what kind of dependency is killed here. This is presumably a core language problem, but could
affect the possible resolutions of the problem.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>
Recommend using a revised example:
</p>
<blockquote><pre>
int lookup(class D* p) 
{
  class E* q = p-&gt;a.load(memory_order_consume);
  int y = std::kill_dependency(q-&gt;y);
}
</pre></blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>



<p id="res-2236"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2237"><a href="2237">2237</a>. <code>&lt;cuchar&gt;</code> macros</h3>
<p><b>Section:</b> 27.5 <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2013-01-29 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in [c.strings].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Apparently C1X changes <code>__STDC_UTF_16__</code> and <code>__STDC_UTF_32__</code> from macros
defined in <code>uchar.h</code> (and reflected in C++ by Table 79) to be predefined by the compiler. 
Do we want to do the same?
</p>



<p id="res-2237"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2238"><a href="2238">2238</a>. Problematic iterator-pair constructor of containers</h3>
<p><b>Section:</b> 27.5 <a href="https://timsong-cpp.github.io/cppwp/c.strings">[c.strings]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Johannes Schaub <b>Opened:</b> 2013-02-02 <b>Last modified:</b> 2016-08-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in [c.strings].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The non-explicit nature of the iterator-pair constructor of containers, such a
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</pre></blockquote>

<p>
can be selected in unexpected situations, leading to a hard runtime error, as demonstrated by the following example:
</p>

<blockquote><pre>
#include &lt;vector&gt;

void f(std::vector&lt;char&gt; v){ /* ... */}

int main() {
  f({"A", "B"});
}
</pre></blockquote>

<p>
The actually intended initializer-list constructor isn't feasible here, so the best match is the constructor template
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</pre></blockquote>

<p>
This compiles, but will result in code running amok. The potential trap (that cannot be easily detected by the
library implementation) could be reduced by making this constructor explicit. It would still have the effect to 
be selected here, but the code would be ill-formed, so the programmer gets a clear message here.
</p>

<p><i>[2014-06 Rapperswil]</i></p>

<p>
JW: can't fix this, don't want to touch this, Do The Right Thing clause has been a source of tricky issues. 
only really happens with string literals, that's the only way to create an array that isn't obviously an array
<p/>
GR: want to see paper
<p/>
AM: is it only string literals, or also UDLs?
<p/>
STL: maybe, but we don't need to deal with that. This is only a problem in a very specific case 
<p/>
Leave as Open. 
</p>



<p id="res-2238"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2248"><a href="2248">2248</a>. <code>numeric_limits::is_iec559</code> misnamed</h3>
<p><b>Section:</b> 17.3.5 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2013-03-08 <b>Last modified:</b> 2018-11-08</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.limits">active issues</a> in [numeric.limits].</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits">issues</a> in [numeric.limits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This member should probably be named "is_ieee754". Or at least the standard should explain that IEC-559 no longer exists, 
and that it's been superseded by IEEE-754.
</p>

<p><i>[2016-06, Oulu]</i></p>

<p>The ISO version of the standard is ISO/IEC/IEEE 60559:2011,
which C11 Annex F refers to as IEC 60559
(although C still refers to it as IEC 559 in the <code>__STDC_IEC_559__</code> macro).
</p>
  


<p id="res-2248"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2262"><a href="2262">2262</a>. Requirement for <code>unique_ptr&lt;T&gt;::get_deleter()(p)</code> to be able to destroy the <code>unique_ptr</code></h3>
<p><b>Section:</b> 20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rob Desbois <b>Opened:</b> 2013-05-15 <b>Last modified:</b> 2017-03-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unique.ptr.single">active issues</a> in [unique.ptr.single].</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N3337 20.3.1.3.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a> contains 2 non-normative notes stating:
</p>

<blockquote>
<p>
[para 4]: &quot;The order of these operations is significant because the call to <code>get_deleter()</code> 
may destroy <code>*this</code>.&quot;
</p>
<p>
[para 5]: &quot;The postcondition does not hold if the call to <code>get_deleter()</code> destroys <code>*this</code> since 
<code>this->get()</code> is no longer a valid expression.&quot;
</p>
</blockquote>

<p>
It seems this wording was created to resolve <a href="998" title="Smart pointer referencing its owner (Status: C++11)">998</a> due to the possibility that a <code>unique_ptr</code> may be 
destroyed through deletion of its stored pointer where that directly or indirectly refers to the same <code>unique_ptr</code>. 
If <code>unique_ptr</code> is required to support circular references then it seems this must be normative text: an implementation 
is currently allowed to operate on <code>*this</code> after the assignment and deletion specified in para 4, since this is only 
'disallowed' by the non-normative note.
</p>

<p>I propose the following draft rewording:</p>

<p>
[para 4]: <i>Effects</i>: assigns <code>p</code> to the stored pointer, and then if the old value of the stored pointer, <code>old_p</code>, was not
equal to <code>nullptr</code>, calls <code>get_deleter()(old_p)</code>. <ins>No operation shall be performed after the call to 
<code>get_deleter()(old_p)</code> that requires <code>*this</code> to be valid, because the deletion may destroy <code>*this</code> if it is 
referred to directly or indirectly by the stored pointer.</ins> <del>[<i>Note:</i> The order of these operations is significant
because the call to <code>get_deleter()</code> may destroy <code>*this</code>. &mdash; <i>end note</i>]</del>
<p/>
[para 5]: <i>Postconditions</i>: <ins>If the call <code>get_deleter()(old_p)</code> destroyed <code>*this</code>, none. Otherwise,</ins> 
<code>get() == p</code>. <del>[<i>Note:</i> The postcondition does not hold if the call to <code>get_deleter()</code>
destroys <code>*this</code> since <code>this->get()</code> is no longer a valid expression. &mdash; <i>end note</i>]</del>
</p>

<p>
I expect it will also be necessary to amend the requirements for a deleter, so in addition:
</p>

<p>
20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> [para 1]: The default type for the template parameter <code>D</code> is <code>default_delete</code>. 
A client-supplied template argument <code>D</code> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <code>d</code> of type <code>D</code> and a value <code>ptr</code> of type 
<code>unique_ptr&lt;T, D&gt;::pointer</code>, the expression <code>d(ptr)</code> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>Where <code>D</code> is not an lvalue reference type, <code>d(ptr)</code> shall be valid if <code>ptr</code> 
refers directly or indirectly to the invoking <code>unique_ptr</code> object.</ins>
</p>

<p><i>[2013-10-05, Stephan T. Lavavej comments and provides alternative wording]</i></p>

<p>
In Chicago, we determined that the original proposed change to 20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a>/1 was insufficient, because 
<code>d</code> might be a reference to a deleter functor that's destroyed during self-destruction.
<p/>
We believed that 20.3.1.3.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a>/4 was already sufficiently clear. The Standard occasionally prevents 
implementations of <code>X</code> from doing various things, through the principle of "nothing allows <code>X</code> to fail in that situation".  
For example, <code>v.push_back(v[0])</code> is required to work for non-empty vectors because nothing allows that to fail. In this case, 
the intent to allow self-destruction is already clear.
<p/>
Additionally, we did not believe that 20.3.1.3.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a>/5 had to be changed. The current note is slightly 
squirrely but it does not lead to confusion for implementers or users.
</p>

<p>
Previous resolution from Rob Desbois:
</p>
<blockquote class="note">
<ol>
<li>
<p>
Edit 20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <code>D</code> is <code>default_delete</code>. 
A client-supplied template argument <code>D</code> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <code>d</code> of type <code>D</code> and a value <code>ptr</code> of type 
<code>unique_ptr&lt;T, D&gt;::pointer</code>, the expression <code>d(ptr)</code> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>Where <code>D</code> is not an lvalue reference type, <code>d(ptr)</code> shall be valid if <code>ptr</code> 
refers directly or indirectly to the invoking <code>unique_ptr</code> object.</ins>
</p></blockquote>
</li>

<li>
<p>
Edit 20.3.1.3.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.modifiers">[unique.ptr.single.modifiers]</a> p4+5 as indicated:
</p>
<blockquote><pre>
void reset(pointer p = pointer()) noexcept;
</pre><blockquote>
<p>
-3- <i>Requires:</i> The expression <code>get_deleter()(get())</code> shall be well formed, shall have well-defined behavior,
and shall not throw exceptions.
<p/>
-4- <i>Effects:</i> assigns <code>p</code> to the stored pointer, and then if the old value of the stored pointer, <code>old_p</code>, was not
equal to <code>nullptr</code>, calls <code>get_deleter()(old_p)</code>. <ins>No operation shall be performed after the call to 
<code>get_deleter()(old_p)</code> that requires <code>*this</code> to be valid, because the deletion may destroy <code>*this</code> if it is 
referred to directly or indirectly by the stored pointer.</ins> <del>[<i>Note:</i> The order of these operations is significant
because the call to <code>get_deleter()</code> may destroy <code>*this</code>. &mdash; <i>end note</i>]</del>
<p/>
-5- <i>Postconditions:</i> <ins>If the call <code>get_deleter()(old_p)</code> destroyed <code>*this</code>, none. Otherwise,</ins> 
<code>get() == p</code>. <del>[<i>Note:</i> The postcondition does not hold if the call to <code>get_deleter()</code>
destroys <code>*this</code> since <code>this->get()</code> is no longer a valid expression. &mdash; <i>end note</i>]</del>
</p>
</blockquote></blockquote>
</li>
</ol>

</blockquote>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li>
<p>
Edit 20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <code>D</code> is <code>default_delete</code>. 
A client-supplied template argument <code>D</code> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <code>d</code> of type <code>D</code> and a value <code>ptr</code> of type 
<code>unique_ptr&lt;T, D&gt;::pointer</code>, the expression <code>d(ptr)</code> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins><code>d(ptr)</code> shall be valid even if it triggers the destruction of <code>d</code> or (if 
<code>D</code> is an lvalue reference to function object type) the function object that <code>d</code> refers to.</ins>
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-05, Lenexa]</i></p>

<p>
After some discussion in Lenexa there was some wavering on if the added sentence is necessary. Here is example code that 
demonstrates why the extra sentence is necessary. In this example the call to <code>d(ptr)</code> is valid, however the deleter 
references <code>*this</code> after destructing its element:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;

class Deleter
{
    int state_ = 0;

    enum
    {
        destructed            = -4,
        self_move_assigned    = -3,
        move_assigned_from    = -2,
        move_constructed_from = -1
    };
public:
    ~Deleter() {state_ = destructed;}

    Deleter() = default;
    Deleter(Deleter const&amp;) = default;
    Deleter&amp; operator=(Deleter const&amp;) = default;

    Deleter(Deleter&amp;&amp; a) noexcept
        : state_(a.state_)
    {a.state_ = move_constructed_from;}

    Deleter&amp; operator=(Deleter&amp;&amp; a) noexcept
    {
        if (this == &amp;a)
            state_ = self_move_assigned;
        else
        {
            state_ = a.state_;
            a.state_ = move_assigned_from;
        }
        return *this;
    }

    Deleter(int state)
        : state_(state)
    {
        assert(state &gt;= 0);
    }

    template &lt;class T&gt;
    void
    operator()(T* t) const
    {
        std::cout &lt;&lt; "Deleter beginning operator()(T*)\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; *this &lt;&lt; '\n';
        std::cout &lt;&lt; "Deleter about to destruct the X.\n";
        delete t;
        std::cout &lt;&lt; "Deleter has destructed the X.\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; *this &lt;&lt; '\n';
        std::cout &lt;&lt; "Deleter ending operator()(T*)\n";
    }

    friend
    std::ostream&amp;
    operator&lt;&lt;(std::ostream&amp; os, const Deleter&amp; a)
    {
        switch (a.state_)
        {
        case destructed:
            os &lt;&lt; "**destructed**";
            break;
        case self_move_assigned:
            os &lt;&lt; "self_move_assigned";
            break;
        case move_assigned_from:
            os &lt;&lt; "move_assigned_from";
            break;
        case move_constructed_from:
            os &lt;&lt; "move_constructed_from";
            break;
        default:
            os &lt;&lt; a.state_;
            break;
        }
        return os;
    }
};

struct X
{
    Deleter deleter_{1};
};

int main()
{
    auto xp = new X;
    {
        std::unique_ptr&lt;X, Deleter&amp;&gt; p(xp, xp-&gt;deleter_);
        std::cout &lt;&lt; "unique_ptr is constructed.\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; p.get_deleter() &lt;&lt; '\n';
        std::cout &lt;&lt; "Destructing unique_ptr...\n";
    }
    std::cout &lt;&lt; "unique_ptr is destructed.\n";
}
</pre></blockquote>
<p>
Which outputs:
</p>
<blockquote>
<pre>
unique_ptr is constructed.
The deleter = 1
Destructing unique_ptr...
Deleter beginning operator()(T*)
The deleter = 1
Deleter about to destruct the X.
Deleter has destructed the X.
The deleter = **destructed**
Deleter ending operator()(T*)
unique_ptr is destructed.
</pre>
</blockquote>
<p>
The line "<code>The deleter = **destructed**</code>" represents the deleter referencing itself after it has been destructed by the 
<code>d(ptr)</code> expression, but prior to that call returning.
<p/>
Suggested alternative to the current proposed wording:
</p>
<blockquote>
<p>
The expression <code>d(ptr)</code> shall not refer to the object <code>d</code> after it executes <code>ptr-&gt;~T()</code>.
</p>
</blockquote>

<p><i>[2015-07, Telecon]</i></p>

<p>
Geoffrey: Deleter may or may not execute ~T().<br/>
Alisdair: After the destructor after the element has run. Say it in words instead of code. <br/>
Howard will provide updated wording. Perhaps need both normative and non-normative wording.<br/>
</p>

<p><i>[2015-08-03, Howard updates P/R per telecon discussion.]</i></p>


<p><i>[2017-03-04, Kona]</i></p>

<p>This is related to <a href="2751" title="shared_ptr deleter not specified to observe expired weak_ptr instances (Status: New)">2751</a>, which has been suggested NAD.</p>
<p>STL wants "Effects equivalent to" here - say it in code.  Marshall to research.</p>


<p id="res-2262"><b>Proposed resolution:</b></p>
<p>This wording is relative to N4431.</p>

<ol>
<li>
<p>
Edit 20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <code>D</code> is <code>default_delete</code>. 
A client-supplied template argument <code>D</code> shall be a function object type (20.9), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <code>d</code> of type <code>D</code> and a value <code>ptr</code> of type 
<code>unique_ptr&lt;T, D&gt;::pointer</code>, the expression <code>d(ptr)</code> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>The expression <code>d(ptr)</code>, if it destructs the object referred to by <code>ptr</code>,
shall not refer to the object <code>d</code> after it destructs <code>*ptr</code>.
[<i>Note:</i> The object being destructed may control the lifetime of <code>d</code>. &mdash; <i>end note</i>]</ins>
</p></blockquote>
</li>
</ol>






<hr>
<h3 id="2265"><a href="2265">2265</a>. 29.3p9 appears to rule out some acceptable executions</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Brian Demsky <b>Opened:</b> 2013-06-17 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe that the following variation on IRIW should admit executions in
which <code>c1 = d1 = 5</code> and <code>c2 = d2 = 0</code>.  If this is allowed, then what is sequence of
program evaluations for 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 that justifies the store to <code>z</code>?  It seems that
32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 should not allow this execution because one of the stores to <code>x</code> or <code>y</code> has
to appear earlier in the sequence, each of the <code>fetch_adds</code> reads the previous load in the thread (and thus must 
appear later in the sequence), and 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 states that each load must read from the last prior 
assignment in the sequence.
</p>

<blockquote><pre>
atomic_int x;
atomic_int y;
atomic_int z;
int c1, c2, d1, d2;

static void a(void* obj)
{
  atomic_store_explicit(&amp;x, 5, memory_order_relaxed); 
}

static void b(void* obj)
{
  atomic_store_explicit(&amp;y, 5, memory_order_relaxed); 
}

static void c(void* obj)
{
  c1 = atomic_load_explicit(&amp;x, memory_order_relaxed);
  // this could also be an atomic load if the address depends on c1:
  c2 = atomic_fetch_add_explicit(&amp;y, c1, memory_order_relaxed);  
}

static void d(void* obj)
{
  d1 = atomic_load_explicit(&amp;y, memory_order_relaxed);
  d2 = atomic_fetch_add_explicit(&amp;x, d1, memory_order_relaxed); 
}

int user_main(int argc, char** argv)
{
  thrd_t t1, t2, t3, t4;

  atomic_init(&amp;x, 0);
  atomic_init(&amp;y, 0);

  printf("Main thread: creating 4 threads\n");
  thrd_create(&amp;t1, (thrd_start_t)&amp;a, NULL);
  thrd_create(&amp;t2, (thrd_start_t)&amp;b, NULL);
  thrd_create(&amp;t3, (thrd_start_t)&amp;c, NULL);
  thrd_create(&amp;t4, (thrd_start_t)&amp;d, NULL);

  thrd_join(t1);
  thrd_join(t2);
  thrd_join(t3);
  thrd_join(t4);
  printf("c1=%d c2=%d\n",c1,c2);
  printf("d1=%d d2=%d\n",d1,d2);

  // Can this store write 1000 (i.e., c1=d1=5, c2=d2=0)?
  atomic_store(&amp;z, (c1+d1)*100+c2+d2);

  printf("Main thread is finished\n");

  return 0;
}
</pre></blockquote>

<p>
It seems that the easiest fix is to allow a load in 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p9 to read from any prior
store in the evaluation order.
<p/>
That said, I would personally advocate the following:
It seems to me that C/C++ atomics are in a bit of different situation than Java
because:
</p>
<ol>
<li><p>People are expected to use relaxed C++ atomics in potentially racy
situations, so it isn't clear that semantics as complicated as the JMM's
causality would be sane.
</p></li>
<li><p>People who use C/C++ atomics are likely to be experts and use them in a
very controlled fashion. I would be really surprised if compilers would find
any real wins by optimizing the use of atomics.
</p></li>
</ol>
<p>
Why not do something like:
<p/>
There is satisfaction DAG of all program evaluations. Each evaluation
observes the values of variables as computed by some prior assignment in
the DAG.
<p/>
There is an edge <code>x-&gt;y</code> between two evaluations <code>x</code> and <code>y</code> if:
</p>
<ol>
<li><p>the evaluation <code>y</code> observes a value computed by the evaluation <code>x</code> or
</p></li>
<li><p>the evaluation <code>y</code> is an atomic store, the evaluation <code>x</code> is an atomic load, and
there is a condition branch c that may depend (intrathread dependence) on <code>x</code>
and <code>x-sb-&gt;c</code> and <code>c-sb-&gt;y</code>.
</p></li>
</ol>
<p>
This seems to allow reordering of relaxed atomics that processors do without
extra fence instructions, allows most reorderings by the compiler, and gets
rid of satisfaction cycles.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>


<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
This was partially addressed (weasel-worded) in C++14 (See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3786.htm">N3786</a>).
The remainder is an open research problem.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3710.html">N3710</a> outlines a "solution" that doesn't have a consensus behind it because it costs performance.  We have no better solution at the moment.
</p>


<p id="res-2265"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2267"><a href="2267">2267</a>. <code>partial_sort_copy</code> underspecified for ranges of two different types</h3>
<p><b>Section:</b> 26.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/partial.sort.copy">[partial.sort.copy]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern  <b>Opened:</b> 2013-06-26 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signature of this function is:
</p>

<blockquote><pre>
template&lt;class InputIterator, class RandomAccessIterator&gt;
RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
                  RandomAccessIterator result_first,
                  RandomAccessIterator result_last);

</pre></blockquote>

<p>
(and the usual overload for an explicitly provided comparison function). The standard says nothing about requirements 
in the case where the input type (<code>iterator_traits&lt;InputIterator&gt;::value_type</code>) and the output type 
(<code>iterator_traits&lt;RandomAccessIterator&gt;::value_type</code>) are different.
<p/>
Presumably the input type must be convertible to the output type. What's less clear is what the requirements are on 
the comparison operator. Does the algorithm only perform comparisons on two values of the output type, or does it also 
perform comparisons on values of the input type, or might it even perform heterogeneous comparisons?
</p>



<p id="res-2267"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2269"><a href="2269">2269</a>. Container iterators and argument-dependent lookup</h3>
<p><b>Section:</b> 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2013-06-26 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following code snippet:
</p>

<blockquote><pre>
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
  std::vector&lt;int&gt; v1(100, 3);
  std::vector&lt;int&gt; v2(100);
  copy(v1.begin(), v1.end(), v2.begin());
}
</pre></blockquote>

<p>
It compiles without error on my desktop. Is it required to? I can't find evidence from the standard that it is. 
In my test <code>std::copy</code> was found by argument-dependent lookup because the implementation I used made 
<code>std::vector&lt;int&gt;::iterator</code> a user-defined type defined in namespace <code>std</code>. But the standard 
only requires <code>std::vector&lt;int&gt;::iterator</code> to be an implementation specified random access iterator 
type. I can't find anything requiring it to be a user-defined type at all (and in fact there are reasonable implementation 
where it isn't), let alone a user defined type defined in a specific namespace.
</p>

<p>
Since the defining namespace of container iterators is visible to users, should the standard say anything about what 
that namespace is?
</p>



<p id="res-2269"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2286"><a href="2286">2286</a>. <code>stringbuf::underflow()</code> underspecified</h3>
<p><b>Section:</b> 31.8.2.5 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.virtuals">[stringbuf.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sergey Zubkov <b>Opened:</b> 2013-08-29 <b>Last modified:</b> 2018-06-12</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#stringbuf.virtuals">active issues</a> in [stringbuf.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 31.8.2.5 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.virtuals">[stringbuf.virtuals]</a>/1, <code>basic_stringbuf::underflow()</code> is specified to unconditionally 
return <code>traits::eof()</code> when a read position is not available.
<p/>
The semantics of <code>basic_stringbuf</code> require, and existing libraries implement it so that this function makes 
a read position available if possible to do so, e.g. if some characters were inserted into the stream since the 
last call to <code>overflow()</code>, resulting in <code>pptr() &gt; egptr()</code>. Compare to the conceptually similar 
99 [depr.strstreambuf.virtuals]/15.
</p>

<p><i>[2018-06-06, Billy argues for NAD]</i></p>

<p>
The existing "Any character in the underlying buffer which has been initialized is considered to be part of the input sequence." 
sentence already describes what the <code>stringbuf</code> is supposed to do to the get area. The specific mechanism that the 
<code>stringbuf</code> uses to alter the get area is unspecified because the mechanism by which the <code>stringbuf</code> 
remembers the "high water mark" is unspecified.
<p/>
Consider the following:
</p>
<blockquote><pre>
stringstream s;
s &lt;&lt; "Hello";
s.seekp(0);
string x;
s &gt;&gt; x;
</pre></blockquote>
<p>
Before this P/R, this will store <code>Hello</code> in <code>x</code>, because the characters <code>Hello</code> are initialized. 
After this P/R, the "written put area" is empty, so it will store the empty string in <code>x</code>.
<p/>
Saying that the initialized part of the string is used already describes what needs to happen here.
</p>

<p><i>[2018-06 Rapperswil Wednesday issues processing]</i></p>

<p>Billy to provide rationale for closing as NAD.</p>



<p id="res-2286"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>

<li><p>Change 31.8.2.5 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.virtuals">[stringbuf.virtuals]</a> as indicated:</p>

<blockquote>
<pre>
int_type underflow();
</pre><blockquote>
<p>
-1- <i>Returns:</i> If the input sequence has a read position available <ins>or the function makes a read position available 
(as described below)</ins>, returns <code>traits::to_int_type(*gptr())</code>. Otherwise, returns <code>traits::eof()</code>. Any 
character in the underlying buffer which has been initialized is considered to be part of the input sequence.
<p/>
<ins>-?- The function can make a read position available only if <code>(mode &amp; ios_base::in) != 0</code> and if the write 
next pointer <code>pptr()</code> is not null and is greater than the current read end pointer <code>egptr()</code>. To make a read 
position available, the function alters the read end pointer <code>egptr()</code> to equal <code>pptr()</code>.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3 id="2289"><a href="2289">2289</a>. <code>constexpr</code> guarantees of defaulted functions still insufficient</h3>
<p><b>Section:</b> 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a>, 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>, 30.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-09 <b>Last modified:</b> 2020-06-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">N3471</a> and
some similar <code>constexpr</code> papers, specific wording was added to <code>pair</code>, <code>tuple</code>, and other templates
that were intended to impose implementation constraints that ensure that the observable <code>constexpr</code> "character"
of a defaulted function template is solely determined by the required expressions of the user-provided types when instantiated,
for example:
</p>

<blockquote><p>
The defaulted move and copy constructor, respectively, of pair shall be a <code>constexpr</code> function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <code>constexpr</code> function.
</p></blockquote>

<p>
This wording doesn't require enough, especially since the core language via CWG 1358 does now support <code>constexpr</code>
function template instantiations, even if such function cannot appear in a constant expression (as specified in 7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) 
or as a constant initializer of that object (as specified in  [basic.start.init]). The wording should be 
improved and should require valid uses in constant expressions and as constant initializers instead.
</p>

<p><i>[Lenexa 2015-05-05]</i></p>

<p>STL : notice order of move/copy and copy/move with "respectively".</p>
<p>General word-smithing; ask for updated wording</p>
<p>Are we happy with this with changes we are suggesting?</p>
<p>unanimous</p>

<p><i>[2016-12-14, Daniel comments]</i></p>

<p>
LWG <a href="2833" title="Library needs to specify what it means when it declares a function constexpr (Status: Open)">2833</a> overlaps considerably and both should be resolved together.
</p>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- <del>The defaulted move and copy constructor, respectively, of pair shall be a <code>constexpr</code> function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <code>constexpr</code> function</del><ins>An invocation of the move or copy constructor of <code>pair</code> shall be a constant expression 
(7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) if all required element-wise initializations would be constant expressions. An invocation of the 
move or copy constructor of <code>pair</code> shall be a constant initializer for that <code>pair</code> object ( [basic.start.init])
if all required element-wise initializations would be constant initializers for the respective subobjects</ins>.
</p>
</blockquote>
</li>

<li><p>Change 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- <del>The defaulted move and copy constructor, respectively, of <code>tuple</code> shall be a <code>constexpr</code> function if 
and only if all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <code>constexpr</code> function. The defaulted move and copy constructor of <code>tuple&lt;&gt;</code> shall be <code>constexpr</code> 
functions</del><ins>An invocation of the move or copy constructor of <code>tuple</code> shall be a constant expression (7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>)
if all required element-wise initializations would be constant expressions. An invocation of the move or copy constructor of 
<code>tuple</code> shall be a constant initializer for that <code>tuple</code> object ( [basic.start.init]) if all 
required element-wise initializations would be constant initializers for the respective subobjects. An invocation of the 
move or copy constructor of <code>tuple&lt;&gt;</code> shall be a constant expression, or a constant initializer for that 
<code>tuple&lt;&gt;</code> object, respectively, if the function argument would be constant expression</ins>.
</p>
</blockquote>
</li>

<li><p>Change 30.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a> p7 as indicated:</p>

<blockquote>
<p>
-7- <i>Remarks:</i> <del>The defaulted copy constructor of duration shall be a <code>constexpr</code> function if and only if
the required initialization of the member <code>rep_</code> for copy and move, respectively, would satisfy the
requirements for a <code>constexpr</code> function.</del><ins>An invocation of the copy constructor of <code>duration</code> shall 
be a constant expression (7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) if the required initialization of the member <code>rep_</code> would be a constant expression.
An invocation of the copy constructor of <code>duration</code> shall be a constant initializer for that <code>duration</code> object 
( [basic.start.init]) if the required initialization of the member <code>rep_</code> would be constant initializers 
for this subobject</ins>.
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2020-06-08 Nina Dinka Ranns comments]</i></p>

<p>
The revised wording provided by LWG <a href="2833" title="Library needs to specify what it means when it declares a function constexpr (Status: Open)">2833</a> should resolve this issue as well.
</p>


<p id="res-2289"><b>Proposed resolution:</b></p>






<hr>
<h3 id="2290"><a href="2290">2290</a>. Top-level "SFINAE"-based constraints should get a separate definition in Clause 17</h3>
<p><b>Section:</b> 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-02 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current library specification uses at several places wording that is intended to refer to
core language template deduction failure at the top-level of expressions (aka "SFINAE"), for example:
</p>

<blockquote><p>
The expression <code>declval&lt;T&gt;() = declval&lt;U&gt;()</code> is well-formed when treated as an unevaluated operand (Clause 5). 
Access checking is performed as if in a context unrelated to <code>T</code> and <code>U</code>. Only the validity of the immediate context 
of the assignment expression is considered. [<i>Note:</i> The compilation of the expression can result in side effects 
such as the instantiation of class template specializations and function template specializations, the generation of
implicitly-defined functions, and so on. Such side effects are not in the "immediate context" and can result in the program
being ill-formed. &mdash; <i>end note</i>]
</p></blockquote>

<p>
Similar wording can be found in the specification of <code>result_of</code>, <code>is_constructible</code>, and <code>is_convertible</code>,
being added to resolve an NB comment by LWG <a href="1390" title="Limit speculative compilation for constructible&#47;convertible traits (Status: Resolved)">1390</a> and <a href="1391" title="constructible&#47;convertible traits and access control (Status: Resolved)">1391</a> through 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">N3142</a>.
<p/>
This wording is necessary to limit speculative compilations needed to implement these traits, but it is also lengthy and repetitive.
</p>

<p><i>[2014-05-19, Daniel suggests a descriptive term]</i></p>

<p>
<b>constrictedly well-formed expression</b>:
<p/>
An expression <em>e</em> depending on a set of types <code>A1</code>, ..., <code>An</code> which is well-formed when treated as 
an unevaluated operand (Clause 5). Access checking is performed as if in a context unrelated to <code>A1</code>, ..., 
<code>An</code>. Only the validity of the immediate context of <em>e</em> is considered. [<i>Note:</i> The compilation of 
the expression can result in side effects such as the instantiation of class template specializations and function 
template specializations, the generation of implicitly-defined functions, and so on. Such side effects are not in the 
"immediate context" and can result in the program being ill-formed. &mdash; <i>end note</i>]
</p>

<p><i>[2014-05-20, Richard and Jonathan suggest better terms]</i></p>

<p>
Richard suggested "locally well-formed"
<p/>
Jonathan suggested "contextually well-formed" and then "The expression ... is valid in a contrived argument
deduction context"
</p>

<p><i>[2014-06-07, Daniel comments and improves wording]</i></p>

<p>
The 2014-05-19 suggestion did only apply to expressions, but there are two important examples that are not expressions, but instead
are involving an <em>object definition</em> (<code>std::is_constructible</code>) and a <em>function definition</em> 
(<code>std::is_convertible</code>), respectively, instead. Therefore I suggest to rephrase the usage of "expression" into "program 
construct" in the definition of Jonathan's suggestion of "valid in a contrived argument deduction context".
<p/>
I would like to point out that given the new definition of "valid in a contrived argument deduction context", there are several other 
places of the Library specification that could take advantage of this wording to improve the existing specification, such as 
22.10.17.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func">[func.wrap.func]</a> p2, most functions in 20.2.9.3 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.members">[allocator.traits.members]</a>, and the <code>**Insertable</code>, 
<code>EmplaceConstructible</code>, and <code>Erasable</code> definitions in 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, but given that
these are not fully described in terms of the aforementioned wording <em>yet</em>, I would recommend to fix them by a separate issue 
once the committee has agreed on following the suggestion presented by this issue.
</p>

<p><i>[2015-05-05 Lenexa: Move to Open]</i></p>

<p>...</p>
<p>MC: I think we like the direction but it isn't quite right: it needs some work</p>
<p>JW: I'm prepared to volunteer to move that further, hopefully with the help of Daniel</p>
<p>Roger Orr: should this be Core wording because it doesn't really have anything to do with libraries - the term could then just be used here</p>
<p>AM: Core has nothing to deal with that, though</p>
<p>HT: it seems there is nothing to imply that allows dropping out with an error - maybe that's a separate issue</p>
<p>MC: I'm not getting what you are getting at: could you write an issue? - any objection to move to Open?</p>
<p>...</p>


<p id="res-2290"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Add the following new definition to  [definitions] as indicated:</p>

<p>
<ins><b>valid in a contrived argument deduction context</b> [defns.valid.contr.context]</ins>
<p/>
<ins>A program construct <em>c</em> depending on a set of types <code>A1</code>, ..., <code>An</code>, and treated as 
an unevaluated operand (Clause 5) when <em>c</em> is an expression, which is well-formed. 
Access checking is performed as if in a context unrelated to <code>A1</code>, ..., <code>An</code>. 
Only the validity of the immediate context (13.10.3 <a href="https://timsong-cpp.github.io/cppwp/temp.deduct">[temp.deduct]</a>) of <em>c</em> is considered. 
[<i>Note:</i> The compilation of <em>c</em> can result in side effects such as the instantiation of class template 
specializations and function template specializations, the generation of implicitly-defined functions, and so on. 
Such side effects are not in the "immediate context" and can result in the program being ill-formed. &mdash; 
<i>end note</i>].</ins>
</p>
</li>

<li><p>Change Table 49 ("Type property predicates") as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 49 &mdash; Type property predicates</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>template &lt;class T, class U&gt;<br/>
struct is_assignable;</code>
</td>

<td>
The expression
<code>declval&lt;T&gt;() =<br/>
declval&lt;U&gt;()</code> is <ins>valid in a<br/>
contrived argument deduction context<br/>
([defns.valid.contr.context]) for types<br/>
<code>T</code> and <code>U</code>.</ins>
<del>well-formed when treated<br/>
as an unevaluated operand<br/>
(Clause 5). Access<br/>
checking is performed as if<br/>
in a context unrelated to <code>T</code><br/>
and <code>U</code>. Only the validity of<br/>
the immediate context of<br/>
the assignment expression<br/>
is considered. [<i>Note</i>: The<br/>
compilation of the<br/>
expression can result in<br/>
side effects such as the<br/>
instantiation of class<br/>
template specializations<br/>
and function template<br/>
specializations, the<br/>
generation of<br/>
implicitly-defined<br/>
functions, and so on. Such<br/>
side effects are not in the<br/>
"immediate context" and<br/>
can result in the program<br/>
being ill-formed. &mdash; end<br/>
note]</del>
</td>

<td align="center">
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> p7 as indicated:</p>

<blockquote><p>
-7- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre></blockquote>
<p>
the predicate condition for a template specialization <code>is_constructible&lt;T, Args...&gt;</code> shall be satisfied
if and only if the following variable definition <del>would be well-formed</del> for some invented 
variable <code>t</code> <ins>would be valid in a contrived argument deduction context ([defns.valid.contr.context]) for 
types <code>T</code> and <code>Args...</code></ins>:
</p>
<blockquote><pre>
T t(create&lt;Args&gt;()...);
</pre></blockquote>
<p>
[<i>Note</i>: These tokens are never interpreted as a function declaration. &mdash; <i>end note</i>] <del>Access checking is
performed as if in a context unrelated to <code>T</code> and any of the <code>Args</code>. Only the validity of the immediate context
of the variable initialization is considered. [<i>Note</i>: The evaluation of the initialization can result in side
effects such as the instantiation of class template specializations and function template specializations, the
generation of implicitly-defined functions, and so on. Such side effects are not in the "immediate context"
and can result in the program being ill-formed. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

<li><p>Change Table 57 ("Other transformations") as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 57 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="3" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>template &lt;class Fn, class... ArgTypes&gt;<br/>
struct result_of&lt;Fn(ArgTypes...)&gt;;</code>
</td>

<td align="center">
[&hellip;]
</td>

<td>
If the expression<br/>
<code><i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...)</code> is<br/>
<ins>valid in a contrived argument deduction<br/>
context ([defns.valid.contr.context]) for types<br/>
<code>Fn</code> and <code>ArgTypes...</code></ins>
<del>well<br/>
formed when treated as an<br/>
unevaluated operand (Clause 5)</del>, the<br/>
member typedef type shall name the<br/>
type<br/>
<code>decltype(<i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...))</code>;<br/>
otherwise, there shall be no member<br/>
type. <del>Access checking is performed as<br/>
if in a context unrelated to <code>Fn</code> and<br/>
<code>ArgTypes</code>. Only the validity of the<br/>
immediate context of the expression is<br/>
considered. [<i>Note</i>: The compilation of<br/>
the expression can result in side<br/>
effects such as the instantiation of<br/>
class template specializations and<br/>
function template specializations, the<br/>
generation of implicitly-defined<br/>
functions, and so on. Such side effects<br/>
are not in the "immediate context"<br/>
and can result in the program being<br/>
ill-formed. &mdash; <i>end note</i>]</del>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> p4 as indicated:</p>

<blockquote><p>
-4- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre></blockquote>
<p>
the predicate condition for a template specialization <code>is_convertible&lt;From, To&gt;</code> shall be satisfied if and
only if the return expression in the following code would be <del>well-formed</del><ins>valid in a contrived argument 
deduction context ([defns.valid.contr.context]) for types <code>To</code> and <code>From</code></ins>, including any implicit conversions
to the return type of the function:
</p>
<blockquote><pre>
To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>
<p>
[<i>Note</i>: This requirement gives well defined results for reference types, <code>void</code> types, array types, and
function types. &mdash; <i>end note</i>] <del>Access checking is performed as if in a context unrelated to <code>To</code> 
and <code>From</code>. Only the validity of the immediate context of the expression of the return-statement (including conversions to
the return type) is considered. [<i>Note</i>: The evaluation of the conversion can result in side effects such as
the instantiation of class template specializations and function template specializations, the generation of
implicitly-defined functions, and so on. Such side effects are not in the "immediate context" and can result
in the program being ill-formed. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="2303"><a href="2303">2303</a>. Explicit instantiation of <code>std::vector&lt;UserType&gt;</code> broken?</h3>
<p><b>Section:</b> 17.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/new.delete.placement">[new.delete.placement]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-18 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library gives explicit permission in 16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> p2 that user code may explicitly instantiate
a library template provided that the instantiations depend on at least one user-defined type:
</p>

<blockquote><p>
A program may explicitly instantiate a template defined in the standard library only if the declaration
depends on the name of a user-defined type and the instantiation meets the standard library requirements
for the original template.
</p></blockquote>

<p>
But it seems that the C++11 library is not specified in a way that guarantees such an instantiation to be well-formed
if the minimum requirements of the library is not satisfied. 
<p/>
For example, in general, the first template parameter of <code>std::vector</code> is not required to be 
<code>DefaultConstructible</code> in general, but due to the split of the single C++03 member function
with default argument
</p>
<blockquote><pre>
void resize(size_type sz, T c = T());
</pre></blockquote>
<p>
into
</p>
<blockquote><pre>
void resize(size_type sz);
void resize(size_type sz, const T&amp; c);
</pre></blockquote>
<p>
the effect is now that for a type <code>ND</code> that is not <code>DefaultConstructible</code>, such as
</p>
<blockquote><pre>
struct NP { 
  NP(int); 
};
</pre></blockquote>
<p>
the explicit instantiation of <code>std::vector&lt;ND&gt;</code> is no longer well-formed, because the attempt to
instantiate the single-argument overload of <code>resize</code> cannot not succeed, because this function imposes
the <code>DefaultInsertable</code> requirements and given the default allocator this effectively requires
<code>DefaultConstructible</code>.
</p>
<p>
But <code>DefaultConstructible</code> is not the only point, what about <code>CopyConstructible</code> versus
<code>MoveConstructible</code> alone? It turns out that currently the second <code>resize</code> overload
would fail during an explicit instantiation for a type like
</p>
<blockquote><pre>
struct MO { 
  MO() = default; 
  MO(MO&amp;&amp;) = default; 
};
</pre></blockquote>
<p>
because it imposes <code>CopyInsertable</code> requirements that end up being equivalent to the <code>CopyConstructible</code>
requirements for the default allocator.
<p/>
Technically a library can solve these issues: For special member functions by defining them in some base class, for others
by transforming them effectively into a function template due to the great feature of default template arguments for
function templates (At the very moment the validity of the latter approach depends on a resolution of core language issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1635">CWG 1635</a>, though). E.g. the here mentioned 
<code>resize</code> functions of <code>std::vector</code> could be prevented from instantiation by defining them like this 
with an implementation:
</p>
<blockquote><pre>
template&lt;class = void&gt;
void resize(size_type sz) { [&hellip;] }
template&lt;class = void&gt;
void resize(size_type sz, const T&amp; c) { [&hellip;] }
</pre></blockquote>
<p>
In this case, these functions could also be defined in a base class, but the latter approach won't work in all cases.
<p/>
Basically such an implementation is required to constrain all member functions that are not covered by the general
requirements imposed on the actual library template parameters. I tested three different C++11 library implementations
and but none could instantiate for example <code>std::list</code>, <code>std::vector</code>, or <code>std::deque</code> with
value types that are not <code>DefaultConstructible</code> or only <code>MoveConstructible</code>. 
<p/>

<p/>
This issue is raised to clarify the current situation in regard to the actual requirements imposed on user-provided
types that are used to explicitly instantiate Library-provided templates. For example, the current Container requirements
impose very little requirements on the actual value type and it is unclear to which extend library implementations have
to respect that. 
<p/>
The minimum solution of this issue should be to at least realize that there is no fundamental requirement on 
<code>DefaultConstructible</code> for value types of library containers, because we have since C++03 the general
statement of 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> ("In general, a default constructor is not required.").
It is unclear whether <code>CopyConstructible</code> should be required for an explicit instantiation request, but
given the careful introduction of move operations in the library it would seem astonishing that a
<code>MoveConstructible</code> type wouldn't suffice for value types of the container types.
<p/>
In any case I can envision at least two approaches to solve this issue:
</p>
<ol>
<li>
<p>
As indicated in LWG <a href="2292" title="Find a better phrasing for &quot;shall not participate in overload resolution&quot; (Status: Resolved)">2292</a>, those function could get an explicit "<i>Template Constraints:</i>"
element, albeit this promises more than needed to solve this issue.
</p>
</li>
<li>
<p>
The library could introduce a completely new element form, such as "<i>Instantiation Constraints:</i>" that
would handle this situation for explicit instantiation situations. This would allow for simpler techniques
to solve the issue when explicit instantiation is required compared to the first bullet, because it would not 
(necessarily) guarantee SFINAE-friendly expression-wellformedness, such as inspecting the expression 
<code>std::declval&lt;std::vector&lt;ND&gt;&amp;&gt;.resize(0)</code> in an unevaluated context.
</p>
</li>
</ol>

<p>
It should be noted that the 2013-08-27 comment to LWG <a href="2193" title="Default constructors for standard library containers are explicit (Status: C++14)">2193</a> could be resolved by a similar solution
as indicated in this issue here.
</p>


<p id="res-2303"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2307"><a href="2307">2307</a>. Should the Standard Library use <code>explicit</code> only when necessary?</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-09-26 <b>Last modified:</b> 2018-11-12</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2193" title="Default constructors for standard library containers are explicit (Status: C++14)">2193</a> yields <code>explicit</code> for default ctors to allow <code>{}</code>, but not for
all cases of uniform initialization. For example:
</p>
<blockquote><pre>
explicit vector(size_type count, const Allocator&amp; alloc = Allocator());
</pre></blockquote>
<p>
This prevents <code>{n, alloc()}</code>. Although this use is relatively rare,
but the behavior is inconsistent with that of
</p>
<blockquote><pre>
vector(size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator());
</pre></blockquote>

<p><i>[Urbana 2014-11-07: Move to Open]</i></p>


<p><i>[2018-08 Batavia Monday issue discussion]</i></p>

<p>This really needs a paper; splitting a lot of constructors. Nevin to write paper.</p>

<p><i>[2018-11 San Diego Thursday night issue processing]</i></p>

<p>LEWG has rejected Nevin's paper, so they need to formulate a policy.</p>


<p id="res-2307"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2321"><a href="2321">2321</a>. Moving containers should (usually) be required to preserve iterators</h3>
<p><b>Section:</b> 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2023-01-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/10 says that unless otherwise specified, "no <code>swap()</code> function invalidates 
any references, pointers, or iterators referring to the elements of the containers being swapped. [<i>Note:</i> The <code>end()</code> 
iterator does not refer to any element, so it may be invalidated. &mdash; <i>end note</i>]". However, move constructors and move 
assignment operators aren't given similar invalidation guarantees. The guarantees need several exceptions, so I do not believe 
that blanket language like /11 "Unless otherwise specified (either explicitly or by defining a function in terms of other functions), 
invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, 
or change the values of, objects within that container." is applicable.
</p>

<p><i>[2014-02-13 Issaquah]</i></p>

<p>
General agreeement on intent, several wording nits and additional paragraphs to hit.
</p>
<p>
STL to provide updated wording.  Move to Open.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: in the proposed wording, I'd like to mention that the iterators now refer to elements of a different container. 
I think we're saying something like this somewhere. JY: There's some wording like that for swap I think. TK: It's also in 
<code>list::splice()</code>. DK to JY: 23.2.1p9.
<p/>
VV: The issue says that STL was going to propose new wording. Has he done that? AM: I believe we're looking at that. 
GR: The request touches on multiple paragraphs, and this PR has only one new paragraph, so this looks like it's not up-to-date. 
MC: This was last updated a year ago in Issaquah.
<p/>
<b>Conclusion</b>: Skip, not up to date. 
</p>

<p><i>[2015-06, Telecon]</i></p>

<p>Still waiting for updated wording</p>

<p><i>[2015-08 Chicago]</i></p>

<p>Still waiting for updated wording</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Priority to 3</p>

<p><i>[2023-01-20; std-proposals post]</i></p>

<p>
Emile Cormier
<a href="https://lists.isocpp.org/std-proposals/2023/01/5439.php">observed</a>
that the proposed resolution of this issue contradicts with changes made by
LWG <a href="2839" title="Self-move-assignment of library types, again (Status: C++23)">2839</a>. Specifially, the current draft does not require
container elements to be preserved on self-move-assignment.
If this issue is accepted, it would either need to allow
iterator invalidation on self-move-assignment or remove the
"If <code>a</code> and <code>rv</code> do not refer to the same object"
changes added to the container requirements by LWG <a href="2839" title="Self-move-assignment of library types, again (Status: C++23)">2839</a>.
</p>



<p id="res-2321"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/10 change as indicated:</p>

<blockquote><p>
-10- Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.3.4, and 23.3.7.5) all container types defined in this
Clause meet the following additional requirements:
</p>
<ul>
<li><p>
[&hellip;]
</p></li>
<li><p>
no copy constructor or assignment operator of a returned iterator throws an exception.
</p></li>
<li><p>
<ins>no move constructor (or move assignment operator when 
<code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code> is true) of a container 
(except for <code>array</code>) invalidates any references, pointers, or iterators referring to the elements of the source container. 
[<i>Note:</i> The <code>end()</code> iterator does not refer to any element, so it may be invalidated. &mdash; <i>end note</i>]</ins>
</p></li>
<li><p>
no <code>swap()</code> function throws an exception.
</p></li>
<li><p>
no <code>swap()</code> function invalidates any references, pointers, or iterators referring to the elements of the
containers being swapped. [<i>Note:</i> The <code>end()</code> iterator does not refer to any element, so it may be
invalidated. &mdash; <i>end note</i>]
</p></li>
</ul>
</blockquote>
</li>

</ol>






<hr>
<h3 id="2331"><a href="2331">2331</a>. <code>regex_constants::collate</code>'s effects are inaccurately summarized</h3>
<p><b>Section:</b> 28.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.synopt">issues</a> in [re.synopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The table in 28.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a>/1 says that <code>regex_constants::collate</code> "Specifies that character ranges of the form 
"<code>[a-b]</code>" shall be locale sensitive.", but 28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a>/14 says that it affects individual character comparisons 
too.
</p>

<p><i>[2012-02-12 Issaquah : recategorize as P3]</i></p>


<p>
Marshall Clow: 28.13/14 only applies to ECMAScript
</p>

<p>
All: we're unsure
</p>

<p>
Jonathan Wakely: we should ask John Maddock
</p>

<p>
Move to P3
</p>

<p><i>[2014-5-14, John Maddock response]</i></p>

<p>
The original intention was the original wording: namely that <code>collate</code> only made character ranges locale sensitive.  
To be frank it's a feature that's probably hardly ever used (though I have no real hard data on that), and is a leftover 
from early POSIX standards which <em>required</em> locale sensitive collation for character ranges, and then later changed 
to implementation defined if I remember correctly (basically nobody implemented locale-dependent collation).
<p/>
So I guess the question is do we gain anything by requiring all character-comparisons to go through the locale when this bit 
is set? Certainly it adds a great deal to the implementation effort (it's not what Boost.Regex has ever done). I guess the 
question is are differing code-points that collate identically an important use case? I guess there might be a few Unicode 
code points that do that, but I don't know how to go about verifying that.
<p/>
STL:
<p/>
If this was unintentional, then 28.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a>/1's table should be left alone, while 28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a>/14 
should be changed instead.
<p/>
Jeffrey Yasskin:
<p/>
<a href="http://www.unicode.org/reports/tr18/tr18-13.html#Tailored_Loose_Matches">This page</a>
mentions that [V] in Swedish should match "W" in a perfect world.
<p/>
However, the most recent version of <a href="http://www.unicode.org/reports/tr18/#Tailored_Loose_Matches">TR18</a> retracts
both language-specific loose matches <em>and</em> language-specific ranges
because "for most full-featured regular expression engines, it is
quite difficult to match under code point equivalences that are not
1:1" and "tailored ranges can be quite difficult to implement
properly, and can have very unexpected results in practice. For
example, languages may also vary whether they consider lowercase below
uppercase or the reverse. This can have some surprising results: [a-Z]
may not match anything if <code>Z &lt; a</code> in that locale."
<p/>
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.15">ECMAScript</a> doesn't include collation at all.
<p/>
IMO, +1 to changing 28.13 instead of 28.5.1. It seems like we'd be on
fairly solid ground if we wanted to remove <code>regex_constants::collate</code>
entirely, in favor of named character classes, but of course that's
not for this issue.
</p>



<p id="res-2331"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 28.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a>/1, Table 138 &mdash; "<code>syntax_option_type</code> effects", change as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 138 &mdash; <code>syntax_option_type</code> effects</caption>
<tr>
<th align="center">Element</th>
<th align="center">Effect(s) if set</th>
</tr>

<tr>
<td colspan="2" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>collate</code>
</td>
<td>
Specifies that character <del>ranges of the form "<code>[a-b]</code>"</del><ins>comparisons and character range comparisons</ins> 
shall be locale sensitive.
</td>
</tr>

<tr>
<td colspan="2" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2338"><a href="2338">2338</a>. &sect;[re.traits]/7 expects of locale facets something not guaranteed by [locale.facet]/4</h3>
<p><b>Section:</b> 28.6.6 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>, 28.3.3.1.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.facet">[locale.facet]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sergey Zubkov <b>Opened:</b> 2013-10-15 <b>Last modified:</b> 2025-03-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.traits">issues</a> in [re.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.6.6 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>/7, begins with "if <code>typeid(use_facet&lt;collate&lt;charT&gt; &gt;) == typeid(collate_byname&lt;charT&gt;)</code>", 
which appears to be pseudocode with the intention to convey that the collate facet has not been replaced by the user. Cf. the wording in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">N1429</a> "there is no portable way to implement 
<code>transform_primary</code> in terms of <code>std::locale</code>, since even if the sort key format returned by 
<code>std::collate_byname&lt;&gt;::transform</code> is known and can be converted into a primary sort key, the user can still 
install their own custom <code>std::collate</code> implementation into the locale object used, and that can use any sort key 
format they see fit.".
<p/>
Taken literally, 28.6.6 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>/7 appears to imply that named locales are required to hold their collate facets with 
dynamic type <code>std::collate_byname&lt;charT&gt;</code>, which is in fact true in some implementations (e.g libc++), but not others 
(e.g. libstdc++). This does not follow from the description of <code>_byname</code> in 28.3.3.1.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.facet">[locale.facet]</a>/4, which is only 
required to provide equivalent semantics, to the named locale's facet, not to actually be one.
</p>


<p><i>[2015-05-06 Lenexa: Move to Open]</i></p>


<p>MC, RP: Consequence of failing to follow the rule is UB.</p>
<p>MC: Tightening of requirements.</p>
<p>RP: It should be this way, we just didn't impose it before.</p>
<p>MC: Second change is a bug fix, original code didn't work.</p>
<p>TK: Doesn't seem to make things worse.</p>
<p>Bring up in larger group tomorrow.</p>
<p>JW arrives.</p>
<p>JW: libstdc++ violates this due to two std::string ABIs.</p>
<p>JW: This prevents installing a type derived from Facet_byname, constrains the implementor from using a smarter derived class version.</p>
<p>JW: Can't look at facet id to detect replacement, because replacements have the same id.</p>
<p>RP: Can you give it multiple ids through multiple inheritance?</p>
<p>JW: No, the facet mechanism wouldn't like that.</p>
<p>JW: We should also ask Martin Sebor, he's implemented this stuff recently.</p>
<p>MC: Sounds like this resolution doesn't work, need a better solution.</p>
<p>JW: Write in words "if the facet has not been replaced by the user", the implementation knows how to detect that, but not like this.</p>
<p>RP: User RE traits need to detect this too.</p>
<p>JW: =(</p>
<p>Move to Open, JW will invite Martin Sebor to join LWG for discussion.</p>
<p>Later ... </p>
<p>JW: This is not needed for user specializations after all.</p>
<p>MC: Agree, [re.traits]/7 only applies to the stdlib traits.</p>
<p>NM: Effects: doesn't make sense.</p>
<p>JW, NM, Martin Sebor to come up with new wording.</p>

<p><i>[2025-03-06; Jonathan comments]</i></p>

<p>
LWG <a href="4186" title="regex_traits::transform_primary mistakenly detects typeid of a function (Status: WP)">4186</a> fixed the missing <code class='backtick'>(getloc())</code> part.
Maybe we can resolve this differently, by changing 28.6.6 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>
to:
<blockquote>
Let <code class='backtick'>C</code> be <code>use_facet&lt;collate&lt;charT&gt; &gt;(getloc())</code>.
If <code>typeid(C) == typeid(collate_byname&lt;charT&gt;)
|| typeid(C) == typeid(collate&lt;charT&gt;)</code> and the form of ...
</blockquote>
</p>



<p id="res-2338"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 28.3.3.1.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.facet">[locale.facet]</a>/4 as indicated:</p>

<blockquote><p>
For some standard facets a standard "...<code>_byname</code>" class, derived from it, implements the virtual function
semantics <del>equivalent to</del><ins>provided by</ins> that facet of the locale constructed by <code>locale(const char*)</code> 
with the same name.
Each such facet provides a constructor that takes a <code>const char*</code> argument, which names the locale, and a
<code>refs</code> argument, which is passed to the base class constructor. Each such facet also provides a constructor
that takes a string argument <code>str</code> and a <code>refs</code> argument, which has the same effect as calling the first
constructor with the two arguments <code>str.c_str()</code> and <code>refs</code>. If there is no "...<code>_byname</code>" 
version of a facet, the base class implements named locale semantics itself by reference to other facets. <ins>For any 
locale <code>loc</code> constructed by <code>locale(const char*)</code> and facet <code>Facet</code> that has a corresponding standard 
<code>Facet_byname</code> class, <code>typeid(use_facet&lt;Facet&gt;(loc)) == typeid(Facet_byname)</code>.</ins>
</p></blockquote>
</li>

<li><p>Modify 28.6.6 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a>/7 as indicated:</p>

<blockquote><pre>
template &lt;class ForwardIterator&gt;
  string_type transform_primary(ForwardIterator first, ForwardIterator last) const;
</pre><blockquote>
<p>
-7- <i>Effects:</i> if <code>typeid(use_facet&lt;collate&lt;charT&gt; &gt;<ins>(getloc())</ins>) == typeid(collate_byname&lt;charT&gt;)</code> 
and the form of the sort key returned by <code>collate_byname&lt;charT&gt;::transform(first, last)</code> is known and
can be converted into a primary sort key then returns that key, otherwise returns an empty string.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3 id="2342"><a href="2342">2342</a>. User conversion to <code>wchar_t const*</code> or to <code>wchar_t</code> not invoked for <code>operator&lt;&lt;</code></h3>
<p><b>Section:</b> 31.7.6.2 <a href="https://timsong-cpp.github.io/cppwp/ostream">[ostream]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alf P. Steinbach <b>Opened:</b> 2013-10-29 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream">issues</a> in [ostream].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For wide streams argument types <code>wchar_t const*</code> and <code>wchar_t</code> are supported only as template parameters. 
User defined conversions are not considered for template parameter matching. Hence inappropriate overloads of 
<code>operator&lt;&lt;</code> are selected when an implicit conversion is required for the argument, which is inconsistent 
with the behavior for <code>char const*</code> and <code>char</code>, is unexpected, and is a useless result.
<p/>
Demonstration:
</p>
<blockquote><pre>
#include &lt;iostream&gt;

struct Byte_string
{ 
  operator char const*() const { return "Hurray, it works!"; } 
};

struct Wide_string
{ 
  operator wchar_t const*() const { return L"Hurray, it works!"; } 
};

struct Byte_ch
{ 
  operator char() const { return 'X'; } 
};

struct Wide_ch
{ 
  operator wchar_t() const { return L'X'; } 
};

auto main() -> int
{
  using namespace std;
  wcout &lt;&lt; "'X' as char value   : " &lt;&lt; Byte_ch() &lt;&lt; endl;
  wcout &lt;&lt; "'X' as wchar_t value: " &lt;&lt; Wide_ch() &lt;&lt; endl;
  wcout &lt;&lt; "Byte string pointer : " &lt;&lt; Byte_string() &lt;&lt; endl;
  wcout &lt;&lt; "Wide string pointer : " &lt;&lt; Wide_string() &lt;&lt; endl;
}
</pre></blockquote>
<p>
Example output:
</p>
<blockquote><pre>
'X' as char value   : X
'X' as wchar_t value: 88
Byte string pointer : Hurray, it works!
Wide string pointer : 000803C8
</pre></blockquote>



<p id="res-2342"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Modify 31.7.6.2 <a href="https://timsong-cpp.github.io/cppwp/ostream">[ostream]</a>, class template <code>basic_ostream</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
[&hellip;]

<i>// 27.7.3.6.4 character inserters</i>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          charT);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          char);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;,
                                         char);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp;,
                                            wchar_t);</ins>
[&hellip;]

template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          const charT*);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          const char*);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;,
                                         const char*);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp;,
                                            const wchar_t*);</ins>
[&hellip;]
}

</pre></blockquote>
</li>

<li><p>Modify 31.7.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.character">[ostream.inserters.character]</a> as indicated: <em>[Drafting note: 
The replacement of <code>os</code> by <code>out</code> in p1 and the insertion of "<code>out.</code>" in p4 
just fix two obvious typos &mdash; end drafting note]</em></p>

<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          charT c);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          char c);
<i>// specialization</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         char c);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp; out,
                                            wchar_t c);</ins>

<i>// signed and unsigned</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                          signed char c);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                          unsigned char c);
</pre><blockquote>
<p>
-1- <i>Effects:</i> Behaves as a formatted output function (31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>) of <code>out</code>. 
Constructs a character sequence <code>seq</code>. If <code>c</code> has type <code>char</code> and the character type of the stream 
is not <code>char</code>, then <code>seq</code> consists of <code>out.widen(c)</code>; otherwise <code>seq</code> consists of <code>c</code>. 
Determines padding for <code>seq</code> as described in 31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>. Inserts <code>seq</code> into 
<code>out</code>. Calls <code><del>os</del><ins>out</ins>.width(0)</code>.
<p/>
-2- <i>Returns:</i> <code>out</code>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const charT* s);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const char* s);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp; out,
                                            const wchar_t* s);</ins>
											
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const signed char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const unsigned char* s);
</pre><blockquote>
<p>
-3- <i>Requires:</i> <code>s</code> shall not be a null pointer.
<p/>
-4- <i>Effects:</i> Behaves like a formatted inserter (as described in 31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>) of <code>out</code>. 
Creates a character sequence <code>seq</code> of <code>n</code> characters starting at <code>s</code>, each widened using <code>out.widen()</code> 
(27.5.5.3), where <code>n</code> is the number that would be computed as if by:
</p>
<ul>
<li><p>
<code>traits::length(s)</code> for the <ins>following</ins> overload<ins>s:</ins>
<ul>
<li><p>
where the first argument is of type <code>basic_ostream&lt;charT, traits&gt;&amp;</code> 
and the second is of type <code>const charT*</code>,
</p></li>
<li><p>
<del>and also for the overload</del> where the first argument is of type 
<code>basic_ostream&lt;char, traits&gt;&amp;</code> and the second is of type <code>const char*</code>,
</p></li>
<li><p>
<ins>where the first argument is of type 
<code>basic_ostream&lt;wchar_t, traits&gt;&amp;</code> and the second is of type <code>const wchar_t*</code>,</ins>
</p></li>
</ul> 
</p></li>
<li><p>
<code>std::char_traits&lt;char&gt;::length(s)</code> for the overload where the first argument is of type
<code>basic_ostream&lt;charT, traits&gt;&amp;</code> and the second is of type <code>const char*</code>,
</p></li>
<li><p>
<code>traits::length(reinterpret_cast&lt;const char*&gt;(s))</code> for the other two overloads.
</p></li>
</ul>
<p>
Determines padding for <code>seq</code> as described in 31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>. Inserts <code>seq</code> into 
<code>out</code>. Calls <code><ins>out.</ins>width(0)</code>.
<p/>
-5- <i>Returns:</i> <code>out</code>.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3 id="2348"><a href="2348">2348</a>. <code>charT('1')</code> is not the wide equivalent of <code>'1'</code></h3>
<p><b>Section:</b> 22.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a>, 31.7.9 <a href="https://timsong-cpp.github.io/cppwp/quoted.manip">[quoted.manip]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Example: <code>char16_t('1') != u'1'</code> is possible.
<p/>
The numeric value of <code>char16_t</code> is defined to be Unicode
code point, which is same to the ASCII value and UTF-8 for
7-bit chars.  However, <code>char</code> is not guaranteed to have an
encoding which is compatible with ASCII. For example, <code>'1'</code> in EBCDIC is 241.
<p/>
I found three places in the standard casting narrow char
literals: <code>bitset::bitset</code>, <code>bitset::to_string</code> and <code>quoted</code>.
<p/>
PJ confirmed this issue and says he has a solution used
in their <code>&lt;filesystem&gt;</code> implementation, and he may want to
propose it to the standard.
<p/>
The solution in my mind, for now, is to make those default
arguments magical, where the "magic" can be implemented
with a C11 <code>_Generic</code> selection (works in clang):
</p>
<blockquote><pre>
#define _G(T, literal) _Generic(T{}, \
      char: literal, \
      wchar_t: L ## literal, \
      char16_t: u ## literal, \
      char32_t: U ## literal)

  _G(char16_t, '1') == u'1'
</pre></blockquote>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Ask for complete PR (need quoted, to string, et al.)</p>
<p>Will then take it up again</p>
<p>Expectation is that this is correct way to fix this</p>


<p id="res-2348"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

[<i>Drafting note:</i> This is a sample wording fixing only one case;
 I'm just too lazy to copy-paste it before we discussed whether
 the solution is worth and sufficient (for example, should the
 other <code class='backtick'>charT</code>s like <code class='backtick'>unsigned char</code> just don't compile without
 supplying those arguments?  I hope so). &mdash; <i>end drafting note</i>]

<ol>
<li><p>Modify 22.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> p1, class template <code>bitset</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;size_t N&gt; class bitset {
  public:
    [&hellip;]
    template&lt;class charT, class traits, class Allocator&gt;
      explicit bitset(
        const basic_string&lt;charT,traits,Allocator&gt;&amp; str,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type pos = 0,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type n =
          basic_string&lt;charT,traits,Allocator&gt;::npos,
          charT zero = <del>charT('0')</del><ins><em>see below</em></ins>, charT one = <del>charT('1')</del><ins><em>see below</em></ins>);
     [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 22.9.2.2 <a href="https://timsong-cpp.github.io/cppwp/bitset.cons">[bitset.cons]</a> as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
explicit 
bitset(const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type pos = 0,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type n =
         basic_string&lt;charT, traits, Allocator&gt;::npos,
         charT zero = <del>charT('0')</del><ins><em>see below</em></ins>, charT one = <del>charT('1')</del><ins><em>see below</em></ins>);
</pre><blockquote>
<p>
<ins>-?- The default values of <code>zero</code> and <code>one</code> compare equal to the
character literals <code>0</code> and <code>1</code> of type <code>charT</code>, respectively.</ins>
<p/>
-3- <i>Requires::</i> <code>pos &lt;= str.size()</code>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3 id="2358"><a href="2358">2358</a>. Apparently-bogus definition of <code>is_empty</code> type trait</h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-02-01 <b>Last modified:</b> 2017-02-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 'Condition' for <code>std::is_empty</code> is listed as:
</p>
<blockquote><p>
"<code>T</code> is a class type, but not a union type, with no non-static data members other than bit-fields of length 0, 
no virtual member functions, no virtual base classes, and no base class <code>B</code> for which <code>is_empty&lt;B&gt;::value</code> 
is false."
</p></blockquote>
<p>
This is incorrect: there is no such thing as a non-static data member that is a bit-field of length 0, since bit-fields of 
length 0 must be unnamed, and unnamed bit-fields are not members (see 11.4.10 <a href="https://timsong-cpp.github.io/cppwp/class.bit">[class.bit]</a> p2).
<p/>
It also means that classes such as:
</p>
<blockquote><pre>
struct S {
 int : 3;
};
</pre></blockquote>
<p>
are empty (because they have no non-static data members). There's implementation divergence on the value of 
<code>is_empty&lt;S&gt;::value</code>.
<p/>
I'm not sure what the purpose of <code>is_empty</code> is (or how it could be useful), but if it's desirable for the above type to 
not be treated as empty, something like this could work:
</p>
<blockquote><p>
"<code>T</code> is a class type, but not a union type, with no non-static data members <del>other than</del><ins>, no unnamed</ins> 
bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class 
<code>B</code> for which <code>is_empty&lt;B&gt;::value</code> is false."
</p></blockquote>
<p>
and if the above type <em>should</em> be treated as empty, then this might be appropriate:
</p>
<blockquote><p>
"<code>T</code> is a class type, but not a union type, with no <ins>(named)</ins> non-static data members <del>other than bit-fields of 
length 0</del>, no virtual member functions, no virtual base classes, and no base class <code>B</code> for which 
<code>is_empty&lt;B&gt;::value</code> is false."
</p></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Walter says: We want <code>is_empty_v&lt;S&gt;</code> to produce false as a result.  Therefore, we recommend adoption of the first of the issue's suggestions.</p>
<p>Tuesday AM: Moved to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<p><i>[2016-10 by Marshall - this PR incorrectly highlighted changed portions]</i></p>


<blockquote class="note">
<p>Modify Table 38  Type property predicates for <code>is_empty</code> as follows:</p>
<blockquote><p>
<code>T</code> is a non-union class type with no non-static data members <del>other than</del><ins>, no unnamed</ins> bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class <code>B</code> for which <code>is_empty_v&lt;B&gt;</code> is false.</p>
</blockquote>
</blockquote>

<p><i>[2016-10 Telecon]</i></p>

<p>Should probably point at section 1.8 for some of this. Status back to 'Open'</p>


<p id="res-2358"><b>Proposed resolution:</b></p>
<p>Modify Table 38  Type property predicates for <code>is_empty</code> as follows:</p>
<blockquote><p>
<code>T</code> <del>is a class type, but not a union type,</del><ins>is a non-union class type</ins> with no non-static data members<del> other than</del><ins>, no unnamed</ins> bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class <code>B</code> for which <code>is_empty_v&lt;B&gt;</code> is false.</p>
</blockquote>





<hr>
<h3 id="2362"><a href="2362">2362</a>. unique, associative <code>emplace()</code> should not move/copy the <code>mapped_type</code> constructor 
arguments when no insertion happens</h3>
<p><b>Section:</b> 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-02-15 <b>Last modified:</b> 2015-09-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>a_uniq.emplace(args)</code> is specified as:
</p>

<blockquote><p>
<i>Effects</i>: Inserts a value_type object <code>t</code> constructed with<br/>
<code>std::forward&lt;Args&gt;(args)...</code> if and only if there is no element in the<br/>
container with key equivalent to the key of <code>t</code>. The <code>bool</code> component of<br/>
the returned pair is true if and only if the insertion takes place,<br/>
and the iterator component of the pair points to the element with key<br/>
equivalent to the key of <code>t</code>. 
</p></blockquote>

<p>
However, we occasionally find code of the form:
</p>

<blockquote><pre>
std::unique_ptr&lt;Foo&gt; p(new Foo);
auto res = m.emplace("foo", std::move(p));
</pre></blockquote>

<p>
where we'd like to avoid destroying the <code>Foo</code> if the insertion doesn't
take place (if the container already had an element with the specified key).
<p/>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3873">N3873</a> includes
a partial solution to this in the form of a new <code>emplace_stable</code> member function, but LEWG's 
discussion strongly agreed that we'd rather have <code>emplace()</code> Just Work:
<p/>
Should <code>map::emplace()</code> be guaranteed not to move/copy its arguments if the insertion doesn't happen?
<p/>
SF: 8 F: 3 N: 0 A: 0 SA: 0
<p/>
This poll was marred by the fact that we didn't notice or call out
that <code>emplace()</code> must construct the key before doing the lookup, and it
must not then move the key after it determines whether an insert is
going to happen, and the <code>mapped_type</code> instance must live next to the key.
<p/>
The very similar issue <a href="2006" title="emplace broken for associative containers (Status: NAD)">2006</a> was previously marked NAD, with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3178.htm">N3178</a> as
discussion. However, given LEWG's interest in the alternate behavior,
we should reopen the question in this issue.
<p/>
We will need a paper that describes how to implement this before we can make more progress.
</p>



<p id="res-2362"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2366"><a href="2366">2366</a>. <code>istreambuf_iterator</code> end-of-stream equality</h3>
<p><b>Section:</b> 24.6.4 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hyman Rosen <b>Opened:</b> 2014-02-19 <b>Last modified:</b> 2023-04-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#istreambuf.iterator">active issues</a> in [istreambuf.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given the following code,
</p>
<blockquote><pre>
#include &lt;sstream&gt;

std::stringbuf buf;
std::istreambuf_iterator&lt;char&gt; begin(&amp;buf);
std::istreambuf_iterator&lt;char&gt; end;
</pre></blockquote>
<p>
it is not clear from the wording of the Standard whether <code>begin.equal(end)</code>
must be true. In at least one implementation it is not (CC: Sun C++ 5.10 SunOS_sparc Patch 128228-25 2013/02/20) and in at least
one implementation it is (gcc version 4.3.2 x86_64-unknown-linux-gnu).
<p/>
24.6.4 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a> says that <code>end</code> is an end-of-stream iterator since it was default
constructed. It also says that an iterator becomes equal to an end-of-stream
iterator when end of stream is reached by <code>sgetc()</code> having returned <code>eof()</code>.
 [istreambuf.iterator::equal] says that <code>equal()</code> returns true iff both iterators are end of stream
or not end of stream. But there seems to be no requirement that <code>equal</code> check for end-of-stream by calling <code>sgetc()</code>. 
<p/>
Jiahan Zi at BloombergLP discovered this issue through his code failing to
work correctly. Dietmar K&uuml;hl has opined in a private communication that
the iterators should compare equal.
</p>

<p><i>[2023-03-31; Jonathan Wakely comments]</i></p>

<p>
I agree that they should compare equal, but that's in conflict with the
resolution of LWG <a href="2544" title="istreambuf_iterator(basic_streambuf&lt;charT, traits&gt;* s) effects unclear when s is 0 (Status: C++17)">2544</a>, which says that <code>begin</code>
must not be at end-of-stream because <code>&amp;buf</code> is not null.
</p>

<p><i>[2023-04-12; Jonathan adds wording]</i></p>




<p id="res-2366"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.</p>

<ol>
<li>
<p>Change 24.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator.general">[istreambuf.iterator.general]</a> as indicated:</p>
<blockquote>
<pre><code>
    constexpr istreambuf_iterator() noexcept;
    constexpr istreambuf_iterator(default_sentinel_t) noexcept;
    istreambuf_iterator(const istreambuf_iterator&amp;) noexcept = default;
    ~istreambuf_iterator() = default;
    istreambuf_iterator(istream_type&amp; s) noexcept<del>;</del>
    <ins>: istreambuf_iterator(s.rdbuf()) { }</ins>
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(const <i>proxy</i>&amp; p) noexcept;
    <i>&hellip;</i>

  private:
    streambuf_type* sbuf_;              <i>// exposition only</i>
    <ins>int_type c_{};                      <i>// exposition only</i></ins>
  };
}
</code></pre>
</blockquote>
</li>
<li>
<p>Change 24.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator.cons">[istreambuf.iterator.cons]</a> as indicated:</p>
<blockquote>
<p>
For each <code>istreambuf_iterator</code> constructor in this section, an end-of-stream iterator is
constructed if <del>and only if</del> the exposition-only member <code>sbuf_</code> is initialized with a null
pointer value
<ins>or if <code>sbuf_->sgetc()</code> returns <code>traits_type::eof()</code></ins>.
</p>
<pre>
constexpr istreambuf_iterator() noexcept;
constexpr istreambuf_iterator(default_sentinel_t) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code>sbuf_</code> with <code>nullptr</code>.
</p>
</blockquote>
<pre><del>istreambuf_iterator(istream_type&amp; s) noexcept;</del></pre>
<blockquote>
<p><del>
-2- <i>Effects</i>: Initializes <code>sbuf_</code> with <code>s.rdbuf()</code>.
</del></p>
</blockquote>
<pre>
istreambuf_iterator(streambuf_type* s) noexcept;
</pre>
<blockquote class="note">
<p>
[<i>Drafting note:</i>
<code>sgetc()</code> can throw, but this function is <code>noexcept</code>.
Should it swallow exceptions and create an end-of-stream iterator,
to avoid weakening the exception spec of an existing function?]
</p>
</blockquote>
<blockquote>
<p>
-3- <i>Effects</i>: Initializes <code>sbuf_</code> with <code>s</code>.
<ins>
If <code>s</code> is not null, initializes <code>c_</code> with <code>s-&gt;sgetc()</code>.
Sets <code>sbuf_</code> to null if <code>sgetc</code> exits via an exception,
or if <code>traits_type::eq_int_type(c_, traits_type::eof())</code> is <code>true</code>.
</ins>
</p>
</blockquote>
<pre>
istreambuf_iterator(const proxy&amp; p) noexcept;
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: Initializes <code>sbuf_</code> with <code>p.sbuf_</code>.
<ins>
If <code>p.sbuf_</code> is not null, initializes <code>c_</code> with <code>p.keep_</code>.
</ins>
</p>
</blockquote>
</blockquote>
</li>
<li>
<p>Change 24.6.4.4 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator.ops">[istreambuf.iterator.ops]</a> as indicated:</p>
<blockquote>
<pre>
charT operator*() const;
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>sbuf_</code> is not null.</ins>
</p>
<p>
-1- <i>Returns</i>:
<del>
The character obtained via the <code>streambuf</code>
member <code>sbuf_-&gt;sgetc()</code>.
</del>
<ins><code>traits_type::to_char_type(c_)</code>.</ins>
</p>
<p>
<ins>-?- <i>Throws</i>: Nothing.</ins>
</p>
</blockquote>
<pre>
istreambuf_iterator&amp; operator++();
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>sbuf_</code> is not null.</ins>
</p>
<p>-2-
<i>Effects</i>:
<del>As if by <code>sbuf_-&gt;sbumpc()</code>.</del>
<ins>
Performs <code>c_ = sbuf_-&gt;snextc()</code>,
then sets <code>sbuf_</code> to null
if <code>traits_type::eq_int_type(c_, traits_type::eof())</code> is <code>true</code>.
</ins>
</p>
<p>-3-
<i>Returns</i>: <code>*this</code>.
</p>
</blockquote>
<pre>
<i>proxy</i> operator++(int);
</pre>
<blockquote>
<p>-4-
<del>
<i>Returns</i>: <code><i>proxy</i>(sbuf_-&gt;sbumpc(), sbuf_)</code>.
</del>
<br/>
<ins><i>Effects</i>: Equivalent to:</ins>
<pre><ins><code><i>proxy</i> p(**this, sbuf_);
++*this;
return p;
</code></ins></pre>
</p>
</blockquote>
<pre>
bool equal(const istreambuf_iterator&amp; b) const;
</pre>
<blockquote>
<p>-5-
<i>Returns</i>: <ins><code>bool(sbuf_) == bool(b.sbuf_)</code>.</ins>
</p>
<p>
<ins>[<i>Note</i>: This is</ins>
<code>true</code> if and only if both iterators are at end-of-stream,
or neither is at end-of-stream, regardless of what streambuf object they use.
<ins>&mdash; <i>end note</i>]</ins>
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
                  const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
</pre>
<blockquote>
<p>-6-
<i>Returns</i>: <code>a.equal(b)</code>.
</p>
</blockquote>
<pre>
bool equal(const istreambuf_iterator&amp; i, default_sentinel_t s) const;
</pre>
<blockquote>
<p>-7-
<i>Returns</i>: <code><del>i.equal(s)</del> <ins>i.sbuf_ == nullptr</ins></code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="2383"><a href="2383">2383</a>. Overflow cannot be ill-formed for chrono::duration integer literals</h3>
<p><b>Section:</b> 30.5.9 <a href="https://timsong-cpp.github.io/cppwp/time.duration.literals">[time.duration.literals]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-05-16 <b>Last modified:</b> 2014-11-08</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.9 <a href="https://timsong-cpp.github.io/cppwp/time.duration.literals">[time.duration.literals]</a> p3 says:
</p>
<blockquote><p>
If any of these suffixes are applied to an integer literal and the
resulting <code>chrono::duration</code> value cannot be represented in the result
type because of overflow, the program is ill-formed.
</p></blockquote>
<p>
Ill-formed requires a diagnostic at compile-time, but there is no way
to  detect the overflow from <code>unsigned long long</code> to the <code>signed
duration&lt;&gt;::rep</code> type.
<p/>
Overflow could be detected if the duration integer literals were
literal operator templates, otherwise overflow can either be undefined
or a run-time error, not ill-formed.
</p>

<p><i>[Urbana 2014-11-07: Move to Open]</i></p>




<p id="res-2383"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2398"><a href="2398">2398</a>. <code>type_info</code>'s destructor shouldn't be required to be virtual</h3>
<p><b>Section:</b> 17.7.3 <a href="https://timsong-cpp.github.io/cppwp/type.info">[type.info]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-06-14 <b>Last modified:</b> 2016-08-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#type.info">issues</a> in [type.info].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>type_info</code>'s destructor is depicted as being <code>virtual</code>, which is nearly unobservable to users (since they can't construct 
or copy this class, they can't usefully derive from it). However, it's technically observable (via <code>is_polymorphic</code> and 
<code>has_virtual_destructor</code>). It also imposes real costs on implementations, requiring them to store one vptr per 
<code>type_info</code> object, when RTTI space consumption is a significant concern.
<p/>
Making this implementation-defined wouldn't affect users (who can observe this only if they're specifically looking for it) and 
wouldn't affect implementations who need <code>virtual</code> here, but it would allow other implementations to drop <code>virtual</code> 
and improve their RTTI space consumption.
<p/>
Richard Smith:
<p/>
It's observable in a few other ways.
</p>
<blockquote><pre>
std::map&lt;void*, something&gt; m;
m[dynamic_cast&lt;void*&gt;(&amp;typeid(blah))] = stuff;
</pre></blockquote>
<p>
... is broken by this change, because you can't <code>dynamic_cast</code> a non-polymorphic class type to <code>void*</code>.
</p>
<blockquote><pre>
type_info&amp; f();
typeid(f());
</pre></blockquote>
<p>
... evaluates <code>f()</code> at runtime without this change, and might not do so with this change.
<p/>
These are probably rare things, but I can imagine at least some forms of the latter being used in SFINAE tricks.
</p>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Marshall to poll LEWG for their opinion</p>

<p><i>[2016-06]</i></p>
 
<p>
On the <a href="http://lists.isocpp.org/lib-ext/2016/06/2451.php">reflector</a>, STL wrote:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>We'll prototype this change and report back with data in the future.</p></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>No update from STL. Set priority to P3</p>


<p id="res-2398"><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 17.7.3 <a href="https://timsong-cpp.github.io/cppwp/type.info">[type.info]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  class type_info {
  public:
    <del>virtual</del><ins><i>see below</i></ins> ~type_info();
    [&hellip;]
  };
}
</pre>
<p>
-1- The class <code>type_info</code> describes type information generated by the implementation. Objects of this class
effectively store a pointer to a name for the type, and an encoded value suitable for comparing two types for
equality or collating order. The names, encoding rule, and collating sequence for types are all unspecified
and may differ between programs. <ins>Whether <code>~type_info()</code> is <code>virtual</code> is implementation-defined.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2414"><a href="2414">2414</a>. Member function reentrancy should be implementation-defined</h3>
<p><b>Section:</b> 16.4.6.9 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-07-01 <b>Last modified:</b> 2021-07-31</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reentrancy">issues</a> in [reentrancy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N3936 16.4.6.9 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a>/1 talks about "functions", but that doesn't address the scenario of calling different member
functions of a single object. Member functions often have to violate and then re-establish invariants. For example, vectors
often have "holes" during insertion, and element constructors/destructors/etc. shouldn't be allowed to observe the vector
while it's in this invariant-violating state. The [reentrancy] Standardese should be extended to cover member functions,
so that implementers can either say that member function reentrancy is universally prohibited, or selectively allowed for
very specific scenarios.
<p/>
(For clarity, this issue has been split off from LWG <a href="2382" title="Unclear order of container update versus object destruction on removing an object (Status: Pending NAD)">2382</a>.)
</p>

<p><i>[2014-11-03 Urbana]</i></p>

<p>
AJM confirmed with SG1 that they had no special concerns with this issue, and LWG should retain ownership.
<p/>
AM: this is too overly broad as it also covers calling the exact same member function on a different object<br/>
STL: so you insert into a map, and copying the value triggers another insertion into a different map of the same type<br/>
GR: reentrancy seems to imply the single-threaded case, but needs to consider the multi-threaded case
<p/>
Needs more wording.
</p>
<p>
Move to Open
</p>

<p><i>[2015-07 Telecon Urbana]</i></p>

<p>Marshall to ping STL for updated wording.<br/></p>

<p><i>[2016-05 email from STL]</i></p>

<p>I don't have any better suggestions than my original PR at the moment.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 16.4.6.9 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a> p1 as indicated:</p>
<blockquote>
<p>
-1- Except where explicitly specified in this standard, it is implementation-defined which functions <ins>(including different
member functions called on a single object)</ins> in the Standard C++ library may be recursively reentered.
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2021-07-29 Tim suggests new wording]</i></p>

<p>
The "<code>this</code> pointer" restriction is modeled on 11.9.5 <a href="https://timsong-cpp.github.io/cppwp/class.cdtor">[class.cdtor]</a> p2.
It allows us to continue to specify a member function <code>f</code> as calling some other
member function <code>g</code>, since any such call would use something obtained
from the first member function's <code>this</code> pointer.
<p/>
In all other cases, this wording disallows such "recursion on object" unless both
member functions are <code>const</code> (or are treated as such for the
purposes of data race avoidance). Using "access" means that we also cover direct
access to the object representation, such as the following pathological example
<a href="https://quuxplusone.github.io/blog/2021/04/17/pathological-string-appends/">from Arthur O'Dwyer</a>,
which is now undefined:
</p>
<blockquote>
<pre>
std::string s = "hello world";
char *first = (char*)&amp;s;
char *last = (char*)(&amp;s + 1);
s.append(first, last);
</pre>
</blockquote>


<p id="res-2414"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4892" title=" Working Draft, Standard for Programming Language C++">N4892</a>.</p>

<ol>
<li><p>Add the following paragraph to 16.4.6.9 <a href="https://timsong-cpp.github.io/cppwp/reentrancy">[reentrancy]</a>:</p>
<blockquote>
<p>
<ins>-?- During the execution of a standard library non-static member function <i>F</i> on an object,
if that object is accessed through a glvalue that is not obtained, directly or indirectly, from
the <code>this</code> pointer of <i>F</i>, in a manner that can conflict (6.10.2.2 <a href="https://timsong-cpp.github.io/cppwp/intro.races">[intro.races]</a>)
with any access that <i>F</i> is permitted to perform (16.4.6.10 <a href="https://timsong-cpp.github.io/cppwp/res.on.data.races">[res.on.data.races]</a>),
the behavior is undefined unless otherwise specified.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2421"><a href="2421">2421</a>. Non-specification of handling zero size in <code>std::align</code> [ptr.align]</h3>
<p><b>Section:</b> 20.2.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.align">[ptr.align]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Melissa Mears <b>Opened:</b> 2014-08-06 <b>Last modified:</b> 2014-11-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ptr.align">active issues</a> in [ptr.align].</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.align">issues</a> in [ptr.align].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>std::align</code> does not appear to specify what happens when the value of the <code>size</code> 
parameter is 0. (The question of what happens when <code>alignment</code> is 0 is mentioned in another Defect Report, <a href="2377" title="std::align requirements overly strict (Status: C++17)">2377</a>; 
it would change the behavior to be undefined rather than potentially implementation-defined.)
<p/>
The case of <code>size</code> being 0 is interesting because the result is ambiguous. Consider the following code's output:
</p>
<blockquote>
<pre>
#include &lt;cstdio&gt;
#include &lt;memory&gt;

int main()
{
  alignas(8) char buffer[8];
  void *ptr = &amp;buffer[1];
  std::size_t space = sizeof(buffer) - sizeof(char[1]);

  void *result = std::align(8, 0, ptr, space);

  std::printf("%d %td\n", !!result, result ? (static_cast&lt;char*&gt;(result) - buffer) : std::ptrdiff_t(-1));
}
</pre>
</blockquote>
<p>
There are four straightforward answers as to what the behavior of <code>std::align</code> with size 0 should be:
</p>
<ol>
<li><p>The behavior is undefined because the size is invalid.</p></li>
<li><p>The behavior is implementation-defined. This seems to be the status quo, with current implementations using #3.</p></li>
<li><p>Act the same as <code>size == 1</code>, except that if <code>size == 1</code> would fail but would be defined and succeed 
if space were exactly 1 larger, the result is a pointer to the byte past the end of the <code>ptr</code> buffer. That is, the 
"aligned" version of a 0-byte object can be one past the end of an allocation. Such pointers are, of course, valid when not 
dereferenced (and a "0-byte object" shouldn't be), but whether that is desired is not specified in the Standard's definition 
of <code>std::align</code>, it appears. The output of the code sample is "<code>1 8</code>" in this case.</p></li>
<li><p>Act the same as <code>size == 1</code>; this means that returning "one past the end" is not a possible result. In this case, 
the code sample's output is "<code>0 -1</code>".</p></li>
</ol>
<p>
The two compilers I could get working with <code>std::align</code>, Visual Studio 2013 and Clang 3.4, implement #3. (Change <code>%td</code> to 
<code>%Id</code> on Visual Studio 2013 and earlier. 2014 and later will have <code>%td</code>.)
</p>


<p id="res-2421"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2423"><a href="2423">2423</a>. Missing specification <code>slice_array</code>, <code>gslice_array</code>, <code>mask_array</code>, <code>indirect_array</code> copy constructor</h3>
<p><b>Section:</b> 29.6.5 <a href="https://timsong-cpp.github.io/cppwp/template.slice.array">[template.slice.array]</a>, 29.6.7 <a href="https://timsong-cpp.github.io/cppwp/template.gslice.array">[template.gslice.array]</a>, 29.6.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a>, 29.6.9 <a href="https://timsong-cpp.github.io/cppwp/template.indirect.array">[template.indirect.array]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Akira Takahashi <b>Opened:</b> 2014-08-12 <b>Last modified:</b> 2014-11-03</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#template.slice.array">issues</a> in [template.slice.array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I found a missing specification of the copy constructor of the following class templates:
</p>
<ul>
<li><p><code>slice_array</code> (29.6.5 <a href="https://timsong-cpp.github.io/cppwp/template.slice.array">[template.slice.array]</a>)</p></li>
<li><p><code>gslice_array</code> (29.6.7 <a href="https://timsong-cpp.github.io/cppwp/template.gslice.array">[template.gslice.array]</a>)</p></li>
<li><p><code>mask_array</code> (29.6.8 <a href="https://timsong-cpp.github.io/cppwp/template.mask.array">[template.mask.array]</a>)</p></li>
<li><p><code>indirect_array</code> (29.6.9 <a href="https://timsong-cpp.github.io/cppwp/template.indirect.array">[template.indirect.array]</a>)</p></li>
</ul>


<p id="res-2423"><b>Proposed resolution:</b></p>
<ol>
<li><p>Before 29.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/slice.arr.assign">[slice.arr.assign]</a> insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <code>slice_array</code> constructors [slice.arr.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>slice_array(const slice_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <code>valarray&lt;T&gt;</code> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 29.6.7.2 <a href="https://timsong-cpp.github.io/cppwp/gslice.array.assign">[gslice.array.assign]</a> insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <code>gslice_array</code> constructors [gslice.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>gslice_array(const gslice_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <code>valarray&lt;T&gt;</code> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 29.6.8.2 <a href="https://timsong-cpp.github.io/cppwp/mask.array.assign">[mask.array.assign]</a> insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <code>mask_array</code> constructors [mask.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>mask_array(const mask_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <code>valarray&lt;T&gt;</code> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 29.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/indirect.array.assign">[indirect.array.assign]</a> insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <code>indirect_array</code> constructors [indirect.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>indirect_array(const indirect_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <code>valarray&lt;T&gt;</code> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2431"><a href="2431">2431</a>. Missing regular expression traits requirements</h3>
<p><b>Section:</b> 28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-09-30 <b>Last modified:</b> 2020-04-16</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.req">active issues</a> in [re.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.req">issues</a> in [re.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on the traits class in 28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> do not say whether a
regular expression traits class is required to be <code>DefaultConstructible</code>, 
<code>CopyConstructible</code>, <code>CopyAssignable</code> etc.
<p/>
The <code>std::regex_traits</code> class appears to be all of the above, but can
<code>basic_regex</code> assume that for user-defined traits classes?
<p/>
Should the following statements all leave <code>u</code> in equivalent states?
</p>
<blockquote><pre>
X u{v};
X u; u = v;
X u; u.imbue(v.getloc();
</pre></blockquote>
<p>
Whether they are equivalent has implications for <code>basic_regex</code> copy construction and 
assignment.
</p>

<p><i>[2020-04-16,
Jonathan adds that 28.6.7.5 <a href="https://timsong-cpp.github.io/cppwp/re.regex.locale">[re.regex.locale]</a> requires the traits type
to be default-initialized, despite no guarantee that the traits type is
default constructible.
]</i></p>




<p id="res-2431"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2452"><a href="2452">2452</a>. <code>is_constructible</code>, etc. and default arguments</h3>
<p><b>Section:</b> 21 <a href="https://timsong-cpp.github.io/cppwp/meta">[meta]</a> <b>Status:</b> <a href="lwg-active.html#Core">Core</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2014-11-04 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>Discussion:</b></p>
<p>
The <code>BaseCharacteristic</code> for <code>is_constructible</code> is defined in terms of the well-formedness 
of a declaration for an invented variable. The well-formedness of the described declaration itself may 
change for the same set of arguments because of the introduction of default arguments.
<p/>
In the following program, there appears to be conflicting definitions of a specialization of 
<code>std::is_constructible</code>; however, it seems that this situation is caused without a user violation 
of the library requirements or the ODR. There is a similar issue with <code>is_convertible</code>, <code>result_of</code>
and others.
<p/>
a.cc:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
struct A { A(int, int); };
const std::false_type&amp; x1 = std::is_constructible&lt;A, int&gt;();

int main() { }
</pre></blockquote>
<p>
b.cc:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
struct A { A(int, int); };

inline A::A(int, int = 0) { }

const std::true_type&amp; x2 = std::is_constructible&lt;A, int&gt;();
</pre></blockquote>
<p>
Presumably this program should invoke undefined behaviour, but the Library specification doesn't
say that.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Core wording should say "this kind of thing is ill-formed, no diagnostic required"
</p>


<p id="res-2452"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2453"><a href="2453">2453</a>. &sect;[iterator.range] and now [iterator.container] aren't available via <code>&lt;initializer_list&gt;</code></h3>
<p><b>Section:</b> 17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>, 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2021-06-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
These sections define helper functions, some of which apply to <code>initializer_list&lt;T&gt;</code>. And they're
available if you include one of a long list of header files, many of which include <code>&lt;initializer_list&gt;</code>.
But they are not available if you include <code>&lt;initializer_list&gt;</code>. This seems very odd.
</p>
<blockquote><pre>
#include &lt;initializer_list&gt;
auto x = {1, 2, 3};
const int *p = data(x); // error, undeclared
#include &lt;vector&gt;
const int *q = data(x); // ok
</pre></blockquote>


<p id="res-2453"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2461"><a href="2461">2461</a>. Interaction between allocators and container exception safety guarantees</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>, 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> dyp <b>Opened:</b> 2014-12-06 <b>Last modified:</b> 2015-06-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When resizing a <code>vector</code>, the accessibility and exception specification of the value type's 
constructors determines whether the elements are copied or moved to the new buffer.
However, the copy/move is performed via the allocator's <code>construct</code> member function, which is 
assumed, but not required, to call the copy/move constructor and propagate only exceptions 
from the value type's copy/move constructor. The issue might also affect other classes. 
<p/>
The current wording in N4296 relevant here is from Table 28 &mdash; "Allocator requirements" in 
16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>: 
</p>
<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>a.construct(c, args)</code>
</td>
<td>
(not used)
</td>
<td>
<i>Effect</i>: Constructs an object of type <code>C</code> at <code>c</code>
</td>
<td>
<code>::new ((void*)c) C(forward&lt;Args&gt;(args)...)</code>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>
<p>
and from 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> p9:
</p>
<blockquote><p>
An allocator may constrain the types on which it can be instantiated and the arguments for which its
<code>construct</code> member may be called. If a type cannot be used with a particular allocator, the allocator class
or the call to <code>construct</code> may fail to instantiate.
</p></blockquote>
<p>
I conclude the following from the wording:
</p>
<ol>
<li><p>The allocator is not required to call the copy constructor if the
arguments (args) is a single (potentially const) lvalue of the value
type. Similarly for a non-const rvalue + move constructor. See also
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p15 which seems to try to require
this, but is not sufficient:
That paragraph specifies the semantics of the allocator's operations,
but not which constructors of the value type are used, if any.
</p></li>
<li>
<p>The allocator may throw exceptions in addition to the exceptions propagated by
the constructors of the value type; it can also propagate exceptions from constructors
other than a copy/move constructor.
</p>
</li>
</ol>
<p>
This leads to an issue with the wording of the exception safety guarantees for vector modifiers in
23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> p1:
</p>
<blockquote>
<p>
[&hellip;]
</p>
<pre>
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</pre>
<blockquote>
<p>
<i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. If no 
reallocation happens, all the iterators and references before the insertion point remain valid. 
If an exception is thrown other than by the copy constructor, move constructor, assignment 
operator, or move assignment operator of <code>T</code> or by any InputIterator operation there are 
no effects.
<span  style="color:#C80000;font-weight:bold">
If an exception is thrown while inserting a single element at the end and <code>T</code> 
is <code>CopyInsertable</code> or <code>is_nothrow_move_constructible&lt;T&gt;::value</code>
is true, there are no effects. Otherwise, if an exception is thrown by the move constructor of a
non-<code>CopyInsertable</code> <code>T</code>, the effects are unspecified.
</span>
</p>
</blockquote>
</blockquote>
<p>
The wording leads to the following problem:
Copy and move assignment are invoked directly from <code>vector</code>.
For intermediary objects (see <a href="2164" title="What are the semantics of vector.emplace(vector.begin(), vector.back())? (Status: C++20)">2164</a>),
<code>vector</code> also directly invokes the copy and move constructor of the value type.
However, construction of the actual element within the buffer is invoked via the allocator abstraction.
As discussed above, the allocator currently is not required to call a copy/move constructor.
If <code>is_nothrow_move_constructible&lt;T&gt;::value</code> is <code>true</code> for some value type <code>T</code>,
but the allocator uses modifying operations for <code>MoveInsertion</code> that do throw,
the implementation is required to ensure that "there are no effects",
even if the source buffer has been modified.
<p/>
Similarly, the <code>vector</code> capacity functions specify exception safety guarantees
referring to the move constructor of the value type. For example, <code>vector::resize</code> in 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> p14:
</p>
<blockquote>
<i>Remarks</i>: If an exception is thrown other than by the move constructor of a
non-<code>CopyInsertable</code> <code>T</code> there are no effects.
</blockquote>
<p>
The wording leads to the same issue as described above.
<p/>
Code example:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
class allocator;

class pot_reg_type // a type which creates
                   // potentially registered instances
{
private:
  friend class allocator&lt;pot_reg_type&gt;;
  struct register_t {};

  static std::set&lt;pot_reg_type*&gt;&amp; get_registry()
  {
    static std::set&lt;pot_reg_type*&gt; registry;
    return registry;
  }
  void enregister() noexcept(false)
  {
    get_registry().insert(this);
  }
  void deregister()
  {
    get_registry().erase(this);
  }

public:
  pot_reg_type(void               ) noexcept(true) {}
  pot_reg_type(pot_reg_type const&amp;) noexcept(true) {}
  pot_reg_type(pot_reg_type&amp;&amp;     ) noexcept(true) {}

private:
  pot_reg_type(register_t                     ) noexcept(false)
  { enregister(); }
  pot_reg_type(register_t, pot_reg_type const&amp;) noexcept(false)
  { enregister(); }
  pot_reg_type(register_t, pot_reg_type&amp;&amp;     ) noexcept(false)
  { enregister(); }
};

template&lt;class T&gt;
class allocator
{
public:
  using value_type = T;

  value_type* allocate(std::size_t p)
  { return (value_type*) ::operator new(p); }

  void deallocate(value_type* p, std::size_t)
  { ::operator delete(p); }

  void construct(pot_reg_type* pos)
  {
    new((void*)pos) pot_reg_type((pot_reg_type::register_t()));
  }
  void construct(pot_reg_type* pos, pot_reg_type const&amp; source)
  {
    new((void*)pos) pot_reg_type(pot_reg_type::register_t(), source);
  }

  template&lt;class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args)
  {
    new((void*)p) T(std::forward&lt;Args&gt;(args)...);
  }
}; 
</pre>
</blockquote>
<p>
The <code>construct</code> member function template is only required for rebinding,
which can be required e.g. to store additional debug information in
the allocated memory (e.g. VS2013).
<p/>
Even though the value type has an accessible and <code>noexcept(true)</code> move
constructor, this allocator won't call that constructor for rvalue arguments.
In any case, it does not call a constructor for which vector has formulated its 
requirements. An exception thrown by a constructor called by this allocator is not
covered by the specification in 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> and therefore is
guaranteed not to have any effect on the vector object when resizing.
<p/>
For an example how this might invalidate the exception safety
guarantees, see <a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/BcM7ya8JeqY/discussion">this post on the std-discussion mailing list</a>.
<p/>
Another problem arises for value types whose constructors are private,
but may be called by the allocator e.g. via friendship.
Those value types are not <code>MoveConstructible</code> 
(<code>is_move_constructible</code> is false), yet they can be <code>MoveInsertable</code>.
It is not possible for <code>vector</code> to create intermediary objects (see <a href="2164" title="What are the semantics of vector.emplace(vector.begin(), vector.back())? (Status: C++20)">2164</a>) of such a type
by directly using the move constructor.
Current implementations of the single-element forms of <code>vector::insert</code> and <code>vector::emplace</code>
do create intermediary objects by directly calling one of the value type's constructors,
probably to allow inserting objects from references that alias other elements of the container.
As far as I can see, Table 100 &mdash; "Sequence container requirements" in 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>
does not require that the creation of such intermediare objects can be performed
by containers using the value type's constructor directly.
It is unclear to me if the allocator's construct function could be used to create those
intermediary objects, given that they have not been allocated by the allocator.
<p/>
Two possible solutions:
</p>
<ol>
<li><p>
Add the following requirement to the <code>allocator_traits::construct</code> function:
If the parameter pack <code>args</code> consists of a single parameter of the type
<code>value_type&amp;&amp;</code>,
the function may only propagate exceptions if <code>is_nothrow_move_constructible&lt;value_type&gt;::value</code>
is <code>false</code>.
<p/>
Requiring <code>alloctor_traits::construct</code> to call a true copy/move constructor
of the value type breaks <code>std::scoped_allocator_adapter</code>,
as pointed out by <a href="https://groups.google.com/a/isocpp.org/d/msg/std-discussion/0yxikZInp-E/Lxj-msFT22cJ">Casey Carter in a post on the std-discussion mailing list</a>.
</p></li>
<li>
<p>
Change vector's criterion whether to move or copy when resizing:
<p/>
Instead of testing the value type's constructors via
<code>is_move_constructible</code>, check the value of
<code>noexcept( allocator_traits&lt;Allocator&gt;::construct(alloc, ptr, rval) )</code>
where
<code>alloc</code> is an lvalue of type <code>Allocator</code>,
<code>ptr</code> is an expression of type <code>allocator_traits&lt;Allocator&gt;::pointer</code>
and
<code>rval</code> is a non-const rvalue of type <code>value_type</code>.
</p>
</li>
</ol>
<p>
A short discussion of the two solutions:
<p/>
Solution 1 allows keeping <code>is_nothrow_move_constructible&lt;value_type&gt;</code>
as the criterion for <code>vector</code> to decide between copying and moving when resizing.
It restricts what can be done inside the <code>construct</code> member function of allocators,
and requires implementers of allocators to pay attention to the value types used.
One could conceive allocators checking the following with a <code>static_assert</code>:
If the value type <code>is_nothrow_move_constructible</code>,
then the constructor actually called for <code>MoveInsertion</code> within the <code>construct</code>
member function is also declared as noexcept.
<p/>
Solution 2 requires changing both the implementation of the default
allocator (add a conditional <code>noexcept</code>) and <code>vector</code> (replace
<code>is_move_constructible</code> with an allocator-targeted check).
It does not impose additional restrictions on the allocator (other than
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> p15),
and works nicely even if the move constructor of a <code>MoveInsertable</code> type is private or deleted
(the allocator might be a friend of the value type).
<p/>
In both cases, an addition might be required to provide the basic exception safety guarantee.
A short discussion on this topic can be found
<a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/yZLnYy_y2z0/discussion">
in the std-discussion mailing list</a>.
Essentially, if <code>allocator_traits&lt;Allocator&gt;::construct</code> throws an exception,
the object may or may not have been constructed.
Two solutions are mentioned in that discussion:
</p>
<ol>
<li><p>
<code>allocator_traits&lt;Allocator&gt;::construct</code> needs to tell its caller
whether or not the construction was successful, in case of an exception.
</p></li>
<li><p>
If <code>allocator_traits&lt;Allocator&gt;::construct</code> propagates an exception,
it shall either not have constructed an object at the specified location,
or that object shall have been destroyed
(or it shall ensure otherwise that no resources are leaked).
</p></li>
</ol>

<p><i>[2015-05-23, Tomasz Kami&nacute;ski comments]</i></p>

<p>
Solution 1 discussed in this issue also breaks support for the <code>polymorphic_allocator</code> proposed in the part 
of the Library Fundamentals TS v1, in addition to already mentioned <code>std::scoped_allocator_adapter</code>. Furthermore 
there is unknown impact on the other user-defined state-full allocators code written in the C++11.
<p/>
In addition the library resolution proposed in the LWG issues <a href="2089" title="std::allocator::construct should use uniform initialization (Status: Resolved)">2089</a> and 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html">N4462</a>, 
will break the relation between the <code>std::allocator_trait::construct</code> method and 
copy/move constructor even for the standard <code>std::allocator</code>. As example please consider following class:
</p>
<blockquote><pre>
struct NonCopyable
{
  NonCopyable() = default;
  NonCopyable(NonCopyable const&amp;) = delete;
  NonCopyable(NonCopyable&amp;&amp;) = delete;
};

struct InitListConstructor : NonCopyable
{
  InitListConstructor() = default;
  InitListConstructor(std::initializer_list&lt;int&gt;);
  operator int() const;
};
</pre></blockquote>
<p>
For the above declarations following expression are ill-formed:
</p>
<blockquote><pre>
InitListConstructor copy(std::declval&lt;InitListConstructor const&amp;&gt;());
InitListConstructor move(std::declval&lt;InitListConstructor&amp;&amp;&gt;());
</pre></blockquote>
<p>
So the class is not <code>CopyConstructible</code> nor <code>MoveConstructible</code>. However the following are well formed:
</p>
<blockquote><pre>
InitListConstructor copy{std::declval&lt;InitListConstructor const&amp;&gt;()};
InitListConstructor move{std::declval&lt;InitListConstructor&amp;&amp;&gt;()};
</pre></blockquote>
<p>
And will be used by <code>std::allocator&lt;InitListConstructor&gt;::construct</code> in case of move-insertion 
and copy-insertion, after appliance of the resolution proposed in mentioned papers:
</p>
<blockquote>
<p>
The gist of the proposed library fix is simple:
</p>
<ul>
<li><p>if <code>is_constructible_v&lt;TargetType, Args...&gt;</code>, use direct-nonlist-initialization</p></li>
<li><p>otherwise, use brace-initialization.</p></li>
</ul>
</blockquote>
<p>
As consequence the requirement proposed in the Solution 1:
</p>
<blockquote><p>
If the parameter pack <code>args</code> consists of a single parameter of the type <code>value_type&amp;&amp;</code>, 
the function may only propagate exceptions if <code>is_nothrow_move_constructible&lt;value_type&gt;::value</code> is false. 
</p></blockquote>
<p>
Will no longer hold for the <code>std::allocator</code>.
</p>



<p id="res-2461"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2471"><a href="2471">2471</a>. <code>copy_n</code>'s number of <code>InputIterator</code> increments unspecified</h3>
<p><b>Section:</b> 26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-01-28 <b>Last modified:</b> 2018-06-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in [alg.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in [alg.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It's unspecified how many times <code>copy_n</code> increments the <code>InputIterator</code>.
<code>uninitialized_copy_n</code> is specified to increment it exactly <code>n</code> times,
which means if an <code>istream_iterator</code> is used then the next character
after those copied is read from the stream and then discarded, losing data.
<p/>
I believe all three of Dinkumware, libc++ and libstdc++ implement
<code>copy_n</code> with <code>n - 1</code> increments of the <code>InputIterator</code>, which avoids reading
and discarding a character when used with <code>istream_iterator</code>, but is
inconsistent with <code>uninitialized_copy_n</code> and causes surprising behaviour
with <code>istreambuf_iterator</code> instead, because <code>copy_n(in, 2, copy_n(in, 2,
out))</code> is not equivalent to <code>copy_n(in, 4, out)</code>
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: refer to LEWG</p>

<p><i>[LEWG Kona 2017]</i></p>

<p>This is a mess. Append to Effects: If the InputIterator is not a forward iterator, increments n-1 times. Otherwise the number of increments is not more than n. (ncm) The preceding proposition is unsatisfactory, because it is wrong for istreambuf_iterator, which is much more useful than istream_iterator. Proposing instead: Append to Effects: If InputIterator is istream_iterator for some T, increments n-1 times. Otherwise, increments n times. Want a paper exploring what the implementations actually do, and what non-uniformity is "right".</p>
<p>Status to Open</p>


<p id="res-2471"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2472"><a href="2472">2472</a>. Heterogeneous comparisons in the standard library can result in ambiguities</h3>
<p><b>Section:</b> 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, 20.2.10.3 <a href="https://timsong-cpp.github.io/cppwp/allocator.globals">[allocator.globals]</a>, 20.3.1.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a>, 20.3.2.2.8 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.cmp">[util.smartptr.shared.cmp]</a>, 30.5.7 <a href="https://timsong-cpp.github.io/cppwp/time.duration.comparisons">[time.duration.comparisons]</a>, 30.6.7 <a href="https://timsong-cpp.github.io/cppwp/time.point.comparisons">[time.point.comparisons]</a>, 20.6.5 <a href="https://timsong-cpp.github.io/cppwp/scoped.adaptor.operators">[scoped.adaptor.operators]</a>, 24.5.1.8 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.cmp">[reverse.iter.cmp]</a>, 24.5.4.8 <a href="https://timsong-cpp.github.io/cppwp/move.iter.op.comp">[move.iter.op.comp]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-02-07 <b>Last modified:</b> 2021-06-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library specifies a lot of heterogeneous comparison operators. For instance:
</p>
<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
</pre>
</blockquote>
<p>
This has an unfortunate consequence:
</p>
<blockquote>
<pre>
#include &lt;tuple&gt;
#include &lt;utility&gt;

using namespace std::rel_ops;
std::tuple&lt;int&gt; a(0);
bool b = a != a;
</pre>
</blockquote>
<p>
The last line here is ill-formed due to ambiguity: it might be <code>rel_ops::operator!=</code>, and it might be the
heterogeneous tuple <code>operator!=</code>. These are not partially ordered, because they have different constraints:
<code>rel_ops</code> requires the types to match, whereas the tuple comparison requires both types to be tuples (but not
to match). The same thing happens for user code that defines its own unconstrained
'<code>template&lt;typename T&gt; operator!=(const T&amp;, const T&amp;)</code>' rather than using <code>rel_ops</code>.
<p/>
One straightforward fix would be to add a homogeneous overload for each heterogeneous comparison:
</p>
<blockquote>
<pre>
template&lt;class... TTypes&gt;
constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;TTypes...&gt;&amp;);
</pre>
<p>
This is then unambiguously chosen over the other options in the preceding case. FWIW, libstdc++ already does this
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.4/libstdc++/api/a01065_source.html#l00788">in some cases</a>.
</p>
</blockquote>


<p id="res-2472"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2478"><a href="2478">2478</a>. Unclear how <code>wstring_convert</code> uses <code>cvtstate</code></h3>
<p><b>Section:</b> 99 [depr.conversions.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2017-04-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.string">active issues</a> in [depr.conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.string">issues</a> in [depr.conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
How do <code>wstring_convert::from_bytes</code> and <code>wstring_convert::to_bytes</code> use
the <code>cvtstate</code> member?
<p/>
Is it passed to the <code>codecvt</code> member functions? Is a copy of it passed
to the member functions? "Otherwise it shall be left unchanged"
implies a copy is used, but if that's really what's intended there are
simpler ways to say so.
</p>


<p id="res-2478"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2479"><a href="2479">2479</a>. Unclear how <code>wbuffer_convert</code> uses <code>cvtstate</code></h3>
<p><b>Section:</b> 99 [depr.conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2017-04-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.buffer">active issues</a> in [depr.conversions.buffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.buffer">issues</a> in [depr.conversions.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
How does <code>wbuffer_convert</code> use the <code>cvtstate</code> member?
<p/>
Is the same conversion state object used for converting both the get
and put areas? That means a read which runs out of bytes halfway 
through a multibyte character will leave some shift state in cvtstate, 
which would then be used by a following write, even though the shift 
state of the get area is unrelated to the put area.
</p>


<p id="res-2479"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2480"><a href="2480">2480</a>. Error handling of <code>wbuffer_convert</code> unclear</h3>
<p><b>Section:</b> 99 [depr.conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2017-04-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.buffer">active issues</a> in [depr.conversions.buffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.buffer">issues</a> in [depr.conversions.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If a <code>codecvt</code> conversion returns <code>codecvt_base::error</code> should that be
treated as <code>EOF</code>? An exception? Should all the successfully converted
characters before a conversion error be available to the users of the
<code>wbuffer_convert</code> and/or the internal <code>streambuf</code>, or does a conversion
error lose information?
</p>


<p id="res-2480"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2481"><a href="2481">2481</a>. <code>wstring_convert</code> should be more precise regarding "byte-error string" etc.</h3>
<p><b>Section:</b> 99 [depr.conversions.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2017-04-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#depr.conversions.string">active issues</a> in [depr.conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.conversions.string">issues</a> in [depr.conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 4 of 99 [depr.conversions.string] introduces <code>byte_err_string</code> 
as "a byte string to display on errors". What does display mean? The string is returned 
on error, it's not displayed anywhere.
<p/>
Paragraph 14 says "Otherwise, if the object was constructed with a
byte-error string, the member function shall return the byte-error
string." The term byte-error string is not used anywhere else.
<p/>
Paragraph 17 talks about storing "default values in <code>byte_err_string</code>".
What default value? Is "Hello, world!" allowed? If it means
default-construction it should say so. If paragraph 14 says it won't
be used what does it matter how it's initialized? The end of the
paragraph refers to storing "<code>byte_err</code> in <code>byte_err_string</code>". This should
be more clearly related to the wording in paragraph 14.
<p/>
It might help if the constructor (and destructor) was specified before
the other member functions, so it can more formally define the
difference between being "constructed with a byte-error string" and
not.
<p/>
All the same issues apply to the <code>wide_err_string</code> member.
</p>


<p id="res-2481"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2490"><a href="2490">2490</a>. <code>&lt;regex&gt;</code> needs lots of <code>noexcept</code></h3>
<p><b>Section:</b> 28.6 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2015-03-27 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re">active issues</a> in [re].</p>
<p><b>View all other</b> <a href="lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Only 4 functions are marked <code>noexcept</code> in all of Clause 28. Many more need to be marked &mdash; for example, 
<code>regex_error::code()</code>, <code>basic_regex::swap()</code>, and <code>sub_match::length()</code>.
</p>



<p id="res-2490"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2491"><a href="2491">2491</a>. <code>std::less&lt;T*&gt;</code> in constant expression</h3>
<p><b>Section:</b> 22.10.8 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-04-01 <b>Last modified:</b> 2021-04-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not entirely clear if and when the specializations of <code>std::less</code> (and friends) for pointer types 
can be used in a constant expression. Consider the following code:
</p>
<blockquote><pre>
#include &lt;functional&gt;

struct foo {};
foo x, y;
constexpr bool b = std::less&lt;foo*&gt;{}(&amp;x, &amp;y); // [1]

foo z[] = {{}, {}};
constexpr bool ba = std::less&lt;foo*&gt;{}(&amp;z[0], &amp;z[1]); // [2]
</pre></blockquote>
<p>
Comparing the address of unrelated objects is not a constant expression since the result is unspecified, so 
it could be expected for [1] to fail and [2] to succeed. However, <code>std::less</code> specialization for pointer 
types is well-defined and yields a total order, so it could just as well be expected for [1] to succeed. Finally, 
since the implementation of such specializations is not mandated, [2] could fail as well (This could happen, if
an implementation would provide such a specialization and if that would use built-in functions that would not be
allowed in constant expressions, for example). In any case, the standard should be clear so as to avoid 
implementation-defined <code>constexpr</code>-ness.
</p>

<p><i>[2017-01-22, Jens provides rationale and proposed wording]</i></p>

<p>
<code>std::less&lt;T*&gt;</code> is required to deliver a total order on pointers.
However, the layout of global objects is typically determined
by the linker, not the compiler, so requiring <code>std::less&lt;T*&gt;</code> to
provide an ordering at compile-time that is consistent with
run-time would need results from linking to feed back to
the compiler, something that C++ has traditionally not required.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Add at the end of 22.10.8 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>:</p>
<blockquote>
<p>
-2- For templates <code>less</code>, <code>greater</code>, <code>less_equal</code>, and <code>greater_equal</code>, [&hellip;], 
if the call operator calls a built-in operator comparing pointers, the call operator yields a strict total order 
that is consistent among those specializations and is also consistent with the partial order imposed by those 
built-in operators. <ins>Relational comparisons of pointer values are not required to be usable as constant expressions.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2021-04-05; Jiang An comments and provides alternative wording]</i></p>

<p>
The libc++ and MSVC STL implementations only support flat address spaces, and always use comparison operators. 
The libstdc++ implementation casts pointer values to <code>uintptr_t</code> if the direct comparison result is unusable 
in constant evaluation.
<p/>
So, I think that we can specify that the implementation-defined strict total order (3.28 <a href="https://timsong-cpp.github.io/cppwp/defns.order.ptr">[defns.order.ptr]</a>) 
generates a core constant expression if and only if the corresponding underlying comparison expression comparing 
pointer values is a core constant expression. No any other case should be a core constant expression, otherwise 
we should also make the underlying comparison expression a core constant expression.
<p/>
IMO the proposed resolution is already implemented in libc++, libstdc++, and MSVC STL, and implementable on compilers 
that either support flat address spaces only or have implemented intrinsics needed for transparent comparison operators 
and <code>std::is_constant_evaluated</code>.
</p>



<p id="res-2491"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4885">N4885</a>.</p>

<ol>
<li><p>Add at the end of 22.10.8 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a> p2:</p>
<blockquote>
<p>
-2- For templates <code>less</code>, <code>greater</code>, <code>less_equal</code>, and <code>greater_equal</code>, the specializations 
for any pointer type yield a result consistent with the implementation-defined strict total order over pointers 
(3.28 <a href="https://timsong-cpp.github.io/cppwp/defns.order.ptr">[defns.order.ptr]</a>). [<i>Note 1</i>: If <code>a &lt; b</code> is well-defined for pointers <code>a</code> and 
<code>b</code> of type <code>P</code>, then <code>(a &lt; b) == less&lt;P&gt;()(a, b)</code>, <code>(a &gt; b) == greater&lt;P&gt;()(a, b)</code>, 
and so forth. &mdash; <i>end note</i>] For template specializations <code>less&lt;void&gt;</code>, <code>greater&lt;void&gt;</code>, 
<code>less_equal&lt;void&gt;</code>, and <code>greater_equal&lt;void&gt;</code>, if the call operator calls a built-in operator 
comparing pointers, the call operator yields a result consistent with the implementation-defined strict total order over 
pointers. <ins>A comparison result of pointer values is a core constant expression if and only if the corresponding 
built-in comparison expression is a core constant expression.</ins>
</p>
</blockquote>
</li>

<li><p>Add at the end of 22.10.9 <a href="https://timsong-cpp.github.io/cppwp/range.cmp">[range.cmp]</a> (3.1):</p>
<blockquote>
<p>
-3- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If the expression <code>std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u)</code> results in a call 
to a built-in operator <code>==</code> comparing pointers: returns <code>false</code> if either (the converted value of) <code>t</code> 
precedes <code>u</code> or <code>u</code> precedes <code>t</code> in the implementation-defined strict total order over pointers 
(3.28 <a href="https://timsong-cpp.github.io/cppwp/defns.order.ptr">[defns.order.ptr]</a>) and otherwise <code>true</code>. <ins>The result is a core constant expression if and only 
if <code>std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u)</code> is a core constant expression.</ins></p></li>
<li><p>(3.2) &mdash; Otherwise, equivalent to: <code>return std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u);</code></p></li>
</ol>
</blockquote>
</li>

<li><p>Add at the end of 22.10.9 <a href="https://timsong-cpp.github.io/cppwp/range.cmp">[range.cmp]</a> (7.1):</p>
<blockquote>
<p>
-7- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; If the expression <code>std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u)</code> results in a call 
to a built-in operator <code>&lt;</code> comparing pointers: returns <code>true</code> if (the converted value of) <code>t</code> 
precedes <code>u</code> in the implementation-defined strict total order over pointers (3.28 <a href="https://timsong-cpp.github.io/cppwp/defns.order.ptr">[defns.order.ptr]</a>) and 
otherwise <code>false</code>. <ins>The result is a core constant expression if and only 
if <code>std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u)</code> is a core constant expression.</ins></p></li>
<li><p>(7.2) &mdash; Otherwise, equivalent to: <code>return std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u);</code></p></li>
</ol>
</blockquote>
</li>

<li><p>Add at the end of 22.10.8.8 <a href="https://timsong-cpp.github.io/cppwp/comparisons.three.way">[comparisons.three.way]</a> (3.1):</p>
<blockquote>
<p>
-3- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If the expression <code>std::forward&lt;T&gt;(t) &lt;=&gt; std::forward&lt;U&gt;(u)</code> results in a call 
to a built-in operator <code>&lt;=&gt;</code> comparing pointers: returns <code>strong_ordering::less</code> if (the converted value 
of) <code>t</code> precedes <code>u</code> in the implementation-defined strict total order over pointers (3.28 <a href="https://timsong-cpp.github.io/cppwp/defns.order.ptr">[defns.order.ptr]</a>), 
<code>strong_ordering::greater</code> if <code>u</code> precedes <code>t</code>, and otherwise <code>strong_ordering::equal</code>. 
<ins>The result is a core constant expression if and only if <code>std::forward&lt;T&gt;(t) &lt;=&gt; std::forward&lt;U&gt;(u)</code> 
is a core constant expression.</ins></p></li>
<li><p>(3.2) &mdash; Otherwise, equivalent to: <code>return std::forward&lt;T&gt;(t) &lt;=&gt; std::forward&lt;U&gt;(u);</code></p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2493"><a href="2493">2493</a>. <code>initializer_list</code> supports incomplete classes</h3>
<p><b>Section:</b> 17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-04-27 <b>Last modified:</b> 2015-05-05</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The typical use-case of <code>std::initializer_list&lt;T&gt;</code> is for a pass-by-value parameter of <code>T</code>'s constructor. 
However, this contravenes 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a>/2.5 because <code>initializer_list</code> doesn't specifically allow 
incomplete types (as do for example <code>std::unique_ptr</code> (20.3.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr">[unique.ptr]</a>/5) and 
<code>std::enable_shared_from_this</code> (20.3.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a>/2)).
<p/>
A resolution would be to copy-paste the relevant text from such a paragraph.
</p>



<p id="res-2493"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2496"><a href="2496">2496</a>. Certain hard-to-avoid errors not in the immediate context are not allowed to be triggered by 
the evaluation of type traits</h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-07 <b>Last modified:</b> 2015-08-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I do not believe that the wording in 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> paragraph 3 allows for the following program to be ill-formed:
</p>
<blockquote>
<pre>
#include &lt;type_traits&gt;

template &lt;typename T&gt; struct B : T { };
template &lt;typename T&gt; struct A { A&amp; operator=(const B&lt;T&gt;&amp;); };

std::is_assignable&lt;A&lt;int&gt;, int&gt; q;
</pre>
</blockquote>
<p>
In particular, I do not see where the wording allows for the "compilation of the expression" 
<code>declval&lt;T&gt;() = declval&lt;U&gt;()</code> to occur as a consequence of instantiating <code>std::is_assignable&lt;T, U&gt;</code> 
(where <code>T</code> and <code>U</code> are, respectively, <code>A&lt;int&gt;</code> and <code>int</code> in the example code).
<p/>
Instantiating <code>A&lt;int&gt;</code> as a result of requiring it to be a complete type does not trigger the instantiation of 
<code>B&lt;int&gt;</code>; however, the "compilation of the expression" in question does.
</p>


<p id="res-2496"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2497"><a href="2497">2497</a>. Use of <code>uncaught_exception()</code></h3>
<p><b>Section:</b> 31.7.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.sentry">[ostream.sentry]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Roger Orr <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.sentry">issues</a> in [ostream.sentry].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current 31.7.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.sentry">[ostream.sentry]</a>, p4 refers to the now deprecated <code>std::uncaught_exception()</code>: 
D.9 [depr.uncaught].
</p>
<blockquote>
<p>
If <code>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception() &amp;&amp; os.good())</code> is true, calls
<code>os.rdbuf()->pubsync()</code>.
</p>
</blockquote>
<p>
This needs to be changed, for example to use <code>std::uncaught_exceptions()</code> and to capture the value on entry and 
compare with the saved value on exit.
</p>

<p><i>[2015-06, Telecon]</i></p>

<p>
JW: I already added an 's' here to make it use the new function, but that doesn't resolve Roger's suggestion to capture the value on entry and check it.
</p>

<p><i>[2019-03-21; Daniel comments and provides wording]</i></p>

<p>
The wording below implements Roger's suggestion.
</p>


<p id="res-2497"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 31.7.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/ostream.sentry">[ostream.sentry]</a>, class <code>basic_ostream::sentry</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class basic_ostream&lt;charT, traits&gt;::sentry {
    bool ok_; <i>// exposition only</i>
    <ins>int uncaught_ = uncaught_exceptions(); <i>// exposition only</i></ins>
  public:
    explicit sentry(basic_ostream&lt;charT, traits&gt;&amp; os);
    ~sentry();
    explicit operator bool() const { return ok_; }
    sentry(const sentry&amp;) = delete;
    sentry&amp; operator=(const sentry&amp;) = delete;
  };
}
</pre>
<p>
[&hellip;]
</p>
<pre>
~sentry();
</pre>
<blockquote>
<p>
-4- If <code>(os.flags() &amp; ios_base::unitbuf) &amp;&amp; <del>!</del>uncaught_exceptions() <ins>&lt;= uncaught_</ins> 
&amp;&amp; os.good()</code> is <code>true</code>, calls <code>os.rdbuf()-&gt;pubsync()</code>. If that function returns <code>-1</code>, 
sets <code>badbit</code> in <code>os.rdstate()</code> without propagating an exception.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2504"><a href="2504">2504</a>. <code>basic_streambuf</code> is not an abstract class</h3>
<p><b>Section:</b> 31.6.3 <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-05-28 <b>Last modified:</b> 2015-08-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
31.6.3 <a href="https://timsong-cpp.github.io/cppwp/streambuf">[streambuf]</a> p1 says:
</p>
<blockquote><p>
The class template <code>basic_streambuf&lt;charT, traits&gt;</code> serves as an abstract base class for deriving various
stream buffers whose objects each control two character sequences: [&hellip;]
</p></blockquote>
<p>
The term "abstract base class" is not defined in the standard, but "abstract class" is (11.7.4 <a href="https://timsong-cpp.github.io/cppwp/class.abstract">[class.abstract]</a>).
<p/>
According to the synopsis <code>basic_streambuf</code> has no pure virtual
functions so is not an abstract class and none of libstdc++, libc++, or
dinkumware implement it as an abstract class. I don't believe the wording was
ever intended to require it to be an abstract class, but it could be
read that way.
<p/>
I suggest the wording be changed to "polymorphic base class" or
something else that can't be seen to imply a normative requirement to
make it an abstract class.
</p>



<p id="res-2504"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2506"><a href="2506">2506</a>. Underspecification of atomics</h3>
<p><b>Section:</b> 6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>, 32.5.8 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a>, 17.14 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a> <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2015-05-29 <b>Last modified:</b> 2018-03-15</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#intro.multithread">issues</a> in [intro.multithread].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The concurrency libraries specified in clauses 29 and 30 do not adequately specify how they relate to the concurrency model 
specified in 6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>. In particular:
<p/>
6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a> specifies "atomic objects" as having certain properties. I can only assume that instances 
of the classes defined in Clause 29 are intended to be "atomic objects" in this sense, but I can't find any wording to 
specify that, and it's genuinely unclear whether Clause 30 objects are atomic objects. In fact, on a literal reading the 
C++ Standard doesn't appear to provide <em>any</em> portable way to create an atomic object, or even determine whether an 
object is an atomic object.
<p/>
(It's not clear if the term "atomic object" is actually needed, given that atomic objects can have non-atomic operations, 
and non-atomic objects can have atomic operations. But even if the term itself goes away, there still needs to be some 
indication that Clause 29 objects have the properties currently attributed to atomic objects).
<p/>
Similarly, 6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a> uses "atomic operation" as a term of art, but the standard never unambiguously 
identifies any operation as an "atomic operation" (although in one case it unambiguously identifies an operation that is 
<em>not</em> atomic). It does come close in a few cases, but not close enough:
</p>
<ul>
<li><p>6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>/p7 could be read to imply that "synchronization operations" in Clauses 29 and 30 
are also atomic operations. However, that's vague and indirect, and somewhat belied by 32.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a>/p5, 
which specifies that mutex lock and unlock operations "behave as atomic operations", but only "for purposes of determining 
the existence of a data race". Furthermore, not a single operation in Clause 29 explicitly identifies itself as a 
"synchronization operation".</p></li>
<li><p>32.5.8 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a>/p4 states in part that "There shall be a specialization <code>atomic&lt;bool&gt;</code> 
which provides the general atomic operations as specified in 29.6.1", but read in context, "general atomic operations" 
appears to be a loose synonym for "general operations on atomic types" as defined in  [atomics.types.operations.general], 
rather than a use of "atomic object" as Words of Power. Incidentally, "atomic type" is never satisfactorily defined either 
(although the <code>&lt;atomic&gt;</code> synopsis comes close).</p></li>
<li><p>17.14 <a href="https://timsong-cpp.github.io/cppwp/support.runtime">[support.runtime]</a>/p10 specifies exactly which operations are "plain lock-free atomic operations", but 
in a standard where an "integral constant expression" isn't necessarily a "constant expression", I do not feel safe assuming 
that a "plain lock-free atomic operation" is an "atomic operation".</p></li>
<li><p>Hans Boehm tells me the operations with "atomically" in the Effects element are intended to be atomic operations, 
but since "atomic operation" is a term of art (e.g. in 6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>/p27.4), I think this needs to be 
spelled out rather than assumed. Furthermore, this does not help with 32.5.11 <a href="https://timsong-cpp.github.io/cppwp/atomics.fences">[atomics.fences]</a>, or anything in Clause 30.</p></li>
</ul>

<p><i>[2018-03 JAX; Geoffrey comments in behalf of SG1]</i></p>

<p>
SG1 consensus is that operations outside clause 32 are not "atomic operations", and objects of types defined outside clause 32 are not "atomic objects". "Synchronization operations" are operations which act as endpoints of primitive edges of partial orders other than sequenced-before, but it may make more sense to just drop that term and inline the definition, so to speak.
<p/>
We would welcome a paper to make those definitions more explicit, and revise the wording as needed to be consistent with those definitions.
</p>


<p id="res-2506"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2507"><a href="2507">2507</a>. <code>codecvt_mode</code> should be a bitmask type</h3>
<p><b>Section:</b> 99 [depr.locale.stdcvt] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-06-08 <b>Last modified:</b> 2017-04-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.locale.stdcvt">issues</a> in [depr.locale.stdcvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The enumeration type <code>codecvt_mode</code> is effectively a bitmask type
(16.3.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a>) with three elements, but isn't defined as
such.
<p/>
This harms usability because bitmask types are required to work well
with bitwise operators, but <code>codecvt_mode</code> doesn't have overloaded
operators, making it very inconvenient to combine values:
</p>
<blockquote><pre>
std::codecvt_utf16&lt;char32_t, 0x10FFFF,
  static_cast&lt;std::codecvt_mode&gt;(std::little_endian|std::generate_header)&gt;
cvt;
</pre></blockquote>
<p>
The <code>static_cast</code> harms readability and should not be necessary.
<p/>
I suggest that either <code>codecvt_mode</code> is specified to be a bitmask type,
or as a minimal fix we provide an overloaded <code>operator|</code> that returns
the right type.
</p>



<p id="res-2507"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2508"><a href="2508">2508</a>. &sect;[new.delete.dataraces] wording needs to be updated</h3>
<p><b>Section:</b> 17.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/new.delete.dataraces">[new.delete.dataraces]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2015-06-09 <b>Last modified:</b> 2016-02-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.dataraces">issues</a> in [new.delete.dataraces].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/new.delete.dataraces">[new.delete.dataraces]</a> uses obsolete wording.
<p/>
It should introduce a "synchronizes with" relationship. "Happens before" is too weak, since that may not composes 
with sequenced before.
<p/>
The "shall not introduce a data race" wording is probably not technically correct either. These may race with other 
(non-allocation/deallocation) concurrent accesses to the object being allocated or deallocated.
</p>



<p id="res-2508"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2512"><a href="2512">2512</a>. Y2K bites; what is an "unambiguous year identifier"?</h3>
<p><b>Section:</b> 28.3.4.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-19 <b>Last modified:</b> 2017-09-07</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#locale.time.get.virtuals">active issues</a> in [locale.time.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.time.get.virtuals">issues</a> in [locale.time.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I recently encountered a failure related to questionable use of <code>do_get_year</code>. The platform where the code happened 
to work had an implementation which handled certain three-digit "year identifiers" as the number of years since 
1900 (<a href="http://www.drdobbs.com/cpp/remembering-y2k/228701726">this article</a> describes such an implementation).
<p/>
28.3.4.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> makes it implementation defined whether two-digit years are accepted, etc., but does not 
say anything specifically about three-digit years.
<p/>
The implementation freedom to not report errors in 28.3.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get">[locale.time.get]</a> paragraph 1 also seems to be too broad.
<p/>
See also the discussion following <a href="http://listarchives.isocpp.org/cgi-bin/wg21/message?wg=lib&amp;msg=38042">c++std-lib-38042</a>.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed PM: This has been this way since C++98. Don't think it's a P2.</p>
<p>Change to P4, and move to Open.</p>


<p id="res-2512"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2513"><a href="2513">2513</a>. Missing requirements for <code>basic_string::value_type</code></h3>
<p><b>Section:</b> 27.1 <a href="https://timsong-cpp.github.io/cppwp/strings.general">[strings.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-06-26 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#strings.general">issues</a> in [strings.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The allocator-aware container requirements in Table 98 impose no
<code>MoveAssignable</code> requirements on the <code>value_type</code> when
<code>propagate_on_container_move_assignment</code> is true, because typically the
container's storage would be moved by just exchanging some pointers.
<p/>
However for a <code>basic_string</code> using the small string optimization move
assignment may need to assign individual characters into the small
string buffer, even when the allocator propagates.
<p/>
The only requirement on the char-like objects stored in a <code>basic_string</code>
are that they are non-array POD types and <code>Destructible</code>, which means
that a POD type with a deleted move assignment operator should be
usable in a <code>basic_string</code>, despite it being impossible to move assign:
</p>
<blockquote><pre>
#include &lt;string&gt;

struct odd_pod 
{
  odd_pod() = default;
  odd_pod&amp; operator=(odd_pod&amp;&amp;) = delete;
};

static_assert(std::is_pod&lt;odd_pod&gt;::value, "POD");

int main()
{
  using S = std::basic_string&lt;odd_pod&gt;;
  S s;
  s = S{};       // fails
}
</pre></blockquote>
<p>
Using libstdc++ <code>basic_string&lt;odd_pod&gt;</code> cannot even be
default-constructed because the constructor attempts to assign the
null terminator to the first element of the small string buffer.
<p/>
Similar problems exist with POD types with a deleted default constructor.
<p/>
I believe that <code>basic_string</code> should require its <code>value_type</code> to be at
least <code>DefaultConstructible</code> and <code>MoveAssignable</code>.
</p>

<p><i>[2016-06, Oulu]</i></p>

<p>This should be resolved by <a href="https://wg21.link/P0178">P0178</a></p>
<p>Note: P0178 was sent back to LEWG in Oulu.</p>


<p id="res-2513"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2528"><a href="2528">2528</a>. Order of <code>std::tuple</code> construction unspecified</h3>
<p><b>Section:</b> 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Rodriguez <b>Opened:</b> 2015-08-25 <b>Last modified:</b> 2017-02-19</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>std::tuple</code> order of element construction is unspecified. It is either in the same order of the type list or in reverse. 
<p/>
Consider the following program:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct X 
{
  X(int) { std::cout &lt;&lt; "X constructor\n"; }
};

struct Y 
{
  Y(int) { std::cout &lt;&lt; "Y constructor\n"; }
};

int main()
{
  std::tuple&lt;X, Y&gt; t(1, 2);
}
</pre></blockquote>
<p>
Here is a <a href="http://coliru.stacked-crooked.com/a/764d0477523ba249">link</a> to two sample compilations. The first uses 
libstdc++ and constructs in reverse order, and the second uses libc++ and constructs in in-order. 
<p/>
A <code>std::tuple</code> mimics both a struct and type-generic container and should thus follow their standards. Construction is 
fundamentally different from a function call, and it has been historically important for a specific order to be guaranteed; 
namely: whichever the developer may decide. Mandating construction order will allow developers to reference younger elements 
later on in the chain as well, much like a struct allows you to do with its members.
<p/>
There are implementation issues as well. Reversed lists will require unnecessary overhead for braced-initializer-list initialization.  
Since lists are evaluated from left to right, the initializers must be placed onto the stack to respect the construction order. 
This issue could be significant for large tuples, deeply nested tuples, or tuples with elements that require 
many constructor arguments.
<p/>
I propose that the <code>std::tuple&lt;A, B, ..., Y, Z&gt;</code>'s constructor implementation be standardized, and made to construct 
in the same order as its type list e.g. <code>A{}, B{}, ..., Y{}, Z{}</code>.
</p>

<p>
<b>Daniel:</b>
<p/>
When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">N3140</a> became accepted, wording had been
added that gives at least an indication of requiring element initialization in the order of the declaration of the template
parameters. This argumentation can be based on 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> p3 (emphasize mine):
</p>
<blockquote><p>
-3- In the constructor descriptions that follow, let <code><i>i</i></code> be in the range <code>[0,sizeof...(Types))</code> 
<span style="color:#C80000;font-weight:bold">in order</span>, 
<code><i>Ti</i></code> be the <code><i>i<sup>th</sup></i></code> type in <code>Types</code>, and <code><i>Ui</i></code> be the 
<code><i>i<sup>th</sup></i></code> type in a template parameter pack named <code>UTypes</code>, where indexing is
zero-based.
</p></blockquote>
<p>
But the current wording needs to be improved to make that intention clearer and an issue like this one is necessary to be sure that
the committee is agreeing (or disagreeing) with that intention, especially because N3140 didn't really point out the relevance of the element
construction order in the discussion, and because not all constructors explicitly refer to the ordered sequence of numbers generated
by the variable <code><i>i</i></code> (The move constructor does it right, but most other don't do that). 
</p>

<p><i>[2017-02-12, Alisdair comments]</i></p>

<p>
Note that this issue should not be extended to cover the assignment operators,
as implementations may want the freedom to re-order member-wise assignment
so that, for example, all potentially-throwing assignments are performed before
non-throwing assignments (as indicated by the <code>noexcept</code> operator).
</p>


<p id="res-2528"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2530"><a href="2530">2530</a>. Clarify observable side effects of releasing a shared state</h3>
<p><b>Section:</b> 32.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-08-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When a shared-state is released, it may be necessary to execute user defined code for the destructor of a 
stored value or exception. It is unclear whether the execution of said destructor constitutes an observable side effect.
</p>
<p>
While discussing N4445 in Lenexa, Nat Goodspeed pointed out that 32.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a>/5.1 does not explicitly 
mention the destruction of the result, so implementations should be allowed to release (or reuse) a shared state ahead 
of time under the "as-if" rule.
<p/>
The standard should clarify whether the execution of destructors is a visible side effect of releasing a shared state.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>This is related to <a href="2532" title="Satisfying a promise at thread exit (Status: Open)">2532</a></p>
<p>Fri AM: Moved to Open</p>


<p id="res-2530"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2532"><a href="2532">2532</a>. Satisfying a <code>promise</code> at thread exit</h3>
<p><b>Section:</b> 32.10.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-08-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>promise::set_value_at_thread_exit</code> and <code>promise::set_exception_at_thread_exit</code> operate on a shared state 
at thread exit, without making the thread participate in the ownership of such shared state.
<p/>
Consider the following snippet:
</p>
<blockquote><pre>
std::promise&lt;int&gt;{}.set_value_at_thread_exit(42);
</pre></blockquote>
<p>
Arguably, since the <code>promise</code> abandons its shared state without actually making it ready, a <code>broken_promise</code> 
error condition should be stored in the shared state. Implementations diverge, they either crash at thread exit by 
dereferencing an invalid pointer, or keep the shared state around until thread exit.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>This is related to <a href="2530" title="Clarify observable side effects of releasing a shared state (Status: Open)">2530</a></p>
<p><i>[2016-08-03, Billy O'Neal suggests concrete wording]</i></p>

<p>Fri AM: Moved to Open</p>


<p id="res-2532"><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 32.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a> p7 as indicated:</p>

<blockquote>
<p>
-7- When an asynchronous provider is said to abandon its shared state, it means:
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; first, if that state is not ready <ins>or scheduled to be made ready at thread exit</ins>, the provider</p>
<ol style="list-style-type: none">
<li><p>(7.1.1) &mdash; stores an exception object of type <code>future_error</code> with an error condition of 
<code>broken_promise</code> within its shared state; and then</p></li>
<li><p>(7.1.2) &mdash; makes its shared state ready;</p></li>
</ol>
</li>
</ol>
</blockquote>
</li>

<li><p>Change 32.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a> p10 as indicated:</p>

<blockquote>
<p>
-10- Some functions (e.g., <code>promise::set_value_at_thread_exit</code>) <del>delay making the shared state ready 
until</del><ins>schedule the shared state to be made ready when</ins> the
calling thread exits. <ins>This associates a reference to the shared state with the calling thread.</ins> The 
destruction of each of that thread's objects with thread storage duration 
(6.8.6.3 <a href="https://timsong-cpp.github.io/cppwp/basic.stc.thread">[basic.stc.thread]</a>) is sequenced before making that shared state ready. <ins>When the calling 
thread makes the shared state ready, if the thread holds the last reference to the shared state, the shared state 
is destroyed. [<i>Note:</i> This means that the shared state may not become ready until after the <em>asynchronous 
provider</em> has been destroyed. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2533"><a href="2533">2533</a>. [concurr.ts] Constrain threads where <code>future::then</code> can run a continuation</h3>
<p><b>Section:</b> 99 [concurr.ts::futures.unique.future] <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2021-06-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: concurr.ts</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4538.pdf">N4538</a>, the continuation given to
<code>future::then</code> can be run "on an unspecified thread of execution". This is too broad, as it allows the
continuation to be run on the main thread, a UI thread, or any other thread. In comparison, functions given to
<code>async</code> run "as if in a new thread of execution", while the Parallelism TS gives less guarantees by running
"in either the invoking thread or in a thread implicitly created by the library to support parallel algorithm execution".
The threads on which the continuation given to <code>future::then</code> can run should be similarly constrained.
</p>

<p><i>[2017-03-01, Kona, SG1]</i></p>

<p>
Agreement that this is a problem. Suggested addition to the issue is below. We have no immediate delivery vehicle
for a fix at the moment, but we would like to make the intended direction clear.
<p/>
There is SG1 consensus that <code>.then</code> continuations should, by default, and in the absence of executors, be run
only in the following ways:
</p>
<ol>
<li><p>If the future is not ready when <code>.then()</code> is called, the <code>.then</code> argument may be run on the execution
agent that fulfills the promise.</p></li>
<li><p>In all cases, the <code>.then</code> argument may be run on an implementation-provided thread, i.e. a thread that is
neither the main thread nor explicitly created by the user.</p></li>
</ol>
<p>
In the absence of an executor argument (which currently cannot be supplied), running of the <code>.then()</code> continuation
will not block the thread calling <code>.then()</code>, even if the future is ready at the time.
<p/>
Straw polls:
<p/>
SF | F | N | A | SA
<p/>
For the default behaviour:
<p/>
"1. Run on completed task or new execution agent"
<p/>
0 | 7 | 5 | 1 | 0
<p/>
"2. Run on completed task or <code>.then</code> caller"
<p/>
0 | 0 | 5 | 5 | 3
<p/>
"3. Leave as implementation defined"
<p/>
1 | 2 | 4 | 3 | 3
<p/>
"4. Always new execution agent"
<p/>
2 | 3 | 6 | 2 | 0
<p/>
The actual conclusion was to allow either (1) or (4) for now, since they are quite close, but present a very different
programming mode from (2).
</p>


<p id="res-2533"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2546"><a href="2546">2546</a>. Implementability of locale-sensitive <em>UnicodeEscapeSequence</em> matching</h3>
<p><b>Section:</b> 28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-10-08 <b>Last modified:</b> 2024-10-03</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> paragraph 2:
</p>
<blockquote><p>
<code>basic_regex</code> member functions shall not call any locale dependent C or C++ API, including the formatted
string input functions. Instead they shall call the appropriate traits member function to achieve the required effect.
</p></blockquote>
<p>
Yet, the required interface for a regular expression traits class (28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a>) does not appear to have
any reliable method for determining whether a character as encoded for the locale associated with the traits
instance is the same as a character represented by a <em>UnicodeEscapeSequence</em>, e.g., assuming a sane
<code>ru_RU.koi8r</code> locale:
</p>
<blockquote><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;regex&gt;

const char data[] = "\xB3";
const char matchCyrillicCaptialLetterYo[] = R"(\u0401)";

int main(void)
{
  try {
    std::regex myRegex;
    myRegex.imbue(std::locale("ru_RU.koi8r"));

    myRegex.assign(matchCyrillicCaptialLetterYo, std::regex_constants::ECMAScript);
    printf("(%s)\n", std::regex_replace(std::string(data), myRegex, std::string("E")).c_str());

    myRegex.assign("[[:alpha:]]", std::regex_constants::ECMAScript);
    printf("(%s)\n", std::regex_replace(std::string(data), myRegex, std::string("E")).c_str());
  } catch (std::regex_error&amp; e) {
    abort();
  }
  return 0;
}
</pre></blockquote>
<p>
The implementation I tried prints:
</p>
<blockquote><pre>
(&#x401;)
(E)
</pre></blockquote>
<p>
Which means that the character class matching worked, but not the matching to the <em>UnicodeEscapeSequence</em>.
</p>

<p><i>[2024-10-03; Jonathan comments]</i></p>

<p>
<code>std::basic_regex&lt;charT&gt;</code> only properly supports
matching single code units that fit in <code class='backtick'>charT</code>.
There's nothing in the spec that supports matching code points that
require multiple code units, let alone checking whether a character
in an arbitrary encoding corresponds to any given Unicode code point.
28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> paragraph 12 appears to be an attempt to
allow implementations to fail to match here, but is insufficient.
When <code>is_unsigned_v&lt;char&gt;</code> is true, the CV of the
<i>UnicodeEscapeSequence</i> <code class='backtick'>"\u0080"</code> is not greater than <code class='backtick'>CHAR_MAX</code>,
but that doesn't help because U+0080 is encoded as two bytes in UTF-8.
Being able to represent <code class='backtick'>0x80</code> as <code class='backtick'>char</code> does not mean the CV can be
matched as a single <code class='backtick'>char</code>.
The API is unsuitable for Unicode-aware strings.
</p>



<p id="res-2546"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2547"><a href="2547">2547</a>. Container requirements (and other library text) should say "strict total order", not just "total order"</h3>
<p><b>Section:</b> 22.10.8 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>, 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, 32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2015-10-08 <b>Last modified:</b> 2015-10-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of places in the library, including 22.10.8 <a href="https://timsong-cpp.github.io/cppwp/comparisons">[comparisons]</a>/14, the Optional container requirements in 
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, and 32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a>/8, use the phrase "total order". 
Unfortunately, that phrase is ambiguous. In mathematics, the most common definition is that a relation <code>&le;</code> is 
a total order if it's total, transitive, and antisymmetric in the sense that <code>x&le;y &#x2227; y&le;x &rArr; x=y</code>. 
What we really want is a strict total order: a relation <code>&lt;</code> is a strict total order if it's total, transitive, and 
antisymmetric in the sense that exactly one of <code>x&lt;y</code>, <code>y&lt;x</code>, and <code>x=y</code> holds.
</p>
<p>
The non-normative note in 26.8 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a>/4 correctly uses the phrase "strict total ordering" rather than 
simply "total ordering".
</p>
<p>
We could address this issue by replacing "total order" with "strict total order" everywhere it appears, since I 
think there are no cases where we actually want a non-strict total order, or we could add something in Clause 17 saying 
that we always mean strict total order whenever we say total order.
</p>


<p id="res-2547"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2592"><a href="2592">2592</a>. Require that <code>chrono::duration_cast</code>s from smaller durations to larger durations do not overflow</h3>
<p><b>Section:</b> 30.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Andy Giese <b>Opened:</b> 2016-02-05 <b>Last modified:</b> 2016-05-08</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.syn">issues</a> in [time.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently 30.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a> states
</p>
<blockquote><pre>
<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least 45 bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least 35 bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least 29 bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least 23 bits</i>, ratio&lt;3600&gt;&gt; hours;
</pre></blockquote>
<p>
However, a <code>duration_cast&lt;minutes&gt;(seconds::max())</code> would cause overflow if the underlying signed integers 
only met the minimums specified.
<p/>
The standard should specify that implementations guarantee that a <code>duration_cast</code> from any smaller duration in 
these "convenience typedefs" will not overflow any larger duration. That is, <code>hours</code> should be able to hold 
the maximum of <code>minutes</code>, which should be able to hold the maximum of <code>seconds</code> and so on.
<p/>
More formally, if the ratio <code>typedef A</code> and <code>typedef B</code> is <code>1:Y</code> where <code>Y &gt; 1</code> (e.g., 
1 : 60 in case of <code>minutes</code> : <code>seconds</code>), then <code>#bits<sub>A</sub>-1</code> must be at least 
<code>ceil(log<sub>2</sub>(2<sup>#bits<sub>B</sub>-1)/Y)</sup>)</code>.
<p/>
In the case of <code>minutes</code> : <code>seconds</code>, <code>X = 1</code>, <code>Y = 60</code>. Let 
<code>#bits<sub>seconds</sub> = 32</code>. Therefore:
</p>
<ul>
<li><p><code>2<sup>(#bits<sub>seconds</sub> - 1)</sup> = 2<sup>31</sup> = 2147483648</code></p></li>
<li><p><code>ceil(log<sub>2</sub>(2<sup>31</sup> / 60) = 26</code></p></li>
<li><p><code>#bits<sub>minutes</sub> - 1 = 26</code></p></li>
<li><p><code>#bits<sub>minutes</sub> = 27</code></p></li>
</ul>
<p>
Therefore, a minimum of 27 bits would be needed to store <code>minutes</code> if 32 were used to store <code>seconds</code>.
<p/>
I propose to change the definitions of the convenience typedefs as follows:
</p>
<blockquote><pre>
<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least 46 bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least 37 bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least 32 bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least 27 bits</i>, ratio&lt;3600&gt;&gt; hours;
</pre></blockquote>
<p>
These bits were chosen to satisfy the above formula. Note that
minimums only increased, so larger ranges could be held. A nice
outcome of this choice is that <code>minutes</code> does not go above 32 bits.
</p>

<p><i>[2016-04-23, Tim Song comments]</i></p>

<p>
The P/R of LWG 2592 doesn't fix the issue it wants to solve, because the actual underlying type will likely 
have more bits than the specified minimum.
<p/>
Consider <code>seconds</code>, which the P/R requires to have at least 37 bits. On a typical system this implies 
using a 64-bit integer. To ensure that casting from <code>seconds::max()</code> to <code>minutes</code> doesn't overflow 
in such a system, it is necessary for the latter to have at least 59 bits (which means, in practice, 64 bits too), 
not just 32 bits. Thus, just changing the minimum number of bits will not be able to provide the desired guarantee 
that casting from a smaller unit to a larger one never overflow.
<p/>
If such a guarantee is to be provided, it needs to be spelled out directly. Note that the difference here is 9 bits 
(for the 1000-fold case) and 5 bits (for the 60-fold case), which is less than the size difference between integer 
types on common systems, so such a requirement would effectively require those convenience typedefs to use the 
same underlying integer type.
</p>


<p id="res-2592"><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 30.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>, header <code>&lt;chrono&gt;</code> synopsis, as indicated</p>

<blockquote><pre>
[&hellip;]

<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least <ins>46</ins><del>45</del> bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least <ins>37</ins><del>35</del> bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least <ins>32</ins><del>29</del> bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least <ins>27</ins><del>23</del> bits</i>, ratio&lt;3600&gt;&gt; hours;

[&hellip;]
</pre></blockquote>

</li>
</ol>





<hr>
<h3 id="2594"><a href="2594">2594</a>. Contradicting definition of empty <code>shared_ptr</code> on <code>shared_ptr(nullptr, d)</code></h3>
<p><b>Section:</b> 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-02-20 <b>Last modified:</b> 2016-06-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Latest draft (N4567) 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> p1 says:
</p>
<blockquote>
<p>
A <code>shared_ptr</code> object is <em>empty</em> if it does not own a pointer.
</p>
</blockquote>
<p>
Please note that it says "own a pointer". This definition was added as
the resolution for LWG defect <a href="813" title="&quot;empty&quot; undefined for shared_ptr (Status: CD1)">813</a>.
<p/>
20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> p8 says about the effect of
<code>shared_ptr(nullptr_t p, D d)</code>:
</p>
<blockquote>
<p>
<i>Effects</i>: Constructs a <code>shared_ptr</code> object that <em>owns</em> the object <code>p</code> and the deleter <code>d</code>.
</p>
</blockquote>
<p>
Please note that it says "<em>owns</em> the object". This was intentionally
changed from "the pointer" as a part of resolution for LWG defect <a href="758" title="shared_ptr and nullptr (Status: C++11)">758</a>,
to cover <code>nullptr_t</code> case.
<p/>
Since <code>shared_ptr(nullptr, d)</code> owns an object of type <code>nullptr_t</code>, but does
not own a pointer, it is said as "empty" by a strict reading of the
above mentioned definition in 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> p1.
<p/>
These cause a contradiction:
<p/>
20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> p9 sets a postcondition
<code>use_count() == 1</code> on <code>shared_ptr(nullptr, d)</code>. But 
20.3.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a> p7 says that the return value of <code>use_count()</code>
is "<code>0</code> when <code>*this</code> is <em>empty</em>".
</p>
<p>
Proposed wording changes:
<p/>
Replace the last 2 words in 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> p1 from
</p>
<blockquote><p>
[&hellip;] <em>empty</em> if it does not own a pointer.
</p></blockquote>
<p>
to
</p>
<blockquote><p>
[&hellip;] <em>empty</em> if it does not own an object.
</p></blockquote>
<p>
Note that <code>shared_ptr(nullptr_t)</code> is defined to be empty in synopsis in
20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>.
</p>
<blockquote><pre>
constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
</pre></blockquote>
<p>
It could be less confusing if <code>shared_ptr(nullptr, d)</code> could be defined to
be empty. But it seems too late to change that (which means changing
whether the deleter is called or not, see 
<a href="https://stackoverflow.com/questions/11164354/">this Stackoverflow article</a>). 
Then I'm proposing just fix the contradiction.
</p>



<p id="res-2594"><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4594.
</p>

<ol>
<li><p>Change 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a> p1 as indicated:</p>

<blockquote>
<p>-1- The <code>shared_ptr</code> class template stores a pointer, usually obtained via <code>new</code>. <code>shared_ptr</code> 
implements semantics of shared ownership; the last remaining owner of the pointer is responsible for destroying the 
object, or otherwise releasing the resources associated with the stored pointer. A <code>shared_ptr</code> object is 
<em>empty</em> if it does not own <ins>an object</ins><del>a pointer</del>.
</p>
</blockquote>

</li>
</ol>






<hr>
<h3 id="2595"><a href="2595">2595</a>. <code>reverse_iterator::operator[]</code>'s return type revisited</h3>
<p><b>Section:</b> 24.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a>, 24.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2016-02-28 <b>Last modified:</b> 2021-06-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterator">issues</a> in [reverse.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="386" title="Reverse iterator's operator[] has impossible return type (Status: CD1)">386</a> changed the return type of <code>reverse_iterator::operator[]</code> to unspecified. However,
as of N3066, the return type of a random access iterator's <code>operator[]</code> shall be convertible to <code>reference</code>;
thus the return type of <code>reverse_iterator::operator[]</code> should be <code>reference</code> (and it is in all common
implementations).
<p/>
Suggested resolution: Adjust 24.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a>'s synopsis and 24.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> to
use <code>reference</code> instead of <code><i>unspecified</i></code>.
</p>

<p><i>[2021-06-06 Tim syncs wording to current working draft]</i></p>



<p id="res-2595"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4885" title=" Working Draft, Standard for Programming Language C++">N4885</a>.
</p>

<ol>
<li><p>Edit 24.5.1.2 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterator">[reverse.iterator]</a>, class template <code></code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Iterator&gt;
  class reverse_iterator {
  public:
    [&hellip;]
    using reference         = iter_reference_t&lt;Iterator&gt;;
    [&hellip;]
    constexpr <ins>reference</ins><del><i>unspecified</i></del> operator[](difference_type n) const;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Change 24.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> before p3 as indicated:</p>

<blockquote>
<pre>
constexpr <ins>reference</ins><del><i>unspecified</i></del> operator[](difference_type n) const;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2599"><a href="2599">2599</a>. Library incomplete type permission phrase is unclear</h3>
<p><b>Section:</b> 22.2.6 <a href="https://timsong-cpp.github.io/cppwp/declval">[declval]</a>, 20.3.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr">[unique.ptr]</a>, 20.3.1.2.1 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.dltr.general">[unique.ptr.dltr.general]</a>, 20.3.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared">[util.smartptr.shared]</a>, 20.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.weak">[util.smartptr.weak]</a>, 20.3.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.enab">[util.smartptr.enab]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2016-03-08 <b>Last modified:</b> 2016-04-16</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#declval">active issues</a> in [declval].</p>
<p><b>View all other</b> <a href="lwg-index.html#declval">issues</a> in [declval].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the phrase to grant this permission is:
</p>
<blockquote><p>
The template parameter <code>T</code> of <code><i>LibraryTemplate</i></code> may be an incomplete type.
</p></blockquote>
<p>
Two problems:
</p>
<ol>
<li><p>The timing is unclear.  We always allow specializations like <code><i>LibraryTemplate</i>&lt;Incomp&gt;* p;</code></p></li>
<li><p>To the users of a template, the correct terminology should be "argument" rather than "parameter".</p></li>
</ol>
<p>
Suggested resolution:
</p>
<blockquote><p>
In an instantiation of <code><i>LibraryTemplate</i></code>, an incomplete type
may be used as the template argument for the template parameter <code>T</code>.
</p></blockquote>
<p>
as shown <a href="https://github.com/cplusplus/draft/pull/304/files">here</a>.
<p/>
Or, to copy <a href=" http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4510.html">N4510's wording</a>:
</p>
<blockquote><p>
An incomplete type <code>T</code> may be used when instantiating <code><i>LibraryTemplate</i></code>.
</p></blockquote>


<p id="res-2599"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2675"><a href="2675">2675</a>. <code>register_callback</code> can fail</h3>
<p><b>Section:</b> 31.5.2.7 <a href="https://timsong-cpp.github.io/cppwp/ios.base.callback">[ios.base.callback]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2019-06-15</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>register_callback</code> allocates memory and so it can fail, but the case is unspecified. libc++ sets
<code>badbit</code>, which is consistent with <code>iword</code> and <code>pword</code>. libstdc++ throws <code>std::bad_alloc</code>.
</p>

<p><i>[2019-06-13; Billy comments]</i></p>

<p>
Just as an additional data point: MSVC++ agrees with libstdc++ and also throws <code>std::bad_alloc</code>.
</p>


<p id="res-2675"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2691"><a href="2691">2691</a>. <code>money_base::space</code> and <code>do_put</code>: U+0020 versus <code>fill</code></h3>
<p><b>Section:</b> 28.3.4.7.4 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct">[locale.moneypunct]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-12 <b>Last modified:</b> 2016-05-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.moneypunct">issues</a> in [locale.moneypunct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The description of <code>money_base::space</code> is that "at least one space is required at that position." 
(N4582 subclause 22.4.6.3 [locale.moneypunct] paragraph 2)
<p/>
When formatting for output (28.3.4.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/locale.money.put.virtuals">[locale.money.put.virtuals]</a>), it is not clear that
</p>
<ol style="list-style-type:lower-alpha">
<li><p>
"the number of characters generated for the specified format" (excluding fill padding) includes exactly 
one character for <code>money_base::space</code> (if present), and
</p></li>
<li><p>
all characters corresponding to <code>money_base::space</code> (excluding fill padding) are copies of <code>fill</code>.
</p></li>
</ol>
<p>
In particular, there is implementation divergence over point (b) as to whether U+0020 or <code>fill</code> should be used.
Further, should a character other than <code>fill</code> be used, it is unclear when "the fill characters are 
placed where <code>none</code> or <code>space</code> appears in the formatting pattern", whether the fill characters are placed 
at the beginning or the end of the "space field".
<p/>
I believe that a strict interpretation of the current wording supports U+0020; however, <code>fill</code> is more likely 
to be the pragmatic choice.
</p>


<p id="res-2691"><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Change 28.3.4.7.4 <a href="https://timsong-cpp.github.io/cppwp/locale.moneypunct">[locale.moneypunct]</a> paragraph 2 as indicated:</p>

<blockquote>
<p>
-2- Where <code>none</code> or <code>space</code> appears, white space is permitted in the format, except where <code>none</code> 
appears at the end, in which case no white space is permitted. <ins>For input, the value <code>space</code> indicates that 
at least one space is required at that position. For output, the value <code>space</code> indicates one instance of the 
fill character (28.3.4.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/locale.money.put.virtuals">[locale.money.put.virtuals]</a>).</ins><del>The value <code>space</code> indicates that at least one 
space is required at that position</del>. Where <code>symbol</code> appears, the sequence of characters returned by 
<code>curr_symbol()</code> is permitted, and can be required. Where <code>sign</code> appears, the first (if any) of the 
sequence of characters returned by <code>positive_sign()</code> or <code>negative_sign()</code> (respectively as the monetary 
value is non-negative or negative) is required. Any remaining characters of the sign sequence are required after all 
other format components. Where <code>value</code> appears, the absolute numeric monetary value is required.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2695"><a href="2695">2695</a>. "As if" unclear in [member.functions]</h3>
<p><b>Section:</b> 16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-15 <b>Last modified:</b> 2017-02-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#member.functions">active issues</a> in [member.functions].</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in [member.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4582 subclause 17.6.5.5 [member.functions], the requirement that:
</p>
<blockquote><p>
any call to the member function that would select an overload from the set of declarations described in this 
standard behaves as if that overload were selected
</p></blockquote>
<p>
is unclear in the extent of the "as if". For example, in providing:
</p>
<blockquote><pre>
basic_string(const charT* s);
</pre></blockquote>
<p>
for a one-argument call to:
</p>
<blockquote><pre>
basic_string(const charT* s, const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
it can be read that an implementation may be required to call the copy constructor for the allocator since 
the core language rules for copy elision would not allow the "a" argument to be constructed directly into 
the member used to store the allocator.
<p/>
Clarification (even if just a note) would be appreciated.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
This is related to issue <a href="2563" title="LWG 2259 relaxes requirements, perhaps unintentionally (Status: NAD)">2563</a>.
</p>


<p id="res-2695"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2702"><a href="2702">2702</a>. <code>num_put::do_put(..., bool)</code> performs ill-formed <code>do_put</code> call</h3>
<p><b>Section:</b> 28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-07 <b>Last modified:</b> 2016-05-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The call to <code>do_put(out, str, fill, (int)val)</code> in N4582 subclause 28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> 
paragraph 6 cannot select a best viable function in overload resolution given the overloads listed for 
<code>do_put</code> in 28.3.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/locale.nm.put">[locale.nm.put]</a>.
<p/>
There is implementation divergence:
</p>
<ul>
<li><p>Some implementations call the <code>long</code> overload (as overriden);</p></li>
<li><p>some implementations call the <code>unsigned long</code> overload (as overriden);</p></li>
<li><p>some implementations call something else.</p></li>
</ul>
<p>
It appears that the resolution to DR <a href="359" title="num_put&lt;&gt;::do_put (..., bool) undocumented (Status: CD1)">359</a> attempted a fix; however, the relevant portion of the 
change was not applied to the WP.
</p>


<p id="res-2702"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2703"><a href="2703">2703</a>. No provision for fill-padding when <code>boolalpha</code> is set</h3>
<p><b>Section:</b> 28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-07 <b>Last modified:</b> 2018-02-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4582 subclause 28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> paragraph 6 makes no provision for fill-padding in its 
specification of the behaviour when <code>(str.flags() &amp; ios_base::boolalpha) != 0</code>.
</p>

<p><i>[2017-07-06, Marshall comments]</i></p>

<p>
All the other cases from <code>num_put</code> &mdash; <code>int</code>, <code>long</code>, etc all are covered in 
28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> p1 .. p5, which describe how to align and pad the output. (Specifically, 
stage 3) p6 does not.
<p/>
With this description:
</p>
<blockquote><pre>
cout &lt;&lt; std::setw(15) &lt;&lt; false;
</pre></blockquote>
<p>
outputs:
</p>
<pre>
&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;&#x2001;0
&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;&#xFE4E;// Column counter
</pre>
<p>
but
</p>
<blockquote><pre>
cout &lt;&lt; std::setw(15) &lt;&lt; boolalpha &lt;&lt; false;
</pre></blockquote>
<p>
outputs:
</p>
<pre>
false
</pre>
<p>
libc++ implements this exactly.<br/>
Dinkumware, libstdc++ and MSVC apply padding and alignment.
<p/>
I think that applying padding and alignment is more appropriate.
</p>


<p id="res-2703"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2705"><a href="2705">2705</a>. Questionable precondition on Sequence containers <code>a.assign(n, t)</code></h3>
<p><b>Section:</b> 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-05-08 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Please look through the following modifications on a value <code>v</code> of type <code>vector&lt;T&gt;</code>:
</p>
<blockquote><pre>
assert(v.size() &gt; 0);
v.push_back(v[0]);
v.insert(v.begin(), v[0]);
v.resize(v.size() * 2, v[0]);
v.assign(v.size() * 2, v[0]);
</pre></blockquote>
<p>
All of these use an element of itself which may be moved or destroyed by
the modification.
<p/>
From what I see so far, the first three are required to work. Please
see library issue <a href="526" title="Is it undefined if a function in the standard changes in parameters? (Status: NAD)">526</a> for validity of them.
<p/>
But only the last one is undefined because it violates a precondition of
a sequence container operation. I think this is too subtle.
<p/>
Should it be like that, really?
<p/>
The precondition is in Table 107 "Sequence container requirements" at the next 
of 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> p3.
</p>
<blockquote>
<p>
In Tables 107 and 108, <code>X</code> denotes a sequence container class,
<code>a</code> denotes a value of <code>X</code> containing elements of type <code>T</code>,
[&hellip;] <code>n</code> denotes a value of <code>X::size_type</code>,
[&hellip;] <code>t</code> denotes an lvalue or a <code>const</code> rvalue of <code>X::value_type</code>,
[&hellip;]
</p>
<p>[&hellip;]</p>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a.assign(n, t)</code>
</td>
<td><code>void</code></td>
<td>
<i>Requires</i>: <code>T</code> shall be <code>CopyInsertable</code> into <code>X</code> and <code>CopyAssignable</code>.<br/>
pre: <code>t</code> is not a reference into <code>a</code>.<br/>
Replaces elements in <code>a</code> with <code>n</code> copies of <code>t</code>.
</td>
</tr>
</table>
</blockquote>
<p>
I looked into the following implementations:
</p>
<ul>
<li><p>
libc++ relies on the precondition.
<p/>
It deallocates first on <code>n &gt; capacity()</code> case,
see <a href="https://github.com/llvm-mirror/libcxx/blob/release_38/include/vector#L1415">here</a>.
</p></li>
<li><p>
libstdc++ doesn't rely on the precondition.
<p/>
It creates temporary <code>vector(n, t)</code> and <code>swap()</code>
on <code>n &gt; capacity()</code> case, see
<a href="https://github.com/gcc-mirror/gcc/blob/gcc_5_3_0_release/libstdc%2B%2B-v3/include/bits/vector.tcc#L223">here</a>.
</p></li>
<li><p>
MSVC relies on the precondition.
<p/>
It unconditionally does <code>clear()</code> and then <code>insert(begin(), n, t)</code>.
I looked into my local "<code>%PROGRAMFILES(X86)%/Microsoft Visual Studio 14.0/VC/include/vector</code>".
</p></li>
</ul>
<p>
One drawback of libstdc++ implementation, I could find so far, is
possibly increased peek memory usage (both old and new buffer exist at
the same time). But, because the same can happen on the most other
modifications, it seems a reasonable trade-off to remove the
precondition to fill the subtle gap. Users who really needs less memory
usage can do <code>clear()</code> and <code>insert()</code> by themselves.
<p/>
I also found that <code>basic_string::assign(n, c)</code> is safe on this point.
At 27.4.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> p17:
</p>
<blockquote>
<pre>
basic_string&amp; assign(size_type n, charT c);
</pre>
<blockquote>
<p>
<i>Effects</i>: Equivalent to <code>assign(basic_string(n, c))</code>.
<p/>
<i>Returns</i>: <code>*this</code>.
</p>
</blockquote>
</blockquote>
<p>
This can be seen as another gap.
<p/>
Looking back on the history, I found that the definition of <code>assign(n, t)</code>
was changed at C++14 for library issue <a href="2209" title="assign() overspecified for sequence containers (Status: C++14)">2209</a>. There were more restricting 
definitions like this:
</p>
<blockquote>
<pre>
void assign(size_type n, const T&amp; t);
</pre>
<blockquote>
<p>
<i>Effects</i>:
</p>
<blockquote><pre>
erase(begin(), end());
insert(begin(), n, t);
</pre></blockquote>
</blockquote>
</blockquote>
<p>
I think the precondition was probably set to accept this old definition
and is not required inherently. And if the less memory usage was really
intended, the standard is now underspecifying about that.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
Howard believes this should be NAD, but we tabled the discussion.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4582">N4582</a>.
</p>

<ol>
<li><p>In 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, edit Table 107 (Sequence container requirements) as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a.assign(n, t)</code>
</td>
<td><code>void</code></td>
<td>
<i>Requires</i>: <code>T</code> shall be <code>CopyInsertable</code> into <code>X</code> and <code>CopyAssignable</code>.<br/>
<del>pre: <code>t</code> is not a reference into <code>a</code>.</del><br/> 
Replaces elements in <code>a</code> with <code>n</code> copies of <code>t</code>.
</td>
</tr>
</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-04-25, Daniel syncs current wording with recent working draft]</i></p>



<p id="res-2705"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>In 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, edit Table [tab:container.seq.req] (Sequence container requirements) as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 77 &mdash; Sequence container requirements (in addition to container) [tab:container.seq.req]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>a.assign(n, t)</code>
</td>
<td><code>void</code></td>
<td>
<i>Preconditions</i>: <code>T</code> is <i>Cpp17CopyInsertable</i> into <code>X</code><br/> 
and <i>Cpp17CopyAssignable</i>. <del><code>t</code> is not a reference into <code>a</code>.</del><br/>
<i>Effects:</i> Replaces elements in <code>a</code> with <code>n</code> copies of <code>t</code>.<br/>
Invalidates all references, pointers and iterators referring to the elements of <code>a</code>.<br/> 
For <code>vector</code> and <code>deque</code>, also invalidates the past-the-end iterator.
</td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2708"><a href="2708">2708</a>. <code>recursive_directory_iterator::recursion_pending()</code> is incorrectly specified</h3>
<p><b>Section:</b> 31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-05-09 <b>Last modified:</b> 2022-12-18</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.rec.dir.itr.members">issues</a> in [fs.rec.dir.itr.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <code>recursion_pending()</code> says (31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a>/24):
</p>
<blockquote><p>
<i>Returns</i>: <code>true</code> if <code>disable_recursion_pending()</code> has not been called subsequent to the prior construction
or increment operation, otherwise <code>false</code>.
</p></blockquote>
<p>
This language does not take into account cases where the prior construction was a copy construction from a iterator,
<code>it</code>, where <code>it.recursion_pending() == false</code>.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Open</p>

<p><i>[2018-1-26 issues processing telecon]</i></p>

<p>Status to 'Tentatively Ready'; Casey will explore whether making <code>recursion_pending</code> an exposition-only member makes this clearer.</p>

<strong>Previous resolution from Eric [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> as indicated:</p>

<blockquote>
<pre>
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Postcondition</i>: <del><code>options() == options</code> for the signatures with a <code>directory_options</code> argument,
otherwise <code>options() == directory_options::none</code>.</del>
</p>
<ul>
<li><p><ins><code>options() == options</code> for the signatures with a <code>directory_options</code> argument, otherwise
<code>options() == directory_options::none</code>.</ins></p></li>
<li><p><ins><code>recursion_pending() == true</code>.</ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The following changes the specification of <code>recursion_pending()</code> seemingly recursive.
Perhaps it would be easier to specify <code>recursion_pending()</code> in terms of a exposition only member in
<code>recursive_directory_iterator</code>.]
</p>
</blockquote>
<pre>
bool recursion_pending() const;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-24- <i>Returns</i>: <del><code>true</code> if <code>disable_recursion_pending()</code> has not been called subsequent to the
prior construction or increment operation, otherwise <code>false</code></del><ins><code>false</code> if
<code>disable_recursion_pending()</code> has been called subsequent to the prior construction or increment operation,
otherwise the value of <code>recursion_pending()</code> set by that operation</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-27- <i>Effects</i>: As specified by Input iterators (24.2.3), except that: [&hellip;]
<p/>
<ins>-?- <i>Postcondition</i>: <code>recursion_pending() == true</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-01-29: Casey provides a PR with an exposition-only member]</i></p>

<p>Status to 'Review'.</p>
<strong>Previous resolution from Casey [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to N4713.
</p>

<ol>
<li><p>Change  [fs.rec.dir.itr] as indicated:</p>
<blockquote>
<pre>
    [&hellip;]

    // other members as required by 24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>, input iterators

  <ins>private:</ins>
    <ins>bool recurse_; // exposition-only</ins>
  };
}
</pre>
</blockquote>
</li>

<li><p>Change 31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> as indicated:</p>

<blockquote>
<pre>
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p><p>
-3- <i>Postconditions</i>: <del><code>options() == options</code> for the signatures with a <code>directory_options</code> argument,
otherwise <code>options() == directory_options::none</code>.</del>
</p>
<ul>
<li><p><ins><code>options() == options</code> for the signatures with a <code>directory_options</code> argument, otherwise
<code>options() == directory_options::none</code>.</ins></p></li>
<li><p><ins><code>recurse_ == true</code>.</ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>

<pre>
recursive_directory_iterator(const recursive_directory_iterator&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
</p><p>
-8- <i>Postconditions:</i>
</p><p>
[&hellip;]
</p><p>
(8.3) &mdash; <del><code>recursion_pending() == rhs.recursion_pending()</code></del><ins><code>recurse_ == rhs.recurse_</code></ins>
</p>
</blockquote>

<pre>
recursive_directory_iterator(recursive_directory_iterator&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p><p>
-10- <i>Postconditions:</i> <code>options()</code>, <code>depth()</code>, and
<del><code>recursion_pending()</code></del><ins><code>recurse_</code></ins> have the values that <code>rhs.options()</code>,
<code>rhs.depth()</code>, and <del><code>rhs.recursion_pending()</code></del><ins><code>rhs.recurse_</code></ins>, respectively,
had before the function call.
</p>
</blockquote>

<pre>
recursive_directory_iterator&amp; operator=(const recursive_directory_iterator&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
</p><p>
-12- <i>Postconditions:</i>
</p><p>
[&hellip;]
</p><p>
(12.3) &mdash; <del><code>recursion_pending() == rhs.recursion_pending()</code></del><ins><code>recurse_ == rhs.recurse_</code></ins>
</p><p>
[&hellip;]
</p>
</blockquote>

<pre>
recursive_directory_iterator&amp; operator=(recursive_directory_iterator&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
</p><p>
-15- <i>Postconditions:</i> <code>options()</code>, <code>depth()</code>, and
<del><code>recursion_pending()</code></del><ins><code>recurse_</code></ins> have the values that <code>rhs.options()</code>,
<code>rhs.depth()</code>, and <del><code>rhs.recursion_pending()</code></del><ins><code>rhs.recurse_</code></ins>, respectively,
had before the function call.
</p><p>
[&hellip;]
</p>
</blockquote>

<pre>
bool recursion_pending() const;
</pre>
<blockquote>
<p>
-21- <i>Returns</i>: <del><code>true</code> if <code>disable_recursion_pending()</code> has not been called subsequent to the
prior construction or increment operation, otherwise <code>false</code></del><ins>recurse_</ins>.
</p><p>
[&hellip;]
</p>
</blockquote>

<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-23- <i>Effects</i>: As specified for the prefix increment operation of Input iterators
( [iterators.input]), except that:
</p><p>
[&hellip;]
</p><p>
<ins>-?- <i>Postcondition</i>: <code>recurse_ == true</code>.</ins>
</p>
</blockquote>

<pre>
void disable_recursion_pending();
</pre>
<blockquote>
<p>
-28- <i>Postcondition<del>s</del>:</i> <code><del>recursion_pending()</del><ins>recurse_</ins> == false</code>.
</p><p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-05-23: Casey restores the intended design with an expansion of the original PR]</i></p>

<p>
The intended design is that all copies of a single <code>recursive_directory_iterator</code> share a
common block of state which includes the values returned by <code>options</code>, <code>depth</code>, and
<code>recursion_pending</code> - hence the mandate that those functions not be called on a
non-dereferenceable iterator in 31.12.12 <a href="https://timsong-cpp.github.io/cppwp/fs.class.rec.dir.itr">[fs.class.rec.dir.itr]</a> para 2. To allow an
implementation with such shared state, it's necessary to make changes to the value returned by
<code>recursion_pending()</code> visible to <em>all copies</em> of the same dereferenceable iterator.
</p><p>
Also:
</p>
<ul>
<li><p><code>pop</code> notionally calls <code>increment</code> repeatedly until the current directory is
exhausted, <code>pop</code> should affect the value of <code>recursion_pending</code> similarly to
<code>increment</code>.</p></li>
<li><p><code>options</code> is not valid for all constructor signatures described by
31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> para 2.</p></li>
<li><p>the copies and moves don't specify what they actually <i>do</i></p></li>
<li><p>it's not quite kosher for the copies and moves to have postconditions on the value of
expressions that have UB if the iterator copied/moved from is not dereferenceable.</p></li>
</ul>

<p><i>[2018-06, Rapperswil, Wednesday evening]</i></p>

<p>
JW: p21 currently can just say "unspecified"<br/>
BO: if we are OK with only remote implementations we can remove the unspecifiedness<br/>
BO: the problematic business is the "recursion pending" bit<br/>
JW: I want time to work on this
<p/>
Move to open and note that Jonathan is reviewing and making recommendations.
</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>General agreement that flag should be shared; Casey to reword.</p>

<p><i>[2022-12-18; Daniel comments]</i></p>

<p>
Note that this proposed wording has some overlap with LWG <a href="3668" title="[recursive_]directory_iterator constructors refer to undefined options (Status: New)">3668</a> for
<code>recursive_directory_iterator</code>'s constructors without <code>options</code> argument.
If we would like a different wording form for this textual location in one issue we
should resync the other issue to reduce the chance of a merge conflict.
</p>


<p id="res-2708"><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4750.
</p>

<ol>
<li><p>Change 31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> as indicated:</p>

<blockquote>
<pre>
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
<ins>-?- For the signatures with no parameter <code>options</code>, let <code>options</code> be
<code>directory_options::none</code>.</ins>
</p><p>
-2- <i>Effects</i>: [&hellip;]
</p><p>
-3- <i>Postconditions</i>: <del><code>options() == options</code> for the signatures with a
<code>directory_options</code> argument, otherwise <code>options() == directory_options::none</code>.</del>
</p>
<ul>
<li><p><ins><code>this->options() == options</code></ins></p></li>
<li><p><ins><code>recursion_pending() == true</code></ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator(const recursive_directory_iterator&amp; rhs);
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Constructs an <del>object of class <code>recursive_directory_iterator</code></del>
<ins>iterator that denotes the same directory entry as <code>rhs</code>, if any.</ins>.
</p><p>
-8- <i>Postconditions</i>: <ins>If <code>rhs</code> is dereferenceable,</ins>
</p><p>
[&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator(recursive_directory_iterator&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-9- <i>Effects</i>: Constructs an <del>object of class <code>recursive_directory_iterator</code></del>
<ins>iterator that denotes the directory entry denoted by <code>rhs</code> before the function call, if
any.</ins>.
</p><p>
-10- <i>Postconditions</i>: <ins>If <code>rhs</code> is dereferenceable,</ins>  [&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator&amp; operator=(const recursive_directory_iterator&amp; rhs);
</pre>
<blockquote>
<p>
-11- <i>Effects</i>: <del>If <code>*this</code> and <code>rhs</code> are the same object, the member has no
effect.</del> <ins>Causes <code>*this</code> to denote the same directory entry denoted by <code>rhs</code>,
if any.</ins>
</p><p>
-12- <i>Postconditions</i>: <ins>If <code>rhs</code> is dereferenceable,</ins>
</p><p>
[&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator&amp; operator=(recursive_directory_iterator&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-14- <i>Effects</i>: <del>If <code>*this</code> and <code>rhs</code> are the same object, the member has no
effect.</del> <ins>Causes <code>*this</code> to denote the directory entry denoted by <code>rhs</code>
before the function call, if any.</ins>
</p><p>
-15- <i>Postconditions</i>: <ins>If <code>rhs</code> was dereferenceable before the function call,</ins>
[&hellip;]
</p><p>
-16- <i>Returns</i>: <code>*this</code>.
</p><p>
<ins>-x- <i>Remarks</i>: If <code>*this</code> and <code>rhs</code> do not refer to the same object, the
resulting state of <code>rhs</code> is unspecified (16.4.6.17 <a href="https://timsong-cpp.github.io/cppwp/lib.types.movedfrom">[lib.types.movedfrom]</a>).</ins>
</p>
</blockquote>
<pre>
directory_options options() const;
</pre>
<blockquote>
<p>
-17- <i>Returns</i>: The value <del>of the argument passed to the constructor for the <code>options</code>
parameter, if present, otherwise <code>directory_options::none</code></del> <ins>established by the most
recently called member that has a postcondition for <code>options()</code></ins>.
</p><p>
[&hellip;]
</p>
</blockquote>
<pre>
bool recursion_pending() const;
</pre>
<blockquote>
<p>
-21- <i>Returns</i>: <del><code>true</code> if <code>disable_recursion_pending()</code> has not been called
subsequent to the prior construction or increment operation, otherwise <code>false</code>.</del> <ins>If
<code>disable_recursion_pending()</code> has been called on a copy of <code>*this</code>, an unspecified
value. Otherwise, the value established for <code>recursion_pending()</code> by the postcondition of the
most recent construction, assignment, increment, or <code>disable_recursion_pending</code> operation.</ins>
</p><p>
[&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec);
</pre>
<blockquote>
<p>
-23- <i>Effects</i>: As specified for the prefix increment operation of Input iterators
(24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>), except that: [&hellip;]
</p><p>
<ins>-?- <i>Postconditions</i>: If <code>*this</code> is dereferenceable,
<code>recursion_pending() == true</code>.</ins>
</p><p>
[&hellip;]
</p>
</blockquote>
<pre>
void pop();
void pop(error_code&amp; ec);
</pre>
<blockquote>
<p>
-26- <i>Effects</i>: If <code>depth() == 0</code>, set <code>*this</code> to
<code>recursive_directory_iterator()</code>. [&hellip;]
</p><p>
<ins>-?- <i>Postconditions</i>: If <code>*this</code> is dereferenceable,
<code>recursion_pending() == true</code>.</ins>
</p><p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2713"><a href="2713">2713</a>. More missing allocator-extended constructors for unordered containers</h3>
<p><b>Section:</b> 23.5 <a href="https://timsong-cpp.github.io/cppwp/unord">[unord]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-20 <b>Last modified:</b> 2022-07-16</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of LWG <a href="2210" title="Missing allocator-extended constructor for allocator-aware containers (Status: C++14)">2210</a> missed constructors accepting a range or initializer list and allocator.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Add to the synopsis in 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_map(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_map(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_multimap(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_multimap(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_set(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_set(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_multiset(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_multiset(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2016-06, Oulu &mdash; Daniel comments and provides new wording]</i></p>

<p>
During the LWG discussion of this issue it has been observed, that the interpretation of the embedded <i>see below</i>
is not really clear and that we should split declaration and definition of the new overloads, so that we have a place
that allows us to specify what "<i>see below</i>" stands for. In addition, the new wording wraps the "<i>see below</i>"
as "<code>size_type(<i>see below</i>)</code>" to clarify the provided expression type, similar as we did for the default
constructor of <code>unordered_map</code>.
</p>

<p><i>[Oulu, 2016-06]</i></p>

<p>Alisdair to review wording.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Add to the synopsis in 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_map(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_map(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multimap(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multimap(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_set(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_set(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multiset(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multiset(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2017-08-04, Daniel and Alisdair finetune wording]</i></p>

<p>
We decided to improve the added <i>Remarks:</i> elements by changing from the previous form:
</p>
<blockquote>
<p>
<i>Remarks:</i> The number of buckets is implementation-defined.
</p>
</blockquote>
<p>
to the more elaborate form:
</p>
<blockquote>
<p>
<i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.
</p>
</blockquote>

<p><i>[2020-11-29; Reflector discussions]</i></p>

<p>
It has been pointed out that this issue is related to LWG <a href="1199" title="Missing extended copy constructor in container adaptors (Status: C++11)">1199</a>, LWG <a href="2210" title="Missing allocator-extended constructor for allocator-aware containers (Status: C++14)">2210</a>, 
and LWG <a href="3506" title="Missing allocator-extended constructors for priority_queue (Status: C++23)">3506</a>. 
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This resolution is relative to <a href="https://wg21.link/n4687">N4687</a>.</p>

<ol>
<li><p>Add to the synopsis in 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_map(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_map(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multimap(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multimap(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_set(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_set(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multiset(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multiset(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2022-07-10; Daniel comments]</i></p>

<p>
It is has been noticed by Daniel Eiband on <a href="https://lists.isocpp.org/std-discussion/2022/07/1681.php">[std-discussion]</a>
that the following deduction guides for the following constructors of the set types 
<code>std::unordered_set</code> and <code>std::unordered_multiset</code> are missing:
</p>
<blockquote><pre>
unordered_set(InputIterator, InputIterator, Allocator);
unordered_set(initializer_list&lt;T&gt;, Allocator);

unordered_multiset(InputIterator, InputIterator, Allocator);
unordered_multiset(initializer_list&lt;T&gt;, Allocator);
</pre></blockquote>
<p>
Since this issue is adding these missing constructors it should also add the associated deduction guides.
The proposed wording has been updated to this effect and also rebased to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This resolution is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.</p>

<ol>
<li><p>Add to the synopsis in 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key, 
           class T,
           class Hash = hash&lt;Key&gt;,
           class Pred = equal_to&lt;Key&gt;,
           class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template&lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template&lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template&lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    [&hellip;]
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template&lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_map(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_map(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key, 
           class T,
           class Hash = hash&lt;Key&gt;,
           class Pred = equal_to&lt;Key&gt;,
           class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template&lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template&lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template&lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    [&hellip;]
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template&lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multimap(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multimap(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key,
           class Hash = hash&lt;Key&gt;,
           class Pred = equal_to&lt;Key&gt;,
           class Allocator = allocator&lt;Key&gt;&gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template&lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template&lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template&lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
  
  [&hellip;]
  template&lt;class T, class Allocator&gt;
    unordered_set(initializer_list&lt;T&gt;, typename <i>see below</i>::size_type, Allocator)
      -&gt; unordered_set&lt;T, hash&lt;T&gt;, equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_set(initializer_list&lt;T&gt;, typename <i>see below</i>::size_type, Hash, Allocator)
      -&gt; unordered_set&lt;T, Hash, equal_to&lt;T&gt;, Allocator&gt;;
      
  <ins>template&lt;class InputIterator, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_set&lt;<i>iter-value-type</i>&lt;InputIterator&gt;,
                       hash&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;,
                       equal_to&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;,                           
                       Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_set(initializer_list&lt;T&gt;, Allocator) 
      -&gt; unordered_set&lt;T, hash&lt;T&gt;, equal_to&lt;T&gt;, Allocator&gt;;</ins>
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template&lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_set(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_set(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key,
           class Hash = hash&lt;Key&gt;,
           class Pred = equal_to&lt;Key&gt;,
           class Allocator = allocator&lt;Key&gt;&gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template&lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template&lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template&lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
  
  [&hellip;]
  template&lt;class T, class Allocator&gt;
    unordered_multiset(initializer_list&lt;T&gt;, typename see below ::size_type, Allocator)
      -&gt; unordered_multiset&lt;T, hash&lt;T&gt;, equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_multiset(initializer_list&lt;T&gt;, typename see below ::size_type, Hash, Allocator)
      -&gt; unordered_multiset&lt;T, Hash, equal_to&lt;T&gt;, Allocator&gt;;
      
  <ins>template&lt;class InputIterator, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, Allocator)
      -&gt; unordered_multiset&lt;<i>iter-value-type</i>&lt;InputIterator&gt;,
                            hash&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;,
                            equal_to&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;,                  
                            Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_multiset(initializer_list&lt;T&gt;, Allocator) 
      -&gt; unordered_multiset&lt;T, hash&lt;T&gt;, equal_to&lt;T&gt;, Allocator&gt;;</ins>
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template&lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multiset(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multiset(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2022-07-15; Casey comments]</i></p>

<p>
<a href="https://wg21.link/P1206R7" title=" Conversions from ranges to containers">P1206R7</a> added <code>from_range_t</code> constructors corresponding to existing iterator pair 
constructors for the standard containers. For consistency, this issue should add <code>from_range_t</code> 
constructors corresponding to each new iterator pair constructor.
</p>

<p><i>[2022-07-16; Daniel comments and updates wording]</i></p>

<p>
The new <code>from_range_t</code> constructors have been added for each added new iterator pair constructor.
Note that the corresponding deduction guides already exist.
</p>


<p id="res-2713"><b>Proposed resolution:</b></p>
<p>This resolution is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.</p>

<ol>
<li><p>Add to the synopsis in 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key, 
           class T,
           class Hash = hash&lt;Key&gt;,
           class Pred = equal_to&lt;Key&gt;,
           class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template&lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template&lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
        : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template&lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
        : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_map(from_range_t, R&amp;&amp; rg, const allocator_type&amp; a);</ins>
    template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_map(from_range_t, R&amp;&amp; rg, size_type n, const allocator_type&amp; a)
        : unordered_map(from_range, std::forward&lt;R&gt;(rg), n, hasher(), key_equal(), a) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_map(from_range_t, R&amp;&amp; rg, size_type n, const hasher&amp; hf, const allocator_type&amp; a)
        : unordered_map(from_range, std::forward&lt;R&gt;(rg), n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.cnstr">[unord.map.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template&lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_map(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
  unordered_map(from_range_t, R&amp;&amp; rg, const allocator_type&amp; a)
    : unordered_map(from_range, std::forward&lt;R&gt;(rg), size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
      
<ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_map(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key, 
           class T,
           class Hash = hash&lt;Key&gt;,
           class Pred = equal_to&lt;Key&gt;,
           class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template&lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template&lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
        : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template&lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
        : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_multimap(from_range_t, R&amp;&amp; rg, const allocator_type&amp; a);</ins>
    template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_multimap(from_range_t, R&amp;&amp; rg, size_type n, const allocator_type&amp; a)
        : unordered_multimap(from_range, std::forward&lt;R&gt;(rg),
                             n, hasher(), key_equal(), a) { }
    [&hellip;]
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.cnstr">[unord.multimap.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template&lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multimap(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
  unordered_multimap(from_range_t, R&amp;&amp; rg, const allocator_type&amp; a)
    : unordered_multimap(from_range, std::forward&lt;R&gt;(rg), size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multimap(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key,
           class Hash = hash&lt;Key&gt;,
           class Pred = equal_to&lt;Key&gt;,
           class Allocator = allocator&lt;Key&gt;&gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template&lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template&lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
        : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template&lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
        : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_set(from_range_t, R&amp;&amp; rg, const allocator_type&amp; a);</ins>
    template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_set(from_range_t, R&amp;&amp; rg, size_type n, const allocator_type&amp; a)
        : unordered_set(from_range, std::forward&lt;R&gt;(rg), n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
  
  [&hellip;]
  template&lt;class T, class Allocator&gt;
    unordered_set(initializer_list&lt;T&gt;, typename <i>see below</i>::size_type, Allocator)
      -&gt; unordered_set&lt;T, hash&lt;T&gt;, equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_set(initializer_list&lt;T&gt;, typename <i>see below</i>::size_type, Hash, Allocator)
      -&gt; unordered_set&lt;T, Hash, equal_to&lt;T&gt;, Allocator&gt;;
      
  <ins>template&lt;class InputIterator, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_set&lt;<i>iter-value-type</i>&lt;InputIterator&gt;,
                       hash&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;,
                       equal_to&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;,                           
                       Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_set(initializer_list&lt;T&gt;, Allocator) 
      -&gt; unordered_set&lt;T, hash&lt;T&gt;, equal_to&lt;T&gt;, Allocator&gt;;</ins>
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.6.2 <a href="https://timsong-cpp.github.io/cppwp/unord.set.cnstr">[unord.set.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template&lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_set(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
  unordered_set(from_range_t, R&amp;&amp; rg, const allocator_type&amp; a)
    : unordered_set(from_range, std::forward&lt;R&gt;(rg), size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_set(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a> p3:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Key,
           class Hash = hash&lt;Key&gt;,
           class Pred = equal_to&lt;Key&gt;,
           class Allocator = allocator&lt;Key&gt;&gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template&lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template&lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template&lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_multiset(from_range_t, R&amp;&amp; rg, const allocator_type&amp; a);</ins>
    template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
      unordered_multiset(from_range_t, R&amp;&amp; rg, size_type n, const allocator_type&amp; a)
        : unordered_multiset(from_range, std::forward&lt;R&gt;(rg),
                             n, hasher(), key_equal(), a) { }
    [&hellip;]
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
  
  [&hellip;]
  template&lt;class T, class Allocator&gt;
    unordered_multiset(initializer_list&lt;T&gt;, typename see below ::size_type, Allocator)
      -&gt; unordered_multiset&lt;T, hash&lt;T&gt;, equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_multiset(initializer_list&lt;T&gt;, typename see below ::size_type, Hash, Allocator)
      -&gt; unordered_multiset&lt;T, Hash, equal_to&lt;T&gt;, Allocator&gt;;
      
  <ins>template&lt;class InputIterator, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, Allocator)
      -&gt; unordered_multiset&lt;<i>iter-value-type</i>&lt;InputIterator&gt;,
                            hash&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;,
                            equal_to&lt;<i>iter-value-type</i>&lt;InputIterator&gt;&gt;,                  
                            Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_multiset(initializer_list&lt;T&gt;, Allocator) 
      -&gt; unordered_multiset&lt;T, hash&lt;T&gt;, equal_to&lt;T&gt;, Allocator&gt;;</ins>
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.cnstr">[unord.multiset.cnstr]</a> p2</p>

<blockquote>
<pre>
<ins>template&lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multiset(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
  unordered_multiset(from_range_t, R&amp;&amp; rg, const allocator_type&amp; a))
    : unordered_multiset(from_range, std::forward&lt;R&gt;(rg), size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multiset(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The initial number of buckets supplied by the <code>size_type</code> argument is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>






<hr>
<h3 id="2714"><a href="2714">2714</a>. <code>complex</code> stream extraction underspecified</h3>
<p><b>Section:</b> 29.4.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-05-23 <b>Last modified:</b> 2018-10-16</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>operator&gt;&gt;(istream&amp;, complex&lt;T&gt;&amp;)</code> is extremely short on details. 
It currently reads, in its entirety (29.4.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a>/12-15):
</p>
<blockquote class="note">
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<i>Effects:</i> Extracts a complex number <code>x</code> of the form: <code>u</code>, <code>(u)</code>, or <code>(u,v)</code>, 
where <code>u</code> is the real part and <code>v</code> is the imaginary part (31.7.5.3 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted">[istream.formatted]</a>).
<p/>
<i>Requires:</i> The input values shall be convertible to <code>T</code>.
<p/>
If bad input is encountered, calls <code>is.setstate(ios_base::failbit)</code> (which may throw <code>ios::failure</code> 
(31.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a>)).
<p/>
<i>Returns:</i> <code>is</code>.
<p/>
<i>Remarks:</i> This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace 
is specified to be the same for each of the simpler extractions.
</p>
</blockquote>
</blockquote>
<p>
It is completely unclear:
</p>
<ul>
<li>which "simpler extractions" are performed,</li>
<li>how the extracted characters are matched to the special characters <code>'('</code>, <code>')'</code> and <code>','</code> 
(by <code>==</code>, or by <code>traits::eq</code>),</li>
<li>what is left in the stream on failure. (For example, with <code>"(0, 0]"</code>, libstdc++ extracts the <code>]</code> 
while libc++ leaves it in the stream.)</li>
</ul>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<blockquote class="note">
<i>Drafting note:</i> the following wording is based on:
<ul>
<li>Characters are extracted using <code>operator&gt;&gt;</code> and compared using <code>traits::eq</code>.</li>
<li>Mismatched characters are returned to the stream. </li>
</ul>
</blockquote>
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Replace 29.4.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a>/12-15 with the following paragraphs:</p>

<blockquote>
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-?- <i>Effects:</i> First, extracts a character from <code>is</code>.
<ul>
<li>If the character extracted is equal to <code>is.widen('(')</code>, extracts an object <code>u</code> of type <code>T</code> from <code>is</code>, 
then extracts a character from <code>is</code>.
<ul>
    <li>
    If this character is equal to <code>is.widen(')')</code>, then assigns <code>complex&lt;T&gt;(u)</code> to <code>x</code>.
    </li>
    <li>
      Otherwise, if this character is equal to <code>is.widen(',')</code>, extracts an object <code>v</code> of type <code>T</code> 
      from <code>is</code>, then extracts a character from <code>is</code>.
      If this character is equal to <code>is.widen(')')</code>, then assigns <code>complex&lt;T&gt;(u, v)</code> to <code>x</code>;
      otherwise returns the character to <code>is</code> and the extraction fails.
    </li>
    <li>
      Otherwise, returns the character to <code>is</code> and the extraction fails.
    </li>
  </ul>
</li>
<li> Otherwise, returns the character to <code>is</code>, extracts an object <code>u</code> of type <code>T</code> from <code>is</code>, and 
assigns <code>complex&lt;T&gt;(u)</code> to <code>x</code>.
</li>
</ul>
In the description above, characters are extracted from <code>is</code> as if by <code>operator&gt;&gt;</code> 
(31.7.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/istream.extractors">[istream.extractors]</a>), and returned to the stream as if by <code>basic_istream::putback</code> 
(31.7.5.4 <a href="https://timsong-cpp.github.io/cppwp/istream.unformatted">[istream.unformatted]</a>). Character equality is determined using <code>traits::eq</code>.
An object <code>t</code> of type <code>T</code> is extracted from <code>is</code> as if by <code> is &gt;&gt; t</code>.
<p/>
If any extraction operation fails, no further operation is performed and the whole extraction fails.
<p/>
On failure, calls <code>is.setstate(ios_base::failbit)</code> (which may throw <code>ios::failure</code>
(31.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a>)).
<p/>
-?- <i>Returns:</i> <code>is</code>.
<p/>
-?- [<i>Note</i>: This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace
is specified to be the same for each of the simpler extractions. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<p><i>[2017-12-13 Tim Song adjusts the P/R to avoid relying on <code>putback</code>.]</i></p>



<p id="res-2714"><b>Proposed resolution:</b></p>
<blockquote class="note">
<i>Drafting note:</i> the following wording assumes that:
<ul>
<li>Characters are extracted using <code>operator&gt;&gt;</code> and compared using <code>traits::eq</code>.</li>
<li>Mismatched characters are not extracted. </li>
<li><code>x</code> is assigned a value-initialized <code>complex</code> on failure for consistency with the arithmetic 
extractors (compare LWG <a href="696" title="istream::operator&gt;&gt;(int&amp;) broken (Status: C++11)">696</a>). </li>
</ul>
</blockquote>
<p>This wording is relative to <a href="https://wg21.link/N4778">N4778</a>.</p>
<ol>
<li><p>Replace 29.4.6 <a href="https://timsong-cpp.github.io/cppwp/complex.ops">[complex.ops]</a>/12-16 with the following paragraphs:</p>

<blockquote>
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-?- <i>Effects:</i> Let <code><i>PEEK</i>(is)</code> be a formatted input function (31.7.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted.reqmts">[istream.formatted.reqmts]</a>) of 
<code>is</code> that returns the next character that 
would be extracted from <code>is</code> by <code>operator&gt;&gt;</code>. [<i>Note</i>: The <code>sentry</code> object is constructed 
and destroyed,
 but the returned character is not extracted from the stream. &mdash; <i>end note</i>] 
<ul>
<li>If <code><i>PEEK</i>(is)</code> is not equal to <code>is.widen('(')</code>, extracts an object <code>u</code> of type <code>T</code> 
from <code>is</code>, and assigns <code>complex&lt;T&gt;(u)</code> to <code>x</code>.</li>
<li>Otherwise, extracts that character from <code>is</code>, then extracts an object <code>u</code> of type <code>T</code> from <code>is</code>, then:
<ul>
   <li>If <code><i>PEEK</i>(is)</code> is equal to <code>is.widen(')')</code>, then extracts that character from <code>is</code> and 
   assigns <code>complex&lt;T&gt;(u)</code> to <code>x</code>. </li>
   <li>Otherwise, if it is equal to <code>is.widen(',')</code>, then extracts that character from <code>is</code> and then extracts 
   an object <code>v</code> of type <code>T</code> from <code>is</code>, then:
    <ul>
       <li>If <code><i>PEEK</i>(is)</code> is equal to <code>is.widen(')')</code>, then extracts that character from <code>is</code> and 
       assigns <code>complex&lt;T&gt;(u, v)</code> to <code>x</code>.</li>
       <li> Otherwise, the extraction fails.</li>
    </ul>
   </li>
   <li>Otherwise, the extraction fails.</li>
</ul>
</li>
</ul>
In the description above, characters are extracted from <code>is</code> as if by <code>operator&gt;&gt;</code> (31.7.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/istream.extractors">[istream.extractors]</a>), character equality is determined using <code>traits::eq</code>, and an object <code>t</code> of type <code>T</code> is extracted from <code>is</code> 
as if by <code> is &gt;&gt; t</code>.
<p/>
If any extraction operation fails, no further operation is performed and the whole extraction fails.
<p/>
On failure, assigns <code>complex&lt;T&gt;()</code> to <code>x</code> and calls <code>is.setstate(ios_base::failbit)</code> (which may throw 
<code>ios::failure</code> (31.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/iostate.flags">[iostate.flags]</a>)).
<p/>
-?- <i>Returns:</i> <code>is</code>.
<p/>
-?- [<i>Note</i>: This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace
is specified to be the same for each of the simpler extractions. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2730"><a href="2730">2730</a>. <code>numeric_limits</code> primary template definition</h3>
<p><b>Section:</b> 17.3.5 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits">[numeric.limits]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-06-09 <b>Last modified:</b> 2023-04-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.limits">active issues</a> in [numeric.limits].</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits">issues</a> in [numeric.limits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've received this report at the <a href="mailto:cxxeditor@gmail.com">project editor mail alias</a>, and it seems like it may be worthy of a LWG issue:
</p>
<blockquote class="note">
<p>
I recently had this problem: 
</p>
<ul>
<li>I was storing data in a vector of <code>__uint128_t</code>s</li>
<li>I used a sorting library which used <code>numeric_limits&lt;T&gt;::max()</code> as a sentinel value</li>
<li>GCC's libstdc++ provides a <code>numeric_limits</code> specialisation for that type, but</li>
<li>Clang's libc++ does not.</li>
</ul>
<p>
This broke the sorting for me on different platforms, and it was quite difficult to determine why. If the default 
<code>numeric_limits</code> didn't default to <code>0</code>s and <code>false</code> values (18.3.2.4 of N4582), and instead 
<code>static_assert</code>ed, causing my code to not compile, I would have found the solution immediately.
<p/>
I know that <code>__uint128_t</code> is non-standard, so neither GCC nor Clang is doing the wrong thing nor the right thing 
here. I could just submit a patch to libc++ providing the specialisations, but it doesn't fix the problem at its core.
<p/>
I am wondering, what is the rationale behind the defaults being <code>0</code> and <code>false</code>? It seems like it is 
inviting a problem for any future numeric types, whether part of a library, compiler extension, and possibly even 
future updates to C++'s numeric types. I think it would be much better to prevent code that tries to use 
unspecified <code>numeric_limits</code> from compiling.
</p>
</blockquote>
<p>
An alternative to this suggestion would be to still define the primary template, but not provide any of the members 
except <code>is_specialized</code>. Either way, this would make <code>numeric_limits</code> members SFINAEable.
<p/>
Along the same lines, one might wonder why the members that only make sense for floating-point types are required to 
be defined to nonsense values for integer types.
</p>

<p><i>[2016-11-12, Issaquah]</i></p>

<p>Sat PM: This looks like a good idea. Jonathan and Marshall will do post C++17 implementations and report back.</p>

<p><i>[2018-11 San Diego Thursday night issue processing]</i></p>

<p>See Walter's paper <a href="https://wg21.link/P0437" title=" Numeric Traits for the Standard Library">P0437</a> for ideas and/or future directions.</p>

<p><i>[2023-04]</i></p>

<p>See Walter's paper <a href="https://wg21.link/P1841" title=" Wording for Individually Specializable Numeric Traits">P1841</a> for the preferred direction.</p>


<p id="res-2730"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2737"><a href="2737">2737</a>. Consider relaxing object size restrictions for single-object allocation functions</h3>
<p><b>Section:</b> 17.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Clark Nelson <b>Opened:</b> 2016-06-21 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#new.delete.single">active issues</a> in [new.delete.single].</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It should be considered whether the description of the
single-object allocation functions should say "or smaller", like
the array allocation functions. For example, according to 17.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> p1 (emphasis mine):
</p>
<blockquote>
<p>
The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate <code>size</code> bytes of
storage suitably aligned to represent any object <em>of that size</em>.
</p>
</blockquote>
<p>
In contrast to this, 17.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/new.delete.array">[new.delete.array]</a> p1 says (emphasis mine):
</p>
<blockquote>
<p>
The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate
<code>size</code> bytes of storage suitably aligned to represent any array object <em>of that size or smaller</em>. 
(footnote: It is not the direct responsibility of <code>operator new[](std::size_t)</code> or <code>operator delete[](void*)</code> 
to note the repetition count or element size of the array. Those operations are performed elsewhere in the array 
<code>new</code> and <code>delete</code> expressions. The array <code>new</code> expression, may, however, increase the size 
argument to operator <code>new[](std::size_t)</code> to obtain space to store supplemental information.)
</p>
</blockquote>


<p id="res-2737"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2746"><a href="2746">2746</a>. Inconsistency between requirements for <code>emplace</code> between <code>optional</code> and <code>variant</code></h3>
<p><b>Section:</b> 22.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a>, 22.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a>, 22.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-13 <b>Last modified:</b> 2020-05-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Referring to N4604:
</p>
<p>
In  [optional.object.assign]: <code>emplace</code> (normal form) has a Requires that the construction works.
</p>
<blockquote>
<p>
<i>Requires:</i> <code>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</code> is <code>true</code>.
</p>
</blockquote>
<p>
<code>emplace</code> (<code>initializer_list</code> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <code>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</code> 
is <code>true</code>.
</p>
</blockquote>
<p>
In 22.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a>: <code>emplace</code> (normal form) has a Requires that the construction works:
</p>
<blockquote>
<p>
<i>Requires:</i> <code>is_constructible_v&lt;T, Args...&gt;</code> is <code>true</code>.
</p>
</blockquote>
<p>
<code>emplace</code> (<code>initializer_list</code> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <code>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</code> is <code>true</code>.
</p>
</blockquote>
<p>
In 22.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a>: <code>emplace</code> (<code>T</code>, normal form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <code>is_constructible_v&lt;T, Args...&gt;</code> is <code>true</code>, and <code>T</code> occurs exactly 
once in <code>Types...</code>.
</p>
</blockquote>
<p>
<code>emplace</code> (Idx, normal form) has a <em>both</em> a Requires and a SFINAE condition:
</p>
<blockquote>
<p>
<i>Requires:</i> <code>I &lt; sizeof...(Types)</code>
<p/>
<i>Remarks:</i> [&hellip;] unless <code>is_constructible_v&lt;T, Args...&gt;</code> is <code>true</code>, and <code>T</code> 
occurs exactly once in <code>Types...</code>.
</p>
</blockquote>
<p>
<code>emplace</code> (<code>T</code>, <code>initializer_list</code> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <code>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</code> is 
<code>true</code>, and <code>T</code> occurs exactly once in <code>Types...</code>.
</p>
</blockquote>
<p>
<code>emplace</code> (Idx, <code>initializer_list</code> form) has a both a Requires and a SFINAE condition:
</p>
<blockquote>
<p>
<i>Requires:</i> <code>I &lt; sizeof...(Types)</code>
<p/>
<i>Remarks:</i> [&hellip;] unless <code>is_constructible_v&lt;T, Args...&gt;</code> is true, and <code>T</code> occurs exactly 
once in <code>Types...</code>.
</p>
</blockquote>
<p>
Why the inconsistency? Should all the cases have a SFINAE requirement?
<p/>
I see that variant has an additional requirement (<code>T</code> occurs exactly once in <code>Types...</code>), but that 
only agues that it must be a SFINAE condition &mdash; doesn't say that the other cases (any/variant) should not.
<p/>
<code>map</code>/<code>multimap</code>/<code>unordered_map</code>/<code>unordered_multimap</code> have SFINAE'd versions of 
<code>emplace</code> that don't take <code>initializer_list</code>s, but they don't have any <code>emplace</code> versions 
that take ILs.
<p/>
Suggested resolution:
<p/>
Add SFINAE requirements to <code>optional::emplace(Args&amp;&amp;... args)</code> and 
<code>any::emplace(Args&amp;&amp;... args);</code>
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>During issue prioritization, people suggested that this might apply to <code>any</code> as well.</p>
<p>Ville notes that <a href="2746" title="Inconsistency between requirements for emplace between optional and variant (Status: New)">2746</a>, <a href="2754" title="The in_place constructors and emplace functions added by P0032R3 don't require CopyConstructible (Status: Resolved)">2754</a> and <a href="2756" title="C++ WP optional&lt;T&gt; should 'forward' T's implicit conversions (Status: C++17)">2756</a> all go together.</p>

<p><i>[2020-05-10; Daniel comments and provides wording]</i></p>

<p>
The inconsistency between the two <code>any::emplace</code> overloads have been removed by resolving LWG
<a href="2754" title="The in_place constructors and emplace functions added by P0032R3 don't require CopyConstructible (Status: Resolved)">2754</a> to use <i>Constraints:</i> elements. The last Mandating paper 
(<a href="https://wg21.link/p1460r1">P1460R1</a>), adopted in Prague, changed the <i>Requires:</i> elements
for <code>variant::emplace</code>, "<code>I &lt; sizeof...(Types)</code>" to <i>Mandates:</i>, but that paper
was focused on fixing inappropriate preconditions, not searching for consistency here. Given that the
<code>in_place_index_t</code> constructors of <code>variant</code> uses SFINAE-conditions for this form of static
precondition violation, I recommend that its <code>emplace</code> functions use the same style, which would bring 
them also in consistency with their corresponding type-based <code>emplace</code> forms that are 
<i>Mandates:</i>-free but delegate to the index-based forms.
</p>


<p id="res-2746"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li><p>Modify 22.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a>, as indicated:</p>

<blockquote>
<pre>
template&lt;class... Args&gt; T&amp; emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-29- <i><del>Mandates</del><ins>Constraints</ins>:</i> <code>is_constructible_v&lt;T, Args...&gt;</code> is <code>true</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class... Args&gt; T&amp; emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-35- <i>Constraints:</i> <code>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</code> is <code>true</code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a>, as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt; T&amp; emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Constraints:</i> <code>is_constructible_v&lt;T, Args...&gt;</code> is <code>true</code>, and <code>T</code> 
occurs exactly once in <code>Types</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class T, class U, class... Args&gt; T&amp; emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-3- <i>Constraints:</i> <code>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</code> is <code>true</code>, 
and <code>T</code> occurs exactly once in <code>Types</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;size_t I, class... Args&gt;
  variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp; emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-5- <i>Mandates:</i> <code>I &lt; sizeof...(Types)</code>.</del>
<p/>
-6- <i>Constraints:</i> <code>is_constructible_v&lt;T<sub><i>I</i></sub>, Args...&gt;</code> is <code>true</code> 
<ins>and <code>I &lt; sizeof...(Types)</code> is <code>true</code></ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;size_t I, class U, class... Args&gt;
  variant_alternative_t&lt;I, variant&lt;Types...&gt;&gt;&amp; emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-12- <i>Mandates:</i> <code>I &lt; sizeof...(Types)</code>.</del>
<p/>
-13- <i>Constraints:</i> <code>is_constructible_v&lt;T<sub><i>I</i></sub>, initializer_list&lt;U&gt;&amp;, Args...&gt;</code> is 
<code>true</code> <ins>and <code>I &lt; sizeof...(Types)</code> is <code>true</code></ins>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3 id="2751"><a href="2751">2751</a>. <code>shared_ptr</code> deleter not specified to observe expired <code>weak_ptr</code> instances</h3>
<p><b>Section:</b> 20.3.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Aaron Jacobs <b>Opened:</b> 2016-07-21 <b>Last modified:</b> 2025-03-18</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.dest">issues</a> in [util.smartptr.shared.dest].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++14 standard contains no language that guarantees the deleter run by a
<code>shared_ptr</code> will see all associated <code>weak_ptr</code> instances as expired. For example,
the standard doesn't appear to guarantee that the assertion in the following
snippet won't fire:
</p>
<blockquote><pre>
std::weak_ptr&lt;Foo&gt; weak;
std::shared_ptr&lt;Foo&gt; strong{
  new Foo,
  [&amp;weak] (Foo* f) {
    assert(weak.expired());
    delete f;
  },
};

weak = strong;
strong.reset();
</pre></blockquote>
<p>
It seems clear that the intent is that associated <code>weak_ptr</code>s are expired,
because otherwise <code>shared_ptr</code> deleters could resurrect a reference to an object
that is being deleted.
<p/>
Suggested fix: 20.3.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.dest">[util.smartptr.shared.dest]</a> should specify that the decrease in
<code>use_count()</code> caused by the destructor is sequenced before the call to the
deleter or the call to <code>delete p</code>.
</p>

<p><i>[2016-11-08, Jonathan and STL suggest NAD]</i></p>

<p>
STL and Jonathan feel that the example has unspecified behaviour, and the
assertion is allowed to fire, and that's OK (the program's expectation
is not reasonable). Otherwise it's necessary to move-construct a copy
of the deleter and use that copy to destroy the owned pointer. We do
not want to be required to do that.
</p>
<p>See also <a href="2262" title="Requirement for unique_ptr&lt;T&gt;::get_deleter()(p) to be able to destroy the unique_ptr (Status: Open)">2262</a>.</p>

<p><i>[2017-09-20, Jonathan comments]</i></p>

<p>
I'd like to withdraw my NAD suggestion. The value of <code>use_count()</code> is already observable during the destructor via 
<code>shared_ptr</code> and <code>weak_ptr</code> objects that share ownership, so specifying when it changes ensures correct 
behaviour.
</p>

<p><i>[2025-03-18, Jonathan comments]</i></p>

<p>See also <a href="2907" title="Semantics for destroying the deleter and the control-block of a shared_ptr are unclear (Status: NAD)">2907</a>.</p>



<p id="res-2751"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2766"><a href="2766">2766</a>. Swapping non-swappable types</h3>
<p><b>Section:</b> 22.3.3 <a href="https://timsong-cpp.github.io/cppwp/pairs.spec">[pairs.spec]</a>, 22.4.12 <a href="https://timsong-cpp.github.io/cppwp/tuple.special">[tuple.special]</a>, 22.5.10 <a href="https://timsong-cpp.github.io/cppwp/optional.specalg">[optional.specalg]</a>, 22.6.10 <a href="https://timsong-cpp.github.io/cppwp/variant.specalg">[variant.specalg]</a>, 20.3.1.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a>, 23.3.3.4 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a>, 23.6.3.6 <a href="https://timsong-cpp.github.io/cppwp/queue.special">[queue.special]</a>, 23.6.4.5 <a href="https://timsong-cpp.github.io/cppwp/priqueue.special">[priqueue.special]</a>, 23.6.6.7 <a href="https://timsong-cpp.github.io/cppwp/stack.special">[stack.special]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-08-15 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.spec">issues</a> in [pairs.spec].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Related: <a href="2748" title="swappable traits for optionals (Status: C++17)">2748</a> swappable traits for optionals, <a href="2749" title="swappable traits for variants (Status: C++17)">2749</a> swappable traits for variants.
</p>
<p>
The adoption of <a href="https://wg21.link/p0185r1">P0185R1</a> "Adding [nothrow-]swappable traits" makes certain 
non-swappable types indirectly swappable. Consider a type defined as follows:
</p>
<blockquote><pre>
struct non_swappable {
  friend void swap(non_swappable&amp;, non_swappable&amp;) = delete;
};

non_swappable ns1, ns2;
using std::swap;
swap(ns1, ns2); // ill-formed

static_assert(std::is_swappable_v&lt;non_swappable&gt; == false); // holds
</pre></blockquote>
<p>
Lvalues of type <code>non_swappable</code> are not swappable, as defined by 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>, 
overload resolution selects the deleted function. Consistently, <code>is_swappable_v&lt;non_swappable&gt;</code> yields 
false. It should be noted that since <code>non_swappable</code> is move constructible and move assignable, a qualified 
call to <code>std::swap</code> would be well-formed, even under P0185. Now consider the following snippet:
</p>
<blockquote><pre>
std::tuple&lt;non_swappable&gt; tns1, tns2;
using std::swap;
swap(tns1, tns2); // previously ill-formed, now well-formed

static_assert(std::is_swappable_v&lt;std::tuple&lt;non_swappable&gt;&gt; == false); // fires
</pre></blockquote>
<p>
Before P0185, this snippet would violate the implicit requirement of specialized swap for tuples that each tuple 
element be swappable. After P0185, this specialized swap overload for tuples would be SFINAEd away, resulting 
in overload resolution selecting the base swap overload, and performing the exchange via move construction and 
move assignment of tuples.
<p/>
This issue affects all of <code>pair</code>, <code>tuple</code>, <code>unique_ptr</code>, <code>array</code>, <code>queue</code>, 
<code>priority_queue</code>, <code>stack</code>, and should eventually also apply to <code>optional</code> and <code>variant</code>.
</p>


<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4606">N4606</a>, except when otherwise noted.</p>

<ol>
<li><p>Modify 22.3.3 <a href="https://timsong-cpp.github.io/cppwp/pairs.spec">[pairs.spec]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y)
  noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> As if by <code>x.swap(y)</code>.
<p/>
-8- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as 
deleted</ins> unless <code>is_swappable_v&lt;T1&gt;</code> is <code>true</code> and <code>is_swappable_v&lt;T2&gt;</code> 
is <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.4.12 <a href="https://timsong-cpp.github.io/cppwp/tuple.special">[tuple.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <code>is_swappable_v&lt;<code>T<sub>i</sub></code>&gt;</code> is <code>true</code> for all <code><i>i</i></code>, where 
<code>0 &lt;= <i>i</i></code> and <code><i>i</i> &lt; sizeof...(Types)</code>. The expression inside <code>noexcept</code> 
is equivalent to:
</p>
<blockquote><pre>
noexcept(x.swap(y))
</pre></blockquote>
<p>
-2- <i>Effects:</i> As if by <code>x.swap(y)</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.3.1.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <code>is_swappable_v&lt;D&gt;</code> is <code>true</code>.
<p/>
-2- <i>Effects:</i> Calls <code>x.swap(y)</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.3.4 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, size_t N&gt;
  void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <code>N == 0</code> or <code>is_swappable_v&lt;T&gt;</code> is <code>true</code>.
<p/>
-2- <i>Effects:</i> As if by <code>x.swap(y)</code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.6.3.6 <a href="https://timsong-cpp.github.io/cppwp/queue.special">[queue.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container&gt;
  void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <code>is_swappable_v&lt;Container&gt;</code> is <code>true</code>.
<p/>
-2- <i>Effects:</i> As if by <code>x.swap(y)</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.6.4.5 <a href="https://timsong-cpp.github.io/cppwp/priqueue.special">[priqueue.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container, class Compare&gt;
  void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x,
            priority_queue&lt;T, Container, Compare&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <code>Remarks:</code> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <code>is_swappable_v&lt;Container&gt;</code> is <code>true</code> and <code>is_swappable_v&lt;Compare&gt;</code> is <code>true</code>.
<p/>
-2- <i>Effects:</i> As if by <code>x.swap(y)</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.6.6.7 <a href="https://timsong-cpp.github.io/cppwp/stack.special">[stack.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container&gt;
  void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <code>is_swappable_v&lt;Container&gt;</code> is <code>true</code>.
<p/>
-2- <i>Effects:</i> As if by <code>x.swap(y)</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.10 <a href="https://timsong-cpp.github.io/cppwp/optional.specalg">[optional.specalg]</a> as indicated:</p>
<blockquote class="note">
<p>
This change should be performed if and only if LWG <a href="2748" title="swappable traits for optionals (Status: C++17)">2748</a> is accepted and is against the wording of <a href="2748" title="swappable traits for optionals (Status: C++17)">2748</a>:
</p>
</blockquote>
<blockquote>
<pre>
template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <code>x.swap(y)</code>.
<p/>
-2- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <code>is_move_constructible_v&lt;T&gt;</code> is <code>true</code> and <code>is_swappable_v&lt;T&gt;</code> is <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.6.10 <a href="https://timsong-cpp.github.io/cppwp/variant.specalg">[variant.specalg]</a> as indicated:</p>
<blockquote class="note">
<p>
This change should be performed if and only if LWG <a href="2749" title="swappable traits for variants (Status: C++17)">2749</a> is accepted and is against the wording of <a href="2749" title="swappable traits for variants (Status: C++17)">2749</a>:
</p>
</blockquote>
<blockquote>
<pre>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <code>v.swap(w)</code>.
<p/>
-2- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <code>is_move_constructible_v&lt;<i>T<sub>i</sub></i>&gt; &amp;&amp; is_swappable_v&lt;<i>T<sub>i</sub></i>&gt;</code> 
is <code>true</code> for all <code><i>i</i></code>. The expression inside <code>noexcept</code> is equivalent to <code>noexcept(v.swap(w))</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-04-17 Jonathan updates proposed resolution based on Ville's 2016-11-17 observation that the container adaptors always require swappable sequences anyway. The new proposed resolution is based on the latest WP, "de-shalled", and <i>Remarks</i> elements are repositioned after the <i>Effects</i>.]</i></p>



<p id="res-2766"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 22.3.3 <a href="https://timsong-cpp.github.io/cppwp/pairs.spec">[pairs.spec]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class T1, class T2&gt;
  constexpr void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> As if by <code>x.swap(y)</code>.
<p/>
-8- <i>Remarks:</i> This function <del>shall not participate in overload resolution</del><ins>is defined as
deleted</ins> unless <code>is_swappable_v&lt;T1&gt;</code> is <code>true</code> and <code>is_swappable_v&lt;T2&gt;</code>
is <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.4.12 <a href="https://timsong-cpp.github.io/cppwp/tuple.special">[tuple.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class... Types&gt;
  constexpr void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-?- <ins><i>Effects:</i> As if by <code>x.swap(y)</code>.</ins>
</p>
<p>
-1- <i>Remarks:</i> This function <del>shall not participate in overload resolution</del><ins>is defined as deleted</ins>
unless <code>is_swappable_v&lt;<code>T<sub>i</sub></code>&gt;</code> is <code>true</code> for all <code><i>i</i></code>, where
<code>0 &lt;= <i>i</i></code> and <code><i>i</i> &lt; sizeof...(Types)</code>. The expression inside <code>noexcept</code>
is equivalent to:
</p>
<blockquote><pre>
noexcept(x.swap(y))
</pre></blockquote>
<p>
-2- <del><i>Effects:</i> As if by <code>x.swap(y)</code>.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.10 <a href="https://timsong-cpp.github.io/cppwp/optional.specalg">[optional.specalg]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <code>x.swap(y)</code>.
<p/>
-2- <i>Remarks:</i> This function <del>shall not participate in overload resolution</del><ins>is defined as deleted</ins>
unless <code>is_move_constructible_v&lt;T&gt;</code> is <code>true</code> and <code>is_swappable_v&lt;T&gt;</code> is <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.6.10 <a href="https://timsong-cpp.github.io/cppwp/variant.specalg">[variant.specalg]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <code>v.swap(w)</code>.
<p/>
-2- <i>Remarks:</i> This function <del>shall not participate in overload resolution</del><ins>is defined as deleted</ins>
unless <code>is_move_constructible_v&lt;<i>T<sub>i</sub></i>&gt; &amp;&amp; is_swappable_v&lt;<i>T<sub>i</sub></i>&gt;</code>
is <code>true</code> for all <code><i>i</i></code>. The expression inside <code>noexcept</code> is equivalent to <code>noexcept(v.swap(w))</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.3.1.6 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.special">[unique.ptr.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;
</pre>
<blockquote>
<p>
-?- <ins><i>Effects:</i> Calls <code>x.swap(y)</code>.</ins>
</p>
<p>
-1- <i>Remarks:</i> This function <del>shall not participate in overload resolution</del><ins>is defined as deleted</ins>
unless <code>is_swappable_v&lt;D&gt;</code> is <code>true</code>.
</p>
<p>
-2- <del><i>Effects:</i> Calls <code>x.swap(y)</code>.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.3.4 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a> as indicated:</p>
<blockquote>
<pre>
template &lt;class T, size_t N&gt;
  void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <del><i>Constraints:</i> <code>N == 0</code> or <code>is_swappable_v&lt;T&gt;</code> is <code>true</code>.</del>
<p/>
-2- <i>Effects:</i> As if by <code>x.swap(y)</code>.
<p/>
-3- <i>Complexity:</i> Linear in <code>N</code>.
<p/>
-?- <ins><i>Remarks:</i> This function is defined as deleted
unless <code>N == 0</code> or <code>is_swappable_v&lt;T&gt;</code> is <code>true</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="2811"><a href="2811">2811</a>. "Selected constructor" wording is incorrect for <code>optional</code>/<code>variant</code>/<code>any</code></h3>
<p><b>Section:</b> 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>, 22.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a>, 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a>, 22.7.4.2 <a href="https://timsong-cpp.github.io/cppwp/any.cons">[any.cons]</a>, 22.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-10-29 <b>Last modified:</b> 2020-06-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.ctor">issues</a> in [optional.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Throughout <code>optional</code>/<code>variant</code>/<code>any</code>'s specification references are made to "the selected constructor 
of <code>T</code>". For example, 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>/16 says of the constructor from <code>const T&amp;</code>:
</p>
<blockquote><p>
-16- <i>Remarks:</i> If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a 
<code>constexpr</code> constructor.
</p></blockquote>
<p>
Similarly, the in-place constructor has this wording (22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>/25-26):
</p>
<blockquote><p>
-25- <i>Throws:</i> Any exception thrown by the selected constructor of <code>T</code>.
<p/>
-26- <i>Remarks:</i> If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, 
this constructor shall be a <code>constexpr</code> constructor.
</p></blockquote>
<p>
If <code>T</code> is a scalar type, it has no constructor at all. Moreover, even for 
class types, the in-place constructor wording ignores any implicit conversion done on the argument before the selected 
constructor is called, which 1) may not be valid in constant expressions and 2) may throw an exception; such exceptions 
aren't thrown "by the selected constructor of <code>T</code>" but outside it.
<p/>
The wording should probably be recast to refer to the entire initialization.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3; Jonathan to provide wording.</p>

<p><i>[2020-06-11; Nina Dinka Ranns comments and provides initial wording]</i></p>

<p>
This wording depends on the current resolution for LWG <a href="2833" title="Library needs to specify what it means when it declares a function constexpr (Status: Open)">2833</a>, which covers the <code>constexpr</code> 
portion of this issue.
</p>


<p id="res-2811"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li>
<p>Modify 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:</p>

<blockquote>
<pre>
constexpr optional(const optional&amp; rhs);
</pre>
<blockquote>
<p>
-3- [&hellip;]
<p/>
-4- [&hellip;]
<p/>
-5- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>T</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
<pre>
constexpr optional(optional&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-7- [&hellip;]
<p/>
[&hellip;]
<p/>
-10- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>T</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-12- [&hellip;]
<p/>
[&hellip;]
<p/>
-15- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>T</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-17- [&hellip;]
<p/>
[&hellip;]
<p/>
-20- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>T</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;class U = T&gt; constexpr explicit(<i>see below</i>) optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-22- [&hellip;]
<p/>
[&hellip;]
<p/>
-25- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>T</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;class U&gt; explicit(<i>see below</i>) optional(const optional&lt;U&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-27- [&hellip;]
<p/>
[&hellip;]
<p/>
-30- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>T</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;class U&gt; explicit(<i>see below</i>) optional(optional&lt;U&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-32- [&hellip;]
<p/>
[&hellip;]
<p/>
-35- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>T</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>

</blockquote>
</li>

<li>
<p>Modify 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt; constexpr explicit variant(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-20- [&hellip;]
<p/>
[&hellip;]
<p/>
-23- <i>Throws:</i> Any exception thrown by <del>calling the selected constructor of <code>T</code></del><ins>the 
initialization of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;class T, class U, class... Args&gt;
  constexpr explicit variant(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-25- [&hellip;]
<p/>
[&hellip;]
<p/>
-28- <i>Throws:</i> Any exception thrown by <del>calling the selected constructor of <code>T</code></del><ins>the 
initialization of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;size_t I, class... Args&gt; constexpr explicit variant(in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-30 [&hellip;]
<p/>
[&hellip;]
<p/>
-33- <i>Throws:</i> Any exception thrown by <del>calling the selected constructor of <code>T<sub><i>I</i></sub></code></del><ins>the 
initialization of the contained value</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 22.7.4.2 <a href="https://timsong-cpp.github.io/cppwp/any.cons">[any.cons]</a> as indicated:</p>

<blockquote>
<pre>
any(const any&amp; other);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> [&hellip;]
<p/>
-3- <i>Throws:</i> Any exceptions <del>arising from calling the selected constructor for</del><ins>thrown 
by the initialization of</ins> the contained value.
</p>
</blockquote>
[&hellip;]
<pre>
template&lt;class T&gt;
  any(T&amp;&amp; value);
</pre>
<blockquote>
<p>
-5- [&hellip;]
<p/>
[&hellip;]
<p/>
-9- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>VT</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;class T, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-10- [&hellip;]
<p/>
[&hellip;]
<p/>
-15- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>VT</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
<pre>
template&lt;class T, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-16- [&hellip;]
<p/>
[&hellip;]
<p/>
-21- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>VT</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 22.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt;
  decay_t&lt;T&gt;&amp; emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
[&hellip;]
<p/>
-7- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>VT</code></del><ins>initialization 
of the contained value</ins>.
<p/>
-8- [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class T, class U, class... Args&gt;
  decay_t&lt;T&gt;&amp; emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-9- [&hellip;]
<p/>
[&hellip;]
<p/>
-15- <i>Throws:</i> Any exception thrown by the <del>selected constructor of <code>VT</code></del><ins>initialization 
of the contained value</ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2815"><a href="2815">2815</a>. <code>quick_exit</code> can deadlock</h3>
<p><b>Section:</b> 17.5 <a href="https://timsong-cpp.github.io/cppwp/support.start.term">[support.start.term]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jean-Fran&ccedil;ois Bastien <b>Opened:</b> 2016-11-07 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.start.term">active issues</a> in [support.start.term].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.start.term">issues</a> in [support.start.term].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While SG1 was processing NB comments CA1 and LATE2 regarding <a href="https://wg21.link/p0270r1">P0270R1</a>, 
we decided to remove the proposed guarantee that <code>quick_exit</code> be made signal safe.
<p/>
Our reasoning is that functions registered with <code>at_quick_exit</code> aren't forbidden from calling 
<code>quick_exit</code>, but <code>quick_exit</code> implementations likely acquire some form of a lock before 
processing all registered functions (because a note forbids the implementation from introducing data races).
<p/>
The following code can therefore deadlock:
</p>
<blockquote><pre>
#include &lt;cstdlib&gt;

int main() 
{
  std::at_quick_exit([] () { std::quick_exit(0); });
  std::quick_exit(1);
  return 0;
}
</pre></blockquote>
<p>
The same applies if a function registered in <code>at_quick_exit</code> handles a signal, and that signal calls 
<code>quick_exit</code>. SG1 believes that both issues (same thread deadlock, and signal deadlock) can be resolved 
in the same manner. Either:
</p>
<ol>
<li>Specify that calling <code>quick_exit</code> while servicing <code>quick_exit</code> is undefined; or</li>
<li>Specifying that calling <code>quick_exit</code> while servicing <code>quick_exit</code> is defined to not deadlock, 
and instead calls <code>_Exit</code> without calling further registered functions.</li>
</ol>
<p>
Option 2. seems preferable, and can be implemented along the lines of:
</p>
<blockquote><pre>
#include &lt;array&gt;
#include &lt;atomic&gt;
#include &lt;cstddef&gt;

namespace {

  typedef void (*func)();
  
  std::array&lt;func, 32&gt; quick_exit_functions;
  
  const auto* quick_exit_functions_ptr = &amp;quick_exit_functions;
  
  std::atomic_flag lock = ATOMIC_FLAG_INIT;
  
  struct scope 
  {
    scope() { while (lock.test_and_set(std::memory_order_acquire)) ; }
    ~scope() { lock.clear(std::memory_order_release); }
  };
  
}

namespace std {

  extern "C" void quick_exit(int status) noexcept
  {
    decltype(quick_exit_functions_ptr) f;
    {
      scope s;
      f = quick_exit_functions_ptr;
      quick_exit_functions_ptr = nullptr;
    }
    if (f) {
      size_t pos = f-&gt;size();
      while (pos &gt; 0)
        (*f)[--pos]();
    }
    _Exit(status);
  }
  
  extern "C++" int at_quick_exit(func f) noexcept
  {
    scope s;
    if (!quick_exit_functions_ptr || quick_exit_functions.size() == quick_exit_functions.max_size())
      return -1;
    quick_exit_functions[quick_exit_functions.size()] = f;
    return 0;
  }

}
</pre></blockquote>
<p>
Ideally, the resolution would also add back the wording which SG1 dropped from <a href="https://wg21.link/p0270r1">P0270R1</a>:
</p>
<blockquote><p>Add at new element to the end of 17.5 <a href="https://timsong-cpp.github.io/cppwp/support.start.term">[support.start.term]</a> p13 (<code>quick_exit()</code>):</p>
<blockquote>
<p>
<ins><i>Remarks:</i> The function <code>quick_exit()</code> is signal-safe (17.14.4 <a href="https://timsong-cpp.github.io/cppwp/csignal.syn">[csignal.syn]</a>). [<i>Note:</i> It might 
still be unsafe to call <code>quick_exit()</code> from a handler, because the functions registered with <code>at_quick_exit()</code> 
might not be signal-safe. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3</p>


<p id="res-2815"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4606">N4606</a>.</p>

<ol>
<li>
<p>Add at new element to the end of 17.5 <a href="https://timsong-cpp.github.io/cppwp/support.start.term">[support.start.term]</a> p13 (<code>quick_exit()</code>):</p>

<blockquote>
<pre>
[[noreturn]] void quick_exit(int status) noexcept;
</pre>
<blockquote>
<p>
-13- <i>Effects:</i> Functions registered by calls to <code>at_quick_exit</code> are called in the reverse order of their
registration, except that a function shall be called after any previously registered functions that had
already been called at the time it was registered. Objects shall not be destroyed as a result of calling
<code>quick_exit</code>. If control leaves a registered function called by <code>quick_exit</code> because the function does not
provide a handler for a thrown exception, <code>std::terminate()</code> shall be called. [<i>Note:</i> <code>at_quick_exit</code>
may call a registered function from a different thread than the one that registered it, so registered
functions should not rely on the identity of objects with thread storage duration. &mdash; <i>end note</i>] After
calling registered functions, <code>quick_exit</code> shall call <code>_Exit(status)</code>. [<i>Note:</i> The standard file 
buffers are not flushed. See: ISO C 7.22.4.5. &mdash; <i>end note</i>]
<p/>
<ins>-?- <i>Remarks:</i> The function <code>quick_exit()</code> is signal-safe (17.14.4 <a href="https://timsong-cpp.github.io/cppwp/csignal.syn">[csignal.syn]</a>). [<i>Note:</i> 
It might still be unsafe to call <code>quick_exit()</code> from a handler, because the functions registered with 
<code>at_quick_exit()</code> might not be signal-safe. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="2819"><a href="2819">2819</a>. Unspecified <i>Return type:</i> elements</h3>
<p><b>Section:</b> 32.2.5 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable">[thread.req.lockable]</a>, 32.6.4 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements">[thread.mutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-11-12 <b>Last modified:</b> 2022-11-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current draft contains 14 occurrences of a <i>Return type:</i> clause.
That clause is not covered by 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> p3.
This was reported as editorial request <a href="https://github.com/cplusplus/draft/issues/266">#266</a>.
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 3; Jonathan to provide wording.</p>

<p><i>[12-May-2020, Jonathan provides wording to correct the <b>13</b> occurrences.]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4861">N4681</a>.</p>

<ol>
<li>
<p>Modify 32.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.req">[thread.req.lockable.req]</a> as indicated:</p>
<blockquote>
<p>-1- A type <code>L</code> meets the <i>Cpp17Lockable</i> requirements
if it meets the <i>Cpp17BasicLockable</i> requirements
and the following expressions are
well-formed<ins>, have type <code>bool</code>,</ins>
and have the specified semantics
(<code>m</code> denotes a value of type <code>L</code>).
</p>
<p><code>m.try_lock()</code></p>
<blockquote>
<p>-2- <i>Effects:</i> [...]</p>
<p><del>-3- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-4- <i>Returns:</i> <code>true</code> if the lock was acquired, <code>false</code> otherwise.</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.2.5.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.timed">[thread.req.lockable.timed]</a> as indicated:</p>
<blockquote>
<p>-1- A type <code>L</code> meets the <i>Cpp17TimedLockable</i> requirements
if it meets the <i>Cpp17BasicLockable</i> requirements
and the following expressions are
well-formed<ins>, have type <code>bool</code>,</ins>
and have the specified semantics
(<code>m</code> denotes a value of type <code>L</code>,
<code>rel_time</code> denotes a value of an instantiation of
<code>duration</code> (30.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a>),
and <code>abs_time</code> denotes a value of an instantiation of
<code>time_point</code> (30.6 <a href="https://timsong-cpp.github.io/cppwp/time.point">[time.point]</a>)).
</p>
<p><code>m.try_lock_for(rel_time)</code></p>
<blockquote>
<p>-2- <i>Effects:</i> [...]</p>
<p><del>-3- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-4- <i>Returns:</i> <code>true</code> if the lock was acquired, <code>false</code> otherwise.</p>
</blockquote>
<p><code>m.try_lock_until(abs_time)</code></p>
<blockquote>
<p>-2- <i>Effects:</i> [...]</p>
<p><del>-3- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-4- <i>Returns:</i> <code>true</code> if the lock was acquired, <code>false</code> otherwise.</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex">[thread.mutex.requirements.mutex]</a> as indicated:</p>
<blockquote>
<p>-6- The expression <code>m.lock()</code> is
well-formed<ins>, has type <code>void</code>,</ins>
and has the following semantics:</p>
<blockquote>
<p>-7- <i>Preconditions:</i> [...]</p>
<p>-8- <i>Effects:</i> [...]</p>
<p>-9- <i>Postconditions:</i> [...]</p>
<p><del>-10- <i>Return type:</i> <code>void</code>.</del></p>
<p>-11- <i>Synchronization:</i> [...]</p>
<p>-12- <i>Throws:</i> [...]</p>
<p>-13- <i>Error conditions:</i> [...]</p>
</blockquote>
<p>-14- The expression <code>m.try_lock()</code> is
well-formed<ins>, has type <code>bool</code>,</ins>
and has the following semantics:</p>
<blockquote>
<p>-15- <i>Preconditions:</i> [...]</p>
<p>-16- <i>Effects:</i> [...]</p>
<p><del>-17- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-18- <i>Returns:</i> <code>true</code> if ownership of the mutex was
obtained for the calling thread, otherwise <code>false</code>.</p>
<p>-19- <i>Synchronization:</i> [...]</p>
<p>-20- <i>Throws:</i> Nothing.</p>
</blockquote>
<p>-21- The expression <code>m.unlock()</code> is
well-formed<ins>, has type <code>void</code>,</ins>
and has the following semantics:</p>
<blockquote>
<p>-22- <i>Preconditions:</i> [...]</p>
<p>-23- <i>Effects:</i> [...]</p>
<p><del>-24- <i>Return type:</i> <code>void</code>.</del></p>
<p>-25- <i>Synchronization:</i> [...]</p>
<p>-26- <i>Throws:</i> Nothing.</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a> as indicated:</p>
<blockquote>
<p>-1- The <i>timed mutex types</i> are the standard library types [...] </p>
<p>-2- The timed mutex types meet the <i>Cpp17TimedLockable</i> requirements
(32.2.5.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.timed">[thread.req.lockable.timed]</a>).</p>
<p>-3- The expression <code>m.try_lock_for(rel_time)</code> is
well-formed<ins>, has type <code>bool</code>,</ins>
and has the following semantics:
</p>
<blockquote>
<p>-4- <i>Preconditions:</i> [...]</p>
<p>-5- <i>Effects:</i> [...]</p>
<p><del>-6- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-7- <i>Returns:</i> <code>true</code> if the shared lock was acquired,
<code>false</code> otherwise.</p>
<p>-8- <i>Synchronization:</i> [...]</p>
<p>-9- <i>Throws:</i> [...]</p>
</blockquote>
<p>-10- The expression <code>m.try_lock_until(abs_time)</code> is
well-formed<ins>, has type <code>bool</code>,</ins>
and has the following semantics:
</p>
<blockquote>
<p>-11- <i>Preconditions:</i> [...]</p>
<p>-12- <i>Effects:</i> [...]</p>
<p><del>-13- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-14- <i>Returns:</i> <code>true</code> if ownership was obtained,
otherwise <code>false</code>.</p>
<p>-15- <i>Synchronization:</i> [...]</p>
<p>-16- <i>Throws:</i> [...]</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.6.4.4 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedmutex.requirements">[thread.sharedmutex.requirements]</a> as indicated:</p>
<blockquote>
<p>-1- The standard library types <code>shared_mutex</code>
and  <code>shared_timed_mutex</code>
are <i>shared mutex types</i>. [...]
</p>
<p>-2- In addition to the exclusive lock ownership mode [...]</p>
<p>-3- The expression <code>m.lock_shared()</code> is
well-formed<ins>, has type <code>void</code>,</ins>
and has the following semantics:
</p>
<blockquote>
<p>-4- <i>Preconditions:</i> [...]</p>
<p>-5- <i>Effects:</i> [...]</p>
<p>-6- <i>Postconditions:</i> [...]</p>
<p><del>-7- <i>Return type:</i> <code>void</code>.</del></p>
<p>-8- <i>Synchronization:</i> [...]</p>
<p>-9- <i>Throws:</i> [...]</p>
<p>-10- <i>Error conditions:</i> [...]</p>
</blockquote>
<p>-11- The expression <code>m.unlock_shared()</code> is
well-formed<ins>, has type <code>void</code>,</ins>
and has the following semantics:
</p>
<blockquote>
<p>-12- <i>Preconditions:</i> [...]</p>
<p>-13- <i>Effects:</i> [...]</p>
<p><del>-14- <i>Return type:</i> <code>void</code>.</del></p>
<p>-15- <i>Synchronization:</i> [...]</p>
<p>-16- <i>Throws:</i> [...]</p>
</blockquote>
<p>-17- The expression <code>m.try_lock_shared()</code> is
well-formed<ins>, has type <code>bool</code>,</ins>
and has the following semantics:
</p>
<blockquote>
<p>-18- <i>Preconditions:</i> [...]</p>
<p>-19- <i>Effects:</i> [...]</p>
<p><del>-20- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-21- <i>Returns:</i> <code>true</code> if the shared ownership lock was acquired,
<code>false</code> otherwise.</p>
<p>-22- <i>Synchronization:</i> [...]</p>
<p>-23- <i>Throws:</i> [...]</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.6.4.5 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements">[thread.sharedtimedmutex.requirements]</a> as indicated:</p>
<blockquote>
<p>-1- The standard library type <code>shared_timed_mutex</code>
is a <i>shared timed mutex type</i>. [...]
</p>
<p>-2- The expression <code>m.try_lock_shared_for(rel_time)</code> is
well-formed<ins>, has type <code>bool</code>,</ins>
and has the following semantics:
</p>
<blockquote>
<p>-3- <i>Preconditions:</i> [...]</p>
<p>-4- <i>Effects:</i> [...]</p>
<p><del>-5- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-6- <i>Returns:</i> <code>true</code> if the shared lock was acquired,
<code>false</code> otherwise.</p>
<p>-7- <i>Synchronization:</i> [...]</p>
<p>-8- <i>Throws:</i> [...]</p>
</blockquote>
<p>-9- The expression <code>m.try_lock_shared_until(abs_time)</code> is
well-formed<ins>, has type <code>bool</code>,</ins>
and has the following semantics:
</p>
<blockquote>
<p>-10- <i>Preconditions:</i> [...]</p>
<p>-11- <i>Effects:</i> [...]</p>
<p><del>-12- <i>Return type:</i> <code>bool</code>.</del></p>
<p>-13- <i>Returns:</i> <code>true</code> if the shared lock was acquired,
<code>false</code> otherwise.</p>
<p>-14- <i>Synchronization:</i> [...]</p>
<p>-15- <i>Throws:</i> [...]</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-11-06; Daniel comments and provides alternative wording]</i></p>

<p>
Now that we have the new element <i>Result:</i> specified in 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>,
we can simply replace all occurrences of the <i>Return type:</i> by this element.
</p>


<p id="res-2819"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li>
<p>Modify 32.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.req">[thread.req.lockable.req]</a> as indicated:</p>
<blockquote>
<p>-1- A type <code>L</code> meets the <i>Cpp17Lockable</i> requirements
if it meets the <i>Cpp17BasicLockable</i> requirements
and the following expressions are
well-formed and have the specified semantics
(<code>m</code> denotes a value of type <code>L</code>).
</p>
<p><code>m.try_lock()</code></p>
<blockquote>
<p>-2- <i>Effects:</i> [...]</p>
<p>-3- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-4- <i>Returns:</i> <code>true</code> if the lock was acquired, otherwise <code>false</code>.</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.2.5.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.timed">[thread.req.lockable.timed]</a> as indicated:</p>
<blockquote>
<p>-1- A type <code>L</code> meets the <i>Cpp17TimedLockable</i> requirements
if it meets the <i>Cpp17Lockable</i> requirements
and the following expressions are
well-formed and have the specified semantics
(<code>m</code> denotes a value of type <code>L</code>,
<code>rel_time</code> denotes a value of an instantiation of
<code>duration</code> (30.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a>),
and <code>abs_time</code> denotes a value of an instantiation of
<code>time_point</code> (30.6 <a href="https://timsong-cpp.github.io/cppwp/time.point">[time.point]</a>)).
</p>
<p><code>m.try_lock_for(rel_time)</code></p>
<blockquote>
<p>-2- <i>Effects:</i> [...]</p>
<p>-3- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-4- <i>Returns:</i> <code>true</code> if the lock was acquired, otherwise <code>false</code>.</p>
</blockquote>
<p><code>m.try_lock_until(abs_time)</code></p>
<blockquote>
<p>-5- <i>Effects:</i> [...]</p>
<p>-6- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-7- <i>Returns:</i> <code>true</code> if the lock was acquired, otherwise <code>false</code>.</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.6.4.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex.requirements.mutex.general">[thread.mutex.requirements.mutex.general]</a> as indicated:</p>
<blockquote>
<p>-5- The expression <code>m.lock()</code> is
well-formed and has the following semantics:</p>
<blockquote>
<p>-6- <i>Preconditions:</i> [...]</p>
<p>-7- <i>Effects:</i> [...]</p>
<p>-8- <i>Synchronization:</i> [...]</p>
<p>-9- <i>Postconditions:</i> [...]</p>
<p>-10- <i><del>Return type</del><ins>Result</ins>:</i> <code>void</code><del>.</del></p>
<p>-11- <i>Throws:</i> [...]</p>
<p>-12- <i>Error conditions:</i> [...]</p>
</blockquote>
<p>-13- The expression <code>m.try_lock()</code> is
well-formed and has the following semantics:</p>
<blockquote>
<p>-14- <i>Preconditions:</i> [...]</p>
<p>-15- <i>Effects:</i> [...]</p>
<p>-16- <i>Synchronization:</i> [...]</p>
<p>-17- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-18- <i>Returns:</i> <code>true</code> if ownership was obtained, otherwise <code>false</code>.</p>
<p>-19- <i>Throws:</i> Nothing.</p>
</blockquote>
<p>-20- The expression <code>m.unlock()</code> is
well-formed and has the following semantics:</p>
<blockquote>
<p>-21- <i>Preconditions:</i> [...]</p>
<p>-22- <i>Effects:</i> [...]</p>
<p>-23- <i><del>Return type</del><ins>Result</ins>:</i> <code>void</code><del>.</del></p>
<p>-24- <i>Synchronization:</i> [...]</p>
<p>-25- <i>Throws:</i> Nothing.</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.6.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements.general">[thread.timedmutex.requirements.general]</a> as indicated:</p>
<blockquote>
<p>-1- The <i>timed mutex types</i> are the standard library types [&hellip;] </p>
<p>-2- The expression <code>m.try_lock_for(rel_time)</code> is
well-formed and has the following semantics:
</p>
<blockquote>
<p>-3- <i>Preconditions:</i> [...]</p>
<p>-4- <i>Effects:</i> [...]</p>
<p>-5- <i>Synchronization:</i> [...]</p>
<p>-6- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-7- <i>Returns:</i> <code>true</code> if ownership was obtained, otherwise <code>false</code>.</p>
<p>-8- <i>Throws:</i> [...]</p>
</blockquote>
<p>-9- The expression <code>m.try_lock_until(abs_time)</code> is
well-formed and has the following semantics:
</p>
<blockquote>
<p>-10- <i>Preconditions:</i> [...]</p>
<p>-11- <i>Effects:</i> [...]</p>
<p>-12- <i>Synchronization:</i> [...]</p>
<p>-13- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-14- <i>Returns:</i> <code>true</code> if ownership was obtained, otherwise <code>false</code>.</p>
<p>-15- <i>Throws:</i> [...]</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.6.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedmutex.requirements.general">[thread.sharedmutex.requirements.general]</a> as indicated:</p>
<blockquote>
<p>-1- The standard library types <code>shared_mutex</code>
and  <code>shared_timed_mutex</code>
are <i>shared mutex types</i>. [...]
</p>
<p>-2- In addition to the exclusive lock ownership mode [...]</p>
<p>-3- The expression <code>m.lock_shared()</code> is
well-formed and has the following semantics:
</p>
<blockquote>
<p>-4- <i>Preconditions:</i> [...]</p>
<p>-5- <i>Effects:</i> [...]</p>
<p>-6- <i>Synchronization:</i> [...]</p>
<p>-7- <i>Postconditions:</i> [...]</p>
<p>-8- <i><del>Return type</del><ins>Result</ins>:</i> <code>void</code><del>.</del></p>
<p>-9- <i>Throws:</i> [...]</p>
<p>-10- <i>Error conditions:</i> [...]</p>
</blockquote>
<p>-11- The expression <code>m.unlock_shared()</code> is
well-formed and has the following semantics:
</p>
<blockquote>
<p>-12- <i>Preconditions:</i> [...]</p>
<p>-13- <i>Effects:</i> [...]</p>
<p>-14- <i><del>Return type</del><ins>Result</ins>:</i> <code>void</code><del>.</del></p>
<p>-15- <i>Synchronization:</i> [...]</p>
<p>-16- <i>Throws:</i> [...]</p>
</blockquote>
<p>-17- The expression <code>m.try_lock_shared()</code> is
well-formed and has the following semantics:
</p>
<blockquote>
<p>-18- <i>Preconditions:</i> [...]</p>
<p>-19- <i>Effects:</i> [...]</p>
<p>-20- <i>Synchronization:</i> [...]</p>
<p>-21- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-22- <i>Returns:</i> <code>true</code> if the shared lock was acquired, otherwise <code>false</code>.</p>
<p>-23- <i>Throws:</i> [...]</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.6.4.5.1 <a href="https://timsong-cpp.github.io/cppwp/thread.sharedtimedmutex.requirements.general">[thread.sharedtimedmutex.requirements.general]</a> as indicated:</p>
<blockquote>
<p>-1- The standard library type <code>shared_timed_mutex</code>
is a <i>shared timed mutex type</i>. [...]
</p>
<p>-2- The expression <code>m.try_lock_shared_for(rel_time)</code> is
well-formed and has the following semantics:
</p>
<blockquote>
<p>-3- <i>Preconditions:</i> [...]</p>
<p>-4- <i>Effects:</i> [...]</p>
<p>-5- <i>Synchronization:</i> [...]</p>
<p>-6- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-7- <i>Returns:</i> <code>true</code> if the shared lock was acquired, otherwise
<code>false</code>.</p>
<p>-8- <i>Throws:</i> [...]</p>
</blockquote>
<p>-9- The expression <code>m.try_lock_shared_until(abs_time)</code> is
well-formed and has the following semantics:
</p>
<blockquote>
<p>-10- <i>Preconditions:</i> [...]</p>
<p>-11- <i>Effects:</i> [...]</p>
<p>-12- <i>Synchronization:</i> [...]</p>
<p>-13- <i><del>Return type</del><ins>Result</ins>:</i> <code>bool</code><del>.</del></p>
<p>-14- <i>Returns:</i> <code>true</code> if the shared lock was acquired, otherwise
<code>false</code>.</p>
<p>-15- <i>Throws:</i> [...]</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="2823"><a href="2823">2823</a>. <code>std::array</code> initialization is still not permissive enough</h3>
<p><b>Section:</b> 23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2016-11-16 <b>Last modified:</b> 2018-03-19</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array.overview">active issues</a> in [array.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#array.overview">issues</a> in [array.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2590" title="Aggregate initialization for std::array (Status: C++17)">2590</a>'s resolution is incomplete:
</p>
<blockquote><pre>
std::array&lt;int, 1&gt; arr{{0}};
</pre></blockquote>
<p>
should be fine, but isn't guaranteed, since <code>{0}</code> has no type. We should rather go for implicit conversion:
</p>
<blockquote><p>
An array is an aggregate (9.5.2 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.aggr">[dcl.init.aggr]</a>) that can be list-initialized with up to <code>N</code> elements 
<del>whose types are convertible to <code>T</code></del><ins>that can be implicitly converted to <code>T</code></ins>.
</p></blockquote>

<p><i>[2016-11-26, Tim Song comments]</i></p>

<p> 
This is not possible as written, because due to the brace elision rules for aggregate initialization,
<code>std::array&lt;int, 2&gt; arr{{0}, {1}};</code> will never work: the <code>{0}</code> 
is taken as initializing the inner array, and the <code>{1}</code> causes an error.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 2; consensus is that the P/R is not quite right.</p>

<p><i>[2018-3-14 Wednesday evening issues processing; priority to 3; move to Open]</i></p>

<p>Jens: There's nothing you can do about the double braces in std::array. That's a core thing.</p>
<p>STL to write paper to resolve this.</p>



<p id="res-2823"><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Change 23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> p2 as indicated:</p>

<blockquote>
<p>
-2- An <code>array</code> is an aggregate (9.5.2 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.aggr">[dcl.init.aggr]</a>) that can be list-initialized with up to <code>N</code> 
elements <del>whose types are convertible</del><ins>that can be implicitly converted</ins> to <code>T</code>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2827"><a href="2827">2827</a>. <code>is_trivially_constructible</code> and non-trivial destructors</h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-17 <b>Last modified:</b> 2023-05-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>
struct S 
{
  ~S(); // non-trivial
};

static_assert(std::is_trivially_constructible&lt;S&gt;::value, "");
</pre></blockquote>
<p>
Should the assert pass? Implementations disagree.
<p/>
Per 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>'s Table 38, this trait looks at whether the following variable definition is 
known to call no operation that is not trivial:
</p>
<blockquote><pre>
S t(create&lt;Args&gt;()...);
</pre></blockquote>
<p>
... where <code>Args</code> is an empty pack in this case. That variable definition results in a call to the <code>S</code> destructor. 
Should that call be considered by the trait?
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>
<p>This issue interacts with <a href="2116" title="is_nothrow_constructible and destructors (Status: Open)">2116</a></p>

<p><i>[2020-01-24; Peter Dimov comments]</i></p>

<p>
<code>std::is_trivially_copy_constructible_v&lt;D&gt;</code>, where <code>D</code> is
</p>
<blockquote><pre>
struct D
{
  ~D() {}
};
</pre></blockquote>
<p>
reports <code>false</code>. This is because the definition of
<code>is_trivially_copy_constructible</code> requires the invented variable 
definition <code>T t(declval&lt;Args&gt;()...);</code>, which in our case is 
<code>D t(declval&lt;D&gt;());</code>, to not call any nontrivial operations.
<p/>
This is interpreted by implementations to include the destructor call,
presumably for consistency with <code>is_nothrow_copy_constructible</code>. 
But that's wrong; the copy constructor <em>is</em> trivial.
<p/>
As a consequence, <code>variant&lt;D&gt;</code> also doesn't have a trivial 
copy constructor, which causes (completely unnecessary) inefficiencies 
when said <code>variant</code> is copied.
</p>

<p><i>[2023-05-25; May 2023 mailing]</i></p>

<p>Alisdair provided <a href="https://wg21.link/P2842R0" title=" Destructor Semantics Do Not Affect Constructible Traits">P2842R0</a>.</p>



<p id="res-2827"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2829"><a href="2829">2829</a>. LWG 2740 leaves behind vacuous words</h3>
<p><b>Section:</b> 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-24 <b>Last modified:</b> 2020-06-13</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.observe">active issues</a> in [optional.observe].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.observe">issues</a> in [optional.observe].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After applying LWG <a href="2740" title="constexpr optional&lt;T&gt;::operator-&gt; (Status: C++17)">2740</a>, we have:
</p>
<blockquote>
<pre>
constexpr const T* operator-&gt;() const;
constexpr T* operator-&gt;();
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <code>*this</code> contains a value.
<p/>
-2- <i>Returns:</i> <code>val</code>.
<p/>
-3- <i>Throws:</i> Nothing.
<p/>
-4- <i>Remarks:</i> These functions shall be <code>constexpr</code> functions.
</p>
</blockquote>
</blockquote>
<p>
Paragraph 4 is completely superfluous. We already said these functions were <code>constexpr</code> in the synopsis. Can it be removed?
</p>

<p><i>[Issues Telecon 16-Dec-2016]</i></p>

<p>Priority 2</p>
<p>Jonathan notes: Although Richard is correct, I suggest we don't strike the paragraph, so that we 
remember to fix it as part of <a href="2833" title="Library needs to specify what it means when it declares a function constexpr (Status: Open)">2833</a>, when we know how to say
this properly.</p>

<p><i>[2018-06 Rapperswil Thursday issues processing]</i></p>

<p>Status to Open; also see 7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>/6 and <a href="2289" title="constexpr guarantees of defaulted functions still insufficient (Status: Open)">2289</a>.</p>

<p><i>[2020-06-08 Nina Dinka Ranns comments]</i></p>

<p>
The revised wording provided by LWG <a href="2833" title="Library needs to specify what it means when it declares a function constexpr (Status: Open)">2833</a> should resolve this issue as well.
</p>


<p id="res-2829"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2833"><a href="2833">2833</a>. Library needs to specify what it means when it declares a function <code>constexpr</code></h3>
<p><b>Section:</b> 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-11-28 <b>Last modified:</b> 2025-08-22</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.ctor">active issues</a> in [variant.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.ctor">issues</a> in [variant.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library has lots of functions declared <code>constexpr</code>, but it's not clear what that means. The <code>constexpr</code> 
keyword implies that there needs to be <em>some</em> invocation of the function, for <em>some</em> set of template 
arguments and function arguments, that is valid in a constant expression (otherwise the program would be ill-formed, 
with no diagnostic required), along with a few side conditions. I suspect the library intends to require something a 
lot stronger than that from implementations (something along the lines of "all calls that could reasonably be constant 
subexpressions are in fact constant subexpressions, unless otherwise stated").
<p/>
[variant.ctor]/1 contains this, which should also be fixed:
</p>
<blockquote><p>
"This function shall be <code>constexpr</code> if and only if the value-initialization of the alternative type <code>T0</code> 
would satisfy the requirements for a <code>constexpr</code> function."
</p></blockquote>
<p>
This is the wrong constraint: instead of constraining whether the function is <code>constexpr</code>, we should constrain 
whether a call to it is a constant subexpression.
</p>
<p>
<b>Daniel:</b>
<p/>
This is has some considerable overlap with LWG <a href="2289" title="constexpr guarantees of defaulted functions still insufficient (Status: Open)">2289</a> but is phrased in a more general way.
</p>

<p><i>[2016-12-16, Issues Telecon]</i></p>

<p>Priority 2; this is also the general case of <a href="2829" title="LWG 2740 leaves behind vacuous words (Status: Open)">2829</a>.</p>

<p><i>[2017-02-20, Alisdair comments and suggests concrete wording]</i></p>

<p>
Below is is draft wording I was working on at Issaquah to try to address both issues.
</p>

<p><i>[2017-11 Albuquerque Wednesday issue processing]</i></p>

<p>Status to Open; really needs a paper.</p>
<p>STL says "What about <code>plus&lt;T&gt;</code>?"  <code>plus&lt;int&gt;</code> needs to be usable in a constexpr context, but <code>plus&lt;string&gt;</code> can't be.</p>

<p><i>[2017-11 Albuquerque Saturday issues processing]</i></p>

<p>Geoffrey to write a paper resolving this.</p>

<p><i>[2018-06 Rapperswil Thursday issues processing]</i></p>

<p>Geoffrey has been unable to write this paper due to time constraints. He wrote up his progress
<a href="http://lists.isocpp.org/lib/2018/04/6587.php">here</a>. Daniel has offered to help someone
to write this paper; he's willing to be a co-author.</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Michael Wong to investigate.</p>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4640">N4640</a>.
</p>

<ol>
<li>
<p>
Modify 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:
</p>
<blockquote>
<h3>17.6.5.6 <code>constexpr</code> functions and constructors [constexpr.functions]</h3>
<p>
-1- This International Standard explicitly requires that certain standard library functions are
<code>constexpr</code> (9.2.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>).  <ins>If the specification for a templated entity
requires that it shall be a <code>constexpr</code> templated entity, then that
templated entity shall be usable in a constant expression.</ins>.  An
implementation <del>shall not</del><ins>may</ins> declare
<del>any</del><ins>additional</ins> standard library function signature as
<code>constexpr</code> <del>except for those where it is explicitly required</del>.
Within any header that provides any non-defining declarations of
<code>constexpr</code> functions or constructors an implementation shall provide
corresponding definitions.
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-06-08 Nina Dinka Ranns comments and provides alternative wording]</i></p>

<p>
The revised wording draft also resolves LWG <a href="2289" title="constexpr guarantees of defaulted functions still insufficient (Status: Open)">2289</a>, LWG <a href="2829" title="LWG 2740 leaves behind vacuous words (Status: Open)">2829</a>, and LWG <a href="3215" title="variant default constructor has vague constexpr requirements (Status: New)">3215</a>.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol style="list-style-type: none">
<li>
<p>
1. Modify 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:
</p>
<blockquote>
<p>
-1- This document explicitly requires that certain standard library functions are <code>constexpr</code> 
(9.2.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>). An implementation shall not declare any standard library function signature 
as <code>constexpr</code> except for those where it is explicitly required. Within any header 
that provides any non-defining declarations of constexpr functions or constructors an implementation 
shall provide corresponding definitions.
<p/>
<ins>-?- Let <code>F</code> denote a standard library function template or member function of a class
template. If the specification of <code>F</code> declares it to be <code>constexpr</code>, unless otherwise specified, 
then <code>F</code> can be used in a constant expression if and only if all the expressions that are evaluated as 
specified in the description of <code>F</code>'s semantics can be used in a constant expression.</ins>
</p>
</blockquote>
</li>

<li>
<p>
2. - 10. [&hellip;] // Remainder of Nina's update
</p>
</li>
</ol>
</blockquote>

<p><i>[2020-10-02 Jens Maurer improves wording]</i></p>

<p>
Specifically the wording for 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> needs improvement and is updated below.
</p>

<p><i>[2020-10-02 Tim Song comments]</i></p>

<p>
The new wording doesn't cover the following example:
</p>
<blockquote><pre>
// global scope
int x;
int y;

constexpr int j = (std::swap(x, y), 0); // error
</pre></blockquote>
<ul>
<li><p><code>swap</code> is a "standard library function template...declared <code>constexpr</code>"</p></li>
<li><p><code>x</code> and <code>y</code> are (lvalue) constant expressions</p></li>
<li><p><code>std::swap(x, y)</code> is plainly not a constant expression</p></li>
</ul>

<p><i>[2020-10-04 Jens Maurer comments]</i></p>

<p>
Yes, we're still lacking text for that (and maybe Nina's old text helps for that).
</p>

<p><i>[2020-12-14; Jiang An comments]</i></p>

<p>
The item "constexpr functions" is also used in 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>/14 and 
24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>/16, and such usage should also be modified by this issue here.
</p>

<p><i>[St. Louis 2024-06-24;
Re-confirmed Tim's previous observation, new P/R needed.
Jens says there are two ways that <code class='backtick'>swap</code> could work, and the library doesn't
actually say how it does what it does, so it's not possible for a reader to
know whether they can expect it to be usable in a constant expression.
]</i></p>


<p><i>[2025-08-22; Discussion of editorial issue #4954]</i></p>

<p>
During the discussion of <a href="https://github.com/cplusplus/draft/issues/4954">editorial issue #4954</a>
it has been suggested that this issue here should also attempt to find a replacement for the 
definition of the term "constant initializer" which got lost by 
<a href="https://wg21.link/cwg2366">CWG 2366</a> but is still referenced by 24.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/istream.iterator.cons">[istream.iterator.cons]</a> p3.
</p>



<p id="res-2833"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4861" title=" Working Draft, Standard for Programming Language C++">N4861</a>.
</p>

<ol>
<li>
<p>
Modify 16.4.6.7 <a href="https://timsong-cpp.github.io/cppwp/constexpr.functions">[constexpr.functions]</a> as indicated:
</p>
<blockquote>
<p>
-1- This document explicitly requires that certain standard library functions are <code>constexpr</code> 
(9.2.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>). An implementation shall not declare any standard library function signature 
as <code>constexpr</code> except for those where it is explicitly required. Within any header 
that provides any non-defining declarations of constexpr functions or constructors an implementation 
shall provide corresponding definitions.
<p/>
<ins>-?- Let <code>F</code> denote a standard library function template or member function of a class template 
declared <code>constexpr</code>. Unless otherwise specified, a function call expression (7.6.1.3 <a href="https://timsong-cpp.github.io/cppwp/expr.call">[expr.call]</a>) 
whose <i>postfix-expression</i> names <code>F</code> is a constant expression if all of the argument subexpressions 
are constant expressions.</ins>
</p>
</blockquote>
</li>

<li>
<p>
Modify 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a> as indicated:
</p>
<blockquote>
<p>
-2- The defaulted <del>move and copy</del> constructor<ins>s</ins><del>, respectively,</del> of 
<code>pair</code> <del>is a constexpr function</del><ins>can be used in a constant expression</ins> if and only if all
required element-wise initializations <del>for move and copy, respectively, would satisfy the requirements for a
constexpr function</del><ins>can be used in a constant expression</ins>.
</p>
</blockquote>
</li>

<li>
<p>
Modify 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:
</p>
<blockquote>
<p>
-3- The defaulted <del>move and copy</del> constructor<ins>s</ins><del>, respectively,</del> of <code>tuple</code> 
<del>is a constexpr function</del><ins>can be used in a constant expression</ins> if and only if all
required element-wise initializations <del>for move and copy, respectively, would satisfy the requirements for a
constexpr function</del><ins>can be used in a constant expression</ins>. The defaulted <del>move and copy</del> 
constructor<ins>s</ins> of <code>tuple&lt;&gt;</code> <del>are constexpr functions</del><ins>can be used in a constant 
expression</ins>. 
</p>
</blockquote>
</li>

<li>
<p>
Modify 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:
</p>
<blockquote>
<pre>
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- <i>Remarks:</i> No contained value is initialized. <del>For every object type <code>T</code> these constructors 
are constexpr constructors (9.2.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.constexpr">[dcl.constexpr]</a>).</del>
</p>
</blockquote>
[&hellip;]
<pre>
template&lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-12- [&hellip;]
<p/>
-13- [&hellip;]
<p/>
-14- [&hellip;]
<p/>
-15- [&hellip;]
<p/>
<del>-16- <i>Remarks:</i> If <code>T</code>'s constructor selected for the initialization is a constexpr constructor, 
this constructor is a constexpr constructor.</del> 
</p>
</blockquote>
<pre>
template&lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-17- [&hellip;]
<p/>
-18- [&hellip;]
<p/>
-19- [&hellip;]
<p/>
-20- [&hellip;]
<p/>
<del>-21- <i>Remarks:</i> If <code>T</code>'s constructor selected for the initialization is a constexpr constructor, 
this constructor is a constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;class U = T&gt; constexpr explicit(<i>see below</i>) optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-22- [&hellip;]
<p/>
-23- [&hellip;]
<p/>
-24- [&hellip;]
<p/>
-25- [&hellip;]
<p/>
-26- <i>Remarks:</i> <del>If <code>T</code>'s constructor selected for the initialization is a constexpr constructor, 
this constructor is a constexpr constructor.</del> The expression inside <code>explicit</code> is equivalent to:
</p>
<blockquote><pre>
!is_convertible_v&lt;U, T&gt;
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> as indicated:
</p>
<blockquote>
<pre>
constexpr const T* operator-&gt;() const;
constexpr T* operator-&gt;();
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- [&hellip;]
<p/>
-3- [&hellip;]
<p/>
<del>-4- <i>Remarks:</i> These functions are constexpr functions.</del>
</p>
</blockquote>
<pre>
constexpr const T&amp; operator*() const&amp;;
constexpr T&amp; operator*() &amp;;
</pre>
<blockquote>
<p>
-5- [&hellip;]
<p/>
-6- [&hellip;]
<p/>
-7- [&hellip;]
<p/>
<del>-8- <i>Remarks:</i> These functions are constexpr functions.</del>
</p>
</blockquote>
[&hellip;]
<pre>
constexpr explicit operator bool() const noexcept;
</pre>
<blockquote>
<p>
-11- <i>Returns:</i> <code>true</code> if and only if <code>*this</code> contains a value.
<p/>
<del>-12- <i>Remarks:</i> This function is a constexpr function.</del>
</p>
</blockquote>
<pre>
constexpr bool has_value() const noexcept;
</pre>
<blockquote>
<p>
-13- <i>Returns:</i> <code>true</code> if and only if <code>*this</code> contains a value.
<p/>
<del>-14- <i>Remarks:</i> This function is a constexpr function.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 22.5.7 <a href="https://timsong-cpp.github.io/cppwp/optional.relops">[optional.relops]</a> as indicated:
</p>
<blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- [&hellip;]
<p/>
<del>-3- <i>Remarks:</i> Specializations of this function template for which <code>*x == *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-4- [&hellip;]
<p/>
-5- [&hellip;]
<p/>
<del>-6- <i>Remarks:</i> Specializations of this function template for which <code>*x != *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-7- [&hellip;]
<p/>
-8- [&hellip;]
<p/>
<del>-9- <i>Remarks:</i> Specializations of this function template for which <code>*x &lt; *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-10- [&hellip;]
<p/>
-11- [&hellip;]
<p/>
<del>-12- <i>Remarks:</i> Specializations of this function template for which <code>*x &gt; *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-13- [&hellip;]
<p/>
-14- [&hellip;]
<p/>
<del>-15- <i>Remarks:</i> Specializations of this function template for which <code>*x &lt;= *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-16- [&hellip;]
<p/>
-17- [&hellip;]
<p/>
<del>-18- <i>Remarks:</i> Specializations of this function template for which <code>*x &gt;= *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
<pre>
template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
  constexpr compare_three_way_result_t&lt;T,U&gt;
    operator&lt;=&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);
</pre>
<blockquote>
<p>
-19- <i>Returns:</i> If <code>x &amp;&amp; y</code>, <code>*x &lt;=&gt; *y</code>; otherwise <code>bool(x) &lt;=&gt; bool(y)</code>.
<p/>
<del>-20- <i>Remarks:</i> Specializations of this function template for which <code>*x &lt;=&gt; *y</code> is a core constant 
expression are constexpr functions.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> as indicated:
</p>
<blockquote>
<pre>
constexpr variant() noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- [&hellip;]
<p/>
-3- [&hellip;]
<p/>
-4- [&hellip;]
<p/>
-5- [&hellip;]
<p/>
-6- <i>Remarks:</i> <del>This function is <code>constexpr</code> if and only if the value-initialization of the 
alternative type <code>T<sub>0</sub></code> would satisfy the requirements for a constexpr function.</del> The 
expression inside <code>noexcept</code> is equivalent to <code>is_nothrow_default_constructible_v&lt;T<sub>0</sub>&gt;</code>. 
[<i>Note:</i> See also class <code>monostate</code>. &mdash; <i>end note</i>]
</p>
</blockquote>
[&hellip;]
<pre>
template&lt;class T&gt; constexpr variant(T&amp;&amp; t) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-14- [&hellip;]
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The expression inside <code>noexcept</code> is equivalent to 
<code>is_nothrow_constructible_v&lt;T<sub><i>j</i></sub>, T&gt;</code>. <del>If <code>T<sub><i>j</i></sub></code>'s 
selected constructor is a constexpr constructor, this constructor is a constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class... Args&gt; constexpr explicit variant(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-20- [&hellip;]
<p/>
[&hellip;]
<p/>
<del>-24- <i>Remarks:</i> If <code>T</code>'s selected constructor is a constexpr constructor, this constructor is a 
constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;class T, class U, class... Args&gt;
  constexpr explicit variant(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-25- [&hellip;]
<p/>
[&hellip;]
<p/>
<del>-29- <i>Remarks:</i> If <code>T</code>'s selected constructor is a constexpr constructor, this constructor is 
a constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;size_t I, class... Args&gt; constexpr explicit variant(in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-30- [&hellip;]
<p/>
[&hellip;]
<p/>
<del>-34- <i>Remarks:</i> If <code>T<sub><i>I</i></sub></code>'s selected constructor is a constexpr constructor, 
this constructor is a constexpr constructor.</del>
</p>
</blockquote>
<pre>
template&lt;size_t I, class U, class... Args&gt;
  constexpr explicit variant(in_place_index_t&lt;I&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-35- [&hellip;]
<p/>
[&hellip;]
<p/>
<del>-38- <i>Remarks:</i> If <code>T<sub><i>I</i></sub></code>'s selected constructor is a constexpr constructor, 
this constructor is a constexpr constructor.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 24.5.4.11 <a href="https://timsong-cpp.github.io/cppwp/move.sent.ops">[move.sent.ops]</a> as indicated:
</p>
<blockquote>
<pre>
constexpr move_sentinel();
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Value-initializes <code>last</code>. <del>If <code>is_trivially_default_constructible_v&lt;S&gt;</code> is 
<code>true</code>, then this constructor is a constexpr constructor.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 22.11.3 <a href="https://timsong-cpp.github.io/cppwp/bit.cast">[bit.cast]</a> as indicated:
</p>
<blockquote>
<pre>
template&lt;class To, class From&gt;
  constexpr To bit_cast(const From&amp; from) noexcept;
</pre>
<blockquote>
<p>
-1- [&hellip;]
<p/>
-3- <i>Remarks:</i> This function <del>is <code>constexpr</code></del><ins>can be used in a constant expression</ins> 
if and only if <code>To</code>, <code>From</code>, and the types of all subobjects of <code>To</code> and From are types 
<code>T</code> such that:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; <code>is_union_v&lt;T&gt;</code> is <code>false</code>;</p></li>
<li><p>(3.2) &mdash; <code>is_pointer_v&lt;T&gt;</code> is <code>false</code>;</p></li>
<li><p>(3.3) &mdash; <code>is_member_pointer_v&lt;T&gt;</code> is <code>false</code>;</p></li>
<li><p>(3.4) &mdash; <code>is_volatile_v&lt;T&gt;</code> is <code>false</code>; and</p></li>
<li><p>(3.5) &mdash; <code>T</code> has no non-static data members of reference type.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

<li>
<p>
Modify 30.5 <a href="https://timsong-cpp.github.io/cppwp/time.duration">[time.duration]</a> as indicated:
</p>

<blockquote>
<p>
-5- The defaulted <del>copy</del> constructor<ins>s</ins> of duration <del>shall be a constexpr 
function</del><ins>can be used in a constant expression</ins> if and only if the required initialization
of the member <code>rep_</code> <del>for copy and move, respectively, would satisfy the requirements for 
a constexpr function</del><ins>can be used in a constant expression</ins>.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="2844"><a href="2844">2844</a>. Stability of <code>a_uniq.insert(i, j)</code></h3>
<p><b>Section:</b> 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2016-12-14 <b>Last modified:</b> 2020-02-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we write <code>a_uniq.insert(i, j)</code> and <code>[i, j)</code> has multiple elements with keys that compare equivalent, 
which ones get inserted? Consider, for example, inserting into a <code>map&lt;string, int&gt;</code> with
</p>
<blockquote><pre>
m.insert({{"red", 5}, {"green", 3}, {"red", 7}, {"blue", 2}, {"pink", 6}});
</pre></blockquote>
<p>
Which value for <code>"red"</code> will the map have?
<p/>
On my implementation we got <code>"red" -&gt; 5</code>, and I suspect that's true on most or all implementations, but I don't believe 
that's guaranteed by anything in the requirements. The wording in Table 90 just says that it "inserts each element from 
the range <code>[i, j)</code> if and only if there is no element with key equivalent to the key of that element", but that 
doesn't tell us what happens if <code>[i, j)</code> contains duplicate keys because it doesn't say what order the insertions 
are performed in. The standard should either guarantee that the first value is the one that gets inserted, or explicitly 
say that this is unspecified.
<p/>
The same issue applies to the range constructor, and to the unordered associative containers.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; Nico to provide wording.</p>

<p><i>[2020-02-14, Prague]</i></p>

<p>
LWG discussion. Suggestion to specify that we like the direction of the wording for <code>insert</code> of
unordered containers, but would also like to clarify that the loop is meant to be "in order" of the 
sequence elements.
<p/>
Daniel K. volunteered to provide such wording.
</p>


<p id="res-2844"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2845"><a href="2845">2845</a>. <code>enable_if</code>, <code>result_of</code>, <code>common_type</code> and <code>aligned_storage</code> do not meet the definition 
of <code>TransformationTrait</code></h3>
<p><b>Section:</b> 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-12-14 <b>Last modified:</b> 2017-02-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.rqmts">issues</a> in [meta.rqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[meta.rqmts]/3 defines <code>TransformationTrait</code> as follows:
</p>
<blockquote><p>
A <code><i>TransformationTrait</i></code> modifies a property of a type. It shall be a class template that takes 
one template type argument and, optionally, additional arguments that help define the modification. It shall 
define a publicly accessible nested type named <code>type</code>, which shall be a synonym for the modified type.
</p></blockquote>
<p>
<code>enable_if</code>, <code>result_of</code> and <code>common_type</code> do not necessarily "define a publicly accessible nested type named <code>type</code>". 
<code>aligned_storage</code> takes no template type argument (it only has two non-type parameters). Yet [meta.trans]/2 
says that they are all <code>TransformationTraits</code>.
<p/>
Incidentally, with the exception of <code>decay</code>, it's not clear that any of the traits in [meta.trans.other] 
could really be described as "modify[ing] a property of a type".
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>


<p id="res-2845"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2846"><a href="2846">2846</a>. Undefined phrase "effectively cast"</h3>
<p><b>Section:</b> 29.4.10 <a href="https://timsong-cpp.github.io/cppwp/cmplx.over">[cmplx.over]</a>, 29.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-12-15 <b>Last modified:</b> 2019-03-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cmplx.over">issues</a> in [cmplx.over].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [cmplx.over] and [cmath.syn], when talking about "sufficient additional overloads", we use the phrase
"effectively cast", but that is not a defined term.
<p/>
A hostile interpretation could read "<code>reinterpret_cast</code>" here.
<p/>
Likely we mean "apply floating-point promotions, floating-integral
conversions, and floating-point conversions", but that should be
spelled out somewhere, e.g. in the library definitions section.
<p/>
(Source: <a href="https://github.com/cplusplus/draft/issues/1248">Editorial issue #1248</a>)
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>

<p><i>[2019-03-16; Daniel comments and provides wording]</i></p>

<p>
I decided to use the form "implicitly converted" and to refer to 7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a> for 29.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a> and
29.4.10 <a href="https://timsong-cpp.github.io/cppwp/cmplx.over">[cmplx.over]</a>, because those conversions can all be done implicitly. This also holds for the 
<code>pow</code> specification 29.4.10 <a href="https://timsong-cpp.github.io/cppwp/cmplx.over">[cmplx.over]</a> p3, because the described conversions of
<code>complex&lt;T&gt;</code> to <code>complex&lt;U&gt;</code> involve only the need of non-explicit constructors.
</p>


<p id="res-2846"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Change 29.4.10 <a href="https://timsong-cpp.github.io/cppwp/cmplx.over">[cmplx.over]</a>, as indicated:</p>

<blockquote>
<p>
-2- The additional overloads shall be sufficient to ensure:
<blockquote>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If the argument has type <code>long double</code>, then it is 
<del>effectively cast</del><ins>implicitly converted (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>)</ins> to <code>complex&lt;long double&gt;</code>.</p></li>
<li><p>(2.2) &mdash; Otherwise, if the argument has type <code>double</code> or an integer type, then it is 
<del>effectively cast</del><ins>implicitly converted</ins> to <code>complex&lt;double&gt;</code>.</p></li>
<li><p>(2.3) &mdash; Otherwise, if the argument has type <code>float</code>, then it is 
<del>effectively cast</del><ins>implicitly converted</ins> to <code>complex&lt;float&gt;</code>.</p></li>
</ol>
</blockquote>
<p/>
-3 Function template <code>pow</code> shall have additional overloads sufficient to ensure, for a call with at least one argument
of type <code>complex&lt;T&gt;</code>:
<blockquote>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If either argument has type <code>complex&lt;long double&gt;</code> or type <code>long double</code>, 
then both arguments are <del>effectively cast</del><ins>implicitly converted (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>)</ins> to 
<code>complex&lt;long double&gt;</code>.</p></li>
<li><p>(3.2) &mdash; Otherwise, if either argument has type <code>complex&lt;double&gt;</code>, <code>double</code>, 
or an integer type, then both arguments are <del>effectively cast</del><ins>implicitly converted</ins> 
to <code>complex&lt;double&gt;</code>.</p></li>
<li><p>(3.3) &mdash; Otherwise, if either argument has type <code>complex&lt;float&gt;</code> or <code>float</code>, 
then both arguments are <del>effectively cast</del><ins>implicitly converted</ins> to 
<code>complex&lt;float&gt;</code>.</p></li>
</ol>
</blockquote>
</p>
</blockquote>

</li>

<li><p>Change 29.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a>, as indicated:</p>

<blockquote>
<p>
-2- For each set of overloaded functions within <code>&lt;cmath&gt;</code>, with the exception of <code>abs</code>, there 
shall be additional overloads sufficient to ensure:
<blockquote>
<ol>
<li><p>If any argument of arithmetic type corresponding to a <code>double</code> parameter has type <code>long double</code>, then
all arguments of arithmetic type (6.9.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>) corresponding to <code>double</code> parameters are 
<del>effectively cast</del><ins>implicitly converted (7.3 <a href="https://timsong-cpp.github.io/cppwp/conv">[conv]</a>)</ins> to <code>long double</code>.</p></li>
<li><p>Otherwise, if any argument of arithmetic type corresponding to a <code>double</code> parameter has type <code>double</code>
or an integer type, then all arguments of arithmetic type corresponding to <code>double</code> parameters are
<del>effectively cast</del><ins>implicitly converted</ins> to <code>double</code>.</p></li>
<li><p>Otherwise, all arguments of arithmetic type corresponding to <code>double</code> parameters have type <code>float</code>.</p></li>
</ol>
</blockquote>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2847"><a href="2847">2847</a>. <code>sin(float)</code> should call <code>sinf(float)</code></h3>
<p><b>Section:</b> 29.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-12-15 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cmath.syn">active issues</a> in [cmath.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#cmath.syn">issues</a> in [cmath.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With <a href="https://wg21.link/p0175r1">P0175R1</a>, we now show in [cmath.syn] three overloads for
the <code>sin</code> function: One taking a <code>float</code>, one taking a <code>double</code>,
and one taking a <code>long double</code>. However, there is no statement that <code>sin(long double)</code> 
should actually invoke <code>sinl</code>, presumably delivering extra precision.
<p/>
An implementation like
</p>
<blockquote><pre>
inline long double sin(long double x)
{ return sinf(x); }
</pre></blockquote>
<p>
seems to satisfy the "effectively cast" requirement, but is certainly unintentional.
<p/>
The same issue arises for all math functions inherited from C.
<p/>
(Source: <a href="https://github.com/cplusplus/draft/issues/1247">Editorial issue #1247</a>)
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3</p>


<p id="res-2847"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2848"><a href="2848">2848</a>. Pass-through threshold for pool allocator</h3>
<p><b>Section:</b> 20.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.pool.options">[mem.res.pool.options]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2016-12-15 <b>Last modified:</b> 2017-02-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.5.5.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.pool.options">[mem.res.pool.options]</a> p3 talks about a "pass-through-threshold".
<p/>
First, the phrase is not defined and it seems it could be easily avoided given the context.
<p/>
Second, given the phrasing here, it seems the implementation is essentially allowed to 
ignore the value <code>largest_required_pool_block</code> as it sees fit. It is unclear whether 
that is the intention.
</p>

<p><i>[2017-01-27 Telecon]</i></p>

<p>Priority 3; Jonathan will ask Alisdair for wording.</p>


<p id="res-2848"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2858"><a href="2858">2858</a>. LWG 2472: actually an incompatibility with C++03</h3>
<p><b>Section:</b> 24.5.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2017-01-28 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterators">issues</a> in [reverse.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Further to LWG <a href="2472" title="Heterogeneous comparisons in the standard library can result in ambiguities (Status: New)">2472</a>, the case of <code>reverse_iterator</code> comparisons is a regression introduced 
by LWG <a href="280" title="Comparison of reverse_iterator to const reverse_iterator (Status: CD1)">280</a>.
<p/>
Consider the following program:
</p>
<blockquote><pre>
#include &lt;utility&gt;
#include &lt;iterator&gt;

using namespace std::rel_ops;

bool f(std::reverse_iterator&lt;int *&gt; it) { return it != it; }
</pre></blockquote>
<p>
Under C++03, the <code>operator!=</code> in lib.reverse.iterator is more specialized than the <code>operator!=</code> in <code>std::rel_ops</code>.
<p/>
Following LWG <a href="280" title="Comparison of reverse_iterator to const reverse_iterator (Status: CD1)">280</a>, neither <code>operator!=</code> candidate is more specialized than the other. The program is 
observed to fail with libc++.
<p/>
Online compiler example, see <a href="http://melpon.org/wandbox/permlink/aeOn1wiOi2CRKwwc">here</a>.
<p/>
Suggested resolution:
<p/>
Reintroduce the homogeneous comparison operators from C++03 alongside the new ones.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 4. STL to write a paper deprecating <code>relops</code> Alisdair to provide an example for Annex C.</p>


<p id="res-2858"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4618">N4618</a>.</p>

<ol>
<li><p>Modify 24.5.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators">[reverse.iterators]</a>, class template <code>reverse_iterator</code> synopsis, as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);
template &lt;class Iterator&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
</blockquote>
</li>

<li><p>Modify  [reverse.iter.op==] as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <code>x.current == y.current</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify  [reverse.iter.op&lt;] as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <code>x.current &gt; y.current</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify  [reverse.iter.op!=] as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <code>x.current != y.current</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify  [reverse.iter.op&gt;] as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <code>x.current &lt; y.current</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify  [reverse.iter.op&gt;=] as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <code>x.current &lt;= y.current</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify  [reverse.iter.op&lt;=] as indicated:</p>
<blockquote>
<pre>
template &lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
<ins>template &lt;class Iterator&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;Iterator&gt;&amp; x,
    const reverse_iterator&lt;Iterator&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> <code>x.current &gt;= y.current</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="2881"><a href="2881">2881</a>. Adopt section III of P0308R0</h3>
<p><b>Section:</b> 22.6.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.variant">issues</a> in [variant.variant].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses CH 7</b>

<p>Consider making the variant statically <code>!valueless_by_exception()</code> for cases where <code>is_nothrow_move_constructible_v&lt;T_i&gt;</code> for all alternative types <code>T<sub><i>i</i></sub></code></p>
<p>Proposed change: Adopt section III of <a href="https://wg21.link/p0308r0">P0308R0</a>.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Priority 3. This is similar to <a href="2904" title="Make variant move-assignment more exception safe (Status: C++17)">2904</a>, Casey to investigate</p>


<p id="res-2881"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="2883"><a href="2883">2883</a>. The standard library should provide <code>string_view</code> parameters instead or in addition for functions 
      defined with <code>char const *</code> or <code>string const &amp;</code> as parameter types.</h3>
<p><b>Section:</b> 27.3 <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.view">active issues</a> in [string.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view">issues</a> in [string.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses CH 9</b>

<p>
The standard library should provide <code>string_view</code> parameters instead or in addition for functions defined with 
<code>char const *</code> or <code>string const &amp;</code> as parameter types. Most notably in cases where both such 
overloads exist or where an internal copy is expected anyway.
</p>
<p>
It might be doubted that the non-null termination of <code>string_view</code> could be an issue with functions that pass 
the <code>char *</code> down to OS functions, such as <code>fstream_buf::open()</code> etc. and those shouldn't provide it 
and favour generating a <code>std::string</code> temporary instead in that case. However, <code>std::path</code> demonstrates 
it is usable to have <code>string_view</code> overloads and there might be many places where it can be handy, or even better.
</p>

<p>Proposed change: Provide the overloads for <code>std::regex</code>, the exception classes, <code>std::bitset</code>, 
<code>std::locale</code> and more.</p>

<p><i>[Post-Kona 2017]</i></p>

<p>Most (all?) of these changes were proposed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0506r0.pdf">P0506r1</a>, which was discussed by LEWG in Kona.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Status LEWG - they're already looking at this.</p>


<p id="res-2883"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="2884"><a href="2884">2884</a>. Relational operators for containers should sfinae; if the underlying type is not comparable, neither should the container be</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>, 22 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-06-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 16</b>

<p>Relational operators for containers should sfinae; if the underlying type is not comparable, neither should the container be. Same applies to <code>tuple</code> and <code>pair</code>.</p>

<p>Proposed change: Make the relational operators of containers and utility components reflect the validity of the underlying 
element types.</p>

<p><i>[
2017-06-27 Moved to LEWG after 5 positive votes on c++std-lib.
]</i></p>



<p id="res-2884"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="2885"><a href="2885">2885</a>. The relational operators of <code>optional</code> and <code>variant</code> completely reflect the semantics of the element 
types &mdash; this is inconsistent with other types in the library</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a>, 22 <a href="https://timsong-cpp.github.io/cppwp/utilities">[utilities]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Finland <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses FI 17</b>

<p>The relational operators of optional and variant completely reflect the semantics of the element types; this is inconsistent 
with other types in the library, like <code>pair</code>, <code>tuple</code> and containers. If we believe it's important that we don't 
synthesize relational operators for wrapper types, we should believe it's important for other types as well. Otherwise comparing 
containers of floating-point types and tuples/pairs etc. of floating point types will give incorrect answers.</p>
<p>Proposed change: Make the relational operators of containers and utility components reflect the semantics of the operators for the underlying element types.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Move to LEWG</p>


<p id="res-2885"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="2906"><a href="2906">2906</a>. There is no ability to supply an allocator for the control block when constructing a <code>shared_ptr</code> from a 
<code>unique_ptr</code></h3>
<p><b>Section:</b> 20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-15</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 130</b>

<p>There is no ability to supply an allocator for the control block when constructing a <code>shared_ptr</code> from a <code>unique_ptr</code>. 
Note that no further <code>shared_ptr</code> constructors need an allocator, as they all have pre-existing control blocks that are shared, 
or already have the allocator overload.</p>
<p>Proposed change: Add an additional <code>shared_ptr</code> constructor, 
<code>template &lt;class Y, class D, class A&gt; shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r, A alloc)</code>, with the same semantics 
as the existing constructor taking a <code>unique_ptr</code>, but using the <code>alloc</code> argument to supply memory as required.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Priority 3; Alisdair to provide wording</p>


<p id="res-2906"><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3 id="2922"><a href="2922">2922</a>. The <code>*_constant&lt;&gt;</code> templates do not make use of <code>template&lt;auto&gt;</code></h3>
<p><b>Section:</b> 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in [meta.type.synop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in [meta.type.synop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 171</b>

<p>The <code>*_constant&lt;&gt;</code> templates (including the proposed addition, <code>bool_constant&lt;&gt;</code>) do 
not make use of the new <code>template&lt;auto&gt;</code> feature.</p>

<p>Proposed change: Add a <code>constant&lt;&gt;</code> (subject to bikeshedding) template which uses <code>template&lt;auto&gt;</code>. </p>
<p>Define <code>integral_constant&lt;&gt;</code> as <code>using integral_constant&lt;T, V&gt; = constant&lt;T(V)&gt;</code> or <code>integral_constant&lt;T, V&gt; = constant&lt;V&gt;</code>.</p>
<p>Either remove <code>bool_constant</code>, define it as using <code>bool_constant = constant&lt;bool(B)&gt;</code> or 
<code>using bool_constant = constant&lt;B&gt;</code>.</p>

<p><i>[2017-03-03, Kona, LEWG]</i></p>

<p>
Straw polls:
</p>
<table border="1">
<caption>Name:</caption>
<tr style="text-align: left">
<td style="width:70%"><code>constant</code></td><td style="width:10%">3</td></tr>
<tr style="text-align: left">
<td><code>numeric_constant</code></td><td>8</td></tr>
<tr style="text-align: left">
<td><code>static_constant</code></td><td>1</td></tr>
<tr style="text-align: left">
<td><code>scalar_constant</code></td><td>7</td></tr>
<tr style="text-align: left">
<td><code>integer_constant</code> (Over LWG's dead body)</td><td>1</td></tr>
<tr style="text-align: left">
<td><code>auto_constant</code></td><td>4</td></tr>
<tr style="text-align: left">
<td><code>integral_c</code></td><td>7</td></tr>
<tr style="text-align: left">
<td><code>int_</code></td><td>0</td></tr>
<tr style="text-align: left">
<td colspan="2"><code>&#x200b;</code></td></tr>
<tr style="text-align: left">
<td><code>scalar_constant</code></td><td>6</td></tr>
<tr style="text-align: left">
<td><code>numeric_constant</code></td><td>3</td></tr>
<tr style="text-align: left">
<td><code>integral_c</code></td><td>5</td></tr>
</table>

<p>
Accept P0377 with "<code>scalar_constant</code>" for C++17 to address LWG 2922 and US 171:
<p/>
SF | F | N | A | SA
<p/>
0  | 1 | 3 | 7 | 5
</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Status LEWG with P0377</p>


<p id="res-2922"><b>Proposed resolution:</b></p>
<p>
</p>








<hr>
<h3 id="2923"><a href="2923">2923</a>. <code>noexcept</code> is inconsistently applied across headers which import components of the C standard library</h3>
<p><b>Section:</b> 29.7.1 <a href="https://timsong-cpp.github.io/cppwp/cmath.syn">[cmath.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> United States <b>Opened:</b> 2017-02-03 <b>Last modified:</b> 2017-07-15</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cmath.syn">active issues</a> in [cmath.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#cmath.syn">issues</a> in [cmath.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses US 172</b>

<p><code>noexcept</code> is inconsistently applied across headers which import components of the C standard library into the C++ library; 
some functions (<code>std::abort()</code>, <code>std::_Exit()</code>, etc) are defined as <code>noexcept</code> in some places, but not in others. 
Some functions which seem like they should be <code>noexcept</code> (<code>std::abs()</code>, <code>std::div()</code>, etc) are not defined as 
<code>noexcept</code>.</p>

<p>Proposed change: Make the majority of the C library functions (with exceptions such as <code>std::qsort()</code> and 
<code>std::bsearch()</code>, which can call user code) <code>noexcept</code>.</p>

<p><i>[2017-07 Toronto Thurs Issue Prioritization]</i></p>

<p>Priority 4</p>


<p id="res-2923"><b>Proposed resolution:</b></p>
<p>
</p>







<hr>
<h3 id="2931"><a href="2931">2931</a>. Missed optimization opportunity with single-argument <code>std::next</code></h3>
<p><b>Section:</b> 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Morwenn <b>Opened:</b> 2017-02-04 <b>Last modified:</b> 2018-12-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that <code>std::next</code> is missing an optimization opportunity when taking a single parameter. The standard 
mandates that <code>std::next</code> shall call <code>std::advance</code> on the passed iterator and return it. For random-access 
iterators, it means that <code>operator+=</code> will be called on the iterator. However, if a single-argument overload was 
added to <code>std::next</code>, it could call <code>++it</code> directly instead of <code>std::advance(it, 1)</code>, which means 
that <code>operator++</code> would be called instead of <code>operator+=</code>. This might make a small performance difference 
for complicated iterators such as <code>std::deque</code>'s ones, where <code>operator++</code> has a simpler logic than 
<code>operator+=</code>.
<p/>
An equivalent optimization could be allowed by adding a single-argument overload to <code>std::prev</code> too.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 3. Alisdair to provide wording.</p>

<p><i>[2018-11-30, Jonathan comments, recommending NAD]</i></p>

<p>
Jonathan suggested NAD, because the proposed "just use increment when <code>n==1</code>" optimization can be done in 
<code>std::next</code> (and/or <code>std::advance</code>, and/or complicated iterators like <code>deque::iterator</code>) without 
adding an overload. Billy said the overload would avoid metaprogramming costs for dispatching to the right 
<code>std::advance</code>, and help in non-optimized builds. Zhihao said the overload would make it clear to users that 
the <code>n==1</code> case is optimized (Jonathan thinks this is irrelevant as there's no requirement that we tell users 
what we optimize).
</p>


<p id="res-2931"><b>Proposed resolution:</b></p>
<p>
</p>






<hr>
<h3 id="2939"><a href="2939">2939</a>. Some type-completeness constraints of traits are overspecified</h3>
<p><b>Section:</b> 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2017-03-02 <b>Last modified:</b> 2024-08-21</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in [meta.type.synop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in [meta.type.synop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2797" title="Trait precondition violations (Status: Resolved)">2797</a> (RU 2) suggests that certain type-traits should be required to
diagnose violations of their pre-conditions. The basic idea is founded and I see no problems for
requiring this for the mentioned traits <code>alignment_of</code> or <code>is_base_of</code>,
for example. But if we want to require this diagnostics for some other traits, such as <code>is_convertible</code>,
<code>is_constructible</code> (and friends), or <code>is_callable</code> (and possibly some others), we really should
be sure that our current requirements are OK. 
<p/>
Unfortunately, there exists some cases, where we currently overspecify imposing complete type requirements where they
are not actually required. For example, for the following situation the answer of the trait could 
be given without ever needing the complete type of <code>X</code>:
</p>
<blockquote><pre>
struct X; // Never defined

static_assert(std::is_convertible_v&lt;X, const X&amp;&gt;);
</pre></blockquote>
<p>
Unfortunately we cannot <em>always</em> allow incomplete types, because most type constructions or conversions indeed
require a complete type, so <em>generally</em> relaxing the current restrictions is also not an option.
<p/>
The core language has a solution for this "small" gap of situations, where the response of the compiler <em>might</em>
depend on type completeness: Undefined behaviour. So, I believe we need a somewhat more detailled form to express the
intend here. Informally, I would suggest that the program should only be ill-formed in the situation described by 
LWG <a href="2797" title="Trait precondition violations (Status: Resolved)">2797</a>, if there exists the <em>possibility</em> that the compiler would require complete types for the
considered operation. The example shown above, <code>std::is_convertible_v&lt;X, const X&amp;&gt;</code>, would <b>never</b>
require the need to complete <code>X</code>, so here no violation should exist.
<p/>
The presented example might seem a tiny one, but the Standard Library type traits are extreme fundamental tools and we should
try to not give the impression that an approximate rule of the current type constraints breaks reasonable code.
<p/>
It is correct, that above example has currently undefined behaviour due to the breakage of pre-conditions, therefore
this issue suggests to fix the current situation <em>before</em> enforcing a diagnostic for such valid situations.
</p>

<p><i>[2017-03-04, Kona]</i></p>

<p>Set priority to 2. Is related to <a href="2797" title="Trait precondition violations (Status: Resolved)">2797</a>, but really needs an audit of the type traits.</p>

<p><i>[2018-08 Batavia Monday issue discussion]</i></p>

<p>Issues <a href="2797" title="Trait precondition violations (Status: Resolved)">2797</a>, <a href="2939" title="Some type-completeness constraints of traits are overspecified (Status: Open)">2939</a>, <a href="3022" title="is_convertible&lt;derived*, base*&gt; may lead to ODR (Status: Resolved)">3022</a>, and <a href="3099" title="is_assignable&lt;Incomplete&amp;, Incomplete&amp;&gt; (Status: Open)">3099</a> are all closely related. Walter to write a paper resolving them.</p>

<p><i>[2020-02 Prague Thursday issue discussion]</i></p>

<p>
Two of the issues (<a href="2797" title="Trait precondition violations (Status: Resolved)">2797</a> and <a href="3022" title="is_convertible&lt;derived*, base*&gt; may lead to ODR (Status: Resolved)">3022</a>) had been resolved by the
acceptance of <a href="https://wg21.link/p1285r0">P1285R0</a>.
</p>

<p><i>[2024-05-09; Jonathan provides wording]</i></p>

<p>
We could also relax the type completeness requirements for
<code class='backtick'>reference_converts_from_temporary</code> and <code class='backtick'>reference_constructs_from_temporary</code>,
as the result is always false if the first type is a non-reference,
so we don't need complete types in that case.
This doesn't seem important to support, but if we wanted to then we could say:
<blockquote>
<ins> Either <code class='backtick'>T</code> is not a reference type, or </ins>
<del><code class='backtick'>T</code> and</del>
<code class='backtick'>U</code> shall be <ins>a complete type</ins> <del>complete types</del>,
<i>cv</i> <code class='backtick'>void</code>, or <ins>an array</ins><del>arrays</del> of unknown bound.
</blockquote>
</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.</p>
<blockquote>
<ol>
<li>
In 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> Table 51,
change the <b>Preconditions</b> text for
<code class='backtick'>is_constructible</code>, <code class='backtick'>is_trivially_constructible</code>, <code class='backtick'>is_nothrow_constructible</code>,
<code class='backtick'>is_convertible</code>, and <code class='backtick'>is_nothrow_convertible</code>,
as indicated.
<blockquote>
<table style="border: 1px solid; border-spacing: 1.5em">
<thead style="text-align: center">
<tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr>
</thead>
<tbody style="vertical-align: top">
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
<tr>
<td>
<pre><code>template&lt;class T, class... Args&gt;
struct is_constructible;</code></pre>
</td>
<td>
For a function type <code class='backtick'>T</code> or
for a <i>cv</i> <code class='backtick'>void</code> type <code class='backtick'>T</code>,
<code>is_constructible_v&lt;T, Args...&gt;</code>
is <code class='backtick'>false</code>,
otherwise <i>see below</i>
<ins>.</ins>
</td>
<td>
<ins>
Either <code class='backtick'>T</code> is a reference type and <code class='backtick'>Args</code> contains a single type that
is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;T&gt;</code>, or
</ins>
<code class='backtick'>T</code> and all types in the template parameter pack <code class='backtick'>Args</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
<tr>
<td>
<pre><code>template&lt;class T, class... Args&gt;
struct is_trivially_constructible;</code></pre>
</td>
<td>
<code>is_constructible_v&lt;T, Args...&gt;</code>
is <code class='backtick'>true</code> and the variable definition for <code class='backtick'>is_constructible</code>,
as defined below, is known to call no operation that is not trivial
(6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.types.general">[basic.types.general]</a>, 11.4.4 <a href="https://timsong-cpp.github.io/cppwp/special">[special]</a>).
</td>
<td>
<ins>
Either <code class='backtick'>T</code> is a reference type and <code class='backtick'>Args</code> contains a single type that
is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;T&gt;</code>, or
</ins>
<code class='backtick'>T</code> and all types in the template parameter pack <code class='backtick'>Args</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
<tr>
<td>
<pre><code>template&lt;class T, class... Args&gt;
struct is_nothrow_constructible;</code></pre>
</td>
<td>
<code>is_constructible_v&lt;T, Args...&gt;</code>
is <code class='backtick'>true</code> and the variable definition for <code class='backtick'>is_constructible</code>,
as defined below, is known not to throw any exceptions
(7.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/expr.unary.noexcept">[expr.unary.noexcept]</a>).
</td>
<td>
<ins>
Either <code class='backtick'>T</code> is a reference type and <code class='backtick'>Args</code> contains a single type that
is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;T&gt;</code>, or
</ins>
<code class='backtick'>T</code> and all types in the template parameter pack <code class='backtick'>Args</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
</tbody>
</table>
</blockquote>
</li>
<li>
In 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> Table 53,
change the <b>Comments</b> text for
<code class='backtick'>is_convertible</code> and <code class='backtick'>is_nothrow_convertible</code>
as indicated.
<blockquote>
<table style="border: 1px solid; border-spacing: 1.5em">
<thead style="text-align: center">
<tr><th>Template</th><th>Condition</th><th>Comments</th></tr>
</thead>
<tbody style="vertical-align: top">
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
<tr>
<td>
<pre><code>template&lt;class From, class To&gt;
struct is_convertible;</code></pre>
</td>
<td>
<i>see below</i>
</td>
<td>
<ins>
Either <code class='backtick'>To</code> is a reference type and <code class='backtick'>From</code>
is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;To&gt;</code>, or
</ins>
<code class='backtick'>From</code> and <code class='backtick'>To</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
<tr>
<td>
<pre><code>template&lt;class From, class To&gt;
struct is_nothrow_convertible;</code></pre>
</td>
<td>
<code>is_convertible_v&lt;From, To&gt;</code>
is <code class='backtick'>true</code> and the conversion, as defined by <code class='backtick'>is_convertible</code>,
is known not to throw any exceptions
(7.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/expr.unary.noexcept">[expr.unary.noexcept]</a>).
</td>
<td>
<ins>
Either <code class='backtick'>To</code> is a reference type and <code class='backtick'>From</code>
is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;To&gt;</code>, or
</ins>
<code class='backtick'>From</code> and <code class='backtick'>To</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
</ol>
</blockquote>
</blockquote>

<p><i>[2024-08-21; Jonathan provides improved wording]</i></p>

<p>
Following on LWG telecon review,
change "Args contains a single type that is similar"
to "Args contains a single type and that type is similar".
</p>



<p id="res-2939"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.</p>
<blockquote>
<ol>
<li>
In 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> Table 51,
change the <b>Preconditions</b> text for
<code class='backtick'>is_constructible</code>, <code class='backtick'>is_trivially_constructible</code>, <code class='backtick'>is_nothrow_constructible</code>,
<code class='backtick'>is_convertible</code>, and <code class='backtick'>is_nothrow_convertible</code>,
as indicated.
<blockquote>
<table style="border: 1px solid; border-spacing: 1.5em">
<thead style="text-align: center">
<tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr>
</thead>
<tbody style="vertical-align: top">
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
<tr>
<td>
<pre><code>template&lt;class T, class... Args&gt;
struct is_constructible;</code></pre>
</td>
<td>
For a function type <code class='backtick'>T</code> or
for a <i>cv</i> <code class='backtick'>void</code> type <code class='backtick'>T</code>,
<code>is_constructible_v&lt;T, Args...&gt;</code>
is <code class='backtick'>false</code>,
otherwise <i>see below</i>
<ins>.</ins>
</td>
<td>
<ins>
Either <code class='backtick'>T</code> is a reference type and <code class='backtick'>Args</code> contains a single type
and that type is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;T&gt;</code>, or
</ins>
<code class='backtick'>T</code> and all types in the template parameter pack <code class='backtick'>Args</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
<tr>
<td>
<pre><code>template&lt;class T, class... Args&gt;
struct is_trivially_constructible;</code></pre>
</td>
<td>
<code>is_constructible_v&lt;T, Args...&gt;</code>
is <code class='backtick'>true</code> and the variable definition for <code class='backtick'>is_constructible</code>,
as defined below, is known to call no operation that is not trivial
(6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.types.general">[basic.types.general]</a>, 11.4.4 <a href="https://timsong-cpp.github.io/cppwp/special">[special]</a>).
</td>
<td>
<ins>
Either <code class='backtick'>T</code> is a reference type and <code class='backtick'>Args</code> contains a single type
and that type is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;T&gt;</code>, or
</ins>
<code class='backtick'>T</code> and all types in the template parameter pack <code class='backtick'>Args</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
<tr>
<td>
<pre><code>template&lt;class T, class... Args&gt;
struct is_nothrow_constructible;</code></pre>
</td>
<td>
<code>is_constructible_v&lt;T, Args...&gt;</code>
is <code class='backtick'>true</code> and the variable definition for <code class='backtick'>is_constructible</code>,
as defined below, is known not to throw any exceptions
(7.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/expr.unary.noexcept">[expr.unary.noexcept]</a>).
</td>
<td>
<ins>
Either <code class='backtick'>T</code> is a reference type and <code class='backtick'>Args</code> contains a single type
and that type is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;T&gt;</code>, or
</ins>
<code class='backtick'>T</code> and all types in the template parameter pack <code class='backtick'>Args</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
</tbody>
</table>
</blockquote>
</li>
<li>
In 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> Table 53,
change the <b>Comments</b> text for
<code class='backtick'>is_convertible</code> and <code class='backtick'>is_nothrow_convertible</code>
as indicated.
<blockquote>
<table style="border: 1px solid; border-spacing: 1.5em">
<thead style="text-align: center">
<tr><th>Template</th><th>Condition</th><th>Comments</th></tr>
</thead>
<tbody style="vertical-align: top">
<tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr>
<tr>
<td>
<pre><code>template&lt;class From, class To&gt;
struct is_convertible;</code></pre>
</td>
<td>
<i>see below</i>
</td>
<td>
<ins>
Either <code class='backtick'>To</code> is a reference type and <code class='backtick'>From</code>
is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;To&gt;</code>, or
</ins>
<code class='backtick'>From</code> and <code class='backtick'>To</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
<tr>
<td>
<pre><code>template&lt;class From, class To&gt;
struct is_nothrow_convertible;</code></pre>
</td>
<td>
<code>is_convertible_v&lt;From, To&gt;</code>
is <code class='backtick'>true</code> and the conversion, as defined by <code class='backtick'>is_convertible</code>,
is known not to throw any exceptions
(7.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/expr.unary.noexcept">[expr.unary.noexcept]</a>).
</td>
<td>
<ins>
Either <code class='backtick'>To</code> is a reference type and <code class='backtick'>From</code>
is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to
<code>remove_reference_t&lt;To&gt;</code>, or
</ins>
<code class='backtick'>From</code> and <code class='backtick'>To</code> shall be complete types,
<i>cv</i> <code class='backtick'>void</code>, or arrays of unknown bound.
</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
</ol>
</blockquote>






<hr>
<h3 id="2947"><a href="2947">2947</a>. Clarify several filesystem terms</h3>
<p><b>Section:</b> 31.12.8.1 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.path.format">[fs.enum.path.format]</a>, 31.12.11 <a href="https://timsong-cpp.github.io/cppwp/fs.class.directory.iterator">[fs.class.directory.iterator]</a>, 31.12.13.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2017-03-14 <b>Last modified:</b> 2023-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the application of <a href="https://wg21.link/p0430r2">P0430R2</a>, we came across several terms that seem insufficiently 
clear and lacking proper definitions.
<p/>
We would like clarification on what those terms mean, and we would welcome wording suggestions, or alternatively a verbose explanation and dispensation to change the presentation editorially.
<p/>
The items in question are:
</p>
<ul>
<li><p>What does it mean to 'always interpret [the character sequence] in the same way'? ([fs.enum.path.format], which is 
[path.format] in the paper)</p></li>
<li><p>What is a "directory-like" file type? ([fs.class.directory_iterator])</p></li>
<li><p>What is an "implementation-defined file type"? (e.g. [fs.op.copy])</p></li>
</ul>

<p><i>[2017-07 Toronto Wed Issue Prioritization]</i></p>

<p>Priority 3</p>

<p><i>[2018-01-16, Jonathan comments]</i></p>

<p>
In 31.12.8.1 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.path.format">[fs.enum.path.format]</a> "always interpreted in the same way" means
irrespective of the <code>path::format</code> value, or the content of the string.
Maybe add ", rather than depending on the <code>path::format</code> value or the
content of the character sequence".
<p/>
In  [fs.class.directory_iterator] an "implementation-defined
directory-like file type" is an implementation-defined file type (see
 [fs.enum.file_type] and Table 115) that is treated like a directory by
the special rules that the OS has for non-regular files (see 31.12.6.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.generic">[fs.path.generic]</a>).
<p/>
In 31.12.13.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a>, an "implementation-defined file type" is exactly
that, see  [fs.enum.file_type] and Table 115 again. I don't see what
isn't clear about that. Maybe add a cross-reference to  [fs.enum.file_type].
</p>


<p id="res-2947"><b>Proposed resolution:</b></p>






<hr>
<h3 id="2949"><a href="2949">2949</a>. Unclear complexity requirements: space vs. time</h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2017-03-20 <b>Last modified:</b> 2017-07-15</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is from editorial issue <a href="https://github.com/cplusplus/draft/issues/1088">#1088</a>:
<p/>
It is not always made explicit whether the requirement is referring to time or space complexity, or both.
</p>
<blockquote>
<p>
"Linear time." vs. "Linear."<br/>
"Constant time." vs. "Constant."
</p>
</blockquote>
<p>
16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> says that the <i>Complexity</i> element specifies "the time and/or space
complexity of the function", so being explicit about this would be good.
<p/>
Examples:
</p>
<ul>
<li><p>[sequence.reqmts] <code>a.clear()</code></p></li>
<li><p>[deque.cons]</p></li>
<li><p>[vector.cons]</p></li>
<li><p>[map.cons]</p></li>
<li><p>[multimap.cons]</p></li>
<li><p>[set.cons]</p></li>
<li><p>[multiset.cons]</p></li>
<li><p>[unord.map.cnstr]</p></li>
<li><p>[unord.multimap.cnstr]</p></li>
</ul>
<p>
etc.
</p>

<p><i>[2017-07 Toronto Wed Issue Prioritization]</i></p>

<p>Priority 4; Robert to look at</p>


<p id="res-2949"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2959"><a href="2959">2959</a>. <code>char_traits&lt;char16_t&gt;::eof</code> is a valid UTF-16 code unit</h3>
<p><b>Section:</b> 27.2.4.4 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char16.t">[char.traits.specializations.char16.t]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-05-05 <b>Last modified:</b> 2019-04-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.specializations.char16.t">issues</a> in [char.traits.specializations.char16.t].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard requires that <code>char_traits&lt;char16_t&gt;::int_type</code> is
<code>uint_least16_t</code>, so when that has the same representation as <code>char16_t</code>
there are no bits left to represent the <code>eof</code> value.
<p/>
27.2.4.4 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char16.t">[char.traits.specializations.char16.t]</a> says:
</p>
<blockquote>
<p>
&mdash; The member <code>eof()</code> shall return an implementation-defined constant
that cannot appear as a valid UTF-16 code unit.
</p>
</blockquote>
<p>
Existing practice is to use the "noncharacter" <code>u'\uffff'</code> for this
value, but the Unicode spec is clear that <code>U+FFFF</code> and other
noncharacters are valid, and their appearance in a UTF-16 string does
not make it ill-formed. See <a href="http://www.unicode.org/faq/private_use.html#nonchar7">here</a> and
<a href="http://www.unicode.org/faq/private_use.html#nonchar8">here</a>:
</p>
<blockquote>
<p>
<i>The fact that they are called "noncharacters" and are not intended for open interchange does not mean 
that they are somehow illegal or invalid code points which make strings containing them invalid.</i>
</p>
</blockquote>
<p>
In practice this means there's no way to tell if
<code>basic_streambuf&lt;char16_t&gt;::sputc(u'\uffff')</code> succeeded or not. If it
can insert the character it returns <code>to_int_type(u'\uffff')</code> and
otherwise it returns <code>eof()</code>, which is the same value.
<p/>
I believe that <code>char_traits&lt;char16_t&gt;::to_int_type(char_type c)</code> can be
defined to transform <code>U+FFFF</code> into <code>U+FFFD</code>, so that the invariant
<code>eq_int_type(eof(), to_int_type(c)) == false</code> holds for any <code>c</code> (and the
return value of <code>sputc</code> will be distinct from <code>eof</code>). I don't think any
implementation currently meets that invariant.
<p/>
I think at the very least we need to correct the statement "The member
<code>eof()</code> shall return an implementation-defined constant that cannot
appear as a valid UTF-16 code unit", because there are no such
constants if <code>sizeof(uint_least16_t) == sizeof(char16_t)</code>.
<p/>
This issue is closely related to LWG <a href="1200" title="&quot;surprising&quot; char_traits&lt;T&gt;::int_type requirements (Status: NAD)">1200</a>, but there it's a
slightly different statement of the problem, and neither the
submitter's recommendation nor the proposed resolution solves this
issue here. It seems that was closed as NAD before the Unicode corrigendum
existed, so at the time our standard just gave "surprising results"
but wasn't strictly wrong. Now it makes a normative statement that
conflicts with Unicode.
</p>

<p><i>[2017-07 Toronto Wed Issue Prioritization]</i></p>

<p>Priority 3</p>


<p id="res-2959"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2962"><a href="2962">2962</a>. Iterators of Containers of move-only types do not model <code>InputIterator</code></h3>
<p><b>Section:</b> 24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Ga&scaron;per A&zcaron;man <b>Opened:</b> 2017-05-10 <b>Last modified:</b> 2022-04-25</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#input.iterators">active issues</a> in [input.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Table 95 in 24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>, it is specified that the expression <code>*a</code> returns <code>reference</code>, 
which must be convertible to <code>value_type</code>. This is not true for move-only types, which incidentally means that
<code>std::vector&lt;std::unique_ptr&lt;int&gt;&gt;</code> does not possess even a lowly <code>InputIterator</code>, which is, of 
course, absurd.
<p/>
With the advent of concepts as first-class citizens in the language, getting this right as soon as possible is a priority.
<p/>
This issue seems to be similar to both LWG <a href="448" title="Random Access Iterators over abstract classes (Status: CD1)">448</a> and LWG <a href="484" title="Convertible to T (Status: Open)">484</a>, but not the same.
<p/>
The proposed resolution stems from two considerations outlined below:
</p>
<blockquote>
<p>
<b>Convertibility is too strong for all algorithms</b>
<p/>
No algorithm in the standard library requires convertibility to <code>value_type</code>. If algorithms require things that smell 
of that, they specify the assignment or constructibility flavor they need directly. I checked this by going through the 
specification of each and every one of them in <code>&lt;algorithm&gt;</code> and <code>&lt;numeric&gt;</code>, which highlighted 
several issues unrelated to this one. These issues are presented in <em>Algorithms with underspecified iterator requirements</em>
(LWG <a href="2963" title="Algorithms with underspecified iterator requirements (Status: New)">2963</a>).
<p/>
<b><code>reference</code> needs to be related to <code>value_type</code></b>
<p/>
Algorithms need this for the following reasons:
</p>
<ul>
<li><p>lifetime-extension: served as adequately by <code>T const&amp;</code> as by <code>T</code>. Also works for iterators that 
return by value. <code>T&amp;&amp;</code> also correctly binds to <code>T const&amp;</code>.</p></li>
<li><p>passing to predicates: again, served adequately by <code>T const&amp;</code></p></li>
<li><p>writing to <code>*result</code>: not provided by the requirement anyway.</p></li>
<li><p>capture-by-copy: currently implicitly guaranteed, but unused in the standard library (always specified separately). 
A separate specification can always be made for algorithms that need to capture-by-copy.</p></li>
</ul>
<p>
We must give due consideration to code that so far required its inputs to be <code>CopyConstructible</code> implicitly by 
requiring convertibility to <code>T</code>. This is done in the issue LWG <a href="2963" title="Algorithms with underspecified iterator requirements (Status: New)">2963</a>, 
which presents the results of a comb-through of <code>&lt;algorithm&gt;</code> and <code>&lt;numeric&gt;</code> to find algorithms 
that have this requirement, but where it is not specified. While related issues have been identified, no algorithms seems 
to require more than <code>T const&amp;</code> convertibility without separately requiring convertibility to <code>T</code>.
<p/>
Since such code is already compiling today, relaxing this requirement does not break code.
<p/>
The only code this could possibly break is if, in a concept checking library, the <code>InputIterator</code> concept requirement 
on <code>reference</code> being convertible to <code>value_type</code> gets relaxed. Such a library, if it offered overloading based 
on most-specific modeled concept, could now, once fixed, resolve the call to a different algorithm, which could break user 
code that uses a hypothetical algorithm with a move-only container and was relying to select some other overload for move-only 
types based on the implicit <code>CopyConstructible</code> assertion provided by the iterator.
<p/>
In our internal concepts-checking library, we have had this issue "fixed" since the very beginning &mdash; move-only types 
were too important for our internal algorithms library, and also no algorithm in it seems to require something like 
<code>Iterator::value_type x = *first</code> without also requiring copy-constructibility anyway.
</p>
</blockquote>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Priority 2; also could affect the ranges TS</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.</p>

<ol>
<li>
<p>Change Table 95 &mdash; "Input iterator requirements", 24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>*a</code>
</td>
<td>
<code>reference</code>,<br/>
<del>convertible to <code>T</code></del><br/>
<ins>that binds to <code>const T&amp;</code></ins>
</td>
<td>
<code></code>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>*r++</code>
</td>
<td>
<del>convertible to <code>T</code></del><br/>
<ins>that binds to <code>const T&amp;</code></ins>
</td>
<td>
<code>
{ <del>T</del><ins>auto&amp;&amp;</ins> tmp = *r;<br/>
++r;<br/>
return tmp; }
</code>
</td>
<td>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-04-20; Eric Niebler provides improved wording]</i></p>

<p>
The revised wording makes it clear that you can only rely on those operational semantics when 
the value type is constructible from the reference type and is movable. When those conditions 
aren't met, we can make no guarantees about the operational semantics of <code>*r++</code> (which 
is why <code>*r++</code> is no longer a required expression of the <code>InputIterator</code> concept 
in the Ranges TS).
<p/>
Really, <em>no</em> generic code should be doing <code>*r++</code> on input iterators. Another 
option would be to simply deprecate this requirement for input iterators, but that might need 
a paper. (For forward iterators, <code>*r++</code> is already required to return <code>reference</code> 
exactly, and the multi-pass guarantee gives it the proper semantics.)
<p/>
I also now have a question about the proposed return type of <code>*a</code> and <code>*r++</code>, 
which says they must be something that "binds to <code>const T&amp;</code>". Does this mean that an 
iterator with a reference type reference-to-[<code>const</code>?]-<code>volatile</code>-<code>T</code> is no longer 
considered an iterator? I don't think that's what we want to say. Perhaps these should read 
"binds to <code>const volatile T&amp;</code> instead, except that has the problem for InputIterators 
that return prvalues that a prvalue is not bindable to a volatile reference.
</p>

<p><i>[2018-11 San Diego Thursday night issue processing]</i></p>

<p>Look at Ranges; EricWF to investigate. Status to Open</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4741" title=" Working Draft, Standard for Programming Language C++">N4741</a>.
</p>

<ol>
<li>
<p>Change Table 89 &mdash; "Input iterator requirements", 24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 89 &mdash; Input iterator requirements (in addition to Iterator)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>*a</code>
</td>
<td>
<code>reference</code>,<br/>
<del>convertible to <code>T</code></del><br/>
<ins>that binds to <code>const T&amp;</code></ins>
</td>
<td>
<code></code>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>*r++</code>
</td>
<td>
<del>convertible to <code>T</code></del><br/>
<ins>that binds to <code>const T&amp;</code></ins>
</td>
<td>
<ins>When <code>T tmp = *r</code> is well-formed and<br/> 
<code>T</code> is <code>MoveConstructible</code>, then<br/></ins>
<code>
{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</code>
</td>
<td>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-04-25; Daniel rebases wording on <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>]</i></p>



<p id="res-2962"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li>
<p>Change 24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a>, Table 83 &mdash; "<i>Cpp17InputIterator</i> requirements (in addition to 
<i>Cpp17Iterator</i>) [tab:inputiterator]" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 83 &mdash; <i>Cpp17InputIterator</i> requirements (in addition to <i>Cpp17Iterator</i>) [tab:inputiterator]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>*a</code>
</td>
<td>
<code>reference</code>,<br/>
<del>convertible to <code>T</code></del><br/>
<ins>that binds to <code>const T&amp;</code></ins>
</td>
<td>
<code></code>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>*r++</code>
</td>
<td>
<del>convertible to <code>T</code></del><br/>
<ins>that binds to <code>const T&amp;</code></ins>
</td>
<td>
<ins>When <code>T tmp = *r</code> is well-formed and<br/> 
<code>T</code> is <i>Cpp17MoveConstructible</i>, then<br/></ins>
<code>
{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</code>
</td>
<td>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3 id="2963"><a href="2963">2963</a>. Algorithms with underspecified iterator requirements</h3>
<p><b>Section:</b> 26 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a>, 29 <a href="https://timsong-cpp.github.io/cppwp/numerics">[numerics]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ga&scaron;per A&zcaron;man <b>Opened:</b> 2017-05-10 <b>Last modified:</b> 2017-07-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While researching whether the proposed resolution of Iterators of Containers of move-only types do not model <code>InputIterator</code>
(LWG <a href="2962" title="Iterators of Containers of move-only types do not model InputIterator (Status: Open)">2962</a>), I came across several algorithms that underspecify their requirements, mostly with regard to some associated type of the iterator type they operate on. A list can be found below.
<p/>
The list of algorithms with underspecified requirements from <code>&lt;algorithm&gt;</code> and <code>&lt;numeric&gt;</code> follows.
<p/>
With the advent of concepts, these algorithms will need better specifications if we are ever hoping to be allowed to overload based on them. I want this issue to bring the standard algorithms closer to having their concept requirements directly transcribable to library annotations.
<p/>
Suggested resolution:
</p>
<ol>
<li>
<p><code>copy</code>, <code>copy_if</code>, <code>copy_n</code>, <code>copy_backward</code></p>
<p>Add to description: <ins><code>*result</code> shall be assignable from <code>*first</code>.</ins></p>
</li>
<li>
<p><code>move</code>, <code>move_backward</code></p>
<p>Add to description: <ins><code>*result</code> shall be move-assignable from <code>*first</code>.</ins></p>
</li>
<li>
<p><code>transform</code></p>
<p>Add to description: <ins>The result of the expression <code>op(*first)</code> or <code>binary_op(*first1, *first2)</code> 
shall be writable to <code>result</code>.</ins></p>
</li>
<li>
<p><code>rotate_copy</code></p>
<p>Add to description: <ins><code>*first</code> shall be writable to <code>result</code>.</ins></p>
</li>
<li>
<p><code>merge</code></p>
<p>Add to description: <ins><code>*first1</code> and <code>*first2</code> shall be writable to <code>result</code>.</ins>.</p>
</li>
<li>
<p><code>set_union</code>, <code>set_intersection</code>, <code>set_difference</code>, <code>set_symmetric_difference</code></p>
<p>Add to description: <ins><code>*first1</code> and <code>*first2</code> shall be writable to <code>result</code>.</ins></p>
</li>
<li>
<p><code>partial_sum</code></p>
<p>
<code>acc</code> is not defined.
<p/>
Change description: <code>acc</code>, a variable of <code>InputIterator</code>'s value type, shall be constructible
</p>
</li>
<li>
<p><code>adjacent_difference</code></p>
<p>
<code>acc</code> is not defined.
<p/>
Change description: <code>acc</code>, a variable of <code>InputIterator</code>'s value type, shall be <code>MoveAssignable</code> and shall be 
<code>constructible</code> from the type of <code>*first</code>.
</p>
</li>
<li>
<p><code>iota</code></p>
<p>
<code>iota</code> is mis-specified. Since the expression we need to support is <code>*first = value</code>: <code>*first</code> 
is required to be of type <code>InputIterator::reference</code>, and value is an lvalue of type <code>T</code>. The current 
specification allows calling <code>iota</code> with a <code>const</code> output iterator!
<p/>
<del><code>T</code> shall be convertible to <code>ForwardIterator</code>'s value type</del><ins><code>value</code> shall be writable to 
<code>first</code>. The expression <code>*first = value</code> shall not modify <code>value</code></ins>.
</p>
</li>
</ol>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Priority 3; Marshall to work with Gaspar to improve wording.</p>


<p id="res-2963"><b>Proposed resolution:</b></p>





<hr>
<h3 id="2973"><a href="2973">2973</a>. <code>inplace_merge</code> exact comparison count complexity prohibits useful real-world optimizations</h3>
<p><b>Section:</b> 26.8.6 <a href="https://timsong-cpp.github.io/cppwp/alg.merge">[alg.merge]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2017-06-08 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.merge">issues</a> in [alg.merge].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
At the moment, <code>inplace_merge</code> requires exactly <code><i>N</i> - 1</code> comparisons, if enough additional memory is 
available (and in practice enough additional memory is always available). However, this prohibits implementing the 
merge operation using forms of binary search, as in Timsort's 
<a href="https://hg.python.org/cpython/file/tip/Objects/listsort.txt#l451">'Galloping Mode'</a>, a useful optimization 
for non-uniform input data. It's not really useful to prohibit standard libraries from trying a few extra speculative 
compares like this, given that users must be prepared for the fallback "not enough memory" 
&#x1d4aa;(<code><i>N</i> lg <i>N</i></code>) algorithm.
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Status to LEWG</p>


<p id="res-2973"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.</p>

<ol>
<li>
<p>Edit 26.8.6 <a href="https://timsong-cpp.github.io/cppwp/alg.merge">[alg.merge]</a> as indicated:</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator&gt;
void inplace_merge(BidirectionalIterator first,
    BidirectionalIterator middle,
    BidirectionalIterator last);
template&lt;class ExecutionPolicy, class BidirectionalIterator&gt;
void inplace_merge(ExecutionPolicy&amp;&amp; exec,
    BidirectionalIterator first,
    BidirectionalIterator middle,
    BidirectionalIterator last);
template&lt;class BidirectionalIterator, class Compare&gt;
void inplace_merge(BidirectionalIterator first,
    BidirectionalIterator middle,
    BidirectionalIterator last, Compare comp);
template&lt;class ExecutionPolicy, class BidirectionalIterator, class Compare&gt;
void inplace_merge(ExecutionPolicy&amp;&amp; exec,
    BidirectionalIterator first,
    BidirectionalIterator middle,
    BidirectionalIterator last, Compare comp);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-8- <i>Complexity:</i> Let <code><i>N</i> = last - first</code>:
</p>
<ol style="list-style-type: none">
<li><p>(8.1) &mdash; For the overloads with no <code>ExecutionPolicy</code>, if enough additional memory is available, 
<del>exactly</del> <code><i>N</i> - 1</code> comparisons <ins>on average, &#x1d4aa;(<code><i>N</i></code>) comparisons in 
the worst case</ins>.</p></li>
<li><p>(8.2) &mdash; For the overloads with no <code>ExecutionPolicy</code> if no additional memory is available, 
&#x1d4aa;(<code><i>N</i> log <i>N</i></code>) comparisons.</p></li>
<li><p>(8.3) &mdash; For the overloads with an <code>ExecutionPolicy</code>, &#x1d4aa;(<code><i>N</i> log <i>N</i></code>)
comparisons.</p></li>
</ol>
<p>
-9- <i>Remarks:</i> Stable (16.4.6.8 <a href="https://timsong-cpp.github.io/cppwp/algorithm.stable">[algorithm.stable]</a>).
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="2983"><a href="2983">2983</a>. <code>money_put::do_put</code> underspecified</h3>
<p><b>Section:</b> 28.3.4.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/locale.money.put.virtuals">[locale.money.put.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-06-21 <b>Last modified:</b> 2017-06-27</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.money.put.virtuals">issues</a> in [locale.money.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Whether you get "<code>.99</code>" or "<code>0.99</code>" for the following depends on the implementation:
</p>
<blockquote><pre>
std::cout.imbue(std::locale("en_US"));
std::cout &lt;&lt; std::put_money(99.L);
</pre></blockquote>
<p>
I don't see any justification in [locale.money.put.virtuals] for the leading <code>0</code>, although that seems more useful.
<p/>
If we want the leading zero, we should say so.
</p>

<p><i>[2017-06-27, Jonathan comments and provides wording]</i></p>

<p>
I suggest that we require a leading zero. The wording below is similar
to how C specifies the <code>%f</code> format specifier for <code>fprintf</code>.
</p>


<p id="res-2983"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 28.3.4.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/locale.money.put.virtuals">[locale.money.put.virtuals]</a> as indicated:</p>

<blockquote>
<pre>
iter_type do_put(iter_type s, bool intl, ios_base&amp; str,
                 char_type fill, long double units) const;
iter_type do_put(iter_type s, bool intl, ios_base&amp; str,
                 char_type fill, const string_type&amp; digits) const;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Remarks:</i> The currency symbol is generated if and only if <code>(str.flags() &amp; str.showbase)</code> is nonzero.
<ins>If the format specifies a decimal point, at least one digit character appears before it.</ins>
If the number of characters generated for the specified format is less than the value returned by
<code>str.width()</code> on entry to the function, then copies of <code>fill</code> are inserted as necessary to pad to the 
specified width. For the value <code>af</code> equal to <code>(str.flags() &amp; str.adjustfield)</code>, if 
<code>(af == str.internal)</code> is <code>true</code>, the fill characters are placed where <code>none</code> or <code>space</code> 
appears in the formatting pattern; otherwise if <code>(af == str.left)</code> is <code>true</code>, they are placed after the 
other characters; otherwise, they are placed before the other characters.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="2984"><a href="2984">2984</a>. <code>put_money(99)</code> is unnecessarily undefined</h3>
<p><b>Section:</b> 31.7.8 <a href="https://timsong-cpp.github.io/cppwp/ext.manip">[ext.manip]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-06-22 <b>Last modified:</b> 2017-06-26</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[ext.manip] p5 says:
</p>
<blockquote><p>
<i>Requires:</i> The type <code>moneyT</code> shall be either <code>long double</code> or a specialization of the 
<code>basic_string</code> template (Clause 24).
</p></blockquote>
<p>
This means that <code>put_money(99)</code>, <code>put_money(99.)</code>, <code>put_money("99")</code>, and 
<code>put_money(string_view{"99"})</code> are all undefined, when in practice they will compile fine and 
do the right thing, converting the argument to <code>long double</code> or <code>std::string</code> as needed.
<p/>
We could change it to be "otherwise the program is ill-formed", or to remove the function templates from overload 
resolution when the argument is not <code>long double</code> or a <code>std::basic_string</code>, but that will unnecessarily 
break code that works fine today. We should accept types convertible to <code>long double</code> or the relevant 
<code>money_put</code> facet's <code>string_type</code> (which is not known until we attempt to write the unspecified 
type to an ostream).
<p/>
The requirement is also insufficient, because <code>cout &lt;&lt; put_money(wstring(L"99"))</code> won't compile on any 
implementation, despite the argument type being a specialization of <code>basic_string</code>. This same problem exists 
for <code>std::get_money</code>.
</p>

<p><i>[2017-06-24, Daniel comments and provides wording]</i></p>

<p>
The wording changes below are supposed to support all <code>moneyT</code> types that are convertible to either 
<code>long double</code> or to <code>money_put/get&lt;Ch, o/istreambuf_iterator&lt;Ch, Tr&gt;&gt;::string_type</code> 
(but not to both), where <code>Ch</code> and <code>Tr</code> are determined by the concrete instantiated specialization of the 
exposition-only function template <code>f</code> that is used to specify the semantics of <code>put_money</code> and 
<code>get_money</code>, respectively. XOR-ing the requirements outlaws types that are convertible to both, which 
would cause an ambiguity unless we would provide wording that would introduce an ordered application of these 
convertibility constraints. This is the rationale for the seemingly odd new <i>Remarks</i> formulation. Note also,
that the wording provided below intentionally attempts to distinguish between the statically testable
conditions based on the <code>is_convertible_v</code> expressions within the <i>Remarks:</i> element and the well-defined 
runtime behaviour requirement of the actually provided argument of deduced type <code>moneyT</code> within the 
pre-existing <i>Requires:</i> element. Another point worth pointing out is that the wording attempts to fix an
currently existing ambiguity of the meaning of the type <code>moneyT</code> (and to a lesser extend for <code>charT</code> and
<code>traits</code>) as either the template parameter of <code>put/get_money</code> or that of the corresponding template
argument of the exposition-only <code>f</code> templates. The revised form makes it clearer that it refers to the latter.
<p/>
It should be emphasized that this extension of the current wording would provide support for <code>put_money(99)</code>, 
<code>put_money(99.)</code>, and <code>put_money("99")</code>, but <em>not</em> yet for <code>put_money(string_view{"99"})</code>, 
because <code>string_view</code> is not convertible to <code>string</code>. To realize support for the latter, this wording 
approach could be extended by referring to <code>is_constructible</code> instead of <code>is_convertible</code>, though.
</p>


<p id="res-2984"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 31.7.8 <a href="https://timsong-cpp.github.io/cppwp/ext.manip">[ext.manip]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class moneyT&gt; <i>unspecified</i> get_money(moneyT&amp; mon, bool intl = false);
</pre>
<blockquote>
<p>
<ins>-?- For an expression <code>in &gt;&gt; get_money(mon, intl)</code> described below, let <code><i>Mo</i></code>, 
<code><i>Ch</i></code>, and <code><i>Tr</i></code> be the deduced template argument types of the template parameters 
<code>moneyT</code>, <code>charT</code>, and <code>traits</code>, respectively, of the instantiated specialization of the 
template <code>f</code>.</ins>
<p/>
-2- <i>Requires:</i> <del>The type <code>moneyT</code> shall be either <code>long double</code> or a specialization of the 
<code>basic_string</code> template (Clause 27 <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a>)</del><ins><code><i>Mo</i></code>
shall be either convertible to <code>long double</code> or shall be convertible to 
<code>money_get&lt;<i>Ch</i>, istreambuf_iterator&lt;<i>Ch</i>, <i>Tr</i>&gt;&gt;::string_type</code></ins>.
<p/>
<ins>-?- <i>Remarks:</i> If <code>is_convertible_v&lt;<i>Mo</i>, long double&gt; == is_convertible_v&lt;<i>Mo</i>, 
money_get&lt;<i>Ch</i>, istreambuf_iterator&lt;<i>Ch</i>, <i>Tr</i>&gt;&gt;::string_type&gt;</code>,
the program is ill-formed.</ins>
<p/>
-3- <i>Effects:</i> The expression <code>in &gt;&gt; get_money(mon, intl)</code> described below behaves as 
a formatted input function (31.7.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/istream.formatted.reqmts">[istream.formatted.reqmts]</a>).
<p/>
-4- <i>Returns:</i> An object of unspecified type such that if <code>in</code> is an object of type 
<code>basic_istream&lt;<del>charT</del><ins><i>Ch</i></ins>, <del>traits</del><ins><i>Tr</i></ins>&gt;</code> then 
the expression <code>in &gt;&gt; get_money(mon, intl)</code> behaves as if it called <code>f(in, mon, intl)</code>, where 
the function <code>f</code> is defined as:
</p>
<blockquote><pre>
template &lt;class charT, class traits, class moneyT&gt;
void f(basic_ios&lt;charT, traits>&amp; str, moneyT&amp; mon, bool intl) {
  using Iter = istreambuf_iterator&lt;charT, traits&gt;;
  using MoneyGet = money_get&lt;charT, Iter&gt;;
  ios_base::iostate err = ios_base::goodbit;
  const MoneyGet&amp; mg = use_facet&lt;MoneyGet>(str.getloc());
  mg.get(Iter(str.rdbuf()), Iter(), intl, str, err, mon);
  if (ios_base::goodbit != err)
    str.setstate(err);
}
</pre></blockquote>
<p>
The expression <code>in &gt;&gt; get_money(mon, intl)</code> shall have type 
<code>basic_istream&lt;<del>charT</del><ins><i>Ch</i></ins>, <del>traits</del><ins><i>Tr</i></ins>&gt;&amp;</code> 
and value <code>in</code>.
</p>
</blockquote>
<pre>
template &lt;class moneyT&gt; <i>unspecified</i> put_money(const moneyT&amp; mon, bool intl = false);
</pre>
<blockquote>
<p>
<ins>-?- For an expression <code>out &lt;&lt; put_money(mon, intl)</code> described below, let <code><i>Mo</i></code>, 
<code><i>Ch</i></code>, and <code><i>Tr</i></code> be the deduced template argument types of the template parameters 
<code>moneyT</code>, <code>charT</code>, and <code>traits</code>, respectively, of the instantiated specialization of the 
template <code>f</code>.</ins>
<p/>
-5- <i>Requires:</i> <del>The type <code>moneyT</code> shall be either <code>long double</code> or a specialization of the 
<code>basic_string</code> template (Clause 27 <a href="https://timsong-cpp.github.io/cppwp/strings">[strings]</a>)</del><ins><code><i>Mo</i></code>
shall be either convertible to <code>long double</code> or shall be convertible to 
<code>money_put&lt;<i>Ch</i>, ostreambuf_iterator&lt;<i>Ch</i>, <i>Tr</i>&gt;&gt;::string_type</code></ins>.
<p/>
<ins>-?- <i>Remarks:</i> If <code>is_convertible_v&lt;<i>Mo</i>, long double&gt; == is_convertible_v&lt;<i>Mo</i>, 
money_put&lt;<i>Ch</i>, ostreambuf_iterator&lt;<i>Ch</i>, <i>Tr</i>&gt;&gt;::string_type&gt;</code>,
the program is ill-formed.</ins>
<p/>
-6- <i>Returns:</i> An object of unspecified type such that if <code>out</code> is an object of type 
<code>basic_ostream&lt;<del>charT</del><ins><i>Ch</i></ins>, <del>traits</del><ins><i>Tr</i></ins>&gt;</code> then 
the expression <code>out &lt;&lt; put_money(mon, intl)</code> behaves as a formatted output function
(31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>) that calls <code>f(out, mon, intl)</code>, where the function <code>f</code> 
is defined as:
</p>
<blockquote><pre>
template &lt;class charT, class traits, class moneyT&gt;
void f(basic_ios&lt;charT, traits&gt;&amp; str, const moneyT&amp; mon, bool intl) {
  using Iter = ostreambuf_iterator&lt;charT, traits&gt;;
  using MoneyPut = money_put&lt;charT, Iter&gt;;
  const MoneyPut&amp; mp = use_facet&lt;MoneyPut>(str.getloc());
  const Iter end = mp.put(Iter(str.rdbuf()), intl, str, str.fill(), mon);
  if (end.failed())
    str.setstate(ios::badbit);
}
</pre></blockquote>
<p>
The expression <code>out &lt;&lt; put_money(mon, intl)</code> shall have type 
<code>basic_ostream&lt;<del>charT</del><ins><i>Ch</i></ins>, <del>traits</del><ins><i>Tr</i></ins>&gt;&amp;</code>
and value <code>out</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="2985"><a href="2985">2985</a>. <code>std::reverse</code> should be permitted to be vectorized</h3>
<p><b>Section:</b> 26.7.10 <a href="https://timsong-cpp.github.io/cppwp/alg.reverse">[alg.reverse]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2017-06-24 <b>Last modified:</b> 2018-04-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.reverse">issues</a> in [alg.reverse].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The fine folks on our backend team suggested that we special case <code>std::reverse</code> of 1/2/4/8 to take 
advantage of vector units. Unfortunately, at present <code>std::reverse</code> says it does <code>N/2 iter_swap</code>s, 
which doesn't permit our vector implementation even if the iterator inputs are pointers to trivially copyable <code>T</code>s.
<p/>
The vectorized version for pointers to <code>short</code>s is 
<a href="https://twitter.com/MalwareMinigun/status/878150939512717312">~8x faster on Skylake</a> than the serial version, 
and about 7x faster for <code>unsigned long long</code>s; and users don't actually care whether or not we call <code>swap</code> here.
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Status to LEWG; this is similar to <a href="2973" title="inplace_merge exact comparison count complexity prohibits useful real-world optimizations (Status: LEWG)">2973</a></p>

<p><i>[2018-04-02, Billy comments]</i></p>

<p>
This issue should be resolved by <a href="https://wg21.link/p0551">P0551</a>, because it prohibits user specialization of  
<code>std::swap</code> and <code>std::iter_swap</code>, which means the proposed vectorization optimization for 
pointers-to-trivially-copyable is now implementable without changes to <code>reverse</code>'s specification (We can detect 
if the user has provided an alternate <code>swap</code> in their own namespace, but not if they explicitly specialized 
<code>swap</code> or <code>iter_swap</code>).
</p>


<p id="res-2985"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 26.7.10 <a href="https://timsong-cpp.github.io/cppwp/alg.reverse">[alg.reverse]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class BidirectionalIterator&gt;
  void reverse(BidirectionalIterator first, BidirectionalIterator last);
template&lt;class ExecutionPolicy, class BidirectionalIterator>
  void reverse(ExecutionPolicy&amp;&amp; exec,
               BidirectionalIterator first, BidirectionalIterator last);
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <code>*first</code> shall be swappable (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>).
<p/>
-2- <i>Effects:</i> For each non-negative integer <code>i &lt; (last - first) / 2</code>, applies <code>iter_swap</code> 
to all pairs of iterators <code>first + i, (last - i) - 1</code>. <ins>If 
<code>is_trivially_copyable_v&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt;</code> is 
<code>true</code>, an implementation may permute the elements by making temporary copies, rather than by calling 
<code>iter_swap</code>. [<i>Note:</i> this allows the implementation to be vectorized. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="2986"><a href="2986">2986</a>. Handling of multi-character collating elements by the <code>regex</code> FSM is underspecified</h3>
<p><b>Section:</b> 28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2017-06-25 <b>Last modified:</b> 2017-07-12</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="https://wg21.link/n4660">N4660</a> subclause 31.13 [re.grammar] paragraph 5:
</p>
<blockquote><p>
The productions <code>ClassAtomExClass</code>, <code>ClassAtomCollatingElement</code> and <code>ClassAtomEquivalence</code> provide
functionality equivalent to that of the same features in regular expressions in POSIX.
</p></blockquote>
<p>
The broadness of the above statement makes it sound like it is merely a statement of intent; however, this appears to 
be a necessary normative statement insofar as identifying the general semantics to be associated with the syntactic 
forms identified. In any case, if it is meant for <code>ClassAtomCollatingElement</code> to provide functionality equivalent 
to a collating symbol in a POSIX bracket expression, multi-character collating elements need to be considered.
<p/>
In [re.grammar] paragraph 14:
</p>
<blockquote><p>
The behavior of the internal finite state machine representation when used to match a sequence of characters is 
as described in ECMA-262. The behavior is modified according to any <code>match_flag_type</code> flags specified when 
using the regular expression object in one of the regular expression algorithms. The behavior is also localized 
by interaction with the traits class template parameter as follows: [bullets 14.1 to 14.4]
</p></blockquote>
<p>
In none of the bullets does the wording handle multi-character collating elements in a clear manner:
</p>
<ul>
<li><p>14.1 deals in characters.</p></li>
<li><p>14.2 deals in characters (<code>traits_inst.translate</code> accepts only a single character).</p></li>
<li><p>14.3 might handle a multi-character collating element; however, there is no specification of how 
such a collating element is to be identified from the sequence of characters. Additionally, the definition 
of primary equivalence class specifies that it is a set of characters (not of collating elements).</p></li>
<li><p>14.4 deals in characters.</p></li>
</ul>
<p>
The ECMA-262 specification for <em>ClassRanges</em> also deals in characters.
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Priority 4</p>


<p id="res-2986"><b>Proposed resolution:</b></p>




<hr>
<h3 id="2987"><a href="2987">2987</a>. Relationship between <code>traits_inst.lookup_collatename</code> and the <code>regex</code> FSM is underspecified with 
regards to <code>ClassAtomCollatingElement</code></h3>
<p><b>Section:</b> 28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2017-06-25 <b>Last modified:</b> 2017-07-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For a user to implement a regular expression traits class meaningfully, the relationship between the return value of <code>traits_inst.lookup_collatename</code> to the behaviour of the finite state machine corresponding to a regular expression 
needs to be better specified.
<p/>
From <a href="https://wg21.link/n4660">N4660</a> subclause 31.13 [re.grammar], <code>traits_inst.lookup_collatename</code> 
only feeds clearly into two operations:
</p>
<ol>
<li><p>a test if the returned string is empty ([re.grammar]/8), and</p></li>
<li><p>a test if the result of <code>traits_inst.transform_primary</code>, with the returned string, 
is empty ([re.grammar]/10).</p></li>
</ol>
<p>
Note: It is unclear if bullet 14.3 in [re.grammar]/14 refers to the result of <code>traits_inst.lookup_collatename</code> when 
it refers to a "collating element"; and if it does, it is unclear what input is to be used.
<p/>
It is therefore unclear what the effect is if <code>traits_inst.lookup_collatename</code> substitutes another member of the 
equivalence class as its output.
<p/>
For example, when processing <code>"[[.AA.]]"</code> as a pattern under a locale <code>da_DK.utf8</code>, what is the expected 
behaviour difference (if any) should <code>traits_inst.lookup_collatename</code> return, for <code>"AA"</code>, <code>"\u00C5"</code> 
(where <code>U+00C5</code> is A with ring, which sorts the same as <code>"AA"</code>)?
</p>

<p><i>[2017-07 Toronto Monday issue prioritization]</i></p>

<p>Priority 3</p>


<p id="res-2987"><b>Proposed resolution:</b></p>




<hr>
<h3 id="2990"><a href="2990">2990</a>. <code>optional::value_type</code> is not always a value type</h3>
<p><b>Section:</b> 22.5.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2017-06-27 <b>Last modified:</b> 2018-01-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.optional">issues</a> in [optional.optional].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>optional&lt;T&gt;::value_type</code> is <code>T</code>, which can be a <i>cv</i>-qualified object type. This is 
inconsistent with the uses of the name <code>value_type</code> elsewhere in the standard. We should either require 
<code>optional&lt;T&gt;::value_type</code> to be <code>remove_cv_t&lt;T&gt;</code> &mdash; a true value type &mdash; 
or rename the type alias to <code>element_type</code>.
</p>

<p><i>[2017-07 Toronto Tuesday PM issue prioritization]</i></p>

<p>Priority 3; may also affect <code>array</code></p>

<p><i>[2018-1-26 issues processing telecon]</i></p>

<p>Status to 'Open'</p>


<p id="res-2990"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 22.5.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a>, class template <code>optional</code> synopsis, as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt;
  class optional {
  public:
    using value_type = <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins>;
    [&hellip;]
  };
</pre>
</blockquote>
</li>
</ol>




<hr>
<h3 id="2991"><a href="2991">2991</a>. <code>variant</code> copy constructor missing <code>noexcept(<i>see below</i>)</code></h3>
<p><b>Section:</b> 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2017-06-27 <b>Last modified:</b> 2024-11-19</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.ctor">active issues</a> in [variant.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.ctor">issues</a> in [variant.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The copy constructor of <code>std::variant</code> is not conditionally <code>noexcept</code> (I think
it was in the original proposal.)
<p/>
It should be, for two reasons: first, this would be consistent with the other three constructors
</p>
<blockquote><pre>
constexpr variant() noexcept(<i>see below</i>);

variant(variant&amp;&amp;) noexcept(<i>see below</i>);

template &lt;class T&gt;
constexpr variant(T&amp;&amp;) noexcept(<i>see below</i>);
</pre></blockquote>
<p>
and second, <code>variant</code> itself makes use of <code>is_nothrow_copy_constructible</code>, so
it's inconsistent for it to take a stance against it.
</p>

<p><i>[2017-07 Toronto Tuesday PM issue prioritization]</i></p>

<p>Status to LEWG</p>

<p><i>[Wrocaw 2024-11-18; LEWG approves the direction]</i></p>

<p>
In <a href="https://wg21.link/P0088R1" title=" Variant: a type-safe union that is rarely invalid (v6)">P0088R1</a> the copy constructor was conditionally noexcept
in the synopsis, but not the detailed description. This was pointed out
during LWG review in Jacksonville.
The approved paper, <a href="https://wg21.link/P008R3">P008R3</a>, doesn't have it in either place.
</p>


<p id="res-2991"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4659">N4659</a>.
</p>

<ol>
<li><p>Edit 22.6.3 <a href="https://timsong-cpp.github.io/cppwp/variant.variant">[variant.variant]</a>, class template <code>variant</code> synopsis, as indicated:</p>

<blockquote>
<pre>
template &lt;class... Types&gt;
  class variant {
  public:
    // 23.7.3.1, constructors
    constexpr variant() noexcept(<i>see below</i>);
    variant(const variant&amp;) <ins>noexcept(<i>see below</i>)</ins>;
    variant(variant&amp;&amp;) noexcept(<i>see below</i>);
    [&hellip;]
  };
</pre>
</blockquote>
</li>

<li><p>Edit 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> as indicated:</p>

<blockquote>
<pre>
variant(const variant&amp; w) <ins>noexcept(<i>see below</i>)</ins>;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-8- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<code>is_copy_constructible_v&lt;T<sub><i>i</i></sub>&gt;</code> is <code>true</code> for all <code><i>i</i></code>.
<ins>The expression inside <code>noexcept</code> is equivalent to the logical AND of
<code>is_nothrow_copy_constructible_v&lt;T<sub><i>i</i></sub>&gt;</code> for all <code><i>i</i></code>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3011"><a href="3011">3011</a>. Requirements for <code>assert(<em>E</em>)</code> inconsistent with C</h3>
<p><b>Section:</b> 19.3 <a href="https://timsong-cpp.github.io/cppwp/assertions">[assertions]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-08-18 <b>Last modified:</b> 2018-08-20</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#assertions">issues</a> in [assertions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C standard says that the expression in an <code>assert</code> must have a scalar type, and implies (or at least allows) 
that the condition is tested by comparison to zero. C++ says that the expression is a constant subexpression if it can 
be contextually converted to <code>bool</code>. Those ways to test the condition are not equivalent.
<p/>
It's possible to have expressions that meet the C++ requirements for a constant subexpression, but fail to meet the C 
requirements, and so don't compile.
</p>
<blockquote><pre>
#include &lt;stdlib.h&gt;

// A toy implementation of assert:
#define assert(E) (void)(((E) != 0) || (abort(), 0))

struct X {
  constexpr explicit operator bool() const { return true; }
};

constexpr bool f(const X&amp; x) {
  assert(x);
  return true;
}
</pre></blockquote>
<p>
C++ says that <code>assert(x)</code> is a constant subexpression, but as it doesn't have scalar type it's not even a valid expression.
<p/>
I think either 19.3.2 <a href="https://timsong-cpp.github.io/cppwp/cassert.syn">[cassert.syn]</a> or 19.3.3 <a href="https://timsong-cpp.github.io/cppwp/assertions.assert">[assertions.assert]</a> should repeat the requirement from C that 
<em>E</em> has scalar type, either normatively or in a note. We should also consider whether "contextually converted to <code>bool</code>" 
is the right condition, or if we should use comparison to zero instead.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 2; status to Open</p>
<p>Jonathan is discussing this with WG14</p>

<p><i>[2018-08-20, Jonathan comments]</i></p>

<p>
This was reported to WG14 as <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2207.htm">N2207</a>.
</p>


<p id="res-3011"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3019"><a href="3019">3019</a>. Presentation of "program defined classes derived from <code>error_category</code>" [syserr.errcat.derived] unclear and contains mistakes</h3>
<p><b>Section:</b> 19.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.derived">[syserr.errcat.derived]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2017-09-20 <b>Last modified:</b> 2017-11-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The presentation of section [syserr.errcat.derived] is currently somewhat problematic:
</p>
<ul>
<li><p>
It is not clear why this section exists and what it is specifying. Presumably, it is the subject of the phrase 
"in this subclause" of the sibling section [syserr.errcat.overview], but that's confusing (because this would require the 
interpretation of "this subclause" as the containing superclause). It would be an improvement to say "shall behave 
as specified in [syserr.errcat.derived]" in the introduction.
</p></li>
<li><p>
The current wording of [syserr.errcat.derived] requires that derived classes keep the <code>name</code> member function pure-virtual, 
making it impossible to have non-abstract derived classes. This appears to be an editorial error. Surely <code>name</code> should 
just not be required to be pure-virtual.
</p></li>
<li><p>
There seems to be no requirement concerning the <code>message</code> virtual member function.
</p></li>
<li><p>
We should use <code>override</code> rather than <code>virtual</code>.
</p></li>
<li><p>
I would welcome a short, introductory paragraph in [syserr.errcat.derived] that states (non-redundantly) that the following 
are requirements on users' derived classes.
</p></li>
</ul>
<p>
Partial wording proposal:
</p>
<ol>
<li><p>In 19.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.overview">[syserr.errcat.overview]</a> p1, change:</p>
<blockquote>
<p>
-1- The class <code>error_category</code> serves as a base class for types used to identify the source and encoding of a
particular category of error code. Classes may be derived from <code>error_category</code> to support categories of
errors in addition to those defined in this International Standard. Such classes shall behave as specified in
<del>this subclause</del><ins>19.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.derived">[syserr.errcat.derived]</a></ins>. [<i>Note:</i> <code>error_category</code> objects 
are passed by reference, and two such objects are equal if they have the same address. This means that applications 
using custom <code>error_category</code> types should create a single object of each such type. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>

<li><p>In 19.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.derived">[syserr.errcat.derived]</a>, change:</p>
<blockquote>
<pre>
<del>virtual</del> const char* name() const noexcept <ins>override</ins> <del> = 0</del>;
</pre>
<blockquote>
<p>
-1- <i>Returns:</i> A string naming the error category.
</p>
</blockquote>
<pre>
<del>virtual</del> error_condition default_error_condition(int ev) const noexcept <ins>override</ins>;
</pre>
<blockquote>
<p>
-2- <i>Returns:</i> An object of type <code>error_condition</code> that corresponds to <code>ev</code>.
</p>
</blockquote>
<pre>
<del>virtual</del> bool equivalent(int code, const error_condition&amp; condition) const noexcept <ins>override</ins>;
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <code>true</code> if, for the category of error represented by <code>*this</code>, <code>code</code> is considered 
equivalent to <code>condition</code>; otherwise, <code>false</code>.
</p>
</blockquote>
<pre>
<del>virtual</del> bool equivalent(const error_code&amp; code, int condition) const noexcept <ins>override</ins>;
</pre>
<blockquote>
<p>
-4- <i>Returns:</i> <code>true</code> if, for the category of error represented by <code>*this</code>, <code>code</code> is considered 
equivalent to condition; otherwise, <code>false</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 3.</p>
<p>Jonathan to talk to Chris K and Walter about writing a paper describing the use of <code>error_code</code>, <code>error_condition</code> and defining your own.</p>


<p id="res-3019"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3021"><a href="3021">3021</a>. [networking.ts] Relax pointer equivalence requirement for <code>ConstBufferSequence</code></h3>
<p><b>Section:</b> 16.2.2 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.constbuffersequence">[networking.ts::buffer.reqmts.constbuffersequence]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Vinnie Falco <b>Opened:</b> 2017-09-20 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: networking.ts</b></p>
<p>
The post-condition buffer sequence requirements mandate pointer equivalence. This means that a copies of buffer sequences must 
point to the same pieces of underlying memory. While this is appropriate for <code>MutableBufferSequence</code>, it is unnecessary 
for <code>ConstBufferSequence</code> and can actually prevent useful implementation strategies such as the following constant buffer 
sequence which avoids dynamic allocations:  
</p>
<blockquote>
<pre>
/// A buffer sequence containing a chunk-encoding header
class chunk_size
{
public:
    // Storage for the longest hex string we might need
    class value_type
    {
        friend class chunk_size;

        // First byte holds the length
        char buf_[1 + 2 * sizeof(std::size_t)];

        template&lt;class = void&gt;
        void prepare(std::size_t n);

        template&lt;class OutIter&gt;
        static OutIter to_hex(OutIter last, std::size_t n)
        {
            if (n == 0)
            {
                *--last = '0';
                return last;
            }
            while (n)
            {
                *--last = "0123456789abcdef"[n &amp; 0xf];
                n >>= 4;
            }
            return last;
        }
    public:
        operator boost::asio::const_buffer() const
        {
            return {
                buf_ + sizeof(buf_) - buf_[0],
                static_cast(buf_[0])
            };
        }
    };

    using const_iterator = value_type const*;

    chunk_size(chunk_size const&amp; other) = default;

    /** Construct a chunk header

        @param n The number of octets in this chunk.
    */
    chunk_size(std::size_t n)
    {
        value_.prepare(n);
    }

    const_iterator begin() const
    {
        return &amp;value_;
    }

    const_iterator end() const
    {
        return begin() + 1;
    }

private:
    value_type value_;
};
</pre>
</blockquote>


<p id="res-3021"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4588">N4588</a>.
</p>

<ol>
<li>
<p>
Modify 16.2.2 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.constbuffersequence">[networking.ts::buffer.reqmts.constbuffersequence]</a> Table 13 "<code>ConstBufferSequence</code> requirements" as indicated:
</p>
<blockquote>
<table border="1">
<caption>Table 13 &mdash; <code>ConstBufferSequence</code> requirements</caption>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note<br/>pre/post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>X u(x);</code>
</td>
<td>
</td>
<td>
post:<br/>
<pre>
equal(
  net::buffer_sequence_begin(x),
  net::buffer_sequence_end(x),
  net::buffer_sequence_begin(u),
  net::buffer_sequence_end(u),
  [](const typename X::value_type&amp; v1,
     const typename X::value_type&amp; v2)
    {
      const_buffer b1(v1);
      const_buffer b2(v2);
      <del>return b1.data() == b2.data()
          &amp;&amp; b1.size() == b2.size()</del>
      <ins>return b1.size() == b2.size()
          &amp;&amp; memcmp(b1.data(), b2.data(), b1.size()) == 0</ins>;
    })
</pre>
</td>
</tr>
</table>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3027"><a href="3027">3027</a>. [networking.ts] <code>DynamicBuffer</code> <code>prepare</code> exception specification</h3>
<p><b>Section:</b> 16.2.4 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.dynamicbuffer">[networking.ts::buffer.reqmts.dynamicbuffer]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Vinnie Falco <b>Opened:</b> 2017-10-16 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#networking.ts::buffer.reqmts.dynamicbuffer">active issues</a> in [networking.ts::buffer.reqmts.dynamicbuffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#networking.ts::buffer.reqmts.dynamicbuffer">issues</a> in [networking.ts::buffer.reqmts.dynamicbuffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: networking.ts</b></p>
<p>
The current wording for the <code>DynamicBuffer</code> <code>prepare</code>
member function implies that <code>std::length_error</code> is the
only allowable thrown exception. This should be changed to reflect that
any exception may be thrown, with <code>std::length_error</code> thrown
in particular when <code>size() + n</code> exceeds <code>max_size()</code>.
</p>

<p><i>[2017-11-08]</i></p>

<p>Priority set to 3 after five votes on mailing list</p>


<p id="res-3027"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4588">N4588</a>.</p>

<ol>
<li><p>Change 16.2.4 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.dynamicbuffer">[networking.ts::buffer.reqmts.dynamicbuffer]</a>, Table 14 "DynamicBuffer requirements", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 14 &mdash; <code>DynamicBuffer</code> requirements</caption>
<tr>
<th>expression</th>
<th>return type</th>
<th>assertion/note pre/post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>x.prepare(n)</code>
</td>
<td>
<code>X::mutable_buffers_type</code>
</td>
<td>
Returns a mutable buffer sequence <code>u</code><br/>
representing the writable bytes, and where<br/>
<code>buffer_size(u) == n</code> . The dynamic buffer<br/>
reallocates memory as required. All constant or<br/> 
mutable buffer sequences previously obtained using<br/>
<code>data()</code> or <code>prepare()</code> are invalidated.<br/>
<i>Throws:</i> <code>length_error</code> if <code>size() + n</code><br/>
exceeds <code>max_size()</code> <ins>or any other exception<br/> 
if the request cannot otherwise be satisfied</ins>.
</td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3029"><a href="3029">3029</a>. <code>pop_heap</code> over-constrains input</h3>
<p><b>Section:</b> 26.8.8.3 <a href="https://timsong-cpp.github.io/cppwp/pop.heap">[pop.heap]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Mathias Stearn <b>Opened:</b> 2017-11-04 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The spec for <code>&lt;algorithms&gt;</code> <code>pop_heap</code> includes
</p>
<blockquote><p>
-1- <i>Requires:</i> The range <code>[first, last)</code> shall be a valid non-empty heap.
</p></blockquote>
<p>
This has the unfortunate consequence that to pop a value and push a new value is substantially less efficient than necessary. 
The popped value must be extracted by <code>pop_heap</code> (using up to 2 log <code><i>N</i></code> compares and swaps), and then, in 
<code>push_heap</code>, the new value must be inserted (for up to <code><i>N</i></code> compares and swaps, but more usually something 
like log <code><i>N</i></code>).
<p/>
Simply relaxing the requirement to
</p>
<blockquote><p>
-1- <i>Requires:</i> The range <code>[first, last - 1)</code> shall be a valid heap.
</p></blockquote>
<p>
enables use of <code>pop_heap</code> in an integrated push-and-pop operation, with less than half the number of expected compare 
and swap operations. Furthermore, if, as is often the case, the newly pushed value would have ended up at position <code>first</code>, 
the push/pop operation could complete in time <code>&#x1d4aa;(1)</code>, instead of (3 log <code><i>N</i></code>).
<p/>
The effect of the proposed relaxation on existing library implementations would be minimal in the extreme, and on existing user 
code nil. The base algorithm code remains exactly identical. The only changes needed would be to any instrumentation in a 
debugging version of the library, which would just need to relax its check, and to test suites that should exercise the newly 
tolerated input.
<p/>
Users today are tempted to get the improved performance by relying on existing implementations' tacit tolerance of input that 
only satisfies the proposed, relaxed requirements. In fact, the 
<a href="http://en.cppreference.com/w/cpp/algorithm/pop_heap">cppreference.com page on <code>pop_heap</code></a> offers no hint 
that this usage is not already allowed. This change would bless such reliance as formally permitted.
<p/>
After this change, minor extensions to <code>std::priority_queue</code> would enable it to take advantage of the newly efficient operation, 
perhaps:
</p>
<blockquote><pre>
void pop_push(const Type&amp;);
void pop_push(Type&amp;&amp;);
template &lt;class... Args&gt; void pop_emplace(Args&amp;&amp;... args);
</pre></blockquote>
<p>
These will appear in a formal proposal if the resolution is accepted.
</p>

<p><i>[2017-11 Albuquerque Wednesday night issues processing]</i></p>

<p>Priority set to 3</p>

<p><i>[2017-11 Albuquerque Saturday issues processing]</i></p>

<p>status to Open; Marshall to review</p>


<p id="res-3029"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4700">N4700</a>.</p>

<ol>
<li><p>Change 26.8.8.3 <a href="https://timsong-cpp.github.io/cppwp/pop.heap">[pop.heap]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RandomAccessIterator&gt;
  void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
template&lt;class RandomAccessIterator, class Compare&gt;
  void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                Compare comp);
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> The range <code>[first, last <ins>- 1</ins>)</code> shall be a valid <del>non-empty</del> heap. 
<code>RandomAccessIterator</code> shall satisfy the requirements of <code>ValueSwappable</code> (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>). 
The type of <code>*first</code> shall satisfy the requirements of <code>MoveConstructible</code> (Table 23) and of <code>MoveAssignable</code> 
(Table 25).
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3044"><a href="3044">3044</a>. Strange specification of <code>max_size()</code> for an allocator</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jon Cohen <b>Opened:</b> 2017-12-06 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 31 in the C++17 standard specifies <code>X::max_size()</code> (where <code>X</code> is an allocator type) as "The largest value 
that can meaningfully be passed to <code>X::allocate()</code>". Noticeably missing is the statement "<i>Throws:</i> Nothing".
<p/>
As an example of why this is an issue, note that <code>vector::max_size()</code> and <code>allocator_traits::max_size()</code> are 
both marked <code>noexcept</code>. We must then interpret <code>max_size()</code> as being allowed to sometimes call 
<code>std::terminate</code>, or else <code>{vector, allocator_traits, ...}::max_size()</code> must be allowed to directly calculate 
<code>numeric_limits&lt;size_type&gt;::max() / sizeof(value_type)</code> instead of querying the allocator, even if 
<code>Alloc::max_size()</code> exists. This seems like a bug in the wording for the requirements of <code>max_size()</code> in an 
allocator type. I think an issue should be opened on this subject to add <i>Throws:</i> Nothing or similar to the requirements 
of <code>max_size()</code> for an allocator.
<p/>
As an example consider writing up a framework to test the exception-safety of types in a given framework, since they were all 
written in an exception-free environment. One of the types in the framework is an allocator which, in a controlled way, 
can throw an exception at any point where it is allowed by the standard. It's important that the test framework be as pedantic 
as possible, so the allocator type throws on <code>max_size()</code>, since it is currently allowed to by the standard. When a 
reasonable <code>vector</code> implementation (at least those in libstdc++ and msvc) is, for example, asked to construct a 
<code>vector</code> from an <code>initializer_list</code>, it will call <code>allocator_traits&lt;Alloc&gt;::max_size()</code>, which will 
terminate the program because the exception thrown in <code>Alloc::max_size()</code> propagated through the <code>noexcept</code> 
traits function. Although this is conformant behavior, I think it's a bug in the standard that a function as benign as 
<code>max_size()</code> can terminate the program in this manner, and I think the fix is that a conformant allocator should be 
required to supply a non-throwing <code>max_size()</code> member function.
<p/>
Daniel:
<p/>
This problem was shortly discussed during review of LWG <a href="2162" title="allocator_traits::max_size missing noexcept (Status: C++14)">2162</a> (see comment 2012-08-05). At that time
the more drastic but also more consistent requirement that an allocator's <code>max_size</code> function shall not throw
exceptions has not been added. IMO this position should be reconsidered to follow the spirit of the new issue LWG 
<a href="3044" title="Strange specification of max_size() for an allocator (Status: New)">3044</a>.
</p>

<p><i>[2018-01; Priority set to 3 after mailing list discussion]</i></p>


<p><i>[2018-08-21, Jonathan comments and provides wording]</i></p>

<p>
The phrase "the largest value that can meaningfully be passed to <code>X::allocate()</code>" is meaningless. Is it a 
requirement on the caller, so that larger values must not be passed? Or a hint from the allocator implementor that larger 
values will produce a <code>bad_alloc</code> exception? Can the return value change dynamically, based on the free memory
available to the allocator?! &mdash; LWG <a href="197" title="max_size() underspecified (Status: NAD)">197</a> says it can't change.
<p/>
As noted in the LWG <a href="2162" title="allocator_traits::max_size missing noexcept (Status: C++14)">2162</a> comments, we don't currently guarantee it can be called on a <code>const</code> object 
(so <code>allocator_traits</code> will not use the allocator's <code>max_size()</code> if it's non-<code>const</code>, although that was 
unclear before DR <a href="2284" title="Inconsistency in allocator_traits::max_size (Status: C++14)">2284</a>). In addition to adding "<i>Throws:</i> nothing" we should ensure it's callable 
on <code>const</code> lvalues, and clarify what "meaningfully" means and who is supposed to care about it. My proposed 
resolution doesn't achieve all of this, but is a start.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4762" title=" Working Draft, Standard for Programming Language C++">N4762</a>.
</p>

<ol>
<li><p>Change 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 32 &mdash; "Descriptive variable definitions", as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 32 &mdash; Descriptive variable definitions</caption>
<tr>
<th>Variable</th>
<th>Definition</th>
</tr>

<tr>
<td>
<code>T, U, C</code>
</td>
<td>
any <i>cv</i>-unqualified object type (3.9)
</td>
</tr>

<tr>
<td colspan="2" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>a, a1, a2</code>
</td>
<td>
lvalues of type <code>X</code>
</td>
</tr>

<tr>
<td>
<ins><code>a3</code></ins>
</td>
<td>
<ins>an lvalue of type <code>const X</code></ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Change 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 33 &mdash; "<i>Cpp17Allocator</i> requirements", as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 33 &mdash; <i>Cpp17Allocator</i> requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>a<ins>3</ins>.max_size()</code>
</td>
<td>
<code>X::size_type</code>
</td>
<td>
the largest value that can<br/>
meaningfully be passed to<br/>
<code>X::allocate()</code><ins>.<br/> 
[<i>Note:</i> Larger values might cause<br/> 
an exception to be thrown. &mdash; <i>end note</i>]<br/> 
<i>Throws:</i> Nothing.</ins>
</td>
<td>
<code>numeric_limits&lt;size_type&gt;::max()<br/>
/ sizeof(value_type)</code>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2022-04-25; Daniel rebases wording on <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>]</i></p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Change 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> as indicated:</p>


<blockquote>
<p>
-2- In subclause 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>,
</p>
<ol style="list-style-type:none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(2.6) &mdash; <code>a</code>, <code>a1</code>, <code>a2</code> denote lvalues of type <code>X</code>,</p></li>
<li><p><ins>(?.?) &mdash; <code>a3</code> denotes an lvalue of type <code>const X</code>,</ins></p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>[&hellip;]</p>
<pre>
a<ins>3</ins>.max_size()
</pre>
<blockquote>
<p>
-50- <i>Result:</i> <code>X::size_type</code>
<p/>
-51- <i>Returns:</i> The largest value that can meaningfully be passed to <code>X::allocate()</code>.
<p/>
<ins>[<i>Note:</i> Larger values might cause an exception to be thrown. &mdash; <i>end note</i>]</ins> 
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-52- <i>Remarks:</i> Default: <code>numeric_limits&lt;size_type&gt;::max() / sizeof(value_type)</code>
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-10-10; Jonathan provides improved wording]</i></p>




<p id="res-3044"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>
<li><p>Change 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> as indicated:</p>


<blockquote>
<p>
-2- In subclause 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>,
</p>
<ol style="list-style-type:none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(2.6) &mdash; <code>a</code>, <code>a1</code>, <code>a2</code> denote lvalues of type <code>X</code>,</p></li>
<li><p><ins>(?.?) &mdash; <code>a3</code> denotes an lvalue of type (possibly const) <code>X</code>,</ins></p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>[&hellip;]</p>
<pre>
a<ins>3</ins>.max_size()
</pre>
<blockquote>
<p>
-50- <i>Result:</i> <code>X::size_type</code>
<p/>
-51- <i>Returns:</i> The largest value that can meaningfully be passed to <code>X::allocate()</code>.
<p/>
<ins>[<i>Note:</i> Larger values can cause an exception to be thrown. &mdash; <i>end note</i>]</ins>
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-52- <i>Remarks:</i> Default: <code>numeric_limits&lt;size_type&gt;::max() / sizeof(value_type)</code>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3046"><a href="3046">3046</a>. Do not require <code>reference_wrapper</code> to support non-referenceable function types</h3>
<p><b>Section:</b> 22.10.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap">[refwrap]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2017-12-14 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#refwrap">issues</a> in [refwrap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[refwrap] says that <code>reference_wrapper&lt;T&gt;</code> is a "wrapper around a reference to an object or function of type <code>T</code>" 
but this doesn't actually constrain it, and doesn't forbid non-referenceable function types like <code>int() const</code>.
<p/>
There is no way to construct a <code>reference_wrapper&lt;int() const&gt;</code> but implementations are required to provide partial 
specializations for functions with <i>cv</i>-qualifiers and ref-qualifiers in order to define a nested <code>result_type</code>. 
It should be undefined to instantiate <code>reference_wrapper&lt;T&gt;</code> with a non-referenceable type, or with a reference type 
(since references to references are not possible). Making it undefined (rather than ill-formed or unspecified) means implementations 
are not required to diagnose such invalid specializations, but also don't have to go to the effort of supporting weak result types etc.
</p>
<p><i>[2018-01; Priority set to 3 after mailing list discussion]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4713">N4713</a>.</p>

<ol>
<li><p>Modify 22.10.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap">[refwrap]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>reference_wrapper&lt;T&gt;</code> is a <code>CopyConstructible</code> and <code>CopyAssignable</code> wrapper around a reference 
to an object or function of type <code>T</code>. <ins><code>T</code> shall be a referenceable type (3.45 <a href="https://timsong-cpp.github.io/cppwp/defns.referenceable">[defns.referenceable]</a>) that 
is not a reference type.</ins>
<p/>
-2- <code>reference_wrapper&lt;T&gt;</code> shall be a trivially copyable type (6.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>).
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2019-03-15; Daniel comments and provides revised wording]</i></p>

<p>
The current wording is now far behind the working draft and a synchronization is therefore recommended. In particular, with the
acceptance of <a href="https://wg21.link/p0357r1">P0357R1</a>, the specification of <code>reference_wrapper</code> has no longer any
<i>weak result type</i>. Second, I would like to concur with a <a href="http://lists.isocpp.org/lib/2017/12/5023.php">remark 
from Tomasz</a> to change the wording to replace the undefined behavior by an ill-formed program instead, because <em>every</em>
attempt to instantiate the definition of <code>reference_wrapper</code> will instantiate its member declarations, and this would
cause the program to become ill-formed anyway because of the illegal formation of references to non-referenceable function 
types for member functions such as <code>T&amp; get() const noexcept</code>.
<p/>
As concrete wording suggestion I would recommend wording that ensures that an ill-formed program is only required when a
specialization of <code>reference_wrapper</code> is instantiated, because in the absence of a constrained template parameter
we shouldn't require implementations to diagnose even forming the name of a <code>reference_wrapper</code> specialization such 
as in the following example:
</p>
<blockquote><pre>
using X = reference_wrapper&lt;int() const&gt;;
</pre></blockquote>
<p>
The wording below does not take advantage of a <i>Mandates:</i> element to prevent a dependency on LWG <a href="3193" title="Mandates: and Expects: elements are not defined for types (Status: New)">3193</a>
and because such an element is rarely used to specify class templates. If the committee wishes to use such an element, 
the equivalent wording would be:
</p>
<blockquote><p>
<i>Mandates:</i> <code>reference_wrapper</code> is instantiated with a referenceable type (3.45 <a href="https://timsong-cpp.github.io/cppwp/defns.referenceable">[defns.referenceable]</a>) 
as the argument for the template parameter <code>T</code>.
</p></blockquote>


<p id="res-3046"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4800">N4800</a>.</p>

<ol>
<li><p>Modify 22.10.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap">[refwrap]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>reference_wrapper&lt;T&gt;</code> is a <i>Cpp17CopyConstructible</i> and <i>Cpp17CopyAssignable</i> wrapper around a reference
to an object or function of type <code>T</code>. <ins>If <code>reference_wrapper</code> is instantiated with a non-referenceable type 
(3.45 <a href="https://timsong-cpp.github.io/cppwp/defns.referenceable">[defns.referenceable]</a>) as the argument for the template parameter <code>T</code>, the program is ill-formed.</ins>
<p/>
-2- <code>reference_wrapper&lt;T&gt;</code> is a trivially copyable type (6.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>).
<p/>
-3- The template parameter <code>T</code> of <code>reference_wrapper</code> may be an incomplete type.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3047"><a href="3047">3047</a>. <code>atomic</code> compound assignment operators can cause undefined behavior when corresponding 
<code>fetch_<i>meow</i></code> members don't</h3>
<p><b>Section:</b> 32.5.8.3 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.int">[atomics.types.int]</a>, 32.5.8.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.pointer">[atomics.types.pointer]</a>, 32.5.8.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.memop">[atomics.types.memop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2017-12-15 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given <code>atomic&lt;int&gt; meow{INT_MAX};</code>, <code>meow.fetch_add(1)</code> has well-defined behavior because 32.5.8.3 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.int">[atomics.types.int]</a> p7 says that
<blockquote>
<p>
<i>Remarks:</i> For signed integer types, arithmetic is defined to use two's complement representation. There are no undefined results.
</p>
</blockquote>
but <code>meow += 1</code> and <code>++meow</code> have undefined behavior, because these operator functions are defined (by, respectively, 
32.5.8.3 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.int">[atomics.types.int]</a> p8 and 32.5.8.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.memop">[atomics.types.memop]</a>) to be equivalent to <code>return fetch_add(1) + 1;</code>, 
and so the addition of 1 to the result of <code>fetch_add</code> &mdash; which causes an integer overflow in this case &mdash; occurs 
outside the protection of <code>fetch_add</code> magic. Additionally, the return value might differ from what <code>fetch_add</code> actually
wrote since that addition isn't required to use two's complement. This seems like a trap for the unwary. Is it intended?
<p/>
A similar issue affects the <code>atomic&lt;T*&gt;</code> partial specialization for pointers.
</p>
<p><i>[2018-01; Priority set to 3 after mailing list discussion]</i></p>


<p><i>[2019-04-15; JF Bastien comments and provides wording]</i></p>

<p>
As discussed by LWG during the <a href="http://wiki.edg.com/bin/view/Wg21sandiego2018/LWGD1236Review">San 
Diego 2018 meeting</a>, Jens removed LWG 3047 from <a href="https://wg21.link/p1236r1">"P1236R1: Alternative Wording for P
0907R4 Signed Integers are Two's Complement"</a>.
</p>


<p id="res-3047"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 32.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.int">[atomics.ref.int]</a> as indicated:</p>

<blockquote>
<pre>
<i>integral</i> operator <i>op</i>=(<i>integral</i> operand) const noexcept;
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Equivalent to: <code>return 
<ins>static_cast&lt;<i>integral</i>&gt;(static_cast&lt;make_unsigned_t&lt;<i>integral</i>&gt;&gt;(</ins>fetch_<i>key</i>(operand)<ins>)</ins> 
<i>op</i> <ins>static_cast&lt;make_unsigned_t&lt;<i>integral</i>&gt;&gt;(</ins>operand<ins>))</ins>;</code>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 32.5.7.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.memop">[atomics.ref.memop]</a> as indicated:</p>

<blockquote>
<pre>
T* operator++() const noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to: <code>return 
<ins>static_cast&lt;T&gt;(static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>fetch_add(1)<ins>)</ins> + 
<ins>static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>1<ins>))</ins>;</code>
</p>
</blockquote>
<pre>
T* operator--(<del>int</del>) const noexcept;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to: <code>return 
<ins>static_cast&lt;T&gt;(static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>fetch_sub(1)<ins>)</ins> - 
<ins>static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>1<ins>))</ins>;</code>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 32.5.8.3 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.int">[atomics.types.int]</a> as indicated:</p>

<blockquote>
<pre>
T operator <i>op</i>=(T operand) volatile noexcept;
T operator <i>op</i>=(T operand) noexcept;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to: <code>return 
<ins>static_cast&lt;T&gt;(static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>fetch_<i>key</i>(operand)<ins>)</ins> 
<i>op</i> <ins>static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>operand<ins>))</ins>;</code>
</p>
</blockquote>
</blockquote>

<blockquote class="note">
<p>
[<i>Drafting note:</i> <code>atomic&lt;<i>integral</i>&gt;</code>'s working for <code>operator++/operator--</code> 
is shared with <code>atomic&lt;T*&gt;</code>. &mdash; <i>end drafting note</i>]
<p/>
[<i>Drafting note:</i> <code>atomic&lt;<i>floating-point</i>&gt;</code> seems to be correct, LWG should confirm 
that it is. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
</li>

<li><p>Modify 32.5.8.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.pointer">[atomics.types.pointer]</a> as indicated:</p>

<blockquote>
<pre>
T* operator <i>op</i>=(ptrdiff_t operand) volatile noexcept;
T* operator <i>op</i>=(ptrdiff_t operand) noexcept;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to: <code>return 
<ins>reinterpret_cast&lt;T*&gt;(reinterpret_cast&lt;ptrdiff_t&gt;(</ins>fetch_<i>key</i>(operand)<ins>)</ins> 
<i>op</i> operand<ins>)</ins>;</code>
<p/>
<ins><i>Remarks:</i> The result may be an undefined address, but the operations otherwise have no undefined behavior.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 32.5.8.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.memop">[atomics.types.memop]</a> as indicated:</p>

<blockquote>
<pre>
T operator++() volatile noexcept;
T operator++() noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to: <code>return 
<ins>static_cast&lt;T&gt;(static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>fetch_add(1)<ins>)</ins> + 
<ins>static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>1<ins>))</ins>;</code>
</p>
</blockquote>
<pre>
T operator--() volatile noexcept;
T operator--() noexcept;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to: <code>return 
<ins>static_cast&lt;T&gt;(static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>fetch_sub(1)<ins>)</ins> - 
<ins>static_cast&lt;make_unsigned_t&lt;T&gt;&gt;(</ins>1<ins>))</ins>;</code>
</p>
</blockquote>
</blockquote>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Alternatively, LWG may want to separate the integral overload of <code>operator++/operator--</code> 
from that of <code>atomic&lt;T*&gt;</code>. <i>end drafting note</i>]
</p>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3049"><a href="3049">3049</a>. Missing wording allowing algorithms to use copies of function objects as substitutes for their parameters</h3>
<p><b>Section:</b> 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jared Hoberock <b>Opened:</b> 2017-12-04 <b>Last modified:</b> 2022-04-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms.requirements">active issues</a> in [algorithms.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms.requirements">issues</a> in [algorithms.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When designing the parallel algorithms library, we intended for parallel algorithms to copy their function objects parameters 
when it is possible and useful to do so, but there doesn't appear to be any wording to enable that latitude. To the contrary, 
algorithm specifications refer to their function object parameters by name, implying that a copy of the parameter may not 
be used as a substitute.
<p/>
This was noticed when Billy O'Neal observed that parallel <code>generate()</code> did not share parallel <code>for_each()</code> and 
<code>for_each_n()</code>'s special requirement for a <code>CopyConstructible</code> user-provided function object.
<p/>
This <code>CopyConstructible Function</code> requirement was added to relax legacy <code>for_each()</code>'s <code>MoveConstructible Function</code>
requirement to allow parallel implementations to make copies as necessary. All parallel algorithms need similar permissions, 
but a strong requirement for <code>CopyConstructible</code> in all algorithms is too restrictive.
<p/>
What we require is to allow algorithm implementations to use copies of function objects as substitutes for their original parameters, 
while not requiring that all function object parameters be copyable.
<p/>
Casey Carter noted that 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> p8 grants permission to all algorithms to copy their function 
object parameters. However, this paragraph is not normative and does not indicate how the algorithm is allowed to use such copies. 
Additionally, it does not specify which algorithm parameters are the ones called out as function objects. For example, 
26.7.7 <a href="https://timsong-cpp.github.io/cppwp/alg.generate">[alg.generate]</a> refers to <code>gen</code> as a function object, but 26.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a> does not refer to <code>f</code> 
as a function object. All the other types of callable algorithm parameters (i.e. <code>Predicate</code>, <code>BinaryPredicate</code>, 
<code>Compare</code>, <code>UnaryOperation</code>, <code>BinaryOperation</code>, <code>BinaryOperation1</code>, and <code>BinaryOperation2</code>) 
are defined to be function objects in 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> and 26.3.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.parallel.user">[algorithms.parallel.user]</a>. This 
list intentionally omits <code>Function</code> and <code>Generator</code> by design.
<p/>
A potential resolution would introduce normative wording to explicitly allow algorithms to use copies of function object parameters 
as substitutes for their function object parameters, and remove ambiguity in algorithm specifications about which parameters are 
function objects.
</p>
<p><i>[2018-01; Priority set to 3 after mailing list discussion]</i></p>


<p><i>[2018-3-14 Wednesday evening issues processing; move to Open]</i></p>

<p>We thought that the notes in [alg.foreach]/1 and /11 should be unwrapped as well. Bryce to work with Jared on updated wording.</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4713" title=" Working Draft, Standard for Programming Language C++">N4713</a>.
</p>

<ol>
<li><p>Modify 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> as indicated:</p>

<blockquote>
<p>
-8- <del>[<i>Note:</i></del> Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy
those function objects freely. <ins>When an algorithm's specification requires the invocation of a function object parameter, 
such a copy may be invoked as a substitute for the original function object parameter.</ins> <ins>[<i>Note:</i> This implies 
that copyable user-supplied function objects should not rely on their identity.</ins> Programmers for whom object identity is 
important should consider using a wrapper class that points to a noncopied implementation object such as 
<code>reference_wrapper&lt;T&gt;</code> (22.10.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap">[refwrap]</a>), or some equivalent solution. &mdash; <i>end note</i>]
</p>
</blockquote>

</li>

<li><p>Modify 26.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class Function&gt;
  constexpr Function for_each(InputIterator first, InputIterator last, Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Effects:</i> Applies <ins>the function object</ins> <code>f</code> to the result of dereferencing every iterator in the range 
<code>[first, last)</code>, [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class ExecutionPolicy, class ForwardIterator, class Function&gt;
  void for_each(ExecutionPolicy&amp;&amp; exec,
                ForwardIterator first, ForwardIterator last,
                Function f);
</pre>
<blockquote>
<p>
<del>-6- <i>Requires:</i> <code>Function</code> shall meet the requirements of <code>CopyConstructible</code>.</del>
<p/>
-7- <i>Effects:</i> Applies <ins>the function object</ins> <code>f</code> to the result of dereferencing every iterator in the range 
<code>[first, last)</code>. [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class InputIterator, class Size, class Function&gt;
constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-13- <i>Effects:</i> Applies <ins>the function object</ins> <code>f</code> to the result of dereferencing every iterator in the range 
<code>[first, first + n)</code> in order. [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class Function&gt;
  ForwardIterator for_each_n(ExecutionPolicy&amp;&amp; exec, ForwardIterator first, Size n,
                             Function f);
</pre>
<blockquote>
<p>
<del>-16- <i>Requires:</i> <code>Function</code> shall meet the requirements of <code>CopyConstructible</code>.</del>
<p/>
[&hellip;]
<p/>
-18- <i>Effects:</i> Applies <ins>the function object</ins> <code>f</code> to the result of dereferencing every iterator in the range 
<code>[first, first + n).</code> [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-04-25; Daniel rebases wording on <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>]</i></p>

<p>
The previously refactored note term "can" in 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> p10 has been 
reverted to "permitted" to specify a normative implementation freedom.
</p>

<p><i>[2022-04-25; Daniel comments]</i></p>

<p>
Bryce and Jared have unassigned from this issue.
</p>


<p id="res-3049"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> as indicated:</p>

<blockquote>
<p>
-10- <del>[<i>Note 2:</i></del> Unless otherwise specified, algorithms that take function objects as arguments 
<del>can</del><ins>are permitted to</ins> copy those function objects freely. <ins>When an algorithm's 
specification requires the invocation of a function object parameter, such a copy may be invoked as a substitute 
for the original function object parameter.
[<i>Note:</i> This implies that copyable user-supplied function objects should not rely on their identity.</ins> 
If object identity is important, a wrapper class that points to a noncopied implementation object such as 
<code>reference_wrapper&lt;T&gt;</code> (22.10.6 <a href="https://timsong-cpp.github.io/cppwp/refwrap">[refwrap]</a>), or some equivalent solution, can be used. &mdash; 
<i>end note</i>]
</p>
</blockquote>

</li>

<li><p>Modify 26.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class Function&gt;
  constexpr Function for_each(InputIterator first, InputIterator last, Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Effects:</i> Applies <ins>the function object</ins> <code>f</code> to the result of dereferencing every iterator in the range 
<code>[first, last)</code>, [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class ExecutionPolicy, class ForwardIterator, class Function&gt;
  void for_each(ExecutionPolicy&amp;&amp; exec,
                ForwardIterator first, ForwardIterator last,
                Function f);
</pre>
<blockquote>
<p>
<del>-6- <i>Preconditions:</i> <code>Function</code> meets the <i>Cpp17CopyConstructible</i> requirements.</del>
<p/>
-7- <i>Effects:</i> Applies <ins>the function object</ins> <code>f</code> to the result of dereferencing every iterator in the range 
<code>[first, last)</code>. [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class InputIterator, class Size, class Function&gt;
constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-18- <i>Effects:</i> Applies <ins>the function object</ins> <code>f</code> to the result of dereferencing every iterator in the range 
<code>[first, first + n)</code> in order. [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class ExecutionPolicy, class ForwardIterator, class Size, class Function&gt;
  ForwardIterator for_each_n(ExecutionPolicy&amp;&amp; exec, ForwardIterator first, Size n,
                             Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-22- <i>Preconditions:</i> <code>n &gt;= 0</code> is <code>true</code>. <del><code>Function</code> meets the 
<code>Cpp17CopyConstructible</code> requirements.</del>
<p/>
-23- <i>Effects:</i> Applies <ins>the function object</ins> <code>f</code> to the result of dereferencing every iterator in the range 
<code>[first, first + n).</code> [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3053"><a href="3053">3053</a>. Prohibit <code>error_code</code> construction from rvalues of <code>error_category</code></h3>
<p><b>Section:</b> 19.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.overview">[syserr.errcode.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Antony Polukhin <b>Opened:</b> 2018-01-24 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#syserr.errcode.overview">issues</a> in [syserr.errcode.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Constructor <code>error_code(int val, const error_category&amp; cat)</code> and
member function <code>void assign(int val, const error_category&amp; cat)</code>
could be misused if a custom <code>error_category</code> is provided:
</p>
<blockquote><pre>
error_code ec{1, test_category{}}; // ec holds a pointer/reference to a temporary
</pre></blockquote>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>


<p id="res-3053"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4713">N4713</a>.</p>

<ol>
<li><p>Modify 19.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.overview">[syserr.errcode.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  class error_code {
  public:
    <i>// 19.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.constructors">[syserr.errcode.constructors]</a>, constructors</i>
    [&hellip;]
    error_code(int val, const error_category&amp; cat) noexcept;
    <ins>error_code(int val, const error_category&amp;&amp; cat) = delete;</ins>
    [&hellip;]
    // 19.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcode.modifiers">[syserr.errcode.modifiers]</a>, modifiers
    void assign(int val, const error_category&amp; cat) noexcept;
    <ins>void assign(int val, const error_category&amp;&amp; cat) = delete;</ins>
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3056"><a href="3056">3056</a>. <code>copy_file()</code> copies which attributes?</h3>
<p><b>Section:</b> 31.12.13.5 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy.file">[fs.op.copy.file]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Davis Herring <b>Opened:</b> 2018-01-26 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.copy.file">issues</a> in [fs.op.copy.file].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(To resolve <a href="https://wg21.link/p0489r0#page=5">C++17 CD comment Late 25</a>.) 
It is not stated which attributes are copied by <code>copy_file()</code>.
</p>

<p><i>[2018-1-26 issues processing telecon]</i></p>

<p>Priority 3</p>


<p id="res-3056"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4713">N4713</a>.</p>
<ol>
<li><p>Modify 31.12.13.5 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy.file">[fs.op.copy.file]</a> as indicated:</p>

<blockquote class="note">
<p>
<b>Rationale:</b>
<p/>
The attributes specified are the useful subset of the attributes that can be queried in C++17.  
Existing practice is complicated: POSIX "cp -p" attempts to preserve user/group IDs, for instance, 
but cannot in general do so, and <code>setuid/setgid</code> permissions may be stripped.
</p>
</blockquote>

<blockquote>
<pre>
bool copy_file(const path&amp; from, const path&amp; to, copy_options options);
bool copy_file(const path&amp; from, const path&amp; to, copy_options options,
               error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(4.2) &mdash; Otherwise, copy the contents<ins>, permissions, and data modification time</ins> 
<del>and attributes</del> of the file <code>from</code> resolves to, to the file <code>to</code> resolves to, if:</p></li>
<li><p>[&hellip;]</p></li>
<li>
<ol style="list-style-type: none">
<li><p>(4.2.3) &mdash; <code>(options &amp; copy_options::update_existing) != copy_options::none</code> 
and <code>from</code> is more recent than <code>to</code>, determined as if by use of the <code>last_write_time</code> 
function (31.12.13.26 <a href="https://timsong-cpp.github.io/cppwp/fs.op.last.write.time">[fs.op.last.write.time]</a>).</p></li>
</ol>
<p>
<ins>Other implementation-defined attributes may be copied. Failure (or partial failure) to copy attributes 
is not an error.</ins>
</p>
</li>
<li><p>[&hellip;]</p></li>
</ol>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3057"><a href="3057">3057</a>. Correct <code>copy_options</code> handling</h3>
<p><b>Section:</b> 31.12.13.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Davis Herring <b>Opened:</b> 2018-01-29 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.copy">issues</a> in [fs.op.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(The resolution of #3 resolves part of <a href="https://wg21.link/p0488r0#page=10">C++17 NB comment US 36</a>.) 
<p/>
The handling of several options for <code>filesystem::copy()</code> is wrong:
</p>
<ol>
<li><p>Single-level directory copying is silently suppressed by any flag other than 
<code>copy_options::recursive</code> (even <code>copy_options::directories_only</code>). Single-level 
directory copying operates via using some unspecified flag to trigger this misfeature.</p></li>
<li><p><code>copy_options::create_symlinks</code> and <code>copy_options::skip_symlinks</code> affect 
the interpretation of the destination name; the latter shouldn't ever, and the former should 
affect only broken symlinks (since it would want to replace them).</p></li>
<li><p>The <code>copy_options</code> groups for existing target files and the form of copying are 
consulted only for creating regular files.</p></li>
<li><p><code>copy("file", "dir")</code> creates dir/file, but <code>copy("symlink", "dir", 
copy_options::copy_symlinks)</code> fails.</p></li>
<li><p>If a symlink is encountered with <code>copy_options::copy_symlinks</code> and 
<code>copy_options::create_symlinks</code>, the latter flag is ignored (but its otherwise sensible 
restriction to absolute paths applies) rather than the former.</p></li>
<li><p><code>copy_options::create_symlinks</code> without <code>copy_options::copy_symlinks</code> 
fails if it encounters a symlink. (This is particularly damaging for recursive operation.)</p></li>
</ol>
<p>
This issue, since it replaces so much text, also addresses two error-handling concerns in passing:
</p>
<ol>
<li><p>The significance of <code>equivalent(from, to)</code> failing is unspecified. (Ignoring such 
failures entirely would make dangerous those operations that replace the target with a link.)</p></li>
<li><p>Copying a directory involves several operations. When an <code>error_code</code> is being used, 
the process continues past errors and (because successful functions call <code>ec.clear()</code>) 
may suppress them.</p></li>
</ol>
<p>
This expands on the resolution for LWG <a href="2681" title="filesystem::copy() cannot copy symlinks (Status: C++17)">2681</a>.
<p/>
This also addresses the same issue as LWG <a href="2682" title="filesystem::copy() won't create a symlink to a directory (Status: C++20)">2682</a>, but has a different result 
(based on the fact that the Example successfully copies directories to new, non-existent names).
</p>

<p><i>[2018-06; Rapperswil Wednesday evening, discussing LWG <a href="2682" title="filesystem::copy() won't create a symlink to a directory (Status: C++20)">2682</a>]</i></p>

<p>
JW: can we use the words we are shipping already since two years?<br/>
BO: what we got is better than what we had before<br/>
no objection to moving to Ready<br/>
ACTION move to Ready<br/>
ACTION link LWG <a href="2682" title="filesystem::copy() won't create a symlink to a directory (Status: C++20)">2682</a> and LWG 3057 and set a priority 2 and look at 3057 in San Diego 
</p>

<p><i>[2018-11 San Diego Thursday night issue processing]</i></p>

<p>Need to gather implementation experience; revisit in Kona. Status to Open.</p>

<p><i>[2018-11-13; Billy O'Neal comments]</i></p>

<p>
I (Billy O'Neal) prefer Davis' solution to LWG 3057, as I think the wording follows the meaning of the individual 
enum values more closely, and enables more scenarios to function correctly instead of reporting such cases as errors.
<p/>
However, I don't want to adopt that wording as is because it requires my implementation to detect errors in places 
that force us to do a bunch of extra system calls, and I don't believe those specific ways error handling happens 
is relevant to what the copy API wants to do.
<p/>
Ideally, the wording would be structured such that it said "here's a list of error conditions, if they happen we 
aren't going to tell you when exactly they are detected" and then listed the behavior irrespective of when errors 
happen. That way implementations can do the error checks when it makes sense according to what their system APIs 
report. For example, anything that requires symlink resolution is very expensive on my platform so I'd want to 
be able to defer anything related to status (rather than <code>symlink_status</code>) to after I've detected that 
there's actually a symlink (or junction) involved.
</p>


<p id="res-3057"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4750">N4750</a>.</p>

<ol>
<li><p>Modify Table 115 &mdash; "Enum class <code>copy_options</code>" as indicated:</p>

<blockquote>
 <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse">
  <tr>
    <th colspan="2">Option group controlling <ins><code>copy</code> and</ins> <code>copy_file</code> 
    function effects for existing target files</th>
  </tr>
    <tr>
      <td><b>Constant</b></td>
      <td><b>Meaning</b></td>
    </tr>
    <tr>
      <td>[&hellip;]</td>
      <td>[&hellip;]</td>
    </tr>
  </table>
</blockquote>

</li>

<li><p>Modify 31.12.13.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a> as indicated:</p>

<blockquote class="note">
<p>
<b>Rationale:</b>
<p/>
POSIX.1-2008 allows the implementation to create hard links "to" symbolic links, and provides 
<code>linkat()</code> to choose between the symlink and its target.
<p/>
31.12.13.4 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy">[fs.op.copy]</a>/4.9 is redundant given 31.12.5 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>/3.1.
</p>
</blockquote>

<blockquote>
<pre>
void copy(const path&amp; from, const path&amp; to, copy_options options);
void copy(const path&amp; from, const path&amp; to, copy_options options,
          error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Requires:</i> At most one element from each option group (31.12.8.3 <a href="https://timsong-cpp.github.io/cppwp/fs.enum.copy.opts">[fs.enum.copy.opts]</a>) 
is set in <code>options</code>.
<p/>
-4- <i>Effects:</i> <del>Before the first use of <code>f</code> and <code>t</code>:</del>
<ol style="list-style-type: none">
<li><p><del>(4.1) &mdash; If [&hellip;]</del></p></li>
<li><p><del>[&hellip;]</del></p></li>
<li><p><del>(4.10) &mdash; Otherwise, no effects.</del></p></li>
</ol>
<ins>If each is needed below,</ins>
<blockquote><pre>
<ins>auto linkf = (options &amp; (copy_options::copy_symlinks |
                         copy_options::skip_symlinks)) != copy_options::none;
auto f = linkf ? symlink_status(from) : status(from), t = status(to);
auto to2 = !is_directory(f) &amp;&amp; is_directory(t) ? to/from.filename() : to.
bool linkt = (options &amp; (copy_options::create_symlinks |
                         copy_options::create_hard_links)) != copy_options::none ||
            is_symlink(f);
auto t2 = linkt ? symlink_status(to2) : status(to2);</ins>
</pre></blockquote>

<blockquote class="note">
<p>
[<i>Drafting note:</i> <code>copy_options::create_symlinks</code> is intentionally omitted for linkf; 
it may simply have been a typo for <code>copy_options::copy_symlinks</code> (which was added by LWG 
<a href="2681" title="filesystem::copy() cannot copy symlinks (Status: C++17)">2681</a>) since at least <a href="https://wg21.link/n3940">N3940</a>.]
</p>
</blockquote>

<ins>Effects are then as follows:</ins>
<ol style="list-style-type: none">
<li><p><ins>(?.?) &mdash; If <code>f.type()</code> or <code>t.type()</code> is an implementation-defined 
file type  [fs.enum.file_type], then the effects are implementation-defined.</ins></p>
<blockquote class="note">
<p>
[<i>Drafting note:</i> the text between the previous drafting note and this one is the only unchanged 
text under /4.]
</p>
</blockquote>
</li>
<li><p><ins>(?.?) &mdash; Otherwise, if <code>exists(f)</code> is <code>false</code>, report an error as 
specified in 31.12.5 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.</ins></p></li>
<li><p><ins>(?.?) &mdash; Otherwise, do nothing if</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?) &mdash; <code>(options &amp; copy_options::directories_only) != copy_options::none</code> 
and <code>is_directory(f)</code> is <code>false</code>, or</ins></p></li>
<li><p><ins>(?.?.?) &mdash; <code>(options &amp; copy_options::skip_symlinks) != copy_options::none</code> 
and <code>is_symlink(f)</code> is <code>true</code>, or</ins></p></li>
<li><p><ins>(?.?.?) &mdash; <code>(options &amp; copy_options::skip_existing) != copy_options::none</code> 
and <code>exists(t2)</code> is <code>true</code>.</ins></p></li>
</ol>
</li>
<li><p><ins>(?.?) &mdash; Otherwise, report an error as specified in 31.12.5 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a> 
if:</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?) &mdash; <code>is_other(f) || is_other(t2)</code> is <code>true</code>, or</ins></p></li>
<li><p><ins>(?.?.?) &mdash; <code>exists(t2) &amp;&amp; exists(from) == exists(to2) &amp;&amp; 
equivalent(from, to)</code> is <code>true</code>.</ins></p></li>
</ol>
</li>
<li><p><ins>(?.?) &mdash; Otherwise, if <code>is_directory(f)</code> is <code>true</code>, then:</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?) &mdash; <code>create_directory(to, from)</code>.</ins></p></li>
<li><p><ins>(?.?.?) &mdash; If <code>(options &amp; copy_options::recursive) != copy_options::none</code> 
or if <code>(options &amp; copy_options::directories_only) == copy_options::none</code>, iterate over 
the files in <code>from</code>, as if by</ins></p>
<blockquote><pre>
<ins>for (const directory_entry&amp; x : directory_iterator(from))
  if ((options &amp; copy_options::recursive) != copy_options::none ||
     !is_directory(linkf ? symlink_status(x.path()) : status(x.path())))
       copy(x.path(), to/x.path().filename(), options);</ins>
</pre></blockquote>
</li>
</ol>
</li>
<li><p><ins>(?.?) &mdash; Otherwise, do nothing if <code>(options &amp; copy_options::update_existing) 
!= copy_options::none, exists(to2)</code> is <code>true</code>, and <code>from</code> is not more recent than 
<code>to2</code>, determined as if by use of the <code>last_write_time</code> function 
( [fs.op.last_write_time]).</ins></p></li>
<li><p><ins>(?.?) &mdash; Otherwise, report an error as specified in 31.12.5 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a> 
if:</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?) &mdash; <code>is_directory(t2)</code> is <code>true</code>, or</ins></p></li>
<li><p><ins>(?.?.?) &mdash; <code>(options &amp; (copy_options::overwrite_existing |
copy_options::update_existing)) == copy_options::none</code> and <code>exists(t2)</code> is <code>true</code>.</ins></p></li>
</ol>
</li>
<li><p><ins>(?.?) &mdash; Otherwise, if <code>linkt</code> is <code>true</code>, then:</ins></p>
<ol style="list-style-type: none">
<li><p><ins>(?.?.?) &mdash; <code>remove(to2)</code> if an existing <code>to2</code> would prevent the 
following link creation.</ins></p></li>
<li><p><ins>(?.?.?) &mdash; If <code>(options &amp; copy_options::create_symlinks) 
!= copy_options::none</code>, <code>create_symlink(from, to2)</code>. [<i>Note:</i> If <code>from</code> 
is a symbolic link, it is not followed. &mdash; <i>end note</i>]</ins></p></li>
<li><p><ins>(?.?.?) &mdash; Otherwise, if <code>(options &amp; copy_options::create_hard_links) 
!= copy_options::none</code>, then create a hard link to <code>from</code>, if <code>linkf</code> is <code>true</code>, 
or else to the file that <code>from</code> resolves to. [<i>Note:</i> Not all file systems that support 
hard links and symbolic links support creating hard links to symbolic links. &mdash; <i>end note</i>]</ins></p></li>
<li><p><ins>(?.?.?) &mdash; Otherwise, <code>copy_symlink(from, to2)</code>.</ins></p></li>
</ol>
</li>
<li><p><ins>(?.?) &mdash; Otherwise, <code>copy_file(from, to2, options)</code>.</ins></p></li>
</ol>
<p/>
-5- <i>Throws:</i> As specified in 31.12.5 <a href="https://timsong-cpp.github.io/cppwp/fs.err.report">[fs.err.report]</a>.
<p/>
-6- <i>Remarks:</i> For the signature with argument <code>ec</code>, any library functions called by the 
implementation shall have an <code>error_code</code> argument if applicable. <ins>If any such function fails, 
<code>copy</code> returns immediately without (further) modifying <code>ec</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3059"><a href="3059">3059</a>. Wrong requirements for map-like associative container assignment?</h3>
<p><b>Section:</b> 23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2018-02-05 <b>Last modified:</b> 2018-02-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What are the requirements for
</p>
<blockquote><pre>
a = b;
</pre></blockquote>
<p>
... where <code>a</code> and <code>b</code> are of map-like associative container type (<code>map</code>, 
<code>multimap</code>, <code>unordered_map</code>, <code>unordered_multimap</code>)?
<p/>
The general container requirements say just:
</p>
<blockquote><pre>
r = a  <i>// Postconditions: r == a</i>
</pre></blockquote>
<p>
(Incidentally, earlier in the table, there is a clear error: the general container requirements permit 
"<code>a = rv</code>" for assignment from an rvalue, but "<code>a</code>" here is a potentially-const container. 
Oops.) Oddly. there are no requirements at all on <code>T</code> here.
<p/>
The allocator-aware container requirements add:
</p>
<blockquote><pre>
a = t  <i>// Requires: T is CopyInsertable into X and CopyAssignable.</i>
</pre></blockquote>
<p>
... where <code>T</code> is the container's <code>value_type</code>, that is, <code>pair&lt;const key_type, 
mapped_type&gt;</code>. Note that such a pair is not <code>CopyAssignable</code> for "normal" key types 
that disallow assignment to <code>const</code> objects. They also add:
</p>
<blockquote><pre>
a = rv  <i>// Requires: if !POCMA, T is MoveInsertable into X and MoveAssignable.</i>
</pre></blockquote>
<p>
... which has the same problem in the !POCMA case.
<p/>
The associative container requirements and unordered associative container requirements have a similar problem for assignment from an initializer list:
</p>
<blockquote><pre>
a = il  <i>// Requires: value_type is CopyInsertable into X and CopyAssignable.</i>
</pre></blockquote>
<p>
Presumably these assignments are intended to actually work, but what are the intended constraints? 
Do we wish to allow implementations to perform node reuse for these map-like containers? 
Presumably yes, and if so, the <code>key_type</code> portion of the node must be assigned as well as the 
<code>value_type</code> portion (for instance, with whatever implementation technique is used to power 
<code>node_handle</code>) as we cannot assume that key equivalence (or, for <code>unordered_*map</code>, 
even key equality) implies substitutability.
<p/>
I think, then, that the associative container requirements and unordered associative container requirements should specify different requirements for the "<code>a = t</code>", "<code>a = rv</code>", and "<code>a = il</code>" for the map-like containers; specifically:
</p>
<ul>
<li><p>for "<code>a = t</code>" and "<code>a = il</code>", we should require that <code>value_type</code> is 
<code>CopyInsertable</code> into <code>X</code>, and <code>key_type</code> and <code>mapped_type</code> are 
<code>CopyAssignable</code></p></li>
<li><p>for "<code>a = rv</code>", if !POCMA, we should require that <code>value_type</code> is 
<code>MoveInsertable</code> into <code>X</code> and <code>key_type</code> and <code>mapped_type</code> are 
<code>MoveAssignable</code></p></li>
</ul>
<p>
(And we should fix the general container requirements to constrain "<code>r = rv</code>", not "<code>a = rv</code>".)
<p/>
<b>Daniel:</b>
<p/>
The "<code>a = rv</code>" problematic is already handled by LWG <a href="3028" title="Container requirements tables should distinguish const and non-const variables (Status: C++23)">3028</a>.
</p>

<p><i>[2018-02-13, Priority set to 3 after mailing list discussion]</i></p>



<p id="res-3059"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3060"><a href="3060">3060</a>. <code>XXX_scan</code> algorithms are specified to work with move-only <code>T</code>, but are 
specified to make <code><i>N</i></code> copies of <code>T</code> into the destination range</h3>
<p><b>Section:</b> 26.10.8 <a href="https://timsong-cpp.github.io/cppwp/exclusive.scan">[exclusive.scan]</a>, 26.10.9 <a href="https://timsong-cpp.github.io/cppwp/inclusive.scan">[inclusive.scan]</a>, 26.10.10 <a href="https://timsong-cpp.github.io/cppwp/transform.exclusive.scan">[transform.exclusive.scan]</a>, 26.10.11 <a href="https://timsong-cpp.github.io/cppwp/transform.inclusive.scan">[transform.inclusive.scan]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-02-06 <b>Last modified:</b> 2019-01-20</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#exclusive.scan">issues</a> in [exclusive.scan].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All of the scan algorithms ([exclusive.scan], [inclusive.scan], [transform.exclusive.scan], [transform.inclusive.scan]) have language like "If <code>init</code> is provided, <code>T</code> shall be 
<code>MoveConstructible</code> (Table 23); otherwise, <code>ForwardIterator1</code>'s value type shall be
<code>MoveConstructible</code>.". However, the algorithms operational semantics require that that type 
be written "by copy" to the destination range, making support for move only types impossible.
<p/>
We probably need to examine real implementations of these things and see what requirements are actually 
necessary, as in general <code><i>GENERALIZED_SUM</i></code> and <code><i>GENERALIZED_NONCOMMUTATIVE_SUM</i></code> 
need to specify the type used to store intermediate calculations.
</p>

<p><i>[2019-01-20 Reflector prioritization]</i></p>

<p>Set Priority to 2</p>


<p id="res-3060"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3063"><a href="3063">3063</a>. Parallel algorithms in <code>&lt;memory&gt;</code> are underspecified</h3>
<p><b>Section:</b> 26.11 <a href="https://timsong-cpp.github.io/cppwp/specialized.algorithms">[specialized.algorithms]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2018-02-12 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#specialized.algorithms">active issues</a> in [specialized.algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The parallel forms of the uninitialized memory algorithms in <code>&lt;memory&gt;</code> are
underspecified in two ways. First, they missed the change that all parallel
algorithms require at least Forward Iterators, even for input ranges. See
<a href="https://wg21.link/p0467r2">P0467R2</a> for more details.
<p/>
The second problem is that they do not have a separate specification to
the serial forms. This is a problem in two ways. First, there is no more
blanket wording saying a parallel policy algorithm has the same semantics
as the serial form unless otherwise specified, so in principle these algorithms
are totally unspecified. However, assuming that intent, all of the existing
specifications use an as-if formulation with code that is explicitly serial in
nature, so need a new specification that talks about the effects on each
element without including the iteration order.
</p>

<p><i>[2018-02-20, Priority set to 3 after mailing list discussion]</i></p>



<p id="res-3063"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3066"><a href="3066">3066</a>. "report a domain error" in [sf.cmath]/1 is underspecified</h3>
<p><b>Section:</b> 29.7.6 <a href="https://timsong-cpp.github.io/cppwp/sf.cmath">[sf.cmath]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-02-17 <b>Last modified:</b> 2018-06-19</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.7.6 <a href="https://timsong-cpp.github.io/cppwp/sf.cmath">[sf.cmath]</a>/1 uses the phrase "report a domain error" (emphasis mine):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
If any argument value to any of the functions specified in this subclause is a NaN (Not a Number), the
function shall return a NaN but it shall not <b>report a domain error</b>. Otherwise, the function shall 
<b>report a domain error</b> for just those argument values for which:
</p>
<ul>
<li><p>the function description's <i>Returns:</i> clause explicitly specifies a domain and those argument 
values fall outside the specified domain, or</p></li>
<li><p>the corresponding mathematical function value has a nonzero imaginary component, or</p></li>
<li><p>the corresponding mathematical function is not mathematically defined.</p></li>
</ul>
</blockquote>
<p>
The behavior this phrase is attempting to convey is unclear. A quick search through the text of the 
standard for "domain error" finds only the <code>domain_error</code> exception type defined in 
19.2.4 <a href="https://timsong-cpp.github.io/cppwp/domain.error">[domain.error]</a>. Is the intent of "report a domain error" that the special math functions 
throw an exception of type <code>domain_error</code>, or is it that they behave as specified in C11 
7.12.1 "Treatment of error conditions" para 2 which defines the term "domain error"?
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>


<p id="res-3066"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3069"><a href="3069">3069</a>. Move assigning <code>variant</code>'s subobject corrupts data</h3>
<p><b>Section:</b> 22.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.assign">[variant.assign]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Antony Polukhin <b>Opened:</b> 2018-02-20 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.assign">active issues</a> in [variant.assign].</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.assign">issues</a> in [variant.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>variant::emplace</code> functions in 22.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a> destroy the currently
contained value before initializing it to a new value. Assignments in 
22.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.assign">[variant.assign]</a> are described in terms on <code>emplace</code>.
<p/>
This leads to situation, when move/copy assigning subobject from <code>variant</code> into the same 
<code>variant</code> corrupts data:
</p>
<blockquote><pre>
#include &lt;variant&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;

using str_t = std::string;
using str_ptr_t = std::unique_ptr&lt;str_t&gt;;
using var_t = std::variant&lt;str_t, str_ptr_t&gt;;

int main() 
{
  var_t v = str_ptr_t{
    new str_t{"Long string that does not fit into SS buffer and forces dynamic allocation"}
  };

  // Any of the following lines corrupt the variant's content:
  v = *std::get&lt;str_ptr_t&gt;(v);
  //v = std::move(*std::get&lt;str_ptr_t&gt;(v));

  std::cout &lt;&lt; std::get&lt;str_t&gt;(v) &lt;&lt; std::endl; // SEGV - 'str_t' inside 'v' is invalid
}
</pre></blockquote>
<p>
Such behavior confuses users, especially those users who are used to
<code>boost::variant</code>'s behavior. Consider making <code>variant</code> assignments safer
by defining them close to copy-and-swap.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3; Antony volunteered to write a paper for Rapperswil.</p>


<p id="res-3069"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li><p>Change 22.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.assign">[variant.assign]</a> as indicated:</p>
<blockquote>
<pre>
variant&amp; operator=(const variant&amp; rhs);
</pre>
<blockquote>
<p>
-1- Let <code><i>j</i></code> be <code>rhs.index()</code>.
<p/>
-2- <i>Effects:</i>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If neither <code>*this</code> nor <code>rhs</code> holds a value, there is no effect.</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code>*this</code> holds a value but <code>rhs</code> does not, 
destroys the value contained in <code>*this</code> and sets <code>*this</code> to not hold a value.</p></li>
<li><p>(2.3) &mdash; Otherwise, if <code>index() == <i>j</i></code>, assigns the value contained in <code>rhs</code> 
to the value contained in <code>*this</code>.</p></li>
<li><p><del>(2.4) &mdash; Otherwise, if either <code>is_nothrow_copy_constructible_v&lt;T<sub><i>j</i></sub>&gt;</code> 
is <code>true</code> or <code>is_nothrow_move_constructible_v&lt;T<sub><i>j</i></sub>&gt;</code> is 
<code>false</code>, equivalent to <code>emplace&lt;<i>j</i>&gt;(get&lt;<i>j</i>&gt;(rhs))</code>.</del></p></li>
<li><p>(2.5) &mdash; Otherwise, equivalent to <ins><code>emplace&lt;<i>j</i>&gt;(T<sub><i>j</i></sub>{get&lt;<i>j</i>&gt;(rhs)})</code></ins><del><code>operator=(variant(rhs))</code></del>.</p></li>
</ol>
[&hellip;]
</p>
</blockquote>
<pre>
variant&amp; operator=(variant&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-6- Let <code><i>j</i></code> be <code>rhs.index()</code>.
<p/>
-7- <i>Effects:</i>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; If neither <code>*this</code> nor <code>rhs</code> holds a value, there is no effect.</p></li>
<li><p>(7.2) &mdash; Otherwise, if <code>*this</code> holds a value but <code>rhs</code> does not, 
destroys the value contained in <code>*this</code> and sets <code>*this</code> to not hold a value.</p></li>
<li><p>(7.3) &mdash; Otherwise, if <code>index() == <i>j</i></code>, assigns 
<code>get&lt;<i>j</i>&gt;(std::move(rhs))</code> to the value contained in <code>*this</code>.</p></li>
<li><p>(7.4) &mdash; Otherwise, equivalent to 
<code>emplace&lt;<i>j</i>&gt;(<ins>T<sub><i>j</i></sub>{</ins>get&lt;<i>j</i>&gt;(std::move(rhs))<ins>}</ins>)</code>.</p></li>
</ol>
[&hellip;]
</p>
</blockquote>
<pre>
</pre>
<blockquote>
<p>
-10- Let <code>T<sub><i>j</i></sub></code> be a type that is determined as follows: build an imaginary function 
<code><i>FUN</i>(T<sub><i>i</i></sub>)</code> for each alternative type <code>T<sub><i>i</i></sub></code>. The overload 
<code><i>FUN</i>(T<sub><i>j</i></sub>)</code> selected by overload resolution for the expression 
<code><i>FUN</i>(std::forward&lt;T&gt;(t))</code> defines the alternative <code>T<sub><i>j</i></sub></code> which is the 
type of the contained value after assignment.
<p/>
-11- <i>Effects:</i>
<ol style="list-style-type: none">
<li><p>(11.1) &mdash; If <code>*this</code> holds a <code>T<sub><i>j</i></sub></code>, assigns 
<code>std::forward&lt;T&gt;(t)</code> to the value contained in <code>*this</code>.</p></li>
<li><p><del>(11.2) &mdash; Otherwise, if <code>is_nothrow_constructible_v&lt;T<sub><i>j</i></sub>, T&gt; || !is_nothrow_move_constructible_v&lt;T<sub><i>j</i></sub>&gt;</code> is <code>true</code>, equivalent to 
<code>emplace&lt;<i>j</i>&gt;(std::forward&lt;T&gt;(t))</code>.</del></p></li>
<li><p>(11.3) &mdash; Otherwise, equivalent to 
<code><ins>emplace&lt;<i>j</i>&gt;(T<sub><i>j</i></sub>{std::forward&lt;T&gt;(t)})</ins><del>operator=(variant(std::forward&lt;T&gt;(t)))</del></code>.</p></li>
</ol>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3072"><a href="3072">3072</a>. [networking.ts] <code>DynamicBuffer</code> object lifetimes underspecified</h3>
<p><b>Section:</b> 16.2.4 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.dynamicbuffer">[networking.ts::buffer.reqmts.dynamicbuffer]</a>, 17.6 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read">[networking.ts::buffer.async.read]</a>, 17.8 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.write">[networking.ts::buffer.async.write]</a>, 17.10 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read.until">[networking.ts::buffer.async.read.until]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2018-02-26 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#networking.ts::buffer.reqmts.dynamicbuffer">active issues</a> in [networking.ts::buffer.reqmts.dynamicbuffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#networking.ts::buffer.reqmts.dynamicbuffer">issues</a> in [networking.ts::buffer.reqmts.dynamicbuffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses: networking.ts</b>
<p>The <code>DynamicBuffer</code> overloads of <code>async_read</code> and <code>async_write</code>, and 
<code>async_read_until</code>, are underspecified with respect to the lifetime of the dynamic 
buffer argument <code>b</code>.</p>

<p>Asio's implementation (and the intended specification) performs <code><em>DECAY_COPY</em>(b)</code> 
in the <code>async_read</code>, <code>async_write</code>, and <code>async_read_until</code> 
initiating functions. All operations performed on <code>b</code> are actually performed on that 
decay-copy, or on a move-constructed descendant of it. The copy is intended to refer to the same 
underlying storage and be otherwise interchangeable with the original in every way.</p>

<p>Most initiating functions' argument lifetimes are covered by [async.reqmts.async.lifetime]. As 
an rvalue reference it falls under the second bullet, which specifies that the object is copied 
(but doesn't say decay-copied).</p>

<p>The proposed resolution adds a postcondition for <code>DynamicBuffer</code> move construction, and 
specifies that <code><em>DECAY_COPY</em>(b)</code> be used for each of these functions. The following 
two alternative resolutions may also be considered:</p>

<ul>
<li><p>Add an extra bullet to [async.reqmts.async.lifetime] to cover rvalue parameters (but specifically exclude CompletionTokens).</p></li>
<li><p>Change the <code>DynamicBuffer</code> arguments to be by-value. (And also change the corresponding synchronous operations to be consistent.)</p></li>
</ul>

<p>However, the proposed resolution below is presented as a change that minimizes the scope of the impact.</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>


<p id="res-3072"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4711">N4711</a>.
</p>

<ol>
<li>
<p>Edit 16.2.4 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.dynamicbuffer">[networking.ts::buffer.reqmts.dynamicbuffer]</a> as indicated:</p>
<blockquote>
<p>-3- In Table 14, <code>x</code> denotes a value of type <code>X</code>, <code>x1</code> denotes a 
(possibly const) value of type <code>X</code>, <del>and</del><ins><code>mx1</code> denotes an 
xvalue of type <code>X</code>,</ins> <code>n</code> denotes a (possibly const) value of type 
<code>size_t</code><ins>, and <code>u</code> denotes an identifier</ins>.</p>

<table border="1">
<caption>Table 14 &mdash; DynamicBuffer requirements</caption>
<tr style="text-align:center">
<th>expression</th>
<th>type</th>
<th>assertion/note pre/post-conditions</th>
</tr>
<tr>
<td>
<ins><code>X u(mx1);</code></ins>
</td>
<td></td>
<td><ins><em>post:</em></ins>
<ul>
<li><ins><code>u.size()</code> is equal to the prior value of <code>mx1.size()</code>.</ins></li>
<li><ins><code>u.max_size()</code> is equal to the prior value of <code>mx1.max_size()</code>.</ins></li>
<li><ins><code>u.capacity()</code> is equal to the prior value of <code>mx1.capacity()</code>.</ins></li>
<li><ins><code>u.data()</code> satisfies the ConstBufferSequence requirements (16.2.2 [buffer.reqmts.constbuffersequence]) as if copy constructed from the prior value of <code>mx1.data()</code>.</ins></li>
<li><ins>All valid const or mutable buffer sequences that were previously obtained using <code>mx1.data()</code> or <code>mx1.prepare()</code> remain valid.</ins></li>
</ul>
</td>
</tr>
</table>
</blockquote>
</li>

<li>
<p>Edit 17.6 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read">[networking.ts::buffer.async.read]</a> as indicated:</p>
<blockquote>
<p>-11- <ins>Let <code>bd</code> be the result of <code><em>DECAY_COPY</em>(b)</code>.</ins> Data is placed into the dynamic buffer (16.2.4 [buffer.reqmts.dynamicbuffer]) object <code><del>b</del><ins>bd</ins></code>. A mutable buffer sequence (16.2.1 [buffer.reqmts.mutablebuffersequence]) is obtained prior to each <code>read_some</code> call using <code>b<ins>d</ins>.prepare(N)</code>, where <code>N</code> is an unspecified value less than or equal to <code>b<ins>d</ins>.max_size() - b<ins>d</ins>.size()</code>. [<em>Note:</em> Implementations are encouraged to use <code>b<ins>d</ins>.capacity()</code> when determining <code>N</code>, to minimize the number of <code>read_some</code> calls performed on the stream. <em>-- end note</em>] After each <code>read_some</code> call, the implementation performs <code>b<ins>d</ins>.commit(n)</code>, where <code>n</code> is the return value from <code>read_some</code>.</p>

<p><em>[&hellip;]</em></p>

<p>-13- The synchronous read operation continues until:</p>
<ul>
<li><p><code>b<ins>d</ins>.size() == b<ins>d</ins>.max_size()</code>; or</p></li>
<li><p>the completion condition returns <code>0</code>.</p></li>
</ul>
</blockquote>
</li>

<li>
<p>Edit 17.8 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.write">[networking.ts::buffer.async.write]</a> as indicated:</p>
<blockquote>
<p>-11- <ins>Let <code>bd</code> be the result of <code><em>DECAY_COPY</em>(b)</code>.</ins> Data is 
written from the dynamic buffer (16.2.4 [buffer.reqmts.dynamicbuffer]) object 
<code>b<ins>d</ins></code>. A constant buffer sequence (16.2.2 [buffer.reqmts.constbuffersequence]) 
is obtained using <code>b<ins>d</ins>.data()</code>. After the data has been written to the stream, 
the implementation performs <code>b<ins>d</ins>.consume(n)</code>, where <code>n</code> is the number 
of bytes successfully written.</p>

<p><em>[&hellip;]</em></p>

<p>-13- The asynchronous write operation continues until:</p>
<ul>
<li><p><code>b<ins>d</ins>.size() == 0</code>; or</p></li>
<li><p>the completion condition returns <code>0</code>.</p></li>
</ul>
</blockquote>
</li>

<li>
<p>Edit 17.10 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read.until">[networking.ts::buffer.async.read.until]</a> as indicated:</p>
<blockquote>
<p>-3- <em>Effects:</em> <ins>Let <code>bd</code> be the result of 
<code><em>DECAY_COPY</em>(b)</code>.</ins> Initiates an asynchronous operation to read data from 
the buffer-oriented asynchronous read stream (17.1.2 [buffer.stream.reqmts.asyncreadstream]) object 
<code>stream</code> by performing zero or more asynchronous read_some operations on the stream, until 
the readable bytes of the dynamic buffer (16.2.4 [buffer.reqmts.dynamicbuffer]) object 
<code>b<ins>d</ins></code> contain the specified delimiter <code>delim</code>.</p>

<p>-4- Data is placed into the dynamic buffer object <code>b<ins>d</ins></code>. A mutable buffer 
sequence (16.2.1 [buffer.reqmts.mutablebuffersequence]) is obtained prior to each 
<code>async_read_some</code> call using <code>b<ins>d</ins>.prepare(N)</code>, where <code>N</code> 
is an unspecified value such that <code>N &lt;= max_size() - size()</code>. [<em>Note:</em> 
Implementations are encouraged to use <code>b<ins>d</ins>.capacity()</code> when determining 
<code>N</code>, to minimize the number of asynchronous read_some operations performed on the 
stream. &mdash; <em>end note</em>] After the completion of each asynchronous <code>read_some</code> 
operation, the implementation performs <code>b<ins>d</ins>.commit(n)</code>, where <code>n</code> 
is the value passed to the asynchronous <code>read_some</code> operation's completion handler.</p>

<p>-5- The asynchronous <code>read_until</code> operation continues until:</p>
<ul>
<li><p>the readable bytes of <code>b<ins>d</ins></code> contain the delimiter <code>delim</code>; or</p></li>
<li><p><code>b<ins>d</ins>.size() == b<ins>d</ins>.max_size()</code>; or</p></li>
<li><p>an asynchronous <code>read_some</code> operation fails.</p></li>
</ul>

<p><em>[&hellip;]</em></p>

<p>-8- On completion of the asynchronous operation, if the readable bytes of <code>b<ins>d</ins></code> 
contain the delimiter, <code>ec</code> is set such that <code>!ec</code> is <code>true</code>. 
Otherwise, if <code>b<ins>d</ins>.size() == b<ins>d</ins>.max_size()</code>, <code>ec</code> is set such 
that <code>ec == stream_errc::not_found</code>. If <code>b<ins>d</ins>.size() &lt; 
b<ins>d</ins>.max_size()</code>, <code>ec</code> is the <code>error_code</code> from the most recent 
asynchronous <code>read_some</code> operation. <code>n</code> is the number of readable bytes in 
<code>b<ins>d</ins></code> up to and including the delimiter, if present, otherwise <code>0</code>.</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3073"><a href="3073">3073</a>. [networking.ts] (<code>async_</code>)<code>read</code> and (<code>async_</code>)<code>write</code> 
don't support <code>DynamicBuffer</code> lvalues</h3>
<p><b>Section:</b> 17 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.stream">[networking.ts::buffer.stream]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2018-02-27 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses: networking.ts</b>
<p>Suppose that we have a user-defined class <code>dyn_buf</code> that satisfies the DynamicBuffer 
requirements ([buffer.reqmts.dynamicbuffer]), and is additionally copy-constructible. The following snippet compiles, as expected:</p>
<blockquote><pre>
dyn_buf b;
net::read_until(my_socket, b, "\n");
</pre></blockquote>
<p>However, this next snippet will not compile, when it should:</p>
<blockquote><pre>
dyn_buf b;
net::read(my_socket, b);
</pre></blockquote>

<p>This is due to:</p>
<ul>
<li>the <code>DynamicBuffer</code> template parameter being deduced as <code>dyn_buf&amp;</code>, and</li>
<li>the <code>read</code> overload being specified to not participate in overload resolution unless <code>is_dynamic_buffer_v&lt;DynamicBuffer&gt;</code> is <code>true</code>.</li>
</ul>

<p>This can fixed by changing the test to <code>is_dynamic_buffer_v&lt;decay_t&lt;DynamicBuffer&gt;&gt;</code>.</p>

<p><i>[2019-01-20 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p id="res-3073"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4711">N4711</a>.
</p>

<ol>

<li>
<p>Edit 17.5 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.read">[networking.ts::buffer.read]</a> as indicated:</p>
<blockquote>
<p>-14- <em>Remarks:</em> This function shall not participate in overload resolution unless 
<code>is_dynamic_buffer_v&lt;<ins>decay_t&lt;</ins>DynamicBuffer<ins>&gt;</ins>&gt;</code> is 
<code>true</code>.</p>
</blockquote>
</li>

<li>
<p>Edit 17.6 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read">[networking.ts::buffer.async.read]</a> as indicated:</p>
<blockquote>
<p>-16- <em>Remarks:</em> This function shall not participate in overload resolution unless 
<code>is_dynamic_buffer_v&lt;<ins>decay_t&lt;</ins>DynamicBuffer<ins>&gt;</ins>&gt;</code> is 
<code>true</code>.</p>
</blockquote>
</li>

<li>
<p>Edit 17.7 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.write">[networking.ts::buffer.write]</a> as indicated:</p>
<blockquote>
<p>-14- <em>Remarks:</em> This function shall not participate in overload resolution unless 
<code>is_dynamic_buffer_v&lt;<ins>decay_t&lt;</ins>DynamicBuffer<ins>&gt;</ins>&gt;</code> is 
<code>true</code>.</p>
</blockquote>
</li>

<li>
<p>Edit 17.8 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.write">[networking.ts::buffer.async.write]</a> as indicated:</p>
<blockquote>
<p>-16- <em>Remarks:</em> This function shall not participate in overload resolution unless 
<code>is_dynamic_buffer_v&lt;<ins>decay_t&lt;</ins>DynamicBuffer<ins>&gt;</ins>&gt;</code> is 
<code>true</code>.</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3078"><a href="3078">3078</a>. <code>directory_entry</code>, <code>directory_iterator</code> and <code>recursive_directory_iterator</code> perform needless path copies</h3>
<p><b>Section:</b> 31.12.10 <a href="https://timsong-cpp.github.io/cppwp/fs.class.directory.entry">[fs.class.directory.entry]</a>, 31.12.11 <a href="https://timsong-cpp.github.io/cppwp/fs.class.directory.iterator">[fs.class.directory.iterator]</a>, 31.12.12 <a href="https://timsong-cpp.github.io/cppwp/fs.class.rec.dir.itr">[fs.class.rec.dir.itr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Gor Nishanov <b>Opened:</b> 2018-03-05 <b>Last modified:</b> 2019-04-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.class.directory.entry">issues</a> in [fs.class.directory.entry].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
An implementation of <code>directory_entry</code> class is likely to store a <code>filesystem::path</code> as a member.
Constructors and assign member functions take <code>filesystem::path</code> by <code>const&amp;</code> thus forcing 
creation of a copy.
<p/>
An implementation of <code>directory_iterator</code> class is likely to store a <code>directory_entry</code> or a 
<code>path</code> as a part of its state. Constructors take <code>filesystem::path</code> by <code>const&amp;</code> 
thus forcing creation of a copy.
<p/>
An implementation of <code>recursive_directory_iterator</code> class is likely to store a <code>directory_entry</code> 
or a <code>path</code> as a part of its state. Constructors take <code>filesystem::path</code> by <code>const&amp;</code> 
thus forcing creation of a copy. 
<p/>
Suggested resolution:
<p/>
Add overloads to <code>directory_entry</code>, <code>directory_iterator</code>, and <code>recursive_directory_iterator</code>
that take <code>filesystem::path</code> by <code>&amp;&amp;</code>.
<p/>
Make it unspecified in case an exception is thrown from those new members where an argument was moved from or not.
</p>
<blockquote><pre>
explicit directory_entry(const filesystem::path&amp; p);
<ins>explicit directory_entry(filesystem::path&amp;&amp; p);</ins>
directory_entry(const filesystem::path&amp; p, error_code&amp; ec);
<ins>directory_entry(filesystem::path&amp;&amp; p, error_code&amp; ec);</ins>

void directory_entry::assign(const filesystem::path&amp; p);
<ins>void directory_entry::assign(filesystem::path&amp;&amp; p);</ins>
void directory_entry::assign(const filesystem::path&amp; p, error_code&amp; ec);
<ins>void directory_entry::assign(filesystem::path&amp;&amp; p, error_code&amp; ec);</ins>

explicit directory_iterator(const path&amp; p);
<ins>explicit directory_iterator(path&amp;&amp; p);</ins>
directory_iterator(const path&amp; p, directory_options options);
<ins>directory_iterator(path&amp;&amp; p, directory_options options);</ins>
directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
<ins>directory_iterator(path&amp;&amp; p, error_code&amp; ec) noexcept;</ins>
directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
<ins>directory_iterator(path&amp;&amp; p, directory_options options, error_code&amp; ec) noexcept;</ins>

explicit recursive_directory_iterator(const path&amp; p);
<ins>explicit recursive_directory_iterator(path&amp;&amp; p);</ins>
recursive_directory_iterator(const path&amp; p, directory_options options);
<ins>recursive_directory_iterator(path&amp;&amp; p, directory_options options);</ins>
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
<ins>recursive_directory_iterator(path&amp;&amp; p, directory_options options, error_code&amp; ec) noexcept;</ins>
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
<ins>recursive_directory_iterator(path&amp;&amp; p, error_code&amp; ec) noexcept;</ins>
</pre></blockquote>

<p><i>[2018-03-20 Priority set to 3 after discussion on the reflector.]</i></p>



<p id="res-3078"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3081"><a href="3081">3081</a>. Floating point <code>from_chars</code> API does not distinguish between overflow and underflow</h3>
<p><b>Section:</b> 28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Greg Falcon <b>Opened:</b> 2018-03-12 <b>Last modified:</b> 2023-03-29</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#charconv.from.chars">active issues</a> in [charconv.from.chars].</p>
<p><b>View all other</b> <a href="lwg-index.html#charconv.from.chars">issues</a> in [charconv.from.chars].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>strtod()</code> distinguishes between overflow and underflow by returning a value that is either 
very large or very small. Floating point <code>from_chars</code> does not currently offer any way for 
callers to distinguish these two cases.
<p/>
It would be beneficial if users could migrate from <code>strtod()</code> to <code>from_chars</code> without 
loss of functionality.
<p/>
I recommend that floating point <code>from_chars</code> use <code>value</code> as an overflow-vs-underflow 
reporting channel, in the same manner as <code>strtod()</code>.
<p/>
My proposed wording gives <code>from_chars</code> the same wide latitude that <code>strtod()</code> enjoys 
for handling underflow. A high-quality implementation would likely set <code>ec == result_out_of_range</code> 
for underflow only when the nearest representable <code>float</code> to the parsed value is a zero and 
the parsed mantissa was nonzero. In this case <code>value</code> would be set to (an appropriately-signed) zero. 
It is worth considering giving <code>from_chars</code> this more predictable behavior, if library writers 
feel they can provide this guarantee for all platforms. (I have a proof-of-concept integer-based 
implementation for IEEE doubles with this property.)
</p>

<p><i>[2018-06 Rapperswil Wednesday issues processing]</i></p>

<p>Marshall to provide updated wording and propose Tentatively Ready on the reflector.</p>
<p>Priority set to 2</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Status to Open; Marshall to reword</p>

<p><i>[2023-03-29; Jonathan adds further discussion]</i></p>

<p>
There are conflicting interpretations of "not in the range representable"
for floating-point types. One view is that 1e-10000 and 1e+10000 are outside
the representable range for a 64-bit double-precision <code>double</code>
(which has min/max exponents of -1022 and 1023). Another view is that the
representable range for floating-point types is [-inf,+inf], which means
that there are values that cannot be <em>accurately</em> represented,
but there are no values "not in the range representable". And 1e-10000 is
clearly within the range [0,<code>numeric_limits&lt;double&gt;::max()</code>],
even if we don't use infinity as the upper bound of the range.
Under the second interpretation, the result will be &pm;0.0 for underflow
and &pm;inf for overflow, but <code>ec</code> will not be set.
</p>
<p>
The current proposed resolution does address this, by making it clear
that <code>value</code> should be set to a very small or very large value
(with appropriate sign), but that <code>ec</code> should also be set.
The use of the word "overflow" for the integer overloads is a problem though,
because the result cannot "overflow" an unsigned integer type,
but can certainly be outside its range.
</p>



<p id="res-3081"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li>
<p>Edit 28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a> as indicated:</p>
<blockquote>
<p>
[&hellip;] Otherwise, the characters matching the pattern are interpreted as a representation
of a value of the type of <code>value</code>. The member <code>ptr</code> of the return value points 
to the first character not matching the pattern, or has the value <code>last</code> if all characters 
match. If the parsed value is not in the range representable by the type of <code>value</code>, 
<del><code>value</code> is unmodified and</del> the member <code>ec</code> of the return value is equal
to <code>errc::result_out_of_range</code>. Otherwise, <code>value</code> is set to the parsed value, 
after rounding according to <code>round_to_nearest</code> (17.3.4 <a href="https://timsong-cpp.github.io/cppwp/round.style">[round.style]</a>), and the member 
<code>ec</code> is value-initialized.
</p>
<pre>
from_chars_result from_chars(const char* first, const char* last,
                             <i>see below</i>&amp; value, int base = 10);
</pre>
<blockquote>
<p>
-2- <i>Requires:</i> <code>base</code> has a value between 2 and 36 (inclusive).
<p/>
-3- <i>Effects:</i> The pattern is the expected form of the subject sequence in the <code>"C"</code> 
locale for the given nonzero base, as described for <code>strtol</code>, except that no <code>"0x"</code> 
or <code>"0X"</code> prefix shall appear if the value of <code>base</code> is 16, and except that <code>'-'</code> is 
the only sign that may appear, and only if <code>value</code> has a signed type. <ins>On overflow, 
<code>value</code> is unmodified.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
from_chars_result from_chars(const char* first, const char* last, float&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, double&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, long double&amp; value,
                             chars_format fmt = chars_format::general);
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> <code>fmt</code> has the value of one of the enumerators of <code>chars_format</code>.
<p/>
-7- <i>Effects:</i> The pattern is the expected form of the subject sequence in the <code>"C"</code> 
locale, as described for <code>strtod</code>, except that
</p>
<ol style="list-style-type: none">
<li><p>(7.1) [&hellip;]</p></li>
<li><p>(7.2) [&hellip;]</p></li>
<li><p>(7.3) [&hellip;]</p></li>
<li><p>(7.4) [&hellip;]</p></li>
</ol>
<p>
In any case, the resulting value is one of at most two floating-point values closest to the value of the
string matching the pattern. <ins>On overflow, <code>value</code> is set to plus or minus 
<code>std::numeric_limits&lt;T&gt;::max()</code> of the appropriate type. On underflow, <code>value</code> 
is set to a value with magnitude no greater than <code>std::numeric_limits&lt;T&gt;::min()</code>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3082"><a href="3082">3082</a>. <code>from_chars</code> specification regarding floating point rounding is inconsistent</h3>
<p><b>Section:</b> 28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Greg Falcon <b>Opened:</b> 2018-03-12 <b>Last modified:</b> 2024-12-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#charconv.from.chars">active issues</a> in [charconv.from.chars].</p>
<p><b>View all other</b> <a href="lwg-index.html#charconv.from.chars">issues</a> in [charconv.from.chars].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/p0682r1">P0682R1</a> added the requirement that <code>from_chars</code> use 
<code>round_to_nearest</code> when converting from string, but later text in the section suggests that 
the implementation has latitude in its choice of rounding logic.
<p/>
If the intent is merely that the floating point environment should not affect <code>from_chars</code> behavior, 
the rounding-mode text should be weakened. If the intent is to always require <code>round_to_nearest</code>, 
the text suggesting a latitude in rounding logic should be removed.
</p>

<p><i>[2018-03-27 Priority set to 2 after discussion on the reflector.]</i></p>


<p><i>[2018-06 Rapperswil Wednesday issues processing]</i></p>

<p>Status to open; also this needs to say that the intent is to be independent of the floating point environment.</p>

<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p>Marshall to talk to Jens about this</p>

<p><i>[2024-12-04; add comments from Richard Smith]</i></p>

<p>
In editorial issue
<a href="https://github.com/cplusplus/draft/issues/6730">#6730</a>
Richard said:
</p>
<blockquote>
28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a>/6.4 says:

<blockquote>
In any case, the resulting value is one of at most two floating-point
values closest to the value of the string matching the pattern.
</blockquote>

This is ambiguous. It could mean either:
<ol>
<li>
The resulting value is the implementation's choice of one of a set of values,
and that set contains the two values closest to the value of the string.
</li>
<li>
The resulting value is the implementation's choice of one of a set of values,
and that set contains all values that are closest to the value of the string
(of which it turns out there can be up to two).
</li>
</ol>
<p>
I think the normal English interpretation would be (1),
but the intended interpretation is actually (2).
</p>
<p>
(Under (1), the string <code class='backtick'>"1.0"</code> can produce the value one ULP less than 1.0
or it can produce 1.0, and the string <code>"1.00&lt;lots of 0s&gt;1"</code>
can produce those same two values, because the value one ULP less than 1.0
is closer to that string than the value one ULP greater than 1.0.)
</p>
<p>
Perhaps the wording from 7.3.10 <a href="https://timsong-cpp.github.io/cppwp/conv.double">[conv.double]</a>/2 and
7.6.1.9 <a href="https://timsong-cpp.github.io/cppwp/expr.static.cast">[expr.static.cast]</a>/11 can be used instead:
</p>
<blockquote>
If the source value can be exactly represented in the destination type,
the result of the conversion is that exact representation.
If the source value is between two adjacent destination values,
the result of the conversion is an implementation-defined choice
of either of those values.
</blockquote>
</blockquote>
<p>
Editorial pull request
<a href="https://github.com/cplusplus/draft/pull/6833">#6833</a>
proposed a change along those lines, but conflicts with the proposed resolution
to this issue.
We should address Richard's comment as part of this issue.
</p>


<p id="res-3082"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li>
<p>Edit 28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a> as indicated:</p>
<blockquote>
<pre>
from_chars_result from_chars(const char* first, const char* last, float&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, double&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, long double&amp; value,
                             chars_format fmt = chars_format::general);
</pre>
<blockquote>
<p>
-6- <i>Requires:</i> <code>fmt</code> has the value of one of the enumerators of <code>chars_format</code>.
<p/>
-7- <i>Effects:</i> The pattern is the expected form of the subject sequence in the <code>"C"</code> 
locale, as described for <code>strtod</code>, except that
</p>
<ol style="list-style-type: none">
<li><p>(7.1) [&hellip;]</p></li>
<li><p>(7.2) [&hellip;]</p></li>
<li><p>(7.3) [&hellip;]</p></li>
<li><p>(7.4) [&hellip;]</p></li>
</ol>
<p>
In any case, the resulting value is <del>one of at most two</del><ins>the</ins> floating-point 
value<del>s</del> closest to the value of the string matching the pattern<ins>, with ties broken 
according to <code>round_to_nearest</code></ins>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3084"><a href="3084">3084</a>. Termination in C++ is unclear</h3>
<p><b>Section:</b> 17.5 <a href="https://timsong-cpp.github.io/cppwp/support.start.term">[support.start.term]</a>, 17.9.5 <a href="https://timsong-cpp.github.io/cppwp/exception.terminate">[exception.terminate]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> JF Bastien  <b>Opened:</b> 2018-03-15 <b>Last modified:</b> 2024-07-26</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.start.term">active issues</a> in [support.start.term].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.start.term">issues</a> in [support.start.term].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It's unclear how different termination facilities in C++ interact (and how they interact with the C 
termination facilities). Individually some of these functions try to handle corner cases, but hilarity 
ensues when combined with each other. As a simple example, can an <code>atexit</code> handler call <code>exit</code>? 
If not, can it call <code>quick_exit</code>, and can then <code>at_quick_exit</code> handler call <code>exit</code>? 
Is it possible to install an <code>atexit</code> handler from an <code>at_quick_exit</code>, without strongly 
happens before, while handling a separate <code>atexit</code> handler (and what happens then)?
<p/>
The termination handlers and termination conditions I collected:
</p>
<ul>
<li><p>returning from <code>main</code> calls <code>atexit</code> handlers.</p></li>
<li><p><code>atexit</code> / <code>exit</code></p></li>
<li><p><code>at_quick_exit</code> / <code>quick_exit</code></p></li>
<li><p><code>set_terminate</code></p></li>
<li><p>violating <code>noexcept</code> and other things that call <code>std::terminate</code> (see 
<code>[except.terminate]</code>)</p></li>
<li><p>violating exception specification</p></li>
<li><p>parallel algorithms leaving with uncaught exception</p></li>
<li><p>some <code>std::signal</code> such as <code>SIGTERM</code>, <code>SIGSEGV</code>, <code>SIGINT</code>, 
<code>SIGILL</code>, <code>SIGABRT</code>, and (maybe?) <code>SIGFPE</code>.</p></li>
<li><p><code>set_unexpected</code> (now a zombie)</p></li>
<li><p><code>unexpected_handler</code> (now a zombie)</p></li>
</ul>
<p>
What's unclear is:
</p>
<ul>
<li><p>Is termination handling a DAG?</p></li>
<li><p>Which thread(s) are termination handlers called on?</p></li>
<li><p>Is program termination Turing complete?</p></li>
</ul>
<p>
I've written a sample program which exercises some of this, see 
<a href="https://github.com/jfbastien/terminator/blob/master/terminator.cc">here</a>.
</p>

<p><i>[2018-04-02, Jens comments]</i></p>

<p>
Any potential wording should carefully take [basic.start] into account, and maybe should actually be integrated 
into the core wording, not the library wording.
</p>

<p><i>[2018-04-02 Priority set to 3 after discussion on the reflector.]</i></p>


<p><i>[2024-07-26; Jonathan comments]</i></p>

<p>
In C89 and C99 the spec for <code class='backtick'>exit</code> in C said
"If more than one call to the exit function is executed by a program,
the behavior is undefined."
Since C11 that was updated to also talk about <code class='backtick'>at_quick_exit</code>, saying
"If a program calls the <code class='backtick'>exit</code> function more than once,
or calls the <code class='backtick'>quick_exit</code> function in addition to the <code class='backtick'>exit</code> function,
the behavior is undefined." The spec for <code class='backtick'>quick_exit</code> is similar.
</p>
<p>
That answers most of the questions here. An <code class='backtick'>atexit</code> or <code class='backtick'>at_quick_exit</code>
handler cannot call <code class='backtick'>exit</code> or <code class='backtick'>quick_exit</code>, because if a handler is running
then it means that <code class='backtick'>exit</code> or <code class='backtick'>quick_exit</code> has already been called,
and calling either of them again would be undefined.
It doesn't matter whether an <code class='backtick'>atexit</code> handler installs an <code class='backtick'>at_quick_exit</code>
handler, because once <code class='backtick'>exit</code> handlers start running
it would be undefined to call <code class='backtick'>quick_exit</code>, and vice versa. So you should never
have a situation where both sets of handlers are running.
</p>
<p>
There is a <a href="https://austingroupbugs.net/view.php?id=1845">suggestion</a>
to relax this in POSIX so that calling <code class='backtick'>exit</code> or <code class='backtick'>quick_exit</code> again from other
threads would not be UB but would just block until the process exits,
which should happen eventually assuming exit handlers make forward progress
(calling <code class='backtick'>exit</code> or <code class='backtick'>quick_exit</code> from a handler would still be UB).
</p>
<p>
Why does C++ not make it undefined to call <code class='backtick'>exit</code> twice? Can we change that?
</p>


<p id="res-3084"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3086"><a href="3086">3086</a>. Possible problem in &sect;[new.delete.single]</h3>
<p><b>Section:</b> 17.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> William M. Miller <b>Opened:</b> 2018-03-16 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#new.delete.single">active issues</a> in [new.delete.single].</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In general requirements on a whole program, as opposed to a single translation unit, generally specify 
"no diagnostic required", since we don't want to require implementations to do multi-translation-unit 
analysis. However, 17.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> paragraph 11 says,
</p>
<blockquote><p>
If a function with a <code>size</code> parameter is defined, the program shall also define the corresponding 
version without the <code>size</code> parameter.
</p></blockquote>
<p>
This is clearly not restricted to a single translation unit; should "no diagnostic required" be added?
</p>

<p><i>[2018-04-03; Thomas K&ouml;ppe and Tim Song suggest wording]</i></p>


<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>


<p id="res-3086"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li><p>Edit 17.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/new.delete.single">[new.delete.single]</a> as indicated:</p>
<blockquote>
<pre>
void operator delete(void* ptr) noexcept;
void operator delete(void* ptr, std::size_t size) noexcept;
void operator delete(void* ptr, std::align_val_t alignment) noexcept;
void operator delete(void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
</pre>
<blockquote>
<p>
-10- <i>Effects:</i> [&hellip;]
<p/>
-11- <i>Replaceable:</i> A C++ program may define functions with any of these function signatures, and thereby
displace the default versions defined by the C++ standard library. If a function without a <code>size</code> parameter
is defined, the program should also define the corresponding function with a <code>size</code> parameter. If a
function with a <code>size</code> parameter is defined, the program shall also define the corresponding version
without the <code>size</code> parameter<ins>; no diagnostic is required</ins>. [<i>Note:</i> The default behavior 
below may change in the future, which will require replacing both deallocation functions when replacing the 
allocation function. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Edit 17.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/new.delete.array">[new.delete.array]</a> as indicated:</p>
<blockquote>
<pre>
void operator delete[](void* ptr) noexcept;
void operator delete[](void* ptr, std::size_t size) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment) noexcept;
void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> [&hellip;]
<p/>
-10- <i>Replaceable:</i> A C++ program may define functions with any of these function signatures, and thereby
displace the default versions defined by the C++ standard library. If a function without a <code>size</code> parameter
is defined, the program should also define the corresponding function with a <code>size</code> parameter. If a
function with a <code>size</code> parameter is defined, the program shall also define the corresponding version
without the <code>size</code> parameter<ins>; no diagnostic is required</ins>. [<i>Note:</i> The default behavior 
below may change in the future, which will require replacing both deallocation functions when replacing the 
allocation function. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3089"><a href="3089">3089</a>. <code>copy_n</code> should require non-overlapping ranges</h3>
<p><b>Section:</b> 26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2018-03-21 <b>Last modified:</b> 2022-11-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in [alg.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in [alg.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All the copy algorithms have some kind of prohibition on having the input and output ranges overlap. 
<p/>
The serial version of <code>copy</code> says:
</p>
<blockquote><p>
<i>Requires:</i> <code>result</code> shall not be in the range <code>[first, last)</code>.
</p></blockquote>
<p>
The parallel version of <code>copy</code> says:
</p>
<blockquote><p>
<i>Requires:</i> The ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> 
shall not overlap.
</p></blockquote>
<p>
<code>copy_if</code> says: 
</p>
<blockquote><p>
<i>Requires:</i> The ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> 
shall not overlap.
</p></blockquote>
<p>
<code>copy_backwards</code> says:
</p>
<blockquote><p>
<i>Requires:</i> <code>result</code> shall not be in the range <code>[first, last)</code>.
</p></blockquote>
<p>
But <code>copy_n</code> has no such requirement.
<p/>
I think it should. I checked the minutes of the LWG discussion from 2008 when this was added, and 
there was no discussion of overlapping ranges.
</p>

<p>What formulation do we want here? Is it sufficient to say "... shall not be in the range ..." or should we use the stronger "... shall not overlap ..."? Some <code>copy</code> variants use one, some use the other.  Should we be consistent? Issue <a href="3085" title="char_traits::copy precondition too weak (Status: C++23)">3085</a> is a similar issue for <code>char_traits::copy</code>.</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.</p>

<ol>
<li><p>Edit 26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> I'm using the permission in 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>/10 to 
do random-access arithmetic on (possibly) input iterators.]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class InputIterator, class Size, class OutputIterator&gt;
  constexpr OutputIterator copy_n(InputIterator first, Size n,
                                  OutputIterator result);
template&lt;class ExecutionPolicy, class ForwardIterator1, class Size, class ForwardIterator2&gt;
  ForwardIterator2 copy_n(ExecutionPolicy&amp;&amp; exec,
                          ForwardIterator1 first, Size n,
                          ForwardIterator2 result);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <code>result</code> shall not be in the range <code>[first, first + n)</code>.</ins>
<p/>
-9- <i>Effects:</i> For each non-negative integer <code>i &lt; n</code>, performs <code>*(result + i) = *(first + i)</code>.
<p/>
-10- <i>Returns:</i> <code>result + n</code>.
<p/>
-11- <i>Complexity:</i> Exactly <code>n</code> assignments.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-11-06; Daniel syncs wording with recent working draft]</i></p>




<p id="res-3089"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Edit 26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> I'm using the permission in 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>/10 to 
do random-access arithmetic on (possibly) input iterators.]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class InputIterator, class Size, class OutputIterator&gt;
  constexpr OutputIterator copy_n(InputIterator first, Size n,
                                  OutputIterator result);
template&lt;class ExecutionPolicy, class ForwardIterator1, class Size, class ForwardIterator2&gt;
  ForwardIterator2 copy_n(ExecutionPolicy&amp;&amp; exec,
                          ForwardIterator1 first, Size n,
                          ForwardIterator2 result);
template&lt;input_iterator I, weakly_incrementable O&gt;
  requires indirectly_copyable&lt;I, O&gt;
  constexpr ranges::copy_n_result&lt;I, O&gt;
    ranges::copy_n(I first, iter_difference_t&lt;I&gt; n, O result);
</pre>
<blockquote>
<p>
-10- Let <code><i>N</i></code> be max<code>(0, n)</code>.
<p/>
-11- <i>Mandates</i>: The type <code>Size</code> is convertible to an integral type (7.3.9, 11.4.8).
<p/>
<ins>-?- <i>Preconditions:</i> <code>result</code> is not in the range <code>[first, first + n)</code>.</ins>
<p/>
-12- <i>Effects</i>: For each non-negative integer <code><i>i</i> &lt; N</code>, performs <code>*(result + <i>i</i>) = *(first + <i>i</i>)</code>.
<p/>
-13- <i>Returns</i>:
</p>
<ol style="list-style-type: none">
<li><p>(13.1) &mdash; <code>result + <i>N</i></code> for the overloads in namespace <code>std</code>.</p></li>
<li><p>(13.2) &mdash; <code>{first + <i>N</i>, result + <i>N</i>}</code> for the overload in namespace <code>ranges</code>.</p></li>
</ol>
<p>
-14- <i>Complexity:</i> Exactly <code><i>N</i></code> assignments.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3090"><a href="3090">3090</a>. What is &sect;[time.duration.cons]p4's "no overflow is induced in the conversion" intended to mean?</h3>
<p><b>Section:</b> 30.5.2 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cons">[time.duration.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2018-03-22 <b>Last modified:</b> 2020-09-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.cons">issues</a> in [time.duration.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.2 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cons">[time.duration.cons]</a> p4 says:
</p>
<blockquote>
<pre>
template&lt;class Rep2, class Period2&gt;
  constexpr duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre>
<blockquote>
<p>
<i>Remarks:</i> This constructor shall not participate in overload resolution unless no overflow is induced in the 
conversion and <code>treat_as_floating_point_v&lt;rep&gt;</code> is <code>true</code> or both 
<code>ratio_divide&lt;Period2, period&gt;::den</code> is 1 and <code>treat_as_floating_point_v&lt;Rep2&gt;</code> is <code>false</code>.
</p>
</blockquote>
</blockquote>
<p>
with this example:
</p>
<blockquote><pre>
duration&lt;int, milli&gt; ms(3);
duration&lt;int, micro&gt; us = ms;  <i>// OK</i>
duration&lt;int, milli&gt; ms2 = us; <i>// error</i>
</pre></blockquote>
<p>
It's unclear to me what "no overflow is induced in the conversion" means in the above. What happens here:
</p>
<blockquote><pre>
duration&lt;int, milli&gt; ms(INT_MAX);
duration&lt;int, micro&gt; us = ms;  <i>// ???</i>
</pre></blockquote>
<p>
An overflow is clearly induced in the conversion here: internally, we'll multiply <code>INT_MAX</code> by 1000. But that 
cannot be determined statically (in general), and so can't affect the result of overload resolution.
<p/>
So what's actually supposed to happen? Are we actually just supposed to check that <code>Rep2</code> is no larger than <code>Rep</code>? 
(If so, what happens on overflow? Undefined behavior?)
<p/>
It has been pointed out by Howard Hinnant:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
This refers to the compile-time conversion factor to convert <code>Period2</code> to <code>Period</code>. If that conversion factor 
is not representable as a (reduced) <code>ratio&lt;N, D&gt;</code>, then the constructor is SFINAE'd out. This might happen 
(for example) converting years to picoseconds.
</blockquote>
<p>
I would not have guessed that from the wording. Maybe replacing "no overflow is induced in the conversion" with "the result 
of <code>ratio_divide&lt;Period2, Period&gt;</code> is representable as a <code>ratio</code>" or similar would help? 
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>

<p><i>[2020-09-12 Jonathan adds a proposed resolution]</i></p>

<p>
Since the result of the <code>ratio_divide</code> has to be a <code>ratio</code>,
if it's not representable then the result simply isn't a valid type.
Implementations are not required to make <code>ratio_divide</code> SFINAE-friendly
to implement this constraint. They can perform the equivalent calculations
to check if they would overflow, without actually using <code>ratio_divide</code>.
</p>



<p id="res-3090"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 30.5.2 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cons">[time.duration.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Rep2, class Period2&gt;
  constexpr duration(const duration&lt;Rep2, Period2&gt;&amp; d);
</pre>
</blockquote>
<p>
-3- <i>Constraints:</i>
<ins>
<code>is_convertible_v&lt;const Rep2&amp;, rep&gt;</code> is <code>true</code>.
<code>ratio_divide&lt;typename Period2::type, period&gt;</code> is
a valid <code>ratio</code> specialization.
Either:
</ins>
</p>
<ul>
<li>
<ins>
<code>treat_as_floating_point_v&lt;rep&gt;</code> is <code>true</code>; or
</ins>
</li>
<li>
<ins>
<code>ratio_divide&lt;Period2, period&gt;::den</code> is <code>1</code>
and <code>treat_as_floating_point_v&lt;Rep2&gt;</code> is <code>false</code>.
</ins>
</li>
</ul>
<p>
<del>
No overflow is induced in the conversion and
<code>treat_as_floating_point_v&lt;rep&gt;</code> is <code>true</code>
or both <code>ratio_divide&lt;Period2, period&gt;::den</code> is <code>1</code>
and <code>treat_as_floating_point_v&lt;Rep2&gt;</code> is <code>false</code>.
</del>
[<i>Note:</i> This requirement prevents implicit truncation error<ins>s</ins>
when converting between integral-based <code>duration</code> types.
Such a construction could easily lead to confusion about the value of the
<code>duration</code>.
&mdash; <i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3 id="3092"><a href="3092">3092</a>. Unclear semantics of <code>enum class</code> bitmask types</h3>
<p><b>Section:</b> 16.3.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2018-03-26 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#bitmask.types">active issues</a> in [bitmask.types].</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[bitmask.types] specifies the semantics of a bitmask type in terms of an "exposition only" <code>enum</code> definition, 
together with some constants and overloads. Notably, it is depicted as an unscoped enum, which implies among other 
things that it is implicitly convertible to <code>int_type</code>. At least some sources treat that as normative (as 
of this writing, <a href="http://cppreference.com/">cppreference.com</a>'s documentation for 
<a href="http://en.cppreference.com/w/cpp/concept/BitmaskType"><code>BitmaskType</code></a> says the expression 
<code>(X &amp; Y) != 0</code> is guaranteed to be well-formed), and it's hard to argue that they're wrong on the basis 
of the existing wording.
<p/>
On the other hand, many standard library types are depicted as scoped enums, but still specified to be "bitmask types". 
As far as I can tell, it's impossible in library code to make a scoped enum implicitly convertible to its underlying type, 
and even if you could, what would be the point? Presumably the specification of those types as scoped enums is intended 
to have some sort of observable consequences.
<p/>
In addition, some library types (notably in clause 31) are specified to be bitmask types, without indicating whether 
they are scoped or unscoped. It's not clear what the standard guarantees about e.g. whether they can be implicitly 
converted.
<p/>
I assume the intent is that "bitmask type" doesn't specify an implicit conversion, or any of the other ways unscoped 
and scoped enums differ, but the standard doesn't actually say that. We really ought to rewrite [bitmask.types] as 
a requirements table, but here's a quick hack to the existing wording as a stopgap.
</p>
<p><i>[2018-04-23 Priority set to 2 after discussion on the reflector.]</i></p>


<p><i>[2018-08-23 Batavia Issues processing]</i></p>

<p><a href="https://wg21.link/N3110">N3110</a> also touches on this.</p>
<p>Nico to survey the enums in the library and report back on which ones should be class.</p>

<p><i>[2019 Cologne Wednesday night]</i></p>

<p>Changing existing enums to class enums is an ABI break on some platforms; current wording does not require the use of enums. See N3110.</p>
<p>Daniel to provide requirements tables, Jonathan to assist. Reduce priority to 3</p>


<p id="res-3092"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.</p>

<ol>
<li><p>Edit 16.3.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> as indicated:</p>
<blockquote>
<p>
-2- The bitmask type <code><i>bitmask</i></code> can be written:
</p>
<blockquote><pre>
<i>// For exposition only.</i>
<i>// </i>int_type<i> is an integral type capable of representing all values of the bitmask type.</i>
<del>enum</del><ins><i>E</i></ins> bitmask : int_type {
  V<sub>0</sub> = 1 &lt;&lt; 0, V<sub>1</sub> = 1 &lt;&lt; 1, V<sub>2</sub> = 1 &lt;&lt; 2, V<sub>3</sub> = 1 &lt;&lt; 3, .....
};
[&hellip;]
</pre></blockquote>
<p>
-3- Here, <ins><code><i>E</i></code> may represent either <code>enum</code> or <code>enum class</code> (the choice is implementation-defined 
unless otherwise specified), and</ins> the names <code><i>C</i><sub>0</sub></code>, <code><i>C</i><sub>1</sub></code>, etc. represent 
<i>bitmask elements</i> for this particular bitmask type. <ins>The zero value <code><i>bitmask</i>{}</code> is used to represent an 
<i>empty bitmask</i>, in which no bitmask elements are set.</ins> All <del>such</del><ins>bitmask</ins> elements have distinct, 
nonzero values such that, for any pair <code><i>C<sub>i</sub></i></code> and <code><i>C<sub>j</sub></i></code> where 
<code><i>i</i> &ne; <i>j</i></code>, <code><i>C<sub>i</sub></i> &amp; <i>C<sub>i</sub></i></code> is nonzero and 
<code><i>C<sub>i</sub></i> &amp; <i>C<sub>j</sub></i></code> is zero. <del>Additionally, the value <code>0</code> is used to represent 
an <i>empty bitmask</i>, in which no bitmask elements are set.</del>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3093"><a href="3093">3093</a>. LWG 2294/2192 missed a <code>std::abs</code> overload</h3>
<p><b>Section:</b> 29.7.2 <a href="https://timsong-cpp.github.io/cppwp/c.math.abs">[c.math.abs]</a>, 17.2.2 <a href="https://timsong-cpp.github.io/cppwp/cstdlib.syn">[cstdlib.syn]</a>, 31.13.2 <a href="https://timsong-cpp.github.io/cppwp/cinttypes.syn">[cinttypes.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2018-03-30 <b>Last modified:</b> 2018-06-19</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2192" title="Validity and return type of std::abs(0u) is unclear (Status: C++17)">2192</a> changed the library specification so that you always get all the <code>std::abs</code> overloads for fundamental 
types if you get any of them.
<p/>
Except that it missed one: <code>&lt;cinttypes&gt;</code> provides a <code>std::abs</code> (and <code>std::div</code>) overload for 
<code>intmax_t</code> if it's not <code>long long</code> (since LWG <a href="1449" title="Incomplete specification of header &lt;cinttypes&gt; (Status: C++11)">1449</a>). Presumably that one should also follow the 
<code>&lt;cstdlib&gt;</code>/<code>&lt;cmath&gt;</code> pattern and we should make the complete <code>abs</code> overload set available 
whenever any of the three headers is included? (And likewise we should make the complete <code>std::div</code> overload set 
available whenever either <code>&lt;cstdlib&gt;</code> or <code>&lt;cinttypes&gt;</code> is included.)
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>



<p id="res-3093"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3095"><a href="3095">3095</a>. <code>strstreambuf</code> refers to nonexistent member of <code>fpos</code>, <code>fpos::offset</code></h3>
<p><b>Section:</b> 99 [depr.strstreambuf.virtuals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-04-04 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.strstreambuf.virtuals">issues</a> in [depr.strstreambuf.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>strstreambuf</code> refers to a nonexistent member function of <code>fpos</code> in the specification of the member function
<code>seekpos</code>, 99 [depr.strstreambuf.virtuals]/18 (emphasize mine): 
</p>
<blockquote><p>
For a sequence to be positioned, if its next pointer is a null pointer, the positioning operation fails.
Otherwise, the function determines <code>newoff</code> from <span style="color:#C80000;font-weight:bold"><code>sp.offset()</code></span>:
</p></blockquote>
<p>
The intent is clearly to get the corresponding <code>streamoff</code> from the <code>fpos</code>, as p19 says "the resultant 
offset <code>newoff</code> (of type <code>off_type</code>)". The mechanism to make that conversion is a normal explicit conversion, 
as indicated in the last row of the table in [fpos.operations].
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 4</p>


<p id="res-3095"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li>
<p>Edit 99 [depr.strstreambuf.virtuals] as indicated:</p>
<blockquote>
<pre>
pos_type seekpos(pos_type sp, ios_base::openmode which
                 = ios_base::in | ios_base::out) override;
</pre>
<blockquote>
<p>
-17- <i>Effects:</i> [&hellip;]
<p/>
-18- For a sequence to be positioned, if its next pointer is a null pointer, the positioning operation fails.
Otherwise, the function determines <code>newoff</code> from <code><ins>static_cast&lt;off_type&gt;(</ins>sp<ins>)</ins><del>.offset()</del></code>:
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3097"><a href="3097">3097</a>. <code>basic_stringbuf seekoff</code> effects trigger undefined behavior and have contradictory returns</h3>
<p><b>Section:</b> 31.8.2.5 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.virtuals">[stringbuf.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-04-07 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#stringbuf.virtuals">active issues</a> in [stringbuf.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph citations relative to <a href="https://wg21.link/n4727">N4727</a>.
</p>
<p>
[stringbuf.virtuals]/10 says that <code>newoff</code> might be calculated from <code>xnext - xbegin</code>, 
or from <code>high_mark - xbegin</code>. After <code>newoff</code> is calculated, it does the null pointer 
check against and zero offset check. However, that means the effects may have already done 
<code>nullptr -</code> non-<code>nullptr</code>, or non-<code>nullptr - nullptr</code>, which [expr.add]/5 says 
is undefined behavior.
<p/>
Moreover, the attempt at avoiding this problem only tests <code>newoff</code>, not the value actually used 
which is <code>newoff + off</code>. For example, <code>buf.seekoff(100, ios_base::beg, ios_base::out)</code> 
on a read-only <code>streambuf</code> would try to assign <code>pptr() + newoff + off to pptr()</code>, but 
<code>pptr()</code> may have been <code>nullptr</code>, giving <code>nullptr + 0 + 100</code> which triggers UB. 
(Perhaps the "refers to an uninitialized character" bit protects that though).
<p/>
Last, the <i>Returns:</i> element says that it returns <code>newoff</code>, but then also says it returns 
the resulting stream position, which should be something like <code>newoff + off</code>. (I checked libc++ 
and MSVC++ and we both return <code>newoff + off</code>)
<p/>
We probably want to resolve that by renaming the value that comes out of Table 108 to something like 
"<code>basis</code>" and make "<code>newoff</code>" actually be the new offset instead of the starting offset.
</p>

<p><i>[2018-04-16 Priority set to 3 after discussion on the reflector.]</i></p>



<p id="res-3097"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3098"><a href="3098">3098</a>. Misleading example for <code>filesystem::path::filename()</code></h3>
<p><b>Section:</b> 31.12.6.5.9 <a href="https://timsong-cpp.github.io/cppwp/fs.path.decompose">[fs.path.decompose]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-04-06 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.path.decompose">issues</a> in [fs.path.decompose].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The example in [fs.path.decompose] p7 includes:
</p>
<blockquote><pre>
path("//host").filename();  <i>// yields</i> ""
</pre></blockquote>
<p>
This result isn't guaranteed, it depends whether the implementation interprets <code>"//host"</code> as a <i>root-name</i> 
or as a <i>root-directory</i> (with a redundant <i>directory-separator</i>) followed by the <i>filename</i> <code>"host"</code>.
<p/>
The example should make it clear that this interpretation is allowed.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4727">N4727</a>.
</p>

<ol>
<li>
<p>Edit 31.12.6.5.9 <a href="https://timsong-cpp.github.io/cppwp/fs.path.decompose">[fs.path.decompose]</a> as indicated:</p>
<blockquote>
<pre>
path filename() const;
</pre>
<blockquote>
<p>
-6- <i>Returns:</i> <code>relative_path().empty() ? path() : *--end()</code>.
<p/>
[<i>Example:</i>
</p>
<blockquote><pre>
path("/foo/bar.txt").filename(); <i>// yields</i> "bar.txt"
path("/foo/bar").filename();     <i>// yields</i> "bar"
path("/foo/bar/").filename();    <i>// yields</i> ""
path("/").filename();            <i>// yields</i> ""
path("//host").filename();       <i>// yields</i> "" <ins><i>or</i> "host"</ins>
path(".").filename();            <i>// yields</i> "."
path("..").filename();           <i>// yields</i> ".."
</pre></blockquote>
<p>
&mdash; end example]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2018-04-10, Jonathan comments and provides revised wording]</i></p>

<p>
Based on the reflector discussion I'd like to change the P/R to Billy's suggestion of simply removing that line from the example.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>


<p id="res-3098"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4727">N4741</a>.
</p>

<ol>
<li>
<p>Edit 31.12.6.5.9 <a href="https://timsong-cpp.github.io/cppwp/fs.path.decompose">[fs.path.decompose]</a> as indicated:</p>
<blockquote>
<pre>
path filename() const;
</pre>
<blockquote>
<p>
-6- <i>Returns:</i> <code>relative_path().empty() ? path() : *--end()</code>.
<p/>
[<i>Example:</i>
</p>
<blockquote><pre>
path("/foo/bar.txt").filename(); <i>// yields</i> "bar.txt"
path("/foo/bar").filename();     <i>// yields</i> "bar"
path("/foo/bar/").filename();    <i>// yields</i> ""
path("/").filename();            <i>// yields</i> ""
<del>path("//host").filename();       <i>// yields</i> ""</del>
path(".").filename();            <i>// yields</i> "."
path("..").filename();           <i>// yields</i> ".."
</pre></blockquote>
<p>
&mdash; end example]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3099"><a href="3099">3099</a>. <code>is_assignable&lt;Incomplete&amp;, Incomplete&amp;&gt;</code></h3>
<p><b>Section:</b> 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-04-10 <b>Last modified:</b> 2024-08-21</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.type.synop">active issues</a> in [meta.type.synop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.type.synop">issues</a> in [meta.type.synop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2939" title="Some type-completeness constraints of traits are overspecified (Status: Open)">2939</a> suggests that the the preconditions of the type traits need reevaluation.
This issue focuses specifically on <code>is_assignable</code> and, by extension, its variants:
<ul>
<li><code>is_copy_assignable&lt;T&gt;</code>, equivalent to <code>is_assignable&lt;T&amp;, const T&amp;&gt;</code>,
</li>
<li><code>is_move_assignable&lt;T&gt;</code>, equivalent to <code>is_assignable&lt;T&amp;, T&gt;</code>,
</li>
<li><code>is_trivially_assignable&lt;T, U&gt;</code>, equivalent to <code>is_assignable&lt;T, U&gt; &amp;&amp;
  /* magic */</code>,
</li>
<li><code>is_trivially_copy_assignable&lt;T&gt;</code>, equivalent to <code>is_assignable&lt;T&amp;, const T&amp;&gt; &amp;&amp;
  /* magic */</code>,
</li>
<li><code>is_trivially_move_assignable&lt;T&gt;</code>, equivalent to <code>is_assignable&lt;T&amp;, T&gt; &amp;&amp;
  /* magic */</code>,
</li>
<li><code>is_nothrow_assignable&lt;T, U&gt;</code>, equivalent to <code>is_assignable&lt;T, U&gt; &amp;&amp;
    noexcept(declval&lt;T&gt;() = declval&lt;U&gt;())</code>,
</li>
<li><code>is_nothrow_copy_assignable&lt;T&gt;</code>, equivalent to <code>is_assignable&lt;T&amp;, const T&amp;&gt; &amp;&amp;
    noexcept(declval&lt;T&amp;&gt;() = declval&lt;const T&amp;&gt;())</code>,
</li>
<li><code>is_nothrow_move_assignable&lt;T&gt;</code>, equivalent to <code>is_assignable&lt;T&amp;, T&gt; &amp;&amp;
    noexcept(declval&lt;T&amp;&gt;() = declval&lt;T&gt;())</code>, and
</li>
</ul>
</p>
<p>
We note a discrepancy: <code>is_copy_assignable&lt;T&gt;</code> requires <code>T</code> to be a complete type, but the
equivalent form <code>is_assignable&lt;T&amp;, const T&amp;&gt;</code> <em>does not</em>. The requirement for
<code>is_copy_assignable&lt;T&gt;</code> seems sensible, since there's no way to determine whether or not the assignment
<code>declval&lt;T&amp;&gt;() = declval&lt;const T&amp;&gt;()</code> is well-formed when <code>T</code> is incomplete.
It seems that the same argument should apply to all of the above "assignable" traits, and that they must require that
the referent type is complete when given a reference type parameter to be implementable.
</p>

<p><i>[2018-08 Batavia Monday issue discussion]</i></p>

<p>Issues <a href="2797" title="Trait precondition violations (Status: Resolved)">2797</a>, <a href="2939" title="Some type-completeness constraints of traits are overspecified (Status: Open)">2939</a>, <a href="3022" title="is_convertible&lt;derived*, base*&gt; may lead to ODR (Status: Resolved)">3022</a>, and <a href="3099" title="is_assignable&lt;Incomplete&amp;, Incomplete&amp;&gt; (Status: Open)">3099</a> are all closely related. Walter to write a paper resolving them.</p>

<p><i>[2020-02-14, Prague]</i></p>

<p>
LWG discussions. Set priority to 2.
</p>

<p><i>[2023-06-12; Varna]</i></p>

<p> 
<a href="https://wg21.link/P1285R0" title=" Improving Completeness Requirements for Type Traits">P1285R0</a> is related to this issue.
</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>This wording is relative to <a href="https://wg21.link/n4741">N4741</a>.</p>
<blockquote>
<ol>
<li>In 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> Table 42, change the Precondition text for <code>is_assignable</code>,
<code>is_trivially_assignable</code>, and <code>is_nothrow_assignable</code> as follows:
<blockquote>
<ins><code>remove_cvref_t&lt;</code></ins><code>T</code><ins><code>&gt;</code></ins> and
<ins><code>remove_cvref_t&lt;</code></ins><code>U</code><ins><code>&gt;</code></ins> shall be complete types, <del><i>cv</i></del>
<code>void</code>, or arrays of unknown bound.
</blockquote>
</li>

<li>In 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> Table 42, change the Precondition text for <code>is_copy_assignable</code>,
<code>is_move_assignable</code>, <code>is_trivially_copy_assignable</code>, <code>is_trivially_move_assignable</code>,
<code>is_nothrow_copy_assignable</code>, and <code>is_nothrow_move_assignable</code> as follows:
<blockquote>
<ins><code>remove_cvref_t&lt;</code></ins><code>T</code><ins><code>&gt;</code></ins> shall be a complete type, <del><i>cv</i></del>
<code>void</code>, or an array of unknown bound.
</blockquote>
</li>
</ol>
</blockquote>
</blockquote>

<p><i>[2024-08-21; Jonathan provides improved wording]</i></p>

<p>
During LWG telecon review Tomasz pointed out that we don't always require
a complete type for the right operand of an assignment.  Given
<code>T::operator=(U&amp;)</code>
we should be able to give a correct answer for
<code>is_assignable&lt;T&amp;, U&amp;&gt;</code>
whether of not <code class='backtick'>U</code> is complete.
This also affects e.g. <code>is_constructible&lt;T, U&amp;&gt;</code>
if <code>T::T(U&amp;)</code> exists.
</p>
<p>
So for the examples above,
<code>remove_cvref_t&lt;U&gt;</code>
is not needed to give a correct answer.
However, if <code>T::operator=(U&amp;)</code> does not exist,
then we do need <code class='backtick'>U</code> to be complete so we can tell if there is
an implicit conversion sequence to <code class='backtick'>T</code> or another type that can be
assigned to <code class='backtick'>T</code>.
We do not know how to solve this problem, and it's broader than just
<code class='backtick'>is_assignable</code>.
It was suggested to make an incremental improvement to <code class='backtick'>is_assignable</code>
and open a new issue for the broader issue.
</p>


<p id="res-3099"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.</p>
<blockquote>
<ol>
<li>In 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> Table 51, change the Precondition text for <code>is_assignable</code>,
<code>is_trivially_assignable</code>, and <code>is_nothrow_assignable</code> as follows:
<blockquote>
<ins><code>remove_cvref_t&lt;</code></ins><code>T</code><ins><code>&gt;</code></ins> and
<code>U</code> shall be complete types, <i>cv</i> <code>void</code>, or arrays of unknown bound.
</blockquote>
</li>

<li>In 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> Table 51, change the Precondition text for <code>is_copy_assignable</code>,
<code>is_move_assignable</code>, <code>is_trivially_copy_assignable</code>, <code>is_trivially_move_assignable</code>,
<code>is_nothrow_copy_assignable</code>, and <code>is_nothrow_move_assignable</code> as follows:
<blockquote>
<ins><code>remove_cvref_t&lt;</code></ins><code>T</code><ins><code>&gt;</code></ins> shall be a complete type, <del><i>cv</i></del>
<code>void</code>, or an array of unknown bound.
</blockquote>
</li>
</ol>
</blockquote>





<hr>
<h3 id="3105"><a href="3105">3105</a>. <code>T1</code> is convertible to <code>T2</code></h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/library">[library]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2018-04-24 <b>Last modified:</b> 2023-06-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library wording frequently uses the construction "type <code>T1</code> is convertible to type <code>T2</code>", 
but this is an undefined phrase.
<p/>
For requirements on user code (e.g. [tuple.rel]), it is unclear whether all expressions of type <code>T1</code> 
must satisfy the convertibility requirement, regardless of value category, or whether a single
value category is in view only.
<p/>
Consider:
</p>
<blockquote>
<pre>
struct C 
{
  operator int() &amp;&amp;;
};

int main()
{
  int x = C(); <i>// prvalue can be implicitly converted to int</i>
  C c;
  int y = c;   <i>// lvalue can't</i>
}
</pre>
</blockquote>
<p>
The library has an "<code>is_convertible&lt;T1, T2&gt;</code>" trait, but that checks convertibility 
only for a single value category, not all possible ones.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>

<p><i>[2023-06-24; Daniel comments]</i></p>

<p>
This issue has very much overlap with LWG <a href="484" title="Convertible to T (Status: Open)">484</a>.
</p>


<p id="res-3105"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3107"><a href="3107">3107</a>. <code>istreambuf_iterator</code> has public <i>exposition-only</i> member</h3>
<p><b>Section:</b> 24.6.4 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-04-26 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#istreambuf.iterator">active issues</a> in [istreambuf.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG has said recently that we don't want public exposition-only things, as that may encourage users to try 
to use those names (and some implementers to actually use those names).
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 4</p>


<p id="res-3107"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4741">N4741</a>.
</p>

<ol>
<li>
<p>Edit 24.6.4 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a> as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class istreambuf_iterator {
  public:
    [&hellip;]
    using istream_type = basic_istream&lt;charT,traits&gt;;
  
    <del>class proxy; <i>// exposition only</i></del>
  
    constexpr istreambuf_iterator() noexcept;
    [&hellip;]
  private:
    <ins>class proxy; <i>// exposition only</i></ins>
    streambuf_type* sbuf_; <i>// exposition only</i>
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3108"><a href="3108">3108</a>. <code>istreambuf_iterator::proxy::operator*</code> should be <code>const</code></h3>
<p><b>Section:</b> 24.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator.proxy">[istreambuf.iterator.proxy]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-04-26 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>operator*</code> on iterators is usually intended to be <code>const</code>; see 24.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/input.iterators">[input.iterators]</a> 
Table 87, <code>*a</code>, where <code>a</code> is of type <code>X</code> or <code>const X</code>. (Technically, <code>proxy</code> 
is implementing the <code>*r++</code> requirement in this table, and <code>r</code> doesn't imply a const iterator, 
but there's no reason for the iterator's <code>operator*</code> to differ from the proxy)
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 3</p>


<p id="res-3108"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4741">N4741</a>.
</p>

<ol>
<li>
<p>Edit 24.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator.proxy">[istreambuf.iterator.proxy]</a> as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class istreambuf_iterator&lt;charT, traits&gt;::proxy { <i>// exposition only</i>
    charT keep_;
    basic_streambuf&lt;charT,traits&gt;* sbuf_;
    proxy(charT c, basic_streambuf&lt;charT,traits&gt;* sbuf)
      : keep_(c), sbuf_(sbuf) { }
    public:
      charT operator*() <ins>const</ins> { return keep_; }
  };
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3109"><a href="3109">3109</a>. <code>strstreambuf</code> is copyable</h3>
<p><b>Section:</b> 99 [depr.strstreambuf] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-05-02 <b>Last modified:</b> 2018-06-19</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++03 <code>strstreambuf</code> was not copyable, because <code>basic_streambuf</code> wasn't copyable. 
In C++11 we made <code>basic_streambuf</code> copyable by derived classes, and <code>strstreambuf</code> 
doesn't define any special members, so it (unintentionally?) became copyable, with completely 
unspecified semantics.
<p/>
VC++ and libc++ make it movable not copyable, and libstdc++ still follows C++03, so it's neither 
movable nor copyable. Making it movable seems to be the sane option, and consistent with 
<code>filebuf</code> and <code>stringbuf</code>.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>Priority set to 4</p>


<p id="res-3109"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3114"><a href="3114">3114</a>. [networking.ts] Permit efficient composition when using <code>DynamicBuffer</code></h3>
<p><b>Section:</b> 16 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer">[networking.ts::buffer]</a>, 17 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.stream">[networking.ts::buffer.stream]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Vinnie Falco <b>Opened:</b> 2018-05-18 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses: networking.ts</b>
<p>
Asynchronous algorithms are started by a call to an <em>initiating function</em>.
When these algorithms are constructed from calls to other initiating functions,
the result is called a <em>composed operation</em>. For example, <code>async_read</code> may be 
implemented in terms of zero or more calls to a stream's <code>async_read_some</code> algorithm. 
For operations where the caller cannot easily determine ahead of time the storage requirements 
needed for an algorithm to meet its post-conditions, [networking.ts] introduces the
<b>DynamicBuffer</b> concept:
</p>
<blockquote>
<p>
A dynamic buffer encapsulates memory storage that may be automatically
resized as required, where the memory is divided into two regions: readable
bytes followed by writable bytes. [buffer.reqmts.dynamicbuffer]
</p>
</blockquote>
<p>
Signatures for algorithms in the technical specification which accept dynamic
buffers use forwarding references:
</p>
<blockquote><pre>
<i>// 17.10 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read.until">[networking.ts::buffer.async.read.until]</a>, asynchronous delimited read operations:</i>

template&lt;
  class AsyncReadStream,
  class DynamicBuffer,
  class CompletionToken&gt;
<i>DEDUCED</i> async_read_until(
  AsyncReadStream&amp; s,
  DynamicBuffer&amp;&amp; b,
  char delim,
  CompletionToken&amp;&amp; token);
</pre></blockquote>
<p>
Because the initiating function returns immediately, and the associated composed operation executes later, 
it is necessary for the algorithm to manage the lifetime of the dynamic buffer. Guidance for doing so is 
given in the TS:
</p>
<blockquote>
<b>13.2.7.5 Lifetime of initiating function arguments [async.reqmts.async.lifetime]</b>
<p>
1. Unless otherwise specified, the lifetime of arguments to initiating functions shall be treated as 
follows: [&hellip;] the implementation does not assume the validity of the argument after the initiating 
function completes [&hellip;] The implementation may make copies of the argument, and all copies shall be
destroyed no later than immediately after invocation of the completion handler.
</p>
</blockquote>
<p>
Given the guidance above, the most sensible approach is for the implementation
to move or make a decay-copy of the argument. An implementation of the TS,
authored by the principal architect of the TS itself, does precisely that:
</p>
<blockquote><pre>
template &lt;
    typename AsyncReadStream,
    typename DynamicBuffer,
    typename ReadHandler&gt;
class read_until_delim_op
{
public:
    template &lt;typename DeducedBuffers&gt;
    read_until_delim_op(
        AsyncReadStream&amp; stream,
        DeducedBuffers&amp;&amp; buffers,
        char delim, ReadHandler&amp; handler)
    : [&hellip;]
      buffers_(std::forward&lt;DeducedBuffers&gt;(buffers))
      [&hellip;]
    {
    }
    [&hellip;]
    DynamicBuffer buffers_;
    [&hellip;]
};

template &lt;
    typename AsyncReadStream,
    typename DynamicBuffer,
    typename ReadHandler&gt;
NET_TS_INITFN_RESULT_TYPE(ReadHandler,
    void (std::error_code, std::size_t))
async_read_until(
    AsyncReadStream&amp; s,
    DynamicBuffer&amp;&amp; buffers,
    char delim,
    ReadHandler&amp;&amp; handler)
{
  // If you get an error on the following line it means that your handler does
  // not meet the documented type requirements for a ReadHandler.
  NET_TS_READ_HANDLER_CHECK(ReadHandler, handler) type_check;

  async_completion&lt;ReadHandler,
    void (std::error_code, std::size_t)&gt; init(handler);

  detail::read_until_delim_op&lt;
    AsyncReadStream,
    typename decay&lt;DynamicBuffer&gt;::type,
    NET_TS_HANDLER_TYPE(ReadHandler, void (std::error_code, std::size_t))&gt;(
        s,
        DynamicBuffer&amp;&amp;buffers,
        delim,
        init.completion_handler)(std::error_code(), 0, 1);

  return init.result.get();
}
</pre></blockquote>
<p>
Given the semantics of dynamic buffers implied by the wording, instances of
dynamic buffers behave more like references to storage types rather than
storage types, as copies refer to the same underlying storage. This can be
seen in the declaration of <code>dynamic_string_buffer</code> which meets
the requirements of <b>DynamicBuffer</b>:
</p>
<blockquote><pre>
template &lt;typename Elem, typename Traits, typename Allocator&gt;
class dynamic_string_buffer
{
  [&hellip;]
private:
  std::basic_string&lt;Elem, Traits, Allocator&gt;&amp; string_;
  std::size_t size_;
  const std::size_t max_size_;
};
</pre></blockquote>
<p>
A dynamic string buffer contains a reference to the underlying string. Copies
of a dynamic string buffer refer to the same string. Note that the dynamic
string buffer also contains some state: the <code>size_</code> and <code>max_size_</code>
data members. This additional metadata informs the dynamic string buffer of
the boundaries between the readable and writable bytes, as well as the maximum
allowed size of the total of the readable and writable bytes.
<p/>
When only one composed operation handles the dynamic buffer, things seem to
work. However, if a composed operation wishes to invoke another composed
operation and pass that dynamic buffer, a problem arises. Consider two composed
operations <code>f</code> and <code>g</code>, which both operate on an instance of
dynamic buffer. When <code>f</code> is invoked, it makes a copy of the dynamic
buffer and then calls <code>g</code> with the copy. At this point, <code>g</code> must
also make a copy. Copies share the underlying storage, but in the case of
dynamic string buffers each copy maintains its own distinct metadata. When
<code>g</code> has finished mutating the dynamic buffer and returns control back
to <code>f</code> by invoking the completion handler, the metadata in the copy of
the dynamic buffer held by <code>f</code> will not have the changes made by <code>g</code>.
<p/>
Another design problem caused by adding metadata to the dynamic buffer concept
is illustrated in the following example code:
</p>
<blockquote><pre>
template&lt;class MutableBufferSequence&gt;
std::size_t read(const MutableBufferSequence&amp;)
{
  throw std::exception{};
}

int main()
{
  std::string s;
  assert(s.empty());
  try
  {
    auto b = boost::asio::dynamic_buffer(s);
    b.commit(read(b.prepare(32)));
  }
  catch(const std::exception&amp;)
  {
    assert(s.empty()); // fails
  }
}
</pre></blockquote>
<p>
While not technically incorrect, it may be surprising to the user that
the string contains additional value-initialized data which was not part
of the original readable bytes (which in this case was empty). The wording of
the dynamic buffer concept does not address this case.
<p/>
The solution we propose is to change the semantics of <b>DynamicBuffer</b>
to represent a true storage type rather than a hybrid reference with metadata.
Instances of dynamic buffers will be passed by reference, and callers will
be required to manage the lifetime of dynamic buffer objects for the duration
of any asynchronous operations. An additional benefit of this change is that
it also solves the problem of exceptions described above.
</p>

<p><i>[2018-06-18 after reflector discussion]</i></p>

<p>
Status to LEWG; there will be a paper <a href="https://wg21.link/p1100r0">P1100R0</a> in the post-Rapperswil mailing 
addressing this.
</p>

<p><i>[2020-05-28; Billy Baker comments]</i></p>

<p>
From <a href="https://github.com/cplusplus/papers/issues/337">Cologne 2019 paper discussion</a>:
<a href="https://wg21.link/p1100">P1100</a> has been superseded by <a href="https://wg21.link/p1790">P1790</a>.
</p>


<p id="res-3114"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4734">N4734</a>.</p>

<blockquote class="note">
<p>[<i>Drafting note:</i> The project editor is kindly asked to replace all occurrences of 
<code>DynamicBuffer&amp;&amp;</code> with <code>DynamicBuffer&amp;</code> as indicated by the provided
wording changes below. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<ol>
<li><p>Modify 16.1 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.synop">[networking.ts::buffer.synop]</a>, header <code>&lt;experimental/buffer&gt;</code> synopsis, 
as indicated:</p>
<blockquote><pre>
[&hellip;]
<i>// 16.11 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.creation">[networking.ts::buffer.creation]</a>, buffer creation:</i>
[&hellip;]

template&lt;class T, class Allocator&gt;
class dynamic_vector_buffer;

template&lt;class CharT, class Traits, class Allocator&gt;
class <ins>basic_</ins>dynamic_string_buffer;

<del><i>// 16.14 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.dynamic.creation">[networking.ts::buffer.dynamic.creation]</a>, dynamic buffer creation:</i></del>

<del>template&lt;class T, class Allocator&gt;
  dynamic_vector_buffer&lt;T, Allocator&gt;
  dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec) noexcept;
template&lt;class T, class Allocator&gt;
  dynamic_vector_buffer&lt;T, Allocator&gt;
  dynamic_buffer(vector&lt;T, Allocator&gt;&amp; vec, size_t n) noexcept;
</del>

<del>template&lt;class CharT, class Traits, class Allocator&gt;
  dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
  dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str) noexcept;
template&lt;class CharT, class Traits, class Allocator&gt;
  dynamic_string_buffer&lt;CharT, Traits, Allocator&gt;
  dynamic_buffer(basic_string&lt;CharT, Traits, Allocator&gt;&amp; str, size_t n) noexcept;</del>

[&hellip;]
<i>// 17.5 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.read">[networking.ts::buffer.read]</a>, synchronous read operations:</i>
[&hellip;]

template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
              CompletionCondition completion_condition);
template&lt;class SyncReadStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
              CompletionCondition completion_condition, error_code&amp; ec);

<i>// 17.6 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read">[networking.ts::buffer.async.read]</a>, asynchronous read operations:</i>              
[&hellip;]

template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read(AsyncReadStream&amp; stream,
                     DynamicBuffer&amp;<del>&amp;</del> b, CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer,
  class CompletionCondition, class CompletionToken&gt;
    <i>DEDUCED</i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;<del>&amp;</del> b,
                       CompletionCondition completion_condition,
                       CompletionToken&amp;&amp; token);

<i>// 17.7 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.write">[networking.ts::buffer.write]</a>, synchronous write operations:</i>                       
[&hellip;]

template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del>; b);
template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b, error_code&amp; ec);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
               CompletionCondition completion_condition);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
               CompletionCondition completion_condition, error_code&amp; ec);

<i>// 17.8 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.write">[networking.ts::buffer.async.write]</a>, asynchronous write operations:</i>               
[&hellip;]

template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_write(AsyncWriteStream&amp; stream,
                      DynamicBuffer&amp;<del>&amp;</del> b, CompletionToken&amp;&amp; token);
template&lt;class AsyncWriteStream, class DynamicBuffer,
  class CompletionCondition, class CompletionToken&gt;
    <i>DEDUCED</i> async_write(AsyncWriteStream&amp; stream,
                        DynamicBuffer&amp;<del>&amp;</del> b,
                        CompletionCondition completion_condition,
                        CompletionToken&amp;&amp; token);

<i>// 17.9 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.read.until">[networking.ts::buffer.read.until]</a>, synchronous delimited read operations:</i>                        

template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b, char delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b,
                    char delim, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b, string_view delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b,
                    string_view delim, error_code&amp; ec);

<i>// 17.10 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read.until">[networking.ts::buffer.async.read.until]</a>, asynchronous delimited read operations:</i>

template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;<del>&amp;</del> b, char delim,
                           CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;<del>&amp;</del> b, string_view delim,
                           CompletionToken&amp;&amp; token);

[&hellip;]
</pre></blockquote>
</li>

<li>
<p>Modify 16.2.4 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.reqmts.dynamicbuffer">[networking.ts::buffer.reqmts.dynamicbuffer]</a>, as indicated:</p>

<blockquote>
<p>
-1- [&hellip;]
<p/>
-2- A type <code>X</code> meets the <code>DynamicBuffer</code> requirements if it satisfies
the requirements of <code>Destructible</code> (C++ 2014 [destructible])
<del>and <code>MoveConstructible</code> (C++ 2014 [moveconstructible]),</del>
as well as the additional requirements listed in Table 14.
</p>
</blockquote>
</li>

<li><p>Modify 16.12 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.dynamic.vector">[networking.ts::buffer.dynamic.vector]</a>, as indicated:</p>

<blockquote>
<blockquote><pre>
[&hellip;]

template&lt;class T, class Allocator<ins> = allocator&lt;T&gt;</ins>&gt;
class dynamic_vector_buffer
{
public:
  <em>// types:</em>
  <ins>using value_type = vector&lt;T, Allocator&gt;;</ins>
  using const_buffers_type = const_buffer;
  using mutable_buffers_type = mutable_buffer;
  
  <em>// constructors:</em>
  <ins>dynamic_vector_buffer() = default;</ins>
  <ins>explicit dynamic_vector_buffer(size_t maximum_size);</ins>
  explicit dynamic_vector_buffer(vector&lt;T, Allocator&gt;<del>&amp;</del> vec) <del>noexcept;</del>
  dynamic_vector_buffer(vector&lt;T, Allocator&gt;<del>&amp;</del> vec, size_t maximum_size) <del>noexcept;</del>
  dynamic_vector_buffer(dynamic_vector_buffer&amp;&amp;) = default;
  
  <em>// members:</em>
  size_t size() const noexcept;
  size_t max_size() const noexcept;
  <ins>void max_size(size_t maximum_size);</ins>
  size_t capacity() const noexcept;
  const_buffers_type data() const noexcept;
  mutable_buffers_type prepare(size_t n);
  void commit(size_t n);
  void consume(size_t n);
  <ins>span&lt;const T&gt; get() const noexcept</ins>
  <ins>value_type release();</ins>

private:
  vector&lt;T, Allocator&gt;<del>&amp;</del> vec_; <em>// exposition only</em>
  size_t size_; <em>// exposition only</em>
  <del>const</del> size_t max_size_; <em>// exposition only</em>
};

[&hellip;]
</pre></blockquote>
<p>
-2- [&hellip;]
<p/>
-3- [&hellip;]
</p>
<pre>
<ins>explicit dynamic_vector_buffer(size_t maximum_size)</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Default-constructs <code>vec_</code>. Initializes <code>size_</code> with <code>0</code>, and 
<code>max_size_</code> with <code>maximum_size</code>.</ins>
</p>
</blockquote>
<pre>
explicit dynamic_vector_buffer(vector&lt;T, Allocator&gt;<del>&amp;</del> vec) <del>noexcept</del>
</pre>
<blockquote>
<p>
-4- <em>Effects:</em> Initializes <code>vec_</code> with <code><ins>move(</ins>vec<ins>)</ins></code>,
  <code>size_</code> with <code>vec<ins>_</ins>.size()</code>, and <code>max_size_</code> with <code>vec<ins>_</ins>.max_size()</code>
</p>
</blockquote>
<pre>
dynamic_vector_buffer(vector&lt;T, Allocator&gt;<del>&amp;</del> vec,
                      size_t maximum_size) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-5- <em>Requires:</em> <code>vec.size() &lt;= maximum_size</code>
<p/>
-6- <em>Effects:</em> Initializes <code>vec_</code> with <code><ins>move(</ins>vec<ins>)</ins></code>,
  <code>size_</code> with <code>vec<ins>_</ins>.size()</code>, and <code>max_size_</code> with <code>maximum_size</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
size_t max_size() const noexcept;
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> <code>max_size_</code>.
</p>
</blockquote>
<pre>
<ins>void max_size(size_t maximum_size)</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Performs <code>max_size_ = maximum_size</code>.</ins>
</p>
</blockquote>
[&hellip;]
<pre>
void consume(size_t n);
</pre>
<blockquote>
<p>
-15- <i>Effects:</i> [&hellip;]
</p>
</blockquote>
<pre>
<ins>span&lt;const T&gt; get() const noexcept</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Returns:</em> <code>span&lt;const T&gt;(vec_.data(), size_)</code>.</ins>
</p>
</blockquote>
<pre>
<ins>value_type release()</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Returns:</em> <code>move(vec_)</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 16.13 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.dynamic.string">[networking.ts::buffer.dynamic.string]</a>, as indicated:</p>

<blockquote>
<blockquote><pre>
template&lt;class CharT, class Traits, class Allocator&gt;
class <ins>basic_</ins>dynamic_string_buffer
{
public:
  <em>// types:</em>
  <ins>using value_type = basic_string&lt;CharT, Traits, Allocator&gt;;</ins>
  using const_buffers_type = const_buffer;
  using mutable_buffers_type = mutable_buffer;

  <em>// constructors:</em>
  <ins>basic_dynamic_string_buffer() = default;</ins>
  <ins>explicit basic_dynamic_string_buffer(size_t maximum_size);</ins>
  explicit <ins>basic_</ins>dynamic_string_buffer(basic_string&lt;CharT, Traits, Allocator&gt;<del>&amp;</del> str) <del>noexcept;</del>
  <ins>basic_</ins>dynamic_string_buffer(basic_string&lt;CharT, Traits, Allocator&gt;<del>&amp;</del> str, size_t maximum_size) <del>noexcept;</del>
  <ins>basic_</ins>dynamic_string_buffer(<ins>basic_</ins>dynamic_string_buffer&amp;&amp;) = default;

  <em>// members:</em>
  size_t size() const noexcept;
  size_t max_size() const noexcept;
  <ins>void max_size(size_t maximum_size)</ins>
  size_t capacity() const noexcept;
  const_buffers_type data() const noexcept;
  mutable_buffers_type prepare(size_t n);
  void commit(size_t n) noexcept;
  void consume(size_t n);
  <ins>basic_string_view&lt;CharT, Traits&gt; get() const noexcept</ins>
  <ins>value_type release();</ins>

private:
  basic_string&lt;CharT, Traits, Allocator&gt;<del>&amp;</del> str_; <em>// exposition only</em>
  size_t size_; <em>// exposition only</em>
  <del>const </del>size_t max_size_; <em>// exposition only</em>
};

<ins>using dynamic_string_buffer =
  basic_dynamic_string_buffer&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;</ins>
</pre>
</blockquote>
<p>
-2- [&hellip;]
<p/>
-3- [&hellip;]
</p>
<pre>
<ins>explicit basic_dynamic_string_buffer(size_t maximum_size)</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Default-constructs <code>str_</code>. Initializes <code>size_</code> with <code>0</code>, and 
<code>max_size_</code> with <code>maximum_size</code>.</ins>
</p>
<p>[&hellip;]</p>
</blockquote>
<pre>
explicit <ins>basic_</ins>dynamic_string_buffer(basic_string&lt;CharT, Traits, Allocator&gt;<del>&amp;</del> str) <del>noexcept</del>
</pre>
<blockquote>
<p>
-4- <em>Effects:</em> Initializes <code>str_</code> with <code><ins>move(</ins>str<ins>)</ins></code>,
  <code>size_</code> with <code>str<ins>_</ins>.size()</code>, and <code>max_size_</code> with <code>str<ins>_</ins>.max_size()</code>
</p>
</blockquote>
<pre>
<ins>basic_</ins>dynamic_string_buffer(string&lt;CharT, Traits, Allocator&gt;<del>&amp;</del> str,
                            size_t maximum_size) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-5- <em>Requires:</em> <code>str.size() &lt;= maximum_size</code>.
</p>
<p>
-6- <em>Effects:</em> Initializes <code>str_</code> with <code><ins>move(</ins>str<ins>)</ins></code>,
  <code>size_</code> with <code>str<ins>_</ins>.size()</code>, and <code>max_size_</code> with <code>maximum_size</code>.
</p>
<p>[&hellip;]</p>
</blockquote>
<pre>
size_t max_size() const noexcept;
</pre>
<blockquote>
<p>
-8- <em>Returns:</em> <code>max_size_</code>.
</p>
</blockquote>
<pre>
<ins>void max_size(size_t maximum_size)</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Effects:</em> Performs <code>max_size_ = maximum_size</code>.</ins>
</p>
</blockquote>
<p>[&hellip;]</p>
<pre>
void consume(size_t n);
</pre>
<blockquote>
<p>
-15- <i>Effects:</i> [&hellip;]
</p>
</blockquote>
<pre>
<ins>basic_string_view&lt;CharT, Traits&gt; get() const noexcept</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Returns:</em> <code>basic_string_view&lt;CharT, Traits&gt;(str_)</code>.</ins>
</p>
</blockquote>
<pre>
<ins>value_type release()</ins>
</pre>
<blockquote>
<p>
<ins>-?- <em>Returns:</em> <code>move(str_)</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 16.14 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.dynamic.creation">[networking.ts::buffer.dynamic.creation]</a> entirely</p></li>

<li><p>Modify 17.5 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.read">[networking.ts::buffer.read]</a>, as indicated:</p>
<blockquote>
<pre>
[&hellip;]

template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
                CompletionCondition completion_condition);
template&lt;class SyncReadStream, class DynamicBuffer,
  class CompletionCondition&gt;
    size_t read(SyncReadStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
                CompletionCondition completion_condition,
                error_code&amp; ec);

[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 17.6 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read">[networking.ts::buffer.async.read]</a>, as indicated:</p>
<blockquote>
<pre>
[&hellip;]

template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read(AsyncReadStream&amp; stream,
                     DynamicBuffer&amp;<del>&amp;</del> b, CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionCondition,
  class CompletionToken&gt;
    <i>DEDUCED</i> async_read(AsyncReadStream&amp; stream,
                       DynamicBuffer&amp;<del>&amp;</del> b,
                       CompletionCondition completion_condition,
                       CompletionToken&amp;&amp; token);

[&hellip;]
</pre>
<p>
-14- The program shall ensure <ins>both</ins> the <code>AsyncReadStream</code>
object <code>stream</code> <ins>and the <code>DynamicBuffer</code> object <code>b</code>
are</ins><del> is</del> valid until the completion handler for the asynchronous
operation is invoked.
</p>
</blockquote>
</li>

<li><p>Modify 17.7 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.write">[networking.ts::buffer.write]</a>, as indicated:</p>
<blockquote><pre>
[&hellip;]

template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b);
template&lt;class SyncWriteStream, class DynamicBuffer&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b, error_code&amp; ec);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
               CompletionCondition completion_condition);
template&lt;class SyncWriteStream, class DynamicBuffer, class CompletionCondition&gt;
  size_t write(SyncWriteStream&amp; stream, DynamicBuffer&amp;<del>&amp;</del> b,
               CompletionCondition completion_condition,
               error_code&amp; ec);

[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 17.8 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.write">[networking.ts::buffer.async.write]</a>, as indicated:</p>
<blockquote><pre>
[&hellip;]

template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_write(AsyncWriteStream&amp; stream,
                      DynamicBuffer&amp;<del>&amp;</del> b, CompletionToken&amp;&amp; token);
template&lt;class AsyncWriteStream, class DynamicBuffer, class CompletionCondition,
  class CompletionToken&gt;
    <i>DEDUCED</i> async_write(AsyncWriteStream&amp; stream,
                        DynamicBuffer&amp;<del>&amp;</del> b,
                        CompletionCondition completion_condition,
                        CompletionToken&amp;&amp; token);

[&hellip;]
</pre>
<p>
-14- The program shall ensure both the <code>AsyncWriteStream</code> object
<code>stream</code> and the <ins><code>DynamicBuffer</code> object <code>b</code></ins>
<del>memory associated with the dynamic buffer <code>b</code></del>
are valid until the completion handler for the asynchronous operation
is invoked.
</p>
</blockquote>
</li>

<li><p>Modify 17.9 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.read.until">[networking.ts::buffer.read.until]</a>, as indicated:</p>
<blockquote><pre>
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b, char delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b,
                    char delim, error_code&amp; ec);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b, string_view delim);
template&lt;class SyncReadStream, class DynamicBuffer&gt;
  size_t read_until(SyncReadStream&amp; s, DynamicBuffer&amp;<del>&amp;</del> b,
                    string_view delim, error_code&amp; ec);

[&hellip;]
</pre></blockquote>
</li>

<li><p>Modify 17.10 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/buffer.async.read.until">[networking.ts::buffer.async.read.until]</a>, as indicated:</p>
<blockquote><pre>
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;<del>&amp;</del> b, char delim,
                           CompletionToken&amp;&amp; token);
template&lt;class AsyncReadStream, class DynamicBuffer, class CompletionToken&gt;
  <i>DEDUCED</i> async_read_until(AsyncReadStream&amp; s,
                           DynamicBuffer&amp;<del>&amp;</del> b, string_view delim,
                           CompletionToken&amp;&amp; token);

[&hellip;]
</pre>
<p>
-6- The program shall ensure <ins>both</ins> the <code>AsyncReadStream</code> object
<code>stream</code> <ins>and the <code>DynamicBuffer</code> object <code>b</code>
are</ins><del> is</del> valid until the completion handler for the
asynchronous operation is invoked.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3124"><a href="3124">3124</a>. [networking.ts] Unclear how <code>execution_context</code> is intended to store services</h3>
<p><b>Section:</b> 13.7.5 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/async.exec.ctx.globals">[networking.ts::async.exec.ctx.globals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-06-23 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<b>Addresses: networking.ts</b>
<p>
<code>make_service</code> and <code>use_service</code> create arbitrary numbers of type <code>Service</code>, a type provided 
by the user, similar to how locale's <code>use_facet</code> works. As a result there's no amount of storage that could 
be reserved inside <code>execution_context</code> to avoid allocating memory. However, there's no allocator support 
here, and <code>make_service</code> is forbidden from throwing allocation related exceptions by 
<a href="https://wg21.link/n4734">N4734</a> [async.exec.ctx.globals]/7.
<p/>
If the intent is for <code>execution_context</code> to allocate memory, are user overloads of <code>operator new</code> 
on type <code>Service</code> intended to be used?
</p>

<p><i>[2018-07-20 Priority set to 3 after reflector discussion]</i></p>

<p><i>[Jonathan provides wording.]</i></p>



<p id="res-3124"><b>Proposed resolution:</b></p>
<p>This wording is relative to the N4762.</p>

<ol>
<li><p>Modify 13.7.5 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/async.exec.ctx.globals">[networking.ts::async.exec.ctx.globals]</a> p7:</p>
<p>
-7- <i>Throws:</i> <code>service_already_exists</code> if a corresponding service object of type <code>Service::key_type</code> is
already present in the set <ins>, <code>bad_alloc</code>, or an implementation-defined exception when a resource other than memory could
not be obtained. Any exception thrown by the constructor of <code>Service</code></ins>.
</p>
</li>
</ol>





<hr>
<h3 id="3126"><a href="3126">3126</a>. There's no <code>std::sub_match::compare(string_view)</code> overload</h3>
<p><b>Section:</b> 28.6.8 <a href="https://timsong-cpp.github.io/cppwp/re.submatch">[re.submatch]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-06-26 <b>Last modified:</b> 2024-10-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.submatch">issues</a> in [re.submatch].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::sub_match::compare</code> can be called with a <code>basic_string</code> or a pointer to a null-terminated
character sequence, but can't be called with a <code>basic_string_view</code>. To compare to a <code>string_view</code>
requires either conversion to <code>basic_string</code> (with a potential allocation) or a redundant call to
<code>traits_type::length</code> to calculate a length that is already known.
</p>

<p><i>[2018-07-02, Jonathan comments and completes proposed wording]</i></p>

<p>
To make the relational and equality operators for <code>sub_match</code> support string views I propose specifying
the semantics, not adding another 12 overloaded operators to namespace <code>std</code>, in addition to the 42
already there. This allows them to be implemented as "hidden friends" if the implementation so desires, or to
retain namespace-scope declaration if backwards compatibility with C++11 - C++17 is preferred.
</p>

<p><i>[2018-07-20 Priority set to 3 after reflector discussion]</i></p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/n4750">N4750</a>.
</p>

<ol>
<li>
<p>Change 28.6.3 <a href="https://timsong-cpp.github.io/cppwp/re.syn">[re.syn]</a>, header <code>&lt;regex&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;initializer_list&gt;

namespace std {
  [&hellip;]
  using csub_match = sub_match&lt;const char*&gt;;
  using wcsub_match = sub_match&lt;const wchar_t*&gt;;
  using ssub_match = sub_match&lt;string::const_iterator&gt;;
  using wssub_match = sub_match&lt;wstring::const_iterator&gt;;

  <del><i>// 28.6.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.op">[re.submatch.op]</a>, sub_match non-member operators</i>
  template&lt;class BiIter&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  [&hellip;]
  template&lt;class BiIter&gt;
    bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
                   const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);</del>

  template&lt;class charT, class ST, class BiIter&gt;
  basic_ostream&lt;charT, ST&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, ST&gt;&amp; os, const sub_match&lt;BiIter&gt;&amp; m);
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li>
<p>Change 28.6.8 <a href="https://timsong-cpp.github.io/cppwp/re.submatch">[re.submatch]</a>, class template <code>sub_match</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class BidirectionalIterator&gt;
  class sub_match : public pair&lt;BidirectionalIterator, BidirectionalIterator&gt; {
  public:
    using value_type =
      typename iterator_traits&lt;BidirectionalIterator&gt;::value_type;
    [&hellip;]
    int compare(const sub_match&amp; s) const;
    int compare(const string_type&amp; s) const;
    int compare(const value_type* s) const;
    <ins>int compare(basic_string_view&lt;value_type&gt; s) const;</ins>
  };
}
</pre>
</blockquote>
</li>

<li>
<p>Change 28.6.8.2 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.members">[re.submatch.members]</a> as indicated:</p>

<blockquote>
<pre>
int compare(const value_type* s) const;
</pre>
<blockquote>
<p>
-7- <i>Returns:</i> <code>str().compare(s)</code>.
</p>
</blockquote>
<pre>
<ins>int compare(basic_string_view&lt;value_type&gt; s) const;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns:</i> <code>str().compare(s)</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Change sub-clause 28.6.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.op">[re.submatch.op]</a> as indicated:</p>

<blockquote>
<p>
<b>31.9.2 <code>sub_match</code> non-member operators [re.submatch.op]</b>
</p>
<pre><del>template&lt;class BiIter&gt;
bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);</del></pre>
<blockquote>
<p>
<del>-1- <i>Returns:</i> <code>lhs.compare(rhs) == 0</code>.</del>
</p>
</blockquote>
<del>[&hellip;]</del>
<pre>
<del>template&lt;class BiIter&gt;
  bool operator&gt;=(const sub_match&lt;BiIter&gt;&amp; lhs,
    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);</del></pre>
<blockquote>
<p>
<del>-42- <i>Returns:</i> <code>!(lhs &lt; rhs)</code>.</del>
</p>
</blockquote>
<pre>
template&lt;class charT, class ST, class BiIter&gt;
  basic_ostream&lt;charT, ST&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, ST&gt;&amp; os, const sub_match&lt;BiIter&gt;&amp; m);</pre>
<blockquote>
<p>
-43- <i>Returns:</i> <code>os &lt;&lt; m.str()</code>.
</p>
</blockquote>
<p>
<ins>Class template <code>sub_match</code> provides overloaded relational operators (7.6.9 <a href="https://timsong-cpp.github.io/cppwp/expr.rel">[expr.rel]</a>) and
equality operators (7.6.10 <a href="https://timsong-cpp.github.io/cppwp/expr.eq">[expr.eq]</a>) for comparisons with another <code>sub_match</code>, with a <code>string</code>,
or with a single character. The expressions shown in Table ?? are valid when one of the operands is a type <code>S</code>,
that is a specialization of <code>sub_match</code>, and the other expression is one of:</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.?) &mdash; a value <code>x</code> of a type <code>S</code>, in which case <code><i>STR</i>(x)</code> is
<code>x.str()</code>;</ins></p></li>
<li><p><ins>(?.?) &mdash; a value <code>x</code> of type <code>basic_string&lt;S::value_type, T, A&gt;</code> for any types
<code>T</code> and <code>A</code>, in which case <code><i>STR</i>(x)</code> is
<code>basic_string_view&lt;S::value_type&gt;(x.data(), x.length())</code>;</ins></p></li>
<li><p><ins>(?.?) &mdash; a value <code>x</code> of type <code>basic_string_view&lt;S::value_type, T&gt;</code> for
any type <code>T</code>, in which case <code><i>STR</i>(x)</code> is
<code>basic_string_view&lt;S::value_type&gt;(x.data(), x.length())</code>;</ins></p></li>
<li><p><ins>(?.?) &mdash; a value <code>x</code> of a type convertible to <code>const S::value_type*</code>, in which
case <code><i>STR</i>(x)</code> is <code>basic_string_view&lt;S::value_type&gt;(x)</code>;</ins></p></li>
<li><p><ins>(?.?) &mdash; a value <code>x</code> of type convertible to <code>S::value_type</code>, in which case
<code><i>STR</i>(x)</code> is <code>basic_string_view&lt;S::value_type&gt;(&amp;x, 1)</code>.</ins></p></li>
</ol>
<table border="1">
<caption><ins>Table ?? &mdash; <code>sub_match</code> comparisons</ins></caption>
<tr style="text-align:center">
<th><ins>Expression</ins></th>
<th><ins>Return type</ins></th>
<th><ins>Operational<br/>semantics</ins></th>
</tr>
<tr>
<td>
<ins><code>s == t</code></ins>
</td>
<td>
<ins><code>bool</code></ins>
</td>
<td>
<ins><code><i>STR</i>(s).compare(<i>STR</i>(t)) == 0</code></ins>
</td>
</tr>
<tr>
<td>
<ins><code>s != t</code></ins>
</td>
<td>
<ins><code>bool</code></ins>
</td>
<td>
<ins><code><i>STR</i>(s).compare(<i>STR</i>(t)) != 0</code></ins>
</td>
</tr>
<tr>
<td>
<ins><code>s &lt; t</code></ins>
</td>
<td>
<ins><code>bool</code></ins>
</td>
<td>
<ins><code><i>STR</i>(s).compare(<i>STR</i>(t)) &lt; 0</code></ins>
</td>
</tr>
<tr>
<td>
<ins><code>s &gt; t</code></ins>
</td>
<td>
<ins><code>bool</code></ins>
</td>
<td>
<ins><code><i>STR</i>(s).compare(<i>STR</i>(t)) &gt; 0</code></ins>
</td>
</tr>
<tr>
<td>
<ins><code>s &lt;= t</code></ins>
</td>
<td>
<ins><code>bool</code></ins>
</td>
<td>
<ins><code><i>STR</i>(s).compare(<i>STR</i>(t)) &lt;= 0</code></ins>
</td>
</tr>
<tr>
<td>
<ins><code>s &gt;= t</code></ins>
</td>
<td>
<ins><code>bool</code></ins>
</td>
<td>
<ins><code><i>STR</i>(s).compare(<i>STR</i>(t)) &gt;= 0</code></ins>
</td>
</tr>
</table>

</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2024-10-03; Jonathan rebases the wording on the latest WP]</i></p>

<p>The proposed resolution has been implemented and tested in libstdc++.</p>



<p id="res-3126"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.</p>

<ol>
<li>
<p>Change 28.6.3 <a href="https://timsong-cpp.github.io/cppwp/re.syn">[re.syn]</a>, header <code>&lt;regex&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
  using csub_match = sub_match&lt;const char*&gt;;
  using wcsub_match = sub_match&lt;const wchar_t*&gt;;
  using ssub_match = sub_match&lt;string::const_iterator&gt;;
  using wssub_match = sub_match&lt;wstring::const_iterator&gt;;

  <i>// 28.6.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.op">[re.submatch.op]</a>, sub_match non-member operators</i>
  template&lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;=&gt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);

  template&lt;class BiIter, class ST, class SA&gt;
    bool operator==(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
  template&lt;class BiIter, class ST, class SA&gt;
    bool operator&lt;=&gt;(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);
<ins>
  template&lt;class BiIter, class ST&gt;
    bool operator==(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string_view&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST&gt;&amp; rhs);
  template&lt;class BiIter, class ST&gt;
    bool operator&lt;=&gt;(
      const sub_match&lt;BiIter&gt;&amp; lhs,
      const basic_string_view&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST&gt;&amp; rhs);
</ins>
  template&lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;=&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                     const typename iterator_traits&lt;BiIter&gt;::value_type* rhs);

  template&lt;class BiIter&gt;
    bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs,
                    const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);
  template&lt;class BiIter&gt;
    bool operator&lt;=&gt;(const sub_match&lt;BiIter&gt;&amp; lhs,
                     const typename iterator_traits&lt;BiIter&gt;::value_type&amp; rhs);

  template&lt;class charT, class ST, class BiIter&gt;
    basic_ostream&lt;charT, ST&gt;&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, ST&gt;&amp; os, const sub_match&lt;BiIter&gt;&amp; m);
</pre>
</blockquote>
</li>

<li>
<p>Change 28.6.8 <a href="https://timsong-cpp.github.io/cppwp/re.submatch">[re.submatch]</a>, class template <code>sub_match</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class BidirectionalIterator&gt;
  class sub_match : public pair&lt;BidirectionalIterator, BidirectionalIterator&gt; {
  public:
    using value_type =
      typename iterator_traits&lt;BidirectionalIterator&gt;::value_type;
    [&hellip;]
    int compare(const sub_match&amp; s) const;
    int compare(const string_type&amp; s) const;
    int compare(const value_type* s) const;
    <ins>int compare(basic_string_view&lt;value_type&gt; s) const;</ins>
  };
}
</pre>
</blockquote>
</li>

<li>
<p>Change 28.6.8.2 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.members">[re.submatch.members]</a> as indicated:</p>

<blockquote>
<pre>
int compare(const value_type* s) const;
</pre>
<blockquote>
<p>
-7- <i>Returns:</i> <code>str().compare(s)</code>.
</p>
</blockquote>
<pre>
<ins>int compare(basic_string_view&lt;value_type&gt; s) const;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns:</i> <code>str().compare(s)</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Change sub-clause 28.6.8.3 <a href="https://timsong-cpp.github.io/cppwp/re.submatch.op">[re.submatch.op]</a> as indicated:</p>

<blockquote>
<p>
<b>32.8.3 <code>sub_match</code> non-member operators [re.submatch.op]</b>
</p>
<p>-1-
Let
<ins>
<code><i>SV</i>(I)</code> be
<code>basic_string_view&lt;typename iterator_traits&lt;I&gt;::value_type&gt;</code>
and let
</ins>
<code><i>SM-CAT</i>(I)</code> be
<code>compare_three_way_result_t&lt;<del>basic_string&lt;typename iterator_traits&lt;I&gt;::value_type&gt;</del><ins><i>SV</i>(I)</ins>&gt;</code>
</p>

<pre>template&lt;class BiIter&gt;
  bool operator==(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);</pre>
<blockquote>
<p>
-2- <i>Returns:</i>
<code>lhs.compare(rhs) == 0</code>.
</p>
</blockquote>

<pre>template&lt;class BiIter&gt;
  bool operator&lt;=&gt;(const sub_match&lt;BiIter&gt;&amp; lhs, const sub_match&lt;BiIter&gt;&amp; rhs);</pre>
<blockquote>
<p>
-3- <i>Returns:</i>
<code>static_cast&lt;<i>SM-CAT</i>(BiIter)&gt;(lhs.compare(rhs) &lt;=&gt; 0)</code>.
</p>
</blockquote>

<pre>template&lt;class BiIter, class ST, class SA&gt;
  bool operator==(
    const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);</pre>
<blockquote>
<p>
-4- <i>Returns:</i>
<code>lhs.compare(<del>typename sub_match&lt;BiIter&gt;::string_type</del><ins><i>SV</i>(BiIter)</ins>(rhs.data(), rhs.size())) == 0</code>.
</p>
</blockquote>

<pre>template&lt;class BiIter, class ST, class SA&gt;
  auto operator&lt;=&gt;(
    const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST, SA&gt;&amp; rhs);</pre>
<blockquote>
<p>
-5- <i>Returns:</i>
<pre><code>static_cast&lt;<i>SM-CAT</i>(BiIter)&gt;(lhs.compare(
    <del>typename sub_match&lt;BiIter&gt;::string_type</del><ins><i>SV</i>(BiIter)</ins>(rhs.data(), rhs.size()))
      &lt;=&gt; 0
    )
</code></pre>
</p>
</blockquote>


<pre><ins>template&lt;class BiIter, class ST&gt;
  bool operator==(
    const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string_view&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST&gt;&amp; rhs);</ins></pre>
<blockquote>
<p>
<ins>
-?- <i>Returns:</i>
<code>lhs.compare(<i>SV</i>(BiIter)(rhs.data(), rhs.size())) == 0</code>.
</ins>
</p>
</blockquote>

<pre><ins>template&lt;class BiIter, class ST&gt;
  auto operator&lt;=&gt;(
    const sub_match&lt;BiIter&gt;&amp; lhs,
    const basic_string_view&lt;typename iterator_traits&lt;BiIter&gt;::value_type, ST&gt;&amp; rhs);</ins></pre>
<blockquote>
<p>
<ins>
-?- <i>Returns:</i>
<code>
static_cast&lt;<i>SM-CAT</i>(BiIter)&gt;(lhs.compare(<i>SV</i>(BiIter)(rhs.data(), rhs.size())) &lt;=&gt; 0)
</code>.
</ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>





<hr>
<h3 id="3142"><a href="3142">3142</a>. <code>std::foo&lt;incomplete&gt;</code> should be ill-formed NDR</h3>
<p><b>Section:</b> 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-07-07 <b>Last modified:</b> 2018-11-27</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.functions">issues</a> in [res.on.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a>/2 states:
<blockquote>
<p>
-2- In particular, the effects are undefined in the following cases:
</p><p>
[&hellip;]
</p><p>
(2.5) &mdash; if an incomplete type (6.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>) is used as a template argument
when instantiating a template component or evaluating a concept, unless specifically allowed for
that component.
</p>
</blockquote>
While undefined behavior is appropriate for the other cases specified in the earlier bullets, which
describe failure to meet (runtime) semantic requirements, "instantiating a template component or
evaluating a concept" with an incomplete type happens at compile-time, and could potentially be
diagnosed. It would therefore be more appropriate to specify that programs which do so are
ill-formed with no diagnostic required.
</p>

<p><i>[2018-11 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p id="res-3142"><b>Proposed resolution:</b></p>

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<p>Change 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> as indicated:</p>
<blockquote>
<p>
<del>(2.5) &mdash; if an incomplete type (6.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>) is used as a template
argument when instantiating a template component or evaluating a concept, unless specifically
allowed for that component.</del>
</p><p>
<ins>-?- Unless explicitly stated otherwise, a program that instantiates a template component or
evaluates a concept with an incomplete type (6.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>) as a template argument is
ill-formed with no diagnostic required.</ins>
</p>
</blockquote>






<hr>
<h3 id="3157"><a href="3157">3157</a>. Allocator <code>destroy</code> and fancy pointer operations must be non-throwing</h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2018-09-07 <b>Last modified:</b> 2018-12-16</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In annotating things required to be called by <code>~vector</code>, Casey pointed out that several operations I guarded 
with <code>noexcept</code> aren't actually mandated by the standard to be <code>noexcept</code>. However, the STL, and more 
specifically here, containers, consider inability to destroy an element an unrecoverable condition. This is evidenced 
for the whole STL by 16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>/3 "Every destructor in the C ++ standard library shall 
behave as if it had a non-throwing exception specification.".
<p/>
As a result, <code>allocator::destroy</code> and fancy pointer operations must be non-throwing for valid input, or the 
containers don't make any sense. This is obvious for things like <code>vector::~vector</code>, but less obviously the 
containers rely on these guarantees whenever inserting more than one element, etc.
<p/>
Moreover, we too narrowly specify the domain of the <code>pointer_traits::pointer_to</code> requirement in the 
<code><i>Cpp17Allocator</i></code> requirements, because any node-based container that uses container-internal sentinel 
nodes needs to be able to form pointers to said sentinel nodes; that operation must also be non-throwing.
</p>

<p><i>[2018-09 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p id="res-3157"><b>Proposed resolution:</b></p>

<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ol>
<li><p>Modify 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 32 "Descriptive variable definitions" as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 32 &mdash; Descriptive variable definitions</caption>
<tr>
<th>Variable</th>
<th>Definition</th>
</tr>

<tr>
<td colspan="2" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>YY</code>
</td>
<td>
the type <code>allocator_traits&lt;Y&gt;</code>
</td>
</tr>

<tr>
<td>
<ins><code>Z</code></ins>
</td>
<td>
<ins>an allocator-aware container type (23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>)</ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>y</code>
</td>
<td>
a value of type <code>XX::const_void_pointer</code> obtained by<br/>
conversion from a result value of <code>YY::allocate</code>, or else a<br/>
value of type (possibly <code>const</code>) <code>std::nullptr_t</code>.
</td>
</tr>

<tr>
<td>
<code><ins>z</ins></code>
</td>
<td>
<ins>an lvalue of type <code>Z</code> such that <code>z.get_allocator() == a</code></ins>
</td>
</tr>

<tr>
<td>
<code><ins>r1</ins></code>
</td>
<td>
<ins>a reference to any member subobject of <code>z</code></ins>
</td>
</tr>

<tr>
<td>
<code>n</code>
</td>
<td>
a value of type <code>XX::size_type</code>.
</td>
</tr>

<tr>
<td colspan="2" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table 33 "<code><i>Cpp17Allocator</i></code> requirements" as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 33 &mdash; <code><i>Cpp17Allocator</i></code> requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>pointer_traits&lt;<br/>
X::pointer<br/>
&gt;::pointer_to(r)</code>
</td>
<td>
<code>X::pointer</code>
</td>
<td>
<ins>S</ins><del>s</del>ame as <code>p</code><ins>.<br/>
<i>Throws:</i> Nothing.</ins>
</td>
<td>
</td>
</tr>

<tr>
<td>
<ins><code>pointer_traits&lt;<br/>
X::pointer<br/>
&gt;::pointer_to(r1)</code></ins>
</td>
<td>
</td>
<td>
<ins>A value of type <code>YY::pointer</code> or<br/>
<code>YY::const_pointer</code> <code>k</code> such that<br/> 
<code>*k</code> is <code>r1</code>.<br/>
<i>Throws:</i> Nothing.</ins>
</td>
<td>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>a.destroy(c)</code>
</td>
<td>
(not used)
</td>
<td>
<i>Effects:</i> Destroys the object at <code>c</code><ins>.</ins><br/>
<ins><i>Throws:</i> Nothing.</ins>
</td>
<td>
<code>c-&gt;~C()</code>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, p5, as indicated:</p>

<blockquote>
<p>
-5- An allocator type <code>X</code> shall satisfy the <code><i>Cpp17CopyConstructible</i></code> requirements (Table 26). 
The <code>X::pointer</code>, <code>X::const_pointer</code>, <code>X::void_pointer</code>, and <code>X::const_void_pointer</code> 
types shall satisfy the <code><i>Cpp17NullablePointer</i></code> requirements (Table 30). No constructor, comparison 
function, copy operation, move operation, or swap operation on these pointer types shall exit via an exception. 
<code>X::pointer</code> and <code>X::const_pointer</code> shall also satisfy the requirements for a random access iterator 
(24.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>) and of a contiguous iterator (24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>)
<ins>and operations in those requirements shall not exit via an exception so long as resulting iterators are 
dereferencable or past-the-end</ins>.
</p>
</blockquote>
</li>

<li><p>Modify 20.2.9.3 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.members">[allocator.traits.members]</a>, as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  static void destroy(Alloc&amp; a, T* p);
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Calls <code>a.destroy(p)</code> if that call is well-formed; otherwise, invokes <code>p-&gt;~T()</code>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3159"><a href="3159">3159</a>. &sect;[unique.ptr.single] requirements on deleter may be too strict</h3>
<p><b>Section:</b> 20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2018-09-17 <b>Last modified:</b> 2018-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unique.ptr.single">active issues</a> in [unique.ptr.single].</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single">[unique.ptr.single]</a> p1 says:
</p>
<blockquote><p>
The default type for the template parameter <code>D</code> is <code>default_delete</code>. A client-supplied template argument 
<code>D</code> shall be a function object type (19.14), lvalue reference to function, or lvalue reference to function object 
type for which, given a value <code>d</code> of type <code>D</code> and a value ptr of type <code>unique_ptr&lt;T, D&gt;::pointer</code>, 
the expression <code>d(ptr)</code> is valid and has the effect of disposing of the pointer as appropriate for that deleter.
</p></blockquote>
<p>
That means this is undefined:
</p>
<blockquote><pre>
#include &lt;memory&gt;

struct IncompleteBase;

struct Deleter {
  void operator()(IncompleteBase*) const;
};

struct IncompleteDerived;

struct X {
  std::unique_ptr&lt;IncompleteDerived, Deleter&gt; p;
  ~X();
};
</pre></blockquote>
<p>
<code>unique_ptr::pointer</code> is <code>IncompleteDerived*</code>, but <code>is_invocable&lt;Deleter, IncompleteDerived*&gt;</code> 
is unknowable until the type is complete (see LWG <a href="3099" title="is_assignable&lt;Incomplete&amp;, Incomplete&amp;&gt; (Status: Open)">3099</a> etc).
<p/>
The intention is that <code>IncompleteDerived</code> only needs to be complete when the deleter is invoked, which is in the 
definition of <code>X::~X()</code> for this example. But the requirement for <code>d(ptr)</code> to be valid requires a complete type. 
If the <code>unique_ptr</code> implementation adds <code>static_assert(is_invocable_v&lt;D, pointer&gt;)</code> to enforce the 
requirement, the example above fails to compile. GCC recently added that assertion.
<p/>
Do we want to relax that requirement, or do we want to force the code above to define <code>Deleter::pointer</code> as 
<code>IncompleteBase*</code> so that the <code>is_invocable</code> condition can be checked?
<p/>
The destructor and <code>reset</code> member function already require that the deleter can be invoked (and that <i>Requires:</i> 
element will be turned into a <i>Mandates:</i> one soon). We can just remove that requirement from the preamble for the 
class template, or say that the expression only needs to be valid when the destructor and <code>reset</code> member are 
instantiated. We could also rephrase it in terms of <code>is_invocable_v&lt;D, unique_ptr&lt;T, D&gt;::pointer&gt;</code>.
</p>

<p><i>[2018-10 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p id="res-3159"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3161"><a href="3161">3161</a>. Container adapters mandate use of <code>emplace_back</code> but don't require it</h3>
<p><b>Section:</b> 23.6.6 <a href="https://timsong-cpp.github.io/cppwp/stack">[stack]</a>, 23.6.3 <a href="https://timsong-cpp.github.io/cppwp/queue">[queue]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2018-10-02 <b>Last modified:</b> 2020-05-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#stack">issues</a> in [stack].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.6.6 <a href="https://timsong-cpp.github.io/cppwp/stack">[stack]</a> p1 says:
</p>
<blockquote>
Any sequence container supporting operations <code>back()</code>, <code>push_back()</code> and <code>pop_back()</code> can be used to
instantiate <code>stack</code>.
</blockquote>

<p>but then in 23.6.6.2 <a href="https://timsong-cpp.github.io/cppwp/stack.defn">[stack.defn]</a> we have the following code:</p>
<pre>
template&lt;class... Args&gt;
  decltype(auto) emplace(Args&amp;&amp;... args)
    { return c.emplace_back(std::forward&lt;Args&gt;(args)...); }
</pre>

<p>The same pattern appears in 23.6.3 <a href="https://timsong-cpp.github.io/cppwp/queue">[queue]</a>.</p>

<p>I see two ways to resolve this:</p>
<p>The first is to add <code>emplace_back()</code> to the list of requirements for underlying containers for <code>stack</code> and <code>queue</code></p>

<p>The second is to replace the calls to <code>c.emplace_back(std::forward&lt;Args&gt;(args)...)</code> with <code>c.emplace(c.end(), std::forward&lt;Args&gt;(args)...)</code>. We can do this w/o messing with the list above because <code>emplace</code> is part of the sequence container requirements, while <code>emplace_back</code> is not. I checked the libc++ implementation of <code>vector</code>, <code>deque</code>, and <code>list</code>, and they all do the same thing for <code>emplace(end(), ...)</code> and <code>emplace_back(...)</code>.</p>

<p><i>[2019-02; Kona Wednesday night issue processing]</i></p>

<p>Status to Open; Casey to provide updated wording, and re-vote on reflector.</p>
<p>Polls were: NAD - 5-1-3; "Option B" - 2-5-2 and "Probe the container" - 7-2-0</p>


<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<blockquote class="note">
I have prepared two mutually exclusive options.
<br/>Option A a requirement for <code>emplace_back</code> to the underlying container.
<br/>Option B one replaces the calls to <code>emplace_back</code> with calls to <code>emplace</code>.
</blockquote>

<p><b>Option A</b></p>
<ol>
<li><p>Edit 23.6.6 <a href="https://timsong-cpp.github.io/cppwp/stack">[stack]</a>, as indicated:</p>
<p>Any sequence container supporting operations <code>back()</code>, <code>push_back()</code>,  <ins><code>emplace_back()</code></ins> and <code>pop_back()</code> can be used to instantiate <code>stack</code>. </p>
</li>

<li><p>Edit 23.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/queue.defn">[queue.defn]</a>, as indicated:</p>
<p>Any sequence container supporting operations <code>front()</code>, <code>back()</code>, <code>push_back()</code>,  <ins><code>emplace_back()</code></ins> and <code>pop_front()</code> can be used to instantiate <code>queue</code>. </p>
</li>
</ol>

<p><b>Option B</b></p>
<ol>
<li><p>Edit 23.6.6.2 <a href="https://timsong-cpp.github.io/cppwp/stack.defn">[stack.defn]</a>, class template <code>stack</code> definition, as indicated:</p>
<blockquote><pre>
template&lt;class... Args&gt;
  decltype(auto) emplace(Args&amp;&amp;... args)
    { return c.emplace<del>_back</del>(<ins>c.end(), </ins>std::forward&lt;Args&gt;(args)...); }
</pre></blockquote>
</li>

<li><p>Edit 23.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/queue.defn">[queue.defn]</a>, class template <code>queue</code> definition, as indicated:</p>
<blockquote><pre>
template&lt;class... Args&gt;
  decltype(auto) emplace(Args&amp;&amp;... args)
    { return c.emplace<del>_back</del>(<ins>c.end(), </ins>std::forward&lt;Args&gt;(args)...); }
</pre></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-05 Casey provides new wording]</i></p>

<p>
This is the "probe for <code>emplace_back</code> with fallback to <code>emplace</code>" approach that LWG
wanted to see wording for in Kona.
</p>

<p><i>[2020-05-09; Reflector prioritization]</i></p>

<p>
Set priority to 3 after reflector discussions.
</p>


<p id="res-3161"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li><p>Edit 23.6.6.2 <a href="https://timsong-cpp.github.io/cppwp/stack.defn">[stack.defn]</a>, class template <code>stack</code> definition, as indicated:</p>
<blockquote><pre>
template&lt;class... Args&gt;
  decltype(auto) emplace(Args&amp;&amp;... args) {
    <ins>if constexpr (requires { c.emplace_back(std::forward&lt;Args&gt;(args)...); }) {</ins>
      return c.emplace_back(std::forward&lt;Args&gt;(args)...);
    <ins>} else {</ins>
      <ins>return c.emplace(c.end(), std::forward&lt;Args&gt;(args)...);</ins>
    <ins>}</ins>
  }
</pre></blockquote>
</li>

<li><p>Edit 23.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/queue.defn">[queue.defn]</a>, class template <code>queue</code> definition, as indicated:</p>
<blockquote><pre>
template&lt;class... Args&gt;
  decltype(auto) emplace(Args&amp;&amp;... args) {
    <ins>if constexpr (requires { c.emplace_back(std::forward&lt;Args&gt;(args)...); }) {</ins>
      return c.emplace_back(std::forward&lt;Args&gt;(args)...);
    <ins>} else {</ins>
      <ins>return c.emplace(c.end(), std::forward&lt;Args&gt;(args)...);</ins>
    <ins>}</ins>
  }
</pre></blockquote>
</li>
</ol>






<hr>
<h3 id="3162"><a href="3162">3162</a>. <code>system_error::system_error(error_code ec)</code> not explicit</h3>
<p><b>Section:</b> 19.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.syserr.members">[syserr.syserr.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2018-10-02 <b>Last modified:</b> 2020-04-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#syserr.syserr.members">issues</a> in [syserr.syserr.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The constructor for <code>std::system_error</code> taking a single argument of type <code>std::error_code</code> is 
not marked explicit, which allows implicit conversions from <code>error_code</code> to <code>system_error</code>. I 
think that this is an oversight and not intentional, and that we should make this constructor explicit.
</p>

<p><i>[2020-04-07 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3162"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4762">N4762</a>.</p>

<ol>
<li><p>Change 19.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.syserr.overview">[syserr.syserr.overview]</a> p2, class <code>system_error</code> synopsis, as indicated</p>
<blockquote><pre>
namespace std {
  class system_error : public runtime_error {
  public:
    system_error(error_code ec, const string&amp; what_arg);
    system_error(error_code ec, const char* what_arg);
    <ins>explicit</ins> system_error(error_code ec);
    system_error(int ev, const error_category&amp; ecat, const string&amp; what_arg);
    system_error(int ev, const error_category&amp; ecat, const char* what_arg);
    system_error(int ev, const error_category&amp; ecat);
    const error_code&amp; code() const noexcept;
    const char* what() const noexcept override;
  };
}
</pre></blockquote>
</li>

<li><p>Change 19.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.syserr.members">[syserr.syserr.members]</a> as indicated</p>
<blockquote>
<pre>
<ins>explicit</ins> system_error(error_code ec);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> [&hellip;]
<p/>
-6- <i>Ensures:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3166"><a href="3166">3166</a>. No such descriptive element as <i>Value:</i></h3>
<p><b>Section:</b> 22.3.4 <a href="https://timsong-cpp.github.io/cppwp/pair.astuple">[pair.astuple]</a>, 22.6.4 <a href="https://timsong-cpp.github.io/cppwp/variant.helper">[variant.helper]</a>, 23.3.3.7 <a href="https://timsong-cpp.github.io/cppwp/array.tuple">[array.tuple]</a>, 20.2.3.2 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.types">[pointer.traits.types]</a>, 20.2.9.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.types">[allocator.traits.types]</a>, 20.6.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.types">[allocator.adaptor.types]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2018-11-08 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#pair.astuple">issues</a> in [pair.astuple].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="https://wg21.link/n4778">N4778</a>, 22.3.4 <a href="https://timsong-cpp.github.io/cppwp/pair.astuple">[pair.astuple]</a>, 22.6.4 <a href="https://timsong-cpp.github.io/cppwp/variant.helper">[variant.helper]</a>, 
and 23.3.3.7 <a href="https://timsong-cpp.github.io/cppwp/array.tuple">[array.tuple]</a>, are partly specified via a fictitious descriptive element <i>Value:</i>  Moreover, 
99 [span.tuple] is on track to do likewise in the near future.
<p/>
Let's invent such a <i>Value:</i> element and properly document it within 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>, 
or else let's respecify the offending uses.
</p>

<p><i>[2018-11 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>

<p><i>[2020-05-01; Daniel comments]</i></p>

<p>
It should be pointed out that the originally referred to <i>Value:</i> element has since
then be renamed to <i>Type:</i> but the reported problem (its lack of definition) still exists
in <a href="https://wg21.link/n4861">N4861</a>.
</p>


<p id="res-3166"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3167"><a href="3167">3167</a>. [fund.ts.v3] Does <code>observer_ptr</code> support function types?</h3>
<p><b>Section:</b> 8.2 [fund.ts.v3::memory.observer.ptr] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2018-11-14 <b>Last modified:</b> 2022-10-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
From the wording, function pointers are never clearly considered. P1 infers
support for only objects, but it is not clear that wording is intended to be a
deliberate restriction, or is casual wording.
<p/>
Paragraph 2 mandates that we cannot instantiate for reference types, and do
support incomplete types, but still does not consider function types. Calling
out references specifically, as they are not object types, suggests the inferred
support for only objects in p1 is more a case of casual phrasing, than deliberate
intent.
<p/>
However, if we did intend to support function pointers, we may want to consider
adding a function-call operator, constrained to supporting pointer-to function types.
One other possibility is that the explicit conversion to <code>pointer</code> already serves that
purpose, although I need to double-check the core language that contextual
conversions to function pointer are considered when invoking the function call
operator.  If this <em>is</em> the case, then I suggest a note to that effect in
[memory.observer.ptr.conv] instead.
</p>

<p><i>[2018-11 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>

<p><i>[2022-10-12 LWG telecon]</i></p>

<p>
Discussed on reflector in July 2022, no consensus on how <code>observer_ptr</code>
is even meant to be used.
</p>

<p>
<code>shared_ptr</code> supports function types, no good reason to disallow them here.
</p>

<p>
No desire to make any change for LFTSv3, but keep the issue open until/unless
the TS is withdrawn. That way we will be less likely to forget about this if
<code>observer_ptr</code> is propsed for the IS.
</p>



<p id="res-3167"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3172"><a href="3172">3172</a>. 3-arg <code>std::hypot</code> is underspecified compared to the 2-arg overload</h3>
<p><b>Section:</b> 29.7.3 <a href="https://timsong-cpp.github.io/cppwp/c.math.hypot3">[c.math.hypot3]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matthias Kretz <b>Opened:</b> 2018-12-06 <b>Last modified:</b> 2018-12-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 2-arg <code>hypot</code> function specified in the C standard is required to avoid overflow and underflow 
(7.12.7.3 p2). Furthermore C's Annex F (IEC 60559 floating-point arithmetic) defines special cases for 
inputs of <code>&plusmn;0</code> and <code>&plusmn;inf</code> (F. 10.4.3). The 3-arg <code>hypot</code> function 
29.7.3 <a href="https://timsong-cpp.github.io/cppwp/c.math.hypot3">[c.math.hypot3]</a> is only specified as "<i>Returns:</i> 
<math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo>
<msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup></msqrt></math>.". This is 
inconsistent with the 2-arg overload.
<p/>
It is not clear whether C's Annex F is "imported" into the C++ standard. [cmath.syn] p1 suggests that it 
is: "The contents and meaning of the header <code>&lt;cmath&gt;</code> are the same as the C standard library 
header <code>&lt;math.h&gt;</code>, [&hellip;]". 
</p>

<p><i>[2018-12-21 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p id="res-3172"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4778">N4778</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.]
</p>
</blockquote>

<p><b>Option A</b></p>

<ol>
<li><p>Modify 29.7.3 <a href="https://timsong-cpp.github.io/cppwp/c.math.hypot3">[c.math.hypot3]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
float hypot(float x, float y, float z);
double hypot(double x, double y, double z);
long double hypot(long double x, long double y, long double z);
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> The <code>hypot</code> functions compute the square root of the sum of the
squares of <code>x</code>, <code>y</code>, and <code>z</code>, without undue overflow or underflow. A range error
may occur.</ins>
<p/>
-1- <i>Returns:</i> <math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo>
<msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup></msqrt></math>.
<p/>
<ins>-?- <i>Remarks:</i> If <code>__STDC_IEC_559__</code> is defined, the following guarantees hold:</ins>
</p>
<ul>
<li><p><ins><code>hypot(x, y, z)</code>, <code>hypot(x, z, y)</code>, <code>hypot(z, y, x)</code>, and <code>hypot(x, y, -z)</code> 
are equivalent.</ins></p></li>
<li><p><ins>if <code>y<sup>2</sup> + z<sup>2</sup> == &plusmn;0</code>, <code>hypot(x, y, z)</code> is equivalent to <code>fabs(x)</code>.</ins></p></li>
<li><p><ins><code>hypot(&plusmn;&infin;, y, z)</code> returns <code>+&infin;</code>, even if <code>y</code> and/or <code>z</code> is a 
NaN.</ins></p></li>
</ul>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>

<p><b>Option B</b></p>

<ol>
<li><p>Add a note that clarifies that the behavior of the 3-arg <code>hypot</code> function
differs from the C specification. I.e. that no special guarantees wrt. over-/underflow or 
special values are given.</p>
</li>
</ol>





<hr>
<h3 id="3174"><a href="3174">3174</a>. Precondition on <code>is_convertible</code> is too strong</h3>
<p><b>Section:</b> 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2018-12-09 <b>Last modified:</b> 2019-03-16</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.rel">active issues</a> in [meta.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Per <a href="http://eel.is/c++draft/meta.rel#tab:type-traits.relationship">Table 49</a>
in 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a>, the preconditions for both
<code>is_convertible&lt;From, To&gt;</code> and
<code>is_nothrow_convertible&lt;From, To&gt;</code> are:
</p>
<blockquote>
<p>
<code>From</code> and <code>To</code> shall be complete types, arrays of unknown bound,
or <i>cv</i> <code>void</code> types.
</p>
</blockquote>
<p>
Consequently, this program fragment:
</p>
<blockquote>
<pre>
struct S;
static_assert(is_convertible_v&lt;S, const S&amp;&gt;);
</pre>
</blockquote>
<p>
has undefined behavior despite that the actual behavior of <code>is_convertible</code>
specified in <a href="https://wg21.link/meta.rel#5">[meta.rel]/5</a>:
</p>
<blockquote>
<p>
-5- The predicate condition for a template specialization
<code>is_convertible&lt;From, To&gt;</code> shall be satisfied if and only if the
return expression in the following code would be well-formed, including any
implicit conversions to the return type of the function:
</p>
<blockquote>
<pre>
To test() {
  return declval&lt;From&gt;();
}
</pre>
</blockquote>
<p>[ <i>Note:</i> &hellip;]</p>
</blockquote>
<p>
is well-formed: <code>declval&lt;S&gt;()</code> is an xvalue of type <code>S</code>,
which certainly does implicitly convert to <code>const S&amp;</code>. We should
relax the precondition to allow this perfectly valid case (and similar cases
like <code>is_convertible&lt;S, S&amp;&amp;&gt;</code>), letting the cases that
would in fact be invalid fall through to the blanket "incompletely-defined
object type" wording in
<a href="https://wg21.link/meta.rqmts#5">[meta.rqmts]/5</a>.
</p>

<p><i>[2018-12-21 Reflector prioritization]</i></p>

<p>Set Priority to 3</p>


<p id="res-3174"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4791">N4791</a>.</p>

<ol>
<li><p>Modify Table 49 in 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> as follows:</p>
<table border="1">
<caption>Table 49 &mdash; Type relationship predicates</caption>
<tr style="text-align:center">
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>
<tr>
<td>[&hellip;]</td>
<td>[&hellip;]</td>
<td>[&hellip;]</td>
</tr>
<tr>
<td>
<pre>
template&lt;class From, class To&gt;
struct is_convertible;
</pre>
</td>
<td><i>see below</i></td>
<td>
<del><code>From</code> and</del> <code>To</code> shall be <ins>a</ins><br/>
complete type<del>s</del>, <ins>an</ins><br/>
array<del>s</del> of unknown bound,<br/>
or <i>cv</i> <code>void</code> <del>types</del>.
</td>
</tr>
<tr>
<td>
<pre>
template&lt;class From, class To&gt;
struct is_nothrow_convertible;
</pre>
</td>
<td>
<code>is_convertible_v&lt;From, <br/>
To&gt;</code> is <code>true</code> and the<br/>
conversion, as defined by<br/>
<code>is_convertible</code>, is known<br/>
not to throw any<br/>
exceptions (7.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/expr.unary.noexcept">[expr.unary.noexcept]</a>)
</td>
<td>
<del><code>From</code> and</del> <code>To</code> shall be <ins>a</ins><br/>
complete type<del>s</del>, <ins>an</ins><br/>
array<del>s</del> of unknown bound,<br/>
or <i>cv</i> <code>void</code> <del>types</del>.
</td>
</tr>
<tr>
<td>[&hellip;]</td>
<td>[&hellip;]</td>
<td>[&hellip;]</td>
</tr>
</table>
</li>
</ol>





<hr>
<h3 id="3188"><a href="3188">3188</a>. <code>istreambuf_iterator::pointer</code> should not be <i>unspecified</i></h3>
<p><b>Section:</b> 24.6.4 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2019-02-21 <b>Last modified:</b> 2019-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#istreambuf.iterator">active issues</a> in [istreambuf.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current working paper requires <code>iterator_traits&lt;Iter&gt;::pointer</code> to be <code>void</code> if <code>Iter</code> 
doesn't define <code>operator-&gt;</code> (24.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a>). We recently removed <code>operator-&gt;</code> 
from <code>istreambuf_iterator</code> via LWG <a href="2790" title="Missing specification of istreambuf_iterator::operator-&gt; (Status: C++17)">2790</a>, therefore either its <code>pointer</code> member should be 
<code>void</code>, or there should be a partial specialization of <code>iterator_traits</code>. Do we want to change 
<i>unspecified</i> to <code>void</code> in the class synopsis in [istreambuf.iterator]?
</p>

<p><i>[2019-03-03, Daniel provides concrete wording]</i></p>


<p><i>[2019-03-05 Priority set to 3 after reflector discussion]</i></p>


<p><i>[2019-03-05, Daniel comments]</i></p>

<p>
With the acceptance of <a href="https://wg21.link/p1252r2">P1252R2</a> the committee decided to deprecate <code>operator-&gt;</code> 
of <code>move_iterator</code>, interestingly without mentioning what should happen with its current <code>pointer</code> typedef (which
is equal to the template parameter <code>Iterator</code> and thus never <code>void</code>). Effectively this is a very similar situation 
as for the here discussed <code>istreambuf_iterator</code> case and it seems attractive to me to solve both cases similarly. 
</p>

<p><i>[2019-10-30, Jonathan comments]</i></p>

<p>
Also, <code>reverse_iterator::operator-&gt;()</code> is now constrained and so not always defined, but 
<code>reverse_iterator::pointer</code> is defined unconditionally.
</p>


<p id="res-3188"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4800">N4800</a>.</p>

<ol>
<li><p>Change class template <code>istreambuf_iterator</code> synopsis, 24.6.4 <a href="https://timsong-cpp.github.io/cppwp/istreambuf.iterator">[istreambuf.iterator]</a>, as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
class istreambuf_iterator {
public:
  using iterator_category = input_iterator_tag;
  using value_type        = charT;
  using difference_type   = typename traits::off_type;
  using pointer           = <ins>void</ins><del><i>unspecified</i></del>;
  using reference         = charT;
  [&hellip;]
};
</pre>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3189"><a href="3189">3189</a>. Missing requirement for <code>std::priority_queue</code></h3>
<p><b>Section:</b> 23.6.4 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2019-02-21 <b>Last modified:</b> 2019-03-05</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#priority.queue">issues</a> in [priority.queue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We don't require that the <code>Compare</code> template parameter can be invoked with arguments of the queue's value type. 
It seems like something we can use <i>Mandates:</i> for, since it'll be ill-formed otherwise. Something like 
<code>is_invocable_r_v&lt;bool, Compare&amp;, value_type&amp;, value_type&amp;&gt;</code>.
<p/>
This might also apply to the <code>Compare</code> parameter for the <code>merge</code> and <code>sort</code> functions of 
<code>forward_list</code> and <code>list</code>.
</p>

<p><i>[2019-03-05 Priority set to 3 after reflector discussion]</i></p>



<p id="res-3189"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3192"><a href="3192">3192</a>. &sect;[allocator.uses.construction] functions misbehave for <code>const</code> types</h3>
<p><b>Section:</b> 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2019-02-28 <b>Last modified:</b> 2020-05-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.uses.construction">active issues</a> in [allocator.uses.construction].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.uses.construction">issues</a> in [allocator.uses.construction].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new functions added by <a href="https://wg21.link/p0591r4">P0591R4</a> misbehave for <i>cv</i>-qualified types. 
A specialization <code>std::uses_allocator&lt;X, Alloc&gt;</code> will not match <code>const X</code>, so 
<code>std::uses_allocator_construction_args&lt;const X&gt;</code> will return a different result from 
<code>std::uses_allocator_construction_args&lt;X&gt;</code>. It makes no sense to construct <code>X</code> and <code>const X</code> 
differently, either the type wants to use an allocator or it doesn't. I think 
<code>std::uses_allocator_construction_args&lt;T&gt;</code> should remove <i>cv</i>-qualifiers before checking 
<code>uses_allocator</code>, so that it works consistently. 
<p/>
We could consider changing <code>std::make_obj_using_allocator</code> to also strip <i>cv</i>-qualifiers, but it's not 
necessary as C++17 guaranteed elision works even for prvalues of <code>const</code> types. We only need to make the 
construction args ignore <i>cv</i>-qualifiers. We don't want to make <i>cv</i>-qualified types ill-formed, because 
that would require users of uses-allocator construction to strip <i>cv</i>-qualifiers before using these functions, 
e.g. in cases like <code>std::tuple&lt;const int&gt; t(allocator_arg, alloc, 1);</code>
</p>

<p><i>[2019-03-15 Priority set to 3 after reflector discussion]</i></p>


<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4800">N4800</a>.</p>

<ol>
<li><p>Change 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class Alloc, class... Args&gt;
  auto uses_allocator_construction_args(const Alloc&amp; alloc, Args&amp;&amp;... args) -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-4- <i>Constraints:</i> <code>T</code> is not a specialization of <code>pair</code>.
<p/>
-5- <i>Returns:</i> A <code>tuple</code> value determined as follows<ins>, where <code>U</code> denotes the type 
<code>remove_cv_t&lt;T&gt;</code></ins>:
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; If <code>uses_allocator_v&lt;<del>T</del><ins>U</ins>, Alloc&gt;</code> is <code>false</code> and 
<code>is_constructible_v&lt;T, Args...&gt;</code> is <code>true</code>, return 
<code>forward_as_tuple(std::forward&lt;Args&gt;(args)...)</code>.</p></li>
<li><p>(5.2) &mdash; Otherwise, if <code>uses_allocator_v&lt;<del>T</del><ins>U</ins>, Alloc&gt;</code> is <code>true</code> and 
<code>is_constructible_v&lt;T, allocator_arg_t, Alloc, Args...&gt;</code> is <code>true</code>, return</p>
<blockquote><pre>
tuple&lt;allocator_arg_t, const Alloc&amp;, Args&amp;&amp;...&gt;(
  allocator_arg, alloc, std::forward&lt;Args&gt;(args)...)
</pre></blockquote>
</li>
<li><p>(5.3) &mdash; Otherwise, if <code>uses_allocator_v&lt;<del>T</del><ins>U</ins>, Alloc&gt;</code> is <code>true</code> and 
<code>is_constructible_v&lt;T, Args..., Alloc&gt;</code> is <code>true</code>, return 
<code>forward_as_tuple(std::forward&lt;Args&gt;(args)..., alloc)</code>.</p></li>
<li><p>(5.4) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</p>
</blockquote>
[&hellip;]
<pre>
template &lt;class T, class Alloc, class Tuple1, class Tuple2&gt;
  auto uses_allocator_construction_args(const Alloc&amp; alloc, piecewise_construct_t,
                                        Tuple1&amp;&amp; x, Tuple2&amp;&amp; y) -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-6- <i>Constraints:</i> <code>T</code> is a specialization of <code>pair</code>.
<p/>
-7- <i>Effects:</i> For <code>T</code> specified as <ins>(possibly <code>const</code>)</ins> <code>pair&lt;T1, T2&gt;</code>, equivalent to:
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class T, class Alloc, class... Args&gt;
  T* uninitialized_construct_using_allocator(T* p, const Alloc&amp; alloc, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-17- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
return ::new(<del>static_cast&lt;void*&gt;</del><ins><i>voidify</i></ins>(<ins>*</ins>p))
  T(make_obj_using_allocator&lt;T&gt;(alloc, std::forward&lt;Args&gt;(args)...));
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-05-01; Daniel syncs wording with recent working draft]</i></p>

<p>
The previously needed change for <code>uninitialized_construct_using_allocator</code> is no longer
required, because the reworded call to <code>construct_at</code> does do the right thing now.
</p>


<p id="res-3192"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li><p>Change 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> as indicated:</p>

<blockquote>
<pre>
template &lt;class T, class Alloc, class... Args&gt;
  constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc, 
                                        Args&amp;&amp;... args) noexcept -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-4- <i>Constraints:</i> <code>T</code> is not a specialization of <code>pair</code>.
<p/>
-5- <i>Returns:</i> A <code>tuple</code> value determined as follows<ins>, where <code>U</code> denotes the type 
<code>remove_cv_t&lt;T&gt;</code></ins>:
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; If <code>uses_allocator_v&lt;<del>T</del><ins>U</ins>, Alloc&gt;</code> is <code>false</code> and 
<code>is_constructible_v&lt;T, Args...&gt;</code> is <code>true</code>, return 
<code>forward_as_tuple(std::forward&lt;Args&gt;(args)...)</code>.</p></li>
<li><p>(5.2) &mdash; Otherwise, if <code>uses_allocator_v&lt;<del>T</del><ins>U</ins>, Alloc&gt;</code> is <code>true</code> and 
<code>is_constructible_v&lt;T, allocator_arg_t, const Alloc&amp;, Args...&gt;</code> is <code>true</code>, return</p>
<blockquote><pre>
tuple&lt;allocator_arg_t, const Alloc&amp;, Args&amp;&amp;...&gt;(
  allocator_arg, alloc, std::forward&lt;Args&gt;(args)...)
</pre></blockquote>
</li>
<li><p>(5.3) &mdash; Otherwise, if <code>uses_allocator_v&lt;<del>T</del><ins>U</ins>, Alloc&gt;</code> is <code>true</code> and 
<code>is_constructible_v&lt;T, Args..., const Alloc&amp;&gt;</code> is <code>true</code>, return 
<code>forward_as_tuple(std::forward&lt;Args&gt;(args)..., alloc)</code>.</p></li>
<li><p>(5.4) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</p>
</blockquote>
[&hellip;]
<pre>
template &lt;class T, class Alloc, class Tuple1, class Tuple2&gt;
  constexpr auto uses_allocator_construction_args(const Alloc&amp; alloc, piecewise_construct_t,
                                        Tuple1&amp;&amp; x, Tuple2&amp;&amp; y) 
                                        noexcept -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-6- <i>Constraints:</i> <code>T</code> is a specialization of <code>pair</code>.
<p/>
-7- <i>Effects:</i> For <code>T</code> specified as <ins>(possibly <code>const</code>)</ins> <code>pair&lt;T1, T2&gt;</code>, equivalent to:
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3193"><a href="3193">3193</a>. <i>Mandates:</i> and <i>Expects:</i> elements are not defined for types</h3>
<p><b>Section:</b> 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2019-03-04 <b>Last modified:</b> 2020-06-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The working paper uses the special elements <i>Mandates:</i>, <i>Expects:</i> as well as
<i>Requires:</i> to types, albeit 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> defines them
only for functions, for example 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> sub-bullet (3.4):
</p>
<blockquote><p>
<i>Expects:</i> the conditions (sometimes termed preconditions) that the function assumes to hold whenever
it is called.
</p></blockquote>
<p>
Examples for such usages on types are (from <a href="https://wg21.link/n4800">N4800</a>):
</p>
<ul>
<li><p>27.2.3 <a href="https://timsong-cpp.github.io/cppwp/char.traits.typedefs">[char.traits.typedefs]</a> for types <code>int_type</code> and <code>state_type</code></p></li>
<li><p>22.3.4 <a href="https://timsong-cpp.github.io/cppwp/pair.astuple">[pair.astuple]</a> for <code>tuple_element&lt;I, pair&lt;T1, T2&gt;&gt;::type</code></p></li>
<li><p>22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a> for <code>tuple_element&lt;I, tuple&lt;Types...&gt;&gt;::type</code></p></li>
<li><p>22.4.11 <a href="https://timsong-cpp.github.io/cppwp/tuple.traits">[tuple.traits]</a> for <code>uses_allocator&lt;tuple&lt;Types...&gt;, Alloc&gt;</code></p></li>
<li><p>Table 62 &mdash; "Container requirements" for type <code>XX::value_type</code></p></li>
<li><p>Table 65 &mdash; "Allocator-aware container requirements" for type <code>allocator_type</code></p></li>
<li><p>Table 69 &mdash; "Associative container requirements" for types <code>X::value_type</code> and <code>X::key_compare</code></p></li>
<li><p>Table 70 &mdash; "Unordered associative container requirements" for types <code>X::value_type</code> and <code>X::key_equal</code></p></li>
</ul>
<p>
Instead of replacing these elements usages for these places by extra wording to reach the same effects I
recommend to update instead 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> to ensure that requirement-expressing elements
are defined in a way that it also allows to express requirements imposed on types by these elements to standardize
"existing practice".
<p/>
Considering details, it seems obvious that <i>Mandates:</i>, <i>Expects:</i> as well as <i>Requires:</i> are "suitable"
to be defined for types (With the acceptance of <a href="https://wg21.link/p1463r1">P1463R1</a> there are now also
<i>Mandates:</i> for types such as Table 65 &mdash; "Allocator-aware container requirements" for type <code>allocator_type</code>).
<p/>
For <i>Constraints:</i> the meaning would not be so clear: Should it mean that there is conditionally a type defined or not?
According to  the submitters knowledge there are currently no known examples for <i>Constraints:</i> to specify
constraint on types, therefore I'm suggesting to restrict this extension to <i>Mandates:</i>, <i>Expects:</i>,
and <i>Requires:</i> alone.
</p>

<p><i>[2019-03-15 Priority set to 3 after reflector discussion]</i></p>


<p><i>[2019-03-15; Daniel comments and provides wording]</i></p>

<p>
During the preparation of the wording for this issue it was found that we should allow
<i>Remarks:</i> elements to be used for other things than functions. One example of imposed
restrictions can be found in 17.12.3 <a href="https://timsong-cpp.github.io/cppwp/cmp.common">[cmp.common]</a>:
</p>
<blockquote>
<pre>
template&lt;class... Ts&gt;
struct common_comparison_category {
  using type = <i>see below</i>;
};
</pre>
<p>
-2- <i>Remarks:</i> The member <i>typedef-name</i> <code>type</code> denotes the common comparison type
(11.10.3 <a href="https://timsong-cpp.github.io/cppwp/class.spaceship">[class.spaceship]</a>) of <code>Ts...</code>, the expanded parameter pack. [&hellip;]
</p>
</blockquote>
<p>
The discussion of this issue speaks of "type" restrictions (versus the specified restrictions on
functions), because even the non-type template argument restrictions of 22.3.4 <a href="https://timsong-cpp.github.io/cppwp/pair.astuple">[pair.astuple]</a>
appear in the context of a member type specification, but there are examples where not really a
single (member) type is involved, e.g. in the 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a> example mentioned above.
<p/>
Another example is when such elements are used for the specification of template specializations, e.g.
in 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>:
</p>
<blockquote>
<pre>
template&lt;class T&gt; struct tuple_size;
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> All specializations of <code>tuple_size</code> shall satisfy the
<i>Cpp17UnaryTypeTrait</i> requirements (21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) with a base characteristic
of <code>integral_constant&lt;size_t, N&gt;</code> for some <code>N</code>.
</p>
</blockquote>
</blockquote>
<p>
Besides class template specializations, a second relevant use-case is the specification of member types
(Which are not necessarily part of a template), typically within the requirement tables, e.g. in
Table 62 &mdash; "Container requirements"'s entry <code>X::value_type</code>:
</p>
<blockquote>
<p>
<i>Requires:</i> <code>T</code> is <i>Cpp17Erasable</i> from <code>X</code>
</p>
</blockquote>
<p>
The suggested wording tries to cover the generalization by means of the term "non-function
entities" in addition to the existing functions to prevent being enforced to enumerate all entities
to which the extended rules apply.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Change 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>, as indicated:</p>

<blockquote>
<p>
-3- Descriptions of function semantics contain the following elements (as appropriate)<ins>; some
of these elements may also appear in the description of non-function entities as denoted
below</ins>: (footnote [&hellip;])
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; <i>Requires:</i> the preconditions <ins>imposed on a non-function entity,
or</ins> for calling the function.</p></li>
<li><p>(3.2) &mdash; <i>Constraints:</i> [&hellip;]</p></li>
<li><p>(3.3) &mdash; <i>Mandates:</i> the conditions that, if not met, render the program
ill-formed. [<i>Example:</i> An implementation might express such a condition
via the <i>constant-expression</i> in a <i>static_assert-declaration</i> (Clause 9).
If the diagnostic is to be emitted only after the function has been selected by overload resolution, an
implementation might express such a condition via a <i>constraint-expression</i>
(13.5.3 <a href="https://timsong-cpp.github.io/cppwp/temp.constr.decl">[temp.constr.decl]</a>) and also define the function as deleted. &mdash; <i>end example</i>]</p></li>
<li><p>(3.4) &mdash; <i>Expects:</i> the conditions (sometimes termed preconditions) <ins>imposed
on a non-function entity, or</ins> that the function assumes to hold whenever
it is called. [<i>Example:</i> An implementation might express such conditions via an attribute such
as <code>[[expects]]</code> ( [dcl.attr.contract]) <ins>on a function declaration</ins>.
However, some such conditions might not lend themselves to expression via code. &mdash;
<i>end example</i>]</p></li> <li><p>[&hellip;]</p></li>
<li><p>(3.11) &mdash; <i>Remarks:</i> additional semantic constraints <del>on the function</del>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</p>
</blockquote>
</li>

<li><p>Change 99 [res.on.required], as indicated:</p>

<blockquote>
<p>
-1- Violation of any preconditions specified in a <del>function's</del> <i>Requires:</i> element
results in undefined behavior unless the function's <i>Throws:</i> element specifies
throwing an exception when <del>the</del><ins>a function's</ins> precondition is violated.
<p/>
-2- Violation of any preconditions specified in a<ins>n</ins> <del>function's</del> <i>Expects:</i>
element results in undefined behavior.
</p>
</blockquote>
</li>
</ol></blockquote>

<p><i>[2020-05-01; Daniel comments and adjusts wording to recent working draft]</i></p>

<p>
It should be pointed out that the originally referred to <i>Expects:</i> element has since
then be renamed to <i>Preconditions:</i> and that the <i>Requires:</i> element does now
only occur in annex D.
</p>

<p><i>[2020-06-11; Jonathan comments]</i></p>

<p>
This issue also affects some type traits such as <code>alignment_of</code>
and <code>make_signed</code>/<code>make_unsigned</code>.
In addition to clarifying what <i>Mandates:</i> means on a non-function
we need to decide exactly what is being mandated in the type traits.
Is instantiating the class template ill-formed,
or just odr-using the nested <code>type</code> or <code>value</code> member?
</p>


<p id="res-3193"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li><p>Change 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>, as indicated:</p>

<blockquote>
<p>
-3- Descriptions of function semantics contain the following elements (as appropriate)<ins>; some
of these elements may also appear in the description of non-function entities as denoted
below</ins>: (footnote [&hellip;])
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; <i>Constraints:</i> [&hellip;]</p></li>
<li><p>(3.2) &mdash; <i>Mandates:</i> the conditions that, if not met, render the program
ill-formed. [<i>Example:</i> An implementation might express such a condition
via the <i>constant-expression</i> in a <i>static_assert-declaration</i> (9.1 <a href="https://timsong-cpp.github.io/cppwp/dcl.pre">[dcl.pre]</a>).
If the diagnostic is to be emitted only after the function has been selected by overload resolution, an
implementation might express such a condition via a <i>constraint-expression</i>
(13.5.3 <a href="https://timsong-cpp.github.io/cppwp/temp.constr.decl">[temp.constr.decl]</a>) and also define the function as deleted. &mdash; <i>end example</i>]</p></li>
<li><p>(3.3) &mdash; <i>Preconditions:</i> the conditions <ins>imposed
on a non-function entity, or</ins> that the function assumes to hold whenever
it is called.</p></li> <li><p>[&hellip;]</p></li>
<li><p>(3.10) &mdash; <i>Remarks:</i> additional semantic constraints <del>on the function</del>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</p>
</blockquote>
</li>

<li><p>Change  [res.on.expects], as indicated:</p>

<blockquote>
<p>
-1- Violation of any preconditions specified in a <del>function's</del> <i>Preconditions:</i>
element results in undefined behavior.
</p>
</blockquote>
</li>

<li><p>Change  [depr.res.on.required], as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Interestingly, albey the <i>Requires:</i> element has nearly vanished, the
issue is still relevant, see D.13 <a href="https://timsong-cpp.github.io/cppwp/depr.meta.types">[depr.meta.types]</a>]
</p>
</blockquote>

<blockquote>
<p>
-1- Violation of any preconditions specified in a <del>function's</del> <i>Requires:</i> element
results in undefined behavior unless the function's <i>Throws:</i> element specifies
throwing an exception when <del>the</del><ins>a function's</ins> precondition is violated.
</p>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3197"><a href="3197">3197</a>. <code>std::prev</code> should not require <code>BidirectionalIterator</code></h3>
<p><b>Section:</b> 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2019-04-03 <b>Last modified:</b> 2024-06-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
MSVC++ (and apparently libc++) have asserts that <code>std::prev</code> only accepts <code>BidirectionalIterator</code>s, 
because it's declared in the standard as accepting only <code>BidirectionalIterator</code>. libc++ changed their tests 
(in <a href="https://github.com/llvm/llvm-project/commit/f51ee632475654a396f93da9d36841989e1c7742">this commit</a>), 
apparently from a bug report from Ville and Jonathan, saying that one could theoretically call <code>std::prev</code> 
with a negative number.
<p/>
The standardese in [iterator.operations] strongly indicates that <code>prev</code> requires a <code>BidirectionalIterator</code>, 
but I don't see the usual wording that connects template type parameters of that name to the <code>&lt;algorithm&gt;</code> 
requirements or similar. So perhaps one could argue that the name <code>Bidirectional</code> there has no meaning. Even 
if that is the case, that's a defect in the other direction.
</p>

<p><i>[2019-06-12 Priority set to 3 after reflector discussion]</i></p>


<p><i>[2022-04-22; Jonathan adds a comment]</i></p>

<p>
<a href="https://wg21.link/p2408">P2408</a> changes the requirements for
types substituting <code>BidirectionalIterator</code> etc. in the Algorithms clause.
We should consider whether that is appropriate here, especially as algorithms
might make use of <code>std::prev</code> internally.
An algorithm that was changed by P2408 to accept types that model
<code>bidirectional_iterator</code> instead of requiring
<code><i>Cpp17BidirectionalIterator</i></code> might have to stop using
<code>std::prev</code> if we don't resolve this issue to allow it.
</p>
<p>
We should consider whether <code>distance</code>, <code>advance</code> and <code>next</code>
need the same treatment.
</p>

<p><i>[2024-06-18; Jonathan adds a comment]</i></p>

<p>
Related to LWG <a href="2353" title="std::next is over-constrained (Status: C++17)">2353</a> which made a similar change to <code class='backtick'>std::next</code>.
Also, if we require a <i>Cpp17BidirectionalIterator</i> here, then that means
you can't use <code class='backtick'>std::prev</code> on a <code class='backtick'>std::bidirectional_iterator</code> unless it also
meets the <i>Cpp17BidirectionalIterator</i> requirements. That seems like an
unnecessary restriction, since <code class='backtick'>std::prev</code> doesn't do anything that wouldn't
work fine with any type that models <code class='backtick'>std::bidirectional_iterator</code>.
</p>



<p id="res-3197"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Three mutually exclusive options are prepared, depicted below by <b>Option A</b>, 
<b>Option B</b>, and <b>Option C</b>, respectively.]
</p>
</blockquote>

<p><b>Option A</b></p>

<ol>
<li><p>NAD, the name <code>BidirectionalIterator</code> actually means that <code>prev</code> requires bidirectional iterators, in which 
case this change to libcxx is incorrect.</p>
</li>
</ol>

<p><b>Option B</b></p>

<ol>
<li><p>Modify 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header <code>&lt;iterator&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
<i>// 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a>, iterator operations</i>
[&hellip;]
template&lt;class <del>Bidirectional</del><ins>Input</ins>Iterator&gt;
  constexpr <del>Bidirectional</del><ins>Input</ins>Iterator prev(<del>Bidirectional</del><ins>Input</ins>Iterator x,
    typename iterator_traits&lt;<del>Bidirectional</del><ins>Input</ins>Iterator&gt;::difference_type n = 1);
</pre>
</blockquote>
</li>

<li><p>Modify 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> as indicated:</p>

<blockquote><pre>
template&lt;class <del>Bidirectional</del><ins>Input</ins>Iterator&gt;
  constexpr <del>Bidirectional</del><ins>Input</ins>Iterator prev(<del>Bidirectional</del><ins>Input</ins>Iterator x,
    typename iterator_traits&lt;<del>Bidirectional</del><ins>Input</ins>Iterator&gt;::difference_type n = 1);
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Equivalent to: <code>advance(x, -n); return x;</code>
</p>
</blockquote>
</blockquote>
</li>
</ol>

<p><b>Option C</b></p>

<ol>
<li><p>The intent of the wording is that the template parameters apply requirements, and the defect is that they do not. 
We should add a requirement in 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a>/1 to the effect that the template parameter names 
impose said requirements.</p>
</li>
</ol>





<hr>
<h3 id="3205"><a href="3205">3205</a>. <code>decay_t</code> in the new <code>common_type</code> fallback should be <code>remove_cvref_t</code></h3>
<p><b>Section:</b> 21.3.9.7 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2019-05-12 <b>Last modified:</b> 2022-04-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/p0898r4">P0898R4</a> "The One Ranges Proposal" added a new fallback case to 
the definition of <code>common_type</code> in 21.3.9.7 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a>, bullet 3.3.4:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Otherwise, if <code><i>COND_RES</i>(<i>CREF</i>(D1), <i>CREF</i>(D2))</code> denotes a type, let <code>C</code> 
denote the type <code>decay_t&lt;<i>COND_RES</i>(<i>CREF</i>(D1), <i>CREF</i>(D2))&gt;</code>.
</p>
</blockquote>
<p>
Per para 3.3, <code>D1</code> and <code>D2</code> are decayed types. If both are <code>void</code>, bullet 3.3.4 
is not reached. If either is an abominable function type or <code>void</code>, the <code><i>COND_RES</i></code> 
type expression above is ill-formed and bullet 3.3.4 does not apply. In all cases in which the 
<code><i>COND_RES</i></code> expression is well-formed, <code>D1</code> and <code>D2</code> denote <i>cv</i>-unqualified 
non-array object types. Given that fact, (1) <code><i>CREF</i>(D1)</code> and <code><i>CREF</i>(D2)</code> 
are equivalent to <code>const D1&amp;</code> and <code>const D2&amp;</code>, respectively, and (2) the 
<code><i>COND_RES</i></code> expression is equivalent to <code>decltype(false ? 
declval&lt;const D1&amp;&gt;() : declval&lt;const D1&amp;&gt;())</code>, i.e., the second and third 
operands of the conditional operator are lvalues of type <code>const D1</code> and <code>const D2</code>, respectively.
<p/>
[expr.cond]/3 cannot apply since the operands are not glvalue bit-fields.
<p/>
If <code>D1</code> and <code>D2</code> are the same type, [expr.cond]/4 does not apply. If <code>D1</code> and 
<code>D2</code> are different types, there are a few cases to consider:
</p>
<ol>
<li><p>If [expr.cond]/4.1 applies, one operand is converted into an lvalue reference to the type of the other, 
i.e., both resulting operands are lvalues of type either <code>const D1</code> or <code>const D2</code>.</p></li>
<li><p>[expr.cond]/4.2 cannot apply since neither operand is an xvalue.</p></li>
<li><p>[expr.cond]/4.3.1 cannot apply since it would imply that the operands have the same type.</p></li>
<li><p>If [expr.cond]/4.3.2 applies &mdash; if either <code>D1</code> or <code>D2</code> is a base class of the 
other &mdash; again the resulting operands are lvalues of type either <code>const D1</code> or <code>const D2</code>.</p></li>
<li><p>If [expr.cond]/4.3.3 applies, the either the <code>const D1&amp;</code> operand converts to 
<code>const D2</code> or the <code>const D2&amp;</code> operand converts to <code>const D1</code>.</p></li>
<li><p>If none of the sub-bullets in [expr.cond]/4 applies, the operands are left unchanged.</p></li>
</ol>
<p>
[expr.cond]/5 applies if the operands initially had the same type, or in cases 1 and 4 above. The 
conditional expression is an lvalue of type <code>const D1</code> or <code>const D2</code>, and the 
<code><i>COND_RES</i></code> expression yields <code>const D1&amp;</code> or <code>const D2&amp;</code>.
<p/>
Only cases 5 and 6 reach [expr.cond]/6. This paragraph performs overload resolution, which may result 
in converting both operands to the same non-class type to invoke a builtin conditional operator "overload". 
<p/>
[expr.cond]/7 applies standard conversions including array-to-pointer and function-to-pointer conversion to the operands. Consequently, the operands are once more "decayed" if [expr.cond]/6 converted them to an array or function type. Again case-by-case:
</p>
<ol>
<li><p>[expr.cond]/7.1 applies if the operands now have the same type, which is the type of the conditional 
expression.</p></li>
<li><p>[expr.cond]/7.2 applies if the operands have arithmetic or enumeration type; the conditional expression yields the result of applying the usual arithmetic conversions.</p></li>
<li><p>[expr.cond]/7.3 applies if the operands have pointer type; the conditional expression yields their composite pointer type.</p></li>
<li><p>[expr.cond]/7.4 applies if the operands have pointer-to-member type; the conditional expression applies some more standard conversions and yields their composite pointer type.</p></li>
<li><p>[expr.cond]/7.5 applies if one operand has type <code>nullptr_t</code> and the other is either a null 
pointer constant or has type <code>nullptr_t</code>; the conditional expression yields <code>nullptr_t</code>.</p></li>
</ol>
<p>
In every case above, the conditional expression is either ill-formed, an lvalue of type <code>const D1</code> or 
<code>const D2</code>, or a prvalue of a non-array non-function type. Consequently the <code><i>COND_RES</i></code> 
type expression always yields a non-array non-function type, for which <code>decay_t</code> and <code>remove_cvref_t</code> 
are equivalent. We can therefore replace <code><i>COND_RES</i>(<i>CREF</i>(D1), <i>CREF</i>(D2))</code> in
[meta.trans.other]/3.3.4 with <code>decltype(false ? declval&lt;const D1&amp;&gt;() : 
declval&lt;const D2&amp;&gt;())</code>, and replace the usage of <code>decay_t</code> with <code>remove_cvref_t</code>.
<p/>
Furthermore, there are now quite a few different cases describing the behavior of <code>common_type</code>. 
It's not clear that <code>common_type&lt;T...&gt;::type</code> is always a decayed type without in-depth analysis. 
We should non-normatively clarify that fact.
</p>

<p><i>[2019-06-12 Priority set to 3 after reflector discussion]</i></p>


<p><i>[2020-05-01; Daniel adjusts wording to recent working draft]</i></p>


<p><i>[2022-04-25; Daniel adjusts wording to recent working draft]</i></p>



<p id="res-3205"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 21.3.9.7 <a href="https://timsong-cpp.github.io/cppwp/meta.trans.other">[meta.trans.other]</a> as indicated:</p>

<blockquote>
<p>
-2- Let:
</p>
<ol style="list-style-type: none">
<li><p><del>(2.1) &mdash; <code><i>CREF</i>(A)</code> be 
<code>add_lvalue_reference_t&lt;const remove_reference_t&lt;A&gt;&gt;</code>,</del></p></li>
<li><p>(2.2) &mdash; [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(2.9) &mdash; [&hellip;]</p></li>
</ol>
<p>
If any of the types computed above is ill-formed, then <code><i>COMMON-REF</i>(A, B)</code> is ill-formed.
<p/>
-3- Note A: For the <code>common_type</code> trait applied to a template parameter pack <code>T</code> of types, the member 
<code>type</code> shall be either defined or not present as follows:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; [&hellip;]</p></li>
<li><p>(3.2) &mdash; [&hellip;]</p></li>
<li><p>(3.3) &mdash; If <code>sizeof...(T)</code> is two, let the first and second types constituting <code>T</code> 
be denoted by <code>T1</code> and <code>T2</code>, respectively, and let <code>D1</code> and <code>D2</code> denote the 
same types as <code>decay_t&lt;T1&gt;</code> and <code>decay_t&lt;T2&gt;</code>, respectively.</p>
<ol style="list-style-type: none">
<li><p>(3.3.1) &mdash; [&hellip;]</p></li>
<li><p>(3.3.2) &mdash; [&hellip;]</p></li>
<li><p>(3.3.3) &mdash; Otherwise, if</p>
<blockquote><pre>
decay_t&lt;decltype(false ? declval&lt;D1&gt;() : declval&lt;D2&gt;())&gt;
</pre></blockquote>
<p>
denotes a valid type, let <code>C</code> denote that type.
</p>
</li>
<li><p>(3.3.4) &mdash; Otherwise, if <del><code><i>COND-RES</i>(<i>CREF</i>(D1), <i>CREF</i>(D2))</code></del></p>
<blockquote><pre>
<ins>remove_cvref_t&lt;decltype(false ? declval&lt;const D1&amp;&gt;() : declval&lt;const D2&amp;&gt;())&gt;</ins>
</pre></blockquote>
<p> 
denotes a type, let <code>C</code> denote th<del>e</del><ins>at</ins> type 
<del><code>decay_t&lt;<i>COND-RES</i>(<i>CREF</i>(D1), <i>CREF</i>(D2))&gt;</code></del>.</p></li>
</ol>
</li>
<li><p>(3.4) &mdash; [&hellip;]</p></li>
</ol>
<p>
<ins>[<i>Note:</i> Whenever the <i>qualified-id</i> <code>common_type&lt;T...&gt;::type</code> is valid, 
it denotes the same type as <code>decay_t&lt;common_type&lt;T...&gt;::type&gt;</code>. &mdash; <i>end note</i>]</ins>
<p/>
-4- Note B: [&hellip;]
</p>
</blockquote>
</li>

</ol>




<hr>
<h3 id="3210"><a href="3210">3210</a>. <code>allocate_shared</code> is inconsistent about removing <code>const</code> from the pointer
passed to allocator <code>construct</code> and <code>destroy</code></h3>
<p><b>Section:</b> 20.3.2.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2019-05-29 <b>Last modified:</b> 2024-10-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I implemented the fix for LWG <a href="3008" title="make_shared (sub)object destruction semantics are not specified (Status: C++20)">3008</a> and Stephan pointed out there's an inconsistency here
for <code>allocate_shared&lt;const T&gt;</code>.
<p/>
20.3.2.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> p3 says that the allocator construct call is done without removing
<i>cv</i> qualifiers, but 20.3.2.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> p7.12 says that the <code>destroy</code>
call is done with removed <i>cv</i> qualifiers.
<p/>
The fallback for <code>allocator_traits::construct</code> rejects <code>const T*</code> (since it <code>static_casts</code>
to <code>void*</code>), so the most likely outcome of attempting to do this today is to fail to compile, which
is a break with C++17.
<p/>
Our options are:
</p>
<ol>
<li><p>Fix the allocator model to deal with <code>const</code> elements somehow, which breaks compatibility
with existing allocators unprepared for <code>const</code> elements here. We would need to extend the allocator
requirements to allow <code>const T*</code> to be passed here, and fix our default to <code>const_cast</code>.</p></li>
<li><p>Fix <code>allocate_shared</code> to remove <code>const</code> before calling <code>construct</code>, which
changes the experience for C++17 customers because <code>allocate_shared</code> constructs a <code>T</code>
instead of a <code>const T</code>, but not in a way substantially different to edits
<a href="https://wg21.link/p0674">P0674</a> already made here.</p></li>
<li><p>Back out <code>allocate_shared</code>'s interaction with this part of the allocator model (reverting
this part of <a href="https://wg21.link/p0674">P0674</a> and reopening LWG <a href="3008" title="make_shared (sub)object destruction semantics are not specified (Status: C++20)">3008</a>).</p></li>
<li><p>Go around the problem by prohibiting <code>allocate_shared&lt;const T&gt;</code>, which breaks
existing C++17 customers.</p></li>
</ol>
<p>
Billy O'Neal argues that only (2) preserves the design intent <a href="https://wg21.link/p0674">P0674</a>
while maintaining compatibility for most allocators and most C++17 customers.
<p/>
Peter Dimov argues that (1) isn't likely to break enough to matter.
</p>

<p><i>[2019-06-16 Priority set to 3 based on reflector discussion]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>This wording is relative to <a href="https://wg21.link/N4810" title=" Working Draft, Standard for Programming Language C++">N4810</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> As the issue submitter prefers option (2), this is wording for that.]
</p>
</blockquote>

<ol>
<li><p>Modify 20.3.2.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, ...&gt;
  shared_ptr&lt;T&gt; make_shared(<i>args</i>);
template&lt;class T, class A, ...&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, <i>args</i>);
template&lt;class T, ...&gt;
  shared_ptr&lt;T&gt; make_shared_default_init(<i>args</i>);
template&lt;class T, class A, ...&gt;
  shared_ptr&lt;T&gt; allocate_shared_default_init(const A&amp; a, <i>args</i>);
</pre>
<blockquote>
<p>
-2- <i>Requires:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-7- <i>Remarks:</i>
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(7.5) &mdash; When a (sub)object of a non-array type <code>U</code> is specified to have an initial
value of <code>v</code>, or <code>U(l...)</code>, where <code>l...</code> is a list of constructor arguments,
<code>allocate_shared</code> shall initialize this (sub)object via the expression
</p>
<ol style="list-style-type: none">
<li><p>(7.5.1) &mdash; <code>allocator_traits&lt;A2&gt;::construct(a2, pv, v)</code> or</p></li>
<li><p>(7.5.2) &mdash; <code>allocator_traits&lt;A2&gt;::construct(a2, pv, l...)</code></p></li>
</ol>
<p>
respectively, where <code>pv</code> points to storage suitable to hold an object of type
<code><ins>remove_cv_t&lt;</ins>U<ins>&gt;</ins></code> and <code>a2</code> of type <code>A2</code> is a
rebound copy of the allocator <code>a</code> passed to <code>allocate_shared</code> such that its <code>value_type</code>
is <code>remove_cv_t&lt;U&gt;</code>.
</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2024-04-13; Jiang An comments and provides improved wording]</i></p>

<p>
The currently proposed resolution is meaningless, because "(allocated) storage suitable to hold an object of type
<code>remove_cv_t&lt;U&gt;</code>" is always "storage suitable to hold an object of type <code>U</code>", and vice versa.
Also, the current specification doesn't seem to specify the type of <code>pv</code> in the cases of <code>allocator_shared</code>,
because <code>pv</code> is merely specified to point some storage instead of an object.
</p>

<p><i>[2024-10-02; will be resolved by issue <a href="3216" title="Rebinding the allocator before calling construct/destroy in allocate_shared (Status: WP)">3216</a>.]</i></p>



<p id="res-3210"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 20.3.2.2.7 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.create">[util.smartptr.shared.create]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> As the issue submitter prefers option (2), this is wording for that.]
</p>
</blockquote>

<blockquote>
<pre>
template&amp;lt;class T, ...>
  shared_ptr&amp;lt;T&amp;gt; make_shared(<i>args</i>);
template&amp;lt;class T, class A, ...>
  shared_ptr&amp;lt;T&amp;gt; allocate_shared(const A&amp; a, <i>args</i>);
template&amp;lt;class T, ...>
  shared_ptr&amp;lt;T&amp;gt; make_shared_for_overwrite(<i>args</i>);
template&amp;lt;class T, class A, ...>
  shared_ptr&amp;lt;T&amp;gt; allocate_shared_for_overwrite(const A&amp; a, <i>args</i>);
</pre>
<blockquote>
<p>
-2- <i>Preconditions:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-7- <i>Remarks:</i>
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(7.5) &mdash; When a (sub)object of a non-array type <code>U</code> is specified to have an initial
value of <code>v</code>, or <code>U(l...)</code>, where <code>l...</code> is a list of constructor arguments,
<code>allocate_shared</code> shall initialize this (sub)object via the expression
</p>
<ol style="list-style-type: none">
<li><p>(7.5.1) &mdash; <code>allocator_traits&lt;A2&gt;::construct(a2, pv, v)</code> or</p></li>
<li><p>(7.5.2) &mdash; <code>allocator_traits&lt;A2&gt;::construct(a2, pv, l...)</code></p></li>
</ol>
<p>
respectively, where <code>pv</code> <ins>has type <code>remove_cv_t&lt;U&gt;*</code> and</ins> points to storage
suitable to hold an object of type <code>U</code> and <code>a2</code> of type <code>A2</code> is a rebound copy of
the allocator a passed to <code>allocate_shared</code> such that its <code>value_type</code> is
<code>remove_cv_t&lt;U&gt;</code>.
</p>
</li>
<li><p>(7.6) &mdash; [&hellip;]</p></li>
<li><p>(7.7) &mdash; When a (sub)object of non-array type <code>U</code> is specified to have a default
initial value, <code>allocate_shared</code> shall initialize this (sub)object via the expression
<code>allocator_traits&lt;A2&gt;::construct(a2, pv)</code>, where <code>pv</code> <ins>has type <code>remove_cv_t&lt;U&gt;*</code>
and</ins> points to storage suitable to hold an object of type <code>U</code> and <code>a2</code> of type <code>A2</code>
is a rebound copy of the allocator a passed to <code>allocate_shared</code> such that its <code>value_type</code>
is <code>remove_cv_t&lt;U&gt;</code>.
</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3214"><a href="3214">3214</a>. &sect;[facet.num.get.virtuals] doesn't say what it means for digit grouping to be consistent</h3>
<p><b>Section:</b> 28.3.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2019-06-03 <b>Last modified:</b> 2019-08-23</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.3.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> paragraph 4 says:
</p>
<blockquote><p>
"Digit grouping is checked. That is, the positions of discarded separators is examined for consistency with
<code>use_facet&lt;numpunct&lt;charT&gt;&gt;(loc).grouping()</code>. If they are not consistent then
<code>ios_base::failbit</code> is assigned to <code>err</code>."
</p></blockquote>
<p>
It's unclear what is considered consistent or not.
<p/>
Obviously if the expected grouping is "1,234,567" then an input of "1,234,567" is consistent. Libstdc++,
MSVC and Boost all consider "1234567" to be consistent with an expected grouping "1,234,567" (and it
looks like libc++ is going to agree soon). That can be justified by saying that there are no discarded
separators to examine, so no inconsistency. But what about "1234,567"? There is only one discarded
separator here, and its position is consistent with the expected format.
<p/>
The wording should clarify that if there are no separators at all, that is OK. If there are one or more
separators then they must be at the expected positions, and there must not be any missing.
</p>

<p><i>[2019-07 Issue Prioritization]</i></p>

<p>Priority to 4 after discussion on the reflector.</p>


<p id="res-3214"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3215"><a href="3215">3215</a>. <code>variant</code> default constructor has vague <code>constexpr</code> requirements</h3>
<p><b>Section:</b> 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Louis Dionne <b>Opened:</b> 2019-06-04 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.ctor">active issues</a> in [variant.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.ctor">issues</a> in [variant.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> p5, we say:
</p>
<blockquote><p>
<i>Remarks:</i> This function shall be <code>constexpr</code> if and only if the value-initialization of
the alternative type <code>T<sub>0</sub></code> would satisfy the requirements for a constexpr function.
[&hellip;]
</p></blockquote>
<p>
First of all, I find it confusing that we say "This function shall be <code>constexpr</code> if [&hellip;]",
when the declaration of the function clearly has the <code>constexpr</code> keyword on it
unconditionally. Instead, I would use the wording "This function shall be usable in a constexpr context
if [&hellip;]".
<p/>
Secondly, I think we shouldn't be using if-and-only-if since it restricts whether implementations can be
<code>constexpr</code>-friendly as an extension. Instead, it seems better to just say "if".
<p/>
Finally, I think the condition under which the function must be <code>constexpr</code>-friendly is not
something we can test for because it says "value-initialization of the alternative type
<code>T<sub>0</sub></code> would satisfy the requirements for a constexpr function", which doesn't imply
the value initialization can actually be be performed inside a constexpr context (for example the
default constructor could be <code>constexpr</code> friendly <em>but</em> not marked with the
<code>constexpr</code> keyword).
</p>

<p><i>[2017-06-17, Tim Song comments]</i></p>

<p>This issue is related to LWG <a href="2833" title="Library needs to specify what it means when it declares a function constexpr (Status: Open)">2833</a>.</p>

<p><i>[2019-07 Issue Prioritization]</i></p>

<p>Priority to 2 after discussion on the reflector.</p>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a> as indicated:</p>

<blockquote>
<pre>
constexpr variant() noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> [&hellip;]
<p/>
-3- <i>Ensures:</i> [&hellip;]
<p/>
-4- <i>Throws:</i> [&hellip;]
<p/>
-5- <i>Remarks:</i> This function shall be <ins>usable in a context that requires constant
evaluation if the alternative type <code>T<sub>0</sub></code> can be value-initialized in a context
that requires constant evaluation</ins><del><code>constexpr</code> if and only if the
value-initialization of the alternative type <code>T<sub>0</sub></code> would satisfy the requirements
for a constexpr function</del>. [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-06-08 Nina Dinka Ranns comments]</i></p>

<p>
The revised wording provided by LWG <a href="2833" title="Library needs to specify what it means when it declares a function constexpr (Status: Open)">2833</a> should resolve this issue as well.
</p>


<p id="res-3215"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3217"><a href="3217">3217</a>. <code>&lt;memory&gt;</code> and <code>&lt;execution&gt;</code> should define <code>__cpp_lib_parallel_algorithm</code></h3>
<p><b>Section:</b> 17.3.1 <a href="https://timsong-cpp.github.io/cppwp/support.limits.general">[support.limits.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2019-06-12 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.limits.general">issues</a> in [support.limits.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are parallel overloads of algorithms in <code>&lt;memory&gt;</code>, so it should define the macro.
Also, <code>&lt;execution&gt;</code> defines the exec policies for use with the algos, so that should
define the macro too.
</p>

<p><i>[2019-07 Issue Prioritization]</i></p>

<p>Priority to 3 after discussion on the reflector.</p>


<p id="res-3217"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 17.3.1 <a href="https://timsong-cpp.github.io/cppwp/support.limits.general">[support.limits.general]</a>, Table 36 &mdash; "Standard library feature-test
macros", as indicated:</p>

<blockquote>

<table border="1">
<caption>Table 36 &mdash; Standard library feature-test macros</caption>
<tr style="text-align:center">
<th>Macro name</th>
<th>Value</th>
<th>Header(s)</th>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td><code>__cpp_lib_parallel_algorithm</code></td>
<td><code>201603L</code></td>
<td><code>&lt;algorithm&gt; <ins>&lt;execution&gt; &lt;memory&gt;</ins> &lt;numeric&gt;</code></td>
</tr>
<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>

</blockquote>
</li>
</ol>




<hr>
<h3 id="3219"><a href="3219">3219</a>. <code>std::array</code> overview container requirements are incorrect</h3>
<p><b>Section:</b> 23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a>, 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nevin Liber &amp; Christian Trott <b>Opened:</b> 2019-06-13 <b>Last modified:</b> 2022-04-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array.overview">active issues</a> in [array.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#array.overview">issues</a> in [array.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements specified in 23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> p3 are incorrect; namely:
</p>
<ul>
<li><p>A default constructed <code>array&lt;T, N&gt;</code> where <code>0 &lt; N</code> has linear,
not constant complexity.</p></li>
<li><p>A default constructed <code>array&lt;T, 0&gt;</code> is empty and has constant complexity.</p></li>
</ul>

<p><i>[2019-07 Issue Prioritization]</i></p>

<p>Priority to 3 after discussion on the reflector.</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/N4810" title=" Working Draft, Standard for Programming Language C++">N4810</a>.</p>

<ol>
<li><p>Modify 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, Table 62 &mdash; "Container requirements",
as indicated (This table can be identified by the "section" identifier [tab:container.req] in the next
working draft):</p>

<blockquote>
<table border="1">
<caption>Table 62 &mdash; Container requirements</caption>
<tr style="text-align:center">
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>semantics</th>
<th>Assertion/note<br/>pre/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td colspan="5" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td>
<code>X u;</code>
</td>
<td>
<code></code>
</td>
<td></td>
<td>
<ins><i>Ensures:</i> <code>!u.empty()</code> for <code>array&lt;T, N&gt;</code> where <code>0 &lt; N</code>, and</ins><br/>
<i>Ensures:</i> <code>u.empty()</code> <ins>for all other standard containers.</ins>
</td>
<td>
<del>constant</del><ins>(Note A)</ins>
</td>
</tr>
<tr>
<td>
<code>X()</code>
</td>
<td>
<code></code>
</td>
<td></td>
<td>
<ins><i>Ensures:</i> <code>!X().empty()</code> for <code>array&lt;T, N&gt;</code> where <code>0 &lt; N</code>, and</ins><br/>
<i>Ensures:</i> <code>X().empty()</code> <ins>for all other standard containers.</ins>
</td>
<td>
<del>constant</del><ins>(Note A)</ins>
</td>
</tr>

<tr>
<td colspan="5" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
<p>
Those entries marked "(Note A)" or "(Note B)" have linear complexity for <code>array<ins>&lt;T, N&gt;</ins></code>
<ins>where <code>0 &lt; N</code></ins> and have constant complexity for all other standard containers.
</p>
</blockquote>

</li>

<li><p>Modify 23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- An <code>array</code> is an aggregate (9.5.2 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.aggr">[dcl.init.aggr]</a>) that can be list-initialized with up to
<code>N</code> elements whose types are convertible to <code>T</code>.
<p/>
-3- <ins>An <code>array&lt;T, 0&gt;</code> satisfies all of the requirements of a container and of a
reversible container (23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>).</ins> An
<code>array<ins>&lt;T, N&gt;</ins></code> <ins>where <code>0 &lt; N</code></ins> satisfies all
of the requirements of a container and of a reversible container
(23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a>), except that a default constructed
<code>array<ins>&lt;T, N&gt;</ins></code> object is not empty and <del>that</del><ins>both default
construction and</ins> <code>swap</code> <del>does not</del> have <del>constant</del><ins>linear</ins>
complexity. An <code>array</code> satisfies some of the requirements of a sequence container
(23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>). Descriptions are provided here only for operations on
<code>array</code> that are not described in one of these tables and for operations where there is
additional semantic information.
</p>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2022-04-24; Daniel rebases wording on <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>]</i></p>



<p id="res-3219"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a> as indicated:</p>

<blockquote>
<pre>
X u;
X u = X();
</pre>
<blockquote>
<p>
-10- <i>Postconditions:</i> <ins><code>!u.empty()</code> for <code>array&lt;T, N&gt;</code> where <code>0 &lt; N</code>, 
and</ins> <code>u.empty()</code> <ins>for all other standard containers.</ins>
<p/>
-11- <i>Complexity:</i> <del>Constant</del><ins>Linear for <code>array&lt;T, N&gt;</code> where <code>0 &lt; N</code> 
and constant for all other standard containers</ins>.
</p>
</blockquote>
[&hellip;]
<pre>
X u(rv);
X u = rv;
</pre>
<blockquote>
<p>
-15- <i>Postconditions:</i> <code>u</code> is equal to the value that <code>rv</code> had before this construction.
<p/>
-11- <i>Complexity:</i> Linear for <code>array<ins>&lt;T, N&gt;</ins></code> <ins>where <code>0 &lt; N</code></ins> and 
constant for all other standard containers.
</p>
</blockquote>
[&hellip;]
<pre>
a.swap(b)
</pre>
<blockquote>
<p>
-45- <i>Result:</i> <code>void</code>
<p/>
-46- <i>Effects:</i> Exchanges the contents of <code>a</code> and <code>b</code>.
<p/>
-47- <i>Complexity:</i> Linear for <code>array<ins>&lt;T, N&gt;</ins></code> <ins>where <code>0 &lt; N</code></ins> and 
constant for all other standard containers.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/array.overview">[array.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- An <code>array</code> is an aggregate (9.5.2 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.aggr">[dcl.init.aggr]</a>) that can be list-initialized with up to
<code>N</code> elements whose types are convertible to <code>T</code>.
<p/>
-3- <ins>An <code>array&lt;T, 0&gt;</code> meets all of the requirements of a container (23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a>) 
and of a reversible container (23.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/container.rev.reqmts">[container.rev.reqmts]</a>).</ins> An
<code>array<ins>&lt;T, N&gt;</ins></code> <ins>where <code>0 &lt; N</code></ins> meets all
of the requirements of a container (23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a>) and of a reversible container
(23.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/container.rev.reqmts">[container.rev.reqmts]</a>), except that a default constructed
<code>array<ins>&lt;T, N&gt;</ins></code> object is not empty if <code>N &gt; 0</code> <ins>and default
construction, move construction, and <code>swap</code> have linear complexity if <code>N &gt; 0</code></ins>. 
An <code>array</code> meets some of the requirements of a sequence container (23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>). 
Descriptions are provided here only for operations on <code>array</code> that are not described in one of these 
tables and for operations where there is additional semantic information.
</p>
</blockquote>

</li>
</ol>




<hr>
<h3 id="3220"><a href="3220">3220</a>. P0558 broke conforming C++14 uses of atomic <code>shared_ptr</code></h3>
<p><b>Section:</b> 32.5.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2019-06-11 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.syn">active issues</a> in [atomics.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.syn">issues</a> in [atomics.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This well-formed C++14 program:
</p>
<blockquote><pre>
#include &lt;atomic&gt;
#include &lt;memory&gt;

struct Abstract { virtual void test() = 0; };
struct Concrete : Abstract { virtual void test() override {} };

int main() {
  std::shared_ptr&lt;Abstract&gt; ptr;
  std::atomic_store&lt;Abstract&gt;(&amp;ptr, std::make_shared&lt;Concrete&gt;());
}
</pre></blockquote>
<p>
is ill-formed in C++17. <a href="https://wg21.link/p0558">P0558</a> changed the non-member
non-<code>shared_ptr</code> atomic functions to avoid deducing from their second argument,
e.g. C++14 <code>atomic_store</code>:
</p>
<blockquote><pre>
template&lt;class T&gt; void atomic_store(atomic&lt;T&gt;*, T); <i>// #1</i>
</pre></blockquote>
<p>
became C++17 <code>atomic_store</code>:
</p>
<blockquote><pre>
template&lt;class T&gt; void atomic_store(atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type); <i>// #2</i>
</pre></blockquote>
<p>
The program intends to call the "other" <code>atomic_store</code> from
99 [depr.util.smartptr.shared.atomic]:
</p>
<blockquote><pre>
template&lt;class T&gt; void atomic_store(shared_ptr&lt;T&gt;*, shared_ptr&lt;T&gt;); <i>// #3</i>
</pre></blockquote>
<p>
In C++14, the call expression in the sample program &mdash;
<code>std::atomic_store&lt;Abstract&gt;(&amp;ptr, std::make_shared&lt;Concrete&gt;())</code> &mdash;
selects overload <code><i>#3</i></code>; overload <code><i>#1</i></code> fails to be viable due to the
lack of conversions from <code>shared_ptr&lt;Abstract&gt;*</code> to <code>atomic&lt;Abstract&gt;*</code>
and from <code>shared_ptr&lt;Concrete&gt;</code> to <code>Abstract</code>. In C++17, overload
<code><i>#2</i></code> doesn't get to the point of considering argument conversions: when we try to
generate the declaration of the specialization for <code>T = Abstract</code> we must instantiate
<code>atomic&lt;Abstract&gt;</code> in order to substitute <code>typename atomic&lt;Abstract&gt;::value_type</code>,
but doing so violates the requirement in [atomics.types.generic] p1 that "The type of the template
argument <code>T</code> shall be trivially copyable"
<p/>
The fix is fairly straightforward since <code>atomic&lt;T&gt;::value_type</code> is always an alias
for <code>T</code>: for those non-member atomic functions with overloads defined in
99 [depr.util.smartptr.shared.atomic], use a different form to require that <code>T</code>
in the type of the second parameter is non-deduced.
</p>

<p><i>[2019-07 Issue Prioritization]</i></p>

<p>Priority to 3 after discussion on the reflector.</p>


<p id="res-3220"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4810">N4810</a>.</p>

<ol>
<li><p>Modify 32.5.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>, header <code>&lt;atomic&gt;</code> synopsis, as indicated:</p>

<blockquote><pre>
[&hellip;]
<i>// 32.5.9 <a href="https://timsong-cpp.github.io/cppwp/atomics.nonmembers">[atomics.nonmembers]</a>, non-member functions</i>
[&hellip;]
template&lt;class T&gt;
  void atomic_store(volatile atomic&lt;T&gt;*, <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>) noexcept;
template&lt;class T&gt;
  void atomic_store(atomic&lt;T&gt;*, <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>) noexcept;
template&lt;class T&gt;
  void atomic_store_explicit(volatile atomic&lt;T&gt;*, <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>,
                             memory_order) noexcept;
template&lt;class T&gt;
  void atomic_store_explicit(atomic&lt;T&gt;*, <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>,
                             memory_order) noexcept;
[&hellip;]
template&lt;class T&gt;
  T atomic_exchange(volatile atomic&lt;T&gt;*, <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>) noexcept;
template&lt;class T&gt;
  T atomic_exchange(atomic&lt;T&gt;*, <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>) noexcept;
template&lt;class T&gt;
  T atomic_exchange_explicit(volatile atomic&lt;T&gt;*, <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>,
                             memory_order) noexcept;
template&lt;class T&gt;
  T atomic_exchange_explicit(atomic&lt;T&gt;*, <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>,
                             memory_order) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_weak(volatile atomic&lt;T&gt;*,
                                    <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>*,
                                    <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_weak(atomic&lt;T&gt;*,
                                    <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>*,
                                    <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_strong(volatile atomic&lt;T&gt;*,
                                      <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>*,
                                      <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_strong(atomic&lt;T&gt;*,
                                      <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>*,
                                      <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_weak_explicit(volatile atomic&lt;T&gt;*,
                                             <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>*,
                                             <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>,
                                             memory_order, memory_order) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_weak_explicit(atomic&lt;T&gt;*,
                                             <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>*,
                                             <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>,
                                             memory_order, memory_order) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_strong_explicit(volatile atomic&lt;T&gt;*,
                                               <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>*,
                                               <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>,
                                               memory_order, memory_order) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_strong_explicit(atomic&lt;T&gt;*,
                                               <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>*,
                                               <del>typename atomic&lt;T&gt;::value_type</del><ins>type_identity_t&lt;T&gt;</ins>,
                                               memory_order, memory_order) noexcept;
</pre></blockquote>

</li>

<li><p>Modify 32.5.9 <a href="https://timsong-cpp.github.io/cppwp/atomics.nonmembers">[atomics.nonmembers]</a> as indicated:</p>

<blockquote>
<p>
-1- A non-member function template whose name matches the pattern <code>atomic_<i>f</i></code> or the
pattern <code>atomic_<i>f</i>_explicit</code> invokes the member function <code><i>f</i></code>, with the
value of the first parameter as the object expression and the values of the remaining parameters
(if any) as the arguments of the member function call, in order. An argument for a parameter of
type <code>atomic&lt;T&gt;::value_type*</code> <ins>or <code>type_identity_t&lt;T&gt;*</code></ins> is
dereferenced when passed to the member function call. If no such member function exists, the
program is ill-formed.
</p>
</blockquote>

</li>
</ol>




<hr>
<h3 id="3227"><a href="3227">3227</a>. Ambiguity issue for <code>extract</code> in ordered and unordered associative containers</h3>
<p><b>Section:</b> 23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>, 23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Konstantin Boyarinov <b>Opened:</b> 2019-06-25 <b>Last modified:</b> 2022-04-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Ordered and unordered associative containers in C++14 contained an issue, which caused an ambiguity
while invoking <code>std::map::erase</code> when <code>key_type</code> of the map can be constructed from
the iterator. In this case both overloads <code>erase(const key_type&amp;)</code> and
<code>erase(const_iterator)</code> could be chosen.
<p/>
The issue LWG <a href="2059" title="C++0x ambiguity problem with map::erase (Status: C++17)">2059</a> was reported and resolved in C++17 by adding an extra overload
for <code>erase</code> in ordered and unordered associative containers which accepts <code>iterator</code>
as an argument.
<p/>
C++17 also introduced new functionality for splicing ordered and unordered maps and sets.
One of the extensions allows to extract a node from the container by passing either
<code>key_type&amp;</code> or <code>const_iterator</code> to the <code>extract()</code> member function:
</p>
<blockquote><pre>
node_type extract(const key_type&amp; x);
node_type extract(const_iterator position);
</pre></blockquote>
<p>
Providing these two <code>extract</code> overloads causes the same problem as for <code>erase</code>.
Consider the following example:
</p>
<blockquote><pre>
#include &lt;map&gt;
#include &lt;string&gt;

struct Key
{
  template &lt;typename T&gt;
  Key(const T&amp;) {}
};

bool operator&lt;(const Key&amp;, const Key&amp;) { return false; }

int main()
{
  using map_type = std::map&lt;Key, std::string&gt;;

  map_type m({ {Key(1), "a"}, {Key(2), "b"} });
  map_type::iterator it = m.begin();
  auto nh = m.extract(it);
}
</pre></blockquote>
<p>
In this case, call to <code>extract()</code> is ambiguous, because the overloads which accept
<code>const_iterator</code> and <code>key_type</code> are equally good matches for the argument
<code>it</code>.
<p/>
Consequently, this issue can be resolved in the same way as for <code>std::map::erase</code>
by adding an overload for <code>extract</code> which accepts <code>iterator</code> as an argument.
</p>

<p><i>[2019-07 Issue Prioritization]</i></p>

<p>Priority to 3 after discussion on the reflector.</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/N4820" title=" Working Draft, Standard for Programming Language C++">N4820</a>.</p>

<ol>
<li><p>Modify  [tab:container.assoc.req], Table 69 &mdash;
"Associative container requirements", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 69 &mdash; Associative container requirements (in addition to container)
 [tab:container.assoc.req]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>a.extract(q)</code>
</td>
<td>
<code>node_type</code>
</td>
<td>
<i>Effects:</i> Removes the element<br/>
pointed to by <code>q</code>.<br/>
<i>Returns:</i> A <code>node_type</code> owning<br/>
that element.
</td>
<td>
amortized constant
</td>
</tr>

<tr>
<td>
<ins><code>a.extract(r)</code></ins>
</td>
<td>
<ins><code>node_type</code></ins>
</td>
<td>
<ins><i>Effects:</i> Removes the element<br/>
pointed to by <code>r</code>.<br/>
<i>Returns:</i> A <code>node_type</code> owning<br/>
that element.</ins>
</td>
<td>
<ins>amortized constant</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify  [tab:container.assoc.req], Table 70 &mdash;
"Unordered associative container requirements", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 70 &mdash; Unordered associative container requirements (in addition to container)
 [tab:container.hash.req]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>a.extract(q)</code>
</td>
<td>
<code>node_type</code>
</td>
<td>
<i>Effects:</i> Removes the element<br/>
pointed to by <code>q</code>.<br/>
<i>Returns:</i> A <code>node_type</code> owning<br/>
that element.
</td>
<td>
Average case
<code>&#x1d4aa;(1)</code>, worst case
<code>&#x1d4aa;(a.size())</code>.
</td>
</tr>

<tr>
<td>
<ins><code>a.extract(r)</code></ins>
</td>
<td>
<ins><code>node_type</code></ins>
</td>
<td>
<ins><i>Effects:</i> Removes the element<br/>
pointed to by <code>r</code>.<br/>
<i>Returns:</i> A <code>node_type</code> owning<br/>
that element.</ins>
</td>
<td>
<ins>Average case
<code>&#x1d4aa;(1)</code>, worst case
<code>&#x1d4aa;(a.size())</code>.</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify 23.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/map.overview">[map.overview]</a>, class template <code>map</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/multimap.overview">[multimap.overview]</a>, class template <code>multimap</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/set.overview">[set.overview]</a>, class template <code>set</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.4.7.1 <a href="https://timsong-cpp.github.io/cppwp/multiset.overview">[multiset.overview]</a>, class template <code>multiset</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a>, class template <code>unordered_map</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a>, class template <code>unordered_multimap</code>
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a>, class template <code>unordered_set</code>
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a>, class template <code>unordered_multiset</code>
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-04-24; Daniel rebases wording on <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>]</i></p>



<p id="res-3227"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a> as indicated:</p>

<blockquote>
<pre>
a.extract(q)
</pre>
<blockquote>
<p>
-108- <i>Result:</i> <code>node_type</code>
<p/>
-109- <i>Effects:</i> Removes the element pointed to by <code>q</code>.
<p/>
-110- <i>Returns:</i> A <code>node_type</code> owning that element.
<p/>
-111- <i>Complexity:</i> Amortized constant.
</p>
</blockquote>
<pre>
<ins>a.extract(r)</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Result:</i> <code>node_type</code></ins>
<p/>
<ins>-?- <i>Effects:</i> Removes the element pointed to by <code>r</code>.</ins>
<p/>
<ins>-?- <i>Returns:</i> A <code>node_type</code> owning that element.</ins>
<p/>
<ins>-?- <i>Complexity:</i> Amortized constant.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> as indicated:</p>

<blockquote>
<pre>
a.extract(q)
</pre>
<blockquote>
<p>
-141- <i>Result:</i> <code>node_type</code>
<p/>
-142- <i>Effects:</i> Removes the element pointed to by <code>q</code>.
<p/>
-143- <i>Returns:</i> A <code>node_type</code> owning that element.
<p/>
-144- <i>Complexity:</i> Average case <code>&#x1d4aa;(1)</code>, worst case <code>&#x1d4aa;(a.size())</code>.
</p>
</blockquote>
<pre>
<ins>a.extract(r)</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Result:</i> <code>node_type</code></ins>
<p/>
<ins>-?- <i>Effects:</i> Removes the element pointed to by <code>r</code>.</ins>
<p/>
<ins>-?- <i>Returns:</i> A <code>node_type</code> owning that element.</ins>
<p/>
<ins>-?- <i>Complexity:</i> Average case <code>&#x1d4aa;(1)</code>, worst case <code>&#x1d4aa;(a.size())</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/map.overview">[map.overview]</a>, class template <code>map</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/multimap.overview">[multimap.overview]</a>, class template <code>multimap</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/set.overview">[set.overview]</a>, class template <code>set</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.4.7.1 <a href="https://timsong-cpp.github.io/cppwp/multiset.overview">[multiset.overview]</a>, class template <code>multiset</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a>, class template <code>unordered_map</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a>, class template <code>unordered_multimap</code>
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/unord.set.overview">[unord.set.overview]</a>, class template <code>unordered_set</code>
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multiset.overview">[unord.multiset.overview]</a>, class template <code>unordered_multiset</code>
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>node_type extract(iterator position);</ins>
node_type extract(const_iterator position);
node_type extract(const key_type&amp; x);
[&hellip;]
</pre>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3229"><a href="3229">3229</a>. &sect;[res.on.exception.handling]#3 cannot apply to types with implicitly declared destructors</h3>
<p><b>Section:</b> 16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2019-06-28 <b>Last modified:</b> 2023-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#res.on.exception.handling">active issues</a> in [res.on.exception.handling].</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.exception.handling">issues</a> in [res.on.exception.handling].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>#3 says:
</p>
<blockquote><p>
Destructor operations defined in the C++ standard library shall not throw exceptions.
Every destructor in the C++ standard library shall behave as if it had a non-throwing
exception specification.
</p></blockquote>
<p>
However, types like <code>pair</code> and <code>array</code> have implicitly declared destructors,
where 14.5 <a href="https://timsong-cpp.github.io/cppwp/except.spec">[except.spec]</a>#8 applies:
</p>
<blockquote><p>
The exception specification for an implicitly-declared destructor, or a destructor without
a <i>noexcept</i>-specifier, is potentially-throwing if and only if any of the destructors
for any of its potentially constructed subobjects is potentially-throwing or the destructor
is virtual and the destructor of any virtual base class is potentially throwing.
</p></blockquote>
<p>
We can relax 16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a> to only cover explicitly declared
destructors because if they hold a user type where the destructor throws then we get UB
from 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a>#2:
</p>
<blockquote><p>
In particular, the effects are undefined in the following cases: [&hellip;]
</p>
<ol style="list-style-type:none">
<li><p>[&hellip;]</p></li>
<li><p>(2.4) &mdash; if any replacement function or handler function or destructor operation
exits via an exception, unless specifically allowed in the applicable
<i>Required behavior:</i> paragraph.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
<p>
and the referred to UB happens before [res.on.exception.handling] could apply.
</p>

<p><i>[2019-07 Issue Prioritization]</i></p>

<p>Priority to 3 after discussion on the reflector.</p>

<p><i>[2023-01-29; Daniel comments]</i></p>

<p>
This issue has very much overlap with LWG <a href="3854" title="&sect;[res.on.exception.handling]/3 should not be applied to all standard library types (Status: New)">3854</a>.
</p>


<p id="res-3229"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4820">N4820</a>.</p>

<ol>
<li><p>Modify 16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a> as indicated:</p>

<blockquote><p>
-3- Destructor operations defined in the C++ standard library shall not throw exceptions.
Every <ins>explicitly declared</ins> destructor in the C++ standard library shall behave
as if it had a non-throwing exception specification.
</p></blockquote>
</li>
</ol>




<hr>
<h3 id="3240"><a href="3240">3240</a>. Headers declare more than entities</h3>
<p><b>Section:</b> 16.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/using.headers">[using.headers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2019-07-24 <b>Last modified:</b> 2020-04-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#using.headers">issues</a> in [using.headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Quoting 16.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/using.headers">[using.headers]</a> p3:
</p>
<blockquote><p>
"[&hellip;] and shall include the header lexically before the first reference in that translation
 unit to any of the entities declared in that header."
</p></blockquote>
<p>
This suggests we may be able to use macros and typedefs (like <code>size_t</code>) declared in 
standard headers without the corresponding <code>#include</code>. Clearly that is not the intended 
behavior!
<p/>
I thought about replacing 'entity' with 'name', but the same name may occur with
different contexts throughout the standard library. I thought about "contents of that
header", but run afoul of the same function overloads (<code>std::begin</code> etc.) being declared
in multiple headers.
<p/>
It may be simpler to turn this sentence around, along the lines of:
</p>
<blockquote><p>
"No part of the standard library shall be used in a translation unit prior to a including
or importing a header that provides that feature."
</p></blockquote>
<p>
Even here, 'used' may be a problematic term of art. Perhaps "named"?
</p>

<p><i>[2020-04-07 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>

<p id="res-3240"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3261"><a href="3261">3261</a>. <code>regex</code> components' <code>noexcept</code> annotations appear broken for POCMA or throwing 
<code>BidirectionalIterator</code></h3>
<p><b>Section:</b> 28.6.7 <a href="https://timsong-cpp.github.io/cppwp/re.regex">[re.regex]</a>, 28.6.9 <a href="https://timsong-cpp.github.io/cppwp/re.results">[re.results]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2019-08-17 <b>Last modified:</b> 2019-10-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::basic_regex</code> and <code>std::match_results</code> have <code>noexcept</code> move construction, and 
<code>std::basic_regex</code> has <code>noexcept</code> move assignment, but both of them have throwing swaps. We 
probably need an <i>Expects:</i> or something to say that <code>BidirectionalIterator</code> doesn't 
throw through these operations. We probably also need <code>match_results::operator=</code> to 
respect <code>propagate_on_container_move_assignment</code> (and maybe the copy ctor respect 
<code>propagate_on_container_copy_assignment</code>).
</p>
<p><i>[2019-09-02; Tim Song comments]</i></p>

<p>
The issue is related to LWG <a href="2490" title="&lt;regex&gt; needs lots of noexcept (Status: New)">2490</a>.
</p>
<p><i>[2019-10 Priority set to 3 after reflector discussion]</i></p>



<p id="res-3261"><b>Proposed resolution:</b></p>



<hr>
<h3 id="3263"><a href="3263">3263</a>. Atomic waiting function calls should only be unblocked once</h3>
<p><b>Section:</b> 32.5.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.wait">[atomics.wait]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2019-08-19 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.wait">active issues</a> in [atomics.wait].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.wait">issues</a> in [atomics.wait].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It appears that in a conforming implementation, all but one <code>wait()</code> call on a given 
atomic object may block forever, regardless of any <code>notify_one()</code> calls, because in 
principle every <code>notify_one()</code> call could be considered to unblock the same single 
<code>wait()</code> call. Common sense suggests (and David Olsen confirms) that the intent is 
for each waiting function call to be (non-spuriously) unblocked by at most one notifying 
function call, but as far as I can tell the words never say that.
</p>

<p><i>[2019-09-14 Priority set to 3 based on reflector discussion]</i></p>



<p id="res-3263"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 32.5.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.wait">[atomics.wait]</a> as indicated:</p>

<blockquote>
<p>
<ins>-?- All blocking and unblocking events on a single atomic object occur in a single total order 
that is consistent with the "happens before" partial order.</ins>
<p/>
-4- A call to an atomic waiting operation on an atomic object <code>M</code> is <i>eligible to be 
unblocked</i> by a call to an atomic notifying operation on <code>M</code> if <ins>it has not been 
unblocked, and</ins> there exist side effects <code>X</code> and <code>Y</code> on <code>M</code> such that:
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; the atomic waiting operation has blocked after observing the result of <code>X</code>,</p></li>
<li><p>(4.2) &mdash; <code>X</code> precedes <code>Y</code> in the modification order of <code>M</code>, and</p></li>
<li><p>(4.3) &mdash; <code>Y</code> happens before the call to the atomic notifying operation.</p></li>
</ol>
</blockquote>
</li>

</ol>



<hr>
<h3 id="3267"><a href="3267">3267</a>. Rebound allocators and <code>is_always_equal</code></h3>
<p><b>Section:</b> 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> FrankHB1989 <b>Opened:</b> 2019-08-27 <b>Last modified:</b> 2023-01-14</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[allocator.requirements] does not mention the interaction between <code>is_always_equal</code> 
and allocator rebinding. As the result, a rebound allocator may have different 
<code>is_always_equal::value</code> to the original allocator.
<p/>
Further, for an allocator type <code>X</code> satisfying 
<code>std::allocator_type&lt;X&gt;::is_always_equal::value == true</code>, rebound allocators 
of <code>X</code> with same type are not guaranteed equal.
<p/>
Consider:
</p>
<ol>
<li><p><code>X</code> is used as an allocator for <code>value_type</code> used in a node-based container;</p></li>
<li><p><code>Y</code> is the rebound allocator type for the node type used in the implementation;</p></li>
<li><p><code>b1</code> and <code>b2</code> are values of <code>Y</code> from different allocator objects.</p></li>
</ol>
<p>
Then, <code>std::allocator_type&lt;X&gt;::is_always_equal::value == true</code> does not necessarily 
imply <code>b1 == b2</code>.
<p/>
Since some of containers in the standard have already explicitly relied on <code>is_always_equal</code> 
of allocators for their <code>value_type</code> (notably, in the exception specification of the move 
assignment), this can cause subtle problems.
<p/>
In general, the implementation of the move assignment operator of such a container can not avoid 
allocation for new nodes when <code>!std::allocator_traits&lt;Y&gt;::propagate_on_container_move_assignment::value 
&amp;&amp; b1 != b2</code>. This can throw, and it can clash with the required exception specification 
based on <code>std::allocator_traits&lt;value_type&gt;::is_always_equal</code>:
</p>
<blockquote><pre>
#include &lt;utility&gt;
#include &lt;memory&gt;
#include &lt;new&gt;
#include &lt;map&gt;
#include &lt;functional&gt; 
#include &lt;type_traits&gt; 

using K = int;
using V = int;
using P = std::pair&lt;const K, V&gt;; 

bool stop_alloc; 

template&lt;typename T&gt;
struct AT
{
  using value_type = T; 

  std::shared_ptr&lt;void&gt; sp = {}; 

  template&lt;typename U&gt;
  struct rebind
  {
    using other = AT&lt;U&gt;;
  }; 

  using is_always_equal = std::is_same&lt;T, P&gt;; 

  AT() : sp(is_always_equal::value ? nullptr : new T*()) {}

  AT(const AT&amp; a) = default;

  template&lt;typename U&gt;
  AT(const AT&lt;U>&amp; a) noexcept : sp(a.sp) {} 

  T* allocate(std::size_t size)
  {
    if (stop_alloc)
      throw std::bad_alloc();
    return static_cast&lt;T*&gt;(::operator new(size * sizeof(T)));
  } 

  void deallocate(T* p, std::size_t)
  {
    ::operator delete(p);
  }

  friend bool operator==(const AT&amp; x, const AT&amp; y) noexcept
  {
    return !x.sp.owner_before(y.sp) &amp;&amp; !y.sp.owner_before(x.sp);
  } 

  friend bool operator!=(const AT&amp; x, const AT&amp; y) noexcept 
  {
    return !(x == y);
  }

};

using A = AT&lt;P&gt;; 

int main()
{
  // Some sanity checks:
  static_assert(std::is_same_v&lt;A::template rebind&lt;A::value_type&gt;::other, A&gt;);
  // For any U:
  using U = int;
  static_assert(std::is_same_v&lt;A::template rebind&lt;U&gt;::other::template rebind&lt;A::value_type&gt;::other, A&gt;); 

  using C = std::less&lt;&gt;;
  using M = std::map&lt;K, V, C, A&gt;; 

  // As required by the current wording of the container move operator:
  using always_equal = std::allocator_traits&lt;A&gt;::is_always_equal;
  constexpr bool std_nothrow = always_equal::value &amp;&amp; std::is_nothrow_move_assignable_v&lt;C&gt;;
  static_assert(std_nothrow);

  // For conforming implementations:
  // static_assert(!(std_nothrow &amp;&amp; !std::is_nothrow_move_assignable&lt;M&gt;::value)); 

  M m{{K(), V()}}, m2;
  auto a = m.get_allocator(); 

  a.sp = std::make_shared&lt;int&gt;(42);
  stop_alloc = true;

  try
  {
    // Call terminate with conforming implementations. This does not work on libstdc++.
    m2 = std::move(m);
    // For libstdc++, terminate on allocator-extended move constructor call.
    //    M m3(std::move(m), a);
  }
  catch(...)
  {}
}
</pre></blockquote>

<p><i>[2019-10 Priority set to 4 after reflector discussion]</i></p>


<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/N4830" title=" Committee Draft, Standard for Programming Language C++">N4830</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Additional questions: Is it necessary to ensure that<br/>
<code>XX::propagate_on_container_copy_assignment::value == YY::propagate_on_container_copy_assignment::value</code>
is <code>true</code> as well?]
</p>
</blockquote>

<ol>
<li><p>Modify 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>, Table [tab:cpp17.allocator] 
"<code><i>Cpp17Allocator</i></code> requirements" as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 34 &mdash; <code><i>Cpp17Allocator</i></code> requirements [tab:cpp17.allocator]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>typename<br/>
X::template<br/>
rebind&lt;U&gt;::other</code>
</td>
<td>
<code>Y</code>
</td>
<td>
For all <code>U</code> (including <code>T</code>),<br/>
<code>Y::template<br/>
rebind&lt;T&gt;::other</code> is <code>X</code>.<br/>
<ins><code>XX::is_always_equal::value == YY::is_always_equal::value</code><br/>
is <code>true</code>.</ins>
</td>
<td>
See Note A,<br/>
below.
</td>
</tr>

<tr>
<td colspan="4" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-04-24; Daniel rebases wording on <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>]</i></p>


<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Additional questions: Is it necessary to ensure that<br/>
<code>XX::propagate_on_container_copy_assignment::value == YY::propagate_on_container_copy_assignment::value</code>
is <code>true</code> as well?]
</p>
</blockquote>

<ol>
<li><p>Modify 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> as indicated:</p>
<blockquote>
<pre>
typename X::template rebind&lt;U&gt;::other
</pre>
<blockquote>
<p>
-16- <i>Result:</i> <code>Y</code>
<p/>
-17- <i>Postconditions:</i> For all <code>U</code> (including <code>T</code>), <code>Y::template rebind&lt;T&gt;::other</code> 
is <code>X</code>. <ins><code>XX::is_always_equal::value == YY::is_always_equal::value</code> is <code>true</code>.</ins>
<p/>
-18- <i>Remarks:</i> If <code>Allocator</code> is a class template instantiation of the form 
<code>SomeAllocator&lt;T, Args&gt;</code>, where <code>Args</code> is zero or more type arguments, and 
<code>Allocator</code> does not supply a <code>rebind</code> member template, the standard <code>allocator_traits</code> 
template uses <code>SomeAllocator&lt;U, Args&gt;</code> in place of <code>Allocator::rebind&lt;U&gt;::other</code> 
by default. For allocator types that are not template instantiations of the above form, no default is provided.
<p/>
-19- [<i>Note 1</i>: The member class template <code>rebind</code> of <code>X</code> is effectively a typedef template. 
In general, if the name <code>Allocator</code> is bound to <code>SomeAllocator&lt;T&gt;</code>, then 
<code>Allocator::rebind&lt;U&gt;::other</code> is the same type as <code>SomeAllocator&lt;U&gt;</code>, where 
<code>SomeAllocator&lt;T&gt;::value_type</code> is <code>T</code> and <code>SomeAllocator&lt;U&gt;::value_type</code> 
is <code>U</code>. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2023-01-08; Jiang An comments and provides improved wording]</i></p>

<p>
Exception specifications of some container operations (added by <a href="https://wg21.link/N4258" title=" Cleaning up noexcept in the Library (Rev 3)">N4258</a> and LWG <a href="3778" title="vector&lt;bool&gt; missing exception specifications (Status: C++23)">3778</a>) 
are specified with the propagation properties of template parameter <code>Allocator</code>. However, for node-based 
containers and <code>std::deque</code> (and common implementations of <code>std::vector&lt;bool, A&gt;</code>), 
rebound allocators are needed to be propagated, and common implementations are currently detecting the propagation 
properties of rebound allocators.
<p/>
I think if the allocator provided as template argument and the rebound have different propagation properties and 
behaves differently on propagation, then it is difficult or impossible for implementations to follow the current 
exception specifications.
</p>


<p id="res-3267"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a> as indicated:</p>
<blockquote>
<pre>
typename X::template rebind&lt;U&gt;::other
</pre>
<blockquote>
<p>
-16- <i>Result:</i> <code>Y</code>
<p/>
-17- <i>Postconditions:</i> For all <code>U</code> (including <code>T</code>), <code>Y::template rebind&lt;T&gt;::other</code> 
is <code>X</code>. <ins>All of <code>XX::is_always_equal::value == YY::is_always_equal::value</code>, 
<code>XX::propagate_on_container_copy_assignment::value == YY::propagate_on_container_copy_assignment::value</code>,  
<code>XX::propagate_on_container_move_assignment::value == YY::propagate_on_container_move_assignment::value</code>, and  
<code>XX::propagate_on_container_swap::value == YY::propagate_on_container_swap::value</code> are <code>true</code>.</ins>
<p/>
-18- <i>Remarks:</i> If <code>Allocator</code> is a class template instantiation of the form 
<code>SomeAllocator&lt;T, Args&gt;</code>, where <code>Args</code> is zero or more type arguments, and 
<code>Allocator</code> does not supply a <code>rebind</code> member template, the standard <code>allocator_traits</code> 
template uses <code>SomeAllocator&lt;U, Args&gt;</code> in place of <code>Allocator::rebind&lt;U&gt;::other</code> 
by default. For allocator types that are not template instantiations of the above form, no default is provided.
<p/>
-19- [<i>Note 1</i>: The member class template <code>rebind</code> of <code>X</code> is effectively a typedef template. 
In general, if the name <code>Allocator</code> is bound to <code>SomeAllocator&lt;T&gt;</code>, then 
<code>Allocator::rebind&lt;U&gt;::other</code> is the same type as <code>SomeAllocator&lt;U&gt;</code>, where 
<code>SomeAllocator&lt;T&gt;::value_type</code> is <code>T</code> and <code>SomeAllocator&lt;U&gt;::value_type</code> 
is <code>U</code>. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3268"><a href="3268">3268</a>. <code>memory_order::memory_order_foo</code> broken in C++20</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2019-08-31 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/p0439r0">P0439R0</a> renamed the <code>std::memory_order</code> enumerators 
when making it a scoped enumeration. The paper makes the old unscoped names available in the 
global namespace, but not within the scope of the enumeration.
<p/>
For example:
<p/>
<code>std::memory_order::memory_order_consume</code> is no longer well-formed but 
<code>std::memory_order::consume</code> and <code>std::memory_order_consume</code> are.
<p/>
In order to prevent unnecessary breakage, we should re-add the <code>memory_order_foo</code> names 
to the enumeration.
</p>
<p><i>[2019-10 Priority set to 4 after reflector discussion]</i></p>



<p id="res-3268"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Add a new sub-clause at the end of Clause D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> as indicated:</p>

<blockquote>
<p>
<ins><b>D.?? Deprecated <code>memory_order</code> enumerators</b></ins>
<p/>
<ins>-?- The following enumerators are declared in addition to those specified in 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>:</ins>
</p>
<blockquote>
<pre>
<ins>namespace std {
  enum class memory_order : <i>unspecified</i> {
    memory_order_relaxed = relaxed, memory_order_consume = consume, memory_order_acquire = acquire, 
    memory_order_release = release, memory_order_acq_rel = acq_rel, memory_order_seq_cst = seq_cst
  };
}</ins>
</pre>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3275"><a href="3275">3275</a>. Why does <code>time_get::do_get</code> require a valid pointer when none of the others do?</h3>
<p><b>Section:</b> 28.3.4.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2019-09-09 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#locale.time.get.virtuals">active issues</a> in [locale.time.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.time.get.virtuals">issues</a> in [locale.time.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 28.3.4.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> p11:
</p>
<blockquote><p>
<i>Requires:</i> <code>t</code> shall point to an object
</p></blockquote>
<p>
[Note: In my "Mandates" paper, I changed this to "<i>Expects:</i> <code>t</code> points to an object"]
<p/>
Nevertheless, it's odd, and inconsistent. <code>time_get::get</code> does not have any such stated requirement, 
and it calls <code>do_get</code>. None of the other "time" calls in <code>time_get</code> have such a (stated) 
requirement.
<p/>
I believe that this requirement is redundant, that it is implied by the wording in P12 and P14.
<p/>
P12: "or until it has extracted and assigned those <code>struct tm</code> members"
<p/>
P14: "It is unspecified whether multiple calls to <code>do_get()</code> with the address of the same 
<code>struct tm</code> object will update the current contents of the object or simply overwrite its members."
<p/>
If the pointer is invalid (null, or points to unmapped memory, say), you've got UB anyway.
<p/>
All the other calls in [locale.time.get.virtuals] were from C++98. <code>do_get_time</code> was added in C++11, 
and p11 originally said "<code>t</code> shall be dereferenceable". 
<p/>
This was changed to "<code>t</code> shall point to an object" as part of the resolution of CWG issue 
<a href="https://wg21.link/cwg342">342</a>
</p>

<p><i>[2019-10 Priority set to 3 after reflector discussion]</i></p>



<p id="res-3275"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 28.3.4.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a> as indicated:</p>

<blockquote>
<pre>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
                 ios_base::iostate&amp; err, tm* t, char format, char modifier) const;
</pre>
<blockquote>
<p>
<del>-11- <i>Requires:</i> <code>t</code> shall point to an object.</del>
<p/>
-12- <i>Effects:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3287"><a href="3287">3287</a>. Exposition-only <code><i>cpp17-input-iterator</i></code> concept is needlessly complex</h3>
<p><b>Section:</b> 24.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2019-09-10 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.traits">issues</a> in [iterator.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new C++20 iterator concepts use <code>common_reference</code> to constrain the value, reference, and 
rvalue_reference associated types in order to support proxy references (see 
24.3.4.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.readable">[iterator.concept.readable]</a>).
<p/>
However, the C++17 iterators did not support proxy references, so the use of <code>common_reference</code> in 
24.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a>/p2 is needlessly complex. The <code>common_reference</code> constraints can be 
replaced with simple convertibility requirements to a <code>const</code> lvalue reference to the value type.
<p/>
This fix has been implemented in range-v3.
</p>

<p><i>[2019-10-14 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3287"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 24.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.traits">[iterator.traits]</a> as indicated:</p>

<blockquote>
<p>
-2- The definitions in this subclause make use of the following exposition-only concepts:
</p>
<blockquote>
<pre>
template&lt;class I&gt;
concept <i>cpp17-iterator</i> =
  copyable&lt;I&gt; &amp;&amp; requires(I i) {
    {   *i } -&gt; <i>can-reference</i>;
    {  ++i } -&gt; same_as&lt;I&amp;&gt;;
    { *i++ } -&gt; <i>can-reference</i>;
  };

template&lt;class I&gt;
concept <i>cpp17-input-iterator</i> =
  <i>cpp17-iterator</i>&lt;I&gt; &amp;&amp; equality_comparable&lt;I&gt; &amp;&amp; requires(I i) {
    typename incrementable_traits&lt;I&gt;::difference_type;
    typename readable_traits&lt;I&gt;::value_type;
    <del>typename common_reference_t&lt;iter_reference_t&lt;I&gt;&amp;&amp;,
                                typename readable_traits&lt;I&gt;::value_type&amp;&gt;;
    typename common_reference_t&lt;decltype(*i++)&amp;&amp;,
                                typename readable_traits&lt;I&gt;::value_type&amp;&gt;;</del>
    <ins>{ *i } -&gt; convertible_to&lt;const typename readable_traits&lt;I&gt;::value_type&amp;&gt;;
    { *i++ } -&gt; convertible_to&lt;const typename readable_traits&lt;I&gt;::value_type&amp;&gt;;</ins>
    requires signed_integral&lt;typename incrementable_traits&lt;I&gt;::difference_type&gt;;
  };

[&hellip;]
</pre>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3288"><a href="3288">3288</a>. <code>atomic&lt;T&gt;::notify_one</code> is unimplementable</h3>
<p><b>Section:</b> 32.5.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.wait">[atomics.wait]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2019-09-11 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.wait">active issues</a> in [atomics.wait].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.wait">issues</a> in [atomics.wait].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I am concerned by the wording around <code>atomic&lt;T&gt;::wait()/atomic&lt;T&gt;::notify_one()</code>.
<p/>
32.5.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.wait">[atomics.wait]</a> p4 requires that the thread that calls <code>wait()</code> observed a
value <code>X</code> prior to the value <code>Y</code> which results from a store that happens-before 
the notify in order to be eligible to be unlocked.
<p/>
I am not sure how to implement that.
</p>
<blockquote><pre>
atomic&lt;int&gt; a = 0;

T1: int ra=a, read 0
T1: a.wait(0)
T2: a=42
T3: int ra=a, read 42
T3: a.wait(42)
T2: a.notify_one()
</pre></blockquote>
<p>
The wording requires that <code>T1</code> is eligible to be unlocked, but not <code>T3</code>, as
there is not a write <em>after</em> the value read by <code>T3</code> that happens-before
the notify.
<p/>
However, both <code>T1</code> and <code>T3</code> are waiting, so <code>T3</code> may be woken by the OS.
Waking <code>T3</code> is allowed (<code>wait()</code> says it may wake spuriously), but waking <code>T1</code>
is currently required as it is the only thread "eligible to be unblocked".
<p/>
This requires <code>notify_one()</code> to wake <em>all</em> waiters, which defeats the purpose.
<p/>
I suspect we need to change 32.5.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.wait">[atomics.wait]</a> p4.
<p/>
How about:
</p>
<blockquote><p>
"A call to an atomic waiting operation <code>W</code> on an atomic object <code>M</code> is
<i>eligible to be unlocked</i> by a call to an atomic notifying operation <code>N</code> on
<code>M</code> if
<ul>
<li><p><code>N</code> does not happen-before <code>W</code></p></li>
<li><p>There are no side effects <code>X</code> and <code>Y</code> in the modification order of <code>M</code> such
that <code>N</code> happens-before <code>X</code>, <code>X</code> precedes <code>Y</code> in the modification order 
of <code>M</code> and an atomic operation that observes the effects of <code>Y</code> happens-before <code>W</code>.</p></li>
</ul>
"
</p></blockquote>
<p>
This would allow <code>T3</code> to be woken in the preceding example, but prevent it
being woken in the following case:
</p>
<blockquote><pre>
T1: int ra=a, read 0
T1: a.wait(0)
T2: a=42
T2: a.notify_one()
T2: a=69
T3: int ra=a, read 69
T3: a.wait(69)
</pre></blockquote>

<p><i>[2020-07-17; Priority set to 2 in telecon]</i></p>



<p id="res-3288"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4830">N4830</a>.</p>

<ol>
<li><p>Modify 32.5.6 <a href="https://timsong-cpp.github.io/cppwp/atomics.wait">[atomics.wait]</a> as indicated:</p>

<blockquote>
<p>
-4- A call to an atomic waiting operation <ins><code>W</code></ins> on an atomic object <code>M</code> is 
<i>eligible to be unblocked</i> by a call to an atomic notifying operation <ins><code>N</code></ins> on <code>M</code> 
if <del>there exist side effects <code>X</code> and <code>Y</code> on <code>M</code> such that:</del>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <ins><code>N</code> does not happen before <code>W</code></ins><del>the atomic waiting operation 
has blocked after observing the result of <code>X</code></del>,</p></li>
<li><p>(4.2) &mdash; <ins>There are no side effects</ins> <code>X</code> <ins>and</ins><del>precedes</del> <code>Y</code> 
in the modification order of <code>M</code><del>, and</del><ins>such that <code>N</code> happens before <code>X</code>, 
<code>X</code> precedes <code>Y</code> in the modification order of <code>M</code> and an atomic operation that observes 
the effects of <code>Y</code> happens before <code>W</code>.</ins></p></li>
<li><p><del>(4.3) &mdash; <code>Y</code> happens before the call to the atomic notifying operation.</del></p></li>
</ol>
</p>
</blockquote>
</li>

</ol>




<hr>
<h3 id="3297"><a href="3297">3297</a>. Useless sequence container requirement</h3>
<p><b>Section:</b> 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2019-09-17 <b>Last modified:</b> 2022-04-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> paragraph 3 says that the names <code>i</code> and <code>j</code> denote 
"iterators that meet the <i>Cpp17InputIterator</i> requirements and refer to elements implicitly 
convertible to <code>value_type</code>". Ignoring for the moment that this is an occurrence of LWG 
<a href="3105" title="T1 is convertible to T2 (Status: New)">3105</a> &mdash; we really mean that <code>*i</code> and <code>*j</code> must be implicitly 
convertible to <code>value_type</code> &mdash; this requirement seems to be completely extraneous.
<p/>
The names <code>i</code> and <code>j</code> are used in three places in the requirements table:
</p>
<ul>
<li><p>The range constructors <code>X(i, j)</code> and <code>X u(i, j)</code>, which require that the 
container's value type is <i>Cpp17EmplaceConstructible</i> into the container from <code>*i</code>; 
implicit conversion is neither necessary nor sufficient.</p></li>
<li><p>The range insert overload <code>a.insert(p, i, j)</code> which also requires <i>Cpp17EmplaceConstructible</i>, 
as well as the capability to move elements around for <code>vector</code> and <code>deque</code>; again, 
implicit conversion is neither necessary nor sufficient. It <em>would</em> be useful / performant 
here to require that the container's value type is assignable from <code>*i</code>, which may have 
been the intent of the implicit conversion requirement &mdash; would doing so be too breaking?</p></li>
<li><p>The range assign overload <code>a.assign(i, j)</code> which requires both 
<i>Cpp17EmplaceConstructible</i> as above and that it can assign the result of dereferencing an 
iterator directly to the container's value type; again, implicit conversion is not useful here.</p></li>
</ul>
<p>
We should strike the implicit conversion requirement since it is not useful and only serves to confuse 
readers of the Standard (see e.g. <a href="https://github.com/microsoft/STL/issues/107">here</a>).
</p>

<p><i>[2019-10-31 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to <a href="https://wg21.link/N4830" title=" Committee Draft, Standard for Programming Language C++">N4830</a>.</p>

<ol>
<li><p>Modify 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote>
<p>
-3- In Tables 76 and 77, <code>X</code> denotes a sequence container class, <code>a</code> denotes a value 
of type <code>X</code> containing elements of type <code>T</code>, <code>u</code> denotes the name of a variable 
being declared, <code>A</code> denotes <code>X::allocator_type</code> if the <i>qualified-id</i>
<code>X::allocator_type</code> is valid and denotes a type (13.10.3 <a href="https://timsong-cpp.github.io/cppwp/temp.deduct">[temp.deduct]</a>) and 
<code>allocator&lt;T&gt;</code> if it doesn't, <code>i</code> and <code>j</code> denote iterators that meet 
the <i>Cpp17InputIterator</i> requirements <del>and refer to elements implicitly convertible to
<code>value_type</code></del>, <code>[i, j)</code> denotes a valid range, [&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2022-04-24; Daniel rebases wording on <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>]</i></p>



<p id="res-3297"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote>
<p>
-3- In this subclause,
</p>
<ol style="list-style-type:none">
<li><p>(3.1) &mdash; [&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(3.5) &mdash; <code>i</code> and <code>j</code> denote iterators that meet the <i>Cpp17InputIterator</i> 
requirements <del>and refer to elements implicitly convertible to <code>value_type</code></del>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3308"><a href="3308">3308</a>. <code>vector</code> and <code>deque</code> iterator <code>erase</code> invalidates elements even when no change occurs</h3>
<p><b>Section:</b> 23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a>, 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2019-10-29 <b>Last modified:</b> 2019-11-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#deque.modifiers">active issues</a> in [deque.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#deque.modifiers">issues</a> in [deque.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems incorrect that a container would invalidate anything as a result of being asked to erase 0 elements. 
This came up in a recent customer bug report against Visual Studio, where given a <code>vector v</code>, 
<code>v.erase(v.begin(), v.begin())</code> triggered a self-assignment of all the elements in the vector. 
<p/>
<code>deque</code> has language enumerating erasures of the first and last element which invalidate fewer 
iterators, and a fallback that says all iterators are invalidated, which seems to intend to be talking about middle-of-container erasures. However, erasing 0 elements isn't really a middle of container erasure.
<p/>
<code>vector</code> says that iterators and references are invalidated after the 'point of the erase', but when 0 
elements are erased it's unclear what that even means.
<p/>
We should say that erasures that erase 0 elements are no ops and be clearer about which elements are 
invalidated for <code>vector</code>.
</p>

<p><i>[2019-11 Priority to 3 during Monday issue prioritization in Belfast]</i></p>



<p id="res-3308"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4835">N4835</a>.</p>

<ol>
<li><p>Modify 23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_front();
void pop_back();
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> <ins>Erases elements as indicated in Table 75 [tab:container.seq.req].</ins> 
An erase operation that erases the last element of a deque invalidates only the past-the-end 
iterator and all iterators and references to the erased elements. An erase operation that erases 
the first element of a deque but not the last element invalidates only iterators and references 
to the erased elements. An erase operation that erases <ins>any elements, but</ins> neither the 
first element nor the last element of a deque invalidates the past-the-end iterator and all 
iterators and references to all the elements of the deque. <del>[<i>Note:</i> <code>pop_front</code> 
and <code>pop_back</code> are erase operations. &mdash; <i>end note</i>]</del>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> <ins>Erases elements as indicated in Table 75 [tab:container.seq.req].</ins> 
Invalidates iterators and references at or after the <del>point of the erase.</del><ins>first erased 
element. [<i>Note:</i> For the second overload of <code>erase</code>, if <code>first == last</code>, no 
elements are erased, and no iterators or references are invalidated. &mdash; <i>end note</i>]</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3309"><a href="3309">3309</a>. Is <code>&lt;ios&gt;</code> implicitly <code>#include</code>d by <code>&lt;sstream&gt;</code>, <code>&lt;fstream&gt;</code> etc.?</h3>
<p><b>Section:</b> 31.8 <a href="https://timsong-cpp.github.io/cppwp/string.streams">[string.streams]</a>, 31.10 <a href="https://timsong-cpp.github.io/cppwp/file.streams">[file.streams]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2019-11-01 <b>Last modified:</b> 2019-11-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.streams">issues</a> in [string.streams].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear whether the streams headers implicitly <code>#include &lt;ios&gt;</code> and make (for example) 
the name <code>std::basic_ios</code> available after including <code>&lt;sstream&gt;</code>.
<p/>
This question becomes more important as header units arrive with modules, where there is an explicit 
choice whether to re-export names from subordinate headers.
</p>

<p><i>[2019-11 Priority to 3 during Monday issue prioritization in Belfast]</i></p>



<p id="res-3309"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3337"><a href="3337">3337</a>. What is "is initialized" supposed to mean?</h3>
<p><b>Section:</b> 28.3.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2019-11-15 <b>Last modified:</b> 2019-11-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#locale.codecvt.virtuals">active issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt.virtuals">issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.3.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a> paragraphs 6 and 11, we find:
</p>
<blockquote>
<p>
<i>Preconditions:</i> <code>(to &lt;= to_end)</code> is well-defined and <code>true</code>; <code>state</code> 
is initialized, if at the beginning of a sequence, or else is equal to the result of converting 
the preceding characters in the sequence."
</p>
</blockquote>
<p>
This doesn't make sense. What is the value of <code>state</code> if we're at the beginning of a sequence? 
Is the fact that we say that it's initialized in that case supposed to imply that it need not be 
initialized otherwise?
<p/>
Perhaps this means "value-initialized" or "default-initialized" instead of merely "initialized"?
</p>

<p><i>[2019-11-30 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3337"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3339"><a href="3339">3339</a>. Move-constructed empty-container capacity</h3>
<p><b>Section:</b> 27.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, 23.3.13 <a href="https://timsong-cpp.github.io/cppwp/vector">[vector]</a>, 23.5.3 <a href="https://timsong-cpp.github.io/cppwp/unord.map">[unord.map]</a>, 23.5.6 <a href="https://timsong-cpp.github.io/cppwp/unord.set">[unord.set]</a>, 23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2019-11-17 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Standard leaves unspecified the <code>capacity()</code> of a <code>string</code> or <code>vector</code>, 
and <code>bucket_count()</code> of an <code>unordered_(multi)set</code> or <code>unordered_(multi)map</code>, 
constructed by move from an empty <code>other</code>.
<p/>
For a non-empty <code>other</code>, normative language in the Standard constrains the new object to 
use (mostly) the same storage as the other, by way of lifetime of iterators and pointers
to elements.
<p/>
For an empty <code>other</code>, there can be no such pointers or iterators. However, the empty 
container may have a non-zero <code>capacity()</code> or <code>bucket_count()</code>, and having reserved 
storage there, one naturally expects that storage to be delivered to the new object in the same 
way as if it had elements.
<p/>
Existing implementations, in fact, do move storage to the new container, provided it can be 
deallocated using the new object's allocator. It is likely that existing programs have come to 
depend on this behavior.
<p/>
The resolution proposed is to add language to the Standard specifying that, if the allocators 
of the existing and new container objects are compatible, the storage of the new object is the 
same as of the old, so that no allocations or deallocations are performed in the process, as 
existing implementations in fact do.
<p/>
This appears to affect only <code>string</code>, <code>vector</code>, <code>unordered_set</code>, 
<code>unordered_multiset</code>, <code>unordered_map</code>, and <code>unordered_multimap</code>, but any 
new container types may also need similar attention.
<p/>
Note that in the case of the hashed containers, the array of buckets appears not to be required 
to be moved, even when elements contained are. This seems to be a similar oversight; extant 
implementations do move the bucket array. The resolution should cover this case as well.
<p/>
It is expected and intended that the proposed resolution does not require changes to the behavior 
of implementations.
<p/>
See also LWG <a href="2321" title="Moving containers should (usually) be required to preserve iterators (Status: Open)">2321</a> and <a href="https://wg21.link/p0966r1">P0966R1</a>.
</p>

<p><i>[2019-11-30 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3339"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3341"><a href="3341">3341</a>. <code>basic_regex</code> range constructor: Missing requirements for iterator types</h3>
<p><b>Section:</b> 28.6.7.2 <a href="https://timsong-cpp.github.io/cppwp/re.regex.construct">[re.regex.construct]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> &Dcy;&iecy;&ncy;&icy;&scy; &Zcy;&acy;&khcy;&acy;&rcy;&ocy;&vcy; <b>Opened:</b> 2019-11-17 <b>Last modified:</b> 2022-04-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.regex.construct">active issues</a> in [re.regex.construct].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex.construct">issues</a> in [re.regex.construct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is description of a <code>basic_regex</code> range constructor from <a href="https://wg21.link/n4835">N4835</a>,
28.6.7.2 <a href="https://timsong-cpp.github.io/cppwp/re.regex.construct">[re.regex.construct]</a>:
</p>
<blockquote>
<pre>
template&lt;class ForwardIterator&gt;
  basic_regex(ForwardIterator first, ForwardIterator last,
              flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
<p>
-17- <i>Throws:</i> <code>regex_error</code> if the sequence <code>[first, last)</code> is not a valid regular expression.
<p/>
-18- <i>Effects:</i> Constructs an object of class <code>basic_regex</code>; the object's internal finite state 
machine is constructed from the regular expression contained in the sequence of characters <code>[first, last)</code>, 
and interpreted according to the flags specified in <code>f</code>.
<p/>
-19- <i>Ensures:</i> <code>flags()</code> returns <code>f. mark_count()</code> returns the number of marked sub-expressions 
within the expression.
</p>
</blockquote>
</blockquote>
<p>
It seems that there are no requirements about dereferenced iterator's element type, that, apparently, 
must be implicitly convertible to the <code>basic_regex::value_type</code>. For example, containers having 
range constructor satisfy a SequenceContainer requirements, where implicit converting to its elements 
is specified.
</p>

<p><i>[2019-11-30 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>

<p><i>[2021-10-04; Jonathan adds a comment]</i></p>

<p>
There isn't even a requirement that the arguments are iterators.
And <code>assign(InputIterator, InputIterator, flag_type)</code> is not
constrained to only accept iterators either, meaning you can call it with
two integers and call the
<code>basic_string(size_type, char_type)</code> constructor.
</p>

<p><i>[2022-04-22; Jonathan adds a comment]</i></p>

<p>
As well as requiring the reference type to be convertible to <code>charT</code>,
we might want to consider constraining these with <code>forward_iterator</code>
as per <a href="https://wg21.link/p2408">P2408</a>.
</p>


<p id="res-3341"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3342"><a href="3342">3342</a>. Library wording uses "initializes <code>x</code> with <code>y</code>", which is underspecified</h3>
<p><b>Section:</b> 22.3.2 <a href="https://timsong-cpp.github.io/cppwp/pairs.pair">[pairs.pair]</a>, 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>, 22.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/variant.ctor">[variant.ctor]</a>, 32.5.8.7.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.atomic.shared">[util.smartptr.atomic.shared]</a>, 20.6.3 <a href="https://timsong-cpp.github.io/cppwp/allocator.adaptor.cnstr">[allocator.adaptor.cnstr]</a>, 28.5.6.6 <a href="https://timsong-cpp.github.io/cppwp/format.parse.ctx">[format.parse.ctx]</a>, 28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/format.arg">[format.arg]</a>, 23.6 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors">[container.adaptors]</a>, 24.5 <a href="https://timsong-cpp.github.io/cppwp/predef.iterators">[predef.iterators]</a>, 25.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.ctor">[range.subrange.ctor]</a>, 25.6 <a href="https://timsong-cpp.github.io/cppwp/range.factories">[range.factories]</a>, 25.7 <a href="https://timsong-cpp.github.io/cppwp/range.adaptors">[range.adaptors]</a>, 26.10 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a>, 30.9 <a href="https://timsong-cpp.github.io/cppwp/time.hms">[time.hms]</a>, 28.6.11 <a href="https://timsong-cpp.github.io/cppwp/re.iter">[re.iter]</a>, 32.5.8 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic">[atomics.types.generic]</a>, 32.5.9 <a href="https://timsong-cpp.github.io/cppwp/atomics.nonmembers">[atomics.nonmembers]</a>, 32.3 <a href="https://timsong-cpp.github.io/cppwp/thread.stoptoken">[thread.stoptoken]</a>, 32.4 <a href="https://timsong-cpp.github.io/cppwp/thread.threads">[thread.threads]</a>, 32.6 <a href="https://timsong-cpp.github.io/cppwp/thread.mutex">[thread.mutex]</a>, 32.8 <a href="https://timsong-cpp.github.io/cppwp/thread.sema">[thread.sema]</a>, 32.9 <a href="https://timsong-cpp.github.io/cppwp/thread.coord">[thread.coord]</a>, 32.10 <a href="https://timsong-cpp.github.io/cppwp/futures">[futures]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2019-11-21 <b>Last modified:</b> 2019-12-08</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The problem was discussed <a href="https://github.com/cplusplus/draft/pull/3454#discussion_r348198610">here</a>:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
It seems to me that this is just one instance of a systemic problem in the library wording. This phrasing 
"initializes <code>x</code> with <code>y</code>" is common, but underspecified (and formally meaningless) &mdash; 
the library wording either needs to say what kind of initialization is performed, or specify an initializer 
(not an expression) with which to initialize. We should ask LWG to think about this; for each "initializes 
<code>x</code> with <code>y</code>" utterance, the reader should know what kind of initialization we mean.
<p/>
Looking at random through the library wording, the first case I found: 23.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/queue.cons">[queue.cons]</a>/1:
</p>
<blockquote><p>
<i>Effects:</i> Initializes <code>c</code> with <code>cont</code>.
</p></blockquote>
<p>
The meaning of this depends on whether this is direct- or copy-initialization. (It's obscure, but if <code>T</code> 
is not <i>Cpp17CopyInsertable</i> into the container, it could be the case that one form of initialization 
works and the other does not, or that they both work and do different things.)
<p/>
Another random sample: 26.10.7 <a href="https://timsong-cpp.github.io/cppwp/partial.sum">[partial.sum]</a>/2:
</p>
<blockquote><p>
<i>Effects:</i> For a non-empty range, the function creates an accumulator <code>acc</code> whose type is 
<code>InputIterator</code>'s value type, initializes it with <code>*first</code>, and assigns the result to <code>*result</code>.
</p></blockquote>
<p>
Again the difference between direct- and copy-initialization is observable here.
<p/>
Perhaps the library should have blanket wording that when it says "initializes", it means by 
direct- or copy-initialization, and that it's unspecified which one you get (or something like that) &mdash; 
and someone should go through all the instances and check if any of them mean something else (I doubt this 
is the only case that does).
</p>
</blockquote>
<p>
Suggestion: either
</p>
<ul>
<li><p>add blanket wording defining what you mean when you say "initializes <code>x</code> with <code>y</code>" 
(e.g., it's unspecified whether copy-initialization or direct-initialization is performed) and make sure 
that that's what's intended for all uses, or</p></li>
<li><p>stop using the "initializes <code>x</code> with <code>y</code>" formulation entirely, and specify the kind 
of initialization on each use, or</p></li>
<li><p>for each such use, ensure that <code>y</code> is an initializer (that is, of the form "<code>= expr</code>" 
or "<code>(expr, expr, &hellip;)</code>" or "<code>= { &hellip; }</code>" or "<code>{ &hellip; }</code>", and not 
merely an expression)</p></li>
</ul>

<p><i>[2019-12-08 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3342"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3343"><a href="3343">3343</a>. Ordering of calls to <code>unlock()</code> and <code>notify_all()</code> in <i>Effects</i> element of <code>notify_all_at_thread_exit()</code> should be reversed</h3>
<p><b>Section:</b> 32.7.3 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.nonmember">[thread.condition.nonmember]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2019-11-21 <b>Last modified:</b> 2023-06-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.7.3 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.nonmember">[thread.condition.nonmember]</a> p2 states:
</p>
<blockquote>
<p>
<i>Effects:</i> Transfers ownership of the lock associated with <code>lk</code> into internal storage 
and schedules <code>cond</code> to be notified when the current thread exits, after all objects of 
thread storage duration associated with the current thread have been destroyed. This notification 
shall be as if:
</p>
<blockquote><pre>
lk.unlock();
cond.notify_all();
</pre></blockquote>
</blockquote>
<p>
One common use-cases for the <code>notify_all_at_thread_exit()</code> is in conjunction with
<code>thread::detach()</code> to allow detached threads to signal when they complete and to allow 
another thread to wait for them to complete using the <code>condition_variable/mutex</code> pair.
<p/>
However, the current wording for <code>notify_all_at_thread_exit(condition_variable&amp; cond, 
unique_lock&lt;mutex&gt; lk)</code> makes it impossible to know when it is safe to destroy the 
<code>condition_variable</code> in the presence of spurious wake-ups and detached threads.
<p/>
For example: Consider the following code-snippet:
</p>
<blockquote><pre>
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

int main() {
  std::condition_variable cv;
  std::mutex mut;
  bool complete = false;

  std::thread{[&amp;] {
    <i>// do work here</i>

    <i>// Signal thread completion</i>
    std::unique_lock lk{mut};
    complete = true;
    std::notify_all_at_thread_exit(cv, std::move(lk));
  }}.detach();

  <i>// Wait until thread completes</i>
  std::unique_lock lk{mut};
  cv.wait(lk, [&amp;] { return complete; });

  <i>// condition_variable destroyed on scope exit</i>
  return 0;
}
</pre></blockquote>
<p>
This seems to an intended usage of <code>thread::detach()</code> and <code>std::notify_all_at_thread_exit()</code> 
and yet this code contains a race involving the call to <code>cv.notify_all()</code> on the created thread, 
and the destructor of the <code>condition_variable</code>.
<p/>
To highlight the issue, consider the following case:
<p/>
Let <code>T0</code> be the thread that executes <code>main()</code> and <code>T1</code> be the thread created 
by the <code>std::thread</code> construction.
</p> 
<blockquote>
<p>
<code>T0</code>: creates thread <code>T1</code><br/>
<code>T0</code>: context-switched out by OS<br/>
<code>T1</code>: starts running<br/>
<p/>
<code>T1</code>: acquires mutex lock<br/>
<code>T1</code>: sets <code>complete = true</code><br/>
<p/>
<code>T1</code>: calls <code>notify_all_at_thread_exit()</code><br/>
<code>T1</code>: returns from thread-main function and runs all thread-local destructors<br/>
<code>T1</code>: calls <code>lk.unlock()</code><br/>
<code>T1</code>: context-switched out by OS<br/>
<code>T0</code>: resumes execution<br/>
<code>T0</code>: acquires mutex lock<br/>
<code>T0</code>: calls <code>cv.wait()</code> which returns immediately as <code>complete</code> is <code>true</code><br/>
<p/>
<code>T0</code>: returns from <code>main()</code>, destroying <code>condition_variable</code><br/>
<code>T1</code>: resumes execution<br/>
<p/>
<code>T1</code>: calls <code>cv.notify_all()</code> on a dangling <code>cv</code> reference (undefined behaviour)<br/>
</p>
</blockquote>
<p>
Other sequencings are possible involving spurious wake-ups of the <code>cv.wait()</code> call.
<p/>
A proof-of-concept showing this issue can be found <a href="https://wandbox.org/permlink/eUu3eiQbLl7JQKMm">here</a>.
<p/>
The current wording requires releasing the mutex lock before calling <code>cv.notify_all()</code>. In the 
presence of spurious wake-ups of a <code>condition_variable::wait()</code>, there is no way to know whether 
or not a detached thread that called <code>std::notify_all_at_thread_exit()</code> has finished calling 
<code>cv.notify_all()</code>. This means there is no portable way to know when it will be safe for the 
waiting thread to destroy that <code>condition_variable</code>.
<p/>
However, if we were to reverse the order of the calls to <code>lk.unlock()</code> and <code>cond.notify_all()</code> 
then the thread waiting for the detached thread to exit would not be able to observe the completion of the 
thread (in the above case, this would be observing the assignment of <code>true</code> to the <code>complete</code> 
variable) until the mutex lock was released by that thread and subsequently acquired by the waiting thread 
which would only happen after the completion of the call to <code>cv.notify_all()</code>. This would allow the 
above code example to eliminate the race between a subsequent destruction of the condition-variable and 
the call to <code>cv.notify_all()</code>.
</p>

<p><i>[2019-12-08 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>

<p><i>[2019-12-15; Daniel synchronizes wording with <a href="https://wg21.link/n4842">N4842</a>]</i></p>


<p><i>[2020-02, Prague]</i></p>

<p>Response from SG1: "We discussed it in Prague. We agree its an error and SG1 agreed with the PR."</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>This wording is relative to <a href="https://wg21.link/n4842">N4842</a>.</p>

<ol>
<li><p>Change 32.7.3 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.nonmember">[thread.condition.nonmember]</a> as indicated:</p>

<blockquote>
<pre>
void notify_all_at_thread_exit(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lk);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Effects:</i> Transfers ownership of the lock associated with <code>lk</code> into internal 
storage and schedules <code>cond</code> to be notified when the current thread exits, after all 
objects of thread storage duration associated with the current thread have been destroyed. 
This notification is equivalent to:
</p>
<blockquote><pre>
<del>lk.unlock();</del>
cond.notify_all();
<ins>lk.unlock();</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2023-06-13, Varna; Tim provides improved wording]</i></p>

<p>Addressed mailing list comments. Ask SG1 to check.</p>



<p id="res-3343"><b>Proposed resolution:</b></p>

<p>This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.</p>

<ol>
<li><p>Change 32.7.3 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.nonmember">[thread.condition.nonmember]</a> as indicated:</p>

<blockquote>
<pre>
void notify_all_at_thread_exit(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lk);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Effects:</i> Transfers ownership of the lock associated with <code>lk</code> into internal
storage and schedules <code>cond</code> to be notified when the current thread
exits<del>,</del><ins>.  This notification is sequenced</ins> after all
objects of thread storage duration associated with the current thread have been
destroyed<del>.  This notification</del> <ins>and</ins> is equivalent to:
</p>
<blockquote><pre>
<del>lk.unlock();</del>
cond.notify_all();
<ins>lk.unlock();</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3344"><a href="3344">3344</a>. <code>advance(i, <i>most-negative</i>)</code> and <code>prev(i, <i>most-negative</i>)</code></h3>
<p><b>Section:</b> 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a>, 24.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iter.op.advance">[range.iter.op.advance]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2019-11-22 <b>Last modified:</b> 2019-12-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>ranges::advance</code> (24.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iter.op.advance">[range.iter.op.advance]</a>) and <code>std::advance</code> 
(24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a>) can be called with a negative count <code>n</code> when the 
iterator argument <code>i</code> models <code>bidirectional_iterator</code> (respectively, meets the 
<i>Cpp17BidirectionalIterator</i> requirements). In this case, they are specified to "decrement <code>i</code> 
by <code>-n</code>". If <code>n</code> is the most-negative value of a signed integral type, the expression <code>-n</code> 
has undefined behavior. This UB is unfortunate given that typical implementations never actually 
form the expression <code>-n</code>. It's nonsensical to describe the effects of a function in terms 
of an expression with undefined behavior, so we should either define the behavior or exclude 
this case via precondition.
<p/>
<code>ranges::prev()</code> and <code>std::prev</code> (24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a>) have a similar problem: 
<code>prev(i, n)</code> is equivalent to:
</p>
<blockquote><pre>
advance(i, -n); 
return i;
</pre></blockquote>
<p>
which has undefined behavior when <code>n</code> is <code>numeric_limits&lt;T&gt;::min()</code> where <code>T</code> 
is <code>iter_difference_t&lt;decltype(i)&gt;</code> (for <code>ranges::prev</code>) or some signed integral type 
(for <code>std::prev</code>). There <em>is</em> an implicit precondition here thanks to "<i>Effects:</i> Equivalent 
to" since the equivalent code has a precondition that <code>n</code> is not a most-negative value, so 
this wording is not defective. We could, however, define behavior for <code>prev</code> regardless of the 
value of <code>n</code> by duplicating the specification of advance and inverting the "direction" of the 
operations. We should consider doing so.
</p>

<p><i>[2019-12-07 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3344"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4835">N4835</a>.</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> I've chosen to provide wording for the conservative "define behavior for 
<code>advance</code> and leave <code>prev</code> as status quo" middle ground.
<p/>
The occurrences of "|" in the below are math-font vertical bars (indicating absolute value). I've 
changed both positive and negative cases for consistency of presentation.
]
</p>
</blockquote>

<ol>
<li><p>Modify 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class Distance&gt;
  constexpr void advance(InputIterator&amp; i, Distance n);
</pre>
<blockquote>
<p>
-2- <i>Expects:</i> <code>n</code> is negative only for bidirectional iterators.
<p/>
-3- <i>Effects:</i> Increments <code>i</code> by <code><ins>|</ins>n<ins>|</ins></code> if <code>n</code> is 
non-negative, and decrements <code>i</code> by <code><del>-</del><ins>|</ins>n<ins>|</ins></code> otherwise.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 24.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iter.op.advance">[range.iter.op.advance]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;input_or_output_iterator I&gt;
  constexpr void ranges::advance(I&amp; i, iter_difference_t&lt;I&gt; n);
</pre>
<blockquote>
<p>
-1- <i>Expects:</i> If <code>I</code> does not model <code>bidirectional_iterator</code>, <code>n</code> is not negative.
<p/>
-2- <i>Effects:</i>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>I</code> models <code>random_access_iterator</code>, 
equivalent to <code>i += n</code>.</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code>n</code> is non-negative, increments <code>i</code> by 
<code><ins>|</ins>n<ins>|</ins></code>.</p></li>
<li><p>(2.3) &mdash; Otherwise, decrements <code>i</code> by <code><del>-</del><ins>|</ins>n<ins>|</ins></code>.</p></li>
</ol>
</p>
</blockquote>
[&hellip;]
<pre>
template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
  constexpr iter_difference_t&lt;I&gt; ranges::advance(I&amp; i, iter_difference_t&lt;I&gt; n, S bound);
</pre>
<blockquote>
<p>
-5- <i>Expects:</i> [&hellip;]
<p/>
-6- <i>Effects:</i>
<ol style="list-style-type: none">
<li><p>(6.1) &mdash; If <code>S</code> and <code>I</code> model 
<code>sized_sentinel_for&lt;S, I&gt;</code>:</p>
<ol style="list-style-type: none">
<li><p>(6.1.1) &mdash; If <code>|n| &ge; |bound - i|</code>, equivalent to <code>ranges::advance(i, bound)</code>.:</p>
</li>
<li><p>(6.1.2) &mdash; Otherwise, equivalent to <code>ranges::advance(i, n)</code>.</p></li>
</ol>
</li>
<li><p>(6.2) &mdash; Otherwise,</p>
<ol style="list-style-type: none">
<li><p>(6.2.1) &mdash; if <code>n</code> is non-negative, while <code>bool(i != bound)</code> is <code>true</code>, 
increments <code>i</code> but at most <code><ins>|</ins>n<ins>|</ins></code> times.:</p>
</li>
<li><p>(6.2.2) &mdash; Otherwise, while <code>bool(i != bound)</code> is <code>true</code>, decrements <code>i</code> 
but at most <code><del>-</del><ins>|</ins>n<ins>|</ins></code> times.</p></li>
</ol>
</li>
</ol>
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3353"><a href="3353">3353</a>. <code>locale</code>'s copy assignment operator should return <code>locale&amp;</code></h3>
<p><b>Section:</b> 28.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/locale">[locale]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2019-12-06 <b>Last modified:</b> 2019-12-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Curiously, <code>locale</code>'s copy assignment operator currently returns <code>const locale&amp;</code>. As Casey 
Carter noted in <a href="https://github.com/microsoft/STL/issues/268">microsoft/STL#268</a>, this is:
</p>
<ul>
<li><p>Weird!</p></li>
<li><p>The only occurrence in the entire Standard Library.</p></li>
<li><p>Preventing <code>locale</code> from satisfying <code>std::copyable</code>.</p></li>
</ul>
<p>
We aren't aware of any reason for this to be <code>const</code>. (I observe that this hasn't changed since 
<a href="https://wg21.link/n1804">N1804</a> on 2005-04-27 and probably goes back to C++98; I suspect that 
when this was originally specified, copy assignment operators were relatively new, and conventions for 
them weren't rigorously followed.)
</p>

<p><i>[2019-12-21 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion based on the observation that we have implementation
divergence.</p>


<p id="res-3353"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4842">N4842</a>.</p>

<ol>
<li><p>Modify 28.3.3.1 <a href="https://timsong-cpp.github.io/cppwp/locale">[locale]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
~locale(); <i>// not virtual</i>
<del>const</del> locale&amp; operator=(const locale&amp; other) noexcept;
template&lt;class Facet&gt; locale combine(const locale&amp; other) const;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 28.3.3.1.3 <a href="https://timsong-cpp.github.io/cppwp/locale.cons">[locale.cons]</a> as indicated:</p>

<blockquote>
<pre>
<del>const</del> locale&amp; operator=(const locale&amp; other) noexcept;
</pre>
<blockquote>
<p>
-14- <i>Effects:</i> Creates a copy of <code>other</code>, replacing the current value.
<p/>
-15- <i>Returns:</i> <code>*this</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>



<hr>
<h3 id="3357"><a href="3357">3357</a>. [fund.ts.v3] <code>default_random_engine</code> is overspecified for per-thread engine</h3>
<p><b>Section:</b> 99 [fund.ts.v3::rand.util.randint] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2019-12-10 <b>Last modified:</b> 2022-11-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
Although "implementation may select this type on the basis of performance, size,
quality, or any combination of such factors," but changing this typedef is an ABI-break
for implementations. Specifying per-thread engine to use this typedef results in losses
of performance, size, and/or quality.
<p/>
Since this type is not involved in <code>randint</code> facilities' interface (other than its member
typedef), the current specification should be relaxed.
</p>

<p><i>[2020-01 Priority set to 3 and assigned to LEWG after review on the reflector.]</i></p>


<p><i>[2020-05-28; LEWG issue reviewing]</i></p>

<p>
LEWG issue processing voted to reject 3357 as NAD. Status change to Open.
</p>
<blockquote>
<pre>
Reject LWG3357 as NAD

SF  F N A SA
1  10 4 2 1
</pre>
</blockquote>

<p><i>[2022-10-19; Reflector poll]</i></p>

<p>
Set status to "Tentatively NAD" based on LEWG recommendation and reflector poll.
</p>

<p><i>[2022-11-30; LWG telecon]</i></p>

<p>
Prefer to keep an open issue for the TS than to possibly forget to address it
if this feature is proposed for the IS some day.
</p>



<p id="res-3357"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4840">N4840</a>.</p>

<ol>
<li><p>Modify 11.1.1 [fund.ts.v3::rand.syn], header <code>&lt;experimental/random&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;random&gt;

namespace std::experimental {
inline namespace fundamentals_v3 {

  <i>// 10.1.2.1, Function template randint</i>
  template &lt;class IntType&gt;
  IntType randint(IntType a, IntType b);
  void reseed();
  void reseed(<del>default_random_engine::result_type</del><ins>uint_fast32_t</ins> value);

} // inline namespace fundamentals_v3
} // namespace std::experimental
</pre>
</blockquote>
</li>

<li><p>Modify 99 [fund.ts.v3::rand.util.randint] as indicated:</p>

<blockquote>
<p>
-1- A separate <i>per-thread engine</i> of <del>type <code>default_random_engine</code> 
(C++17 &sect;29.6.5)</del><ins>unspecified type that meets the requirements of random 
number engine (C++17 [rand.req.eng])</ins>, initialized to an unpredictable state, 
shall be maintained for each thread. <ins>[<i>Note:</i> The implementation may choose 
the engine type on the basis of performance, size, quality, or any combination of such 
factors, so as to provide at least acceptable engine behavior for relatively casual, 
inexpert, and/or lightweight use. &mdash; <i>end note</i>]</ins>
</p>
[&hellip;]
<pre>
void reseed();
void reseed(<del>default_random_engine::result_type</del><ins>uint_fast32_t</ins> value);
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Let <code>g</code> be the per-thread engine. The first form sets <code>g</code> to an unpredictable 
state. The second form invokes <code>g.seed(value)</code>.
<p/>
-8- <i>Postconditions:</i> Subsequent calls to <code>randint</code> do not depend on values produced by <code>g</code> 
before calling reseed. [<i>Note:</i> <code>reseed</code> also resets any instances of 
<code>uniform_int_distribution</code> used by <code>randint</code>. &mdash; <i>end note</i>] 
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3 id="3370"><a href="3370">3370</a>. &sect;[cstdint.syn]p2 and &sect;[headers]p5 are not sufficiently clear</h3>
<p><b>Section:</b> 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>, 16.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dawid Pilarski <b>Opened:</b> 2020-01-14 <b>Last modified:</b> 2020-01-25</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue has been submitted, because the editorial change requests 
<a href="https://github.com/cplusplus/draft/issues/3521">c++-draft-issue 3521</a> and
<a href="https://github.com/cplusplus/draft/pull/3528">c++-draft-pull request 3528</a>
has been rejected as not being editorial changes:
</p>
<p>
Currently given wording of 17.4.1 <a href="https://timsong-cpp.github.io/cppwp/cstdint.syn">[cstdint.syn]</a>p2:
</p>
<blockquote><p>
The header defines all types and macros the same as the C standard library header <code>&lt;stdint.h&gt;</code>.
</p></blockquote>
<p>
might be understood as intended: typedefs inside <code>stdint.h</code> and inside <code>cstdint</code> in namespace 
<code>std::</code> refer to the same types, but another interpretation could be, that it's understood as:
<p/>
Definitions in both files are done the same way (<code>cstdint</code> provides typedefs not in namespace 
<code>std</code>, because it would be a different definition than one in <code>stdint.h</code>).
<p/>
Also 16.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a>p5 is non sufficiently clear:
</p>
<blockquote><p>
[&hellip;] the contents of each header <code>c<i>name</i></code> is the same as that of the corresponding header 
<code><i>name</i>.h</code> [&hellip;]
</p></blockquote>
<p>
As it doesn't say what does "same content" mean. For example is an implementation allowed to do following:
</p>
<blockquote><pre>
// __impl.h
typedef int __my_int;
namespace std { typedef long __my_int; }

// cname header
#include "__impl.h"

namespace std {
  typedef __my_int uint32_t;
}

// name.h header
#include "__impl.h"
typedef __my_int uint32_t;
</pre></blockquote>
<p>
? 
<p/>
In this case typedef from namespace <code>std</code> and from global namespace refer to different types?
<p/>
Proposed change:
<p/>
Apply wording, that will unambiguously make typedefs from namespace <code>std</code> refer to the same types 
as typedefs from global namespace for all headers <code><i>name</i>.h</code> and their corresponding headers 
<code>c<i>name</i></code>.
</p>

<p><i>[2020-01-25 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>

<p id="res-3370"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3378"><a href="3378">3378</a>. <code>tuple_size_v/tuple_element_t</code> should be available when <code>tuple_size/tuple_element</code> are</h3>
<p><b>Section:</b> 22.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.syn">[tuple.syn]</a>, 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-01-17 <b>Last modified:</b> 2021-11-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>/6 makes the <code>const</code>/<code>volatile</code>/<code>const volatile</code> partial 
specializations of <code>tuple_size</code> available when any of <code>&lt;array&gt;</code>, <code>&lt;ranges&gt;</code>, 
<code>&lt;span&gt;</code>, or <code>&lt;utility&gt;</code> is included. 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>/8 makes the 
<code>const</code>/<code>volatile</code>/<code>const volatile</code> partial specializations of <code>tuple_element</code> 
available when any of those same headers is included. This leads to a couple of problems:
</p>
<ol>
<li><p>For users of the Standard Library, it's not helpful to have these partial specializations of class 
templates available when the preferred interface &mdash; the variable template <code>tuple_size_v</code> and 
alias template <code>tuple_element_t</code> &mdash; are not.</p></li>
<li><p>For specifiers of the Standard Library, we must update two distinct yet identical lists of headers 
that make this same set of templates available when adding another header.</p></li></ol>
<p>
We could solve both of these problems by coalescing the two paragraphs into one and including the variable 
and alias template in the set of declarations made available by the pertinent (now single) list of headers.
</p>

<p><i>[2020-02-08 Issue Prioritization]</i></p>

<p>
Priority to 3 after reflector discussion.
Tim Song said: Its not clear that entities only mentioned in the synopsis are "defined in this subclause".
</p>

<p><i>[2021-11-04; Jonathan Wakely adds note]</i></p>

<p>
The <code>__cpp_lib_tuple_element_t</code> macro in
17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> should be updated too.
</p>



<p id="res-3378"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4842">N4842</a>.</p>

<ol>
<li><p>Modify 22.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.syn">[tuple.syn]</a>, header <code>&lt;tuple&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]

  <i>// 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>, tuple helper classes</i>
  template&lt;class T&gt; struct tuple_size; // not defined
  template&lt;class T&gt; struct tuple_size&lt;const T&gt;;
  template&lt;class T&gt; struct tuple_size&lt;volatile T&gt;;
  template&lt;class T&gt; struct tuple_size&lt;const volatile T&gt;;
  
  <ins>template&lt;class T&gt;
    inline constexpr size_t tuple_size_v = tuple_size&lt;T&gt;::value;</ins>
  <del>template&lt;class... Types&gt; struct tuple_size&lt;tuple&lt;Types...&gt;&gt;;</del>
  
  template&lt;size_t I, class T&gt; struct tuple_element; <i>// not defined</i>
  template&lt;size_t I, class T&gt; struct tuple_element&lt;I, const T&gt;;
  template&lt;size_t I, class T&gt; struct tuple_element&lt;I, volatile T&gt;;
  template&lt;size_t I, class T&gt; struct tuple_element&lt;I, const volatile T&gt;;
  
  <del>template&lt;size_t I, class... Types&gt;
    struct tuple_element&lt;I, tuple&lt;Types...&gt;&gt;;</del>
  
  template&lt;size_t I, class T&gt;
    using tuple_element_t = typename tuple_element&lt;I, T&gt;::type;
    
  <i>// 22.4.8 <a href="https://timsong-cpp.github.io/cppwp/tuple.elem">[tuple.elem]</a>, element access</i>
  <ins>template&lt;class... Types&gt; struct tuple_size&lt;tuple&lt;Types...&gt;&gt;;</ins>
  
  <ins>template&lt;size_t I, class... Types&gt;
    struct tuple_element&lt;I, tuple&lt;Types...&gt;&gt;;</ins>
  
  template&lt;size_t I, class... Types&gt;
    constexpr tuple_element_t&lt;I, tuple&lt;Types...&gt;&gt;&amp; get(tuple&lt;Types...&gt;&amp;) noexcept;
  template&lt;size_t I, class... Types&gt;
    constexpr tuple_element_t&lt;I, tuple&lt;Types...&gt;&gt;&amp;&amp; get(tuple&lt;Types...&gt;&amp;&amp;) noexcept;
  [&hellip;]
  
  <del><i>// 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>, tuple helper classes</i></del>
  <del>template&lt;class T&gt;
    inline constexpr size_t tuple_size_v = tuple_size&lt;T&gt;::value;</del>
}
</pre>
</blockquote>
</li>

<li><p>Modify 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a> as indicated:</p>

<blockquote>
<p>
<b>20.5.6 Tuple helper classes [tuple.helper]</b>
<p/>
<ins>-?- In addition to being available via inclusion of the <code>&lt;tuple&gt;</code> header, the entities 
defined in this subclause [tuple.helper] are available when any of the headers <code>&lt;array&gt;</code> 
(23.3.2 <a href="https://timsong-cpp.github.io/cppwp/array.syn">[array.syn]</a>), <code>&lt;ranges&gt;</code> (25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>), <code>&lt;span&gt;</code> 
(23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a>), or <code>&lt;utility&gt;</code> (22.2.1 <a href="https://timsong-cpp.github.io/cppwp/utility.syn">[utility.syn]</a>) are included.</ins>
</p>
<pre>
template&lt;class T&gt; struct tuple_size;
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> All specializations of <code>tuple_size</code> shall meet the <i>Cpp17UnaryTypeTrait</i> 
requirements (21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) with a base characteristic of <code>integral_constant&lt;size_t, N&gt;</code> 
for some <code>N</code>.
</p>
</blockquote>
<pre>
<del>template&lt;class... Types&gt;
  struct tuple_size&lt;tuple&lt;Types...&gt;&gt; : public integral_constant&lt;size_t, sizeof...(Types)&gt; { };

template&lt;size_t I, class... Types&gt;
  struct tuple_element&lt;I, tuple&lt;Types...&gt;&gt; {
    using type = TI;
  };</del>
</pre>
<blockquote>
<p>
<del>-2- <i>Requires:</i> <code>I &lt; sizeof...(Types)</code>. The program is ill-formed if <code>I</code> is out of bounds.</del>
<p/>
<del>-3- <i>Type:</i> <code>TI</code> is the type of the <code>I<sup>th</sup></code> element of <code>Types</code>, where 
indexing is zero-based.</del>
</p>
</blockquote>
<pre>
template&lt;class T&gt; struct tuple_size&lt;const T&gt;;
template&lt;class T&gt; struct tuple_size&lt;volatile T&gt;;
template&lt;class T&gt; struct tuple_size&lt;const volatile T&gt;;
</pre>
<blockquote>
<p>
-4- Let <code>TS</code> denote <code>tuple_size&lt;T&gt;</code> of the <i>cv</i>-unqualified type <code>T</code>. 
If the expression <code>TS::value</code> is well-formed when treated as an unevaluated operand, then each 
of the three templates shall meet the <i>Cpp17UnaryTypeTrait</i> requirements (21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) 
with a base characteristic of
<blockquote><pre>
integral_constant&lt;size_t, TS::value&gt;
</pre></blockquote>
Otherwise, they shall have no member value.
<p/>
-5- Access checking is performed as if in a context unrelated to <code>TS</code> and <code>T</code>. Only the 
validity of the immediate context of the expression is considered. [<i>Note:</i> The compilation of the 
expression can result in side effects such as the instantiation of class template specializations and 
function template specializations, the generation of implicitly-defined functions, and so on. Such side 
effects are not in the "immediate context" and can result in the program being ill-formed. &mdash; <i>end note</i>]
<p/>
<del>-6- In addition to being available via inclusion of the <code>&lt;tuple&gt;</code> header, the three 
templates are available when any of the headers <code>&lt;array&gt;</code> (23.3.2 <a href="https://timsong-cpp.github.io/cppwp/array.syn">[array.syn]</a>), 
<code>&lt;ranges&gt;</code> (25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>), <code>&lt;span&gt;</code> (23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a>), 
or <code>&lt;utility&gt;</code> (22.2.1 <a href="https://timsong-cpp.github.io/cppwp/utility.syn">[utility.syn]</a>) are included.</del>
</p>
</blockquote>
<pre>
template&lt;size_t I, class T&gt; struct tuple_element&lt;I, const T&gt;;
template&lt;size_t I, class T&gt; struct tuple_element&lt;I, volatile T&gt;;
template&lt;size_t I, class T&gt; struct tuple_element&lt;I, const volatile T&gt;;
</pre>
<blockquote>
<p>
-7- Let <code>TE</code> denote <code>tuple_element_t&lt;I, T&gt;</code> of the <i>cv</i>-unqualified type <code>T</code>. 
Then each of the three templates shall meet the <i>Cpp17TransformationTrait</i> requirements 
(21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) with a member typedef type that names the following type:
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; for the first specialization, <code>add_const_t&lt;TE&gt;</code>,</p></li>
<li><p>(7.2) &mdash; for the second specialization, <code>add_volatile_t&lt;TE&gt;</code>, and</p></li>
<li><p>(7.3) &mdash; for the third specialization, <code>add_cv_t&lt;TE&gt;</code>.</p></li>
</ol>
<del>-8- In addition to being available via inclusion of the <code>&lt;tuple&gt;</code> header, the three 
templates are available when any of the headers <code>&lt;array&gt;</code> (23.3.2 <a href="https://timsong-cpp.github.io/cppwp/array.syn">[array.syn]</a>), 
<code>&lt;ranges&gt;</code> (25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>), <code>&lt;span&gt;</code> (23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a>), 
or <code>&lt;utility&gt;</code> (22.2.1 <a href="https://timsong-cpp.github.io/cppwp/utility.syn">[utility.syn]</a>) are included.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.4.8 <a href="https://timsong-cpp.github.io/cppwp/tuple.elem">[tuple.elem]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Since this issue performs colliding text changes with 
<a href="https://wg21.link/p1460r0">P1460R0</a>, we perform similar wording changes as suggested
on <a href="https://wg21.link/p1460r0#page=19">page 19 [tuple.helper] p2</a>.]
</p>
</blockquote>

<blockquote>
<p>
<b>20.5.7 Element access [tuple.elem]</b>
</p>
<pre>
<ins>template&lt;class... Types&gt;</ins>
  <ins>struct tuple_size&lt;tuple&lt;Types...&gt;&gt; : public integral_constant&lt;size_t, sizeof...(Types)&gt; { };</ins>

<ins>template&lt;size_t I, class... Types&gt;</ins>
  <ins>struct tuple_element&lt;I, tuple&lt;Types...&gt;&gt; {</ins>
    <ins>using type = TI;</ins>
  <ins>};</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates:</i> <code>I &lt; sizeof...(Types)</code>.</ins>
<p/>
<ins>-?- Type: <code>TI</code> is the type of the <code>I<sup>th</sup></code> element of <code>Types</code>, where 
indexing is zero-based.</ins>
</p>
</blockquote>
<pre>
template&lt;size_t I, class... Types&gt;
  constexpr tuple_element_t&lt;I, tuple&lt;Types...&gt;&gt;&amp;
    get(tuple&lt;Types...&gt;&amp; t) noexcept;
[&hellip;]
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3400"><a href="3400">3400</a>. Does <code>is_nothrow_convertible</code> consider destruction of the destination type?</h3>
<p><b>Section:</b> 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2020-02-10 <b>Last modified:</b> 2023-12-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.rel">active issues</a> in [meta.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue was submitted after a previous <a href="https://github.com/cplusplus/draft/issues/3576">editorial 
change request</a> had been rejected by the project editors.
<p/>
I find that all known implementations (at least 
<a href="https://github.com/microsoft/STL/blob/master/stl/inc/type_traits#L1658">msvcstl</a>, 
<a href="https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits#L1506">libc++</a>, 
<a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/type_traits#L1458">libstdc++</a> and the sample in <a href="https://wg21.link/p0758r1#Appendix">P0758R1</a>) of <code>std::is_nothrow_convertible</code>
may be not clear enough to indicate that whether destruction of the destination type is considered (or not).
<p/>
For example, given a type <code>Weird</code> defined as
</p>
<blockquote><pre>
struct Weird 
{
  Weird(int) noexcept {}
  ~Weird() noexcept(false) {}
};
</pre></blockquote>
<p>
Then <code>std::is_nothrow_convertible_v&lt;int, Weird&gt;</code> is <code>false</code> in every known implementation. 
However, it seems that the conversion itself is <code>noexcept</code>.
</p>

<p><i>[2020-02-22, Daniel comments]</i></p>

<p>
This seems to be quite related to the existing issue LWG <a href="2116" title="is_nothrow_constructible and destructors (Status: Open)">2116</a>.
</p>

<p><i>[2020-03-11 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>

<p><i>[2023-12-22; Daniel comments]</i></p>

<p>
This issue should be resolved by LWG <a href="4028" title="std::is_(nothrow_)convertible should be reworded to avoid dependence on the return statement (Status: New)">4028</a>.
</p>


<p id="res-3400"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3401"><a href="3401">3401</a>. Is "as if by" equivalent to "equivalent to"?</h3>
<p><b>Section:</b> 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-02-14 <b>Last modified:</b> 2020-03-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have quite a few occurrences of the phrase "as if by" in <i>Effects:</i> elements in the 
library specification. Is the meaning of this phrase the same as "equivalent to"? If so, we 
should replace occurrences of "as if by" with "equivalent to" to make it clear that the magic 
"<i>Effects:</i> Equivalent to" wording in 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> para 4 
is intended to apply.
</p>

<p><i>[2020-03-11 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3401"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3402"><a href="3402">3402</a>. Wording for <code>negative_binomial_distribution</code> is unclear as a consequence of LWG 2406 resolution</h3>
<p><b>Section:</b> 29.5.9.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern.negbin">[rand.dist.bern.negbin]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ahti Lepp&auml;nen <b>Opened:</b> 2020-02-17 <b>Last modified:</b> 2020-03-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.bern.negbin">issues</a> in [rand.dist.bern.negbin].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue has been created because a corresponding 
<a href="https://github.com/cplusplus/draft/issues/3606">editorial change request</a> had been rejected.
<p/>
The resolution of LWG <a href="2406" title="negative_binomial_distribution should reject p == 1 (Status: C++17)">2406</a> added a note to the definition of <code>negative_binomial_distribution</code>:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
[<i>Note</i>: This implies that <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>P</mi><mrow><mo>(</mo><mi>i</mi><mo>|</mo><mi>k</mi><mo>,</mo><mi>p</mi><mo>)</mo></mrow> 
</math> is undefined when <code>p == 1</code>. &mdash; <i>end note</i>]
</p>
</blockquote>
<p>
This issue argues that the note is invalid as are the premises on which LWG 2406 was based 
on. It's also argued that current normative standard text allowing <code>p == 1</code> is valid 
both conceptually and mathematically, and that it follows existing conventions in other software.
<p/>
Problems with the added note:
</p>
<ul>
<li><p>Why does <code>p == 1</code> imply that <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>P</mi><mrow><mo>(</mo><mi>i</mi><mo>|</mo><mi>k</mi><mo>,</mo><mi>p</mi><mo>)</mo></mrow> 
</math> is undefined? The only questionable factor in the definition of 
<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mrow><mo>(</mo><mi>i</mi><mo>|</mo>
<mi>k</mi><mo>,</mo><mi>p</mi><mo>)</mo></mrow></math> seems to be that in case of 
<code>p == 1</code>, the factor <code>(1 - p)<sup>i</sup></code> leads to <code>0<sup>0</sup></code> 
when <code>i == 0</code>. While it is true that there's 
<a href="https://en.wikipedia.org/wiki/Zero_to_the_power_of_zero">no generally accepted convention</a> 
what this means, <code>std::binomial_distribution</code> already uses the common convention 
<code>0<sup>0</sup> == 1</code> (e.g. with <code>p == 1 &amp;&amp; t == i</code>, 
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>P</mi><mrow><mo>(</mo><mi>i</mi><mo>|</mo><mi>k</mi><mo>,</mo><mi>p</mi><mo>)</mo></mrow> 
</math> leads to <code>0<sup>0</sup></code>)</p></li>
<li><p>Even if the term was undefined mathematically, does a non-normative note of
mathematical term being undefined mean that the behaviour of the program is
undefined (instead of e.g. resulting to NaN) even when no preconditions are violated?</p></li>
<li><p>The note has lead to unclear situation of being able to construct a
distribution object, but calling <code>operator()</code> might lead to undefined behaviour
even though no preconditions are violated: for example the 
<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/random/negative_binomial_distribution/negative_binomial_distribution&amp;oldid=102755">cppreference.com notes</a> that 
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
If <code>p == 1</code>, subsequent calls to the <code>operator()</code> overload that does not
accept a <code>param_type</code> object will cause undefined behavior.
</p>
</blockquote>
</li>
</ul>
<p>
Invalidity of premises of LWG 2406:
</p>
<ul>
<li>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
For <code>p == 1</code>, this is "<code>* 1^k * 0^i</code>", so every integer 
<code>i &gt;= 0</code> is produced with zero probability. (Let's avoid thinking about 
<code>0^0</code>.)
</p>
</blockquote>
<ul>
<li><p>This is contradictory: first assuming that <code>0^i == 0</code> for all 
<code>i &gt;= 0</code> (implying that <code>0^0 == 0</code>), but then comments not to 
think about <code>0^0</code>. The very essence of the issue is interpretation of 
<code>0^0</code> and given the definition of <code>binomial_distribution</code>, 
where <code>0^0 == 1</code>, the claim "so every integer <code>i &gt;= 0</code> is 
produced with zero probability" can be considered faulty.
</p></li>
</ul>
</li>
<li>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Wikipedia states that <code>p</code> must be within <code>(0, 1)</code>, exclusive on both sides.
</p>
</blockquote>
<ul>
<li><p>
I cannot find any mention of this in the 
<a href="https://en.wikipedia.org/w/index.php?title=Negative_binomial_distribution&amp;oldid=611204120">Wikipedia's
version as of 2014-06-02</a> (i.e. around the time when LWG 2406 was opened). Note that 
the Wikipedia's version is not the same as in C++ standard; in Wikipedia, <code>p</code> 
parameter is the same &mdash; i.e. the probability of success &mdash; but the integer parameter 
(<code>&gt; 0</code>) is <em>number of failures</em>, while in C++ it is the <em>number of successes</em>. 
In the failure formulation <code>p == 1</code> is indeed invalid for essentially the same reason why 
<code>p == 0</code> is invalid for the C++ definition (i.e. leads to 
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>P</mi><mrow><mo>(</mo><mi>i</mi><mo>|</mo><mi>k</mi><mo>,</mo><mi>p</mi><mo>)</mo></mrow> 
</math><code> == 0</code> for all <code>i</code>).
</p></li>
</ul>
</li>
</ul>
<p>
Validity of <code>p == 1</code>:
</p>
<ul>
<li>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>[&hellip;] distribution of the number of failures in a sequence of trials with
success probability <code>p</code> before <code>n</code> successes occur.
</p>
</blockquote>
<p>
(from <a href="https://reference.wolfram.com/language/ref/NegativeBinomialDistribution.html">
Wolfram documentation</a>). When <code>p == 1</code>, this means that trial always succeeds, 
so it's obvious that the probability to get 0 failures is 1, and the probability for 
<code>i &gt; 0</code> failures is 0. This is exactly what the mathematical definition in
29.5.9.3.4 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.bern.negbin">[rand.dist.bern.negbin]</a> gives with convention <code>0<sup>0</sup> = 1</code> 
when <code>p == 1</code>.
</p>
</li>
<li><p>
Software such as 
<a href="https://reference.wolfram.com/language/ref/NegativeBinomialDistribution.html">Mathematica</a>,
<a href="https://mathworks.com/help/stats/prob.negativebinomialdistribution.html">Matlab</a>
and <a href="http://search.r-project.org/R/library/stats/html/NegBinomial.html">R</a> all
accept <code>p == 1</code> for negative binomial distribution and they use the integer parameter 
as number of successes like the C++ standard.
</p></li>
</ul>
<p>
What comes to the reasons why <code>p == 1</code> could have been considered invalid, it
seems that major implementations &mdash; namely 
<a href="https://github.com/gcc-mirror/gcc/blob/07c86323a199ca15177d99ad6c488b8f5fb5c729/libstdc%2B%2B-v3/include/bits/random.h#L4240">libstd++</a>,
<a href="https://github.com/llvm/llvm-project/blob/d081962dead08ef0982081e78d679dd609947ca5/libcxx/include/random#L5233">libc++</a> and 
<a href="https://github.com/microsoft/STL/blob/0e336ac7379c5b4d80280fa828b1a3bccc351d27/stl/inc/random#L4350">MSVC
standard library</a> &mdash; are using <code>std::gamma_distribution</code> in 
<code>std::negative_binomial_distribution</code> and passing <code>(1 - p)/p</code> as the second argument
of <code>std::gamma_distribution</code>. Case <code>p == 1</code> is not checked leading to violation of
precondition of <code>std::gamma_distribution</code>, which requires argument to be <code>&gt; 0</code>.
<p/>
For these reasons the note added by resolution of LWG 2406 seems invalid and could be considered for 
removal. However given the current status and history regarding handling of case <code>p == 1</code>, 
removing the note might not be the only option to consider.
</p>

<p><i>[2020-03-11 Issue Prioritization]</i></p>

<p>Priority to 3 and hand over to SG6 after reflector discussion.</p>


<p id="res-3402"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3409"><a href="3409">3409</a>. Too lax description of <code>atomic_ref&lt;T&gt;::required_alignment</code></h3>
<p><b>Section:</b> 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Andrey Semashev <b>Opened:</b> 2020-02-27 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.ref.ops">active issues</a> in [atomics.ref.ops].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.ref.ops">issues</a> in [atomics.ref.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/n4849">N4849</a> 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a>/1 
describes <code>atomic_ref&lt;T&gt;::required_alignment</code> constant as follows:
</p>
<blockquote><p>
The alignment required for an object to be referenced by an atomic
reference, which is at least <code>alignof(T)</code>.
</p></blockquote>
<p>
This wording allows for an implementation to always define <code>required_alignment</code> 
to be equal to <code>alignof(T)</code> and implement atomic operations using locking, 
even if a lock-free implementation is possible at a higher alignment. For example, 
on x86-64, <code>atomic_ref&lt;complex&lt;double&gt;&gt;</code> could be lock-free 
only when the referred object is aligned to 16 bytes, but the above definition 
allows an implementation to define <code>required_alignment</code> to 8 and use locking.
<p/>
The note in 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a>/2 does mention that lock-free operations
may require higher alignment, but it does not provide guidance to the implementations 
so that <code>required_alignment</code> reflects alignment required for lock-free 
operations, if possible, and not just minimum alignment required for any kind of 
implementation.
<p/>
The suggested resolution is to change the wording so that it is clear
that <code>required_alignment</code> indicates the alignment required for lock-free
implementation, if one is possible, or <code>alignof(T)</code> otherwise.
<p/>
Further, the note in 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a>/2 contains this sentence:
</p>
<blockquote><p>
Further, whether operations on an <code>atomic_ref</code> are lock-free could
depend on the alignment of the referenced object.
</p></blockquote>
<p>
This sentence is misleading, because according to <code>is_lock_free()</code>
definition in 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a>/4, the lock-free property is not 
allowed to depend on the alignment of a particular referenced object
(<code>is_lock_free()</code> must return <code>true</code> or <code>false</code> if 
operations on <em>all</em> objects of the given type <code>T</code> are lock-free or 
not). In other words, <code>atomic_ref</code> can only refer to an object aligned at 
least to <code>required_alignment</code> and its lock-free capability cannot depend 
on the actual runtime alignment of the object.
<p/>
To avoid the confusion, I propose to remove the sentence. The rest of
the note can stay intact. However, this second edit is less important
than the first one and can be omitted in case of disagreement.
</p>

<p><i>[2020-04-04 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3409"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4849">N4849</a>.
</p>

<ol>
<li><p>Modify 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a> as indicated:</p>

<blockquote>
<pre>
static constexpr size_t required_alignment;
</pre>
<blockquote>
<p>
-1- <ins>Let <code>A</code> be t</ins><del>T</del>he alignment required for an object to be referenced by 
an atomic reference, <del>which is at least <code>alignof(T)</code></del><ins>so that 
<code>is_always_lock_free</code> is <code>true</code>. If there is no such alignment or <code>A</code> is less 
than <code>alignof(T)</code>, <code>required_alignment</code> equals <code>alignof(T)</code>. Otherwise, 
<code>required_alignment</code> equals <code>A</code></ins>.
<p/>
-2- [<i>Note:</i> Hardware could require an object referenced by an <code>atomic_ref</code> to have 
stricter alignment (6.8.3 <a href="https://timsong-cpp.github.io/cppwp/basic.align">[basic.align]</a>) than other objects of type <code>T</code>. <del>Further, 
whether operations on an <code>atomic_ref</code> are lock-free could depend on the alignment of the 
referenced object.</del> For example, lock-free operations on <code>std::complex&lt;double&gt;</code>
could be supported only if aligned to <code>2*alignof(double)</code>. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3416"><a href="3416">3416</a>. The <i>Throws:</i> specification of <code>std::any</code> does not mention allocation</h3>
<p><b>Section:</b> 22.7.4 <a href="https://timsong-cpp.github.io/cppwp/any.class">[any.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2020-03-04 <b>Last modified:</b> 2020-04-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#any.class">issues</a> in [any.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several of the function specifications in 22.7.4 <a href="https://timsong-cpp.github.io/cppwp/any.class">[any.class]</a> have <i>Throws:</i> elements, 
but those only mention "exceptions thrown by a constructor". It seems necessary for <code>std::any</code> 
to perform dynamic allocation in general, and so in general there should be a possibility of an 
exception raised by such dynamic allocation. (This may come from a user-provided 
<code>T::operator new</code>, as far as I can tell.)
<p/>
We should revise the specifications to add relevant sources of exceptions.
<p/>
The functions that should probably mention allocations are:
<p/>
<ul>
<li><p><code>any(const any&amp; other)</code></p></li>
<li><p><code>template&lt;class T&gt; any(T&amp;&amp; value)</code></p></li>
<li><p>both <code>any(in_place_t&lt;T&gt;, &hellip;)</code> overloads</p></li>
<li><p><code>any&amp; operator=(const any&amp; rhs)</code></p></li>
<li><p><code>template&lt;class T&gt; any&amp; operator=(T&amp;&amp; rhs)</code></p></li>
<li><p>all <code>emplace</code> overloads</p></li>
</ul>
<p/>
Proposed wording: None yet. Maybe insert something like "thrown by unspecified, internal bookkeeping logic" 
into each <i>Throws:</i> element, but perhaps something more specific is necessary.
</p>

<p><i>[2020-04-04 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3416"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3417"><a href="3417">3417</a>. Missing <code>volatile</code> atomic deprecations</h3>
<p><b>Section:</b> 32.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2020-03-19 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paper <a href="https://wg21.link/p1831r1">P1831R1</a> aimed to deprecate all 
the atomic overloads for <code>volatile</code> qualified member function of 
<code>std::atomic</code> unless <code>is_always_lock_free</code> is <code>true</code>. 
There are a few omissions in the wording.
<p/>
First, <code>operator++</code> and <code>operator--</code> are correctly constrained, 
but the deprecated overloads are not restored in Annex D, unlike the other
member functions. I confirmed with the paper author this is an accidental 
oversight, and not an intended change of behavior for C++20.
<p/>
Secondly, the wait/notify APIs were added after the initial wording
For this paper was drafted, and the paper did not catch up. Again, I 
confirmed with the paper author that these functions should be
similarly constrained and deprecated.
</p>

<p><i>[2020-04-04 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion. The suggested wording was generally accepted, but there
were considerable doubts that it is necessary to add deprecated functions of the new <code>wait/notify</code>
functions instead of declaring only the non-volatile overloads. The wish was expressed that both SG1 and 
LEWG should express their opinion here.</p>


<p id="res-3417"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 32.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> as indicated:</p>

<blockquote>
<pre>
void wait(T old, memory_order order = memory_order::seq_cst) const volatile noexcept;
void wait(T old, memory_order order = memory_order::seq_cst) const noexcept;
</pre>
<blockquote>
<p>
<ins><i>Constraints:</i> For the <code>volatile</code> overload of this function, <code>is_always_lock_free</code> is <code>true</code>.</ins>
<p/>
-29- <i>Preconditions:</i> [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
void notify_one() volatile noexcept;
void notify_one() noexcept;
</pre>
<blockquote>
<p>
<ins><i>Constraints:</i> For the <code>volatile</code> overload of this function, <code>is_always_lock_free</code> is <code>true</code>.</ins>
<p/>
-32- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
void notify_all() volatile noexcept;
void notify_all() noexcept;
</pre>
<blockquote>
<p>
<ins><i>Constraints:</i> For the <code>volatile</code> overload of this function, <code>is_always_lock_free</code> is <code>true</code>.</ins>
<p/>
-34- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.atomics.volatile">[depr.atomics.volatile]</a>, annex D, as indicated:</p>

<blockquote>
<p>
If an atomic specialization has one of the following overloads, then that overload participates in overload
resolution even if <code>atomic&lt;T&gt;::is_always_lock_free</code> is <code>false</code>:
</p>
<blockquote>
<pre>
void store(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
[&hellip;]
T* fetch_<i>key</i>(ptrdiff_t operand, memory_order order = memory_order::seq_cst) volatile noexcept;
<ins>value_type operator++(int) volatile noexcept;
value_type operator--(int) volatile noexcept;
value_type operator++() volatile noexcept;
value_type operator--() volatile noexcept;
void wait(T old, memory_order order = memory_order::seq_cst) const volatile noexcept;
void notify_one() volatile noexcept;
void notify_all() volatile noexcept;</ins>
</pre>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3 id="3418"><a href="3418">3418</a>. Deprecated free functions in <code>&lt;atomic&gt;</code></h3>
<p><b>Section:</b> 32.5.9 <a href="https://timsong-cpp.github.io/cppwp/atomics.nonmembers">[atomics.nonmembers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2020-03-19 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paper <a href="https://wg21.link/p1831r1">P1831R1</a> deprecated the <code>volatile</code>-qualified 
member functions of <code>std::atomic</code> unless <code>is_always_lock_free</code> is <code>true</code>.  
32.5.9 <a href="https://timsong-cpp.github.io/cppwp/atomics.nonmembers">[atomics.nonmembers]</a> maps free functions calls, declared in the <code>&lt;atomic&gt;</code> 
header, to those member functions, but does not deprecate them under the same circumstances.
<p/>
I have confirmed with the paper author that the intended design was to deprecate these too, 
but currently we have no wording.
</p>

<p><i>[2020-03-29; Daniel provides wording]</i></p>

<p>
The suggested wording changes for 32.5.9 <a href="https://timsong-cpp.github.io/cppwp/atomics.nonmembers">[atomics.nonmembers]</a> attempts to make clear that 
any of the specification elements of the member function (including but not restricted to <i>Constraints:</i>
elements) are also imposed on the corresponding non-member function template. According to 
16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>, the wording "the semantics of the code sequence are determined 
by the <i>Constraints</i>,[&hellip;], and <i>Error conditions</i> specified for the function invocations contained in 
the code sequence." should realize the wanted effect. The advantage of this more general wording form is
that we don't need to to worry in case that in the future <i>Constraints:</i> elements of the member 
functions are modified.
</p>

<p><i>[2020-03-30; Tim improves wording]</i></p>


<p><i>[2020-04-25 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3418"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 32.5.9 <a href="https://timsong-cpp.github.io/cppwp/atomics.nonmembers">[atomics.nonmembers]</a> as indicated:</p>

<blockquote>
<p>
-1- A non-member function template whose name matches the pattern <code>atomic_<i>f</i></code> or the 
pattern <code>atomic_<i>f</i>_explicit</code> invokes the member function <code><i>f</i></code>, with the 
value of the first parameter as the object expression and the values of the remaining parameters 
(if any) as the arguments of the member function call, in order. An argument for a parameter of 
type <code>atomic&lt;T&gt;::value_type*</code> is dereferenced when passed to the member function call. 
If no such member function exists, the program is ill-formed. <ins>Otherwise, a call to such
a function template has effects equivalent to (16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>) the effective 
code sequence containing the <code><i>f</i></code> invocation specified in this subclause.</ins>
</p>
</blockquote>
</li>

<li><p>Modify D.23.2 <a href="https://timsong-cpp.github.io/cppwp/depr.atomics.volatile">[depr.atomics.volatile]</a>, annex D, as indicated:</p>

<blockquote>
<p>
If an atomic specialization has one of the following overloads, then that overload participates in overload
resolution even if <code>atomic&lt;T&gt;::is_always_lock_free</code> is <code>false</code>:
</p>
<blockquote>
<pre>
void store(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
[&hellip;]
T* fetch_<i>key</i>(ptrdiff_t operand, memory_order order = memory_order::seq_cst) volatile noexcept;
</pre>
</blockquote>
<p>
<ins>In addition, the following non-member function templates participate in overload
resolution even if <code>atomic&lt;T&gt;::is_always_lock_free</code> is <code>false</code>:</ins> 
</p>
<blockquote>
<pre>
<ins>template&lt;class T&gt;
  void atomic_store(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
template&lt;class T&gt;
  T atomic_load(const volatile atomic&lt;T&gt;*) noexcept;
template&lt;class T&gt;
  T atomic_load_explicit(const volatile atomic&lt;T&gt;*, memory_order) noexcept;
template&lt;class T&gt;
  T atomic_exchange(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;
template&lt;class T&gt;
T atomic_exchange_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
  memory_order) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_weak(volatile atomic&lt;T&gt;*,
                                    typename atomic&lt;T&gt;::value_type*,
                                    typename atomic&lt;T&gt;::value_type) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_strong(volatile atomic&lt;T&gt;*,
                                      typename atomic&lt;T&gt;::value_type*,
                                      typename atomic&lt;T&gt;::value_type) noexcept;
template&lt;class T&gt;
  bool atomic_compare_exchange_weak_explicit(volatile atomic&lt;T&gt;*,
                                             typename atomic&lt;T&gt;::value_type*,
                                             typename atomic&lt;T&gt;::value_type,
                                             memory_order, memory_order) noexcept;    
template&lt;class T&gt;
  bool atomic_compare_exchange_strong_explicit(volatile atomic&lt;T&gt;*,
                                               typename atomic&lt;T&gt;::value_type*,
                                               typename atomic&lt;T&gt;::value_type,
                                               memory_order, memory_order) noexcept;  
template&lt;class T&gt;
  T atomic_fetch_<i>key</i>(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type) noexcept;  
template&lt;class T&gt;
  T atomic_fetch_<i>key</i>_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::difference_type,
                              memory_order) noexcept;  
template&lt;class T&gt;
  T atomic_fetch_<i>key</i>(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type) noexcept;  
template&lt;class T&gt;
  T atomic_fetch_<i>key</i>_explicit(volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                              memory_order) noexcept;  
template&lt;class T&gt;
  void atomic_wait(const volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type);
template&lt;class T&gt;
  void atomic_wait_explicit(const volatile atomic&lt;T&gt;*, typename atomic&lt;T&gt;::value_type,
                            memory_order);
template&lt;class T&gt;
  void atomic_notify_one(volatile atomic&lt;T&gt;*);
template&lt;class T&gt;
  void atomic_notify_all(volatile atomic&lt;T&gt;*);</ins>
</pre>
</blockquote>

</blockquote>
</li>

</ol>




<hr>
<h3 id="3423"><a href="3423">3423</a>. <code>std::any_cast</code> should never return a <i>cv</i>-qualified type</h3>
<p><b>Section:</b> 22.7.5 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-04-02 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#any.nonmembers">issues</a> in [any.nonmembers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The return type of the non-pointer overloads of <code>std::any_cast&lt;T&gt;</code> is <code>T</code>. This is silly 
when <code>T</code> is <i>cv</i>-qualified (and, since merging <a href="https://wg21.link/p1152">P1152</a> 
"Deprecating volatile" into the working draft, deprecated when <code>T</code> is <code>volatile</code>-qualified). 
We should strip <i>cv</i>-qualifiers to determine the type returned.
</p>

<p><i>[2020-04-18 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>


<p id="res-3423"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 22.7.2 <a href="https://timsong-cpp.github.io/cppwp/any.synop">[any.synop]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class T&gt;
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> any_cast(const any&amp; operand);
template&lt;class T&gt;
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> any_cast(any&amp; operand);
template&lt;class T&gt;
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> any_cast(any&amp;&amp; operand);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 22.7.5 <a href="https://timsong-cpp.github.io/cppwp/any.nonmembers">[any.nonmembers]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> any_cast(const any&amp; operand);
template&lt;class T&gt;
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> any_cast(any&amp; operand);
template&lt;class T&gt;
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> any_cast(any&amp;&amp; operand);
</pre>
<blockquote>
<p>
-4- Let <ins><code>R</code> be the type <code>remove_cv_t&lt;T&gt;</code>, and</ins> <code>U</code> 
be the type <code>remove_cvref_t&lt;T&gt;</code>.
<p/>
-5- <i>Mandates:</i> For the first overload, <code>is_constructible_v&lt;<del>T</del><ins>R</ins>, const U&amp;&gt;</code> is <code>true</code>. 
For the second overload, <code>is_constructible_v&lt;<del>T</del><ins>R</ins>, U&amp;&gt;</code> is <code>true</code>. For the third overload, 
<code>is_constructible_v&lt;<del>T</del><ins>R</ins>, U&gt;</code> is <code>true</code>.
<p/>
-6- <i>Returns:</i> For the first and second overload, <code>static_cast&lt;<del>T</del><ins>R</ins>&gt;(*any_cast&lt;U&gt;(&amp;operand))</code>. 
For the third overload, <code>static_cast&lt;<del>T</del><ins>R</ins>&gt;(std::move(*any_cast&lt;U&gt;(&amp;operand)))</code>.
<p/>
-7- <i>Throws:</i> <code>bad_any_cast</code> if <code>operand.type() != typeid(remove_reference_t&lt;T&gt;)</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3424"><a href="3424">3424</a>. <code>optional::value_or</code> should never return a <i>cv</i>-qualified type</h3>
<p><b>Section:</b> 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-04-02 <b>Last modified:</b> 2023-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.observe">active issues</a> in [optional.observe].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.observe">issues</a> in [optional.observe].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>optional&lt;T&gt;::value_or</code> overloads are specified to return <code>T</code>. This seems silly when
<code>T</code> is <code>const</code> or <code>volatile</code> qualified &mdash; return types should never be <i>cv</i>-qualified.
(In the <code>volatile</code> case, it is even deprecated since merging <a href="https://wg21.link/p1152r4">P1152R4</a>
"Deprecating volatile" into the working draft.) We should strip <i>cv</i>-qualifiers from these return types.
</p>

<p><i>[2020-04-18 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 22.5.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp;) const&amp;;
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp;) &amp;&amp;;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp; v) const&amp;;
</pre>
<blockquote>
<p>
<ins>-?- Let <code>R</code> be <code>remove_cv_t&lt;T&gt;</code>.</ins>
<p/>
-17- <i>Mandates:</i> <code><del>is_copy_constructible_v&lt;T&gt;</del><ins>is_convertible_v&lt;const T&amp;, R&gt;</ins>
&amp;&amp; is_convertible_v&lt;U<del>&amp;&amp;</del>, T&gt;</code> is <code>true</code>.
<p/>
-18- <i>Effects:</i> Equivalent to:
<blockquote><pre>
return bool(*this) ? **this : static_cast&lt;<del>T</del><ins>R</ins>&gt;(std::forward&lt;U&gt;(v));
</pre></blockquote>
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
<ins>-?- Let <code>R</code> be <code>remove_cv_t&lt;T&gt;</code>.</ins>
<p/>
-19- <i>Mandates:</i> <code><del>is_move_constructible_v&lt;T&gt;</del><ins>is_convertible_v&lt;T, R&gt;</ins>
&amp;&amp; is_convertible_v&lt;U<del>&amp;&amp;</del>, T&gt;</code> is <code>true</code>.
<p/>
-20- <i>Effects:</i> Equivalent to:
<blockquote><pre>
return bool(*this) ? std::move(**this) : static_cast&lt;<del>T</del><ins>R</ins>&gt;(std::forward&lt;U&gt;(v));
</pre></blockquote>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2023-02-09 Casey improves wording and expands to cover <code>expected::value_or</code>]</i></p>

<p>Since <code>expected</code> was modeled on <code>optional</code>, it has the same issue.</p>


<p id="res-3424"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4928">N4928</a>.</p>

<ol>
<li><p>Modify 22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp;) const&amp;;
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp;) &amp;&amp;;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The two removals of the <code>&amp;&amp;</code> in
<code>is_convertible_v&lt;U&amp;&amp;, T&gt;</code> below is a simplification to restore consistency
with the wording for <code>expected::value_or</code>.]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp; v) const &amp;;
</pre>
<blockquote>
<p>
<ins>-?- Let <code>R</code> be <code>remove_cv_t&lt;T&gt;</code>.</ins>
<p/>
-15- <i>Mandates:</i> <code>
<del>is_copy_constructible_v&lt;T&gt;</del> <ins>is_convertible_v&lt;const T&amp;, R&gt;</ins> &amp;&amp;
is_convertible_v&lt;U<del>&amp;&amp;</del>, <del>T</del><ins>R</ins>&gt;
</code> is <code>true</code>.
<p/>
-16- <i>Effects:</i> Equivalent to:
<blockquote><pre>
return bool(*this) ? **this : static_cast&lt;<del>T</del><ins>R</ins>&gt;(std::forward&lt;U&gt;(v));
</pre></blockquote>
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
<ins>-?- Let <code>R</code> be <code>remove_cv_t&lt;T&gt;</code>.</ins>
<p/>
-17- <i>Mandates:</i> <code>
<del>is_move_constructible_v&lt;T&gt;</del> <ins>is_convertible_v&lt;T, R&gt;</ins> &amp;&amp;
is_convertible_v&lt;U<del>&amp;&amp;</del>, <del>T</del><ins>R</ins>&gt;
</code> is <code>true</code>.
<p/>
-18- <i>Effects:</i> Equivalent to:
<blockquote><pre>
return bool(*this) ? std::move(**this) : static_cast&lt;<del>T</del><ins>R</ins>&gt;(std::forward&lt;U&gt;(v));
</pre></blockquote>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp;) const &amp;;
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp;) &amp;&amp;;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 22.8.6.6 <a href="https://timsong-cpp.github.io/cppwp/expected.object.obs">[expected.object.obs]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp; v) const &amp;;
</pre>
<blockquote>
<p>
<ins>-?- Let <code>R</code> be <code>remove_cv_t&lt;T&gt;</code>.</ins>
<p/>
-16- <i>Mandates:</i> <code>
<del>is_copy_constructible_v&lt;T&gt;</del> <ins>is_convertible_v&lt;const T&amp;, R&gt;</ins> &amp;&amp;
is_convertible_v&lt;U, <del>T</del><ins>R</ins>&gt;
</code> is <code>true</code>.
<p/>
-17- <i>Returns:</i>
<code>has_value() ? **this : static_cast&lt;<del>T</del><ins>R</ins>&gt;(std::forward&lt;U&gt;(v))</code>.
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
<ins>-?- Let <code>R</code> be <code>remove_cv_t&lt;T&gt;</code>.</ins>
<p/>
-18- <i>Mandates:</i> <code>
<del>is_move_constructible_v&lt;T&gt;</del> <ins>is_convertible_v&lt;T, R&gt;</ins> &amp;&amp;
is_convertible_v&lt;U, <del>T</del><ins>R</ins>&gt;
</code> is <code>true</code>.
<p/>
-19- <i>Returns:</i>
<code>has_value() ? std::move(**this) : static_cast&lt;<del>T</del><ins>R</ins>&gt;(std::forward&lt;U&gt;(v))</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3429"><a href="3429">3429</a>. "models" should subsume like "satisfies"</h3>
<p><b>Section:</b> 16.4.5.11 <a href="https://timsong-cpp.github.io/cppwp/res.on.requirements">[res.on.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2020-04-07 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#res.on.requirements">active issues</a> in [res.on.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.requirements">issues</a> in [res.on.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It has been pointed out both on the LWG reflector and as 
<a href="https://github.com/cplusplus/draft/issues/3912">editorial issue 3912</a> that the
definition of "models" added in <a href="https://wg21.link/p2101r0">P2101R0</a> 
is not a model of clarity when a concept is defined in terms of other concepts.
</p>

<p><i>[2020-04-25 Issue Prioritization]</i></p>

<p>Priority to 3 after reflector discussion. There was a temptation to resolve this as P0, but
concerns were expressed that the "satisfied as part of the satisfaction" part was a bit confusing.</p>


<p id="res-3429"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<ol>
<li><p>Modify 16.4.5.11 <a href="https://timsong-cpp.github.io/cppwp/res.on.requirements">[res.on.requirements]</a> as indicated:</p>

<blockquote>
<p>
-1- A sequence <code>Args</code> of template arguments is said to <em>model</em> a concept <code>C</code> 
if<ins>:</ins> 
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <code>Args</code> satisfies <code>C</code> (13.5.3 <a href="https://timsong-cpp.github.io/cppwp/temp.constr.decl">[temp.constr.decl]</a>)<ins>;</ins></p></li>
<li><p>(1.2) &mdash; <del>and</del><ins><code>Args</code></ins> meets all semantic requirements (if any) 
given in the specification of <code>C</code><ins>; and</ins></p></li>
<li><p>(1.3) &mdash; <ins>every concept found to be satisfied as part of the satisfaction 
determination above is also modeled</ins>.</p></li>
</ol>
</p>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3438"><a href="3438">3438</a>. &sect;[container.node.overview] missing <code>multiset</code>/<code>map</code> cases</h3>
<p><b>Section:</b> 23.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2020-04-30 <b>Last modified:</b> 2020-05-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.node.overview">issues</a> in [container.node.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue resulted out of <a href="https://github.com/cplusplus/draft/issues/3967">this 
editorial change request</a>.
<p/>
In 23.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a>, there is Table 79 [tab:container.node.compat]
which indicates which containers have compatible nodes.
<p/>
It appears that rows along
</p>
<blockquote>
<pre>
multimap&lt;K, T, C1, A&gt;     multimap&lt;K, T, C2, A&gt;
</pre>
</blockquote>
<p>
(i.e. multimaps with differing <code>Compare</code> functions) are missing from the table.
<p/>
(Same for <code>multiset</code> and <code>unordered_multiset/map</code>.)
<p/>
However, the introductory sentences in 23.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a> do not relate 
"compatible nodes" with Table 79 and do not clearly state transitivity:
</p>
<blockquote><p>
A node handle is an object that accepts ownership of a single element from an associative container 
(23.2.7 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts">[associative.reqmts]</a>) or an unordered associative container (23.2.8 <a href="https://timsong-cpp.github.io/cppwp/unord.req">[unord.req]</a>). 
It may be used to transfer that ownership to another container with compatible nodes. Containers 
with compatible nodes have the same node handle type. Elements may be transferred in either direction 
between container types in the same row of Table 79 [tab:container.node.compat].
</p></blockquote>

<p><i>[2020-05-09; Reflector prioritization]</i></p>

<p>
Set priority to 3 after reflector discussions.
</p>


<p id="res-3438"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3439"><a href="3439">3439</a>. "<code>Distance</code>" template parameter is underspecified</h3>
<p><b>Section:</b> 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a>, 26.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.random.sample">[alg.random.sample]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2020-05-01 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library specification conveys pre-concept requirements on template
parameters by naming, e.g. "<code>InputIterator</code>".
<p/>
There is no general specification for template parameters named "<code>Distance</code>",
as used by <code>std::advance</code> (see 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a>).
When addressing this omission, the local restriction in 26.7.12 <a href="https://timsong-cpp.github.io/cppwp/alg.random.sample">[alg.random.sample]</a> 
could possibly be removed.
<p/>
See the related issue <a href="3213" title="for_each_n and copy_n missing requirements for Size (Status: Resolved)">3213</a> for the <code>Size</code> template parameter.
</p>

<p><i>[2025-10-10; Jonathan comments]</i></p>

<p>
The SGI STL has the requirement that
"<code class='backtick'>Distance</code> is an integral type that is convertible to <code class='backtick'>InputIterator</code>'s
distance type." But the SGI STL also required that <code class='backtick'>Size</code> arguments to
<code class='backtick'>fill_n</code> etc. have integral types, and the standard only requires them to
be convertible to integral types. Presumably that relaxation was intentional.
</p>

<p><i>[2020-05-09; Reflector prioritization]</i></p>

<p>
Set priority to 3 after reflector discussions.
</p>


<p id="res-3439"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3444"><a href="3444">3444</a>. [networking.ts] <code>net::basic_socket_streambuf::connect(Args&amp;&amp;...)</code> effects are wrong</h3>
<p><b>Section:</b> 19.1.2 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/socket.streambuf.members">[networking.ts::socket.streambuf.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-05-14 <b>Last modified:</b> 2020-07-17</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: networking.ts</b></p>
<p>
The effects in 19.1.2 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/socket.streambuf.members">[networking.ts::socket.streambuf.members]</a> p3 say that the function loops through every endpoint in the 
sequence, attempting to establish a connection. It needs to say that as soon as a connection is successfully established 
it returns. Otherwise even if a connection is made, it closes the socket and tries the next endpoint in the sequence. 
That means it will always be left in whatever state resulted from trying the last endpoint in the sequence (or from 
timing out if the expiry time was reached before iterating through all endpoints).
</p>

<p><i>[2020-07-17; Priority set to 2 in telecon]</i></p>

<p>Jonathan to provide wording.</p>


<p id="res-3444"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3445"><a href="3445">3445</a>. [networking.ts] <code>net::basic_socket_istream::connect</code> should be constrained</h3>
<p><b>Section:</b> 19.2.1 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/socket.iostream.cons">[networking.ts::socket.iostream.cons]</a>, 19.2.2 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/socket.iostream.members">[networking.ts::socket.iostream.members]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-05-14 <b>Last modified:</b> 2021-05-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#networking.ts::socket.iostream.cons">issues</a> in [networking.ts::socket.iostream.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: networking.ts</b></p>
<p>
<code>basic_socket_streambuf&lt;P, C, W&gt;::connect(Args&amp;&amp;...)</code> is constrained to only exist when 
<code>P</code> meets the <code>InternetProtocol</code> requirements, but <code>basic_socket_iostream&lt;P, C, W&gt;::connect(Args&amp;&amp;...)</code> 
is not constrained. Since it just passes those arguments straight to the <code>streambuf</code>, the outer 
<code>connect(Args&amp;&amp;...)</code> should be constrained too.
<p/>
In addition to that, the <code>basic_socket_iostream(Args&amp;&amp;...)</code> constructor should be constrained, so that 
<code>is_constructible</code> gives the right answer.
</p>

<p><i>[2020-07-17; Priority set to 3 in telecon]</i></p>



<p id="res-3445"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4771">N4771</a>.</p>

<ol>
<li><p>Modify 19.2.1 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/socket.iostream.cons">[networking.ts::socket.iostream.cons]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> As a drive-by fix, a missing <code>std::</code> qualification in front of <code>forward</code> has been added]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class... Args&gt;
  explicit basic_socket_iostream(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Initializes the base class as <code>basic_iostream&lt;char&gt;(&amp;sb_))</code>, 
value-initializes <code>sb_</code>, and performs <code>setf(std::ios_base::unitbuf)</code>. Then calls 
<code>rdbuf()-&gt;connect(<ins>std::</ins>forward&lt;Args&gt;(args)...)</code>. If that function returns a null pointer, 
calls <code>setstate(failbit)</code>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless the expression 
<code>rdbuf()-&gt;connect(std::forward&lt;Args&gt;(args)...)</code> is well-formed.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 19.2.2 <a href="https://timsong-cpp.github.io/cppwp/networking-ts/socket.iostream.members">[networking.ts::socket.iostream.members]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> As a drive-by fix, a missing <code>std::</code> qualification in front of <code>forward</code> has been added]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class... Args&gt;
  void connect(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <code>rdbuf()-&gt;connect(<ins>std::</ins>forward&lt;Args&gt;(args)...)</code>. If that function 
returns a null pointer, calls <code>setstate(failbit)</code> (which may throw <code>ios_base::failure</code>).
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless the expression 
<code>rdbuf()-&gt;connect(std::forward&lt;Args&gt;(args)...)</code> is well-formed.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>




<hr>
<h3 id="3451"><a href="3451">3451</a>. Inconsistently explicit deduction guides</h3>
<p><b>Section:</b> 27.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, 25.7.14.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.view">[range.join.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2020-06-11 <b>Last modified:</b> 2020-07-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library inconsistently marks deduction guides as <code>explicit</code>. <code>join_view</code> and <code>basic_string</code> 
account for the only two occurrences of unconditionally explicit deduction guides. All other deduction
guides have no <code>explicit</code>-specifier. Following is a list of unconditionally explicit constructors 
with their deduction guides.
</p>
<blockquote><pre>
template&lt;class Y&gt;
  explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);

template&lt;class T&gt;
  shared_ptr(weak_ptr&lt;T&gt;) -&gt; shared_ptr&lt;T&gt;;

template&lt;class T&gt;
  constexpr explicit basic_string(const T&amp; t, const Allocator&amp; a = Allocator());

template&lt;class charT,
         class traits,
         class Allocator = allocator&lt;charT&gt;&gt;
  explicit basic_string(basic_string_view&lt;charT, traits&gt;, const Allocator&amp; = Allocator())
    -&gt; basic_string&lt;charT, traits, Allocator&gt;;

explicit queue(const Container&amp;);
explicit queue(Container&amp;&amp;);

template&lt;class Container&gt;
  queue(Container) -&gt; queue&lt;typename Container::value_type, Container&gt;;

explicit stack(const Container&amp;);
explicit stack(Container&amp;&amp;);

template&lt;class Container&gt;
  stack(Container) -&gt; stack&lt;typename Container::value_type, Container&gt;;

constexpr explicit join_view(V base);

template&lt;class R&gt;
  explicit join_view(R&amp;&amp;) -&gt; join_view&lt;views::all_t&lt;R&gt;&gt;;

constexpr explicit common_view(V r);

template&lt;class R&gt;
  common_view(R&amp;&amp;) -&gt; common_view&lt;views::all_t&lt;R&gt;&gt;;

constexpr explicit reverse_view(V r);

template&lt;class R&gt;
  reverse_view(R&amp;&amp;) -&gt; reverse_view&lt;views::all_t&lt;R&gt;&gt;;


explicit zoned_time(TimeZonePtr z);
explicit zoned_time(string_view name);

template&lt;class TimeZonePtrOrName&gt;
  zoned_time(TimeZonePtrOrName&amp;&amp;)
    -&gt; zoned_time&lt;seconds, time-zone-representation&lt;TimeZonePtrOrName&gt;&gt;;

template&lt;class C&gt;
explicit stop_callback(const stop_token&amp; st, C&amp;&amp; cb)
    noexcept(is_nothrow_constructible_v&lt;Callback, C&gt;);
template&lt;class C&gt;
explicit stop_callback(stop_token&amp;&amp; st, C&amp;&amp; cb)
    noexcept(is_nothrow_constructible_v&lt;Callback, C&gt;);

template&lt;class Callback&gt;
  stop_callback(stop_token, Callback) -&gt; stop_callback&lt;Callback&gt;;
</pre></blockquote>

<p><i>[2020-07-17; Priority set to 3 in telecon]</i></p>



<p id="res-3451"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.</p>

<ol>
<li>
<p>Modify 27.4.3 <a href="https://timsong-cpp.github.io/cppwp/basic.string">[basic.string]</a>, class template <code>basic_string</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class charT,
         class traits,
         class Allocator = allocator&lt;charT&gt;&gt;
  <del>explicit</del> basic_string(basic_string_view&lt;charT, traits&gt;, const Allocator&amp; = Allocator())
    -&gt; basic_string&lt;charT, traits, Allocator&gt;;
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>Modify 27.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class charT,
         class traits,
         class Allocator = allocator&lt;charT&gt;&gt;
  <del>explicit</del> basic_string(basic_string_view&lt;charT, traits&gt;, const Allocator&amp; = Allocator())
    -&gt; basic_string&lt;charT, traits, Allocator&gt;;
[&hellip;]
</pre>
<blockquote>
<p>
-22- <i>Constraints:</i> <code>Allocator</code> is a type that qualifies as an allocator (23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>).
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 25.7.14.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.view">[range.join.view]</a>, class template <code>join_view</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class R&gt;
  <del>explicit</del> join_view(R&amp;&amp;) -&gt; join_view&lt;views::all_t&lt;R&gt;&gt;;
[&hellip;]
</pre>
</blockquote>
</li>
</ol>




<hr>
<h3 id="3454"><a href="3454">3454</a>. <code>pointer_traits::pointer_to</code> should be <code>constexpr</code></h3>
<p><b>Section:</b> 20.2.3 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits">[pointer.traits]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2020-06-21 <b>Last modified:</b> 2024-11-19</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#pointer.traits">issues</a> in [pointer.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Trying to implement a <code>constexpr std::list</code> (inspired by Tim Song's
note on using variant members in the node) as part of evaluating
the <code>constexpr</code> container and adapters proposals, I hit problems
I could not code around in <code>pointer_traits</code>, as only the specialization
for native pointers has a <code>constexpr pointer_to</code> function.
<p/>
This means that containers of my custom allocator, that delegates
all allocation behavior to <code>std::allocator&lt;T&gt;</code> but adds extra
telemetry and uses a fancy pointer, does not work with the approach
I tried for implementing <code>list</code> (common link type, shared between
nodes, and stored as <code>end</code> sentinel directly in the <code>list</code> object).
</p>

<p><i>[2020-07-17; Forwarded to LEWG after review in telecon]</i></p>


<p><i>[2022-07-19; Casey Carter comments]</i></p>

<p>
 This is no longer simply a theoretical problem that impedes implementing 
 <code>constexpr std::list</code>, but an actual defect affecting current 
 implementations of <code>constexpr std::string</code>. More specifically, it 
 makes it impossible to  support so-called "fancy pointers" in a <code>constexpr 
 basic_string</code> that performs the small string optimization (SSO). 
 (<code>pointer_traits::pointer_to</code> is critically necessary to get a 
 pointer that designates the SSO buffer.) As things currently stand, 
 <code>constexpr basic_string</code> can support fancy pointers <em>or</em> SSO, 
 but not both.
</p>
<p><i>[Wrocaw 2024-11-18; LEWG approves the direction]</i></p>

<p>
Should there be an Annex C entry noting that program-defined specializations
need to add <code class='backtick'>constexpr</code> to be conforming?
</p>


<p id="res-3454"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>. 
</p>

<ol>
<li><p>Modify 20.2.3 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits">[pointer.traits]</a> as indicated:</p>

<blockquote>
<p>
-1- The class template <code>pointer_traits</code> supplies a uniform interface to certain attributes of pointer-like types.
</p>
<blockquote>
<pre>
namespace std {
  template&lt;class Ptr&gt; struct pointer_traits {
    using pointer         = Ptr;
    using element_type    = <i>see below</i>;
    using difference_type = <i>see below</i>;
    
    template&lt;class U&gt; using rebind = <i>see below</i>;
    
    static <ins>constexpr</ins> pointer pointer_to(<i>see below</i> r);
  };
  [&hellip;]
}
</pre>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.2.3.3 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.functions">[pointer.traits.functions]</a> as indicated:</p>

<blockquote>
<pre>
static <ins>constexpr</ins> pointer pointer_traits::pointer_to(<i>see below</i> r);
static constexpr pointer pointer_traits&lt;T*&gt;::pointer_to(<i>see below</i> r) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Mandates:</i> For the first member function, <code>Ptr::pointer_to(r)</code> is well-formed.
<p/>
-2- <i>Preconditions:</i> For the first member function, <code>Ptr::pointer_to(r)</code> returns a pointer 
to <code>r</code> through which indirection is valid.
<p/>
-3- <i>Returns:</i> The first member function returns <code>Ptr::pointer_to(r)</code>. The second member function
returns <code>addressof(r)</code>.
<p/>
-4- <i>Remarks:</i> If <code>element_type</code> is <i>cv</i> <code>void</code>, the type of <code>r</code> is unspecified; 
otherwise, it is <code>element_type&amp;</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3456"><a href="3456">3456</a>. Pattern used by <code>std::from_chars</code> is underspecified</h3>
<p><b>Section:</b> 28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-06-23 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#charconv.from.chars">active issues</a> in [charconv.from.chars].</p>
<p><b>View all other</b> <a href="lwg-index.html#charconv.from.chars">issues</a> in [charconv.from.chars].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The intention of 28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a> p7 is that the <code>fmt</code> argument modifies 
the expected pattern, so that only a specific subset of valid <code>strtod</code> patterns are recognized 
for each format. This is not clear from the wording.
<p/>
When <code>fmt == chars_format::fixed</code> no exponent is to be used, so any trailing characters that match 
the form of a <code>strtod</code> exponent are ignored. For example, <code>"1.23e4"</code> should produce the result 
<code>1.23</code> for the fixed format. The current wording says "the optional exponent part shall not appear" 
which can be interpreted to mean that <code>"1.23e4"</code> violates a precondition and so has undefined behaviour!
<p/>
When <code>fmt != chars_format::hex</code> only decimal numbers should be recognized. This means that for any
format except scientific, <code>"0x123"</code> produces <code>0.0</code> (it's invalid when 
<code>fmt == chars_format::scientific</code> because there's no exponent). The current wording only says that 
when <code>hex</code> is used the string has an assumed <code>"0x"</code> prefix, so is interpreted as a hexadecimal 
float, it doesn't say that when <code>fmt != hex</code> that the string is <em>not</em> interpreted as a 
hexadecimal float.
<p/>
Two alternative resolutions are provided, one is a minimal fix and the other attempts to make it clearer by 
not referring to a modified version of the C rules.
</p>

<p><i>[2020-07-14; Jonathan fixes the <code>strtod</code> call in Option B]</i></p>


<p><i>[2020-07-17; Priority set to 3 in telecon]</i></p>



<p id="res-3456"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>. 
</p>

<b>Option A:</b>
<ol>
<li><p>Modify 28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a> as indicated:</p>

<blockquote>
<pre>
from_chars_result from_chars(const char* first, const char* last, float&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, double&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, long double&amp; value,
                             chars_format fmt = chars_format::general);
</pre>
<blockquote>
<p>
-6- <i>Preconditions:</i> <code>fmt</code> has the value of one of the enumerators of <code>chars_format</code>.
<p/>
-7- <i>Effects:</i> The pattern is the expected form of the subject sequence in the "C" locale, as described for
<code>strtod</code>, except that
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; the sign <code>'+'</code> may only appear in the exponent part;</p></li>
<li><p>(7.2) &mdash; if <code>fmt</code> has <code>chars_format::scientific</code> set but not <code>chars_format::fixed</code>, 
the <del>otherwise optional exponent part shall appear</del><ins>exponent part is not optional</ins>;</p></li>
<li><p>(7.3) &mdash; if <code>fmt</code> has <code>chars_format::fixed</code> set but not <code>chars_format::scientific</code>, 
<del>the optional exponent part shall not appear; and</del><ins>there is no exponent part;</ins></p></li>
<li><p><ins>(?.?) &mdash; if <code>fmt</code> is not <code>chars_format::hex</code>, only decimal digits and an 
optional <code>'.'</code> appear before the exponent part (if any); and</ins></p></li>
<li><p>(7.4) &mdash; if <code>fmt</code> is <code>chars_format::hex</code>, the prefix <code>"0x"</code> or <code>"0X"</code> is 
assumed. [<i>Example:</i> The string <code>0x123</code> is parsed to have the value <code>0</code> with remaining characters 
<code>x123</code>. &mdash; <i>end example</i>]</p></li>
</ol>
<p>
In any case, the resulting <code>value</code> is one of at most two floating-point values closest to the value of the
string matching the pattern.
</p>
</blockquote>
</blockquote>
</li>
</ol>

<b>Option B:</b>
<ol>
<li><p>Modify 28.2.3 <a href="https://timsong-cpp.github.io/cppwp/charconv.from.chars">[charconv.from.chars]</a> as indicated:</p>

<blockquote>
<pre>
from_chars_result from_chars(const char* first, const char* last, float&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, double&amp; value,
                             chars_format fmt = chars_format::general);
from_chars_result from_chars(const char* first, const char* last, long double&amp; value,
                             chars_format fmt = chars_format::general);
</pre>
<blockquote>
<p>
-6- <i>Preconditions:</i> <code>fmt</code> has the value of one of the enumerators of <code>chars_format</code>.
<p/>
-7- <i>Effects:</i> <del>The pattern is the expected form of the subject sequence in the "C" locale, as described for
<code>strtod</code>, except that</del><ins>The pattern is an optional <code>'-'</code> sign followed by one of:</ins>
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; <del>the sign <code>'+'</code> may only appear in the exponent part</del><ins><code>INF</code> or 
<code>INFINITY</code>, ignoring case</ins>;</p></li>
<li><p>(7.2) &mdash; <del>if <code>fmt</code> has <code>chars_format::scientific</code> set but not <code>chars_format::fixed</code>, 
the otherwise optional exponent part shall appear</del><ins>if <code>numeric_limits&lt;T&gt;::has_quiet_NaN</code> is 
<code>true</code>, <code>NAN</code> or <code>NAN(</code><i>n-char-sequence<sub>opt</sub></i><code>)</code>, ignoring case in the 
<code>NAN</code> part, where:</ins></p>
<blockquote>
<pre>
<ins><i>n-char-sequence:</i>
       <i>digit</i>
       <i>nondigit</i>
       <i>n-char-sequence digit</i>
       <i>n-char-sequence nondigit</i></ins>
</pre>
</blockquote>
<p>;</p></li>
<li><p>(7.3) &mdash; <del>if <code>fmt</code> has <code>chars_format::fixed</code> set but not <code>chars_format::scientific</code>, 
the optional exponent part shall not appear; and</del><ins>if <code>fmt</code> is equal to <code>chars_format::scientific</code>, 
a sequence of characters matching <i>chars-format-dec exponent-part</i>, where:</ins></p>
<blockquote>
<pre>
<ins><i>chars-format-dec:</i>
         <i>fractional-constant</i>
         <i>digit-sequence</i></ins>
</pre>
</blockquote>
<p><ins>;</ins></p></li>
<li><p>(7.4) &mdash; <del>if <code>fmt</code> is <code>chars_format::hex</code>, the prefix <code>"0x"</code> or <code>"0X"</code> is 
assumed. [<i>Example:</i> The string <code>0x123</code> is parsed to have the value <code>0</code> with remaining characters 
<code>x123</code>. &mdash; <i>end example</i>]</del><ins>if <code>fmt</code> is equal to <code>chars_format::fixed</code>, a 
sequence of characters matching <i>chars-format-dec</i>;</ins></p></li>
<li><p><ins>(?.?) &mdash; if <code>fmt</code> is equal to <code>chars_format::general</code>, a sequence of characters matching 
<i>chars-format-dec exponent-part<sub>opt</sub></i>; or</ins></p></li>
<li><p><ins>(?.?) &mdash; if <code>fmt</code> is equal to <code>chars_format::hex</code>, a sequence of characters matching 
<i>chars-format-hex binary-exponent-part<sub>opt</sub></i>, where:</ins></p>
<blockquote>
<pre>
<ins><i>chars-format-hex:</i>
         <i>hexadecimal-fractional-constant</i>
         <i>hexadecimal-digit-sequence</i></ins>
</pre>
</blockquote>
<p><ins>[<i>Note:</i> The pattern is derived from the subject sequence in the <code>"C"</code> locale for <code>strtod</code>, 
with the value of <code>fmt</code> limiting which forms of the subject sequence are recognized, and with no <code>0x</code> 
or <code>0X</code> prefix recognized. &mdash; <i>end note</i>]</ins></p></li>
</ol>
<p>
<ins>For a character sequence <code>INF</code>, <code>INFINITY</code>, <code>NAN</code>, or 
<code>NAN(</code><i>n-char-sequence<sub>opt</sub></i><code>)</code> the resulting value is obtained as if by evaluating 
<code>strtod(string(first, last).c_str(), nullptr)</code> in the <code>"C"</code> locale.
In all other cases</ins><del>In any case</del>,
the resulting <code>value</code> is one of at most two floating-point values closest to the value of the
string matching the pattern.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3457"><a href="3457">3457</a>. <code>*this</code> is not invalidated</h3>
<p><b>Section:</b> 27.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2020-06-26 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view.template">issues</a> in [string.view.template].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a> states:
</p>
<blockquote><p>
For a <code>basic_string_view str</code>, any operation that invalidates a pointer in the range <code>[str.data(), 
str.data() + str.size())</code> invalidates pointers, iterators, and references returned from <code>str</code>'s member functions.
</p></blockquote>
<p>
The assignment operators return a reference to <code>*this</code>, but <code>*this</code> is not invalidated.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>. 
</p>

<ol>
<li><p>Modify 27.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a> as indicated:</p>

<blockquote>
<p>
-2- For a <code>basic_string_view str</code>, any operation that invalidates a pointer in the range <code>[str.data(),
str.data() + str.size())</code> invalidates pointers, iterators, and references <ins>to the elements in that range 
and its past-the-end iterator</ins> returned from <code>str</code>'s member functions.
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2020-06-29; Casey comments and provides alternative proposed wording]</i></p>

<p>
I think we should additionally strike "returned from <code>str</code>'s member functions" from the end of the sentence. 
Provenance shouldn't affect invalidation; <code>ranges::next(some_string_view.begin(), 42)</code>, for example, 
returns an iterator that denotes an element of <code><i>some_</i>string_view</code>, but is not a member function 
of <code>basic_string_view</code>.
</p>

<p><i>[2020-07-05; Reflector prioritization]</i></p>

<p>
Set priority to 3 after reflector discussions.
</p>


<p id="res-3457"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>. 
</p>

<ol>
<li><p>Modify 27.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.view.template">[string.view.template]</a> as indicated:</p>

<blockquote>
<p>
-2- For a <code>basic_string_view str</code>, any operation that invalidates a pointer in the range <code>[str.data(),
str.data() + str.size())</code> invalidates pointers, iterators, and references <ins>to the elements in that range 
and its past-the-end iterator</ins><del>returned from <code>str</code>'s member functions</del>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3459"><a href="3459">3459</a>. Why doesn't <code>std::convertible_to</code> have semantic requirement when <code>To</code> is reference-to-function type?</h3>
<p><b>Section:</b> 18.4.4 <a href="https://timsong-cpp.github.io/cppwp/concept.convertible">[concept.convertible]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2020-06-30 <b>Last modified:</b> 2020-07-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concept.convertible">active issues</a> in [concept.convertible].</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.convertible">issues</a> in [concept.convertible].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.4.4 <a href="https://timsong-cpp.github.io/cppwp/concept.convertible">[concept.convertible]</a> p2:
</p>
<blockquote>
<p>
Types <code>From</code> and <code>To</code> model <code>convertible_to&lt;From, To&gt;</code> only if:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code>To</code> is not an object or reference-to-object type, or <code>static_cast&lt;To&gt;(f())</code> is 
equal to <code>test(f)</code>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
<p>
This requires the implicit and explicit conversions to produce equal results.
<p/>
However, it seems that when <code>To</code> is a reference-to-function type, this restriction does not apply. 
This makes it possible to create a class that models <code>convertible_to</code>, but produces different 
results depending on the kind of conversion:
</p>
<blockquote><pre>
#include &lt;concepts&gt;

int foo() { return 0; }
int bar() { return 42; }

using FT = int();
struct A 
{
  operator FT&amp;() const { return foo; }
  explicit operator FT&amp;() { return bar; }
};

static_assert(std::convertible_to&lt;A, FT&amp;&gt;);

A a;
FT&amp; x = a;                    // x == foo
auto y = static_cast&lt;FT&amp;&gt;(a); // y == bar
</pre></blockquote>

<p><i>[2020-07-12; Reflector prioritization]</i></p>

<p>
Set priority to 3 after reflector discussions.
</p>


<p id="res-3459"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3463"><a href="3463">3463</a>. Incorrect requirements for <code>transform_inclusive_scan</code> without initial value</h3>
<p><b>Section:</b> 26.10.11 <a href="https://timsong-cpp.github.io/cppwp/transform.inclusive.scan">[transform.inclusive.scan]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2020-07-07 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements for the overloads of <code>std::transform_inclusive_scan</code>
without an initial value incorrectly assume that the internal accumulator uses 
the iterator's value type, as it does for <code>std::inclusive_scan</code>, rather 
than the transformed type of the iterator's value type, as it was intended.
<p/>
According to the standard, the following program is ill-formed as it
requires <code>std::string</code> to be convertible to <code>int</code>:
</p>
<blockquote><pre>
auto vs = {0, 1, 2};
std::transform_inclusive_scan(
   vs.begin(), vs.end(),
   std::ostream_iterator&lt;std::string&gt;(std::cout, ";"),
   [](std::string x, std::string y) { return x + y; },
   [](int x) { return std::to_string(x); });
</pre></blockquote>
<p>
libstdc++ and Microsoft's STL accept the snippet, producing <code>0;01;012;</code>
as expected, libc++ strictly conforms to the standard and rejects it.
<p/>
These constrains were introduced by <a href="https://wg21.link/p0574r1">P0574R1</a>.
</p>

<p><i>[2020-07-17; Priority set to 3 in telecon]</i></p>



<p id="res-3463"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>. 
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Current implementations that accept the code, do some form of <code>auto acc =
unary_op(*first);</code>, therefore the following proposed wording uses <code>decay_t</code>
instead of e.g. <code>remove_cvref_t</code>.]
</p>
</blockquote>

<ol>
<li><p>Modify 26.10.11 <a href="https://timsong-cpp.github.io/cppwp/transform.inclusive.scan">[transform.inclusive.scan]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class OutputIterator,
         class BinaryOperation, class UnaryOperation&gt;
  constexpr OutputIterator
    transform_inclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result,
                             BinaryOperation binary_op, UnaryOperation unary_op);
template&lt;class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2,
         class BinaryOperation, class UnaryOperation&gt;
  ForwardIterator2
    transform_inclusive_scan(ExecutionPolicy&amp;&amp; exec,
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result,
                             BinaryOperation binary_op, UnaryOperation unary_op);
template&lt;class InputIterator, class OutputIterator,
         class BinaryOperation, class UnaryOperation, class T&gt;
  constexpr OutputIterator
    transform_inclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result,
                             BinaryOperation binary_op, UnaryOperation unary_op,
                             T init);
template&lt;class ExecutionPolicy,
         class ForwardIterator1, class ForwardIterator2,
         class BinaryOperation, class UnaryOperation, class T&gt;
  ForwardIterator2
    transform_inclusive_scan(ExecutionPolicy&amp;&amp; exec,
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result,
                             BinaryOperation binary_op, UnaryOperation unary_op,
                             T init);
</pre>
<blockquote>
<p>
-1- Let <code>U</code> be <del>the value type of <code>decltype(first)</code></del><ins><ins><code>decay_t&lt;decltype(unary_op(*first))&gt;</code></ins></ins>.
<p/>
-2- [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3475"><a href="3475">3475</a>. <code>std::thread</code>'s constructor needs to be able to report general memory allocation failures</h3>
<p><b>Section:</b> 32.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.constr">[thread.thread.constr]</a>, 32.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.jthread.cons">[thread.jthread.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2020-08-14 <b>Last modified:</b> 2020-09-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>(j)thread</code>'s constructor needs to <code><i>decay-copy</i></code> the supplied parameters and callable over to the started 
thread through an operating system API that generally only accepts a single <code>void*</code>. The MSVC++ and libc++ 
implementations do this by putting the parameters in a <code>std::tuple</code> allocated from the heap, passing a 
pointer to that tuple through the operating system API, and leaving ownership of the parameters to the other thread.
<p/>
It might be theoretically possible to introduce an additional copy and synchronization where the starting thread 
blocks for the started thread to make a move constructed copy of that tuple from the parameters, but that would 
introduce unreasonable synchronization overhead since the starting thread would have to block for all TLS 
initializers and similar in the started thread.
<p/>
It is technically possible to implement the current design by transforming this allocation failure into 
<code>resource_unavailable_try_again</code>, but the description for this error in the standard is that some thread-based 
limitation has been reached, not a general memory limit, so that doesn't seem to meet the spirit of the requirement.
</p>
<p><i>[2020-08-21; Issue processing telecon: set priority to 3]</i></p>

<p>
Jonathan: I prefer Option A, but I think we need something like:
"any exceptions thrown by the <i><code>decay-copy</code></i> calls, or ...".
</p>


<p id="res-3475"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> The memory allocation failure results in <code>bad_alloc</code>.
</p>
<ol>
<li><p>Modify 32.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.constr">[thread.thread.constr]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F, class... Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-3- <i>Constraints:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-8- <i>Postconditions:</i> <code>get_id() != id()</code>. <code>*this</code> represents the newly started thread.
<p/>
-9- <i>Throws:</i> <ins><code>bad_alloc</code> if memory to transfer parameters to the new thread cannot be obtained.</ins> 
<code>system_error</code> if unable to start the new thread.
<p/>
-10- <i>Error conditions:</i>
</p>
<ol style="list-style-type: none">
<li><p>(10.1) &mdash; <code>resource_unavailable_try_again</code> &mdash; the system lacked the necessary resources 
to create another thread, or the system-imposed limit on the number of threads in a process would be exceeded.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

<li><p>Modify 32.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.jthread.cons">[thread.jthread.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F, class... Args&gt; explicit jthread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-3- <i>Constraints:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-8- <i>Postconditions:</i> <code>get_id() != id()</code> is <code>true</code> and <code>ssource.stop_possible()</code> 
is <code>true</code> and <code>*this</code> represents the newly started thread. [<i>Note:</i> The calling thread 
can make a stop request only once, because it cannot replace this stop token. &mdash; <i>end note</i>]
<p/>
-9- <i>Throws:</i> <ins><code>bad_alloc</code> if memory to transfer parameters to the new thread cannot be obtained.</ins> 
<code>system_error</code> if unable to start the new thread.
<p/>
-10- <i>Error conditions:</i>
</p>
<ol style="list-style-type: none">
<li><p>(10.1) &mdash; <code>resource_unavailable_try_again</code> &mdash; the system lacked the necessary resources 
to create another thread, or the system-imposed limit on the number of threads in a process would be exceeded.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>

<p>
<b>Option B:</b> The memory allocation failure results in a <code>system_error</code> with the error condition 
<code>out_of_memory</code>.
</p>
<ol>
<li><p>Modify 32.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.constr">[thread.thread.constr]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F, class... Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-3- <i>Constraints:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-8- <i>Postconditions:</i> <code>get_id() != id()</code>. <code>*this</code> represents the newly started thread.
<p/>
-9- <i>Throws:</i> <code>system_error</code> if unable to start the new thread.
<p/>
-10- <i>Error conditions:</i>
</p>
<ol style="list-style-type: none">
<li><p><ins>(10.?) &mdash; <code>not_enough_memory</code> &mdash; the system lacked memory resources to transfer parameters 
to the new thread.</ins></p></li>
<li><p>(10.1) &mdash; <code>resource_unavailable_try_again</code> &mdash; the system lacked the necessary resources 
to create another thread, or the system-imposed limit on the number of threads in a process would be exceeded.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

<li><p>Modify 32.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/thread.jthread.cons">[thread.jthread.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F, class... Args&gt; explicit jthread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-3- <i>Constraints:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-8- <i>Postconditions:</i> <code>get_id() != id()</code> is <code>true</code> and <code>ssource.stop_possible()</code> 
is <code>true</code> and <code>*this</code> represents the newly started thread. [<i>Note:</i> The calling thread 
can make a stop request only once, because it cannot replace this stop token. &mdash; <i>end note</i>]
<p/>
-9- <i>Throws:</i> <code>system_error</code> if unable to start the new thread.
<p/>
-10- <i>Error conditions:</i>
</p>
<ol style="list-style-type: none">
<li><p><ins>(10.?) &mdash; <code>not_enough_memory</code> &mdash; the system lacked memory resources to transfer parameters 
to the new thread.</ins></p></li>
<li><p>(10.1) &mdash; <code>resource_unavailable_try_again</code> &mdash; the system lacked the necessary resources 
to create another thread, or the system-imposed limit on the number of threads in a process would be exceeded.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3484"><a href="3484">3484</a>. Should <code>&lt;stddef.h&gt;</code> declare <code>::nullptr_t</code>?</h3>
<p><b>Section:</b> 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2020-09-06 <b>Last modified:</b> 2022-09-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.c.headers.other">active issues</a> in [support.c.headers.other].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.c.headers.other">issues</a> in [support.c.headers.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From this <a href="https://github.com/cplusplus/draft/issues/4144">editorial issue request</a>: 
<p/>
The header <code>&lt;stddef.h&gt;</code> is currently specified in 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a> 
to not declare a global name corresponding to <code>std::byte</code>, but no similar exclusion exists for 
<code>std::nullptr_t</code>.
<p/>
Is an oversight or intentional? There does not seem to be an interoperability reason to provide a global 
namespace name <code>::nullptr_t</code>, since this construction would be meaningless in C and thus the name 
would not be encountered in code that is both valid C and C++.
<p/>
For lack of justification, I would like to propose to require normatively that no name 
<code>::nullptr_t</code> be declared by <code>&lt;stddef.h&gt;</code>.
<p/>
Additional notes: The proposing paper <a href="https://wg21.link/n2431">N2431</a> mentions only an addition 
of "<code>nullptr_t</code>" to <code>&lt;cstddef&gt;</code> and does not discuss the impact on <code>&lt;stddef.h&gt;</code>. 
By omission this means the default rules for <code>&lt;stddef.h&gt;</code> apply and the global name should exist, 
but this does not provide us with a positive signal of intention.
<p/>
I also realize that this is a rather obscure point, and that vendors are already shipping <code>::nullptr_t</code>, 
so I am also happy to drop this issue as not being worth the churn and the increase in implementation complexity 
(since removals don't generally simplify implementations). I would welcome a bit of discussion, though.
</p>

<p><i>[2020-09-29; Priority to P3 after reflector discussions]</i></p>


<p><i>[2022-09-18; Daniel comments]</i></p>

<p>
See also <a href="3782" title="Should &lt;math.h&gt; declare ::lerp? (Status: C++23)">3782</a>, which points out that <code>nullptr_t</code> has become a part of the C standard library 
as of C23 (see <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3042.htm">WG14-N3042</a> and 
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3048.htm">WG14-N3048</a>).
</p>


<p id="res-3484"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a> as indicated:</p>

<blockquote>
<p>
-1- Every C header other than <code>&lt;complex.h&gt;</code> (17.15.2 <a href="https://timsong-cpp.github.io/cppwp/complex.h.syn">[complex.h.syn]</a>), 
<code>&lt;iso646.h&gt;</code> (17.15.3 <a href="https://timsong-cpp.github.io/cppwp/iso646.h.syn">[iso646.h.syn]</a>), <code>&lt;stdalign.h&gt;</code> 
(17.15.4 <a href="https://timsong-cpp.github.io/cppwp/stdalign.h.syn">[stdalign.h.syn]</a>), <code>&lt;stdatomic.h&gt;</code> (32.5.12 <a href="https://timsong-cpp.github.io/cppwp/stdatomic.h.syn">[stdatomic.h.syn]</a>), 
<code>&lt;stdbool.h&gt;</code> (17.15.5 <a href="https://timsong-cpp.github.io/cppwp/stdbool.h.syn">[stdbool.h.syn]</a>), and <code>&lt;tgmath.h&gt;</code> (17.15.6 <a href="https://timsong-cpp.github.io/cppwp/tgmath.h.syn">[tgmath.h.syn]</a>), 
each of which has a name of the form 
<code>&lt;<i>name</i>.h&gt;</code>, behaves as if each name placed in the standard library namespace by the 
corresponding <code>&lt;c<i>name</i>&gt;</code> header is placed within the global namespace scope, except 
for the functions described in 29.7.6 <a href="https://timsong-cpp.github.io/cppwp/sf.cmath">[sf.cmath]</a>, the declaration of <code>std::byte</code> <ins>and
<code>std::nullptr_t</code></ins> (17.2.1 <a href="https://timsong-cpp.github.io/cppwp/cstddef.syn">[cstddef.syn]</a>), and the functions and function templates 
described in 17.2.5 <a href="https://timsong-cpp.github.io/cppwp/support.types.byteops">[support.types.byteops]</a>. It is unspecified whether these names are first
declared or defined within namespace scope (6.4.6 <a href="https://timsong-cpp.github.io/cppwp/basic.scope.namespace">[basic.scope.namespace]</a>) of the namespace 
<code>std</code> and are then injected into the global namespace scope by explicit <i>using-declaration</i>s 
(9.10 <a href="https://timsong-cpp.github.io/cppwp/namespace.udecl">[namespace.udecl]</a>).
</p>
</blockquote>
</li>

<li><p>In [diff.cpp??] [Editorial note: new compatibility section to be created for C++20], add a new entry:</p>

<blockquote>
<p>
<ins><b>Affected subclause:</b> 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a><br/>
<b>Change:</b> Removal of name <code>::nullptr_t</code> from header <code>&lt;stddef.h&gt;</code>.<br/>
<b>Rationale:</b> <code>std::nullptr_t</code> is a C++-only feature that is not useful for interoperability with ISO C.<br/>
<b>Effect on original feature:</b> Valid C++20 code may fail to compile in this International Standard. Occurrences 
of <code>#include &lt;stddef.h&gt;</code> and <code>nullptr_t</code> should be replaced with 
<code>#include &lt;cstddef&gt;</code> and <code>std::nullptr_t</code>.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3486"><a href="3486">3486</a>. <code>is_constructible&lt;T[], T...&gt;</code> may be misleading in C++20</h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-10-01 <b>Last modified:</b> 2020-10-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the current wording,
<code>std::is_constructible&lt;int[], int&gt;</code>
should be true, because the preconditions are met
(all types are complete types or unbounded arrays)
and the variable definition is well-formed since C++20:
</p>
<blockquote><pre>
using T = int[];
T t(declval&lt;int&gt;()); <i>// equiv. to</i> int t[] = {1};
</pre></blockquote>

<p>
However, this doesn't construct an object of type <code>int[]</code>
because it deduces the array bound from the initializers,
and so constructs <code>int[1]</code>, which is not the type being asked about.
It seems more logical for the trait to give a false result
for an unbounded array, because it's an incomplete type,
and no <code>int[]</code> can ever be constructed.
</p>

<p>
On the reflector Tim Song noted:
</p>
<blockquote>
On the other hand, the result is something to which an <code>int(&amp;)[]</code>
can be bound directly thanks to another C++20 change,
so a lot of things might Just Work (for some definition of "Work")
despite the type difference.
</blockquote>

<p>
This seems to me a reasonable rationale for
<code>is_constructible&lt;int(&amp;&amp;)[], int&gt;</code>
to be true (which it is today),
but not for <code>int[]</code>.
</p>

<p>
Peter Dimov replied:
</p>
<blockquote>
Placement new, which is often the way to construct we're interested in,
is not going to work even for <code>T[2]</code>.
</blockquote>

<p>For example:</p>
<blockquote><pre>
using T2 = int[2];
T2 x;
new(x) T2(1, 2); <i>// ill-formed</i>
</pre></blockquote>

<p>
We need to decide what behaviour we want here.
Do we just want <code>is_constructible</code>
to reflect the <code>T(declval&lt;Args...&gt;);</code> construct
as currently specified in 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> p8,
or do we want to give a more useful/meaningful answer here?
</p>

<p>
Should we revisit 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> p8
in the light of parenthesized aggregate init,
so that <code>is_constructible&lt;T[], T&gt;</code>
and <code>is_constructible&lt;T[1], T&gt;</code> are false?
</p>

<p>
There may be some interaction with LWG <a href="3436" title="std::construct_at should support arrays (Status: WP)">3436</a>.
</p>


<p id="res-3486"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="3487"><a href="3487">3487</a>. Missing precondition on input and output aliasing of [numeric.ops]</h3>
<p><b>Section:</b> 26.10 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops">[numeric.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matthias Kretz <b>Opened:</b> 2020-10-01 <b>Last modified:</b> 2020-10-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.ops">issues</a> in [numeric.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The algorithms
<code>partial_sum</code>,
<code>exclusive_scan</code>,
<code>inclusive_scan</code>,
<code>transform_exclusive_scan</code>,
<code>transform_inclusive_scan</code>,
and
<code>adjacent_difference</code>
with no <code>ExecutionPolicy</code> do not have a precondition
"<code>result</code> is not in the range [<code>first</code>, <code>last</code>)".
But they explicitly allow "<code>result</code> may be equal to <code>first</code>".
This suggests the precondition got lost,
because otherwise the permission is redundant.
</p>

<p>
Suggested fix:
Add
"<code>result</code> is not in the range [<code>first + 1</code>, <code>last</code>)."
to the <i>Preconditions</i> paragraphs
of the affected generalized numeric operations.
</p>

<p><i>[2020-10-02; Issue processing telecon: Priority set to P3.]</i></p>




<p id="res-3487"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3488"><a href="3488">3488</a>. Is <code>array&lt;const int, 0&gt;</code> swappable or not?</h3>
<p><b>Section:</b> 23.3.3.4 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2020-10-01 <b>Last modified:</b> 2020-10-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Per 23.3.3.4 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a>/1,
<code>std::array</code>'s non-member swap participates in overload resolution
when the array has size 0 or swappable elements.
The effects of non-member swap are "As if by [member swap]",
but member swap's effects are simply
"Equivalent to swap_ranges(begin(), end(), y.begin())"
per 23.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/array.members">[array.members]</a>/4.
In effect, we've gone out of our way to ensure that
<code>is_swappable_v&lt;array&lt;T, 0&gt;&gt;</code>
and <code>swappable&lt;array&lt;T, 0&gt;&gt;</code>
are always true
despite that actually swapping such an array may be ill-formed.
</p>

<p>
It seems that the wording stops half-way to making
<code>array&lt;T, 0&gt;</code> swappable regardless of <code>T</code>.
I personally find that design distasteful
- it seems a gratuitous difference between
<code>array&lt;T, N&gt;</code> and <code>array&lt;T, 0&gt;</code>
- but I'd prefer a consistent design over the status quo
even if it's the "wrong" design.
</p>

<p><i>[2020-10-02; Issue processing telecon]</i></p>

<p>
Preference for Option B, and successful vote to move to Tentatively Ready.
But on the reflector Tim Song pointed out a conflict with
<a href="2157" title="How does std::array&lt;T,0&gt; initialization work when T is not default-constructible? (Status: Open)">2157</a> and question the decision. Status to Open instead.
Priority set to P3 in line with <a href="2157" title="How does std::array&lt;T,0&gt; initialization work when T is not default-constructible? (Status: Open)">2157</a>.
</p>



<p id="res-3488"><b>Proposed resolution:</b></p>
<p>
Wording relative to <a href="https://wg21.link/n4861">N4861</a>. 
<p/>
This resolution proposes two wording alternatives:
Option A makes <code>array&lt;T, 0&gt;</code> swappable regardless of <code>T</code>,
and the clearly superior Option B makes <code>array&lt;T, N&gt;</code> swappable
only if <code>T</code> is swappable (i.e., regardless of <code>N</code>)
removing gratuitous special-case behavior for the <code>N == 0</code> case.
</p>

<p><b>Option A:</b></p>
<ol>
<li>
<p>Change 23.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/array.members">[array.members]</a> as follows:</p>
<blockquote>
<pre>
constexpr void swap(array&amp; y) noexcept(<ins>N == 0 || </ins>is_nothrow_swappable_v&lt;T&gt;);
</pre>
</blockquote>
<p>
-4- <i>Effects:</i> <ins>If <code>N == 0</code>, no effects. Otherwise, equivalent</ins> <del>Equivalent</del> to <code>swap_ranges(begin(), end(), y.begin())</code>.
</p>
<p>-5- [&hellip;]</p>
</li>
<li>
<p>
Also remove the now-redundant paragraph four from 23.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> as follows:
</p>
<blockquote>
<p>
<del>-4- Member function <code>swap()</code> shall have a non-throwing exception specification.</del>
</p>
</blockquote>
</li>
</ol>

<p><b>Option B:</b></p>
<ol>
<li>
<p>Change 23.3.3.4 <a href="https://timsong-cpp.github.io/cppwp/array.special">[array.special]</a> as follows:</p>
<blockquote>
<pre>
template&lt;class T, size_t N&gt;
constexpr void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
</blockquote>
<p>
-1- <i>Constraints:</i> <del><code>N == 0</code> or</del> <code>is_swappable_v&lt;T&gt;</code> is <code>true</code>.
</p>
</li>
<li>
<p>
Also remove paragraph four from 23.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/array.zero">[array.zero]</a> as follows:
</p>
<blockquote>
<p>
<del>-4- Member function <code>swap()</code> shall have a non-throwing exception specification.</del>
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3489"><a href="3489">3489</a>. Improve <code>istream_view</code> wording</h3>
<p><b>Section:</b> 25.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Michael Schellenberger Costa <b>Opened:</b> 2020-10-09 <b>Last modified:</b> 2021-09-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.istream.iterator">issues</a> in [range.istream.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While implementing <code>iranges::stream_view</code> we found some issues with the <i>Preconditions</i> 
on the member functions of <code>istream_view::iterator</code>, which are superfluous or incorrect.
</p>

<ol>
<li>
<p>
25.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> p2 reads as:
</p>
<blockquote><p>
<i>Preconditions:</i> <code><i>parent_</i>-&gt;<i>stream_</i> != nullptr</code> is <code>true</code>.
</p></blockquote>
<p>
However in the <i>Effects</i> element 25.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> p3 it reads:
</p>
<blockquote>
<p>
<i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
*<i>parent_</i>-&gt;<i>stream_</i> &gt;&gt; <i>parent_</i>-&gt;<i>object_</i>;
return *this;
</pre></blockquote>
</blockquote>
<p>
For the <i>Effects</i> element to be valid, we implicitly require that <code><i>parent_</i> != nullptr</code>, 
<code><i>parent_</i>-&gt;<i>stream_</i> != nullptr</code> and &mdash; because we are reading from the underlying 
stream &mdash; <code>!*x.<i>parent_</i>-&gt;<i>stream_</i></code>.
<p/>
Given that the <i>Preconditions</i> element only mentions one of the three preconditions and essentially 
means that we are not at the end of the stream, we should replace 25.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> p2 
by:
</p>
<blockquote><p>
<i>Preconditions:</i> <code>*this != default_sentinel</code>.
</p></blockquote>
</li>
<li>
<p>
We should use the same precondition for 25.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> p4, even if it is implicit 
via the <i>Effects</i> element in 25.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> p5, as that requires experts knowledge 
of the standard.
</p>
</li>
<li>
<p>
The Precondition in 25.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> p6 is completely bogus, as accessing the 
cached object has no dependency on the stream. We assume it is meant that we are not at the end of the stream. 
Again we should change this to:
</p>
<blockquote><p>
<i>Preconditions:</i> <code>*this != default_sentinel</code>.
</p></blockquote>
</li>
</ol>

<p><i>[2020-10-14; Priority to P3 after reflector discusssion]</i></p>


<p><i>[2021-09-02; Jonathan comments:]</i></p>

<p>
The preconditions were removed by <a href="https://wg21.link/P2325R3" title=" Views should not be required to be default constructible">P2325R3</a> approved in June 2021.
Although the pointers now cannot be null, it's unclear if we want to require
<code>fail()</code> to be false for the stream.
</p>



<p id="res-3489"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4861">N4861</a>. 
</p>

<ol>
<li>
<p>
Modify 25.6.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.istream.iterator">[range.istream.iterator]</a> as indicated:
</p>
<blockquote>
<pre>
<i>iterator</i>&amp; operator++();
</pre>
<blockquote>
<p>
-2- <i>Preconditions:</i> <code><del><i>parent_</i>-&gt;<i>stream_</i> != nullptr</del><ins>*this != default_sentinel</ins></code> 
is <code>true</code>.
<p/>
-3- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
*<i>parent_</i>-&gt;<i>stream_</i> &gt;&gt; <i>parent_</i>-&gt;<i>object_</i>;
return *this;
</pre></blockquote>
</blockquote>
<pre>
void operator++(int);
</pre>
<blockquote>
<p>
-4- <i>Preconditions:</i> <code><del><i>parent_</i>-&gt;<i>stream_</i> != nullptr</del><ins>*this != default_sentinel</ins></code> 
is <code>true</code>.
<p/>
-5- <i>Effects:</i> Equivalent to <code>++*this</code>.
</p>
</blockquote>
<pre>
Val&amp; operator*() const;
</pre>
<blockquote>
<p>
-6- <i>Preconditions:</i> <code><del><i>parent_</i>-&gt;<i>stream_</i> != nullptr</del><ins>*this != default_sentinel</ins></code> 
is <code>true</code>.
<p/>
-7- <i>Effects:</i> Equivalent to: <code>return <i>parent_</i>-&gt;<i>object_</i>;</code>
</p>
</blockquote>
<pre>
friend bool operator==(const <i>iterator</i>&amp; x, default_sentinel_t);
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to: <code>return x.<i>parent_</i> == nullptr || !*x.<i>parent_</i>-&gt;<i>stream_</i>;</code>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3491"><a href="3491">3491</a>. What is a "decayed type"?</h3>
<p><b>Section:</b> 17.12.6 <a href="https://timsong-cpp.github.io/cppwp/cmp.alg">[cmp.alg]</a>, 25.7.6.1 <a href="https://timsong-cpp.github.io/cppwp/range.all.general">[range.all.general]</a>, 17.12.6 <a href="https://timsong-cpp.github.io/cppwp/cmp.alg">[cmp.alg]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2020-10-27 <b>Last modified:</b> 2021-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cmp.alg">active issues</a> in [cmp.alg].</p>
<p><b>View all other</b> <a href="lwg-index.html#cmp.alg">issues</a> in [cmp.alg].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Some of our newer wording for C++20 uses the term "decayed type" as if it were 
a defined term of art.  While I have intuition for what may be intended in these 
cases, it turns out the "function to function pointer decay" and "array to array 
pointer decay" were never actually Core terms of art &mdash; having searched all
standards going back as far as C++03.
<p/>
We should either define this term for library use, or find a way to state
our intent using existing well-defined terms of art.
<p/>
Affected clauses:
<p/>
<ul>
<li><p>17.12.6 <a href="https://timsong-cpp.github.io/cppwp/cmp.alg">[cmp.alg]</a>: Most heavily used here.</p></li>
<li><p>25.7.6.1 <a href="https://timsong-cpp.github.io/cppwp/range.all.general">[range.all.general]</a></p></li>
<li><p>17.12.6 <a href="https://timsong-cpp.github.io/cppwp/cmp.alg">[cmp.alg]</a></p></li>
</ul>
</p>

<p><i>[2021-01-15; Telecon prioritization]</i></p>

<p>
Set priority to 3 following reflector and telecon discussions.
</p>



<p id="res-3491"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3493"><a href="3493">3493</a>. The constructor of <code>std::function</code> taking an <code>F</code> is missing a constraint</h3>
<p><b>Section:</b> 22.10.17.3.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2020-10-31 <b>Last modified:</b> 2021-08-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="https://wg21.link/p0288">P0288</a>, <code>any_invocable</code> is (correctly) constraining
its constructor that takes an <code>F</code>:
</p>
<blockquote>
<pre>
template&lt;class F&gt; any_invocable(F&amp;&amp; f);
</pre>
<blockquote>
<p>
Let <code>VT</code> be <code>decay_t&lt;F&gt;</code>.
<p/>
<i>Constraints:</i>
</p>
<ol style="list-style-type: none">
<li><p>&mdash; [&hellip;]</p></li>
<li><p>&mdash; <code>is_constructible_v&lt;VT, F&gt;</code> is <code>true</code>, and</p></li>
<li><p>&mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>
<p>
<code>std::function</code> doesn't do that. According to <a href="https://wg21.link/n4868">N4868</a>,
22.10.17.3.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> p8 has a constraint for Lvalue-Callable, but not for
copy-constructibility. There is a precondition in p9, but that's not enough for portable
well/ill-formedness.
<p/>
Since this is a constructor, and we want to give the right answer to
<code>is_constructible</code>/<code>constructible_from</code> queries, we should
add the relevant constraint.
</p>

<p><i>[2020-11-01; Daniel comments]</i></p>

<p>
This issue has some overlap with LWG <a href="2774" title="std::function construction vs assignment (Status: C++23)">2774</a>.
</p>

<p><i>[2021-01-15; Telecon prioritization]</i></p>

<p>
Set priority to 3 following reflector and telecon discussions.
</p>

<p><i>[2021-05-17; Tim comments]</i></p>

<p>
The new constraint causes constraint recursion in an example like:
</p>
<blockquote>
<pre>
struct C {
    explicit C(std::function&lt;void()&gt;); // #1
    void operator()() {}
};
static_assert(std::is_constructible_v&lt;C, const C&amp;&gt;);
</pre>
</blockquote>
<p>
Here, to determine whether a <code>C</code> can be constructed from a <code>const C</code>
lvalue, the overload resolution will attempt to determine whether the constructor
marked <code>#1</code> is a viable candidate, which involves a determination of
whether that lvalue can be implicitly converted to a <code>std::function&lt;void()&gt;</code>,
which, with the new constraint, requires a determination whether
<code>C</code> is copy-constructible &mdash; in other words, whether it can be constructed
from a <code>C</code> lvalue.
<p/>
This is similar to LWG <a href="3420" title="cpp17-iterator should check that the type looks like an iterator first (Status: C++23)">3420</a>: in both cases we have a class
(<code>filesystem::path</code> there, <code>function</code> here) that is
convertible from every type that are, <i>inter alia</i>, copy constructible,
and this then results in constraint recursion when we ask whether a different
type that is constructible from such a class is copy constructible.
<p/>
The <code>C</code> above is reduced from an internal helper type in libstdc++. Given
the ubiquity of call wrappers &mdash; types that are callable in their own right
and therefore may not be able to be ruled out by the Lvalue-Callable constraint,
and can also naturally have a constructor that take the wrapped function object
as the argument, triggering the recursion scenario &mdash; it is not clear that
there is a good way to add this constraint without causing undue breakage.
</p>

<p><i>[2021-08-20; LWG telecon]</i></p>

<p>
LWG requested that the constraint cited above for
<code>move_only_function</code> (n&eacute; <code>any_invocable</code>)
be moved to a <i>Mandates:</i> element instead, to avoid the same
constraint recursion.
</p>



<p id="res-3493"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4868">N4868</a>.
</p>

<ol>
<li>
<p>
Modify 22.10.17.3.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.con">[func.wrap.func.con]</a> as indicated:
</p>

<blockquote>
<pre>
template&lt;class F&gt; function(F f);
</pre>
<blockquote>
<p>
-8- <i>Constraints:</i> <code>F</code> is Lvalue-Callable (22.10.17.3.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.func.general">[func.wrap.func.general]</a>) for
argument types <code>ArgTypes...</code> and return type <code>R</code><ins>, and
<code>is_copy_constructible_v&lt;F&gt;</code> is <code>true</code></ins>.
<p/>
-9- <i>Preconditions:</i> <code>F</code> meets the <i>Cpp17CopyConstructible</i> requirements.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3496"><a href="3496">3496</a>. What does "uniquely associated" mean for <code>basic_syncbuf::emit()</code>?</h3>
<p><b>Section:</b> 31.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.members">[syncstream.syncbuf.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-11-10 <b>Last modified:</b> 2020-11-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#syncstream.syncbuf.members">active issues</a> in [syncstream.syncbuf.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#syncstream.syncbuf.members">issues</a> in [syncstream.syncbuf.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
31.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.members">[syncstream.syncbuf.members]</a> p5 says "May call member functions of <code>wrapped</code> while holding a 
lock uniquely associated with <code>wrapped</code>."
<p/>
It's unclear what "uniquely associated" means. Is it required to be a one-to-one mapping, so that every 
<code>streambuf*</code> that is wrapped is associated with a different lock?
<p/>
I believe the intention is only that for a given <code>streambuf*</code> every <code>syncbuf</code> that wraps it 
uses the same lock. The intention was that it's a valid implementation for the same lock to be used for more 
than one <code>streambuf*</code> (e.g. using a table of <code>N</code> locks which are indexed by a hash of the 
<code>streambuf* value)</code>. The current wording can be interpreted to forbid that implementation.
</p>

<p><i>[2020-11-21; Reflector prioritization]</i></p>

<p>
Set priority to 3 during reflector discussions.
</p>


<p id="res-3496"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3497"><a href="3497">3497</a>. Postconditions for <code>basic_syncbuf::emit()</code></h3>
<p><b>Section:</b> 31.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.members">[syncstream.syncbuf.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-11-10 <b>Last modified:</b> 2020-11-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#syncstream.syncbuf.members">active issues</a> in [syncstream.syncbuf.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#syncstream.syncbuf.members">issues</a> in [syncstream.syncbuf.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
31.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/syncstream.syncbuf.members">[syncstream.syncbuf.members]</a> p2 says:
</p>
<blockquote><p>
<i>Postconditions:</i> On success, the associated output is empty.
</p></blockquote>
<p>
Are there any postconditions on failure? If part of the associated output was written, is that 
part still in the associated output? Will another call to <code>emit()</code> duplicate that part?
</p>

<p><i>[2020-11-21; Reflector prioritization]</i></p>

<p>
Set priority to 3 during reflector discussions.
</p>


<p id="res-3497"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3499"><a href="3499">3499</a>. Timed lockable and mutex requirements are imprecise about <code>duration</code> and <code>time_point</code></h3>
<p><b>Section:</b> 32.2.5.4 <a href="https://timsong-cpp.github.io/cppwp/thread.req.lockable.timed">[thread.req.lockable.timed]</a>, 32.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/thread.timedmutex.requirements">[thread.timedmutex.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2020-11-14 <b>Last modified:</b> 2020-11-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The timed lockable and mutex requirements currently use "<code>rel_time</code> denotes an object of an 
instantiation of duration, and <code>abs_time</code> denotes an object of an instantiation of <code>time_point</code>" 
to define the variables used to specify the timed lock functions. During LWG review of 
<a href="https://wg21.link/p2160r0">P2160R0</a>, it was noted that this definition is deficient in two
aspects:
</p>
<ul>
<li><p>It doesn't allow for <i>cv</i>-qualification of <code>rel_time</code> and <code>abs_time</code></p></li>
<li><p>For <code>time_point</code>s, it should require that the clock is a real <i>Cpp17Clock</i>. We impose 
that requirement via 32.2.1 <a href="https://timsong-cpp.github.io/cppwp/thread.req.paramname">[thread.req.paramname]</a>, but there are no template parameters named 
<code>Clock</code> here.</p></li>
</ul>

<p><i>[2020-11-21; Reflector prioritization]</i></p>

<p>
Set priority to 3 during reflector discussions.
</p>


<p id="res-3499"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3501"><a href="3501">3501</a>. <code>basic_syncbuf</code>-related manipulators refer to some <code>Allocator</code> without defining it</h3>
<p><b>Section:</b> 31.7.6.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.manip">[ostream.manip]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-11-15 <b>Last modified:</b> 2020-11-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.manip">issues</a> in [ostream.manip].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From <a href="https://github.com/cplusplus/draft/pull/4300">this editorial issue request</a>: 
</p>
<p>
The three <code>basic_syncbuf</code>-related manipulators <code>emit_on_flush</code>, <code>noemit_on_flush</code>, 
and <code>flush_emit</code> use in their <i>Effects:</i> elements the following wording:
</p>
<blockquote><p>
"If <code>os.rdbuf()</code> is a <code>basic_syncbuf&lt;charT, traits, Allocator&gt;*</code>, called <code>buf</code> 
for the purpose of exposition, calls [&hellip;]
</p></blockquote>
<p>
There are two problems with that wording (even when considering the helpful note following p8): First, 
the type <code>Allocator</code> is not defined elsewhere (e.g. it is not part of the function signature) 
and second, <code>os.rdbuf()</code> has type <code>basic_streambuf&lt;charT, traits&gt;*</code> and not any 
other type.
<p/>
By introducing an expository <code><i>SYNCBUF</i></code> to detect <code>basic_syncbuf</code> during the work 
on the above mentioned editorial issue to solve these problems it turned out that the suggested wording 
fix would introduce an apparently normative change that the <code>syncbuf</code> type must not use a 
program-defined specialization.
</p>

<p><i>[2020-11-21; Reflector prioritization]</i></p>

<p>
Set priority to 3 during reflector discussions.
</p>


<p id="res-3501"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4868">N4868</a>. 
</p>

<blockquote class="note">
<p>
This proposed wording is known to be incorrect, but is nonetheless depicted to present the
overall idea.
</p>
</blockquote>

<ol>
<li>
<p>
Modify 31.7.6.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.manip">[ostream.manip]</a> as indicated:
</p>

<blockquote>
<p>
-1- Each instantiation of any of the function templates specified in this subclause is a designated 
addressable function (16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>).
<p/>
<ins>-?- In this subclause, <code><i>SYNCBUF</i>(p)</code> for a pointer <code>p</code> of type <code>B*</code>
is determined as follows. If <code>*p</code> is a base class subobject of an object of type <code>S</code>,
where <code>S</code> is a specialization generated from the <code>basic_syncbuf</code> primary template,
and <code>is_convertible_v&lt;S*, B*&gt;</code> is <code>true</code>, then <code><i>SYNCBUF</i>(p)</code> is 
<code>dynamic_cast&lt;S*&gt;(p)</code>. Otherwise, <code><i>SYNCBUF</i>(p)</code> is 
<code>static_cast&lt;void*&gt;(nullptr)</code>. [<i>Note ?:</i> To work around the issue that the
<code>Allocator</code> template argument of <code>S</code> cannot be deduced, implementations can introduce an 
intermediate base class to <code>basic_syncbuf</code> that manages its <code>emit_on_sync</code> flag. &mdash; 
<i>end note</i>]</ins>
<p/>
[&hellip;]
</p>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp; emit_on_flush(basic_ostream&lt;charT, traits&gt;&amp; os);
</pre>
<blockquote>
<p>
<ins>Let <code>p</code> be <code><i>SYNCBUF</i>(os.rdbuf())</code>.</ins>
<p/>
-8- <i>Effects:</i> If <code><ins>p</ins><del>os.rdbuf()</del></code> is <ins>not null</ins><del>a 
<code>basic_syncbuf&lt;charT, traits, Allocator&gt;*</code>, called <code>buf</code> for the purpose of exposition</del>, 
calls <code><ins>p</ins><del>buf</del>-&gt;set_emit_on_sync(true)</code>. Otherwise this manipulator has no effect.
<del>[<i>Note 1:</i> To work around the issue that the Allocator template argument cannot be deduced, 
implementations can introduce an intermediate base class to <code>basic_syncbuf</code> that manages 
its <code>emit_on_sync</code> flag. &mdash; <i>end note</i>]</del>
<p/>
-9- <i>Returns:</i> <code>os</code>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp; noemit_on_flush(basic_ostream&lt;charT, traits&gt;&amp; os);
</pre>
<blockquote>
<p>
<ins>Let <code>p</code> be <code><i>SYNCBUF</i>(os.rdbuf())</code>.</ins>
<p/>
-10- <i>Effects:</i> If <code><ins>p</ins><del>os.rdbuf()</del></code> is <ins>not null</ins><del>a 
<code>basic_syncbuf&lt;charT, traits, Allocator&gt;*</code>, called <code>buf</code> for the purpose of exposition</del>, 
calls <code><ins>p</ins><del>buf</del>-&gt;set_emit_on_sync(false)</code>. 
Otherwise this manipulator has no effect.
<p/>
-11- <i>Returns:</i> <code>os</code>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp; flush_emit(basic_ostream&lt;charT, traits&gt;&amp; os);
</pre>
<blockquote>
<p>
<ins>Let <code>p</code> be <code><i>SYNCBUF</i>(os.rdbuf())</code>.</ins>
<p/>
-12- <i>Effects:</i> Calls <code>os.flush()</code>. Then, if <code><ins>p</ins><del>os.rdbuf()</del></code> is 
<ins>not null</ins><del>a <code>basic_syncbuf&lt;charT, traits, Allocator&gt;*</code>, called <code>buf</code> 
for the purpose of exposition</del>, calls <code><ins>p</ins><del>buf</del>-&gt;emit()</code>.
<p/>
-13- <i>Returns:</i> <code>os</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3503"><a href="3503">3503</a>. <code>chrono::ceil</code> has surprising requirement</h3>
<p><b>Section:</b> 30.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cast">[time.duration.cast]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-11-18 <b>Last modified:</b> 2024-09-19</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cast">[time.duration.cast]</a> p7 requires that the return value is "The least result <code>t</code>
representable in <code>ToDuration</code> for which <code>t &gt;= d</code>".
<p/>
This means that <code>chrono::ceil&lt;chrono::microseconds&gt;(chrono::duration&lt;float, milli&gt;(m)).count()</code>
is required to be the smallest integer <code>n</code> such that <code>(float)n == m*1000.0f</code>, which might be less
than the mathematically correct value of <code>m &times; 1000</code>.
<p/>
(The specific values below assume <code>float</code> uses the IEEE binary32 format and default rounding, but
similar problems will exist for other formats, even if the specific values are different.)
<p/>
For example, if <code>m == 13421772.0f</code> then the naively expected result is <code>n == 13421772000</code>, but
the standard requires <code>n == 13421771265</code>, a significantly lower value. This surprising result is a
consequence of how the <code>chrono::ceil</code> spec interacts with floating-point arithmetic, due to the fact that
for the integers in the range <code>[13421770753, 13421772799]</code>, only one can be exactly represented as
32-bit <code>float</code>. All but that one will be rounded to a different value when converted to <code>float</code>.
<p/>
A straightforward implementation of <code>chrono::ceil</code> will produce <code>(long long)(13421772.0f * 1000)</code>
which is <code>13421771776</code>, which is less than the expected result, but compares equal using the <code>t &gt;= d</code>
expression. That expression converts both operands to their <code>common_type</code>, which is
<code>chrono::duration&lt;float, micro&gt;</code>. That means we compare <code>(float)13421771776 &gt;= (13421772.0f * 1000)</code>
which is <code>true</code>. But the spec requires an even worse result. All integers in <code>[13421771265, 13421771776)</code>
are also rounded to that value when converted to <code>float</code>. That means <code>chrono::microseconds(13421771265)</code>
is "the least result representable in <code>ToDuration</code> for which <code>t &gt;= d</code>".
<p/>
Meeting the "least result" requirement is impractical, and unhelpful. The straightforward result <code>13421771776</code>
is already lower than the naively expected result (which is surprising for a "ceil" function). To meet the
standard's requirements the implementation would have to do extra work, just to produce an even lower (and even
more surprising) result.
<p/>
It might be impractical to require the naively expected value to be returned (the additional work might have
unacceptable performance implications), but the standard  should at least permit the straightforward result
instead of requiring an even worse one.
<p/>
The same problem almost certainly exists for <code>chrono::floor</code> in reverse.
</p>

<p><i>[2020-11-29; Reflector prioritization]</i></p>

<p>
Set priority to 3 during reflector discussions.
</p>
<p><i>[2024-09-19; Jonathan adds a note]</i></p>

<p>
Another problem discovered by STL occurs when the result is floating-point.
We can't just add 1. In fact, there is no requirement for whole-numberness.
</p>
<p>
For example, when converting from <code class='backtick'>double</code> to <code class='backtick'>float</code>:
<pre>
<code>chrono::floor&lt;duration&lt;float&gt;&gt;(duration&lt;double&gt;(0.1))</code>
</pre>
This produces the result <code>duration&lt;float&gt;(-0.9f)</code>
with the reference implementation in <a href="https://wg21.link/P0092R1" title=" Polishing">P0092R1</a>,
and the implementations in libstdc++, libc++, and MSVC.
This is because <code>0.1f &lt;= 0.1</code> is false,
so the result is <code>duration&lt;float&gt;(0.1f - 1.0f)</code>,
which is not the greatest value representable that is not greater than <code class='backtick'>1.0</code>.
The correct result according to the standard would be
<code>duration&lt;float&gt;(nexttoward(0.1f, -HUGE_VAL))</code>,
but we can't use <code class='backtick'>nexttoward</code> for arbitrary <code class='backtick'>treat_as_floating_point</code> types,
only for <code class='backtick'>float</code>, <code class='backtick'>double</code> and <code class='backtick'>long double</code>.
</p>
<p>
STL found cases where
<code>ceil&lt;duration&lt;float&gt;&gt;(duration&lt;double&gt;(x))</code>
produces a value that is lower than <code class='backtick'>x</code>, e.g. for <code class='backtick'>x = 13421771263.0</code>
the result is <code class='backtick'>13421770752.0f</code>.
</p>
<p>
A possible resolution for this problem would be to make <code class='backtick'>ceil</code> and <code class='backtick'>floor</code>
behave exactly like <code class='backtick'>duration_cast</code> when the result is a floating-point type.
This would still permit a <code class='backtick'>ceil</code> that is smaller than the input
(and a <code class='backtick'>floor</code> result that is larger) but that's just a consequence of
converting to a floating-point type with less precision.
We could also specify that for non-floating-point result types,
the effects should be what all known implementations do.
That would mean the behaviour is at least predictable and explainable,
even if the result is not always the correct mathematical value.
</p>


<p id="res-3503"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>
<ol>
<li><p>Modify 30.5.8 <a href="https://timsong-cpp.github.io/cppwp/time.duration.cast">[time.duration.cast]</a> as indicated:</p>
<blockquote>
<pre>
template&lt;class ToDuration, class Rep, class Period&gt;
  constexpr ToDuration floor(const duration&lt;Rep, Period&gt;&amp; d);
</pre>
<p>-4-
<i>Constraints</i>: <code class='backtick'>ToDuration</code> is a specialization of <code class='backtick'>duration</code>.
</p>
<p>-5-
<del>
<i>Returns</i>:
The greatest result <code class='backtick'>t</code> representable in <code class='backtick'>ToDuration</code> for which
<code>t &lt;= d</code>.
</del>
</p>
<p>
<ins><i>Effects</i>: Equivalent to:</ins>
<pre><code><ins>auto t = duration_cast&lt;ToDuration&gt;(d);
if constexpr (treat_as_floating_point_v&lt;typename ToDuration::rep&gt;)
  return t;
else if (t &lt;= d)
  return t;
else
  return --t;
</ins></code></pre>
</p>

<pre>
template&lt;class ToDuration, class Rep, class Period&gt;
  constexpr ToDuration ceil(const duration&lt;Rep, Period&gt;&amp; d);
</pre>
<p>-6-
<i>Constraints</i>: <code class='backtick'>ToDuration</code> is a specialization of <code class='backtick'>duration</code>.
</p>
<p>-7-
<del>
<i>Returns</i>:
The least result <code class='backtick'>t</code> representable in <code class='backtick'>ToDuration</code> for which
<code>t &gt;= d</code>.
</del>
</p>
<p>
<ins><i>Effects</i>: Equivalent to:</ins>
<pre><code><ins>auto t = duration_cast&lt;ToDuration&gt;(d);
if constexpr (treat_as_floating_point_v&lt;typename ToDuration::rep&gt;)
  return t;
else if (t &gt;= d)
  return t;
else
  return ++t;
</ins></code></pre>
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3504"><a href="3504">3504</a>. <code>condition_variable::wait_for</code> is overspecified</h3>
<p><b>Section:</b> 32.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-11-18 <b>Last modified:</b> 2024-06-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> p24 says:
</p>
<blockquote><p>
<i>Effects:</i> Equivalent to: <code>return wait_until(lock, chrono::steady_clock::now() + rel_time);</code>
</p></blockquote>
<p>
This is overspecification, removing implementer freedom to make <code>cv.wait_for(duration&lt;float&gt;(1))</code> work accurately.
<p/>
The type of <code>steady_clock::now() + duration&lt;float&gt;(n)</code> is <code>time_point&lt;steady_clock, 
duration&lt;float, steady_clock::period&gt;&gt;</code>. If the steady clock's period is <code>std::nano</code> 
and its epoch is the time the system booted, then in under a second a 32-bit <code>float</code> becomes unable 
to exactly represent those <code>time_points</code>! Every second after boot makes <code>duration&lt;float, nano&gt;</code> 
less precise.
<p/>
This means that adding a <code>duration&lt;float&gt;</code> to a <code>time_point</code> (or <code>duration</code>) 
measured in nanoseconds is unlikely to produce an accurate value. Either it will round down to a value less 
than <code>now()</code>, or round up to one greater than <code>now() + 1s</code>. Either way, the <code>wait_for(rel_time)</code> 
doesn't wait for the specified time, and users think the implementation is faulty.
<p/>
A possible solution is to use <code>steady_clock::now() + ceil&lt;steady_clock::duration&gt;(rel_time)</code> 
instead. This converts the relative time to a suitably large integer, and then the addition is not affected 
by floating-point rounding errors due to the limited precision of 32-bit <code>float</code>. Libstdc++ has been 
doing this for nearly three years. Alternatively, the standard could just say that the relative timeout is 
converted to an absolute timeout measured against the steady clock, and leave the details to the implementation. 
Some implementations might not be affected by the problem (e.g. if the steady clock measures milliseconds, 
or processes only run for a few seconds and use the process start as the steady clock's epoch).
<p/>
This also affects the other overload of <code>condition_variable::wait_for</code>, and both overloads of 
<code>condition_variable_any::wait_for</code>.
</p>

<p><i>[2020-11-29; Reflector prioritization]</i></p>

<p>
Set priority to 3 during reflector discussions.
</p>

<p><i>[2024-06-18; Jonathan adds wording]</i></p>



<p id="res-3504"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>
<ol>
<li>
<p>Modify 32.7.1 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.general">[thread.condition.general]</a> as indicated,
adding a new paragraph to the end:</p>
<blockquote>
<ins>-6-
The definitions in 32.7 <a href="https://timsong-cpp.github.io/cppwp/thread.condition">[thread.condition]</a> make use of the
following exposition-only function:
</ins>
<blockquote>
<pre><code><ins>template&lt;class Dur&gt;
  chrono::steady_clock::time_point <em>rel-to-abs</em>(const Dur&amp; rel_time)
  { return chrono::steady_clock::now() + chrono::ceil&lt;chrono::steady_clock::duration&gt;(rel_time); }
</ins>
</code></pre>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 32.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> as indicated:</p>
<blockquote>
<pre><code>
template&lt;class Rep, class Period&gt;
  cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                     const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></pre>
<p>-23- <i>Preconditions</i>:
<code class='backtick'>lock.owns_lock()</code> is <code class='backtick'>true</code> and <code class='backtick'>lock.mutex()</code> is locked by the calling thread,
and either [...]
</p>
<p>-24- <i>Effects</i>: Equivalent to:
<blockquote><code>
return wait_until(lock, <del>chrono::steady_clock::now() + rel_time</del> <ins><em>rel-to-abs</em>(rel_time)</ins>);
</code></blockquote>
</p>
<p>[...]</p>
<pre><code>
template&lt;class Rep, class Period, class Predicate&gt;
  cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
                     const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
                     Predicate pred);
</code></pre>
<p>-35- <i>Preconditions</i>:
<code class='backtick'>lock.owns_lock()</code> is <code class='backtick'>true</code> and <code class='backtick'>lock.mutex()</code> is locked by the calling thread,
and either [...]
</p>
<p>-36- <i>Effects</i>: Equivalent to:
<blockquote><code>
return wait_until(lock, <del>chrono::steady_clock::now() + rel_time</del> <ins><em>rel-to-abs</em>(rel_time)</ins>, std::move(pred));
</code></blockquote>
</p>
<p>
[<i>Note 8</i>:
There is no blocking if <code class='backtick'>pred()</code> is initially <code class='backtick'>true</code>, even if the timeout has already expired.
&mdash; <i>end note</i>]
</p>
</blockquote>
</li>

<li>
<p>Modify 32.7.5.2 <a href="https://timsong-cpp.github.io/cppwp/thread.condvarany.wait">[thread.condvarany.wait]</a> as indicated:</p>
<blockquote>
<pre><code>
template&lt;class Lock, class Rep, class Period&gt;
  cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</code></pre>
<p>-11- <i>Effects</i>: Equivalent to:
<blockquote><code>
return wait_until(lock, <del>chrono::steady_clock::now() + rel_time</del> <ins><em>rel-to-abs</em>(rel_time)</ins>);
</code></blockquote>
</p>
<p>[...]</p>
<pre><code>
template&lt;class Lock, class Rep, class Period, class Predicate&gt;
  cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time, Predicate pred);
</code></pre>
<p>-19- <i>Effects</i>: Equivalent to:
<blockquote><code>
return wait_until(lock, <del>chrono::steady_clock::now() + rel_time</del> <ins><em>rel-to-abs</em>(rel_time)</ins>, std::move(pred));
</code></blockquote>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3507"><a href="3507">3507</a>. P0881R7 ("stacktrace") does not define "actual file name", "actual line number"</h3>
<p><b>Section:</b> 19.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.entry.query">[stacktrace.entry.query]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas K&ouml;ppe <b>Opened:</b> 2020-12-02 <b>Last modified:</b> 2023-01-11</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of 19.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.entry.query">[stacktrace.entry.query]</a> uses the terms "presumed or actual name 
of the source file" and "actual line number". It makes reference to 15.12 <a href="https://timsong-cpp.github.io/cppwp/cpp.predefined">[cpp.predefined]</a>, 
which introduces the term "presumed". It does not clearly define the term, but it describes how the 
presumed values can be modified with preprocessor directives. However, there is no definition whatsoever 
of "actual".
<p/>
The term should either be defined, or we should strike the "actual" parts of the stacktrace wording. 
We should consult implementers about this.
<p/>
I don't have a proposed resolution, but if we want to keep "actual", then perhaps we should define 
both "presumed" and "actual" in 15.12 <a href="https://timsong-cpp.github.io/cppwp/cpp.predefined">[cpp.predefined]</a>.
</p>

<p><i>[2021-01-15; Telecon prioritization]</i></p>

<p>
Set priority to 2 following reflector and telecon discussions.
</p>

<p><i>[2023-01-11; LWG telecon]</i></p>

<p>
We want to know the original intended meaning of "actual line number" here.
Presumably debuginfo stored in binaries uses a real line number in the source,
not one that might have been set by a <code>#line</code> directive.
The "presumed or actual" wording was added in R2 of the paper, possibly
as a result of LWG review.
</p>


<p id="res-3507"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3511"><a href="3511">3511</a>. Clarify global permission to move</h3>
<p><b>Section:</b> 16.4.5.9 <a href="https://timsong-cpp.github.io/cppwp/res.on.arguments">[res.on.arguments]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Gonzalo Brito Gadeschi <b>Opened:</b> 2020-12-08 <b>Last modified:</b> 2021-01-15</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.arguments">issues</a> in [res.on.arguments].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The intent of LWG <a href="1204" title="Global permission to move (Status: C++11)">1204</a> is to allow standard library APIs accepting rvalue arguments:
</p>
<ul>
<li><p>to move from their arguments, e.g., without having to specify that they might do this as part of 
their <i>Effects</i> clause, and</p></li>
<li><p>to assume that rvalue arguments do not alias any pointer in the scope of the standard library API, 
e.g., to allow <code>vector</code>'s <code>push_back(T&amp;&amp; t)</code> to assume that <code>t</code> is not an 
element of the <code>vector</code>.</p></li>
</ul>
<p>
The current wording in 16.4.5.9 <a href="https://timsong-cpp.github.io/cppwp/res.on.arguments">[res.on.arguments]</a>/1.3 states:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
If a function argument binds to an rvalue reference parameter, the implementation may assume that this 
parameter is a unique reference to this argument.
</p>
</blockquote>
<p>
This sentence is not clear about the scope in which the reference can be assumed to be unique, and it 
does not explicitly state that the function can modify the argument, e.g., to move from it.
<p/>
If the scope of the "unique reference" is "whole program scope", this example:
</p>
<blockquote><pre>
void example(vector&lt;int&gt;&amp; a, int* b) 
{
  int* c = b;            <i>// reference to object pointed at by</i> <code>b</code>
  a.push_back(move(*b)); <i>// UB: rvalue reference aliases</i> <code>c</code><i>: not unique in whole-program scope</i>
  assert(c == b);        <i>// FAILS: if rvalue reference to</i> <code>*b</code><i> is unique,</i> <code>b</code><i> is unique, and</i> <code>c == b</code><i> is false</i>
}
</pre></blockquote>
<p>
exhibits UB because the implementation may assume that the reference to <code>b</code> is unique, which 
does not hold since <code>c</code> is also a reference to <code>b</code>.  
<p/>
If the scope of the "unique reference" is the "function scope" of the standard
library API, then the semantics of the rvalue reference argument are very similar
to those of C's <code>restrict</code>. This allows aliasing optimizations, for example:
</p>
<blockquote><pre>
void std_api(int&amp;&amp; a, int&amp;&amp; b); <i>// allowed to assume that</i> <code>a</code><i> and</i> <code>b</code> <i>do not alias</i>
int a, b, c;
std_api(move(a), move(b)); <i>// OK: two unique references in</i> <code>std_api</code>
std_api(move(c), move(c)); <i>// UB:</i> <code>a</code> <i>and</i> <code>b</code> <i>alias</i>
</pre></blockquote>
<p>
See <a href="https://bugs.llvm.org/show_bug.cgi?id=48238">llvm Bug 48238</a> for a bug tracking 
the implementation of these optimizations in clang.
<p/>
This also allows optimizing <code>vector::push_back(T&amp;&amp; t)</code> since if <code>t</code> does not 
alias any pointer in <code>vector::push_back</code>'s scope, it also does not alias <code>this</code>, 
<code>this-&gt;data()</code>, <code>(*this)[0]</code>, etc.
</p>

<p><i>[2021-01-15; Telecon prioritization]</i></p>

<p>
Set priority to 3 following reflector and telecon discussions.
</p>



<p id="res-3511"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4868">N4868</a>. 
</p>

<ol>
<li><p>Modify 16.4.5.9 <a href="https://timsong-cpp.github.io/cppwp/res.on.arguments">[res.on.arguments]</a> as indicated:</p>

<blockquote>
<p>
-1- Each of the following applies to all arguments to functions defined in the C++ standard library, unless
explicitly stated otherwise.
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If an argument to a function has an invalid value (such as a value outside the 
domain of the function or a pointer invalid for its intended use), the behavior is undefined.</p></li>
<li><p>(1.2) &mdash; If a function argument is described as being an array, the pointer actually passed 
to the function shall have a value such that all address computations and accesses to objects (that 
would be valid if the pointer did point to the first element of such an array) are in fact valid.</p></li>
<li><p>(1.3) &mdash; If a function argument binds to an rvalue reference parameter, the implementation 
may assume that this parameter is a unique reference to <del>this argument</del><ins>the value within 
the function's scope and may move from it</ins>.
<p/>
<ins>[<i>Example ?:</i></ins>
</p>
<blockquote><pre>
<ins>void std_api(int&amp;&amp; a);
int a;
std_api(move(a));
<i>// <code>a</code> is in an unspecified but valid state</i></ins>
</pre></blockquote>
<p>
<ins>&mdash; <i>end example</i>]</ins>
<p/>
<ins>[<i>Example ?:</i></ins>
</p>
<blockquote><pre>
<ins>void std_api(int&amp;&amp; a, int&amp;&amp; b);
int a, b, c;
std_api(move(a), move(b)); <i>// OK:</i> <code>int&amp;&amp; a</code> <i>and</i> <code>int&amp;&amp; b</code> <i>do not alias</i>
std_api(move(c), move(c)); <i>// UB:</i> <code>int&amp;&amp; a</code> <i>and</i> <code>int&amp;&amp; b</code> <i>alias</i></ins>
</pre></blockquote>
<p>
<ins>&mdash; <i>end example</i>]</ins>
<p/>
<ins>[<i>Example ?:</i></ins>
</p>
<blockquote><pre>
<ins>std::vector&lt;int&gt; a = {...};
a.push_back(move(42)); <i>// OK: unique reference</i>
a.push_back(move(a[0])); <i>// UB:</i> <code>(*this)[0]</code> <i>and rvalue argument alias</i></ins>
</pre></blockquote>
<p>
<ins>&mdash; <i>end example</i>]</ins>
<p/>
[<i>Note 1:</i> If the parameter is a generic parameter of the form <code>T&amp;&amp;</code> and an lvalue 
of type <code>A</code> is bound, the argument binds to an lvalue reference (13.10.3.2 <a href="https://timsong-cpp.github.io/cppwp/temp.deduct.call">[temp.deduct.call]</a>) 
and thus is not covered by <del>the previous sentence</del><ins>this item</ins>. &mdash; end note]
<del>[<i>Note 2:</i> If a program casts an lvalue to an xvalue while passing that lvalue to a library function 
(e.g., by calling the function with the argument <code>std::move(x))</code>, the program is effectively asking 
that function to treat that lvalue as a temporary object. The implementation is free to optimize away 
aliasing checks which might be needed if the argument was an lvalue. &mdash; end note]</del></p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3512"><a href="3512">3512</a>. Incorrect exception safety guarantee for unordered containers</h3>
<p><b>Section:</b> 22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2020-12-28 <b>Last modified:</b> 2021-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See <a href="https://github.com/cplusplus/draft/issues/4437">this editorial issue</a>.
<p/>
22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a> p5.4 ends with "shall not throw an exception unless <code>hash&lt;Key&gt;</code> 
is a program-defined specialization that depends on at least one program-defined type."
<p/>
This seems wrong, because <code>hash&lt;optional&lt;T&gt;&gt;</code> is not a program-defined specialization, 
but it might throw if <code>hash&lt;T&gt;</code> can throw. There are also other partial specializations 
of <code>std::hash</code> defined in the standard library but that depend on program-defined specializations 
and so can throw.
</p>

<p><i>[2021-01-29; reflector prioritization]</i></p>

Set priority to 3 following reflector discussions.
It was pointed out that this wording could be simplified if <a href="3513" title="Fix definition of program-defined based on its uses (Status: New)">3513</a>
changes the definition of program-defined type.



<p id="res-3512"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3513"><a href="3513">3513</a>. Fix definition of program-defined based on its uses</h3>
<p><b>Section:</b> 3.43 <a href="https://timsong-cpp.github.io/cppwp/defns.prog.def.type">[defns.prog.def.type]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2020-12-29 <b>Last modified:</b> 2021-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following definitions:
</p>
<blockquote><p>
<b>3.42 [defns.prog.def.spec]</b><br/> 
<b>program-defined specialization</b><br/>
&lt;library&gt; explicit template specialization or partial specialization that is not part 
of the C++ standard library and not defined by the implementation
</p></blockquote>
<p>
and
</p>
<blockquote><p>
<b>3.43 [defns.prog.def.type]</b><br/>
<b>program-defined type</b><br/>
&lt;library&gt; non-closure class type or enumeration type that is not part of the C++ standard library 
and not defined by the implementation, or a closure type of a non-implementation-provided lambda expression, 
or an instantiation of a program-defined specialization
[<i>Note 1 to entry:</i> Types defined by the implementation include extensions (4.1) and internal types 
used by the library. &mdash; <i>end note</i>]
</p></blockquote>
<p>
A program-defined type is either a type or an instantiation. "program-defined type" is used in 
16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> p2 to give permission to specialize standard class templates:
</p>
<blockquote><p>
Unless explicitly prohibited, a program may add a template specialization for any standard library class
template to namespace <code>std</code> provided that (a) the added declaration depends on at least one 
program-defined type and (b) the specialization meets the standard library requirements for the original 
template.
</p></blockquote>
<p>
ISO requires that the terms in Clause 3 be substitutable with their definitions. If this were done for 
"program-defined type", we'd end up with "or an instantiation of a program-defined specialization".
It's fine to depend on a type, but not an instantiated type, because all you need is the name of its 
specialization (its type) as a template argument to explicitly or partially specialize a template.
</p>

<p><i>[2021-01-29; reflector prioritization]</i></p>

Set priority to 3 following reflector discussions.
It was pointed out that it might be easier to resolve <a href="3512" title="Incorrect exception safety guarantee for unordered containers (Status: New)">3512</a>
if this issue changes the definition of program-defined type.



<p id="res-3513"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>. 
</p>

<ol>
<li><p>Modify 3.43 <a href="https://timsong-cpp.github.io/cppwp/defns.prog.def.type">[defns.prog.def.type]</a> as indicated:</p>

<blockquote>
<b>3.43 [defns.prog.def.type]</b><br/>
<b>program-defined type</b><br/>
&lt;library&gt; non-closure class type or enumeration type that is not part of the C++ standard library 
and not defined by the implementation, or a closure type of a non-implementation-provided lambda expression, 
or <del>an instantiation</del><ins>a name</ins> of a program-defined specialization <ins>or instantiation 
thereof</ins>
[<i>Note 1 to entry:</i> Types defined by the implementation include extensions (4.1 <a href="https://timsong-cpp.github.io/cppwp/intro.compliance">[intro.compliance]</a>) 
and internal types used by the library. &mdash; <i>end note</i>]
</blockquote>
</li>
</ol>





<hr>
<h3 id="3516"><a href="3516">3516</a>. <code>thread::id</code> spaceship may be inconsistent with equality</h3>
<p><b>Section:</b> 32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2021-01-26 <b>Last modified:</b> 2021-03-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a>/5-7 specify the behavior of <code>==</code> and <code>&lt;=&gt;</code> for 
<code>std::thread::id</code>:
</p>
<blockquote>
<pre>
bool operator==(thread::id x, thread::id y) noexcept;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> <code>true</code> only if <code>x</code> and <code>y</code> represent the same thread of execution 
or neither <code>x</code> nor <code>y</code> represents a thread of execution.
</p>
</blockquote>
<pre>
strong_ordering operator&lt;=&gt;(thread::id x, thread::id y) noexcept;
</pre>
<blockquote>
<p>
-6- Let <code><i>P</i>(x, y)</code> be an unspecified total ordering over <code>thread::id</code> as described in 25.8.
<p/>
-7- <i>Returns:</i> <code>strong_ordering::less</code> if <code><i>P</i>(x, y)</code> is <code>true</code>. Otherwise, 
<code>strong_ordering::greater</code> if <code><i>P</i>(y, x)</code> is <code>true</code>. Otherwise, <code>strong_ordering::equal</code>.
</p>
</blockquote>
</blockquote>
<p>
"Unspecified total ordering" provides too much freedom, since it does not require that <code>!P(x, y)</code> 
holds when <code>x</code> and <code>y</code> both represent the same thread of execution or both represent no 
thread of execution. A conforming implementation could return <code>strong_ordering::equal</code> from 
<code>&lt;=&gt;</code> for a pair of <code>thread::id</code> values for which <code>==</code> returns <code>false</code>. 
We should guarantee consistency of <code>==</code> and <code>&lt;=&gt;</code> for <code>thread::id</code> to 
preserve sanity of the programming model.
</p>

<p><i>[2021-03-12; Reflector poll]</i></p>

<p>
Set priority to 3 following reflector poll.
</p>



<p id="res-3516"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>. 
</p>

<ol>
<li><p>Modify 32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a> as indicated:</p>

<blockquote>
<pre>
strong_ordering operator&lt;=&gt;(thread::id x, thread::id y) noexcept;
</pre>
<blockquote>
<p>
-6- Let <code><i>P</i>(x, y)</code> be <del>an unspecified</del><ins>a</ins> total ordering over <code>thread::id</code> 
as described in 26.8 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting">[alg.sorting]</a><ins>, unspecified except that <code><i>P</i>(x, y)</code> is <code>false</code> 
when <code>x</code> and <code>y</code> both represent the same thread of execution, or when neither represents a thread 
of execution</ins>.
<p/>
-7- <i>Returns:</i> <code>strong_ordering::less</code> if <code><i>P</i>(x, y)</code> is <code>true</code>. Otherwise, 
<code>strong_ordering::greater</code> if <code><i>P</i>(y, x)</code> is <code>true</code>. Otherwise, <code>strong_ordering::equal</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3531"><a href="3531">3531</a>. LWG 3025 broke previous valid code</h3>
<p><b>Section:</b> 23.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/map.overview">[map.overview]</a>, 23.4.4.1 <a href="https://timsong-cpp.github.io/cppwp/multimap.overview">[multimap.overview]</a>, 23.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/unord.map.overview">[unord.map.overview]</a>, 23.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/unord.multimap.overview">[unord.multimap.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2021-03-09 <b>Last modified:</b> 2021-04-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#map.overview">active issues</a> in [map.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#map.overview">issues</a> in [map.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution for LWG <a href="3025" title="Map-like container deduction guides should use pair&lt;Key, T&gt;, not pair&lt;const Key, T&gt; (Status: C++20)">3025</a> enabled code like the following to be accepted:
</p>
<blockquote><pre>
map m1{{pair{1, 2}, {3, 4}}, less&lt;int&gt;()};
</pre></blockquote>
<p>
but breaks code that had been previously working like the following
</p>
<blockquote><pre>
using value_type = pair&lt;const int, int&gt;;

map m2{{value_type{1, 2}, {3, 4}}, less&lt;int&gt;()};
</pre></blockquote>
<p>
as shown <a href="https://godbolt.org/z/rz3fb9">on godbolt</a>.
<p/>
[Acknowledgment to Tim Song and Arthur O'Dwyer for independently pointing out this case on the LWG mailing list]
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Priority set to 3. Three preferences expressed for Option B, none for A.
</p>



<p id="res-3531"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<blockquote class="note">
<p>
We present two <em>partial</em> wording options for <code>std::map</code>, denoted by <b>(A)</b> and <b>(B)</b> below. 
If the committee accepts one of them, we will complete them to all key-value containers.
</p>
</blockquote>

<ol style="list-style-type: none">
<li><p><b>(A)</b> Wording option 1: In this option, we restore the deduction guide that was removed in LWG 
<a href="3025" title="Map-like container deduction guides should use pair&lt;Key, T&gt;, not pair&lt;const Key, T&gt; (Status: C++20)">3025</a> while maintaining the one that was added, <a href="https://godbolt.org/z/j74n9W"/> demonstrates 
this working.</p>
<ol>
<li><p>Modify 23.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/map.overview">[map.overview]</a> as indicated:</p>
<blockquote>
<pre>
[&hellip;]
template&lt;class Key, class T, class Compare = less&lt;Key&gt;,
         class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;
  map(initializer_list&lt;pair&lt;Key, T&gt;&gt;, Compare = Compare(), Allocator = Allocator())
    -&gt; map&lt;Key, T, Compare, Allocator&gt;;
    
<ins>template&lt;class Key, class T, class Compare = less&lt;Key&gt;,
         class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;
  map(initializer_list&lt;pair&lt;const Key, T&gt;&gt;, Compare = Compare(), Allocator = Allocator())
    -&gt; map&lt;Key, T, Compare, Allocator&gt;;</ins>

template&lt;class InputIterator, class Allocator&gt;
  map(InputIterator, InputIterator, Allocator)
    -&gt; map&lt;<i>iter-key-type</i>&lt;InputIterator&gt;, <i>iter-mapped-type</i>&lt;InputIterator&gt;,
           less&lt;<i>iter-key-type</i>&lt;InputIterator&gt;&gt;, Allocator&gt;;
           
template&lt;class Key, class T, class Allocator&gt;
  map(initializer_list&lt;pair&lt;Key, T&gt;&gt;, Allocator) -&gt; map&lt;Key, T, less&lt;Key&gt;, Allocator&gt;;           
           
<ins>template&lt;class Key, class T, class Allocator&gt;
  map(initializer_list&lt;pair&lt;const Key, T&gt;&gt;, Allocator) -&gt; map&lt;Key, T, less&lt;Key&gt;, Allocator&gt;;</ins>
[&hellip;]
</pre>
</blockquote>
</li>
</ol>
</li>

<li><p><b>(B)</b> Wording option 2: This one follows <a href="https://lists.isocpp.org/lib/2019/08/13091.php">Tim Song's suggestion</a>: 
"It seems that the cleanest fix is to 1) disallow the <code>initializer_list&lt;value_type&gt;</code> constructors from being 
used for CTAD, and 2) change the guides to use <code>remove_const_t&lt;Key&gt;</code>." This change has been tested locally 
with g++ similar to the above godbolt.</p>
<ol>
<li><p>Modify 23.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/map.overview">[map.overview]</a> as indicated:</p>
<blockquote><pre>
[&hellip;]
<i>// types</i>
using key_type = Key;
using mapped_type = T;
using value_type = <ins>type_identity_t&lt;</ins>pair&lt;const Key, T&gt;<ins>&gt;</ins>;
[&hellip;]

template&lt;class Key, class T, class Compare = less&lt;<ins>remove_const_t&lt;</ins>Key<ins>&gt;</ins>&gt;,
         class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;
  map(initializer_list&lt;pair&lt;Key, T&gt;&gt;, Compare = Compare(), Allocator = Allocator())
    -&gt; map&lt;<ins>remove_const_t&lt;</ins>Key<ins>&gt;</ins>, T, Compare, Allocator&gt;;
    
template&lt;class InputIterator, class Allocator&gt;
  map(InputIterator, InputIterator, Allocator)
    -&gt; map&lt;<i>iter-key-type</i>&lt;InputIterator&gt;, <i>iter-mapped-type</i>&lt;InputIterator&gt;,
           less&lt;<i>iter-key-type</i>&lt;InputIterator&gt;&gt;, Allocator&gt;;
           
template&lt;class Key, class T, class Allocator&gt;
  map(initializer_list&lt;pair&lt;Key, T&gt;&gt;, Allocator) 
    -&gt; map&lt;<ins>remove_const_t&lt;</ins>Key<ins>&gt;</ins>, T, less&lt;<ins>remove_const_t&lt;</ins>Key<ins>&gt;</ins>&gt;, Allocator&gt;;           

[&hellip;]
</pre></blockquote>
</li>
</ol>
</li>
</ol>






<hr>
<h3 id="3534"><a href="3534">3534</a>. <code>ranges::set_intersection</code> and <code>ranges::set_difference</code> algorithm requirements are too strict</h3>
<p><b>Section:</b> 26.8.7.4 <a href="https://timsong-cpp.github.io/cppwp/set.intersection">[set.intersection]</a>, 26.8.7.5 <a href="https://timsong-cpp.github.io/cppwp/set.difference">[set.difference]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alexander Bessonov <b>Opened:</b> 2021-03-16 <b>Last modified:</b> 2021-04-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>std::mergeable</code> concept requires elements of both source ranges to be copyable to the output iterator, while 
the standard specifically tells that both algorithms <code>ranges::set_intersection</code> and <code>ranges::set_difference</code> 
only use the first range as the source of elements to be copied into output. The following code snippet illustrates the problem:
</p>
<blockquote><pre>
#include &lt;vector&gt;
#include &lt;ranges&gt;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
 
int main()
{
  std::vector&lt;std::pair&lt;int, int&gt;&gt; v1;
  std::vector&lt;int&gt; v2;
  
  assert(std::ranges::is_sorted(v1));
  assert(std::ranges::is_sorted(v2));
  
  std::vector&lt;std::pair&lt;int, int&gt;&gt; v3;
  
  // Compilation error on the following line:
  std::ranges::set_intersection(v1, v2, std::back_inserter(v3),
    std::less{}, [](const auto&amp; p) { return p.first; });
}
</pre></blockquote>
<p>
The proposed solution is to introduce a new concept. It could be declared "exposition-only" and is worded 
<code><i>half-mergeable</i></code> below:
</p>
<blockquote><pre>
template&lt;class I1, class I2, class Out, class R = ranges::less,
	     class P1 = identity, class P2 = identity&gt;
  concept <i>half-mergeable</i> =
    input_iterator&lt;I1&gt; &amp;&amp;
    input_iterator&lt;I2&gt; &amp;&amp;
    weakly_incrementable&lt;Out&gt; &amp;&amp;
    indirectly_copyable&lt;I1, Out&gt; &amp;&amp;
    <i>// indirectly_copyable&lt;I2, Out&gt; &amp;&amp; &lt;&mdash; this line removed</i>
    indirect_strict_weak_order&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;;
</pre></blockquote>
<p>
After such template is introduced, <code>std::mergeable</code> may be defined based on it:
</p>
<blockquote><pre>
template&lt;class I1, class I2, class Out, class R = ranges::less,
	     class P1 = identity, class P2 = identity&gt;
  concept mergeable = <i>half-mergeable</i>&lt;I1, I2, Out, R, P1, P2&gt; &amp;&amp; 
    indirectly_copyable&lt;I2, Out&gt;;
</pre></blockquote>
<p>
See also the related discussion on 
<a href="https://www.reddit.com/r/cpp/comments/m1eqds/requirements_for_rangesset_intersection_algorithm/">reddit</a>.
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Priority set to 3. Send to LEWG.
</p>



<p id="res-3534"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4878">N4878</a>.
</p>

<ol>
<li><p>Modify 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header <code>&lt;iterator&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
  [&hellip;]
  
  <i>// 24.3.7.7 <a href="https://timsong-cpp.github.io/cppwp/alg.req.mergeable">[alg.req.mergeable]</a>, concept mergeable</i>
  <ins>template&lt;class I1, class I2, class Out, 
      class R = ranges::less, class P1 = identity, class P2 = identity&gt;
    concept <i>half-mergeable</i> = <i>see below</i>; <i>// exposition only</i></ins>

  template&lt;class I1, class I2, class Out, 
      class R = ranges::less, class P1 = identity, class P2 = identity&gt;
    concept mergeable = <i>see below</i>;

 [&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 24.3.7.7 <a href="https://timsong-cpp.github.io/cppwp/alg.req.mergeable">[alg.req.mergeable]</a> as indicated:</p>

<blockquote>
<p>
<b>23.3.7.7 Concept <code>mergeable</code> [alg.req.mergeable]</b>
<p/>
-1- The <code>mergeable</code> concept specifies the requirements of algorithms that merge sorted sequences 
into an output sequence by copying elements.
</p>
<blockquote>
<pre>
<ins>template&lt;class I1, class I2, class Out, class R = ranges::less,
         class P1 = identity, class P2 = identity&gt;
  concept <i>half-mergeable</i> = <i>// exposition only</i>
    input_iterator&lt;I1&gt; &amp;&amp;
    input_iterator&lt;I2&gt; &amp;&amp;
    weakly_incrementable&lt;Out&gt; &amp;&amp;
    indirectly_copyable&lt;I1, Out&gt; &amp;&amp;
    indirect_strict_weak_order&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;;
</ins>

template&lt;class I1, class I2, class Out, class R = ranges::less,
         class P1 = identity, class P2 = identity&gt;
  concept mergeable =
    <ins><i>half-mergeable</i>&lt;I1, I2, Out, R, P1, P2&gt; &amp;&amp;</ins>
    <del>input_iterator&lt;I1&gt; &amp;&amp;
    input_iterator&lt;I2&gt; &amp;&amp;
    weakly_incrementable&lt;Out&gt; &amp;&amp;
    indirectly_copyable&lt;I1, Out&gt; &amp;&amp;</del>
    indirectly_copyable&lt;I2, Out&gt; <del>&amp;&amp;
    indirect_strict_weak_order&lt;R, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;</del>;
</pre>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.8.7.4 <a href="https://timsong-cpp.github.io/cppwp/set.intersection">[set.intersection]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity&gt;
  requires <ins><i>half-mergeable</i></ins><del>mergeable</del>&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  constexpr ranges::set_intersection_result&lt;I1, I2, O&gt;
    ranges::set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template&lt;input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
  requires <ins><i>half-mergeable</i></ins><del>mergeable</del>&lt;iterator_t&lt;R1&gt;&gt;, 
    iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
  constexpr ranges::set_intersection_result&lt;borrowed_iterator_t&lt;R1&gt;, borrowed_iterator_t&lt;R2&gt;, O&gt;
    ranges::set_intersection(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                             Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Remarks:</i> Stable (16.4.6.8 <a href="https://timsong-cpp.github.io/cppwp/algorithm.stable">[algorithm.stable]</a>). If <code>[first1, last1)</code> contains <code><i>m</i></code> 
elements that are equivalent to each other and <code>[first2, last2)</code> contains <code><i>n</i></code> elements that are 
equivalent to them, the first <code>min(<i>m</i>, <i>n</i>)</code> elements are copied from the first range to the output 
range, in order.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.8.7.5 <a href="https://timsong-cpp.github.io/cppwp/set.difference">[set.difference]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,
         weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity&gt;
  requires <ins><i>half-mergeable</i></ins><del>mergeable</del>&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  constexpr ranges::set_difference_result&lt;I1, O&gt;
    ranges::set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template&lt;input_range R1, input_range R2, weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
  requires <ins><i>half-mergeable</i></ins><del>mergeable</del>&lt;iterator_t&lt;R1&gt;&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
  constexpr ranges::set_difference_result&lt;borrowed_iterator_t&lt;R1&gt;, O&gt;
    ranges::set_difference(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Remarks:</i> If <code>[first1, last1)</code> contains <code><i>m</i></code> elements that are equivalent to each other 
and <code>[first2, last2)</code> contains <code><i>n</i></code> elements that are equivalent to them, the last 
<code>max(<i>m</i> - <i>n</i>, 0)</code> elements from <code>[first1, last1)</code> is copied to the output range, in order.
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3537"><a href="3537">3537</a>. &sect;[iterator.range] Missing <code>noexcept</code> for <code>std::rbegin</code>/<code>rend</code> for arrays and 
<code>initializer_list</code></h3>
<p><b>Section:</b> 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-03-21 <b>Last modified:</b> 2025-07-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Overloads for <code>std::rbegin</code>/<code>rend</code> for built-in arrays and <code>std::initializer_list</code>'s has 
no preconditions and never throw exceptions, thus should be <code>noexcept</code>. LWG <a href="2280" title="begin/end for arrays should be constexpr and noexcept (Status: C++14)">2280</a> 
addressed a similar issue for <code>std::begin/end</code>.
<p/>
Suggestion: change these declarations in 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> (p10, 11, 12, 13) as indicated:
</p>
<blockquote>
<pre>
template&lt;class T, size_t N&gt; constexpr reverse_iterator&lt;T*&gt; rbegin(T (&amp;array)[N]) <ins>noexcept</ins>;

template&lt;class T, size_t N&gt; constexpr reverse_iterator&lt;T*&gt; rend(T (&amp;array)[N]) <ins>noexcept</ins>;

template&lt;class E&gt; constexpr reverse_iterator&lt;const E*&gt; rbegin(initializer_list&lt;E&gt; il) <ins>noexcept</ins>;

template&lt;class E&gt; constexpr reverse_iterator&lt;const E*&gt; rend(initializer_list&lt;E&gt; il) <ins>noexcept</ins>;
</pre>
</blockquote>
<p>
If this change is accepted, we may also specify <em>conditional</em> <code>noexcept</code> for <code>std::crbegin/crend</code> 
(in 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> p14, 15), by adding <code>noexcept(noexcept(std::rbegin/crend(c)))</code>, like in 
LWG <a href="2280" title="begin/end for arrays should be constexpr and noexcept (Status: C++14)">2280</a>.
<p/>
Conditional noexcept for other functions in 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> (p2, 3, 7, 8, 16, 18, 20 22) may also be 
added for consistency.
</p>

<p><i>[2021-03-21; Daniel comments]</i></p>

<p>
There is intentionally no P/R provided at this point, but I'm volunteering to provide it if we got feedback whether
adding <em>conditional</em> <code>noexcept</code> specifiers similar to those provided by LWG <a href="2280" title="begin/end for arrays should be constexpr and noexcept (Status: C++14)">2280</a> would
be preferred or not.
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Priority set to 3.
</p>
<p>
Jonathan: This would create a strange situation where <code>std::rbegin</code>
and <code>std::crbegin</code> on an <code>initializer_list</code> are noexcept but
<code>std::begin</code> and <code>std::cbegin</code> aren't guaranteed to be
(because an <code>initializer_list</code> uses the generic <code>std::begin</code>
and <code>std::cbegin</code> overloads, which have no conditional noexcept).
</p>
<p>
Casey: I don't think we should mark these rbegin/rend overloads noexcept
without making the pertinent <code>reverse_iterator</code> constructors
conditionally noexcept.
</p>

<p><i>[2025-07-01; <a href="https://wg21.link/P3623R0" title=" Add noexcept to [iterator.range] (LWG 3537)">P3623R0</a> would resolve this]</i></p>




<p id="res-3537"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3538"><a href="3538">3538</a>. &sect;[library.c] C library functions are not addressable</h3>
<p><b>Section:</b> 16.2 <a href="https://timsong-cpp.github.io/cppwp/library.c">[library.c]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-03-29 <b>Last modified:</b> 2021-04-20</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/p0551r3">P0551R3</a> has made almost all standard library functions non-addressable, 
including all functions from the C standard library. However, C17 (and the latest C23 working draft) explicitly 
allows taking address of a C standard library function in 7.1.4/1.
<p/>
Should we require something like "every function from the C standard library is addressable unless it is overloaded", 
in order to minimize the incompatibility with C? Or explicitly say something in C.8 <a href="https://timsong-cpp.github.io/cppwp/diff.library">[diff.library]</a> if 
such requirement is not wanted?
</p>

<p><i>[2021-04-20; Reflector poll]</i></p>

<p>
Priority set to 2.
</p>



<p id="res-3538"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3550"><a href="3550">3550</a>. Names reserved by C for standard library not reserved by C++</h3>
<p><b>Section:</b> 16.4.5.3 <a href="https://timsong-cpp.github.io/cppwp/reserved.names">[reserved.names]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2021-05-10 <b>Last modified:</b> 2021-05-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reserved.names">issues</a> in [reserved.names].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C standard has a section called "Future library directions". This is subclause 7.31 in C17, which is the 
version that the C++ working draft references. C reserves the names described in that subclause for its standard 
library, allowing C library vendors to introduce some names from future standards as conforming, "orthogonal" 
extensions. ISO C++ does not appear to reserve these names in a clear way. In particular, 16.4.5.3 <a href="https://timsong-cpp.github.io/cppwp/reserved.names">[reserved.names]</a> 
has wording about names and function signatures "from the C standard library declared with external linkage", 
but C's "Future library directions" describes names that "may be added to the declarations in [some] header[s]".
<p/>
Extra clarity regarding whether these names are actually intended to be reserved by C++ would be appreciated.
</p>

<p><i>[2021-05-20; Reflector poll]</i></p>

<p>
Priority set to 3.
</p>



<p id="res-3550"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3556"><a href="3556">3556</a>. Specification of when semantic constraints are imposed by use of concepts
is unclear</h3>
<p><b>Section:</b> 16.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/structure.requirements">[structure.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2021-05-23 <b>Last modified:</b> 2021-05-26</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.requirements">issues</a> in [structure.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/structure.requirements">[structure.requirements]</a> p9 says:
</p>
<blockquote>
<p>
A declaration may explicitly impose requirements through its associated
constraints (13.5.3 <a href="https://timsong-cpp.github.io/cppwp/temp.constr.decl">[temp.constr.decl]</a>). When the associated constraints
refer to a concept (13.7.9 <a href="https://timsong-cpp.github.io/cppwp/temp.concept">[temp.concept]</a>), the semantic constraints
specified for that concept are additionally imposed on the use of the declaration.
</p>
</blockquote>
<p>
There are at least two issues with this wording:
</p>
<ol>
<li><p>
First, "associated constraints" is a Core term that refers to the constraints
on a declaration <i>after normalization</i>, at which point direct uses of
concepts have been decomposed into the constituent atomic constraints and are
no longer visible.
</p></li>
<li><p>
Second, "refers to" is too vague. Does <code>!C&lt;T&gt;</code> "refer to"
<code>C</code> and impose its semantic constraints? Does <code>C1&lt;T&gt; || C2&lt;T&gt;</code>
"refer to" both <code>C1</code> and <code>C2</code> and therefore impose the semantic
constraints of both?
</p></li>
</ol>

<p><i>[2021-05-26; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3556"><b>Proposed resolution:</b></p>




<hr>
<h3 id="3577"><a href="3577">3577</a>. Merging an (unordered) associative container with itself</h3>
<p><b>Section:</b> 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a>, 23.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz <b>Opened:</b> 2021-08-04 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts.general">active issues</a> in [associative.reqmts.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts.general">issues</a> in [associative.reqmts.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For the expression <code>a.merge(a2)</code>, it is not explicitly stated whether <code>a2</code> can be the 
same object as <code>a</code>. libstdc++-v3 and libc++ seemingly assume this is not allowed, as the following code
produces an infinite loop with both standard library implementations:
</p>
<blockquote><pre>
#include &lt;set&gt;

int main()
{
  std::multiset&lt;int&gt; c={0, 0};
  c.merge(c);
}
</pre></blockquote>
<p>
A strict reading of postconditions seems to ban the case where <code>a</code> and <code>a2</code> are the same:
</p>
<ul>
<li><p>23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a>: "Iterators referring to the transferred elements [&hellip;] 
now behave as iterators into <code>a</code>, not into <code>a2</code>": if <code>a</code> and <code>a2</code> are the same, 
a transferred iterator can't be both an iterator to <code>a</code> and not an iterator to <code>a2</code>.</p></li>
<li><p>23.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a>: "Iterators referring to the transferred elements and all iterators 
referring to <code>a</code> will be invalidated, but iterators to elements remaining in <code>a2</code> will remain valid": 
if <code>a</code> and <code>a2</code> are the same, an iterator can't both be invalidated and remain valid.</p></li>
</ul>
<p>
Even if a provision is made that, when <code>a</code> and <code>a2</code> are the same, no elements are transferred by 
convention, 23.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> would still implicitly ban the case, as all iterators would be 
invalidated but the iterators to the remaining elements (again, all iterators) would remain valid, which is 
contradictory.
<p/>
For context, analogous operations for <code>std::list</code> take inconsistent approaches:
</p>
<ul>
<li><p><code>splice(const_iterator position, list&amp; x)</code> requires that source and destination be not the same.</p></li>
<li><p><code>splice(const_iterator position, list&amp; x, const_iterator i)</code> implicitly allows <code>addressof(x) == this</code>, 
as the case <code>position == i</code> is taken care of.</p></li>
<li><p><code>std::list::merge</code> explicitly allows the case <code>addressof(x) == this</code> (resulting in a no-op).</p></li>
</ul>

<p><i>[2021-08-20; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.

Tim Song commented:
"I think the current PR of LWG<a href="2414" title="Member function reentrancy should be implementation-defined (Status: Open)">2414</a> bans this code,
but we might want to have consistency with <code>list::merge</code> instead."
</p>



<p id="res-3577"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3582"><a href="3582">3582</a>. Unclear where <code>std::async</code> exceptions are handled</h3>
<p><b>Section:</b> 32.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-08-23 <b>Last modified:</b> 2021-09-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> (3.1) says:
</p>
<blockquote>
<p>
Any exception propagated from the execution of <code>invoke(<i>decay-copy</i>(std::forward&lt;F&gt;(f)), 
<i>decay-copy</i>(std::forward&lt;Args&gt;(args))...)</code> is stored as the exceptional result in the 
shared state.
</p>
</blockquote>
<p>
It's not clear whether this includes the evaluation of the <code><i>decay-copy</i></code> calls in the calling 
thread, or only the invocation of invoke with the results of those <code><i>decay-copy</i></code> calls.
<p/>
A literal reading suggests that any exceptions from any part of that expression should be stored in the 
shared state. All of libstdc++, libc++ and MSVC only store exceptions from the call to <code>invoke</code>, not the 
calls to <code><i>decay-copy</i></code>. Exceptions from the <code><i>decay-copy</i></code> calls are propagated 
to the caller of <code>std::async</code>. We should clarify that that's what the standard means.
</p>

<p><i>[2021-09-20; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2021-09-20;
Jonathan updates wording to change the <i>Throws:</i> and attempt to
align the <i>Effects:</i> with the deferred function case.
]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 32.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F, class... Args&gt;
  [[nodiscard]] future&lt;invoke_result_t&lt;decay_t&lt;F&gt;, decay_t&lt;Args&gt;...&gt;&gt;
    async(F&amp;&amp; f, Args&amp;&amp;... args);
template&lt;class F, class... Args&gt;
  [[nodiscard]] future&lt;invoke_result_t&lt;decay_t&lt;F&gt;, decay_t&lt;Args&gt;...&gt;&gt;
    async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-2- <i>Mandates</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: The first function behaves the same as a call to the second function with a <code>policy</code> argument of
<code>launch::async | launch::deferred</code> and the same arguments for <code>F</code> and <code>Args</code>. The second function
creates a shared state that is associated with the returned <code>future</code> object. The further behavior of the second function 
depends on the <code>policy</code> argument as follows (if more than one of these conditions applies, the implementation may 
choose any of the corresponding policies):
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If <code>launch::async</code> is set in <code>policy</code>, calls 
<code>invoke(<i>decay-copy</i>(std::forward&lt;F&gt;(f)), <i>decay-copy</i>(std::forward&lt;Args&gt;(args))...)</code> 
(22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>, 32.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.constr">[thread.thread.constr]</a>) as if in a new thread of execution
represented by a <code>thread</code> object with the calls to <code><i>decay-copy</i></code> being evaluated 
in the thread that called <code>async</code>. Any return value is stored as the result in the shared state. Any 
exception propagated from the <del>execution of <code>invoke(<i>decay-copy</i>(std::forward&lt;F&gt;(f)), 
<i>decay-copy</i>(std::forward&lt;Args&gt;(args))...)</code></del><ins>call to <code>invoke</code></ins> is stored as 
the exceptional result in the shared state. <ins>[<i>Note ?:</i> Exceptions from the <code><i>decay-copy</i></code> 
calls are propagated to the caller. &mdash; <i>end note</i>]</ins> The <code>thread</code> object is stored in 
the shared state and affects the behavior of any asynchronous return objects that reference that state.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>



<p id="res-3582"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 32.10.9 <a href="https://timsong-cpp.github.io/cppwp/futures.async">[futures.async]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F, class... Args&gt;
  [[nodiscard]] future&lt;invoke_result_t&lt;decay_t&lt;F&gt;, decay_t&lt;Args&gt;...&gt;&gt;
    async(F&amp;&amp; f, Args&amp;&amp;... args);
template&lt;class F, class... Args&gt;
  [[nodiscard]] future&lt;invoke_result_t&lt;decay_t&lt;F&gt;, decay_t&lt;Args&gt;...&gt;&gt;
    async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-2- <i>Mandates</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: The first function behaves the same as a call to the second function with a <code>policy</code> argument of
<code>launch::async | launch::deferred</code> and the same arguments for <code>F</code> and <code>Args</code>. The second function
creates a shared state that is associated with the returned <code>future</code> object. The further behavior of the second function 
depends on the <code>policy</code> argument as follows (if more than one of these conditions applies, the implementation may 
choose any of the corresponding policies):
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If <code>launch::async</code> is set in <code>policy</code>, calls 
<code>invoke(<i>decay-copy</i>(std::forward&lt;F&gt;(f)), <i>decay-copy</i>(std::forward&lt;Args&gt;(args))...)</code> 
(22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>, 32.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.constr">[thread.thread.constr]</a>) as if in a new thread of execution
represented by a <code>thread</code> object with the calls to <code><i>decay-copy</i></code> being evaluated 
in the thread that called <code>async</code>. Any return value is stored as the result in the shared state. Any 
exception propagated from the execution of <code>invoke(<del><i>decay-copy</i>(std::forward&lt;F&gt;(f)), 
<i>decay-copy</i>(std::forward&lt;Args&gt;(args)...)</del><ins>std::move(g), std::move(xyz)</ins>)</code> is stored as 
the exceptional result in the shared state<ins>,
where <code>g</code> is the result of
<code><i>decay-copy</i>(std::forward&lt;F&gt;(f))</code>
and <code>xyz</code> is the result of
<code><i>decay-copy</i>(std::forward&lt;Args&gt;(args))...</code>
</ins>.
<ins>[<i>Note ?:</i> Exceptions from the <code><i>decay-copy</i></code> 
calls are propagated to the caller. &mdash; <i>end note</i>]</ins> The <code>thread</code> object is stored in 
the shared state and affects the behavior of any asynchronous return objects that reference that state.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>[&hellip;]</p>
<p>-6- <i>Throws:</i>
<code>system_error</code> if <code>policy == launch::async</code>
and the implementation is unable to start a new thread;
<code><del>std::</del>bad_alloc</code> if memory for the internal data structures
  cannot be allocated<ins>;
or any exception thrown by the initialization of the objects returned by the
  <code><i>decay-copy</i></code> calls</ins>.</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3583"><a href="3583">3583</a>. Clarify if/when short circuiting applies to conditions in <i>Constraints:</i> elements</h3>
<p><b>Section:</b> 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-08-23 <b>Last modified:</b> 2021-09-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We do not specify whether or not short-circuiting is expected to happen for individual conditions stated in a <i>Constraints:</i> 
element. For example, 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> p12 says:
</p>
<blockquote><p>
<i>Constraints:</i> <code>sizeof...(Types)</code> equals <code>sizeof...(UTypes)</code> and <code>sizeof...(Types) &le; 1</code> and 
<code>is_constructible_v&lt;T<sub><i>i</i></sub> , U<sub><i>i</i></sub>&gt;</code> is <code>true</code> for all <code><i>i</i></code>.
</p></blockquote>
<p>
It's not even possible to test the <code>is_constructible</code> part unless the first part is true, so presumably it is 
expected that the <code>sizeof...</code> expressions are tested first, and so the <code>is_constructible</code> traits don't 
even need to be instantiated.
<p/>
In some cases it might be user observable whether short circuiting happens, as whether later conditions are tested might 
affect whether errors outside the immediate context are permitted or not.
<p/>
We should clarify what is intended, and refactor any <i>Constraints:</i> elements that are special cases where something 
different is required.
</p>

<p><i>[2021-09-20; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3583"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3584"><a href="3584">3584</a>. Clarify common comparison category conversions</h3>
<p><b>Section:</b> 17.12.3 <a href="https://timsong-cpp.github.io/cppwp/cmp.common">[cmp.common]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Brett <b>Opened:</b> 2021-08-23 <b>Last modified:</b> 2021-09-20</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.12.3 <a href="https://timsong-cpp.github.io/cppwp/cmp.common">[cmp.common]</a>/1 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
The type <code>common_comparison_category</code> provides an alias for the
strongest comparison category to which all of the template arguments
can be converted.
</p></blockquote>
<p>
A naive reader like me might interpret this as meaning that (1) you
attempt to convert the template arguments to comparison categories and
then (2) obtain the strongest among them.
<p/>
However, the intent is in fact to realize the common comparison type
notion from 11.10.3 <a href="https://timsong-cpp.github.io/cppwp/class.spaceship">[class.spaceship]</a>/4. To obtain a non-<code>void</code>
result, all the template arguments must be comparison categories, rather than
convertible to comparison categories.
<p/>
17.12.3 <a href="https://timsong-cpp.github.io/cppwp/cmp.common">[cmp.common]</a>/2 mildly contradicts the first paragraph:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
<i>Remarks:</i> The member <i>typedef-name</i> <code>type</code> denotes the common comparison
type (11.10.3 <a href="https://timsong-cpp.github.io/cppwp/class.spaceship">[class.spaceship]</a>) of <code>Ts...</code>, the expanded parameter pack, or
<code>void</code> if any element of <code>Ts</code> is not a comparison category type.
</p></blockquote>
<p>
It more precisely states the behaviour, cross-references
11.10.3 <a href="https://timsong-cpp.github.io/cppwp/class.spaceship">[class.spaceship]</a>, and uses the correct core terminology for the
metafunction that the template represents.
<p/>
Suggested resolution;
<p/>
Delete 17.12.3 <a href="https://timsong-cpp.github.io/cppwp/cmp.common">[cmp.common]</a>/1, because it does not provide any information not
already more precisely included in 17.12.3 <a href="https://timsong-cpp.github.io/cppwp/cmp.common">[cmp.common]</a>/2.
</p>

<p><i>[2021-09-20; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2021-09-20; Reflector poll]</i></p>

<p>
Jens suggests alternative wording.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 17.12.3 <a href="https://timsong-cpp.github.io/cppwp/cmp.common">[cmp.common]</a> as indicated:</p>

<blockquote>
<p>
<del>-1- The type <code>common_comparison_category</code> provides an alias for the strongest comparison category to which
all of the template arguments can be converted.
[<i>Note 1</i>: A comparison category type is stronger than another if they are distinct types and an instance of the former
can be converted to an instance of the latter. &mdash; <i>end note</i>]</del>
</p>
<pre>
template&lt;class... Ts&gt;
struct common_comparison_category {
  using type = <i>see below</i>;
};
</pre>
<p>
-2- <i>Remarks:</i> The member <i>typedef-name</i> <code>type</code> denotes the common comparison type (11.10.3 <a href="https://timsong-cpp.github.io/cppwp/class.spaceship">[class.spaceship]</a>) 
of <code>Ts...</code>, the expanded parameter pack, or <code>void</code> if any element of <code>Ts</code> is not a comparison category type.
</p>
</blockquote>
</li>
</ol>

</blockquote>



<p id="res-3584"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 17.12.3 <a href="https://timsong-cpp.github.io/cppwp/cmp.common">[cmp.common]</a> as indicated:</p>

<blockquote>
<p>
-1- The type <code>common_comparison_category</code> provides an alias for the strongest comparison category <del>to which
all of the template arguments can be converted</del>
<ins>among all the template arguments</ins>.
[<i>Note 1</i>: A comparison category type is stronger than another if they are distinct types and an instance of the former
can be converted to an instance of the latter. &mdash; <i>end note</i>]
</p>
<pre>
template&lt;class... Ts&gt;
struct common_comparison_category {
  using type = <i>see below</i>;
};
</pre>
<p>
-2- <i>Remarks:</i> The member <i>typedef-name</i> <code>type</code> denotes the common comparison type (11.10.3 <a href="https://timsong-cpp.github.io/cppwp/class.spaceship">[class.spaceship]</a>)
of <code>Ts...</code>, the expanded parameter pack, or <code>void</code> if any element of <code>Ts</code> is not a comparison category type.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3586"><a href="3586">3586</a>. Formatting character alignment inconsistencies</h3>
<p><b>Section:</b> 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mark de Wever <b>Opened:</b> 2021-09-05 <b>Last modified:</b> 2021-12-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.string.std">active issues</a> in [format.string.std].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.string.std">issues</a> in [format.string.std].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The alignment options specified in 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a>, Table [tab:format.align] 
causes an inconsistency when formatting characters. The output differs depending on whether 
an integer is formatted using a character presentation type or when using a character directly:
</p>
<blockquote><pre>
format("{:3}", '*'); -&gt; "*  " <i>// aligned at the start of the available space</i>
format("{:3c}", 42); -&gt; "  *" <i>// aligned at the end of the available space</i>
</pre></blockquote>
<p>
I expect both calls to return the same value: <code>"*  "</code>. The current wording
mixes the type and the presentation type. To me, it seems clearer to adjust to wording 
to only use the presentation type. Another approach would be adjusting the wording to 
add an exception when an integer type uses the character presentation.
</p>

<p><i>[2021-09-20; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
Victor said "It mostly looks correct but I think the wording needs a bit more
work because we don't mention arithmetic presentation types anywhere."
</p>


<p><i>[2021-11-29; Daniel comments]</i></p>

<p>
This issue touches the same wording area as LWG <a href="3644" title="std::format does not define &quot;integer presentation type&quot; (Status: New)">3644</a> does.
</p>


<p id="res-3586"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4892" title=" Working Draft, Standard for Programming Language C++">N4892</a>.
</p>

<ol>
<li><p>Modify 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a>, Table [tab:format.align], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 59 &mdash; Meaning of <i>align</i> options  [tab:format.align]</caption>
<tr style="text-align:center">
<th>Option</th>
<th>Meaning</th>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Forces the field to be aligned to the start of the available space. This is the default <ins>when 
the presentation type is a non-arithmetic type</ins><del>for non-arithmetic types, <code>charT</code>, and 
<code>bool</code>, unless an integer presentation type is specified</del>.</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Forces the field to be aligned to the end of the available space. This is the default <ins>when 
the presentation type is an arithmetic type</ins><del>for arithmetic types other than <code>charT</code> 
and <code>bool</code> or when an integer presentation type is specified</del>.</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3587"><a href="3587">3587</a>. <code>std::three_way_comparable_with&lt;T, U, void&gt;</code> can be satisfied but can't be modeled</h3>
<p><b>Section:</b> 17.12.4 <a href="https://timsong-cpp.github.io/cppwp/cmp.concept">[cmp.concept]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-09-06 <b>Last modified:</b> 2021-10-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cmp.concept">issues</a> in [cmp.concept].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Due to the current specification of <code>std::common_comparison_category</code>,
<code><i>compare-as</i>&lt;void, void&gt;</code> is satisfied. And thus given two types <code>T</code>
and <code>U</code> with regular <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
and <code>&gt;=</code> but irregular <code>&lt;=&gt;</code> that has return type <code>void</code>,
<code>std::three_way_comparable_with&lt;T, U, void&gt;</code> is satisfied.
<p/>
However, in this situation <code>std::three_way_comparable_with&lt;T, U, void&gt;</code>
can't be modeled, because <code>Cat(t &lt;=&gt; u) == Cat(C(t) &lt;=&gt; C(u))</code>
is ill-formed if <code>Cat</code> is <code>void</code> (see <a href="https://gcc.godbolt.org/z/5c4839qz1">this godbolt link</a>).
<p/>
I don't think this issue has any impact on meaningful codes, but it seems to be a hole in the
current specification.
<p/>
It seems that <code><i>compares-as</i>&lt;void, void&gt;</code> should be changed to <code>false</code>.
<code><i>compares-as</i>&lt;NonComparisonCategoryType, void&gt;</code> might need refinement.
<p/>
(Note: The same problem does not exists for <code>std::three_way_comparable</code>, because
<code>std::three_way_comparable&lt;T, void&gt;</code> can be modeled if the <code>&lt;=&gt;</code> on <code>T</code>
has "regular" definition or its return type is not a comparison category type, but the return value
has "regular" semantics)
</p>

<p><i>[2021-09-20; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3587"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3599"><a href="3599">3599</a>. The <code>const</code> overload of <code>lazy_split_view::begin</code> should be constrained by <code>const Pattern</code></h3>
<p><b>Section:</b> 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2021-09-23 <b>Last modified:</b> 2021-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.lazy.split.view">active issues</a> in [range.lazy.split.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.lazy.split.view">issues</a> in [range.lazy.split.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
 Consider the following code snippet:
</p>
<blockquote>
<pre>
#include &lt;ranges&gt;

int main() {
  auto p = std::views::iota(0)
         | std::views::take(1)
         | std::views::reverse;
  auto r = std::views::single(42)
         | std::views::lazy_split(p);
  auto f = r.front();
}
</pre>
</blockquote>
<p>
<code>r.front()</code> is ill-formed even if <code>r</code> is a <code>forward_range</code>.
</p>
<p>
This is because the <code>const</code> overload of <code>lazy_split_view::begin</code> is not constrained by the
<code>const Pattern</code>, which makes it still well-formed in such cases. When the <code>const</code> overload 
of <code>view_interface&lt;lazy_split_view&lt;V, Pattern&gt;&gt;::front</code> is instantiated, the 
<code>subrange{parent_-&gt;pattern_}</code> inside <code>lazy_split_view::<i>outer-iterator</i>&lt;true&gt;::operator++()</code> 
will cause a hard error since <code>const Pattern</code> is not a <code>range</code>.
</p>

<p><i>[2021-09-24; Daniel comments]</i></p>

<p>
This issue is related to LWG <a href="3592" title="lazy_split_view needs to check the simpleness of Pattern (Status: C++23)">3592</a>.
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3599"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a>, class template <code>lazy_split_view</code> synopsis, as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {

  [&hellip;]

  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
            (forward_range&lt;V&gt; || <i>tiny-range</i>&lt;Pattern&gt;)
  class lazy_split_view : public view_interface&lt;lazy_split_view&lt;V, Pattern&gt;&gt; {
  private:
    [&hellip;]
  public:
    [&hellip;]

    constexpr auto begin() {
      [&hellip;]
    }
    
    constexpr auto begin() const requires forward_range&lt;V&gt; &amp;&amp; forward_range&lt;const V&gt; <ins>&amp;&amp;
                                          forward_range&lt;const Pattern&gt;</ins>{
      return <i>outer-iterator</i>&lt;true&gt;{*this, ranges::begin(<i>base_</i>)};
    }
    
    constexpr auto end() requires forward_range&lt;V&gt; &amp;&amp; common_range&lt;V&gt; {
      [&hellip;]
    }

    constexpr auto end() const {
      if constexpr (forward_range&lt;V&gt; &amp;&amp; forward_range&lt;const V&gt; &amp;&amp; common_range&lt;const V&gt; <ins>&amp;&amp;
                    forward_range&lt;const Pattern&gt;</ins>)
        return <i>outer-iterator</i>&lt;true&gt;{*this, ranges::end(<i>base_</i>)};
      else
        return default_sentinel;
    }
  };
  
  [&hellip;]
  
}
</pre>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3602"><a href="3602">3602</a>. <code>reverse_iterator</code>'s converting assignment is overconstrained</h3>
<p><b>Section:</b> 24.5.1.4 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.cons">[reverse.iter.cons]</a>, 24.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/move.iter.cons">[move.iter.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2021-09-26 <b>Last modified:</b> 2021-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.cons">issues</a> in [reverse.iter.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to remove the incorrect bi-convertibility of <code>reverse_iterator&lt;int*&gt;</code> and
<code>reverse_iterator&lt;const int*&gt;</code>, LWG <a href="3435" title="three_way_comparable_with&lt;reverse_iterator&lt;int*&gt;, reverse_iterator&lt;const int*&gt;&gt; (Status: C++23)">3435</a> adds two constraints to 
<code>reverse_iterator</code>'s converting assignment, namely
<code>convertible_to&lt;const U&amp;, Iterator&gt;</code> and 
<code>assignable_from&lt;Iterator&amp;, const U&amp;&gt;</code>, but since this function only assigns 
<code>u.current</code> to <code>current</code>, there is no need to require 
<code>convertible_to&lt;const U&amp;, Iterator&gt;</code> &mdash; the latter is sufficient.
<p/>
We should remove this constraint and be consistent with the <code>move_sentinel</code> and 
<code>counted_iterator</code>' converting assignment.
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p><i>[Tim Song commented:]</i></p>

<p>
This was
<a href="https://lists.isocpp.org/lib/2020/05/16242.php">intentional</a>,
but I think we missed the fact that <code>counted_iterator</code> did something
else already. These should probably be made consistent one way or another.
</p>
<p><i>[Tomasz Kamiski commented]</i></p>

<p>
The <code>move_iterator</code>/<code>reverse_iterator</code> were present before C++20,
and this change restores their compatibility with C++17 code,
where only assignment was required.
They are materially different from adapters introduced with C++20,
and I believe we should put more weight into backward compatibility
than consistency with newer iterator wrappers.
</p>



<p id="res-3602"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 24.5.1.4 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.cons">[reverse.iter.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U&gt;
  constexpr reverse_iterator&amp;
    operator=(const reverse_iterator&lt;U&gt;&amp; u);
</pre>
<blockquote>
<p>
-5- <i>Constraints:</i> <code>is_same_v&lt;U, Iterator&gt;</code> is <code>false</code><del>, <code>const U&amp;</code> 
models <code>convertible_to&lt;Iterator&gt;</code>,</del> and <code>assignable_from&lt;Iterator&amp;, const U&amp;&gt;</code> 
is modeled.
<p/>
-6- <i>Effects:</i> Assigns <code>u.current</code> to <code>current</code>.
<p/>
-7- <i>Returns:</i> <code>*this</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 24.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/move.iter.cons">[move.iter.cons]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> As drive-by fix a missing "<i>Returns:</i> <code>*this</code>" has been added as well.]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class U&gt; constexpr move_iterator&amp; operator=(const move_iterator&lt;U&gt;&amp; u);
</pre>
<blockquote>
<p>
-5- <i>Constraints:</i> <code>is_same_v&lt;U, Iterator&gt;</code> is <code>false</code><del>, <code>const U&amp;</code> 
models <code>convertible_to&lt;Iterator&gt;</code>,</del> and <code>assignable_from&lt;Iterator&amp;, const U&amp;&gt;</code> 
is modeled.
<p/>
-6- <i>Effects:</i> Assigns <code>u.current</code> to <code>current</code>.
<p/>
<ins>-?- <i>Returns:</i> <code>*this</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3603"><a href="3603">3603</a>. Matching of null characters by regular expressions is underspecified</h3>
<p><b>Section:</b> 28.6.7.2 <a href="https://timsong-cpp.github.io/cppwp/re.regex.construct">[re.regex.construct]</a>, 28.6.10 <a href="https://timsong-cpp.github.io/cppwp/re.alg">[re.alg]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-09-27 <b>Last modified:</b> 2021-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.regex.construct">active issues</a> in [re.regex.construct].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex.construct">issues</a> in [re.regex.construct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
ECMAScript says that <code>\0</code> is an ordinary character and can be matched. POSIX says the opposite:
<p/>
"The interfaces specified in POSIX.1-2017 do not permit the inclusion of a NUL character in an RE or 
in the string to be matched. If during the operation of a standard utility a NUL is included in the 
text designated to be matched, that NUL may designate the end of the text string for the purposes of matching."
<p/>
So does that mean <code>std::regex{"", 1, regex::basic}</code> should throw an exception?
<p/>
And <code>std::regex_match(string{"a\0b", 3}, regex{"a.b", regex::basic})</code> should fail?
<p/>
The POSIX rule is because those interfaces are specified with NTBS arguments, so there's no way to 
distinguish <code>"a\0b"</code> and <code>"a"</code>. The C++ interfaces could allow it, but we never specify 
any divergence from POSIX, so presumably the rule still applies. Is that what was intended and is it 
what we want?
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3603"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3604"><a href="3604">3604</a>. What is the effect of an invalid value of type <code>syntax_option_type</code>?</h3>
<p><b>Section:</b> 28.6.7.2 <a href="https://timsong-cpp.github.io/cppwp/re.regex.construct">[re.regex.construct]</a>, 28.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-09-27 <b>Last modified:</b> 2021-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.regex.construct">active issues</a> in [re.regex.construct].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex.construct">issues</a> in [re.regex.construct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/re.synopt">[re.synopt]</a> says:
</p>
<blockquote><p>
A valid value of type <code>syntax_option_type</code> shall have at most one of the grammar elements <code>ECMAScript</code>, 
<code>basic</code>, <code>extended</code>, <code>awk</code>, <code>grep</code>, <code>egrep</code>, set.
</p></blockquote>
<p>
But then we never say what happens if an invalid value is used.
<p/>
What does <code>std::regex(".", std::regex::grep|std::regex::awk)</code> do? Is it undefined? Does it throw?
<p/>
It seems reasonable for <code>basic_regex</code> constructors to throw if <code>f</code> is not a valid value, i.e. 
for each non-default constructor:
</p>
<blockquote><p>
<i>Throws:</i> <code>regex_error</code> <ins>if <code>f</code> is not a valid value, or</ins> if [&hellip;] is not a valid 
regular expression according to the grammar specified by <code>f</code>.
</p></blockquote>
<p>
However, there is no <code>regex_constants::error_code</code> value suitable for this error condition.
<p/>
Also, the constructors say "<i>Postconditions:</i> <code>flags()</code> returns <code>f</code>." This prevents an 
implementation from storing <code>f|ECMAScript</code> in <code>flags()</code> if no grammar element is present in <code>f</code>. 
This seems like an unnecessary restriction, and forces implementations to do extra work to check if the 
<code>ECMAScript</code> grammar is in use. Arguably, it would even be better to require implementations to set 
<code>ECMAScript</code> in <code>flags()</code> if no grammar element was set in the flags passed to the constructor.
This problem was introduced by LWG <a href="2330" title="regex(&quot;meow&quot;, regex::icase) is technically forbidden but should be permitted (Status: C++14)">2330</a>.
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3604"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3605"><a href="3605">3605</a>. <code>regex_constants::match_prev_avail</code> is underspecified</h3>
<p><b>Section:</b> 28.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/re.matchflag">[re.matchflag]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-09-27 <b>Last modified:</b> 2021-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.matchflag">issues</a> in [re.matchflag].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard doesn't say what it means if <code>match_prev_avail</code> is set. Table [tab:re.matchflag] says:
</p>
<blockquote><p>
<code>--first</code> is a valid iterator position. When this flag is set the flags 
<code>match_not_bol</code> and <code>match_not_bow</code> shall be ignored by the regular expression
algorithms (28.6.10 <a href="https://timsong-cpp.github.io/cppwp/re.alg">[re.alg]</a>) and iterators (28.6.11 <a href="https://timsong-cpp.github.io/cppwp/re.iter">[re.iter]</a>).
</p></blockquote>
<p>
What difference does it make whether <code>--first</code> is a valid iterator position or not? 
<p/>
What behaviour is changed when it's a valid iterator position? The standard doesn't say anything else about that. 
<p/>
When do the regex algorithms care about <code>--first</code>?
</p>

<p>
Examples like <code>regex_match("xa"+1, regex("^a"), match_prev_avail)</code>
and <code>regex_match("xa"+1, regex("\\ba"), match_prev_avail)</code>
are presumably supposed to inspect the character at <code>--first</code>
to determine if there is a match.
The standard doesn't specify that <code>*--first</code> is ever inspected,
only that it's a valid character
(which is a useless guarantee if nothing looks at it).
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3605"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3606"><a href="3606">3606</a>. Missing <code>regex_traits::locale_type</code> requirements</h3>
<p><b>Section:</b> 28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-09-28 <b>Last modified:</b> 2021-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.req">active issues</a> in [re.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.req">issues</a> in [re.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Why is <code>locale_type</code> part of the regular expression traits requirements in 28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a>? 
When would <code>locale_type</code> not be <code>std::locale</code>? What are the requirements on the type? 
Does it have to provide exactly the same interface as <code>std::locale</code>, or just some unspecified 
interface that a custom regex traits type needs from it? Why is none of this specified?
<p/>
Currently the only requirement on <code>locale_type</code> in the standard is that it's copy constructible. 
Clearly it needs to be default constructible as well, otherwise you can't construct a <code>basic_regex</code>, 
since none of them allows passing in a locale, so they have to default construct it (see also LWG <a href="2431" title="Missing regular expression traits requirements (Status: New)">2431</a>).
<p/>
The other requirements on <code>locale_type</code> are a mystery. Why do we allow custom locale types, 
but not say anything about what they should do? Can we just require <code>locale_type</code> to be <code>std::locale</code>? 
Is anybody really going to use <code>boost::locale</code> with <code>std::basic_regex</code>, when they 
could just use <code>boost::basic_regex</code> instead?
<p/>
Why does the regular expression traits requirements table say that <code>imbue</code> and <code>getloc</code> 
talk about the locale used, "if any". How would there not be one already?
<p/>
Why is imbuing a locale into a <code>basic_regex</code> a separate operation from compiling the regular expression 
pattern? Is the following supposed to change the compiled regex?
</p>
<blockquote><pre>
std::regex r("[a-z]");
r.imbue(std::locale("en_GB.UTF-8"));
</pre></blockquote>
<p>
Hasn't the regex constructor already made use of the locale to compile the <code>"[a-z]"</code> pattern, 
and so changing the locale is too late? So do we need to do the following to compile the regex with 
a specific locale?
</p>
<blockquote><pre>
std::regex r;
r.imbue(std::locale("en_GB.UTF-8"));
r.assign("[a-z]");
</pre></blockquote>
<p>
Why require two-stage initialization like this, is it just so that we appear consistent with the 
<code>imbue</code>/<code>getloc</code> API of <code>std::ios_base</code>? It works for <code>ios_base</code>, 
because the new locale is effective after imbuing it, but for <code>basic_regex</code> the pattern 
has already been compiled using the old locale and imbuing a new one can't change that. Is the 
<code>basic_regex</code> supposed to store the pattern and recompile it after <code>imbue</code>, or is 
this just an inappropriate API for <code>basic_regex</code>?
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3606"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3608"><a href="3608">3608</a>. <code>convertible_to</code> and temporary-bound references</h3>
<p><b>Section:</b> 18.4.4 <a href="https://timsong-cpp.github.io/cppwp/concept.convertible">[concept.convertible]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2021-09-28 <b>Last modified:</b> 2021-10-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concept.convertible">active issues</a> in [concept.convertible].</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.convertible">issues</a> in [concept.convertible].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The semantic requirements of <code>convertible_to</code> express implicit
conversion by means of a function:
</p>
<blockquote><pre>
To test(FromR (&amp;f)()) {
  return f();
}
</pre></blockquote>
<p>
and it requires that <code>static_cast&lt;To&gt;(f())</code> be equal to <code>test(f)</code> for some
equality-preserving function <code>f</code>. However, when <code>To</code> is a reference type
but <code>FromR</code> is such that the conversion binds the reference to a temporary, the 
<code>static_cast</code> is valid but <code>test(f)</code> would produce a dangling reference.
<p/>
We should rephrase this requirement to just perform the implicit conversion in words. Using a 
function handles the convert-<code>void</code>-to-<code>void</code> case, but the semantic requirements 
wording already excluded that case anyway.
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>


<p id="res-3608"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3609"><a href="3609">3609</a>. <code>std::ranges::iota_view&lt;int, long&gt;</code> has non-subtractable <code><i>iterator</i></code> and 
<code><i>sentinel</i></code> types</h3>
<p><b>Section:</b> 25.6.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.iota.sentinel">[range.iota.sentinel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-09-25 <b>Last modified:</b> 2021-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently <code>std::ranges::iota_view&lt;int, long&gt;</code> uses its special <code><i>sentinel</i></code> type, as its 
<code>W</code> and <code>Bound</code> are different types and <code>Bound</code> is not <code>std::unreachable_sentinel_t</code>. 
However, as <code>W</code> (<code>int</code>) is not an iterator type, the iterator and sentinel types don't satisfy 
<code>std::sized_sentinel_for</code>, and thus not subtractable.
<p/>
IMO we should handle <code>operator-</code> overloads for <code>iota_view::<i>iterator</i></code> and <code>iota_view::<i>sentinel</i></code> 
like <code>iota_view::size</code> and <code>operator-</code> for <code>iota_view::<i>iterator</i></code>.
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p><i>[Tim Song commented:]</i></p>

<p>
We might be able to simplify the <code>(y_value > x.value_)</code> conditional
since we know that we are working with an iterator and its sentinel.
</p>



<p id="res-3609"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 25.6.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.iota.sentinel">[range.iota.sentinel]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;weakly_incrementable W, semiregular Bound&gt;
    requires <i>weakly-equality-comparable-with</i>&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  struct iota_view&lt;W, Bound&gt;::<i>sentinel</i> {
  private:
    Bound <i>bound_</i> = Bound(); <i>// exposition only</i>
  public:
    <i>sentinel</i>() = default;
    constexpr explicit <i>sentinel</i>(Bound bound);
    
    friend constexpr bool operator==(const <i>iterator</i>&amp; x, const <i>sentinel</i>&amp; y);
    
    friend constexpr <del>iter_difference_t&lt;W&gt;</del><ins><i>IOTA-DIFF-T</i>(W)</ins> operator-(const <i>iterator</i>&amp; x, const <i>sentinel</i>&amp; y)
      requires <ins>(<i>is-integer-like</i>&lt;W&gt; &amp;&amp; <i>is-integer-like</i>&lt;Bound&gt;) ||</ins> sized_sentinel_for&lt;Bound, W&gt;;

    friend constexpr <del>iter_difference_t&lt;W&gt;</del><ins><i>IOTA-DIFF-T</i>(W)</ins> operator-(const <i>sentinel</i>&amp; x, const <i>iterator</i>&amp; y)
      requires <ins>(<i>is-integer-like</i>&lt;W&gt; &amp;&amp; <i>is-integer-like</i>&lt;Bound&gt;) ||</ins> sized_sentinel_for&lt;Bound, W&gt;;
  };
}
</pre>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
friend constexpr <del>iter_difference_t&lt;W&gt;</del><ins><i>IOTA-DIFF-T</i>(W)</ins> operator-(const <i>iterator</i>&amp; x, const <i>sentinel</i>&amp; y)
  requires <ins>(<i>is-integer-like</i>&lt;W&gt; &amp;&amp; <i>is-integer-like</i>&lt;Bound&gt;) ||</ins> sized_sentinel_for&lt;Bound, W&gt;;
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to: <del><code>return x.<i>value_</i> - y.<i>bound_</i>;</code></del>
</p>
<blockquote><pre>
<ins>using D = <i>IOTA-DIFF-T</i>(W);
if constexpr (<i>is-integer-like</i>&lt;W&gt;) {
  auto y_value = W(y.<i>bound_</i>);
  if constexpr (<i>is-signed-integer-like</i>&lt;W&gt;) {
    return D(D(x.<i>value_</i>) - D(y_value));
  } else {
    return (y_value > x.<i>value_</i>)
      ? D(-D(y_value - x.<i>value_</i>))
      : D(x.<i>value_</i> - y_value);
  }
} else {
  return x.<i>value_</i> - y.<i>bound_</i>;
}</ins>
</pre></blockquote>
</blockquote>
<pre>
friend constexpr <del>iter_difference_t&lt;W&gt;</del><ins><i>IOTA-DIFF-T</i>(W)</ins> operator-(const <i>sentinel</i>&amp; x, const <i>iterator</i>&amp; y)
  requires <ins>(<i>is-integer-like</i>&lt;W&gt; &amp;&amp; <i>is-integer-like</i>&lt;Bound&gt;) ||</ins> sized_sentinel_for&lt;Bound, W&gt;;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to: <code>return -(y - x);</code>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3613"><a href="3613">3613</a>. Specify that <code>nullopt_t</code> is copyable</h3>
<p><b>Section:</b> 22.5.5 <a href="https://timsong-cpp.github.io/cppwp/optional.nullopt">[optional.nullopt]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Frank Birbacher <b>Opened:</b> 2021-10-01 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.nullopt">issues</a> in [optional.nullopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Standard defines a number of types that are used to create overload disambiguators for constructors, 
like <code>nullopt_t</code> and <code>allocator_tag_t</code>. Values of such types are passed by value to such 
constructors to give it particular meaning. For pass-by-value these types need to be copy-constructible 
and for consistency should also be copy-assignable. Of those types the specification of <code>nullopt_t</code> 
doesn't clearly state that the type is copyable, 22.5.5 <a href="https://timsong-cpp.github.io/cppwp/optional.nullopt">[optional.nullopt]</a>.
<p/>
The reason that <code>nullopt_t</code> is defined differently from other such types is to avoid ambiguity 
in expressions that assign an empty brace initializer to an <code>optional</code>.

<span style="text-decoration: line-through">
The meaning of such 
assignment should be to engage the <code>optional</code> instead of taking the braces to create a temporary 
<code>nullopt_t</code> for assignment and thus reset the <code>optional</code>.
</span>
The RHS of such assignment should be a temporary empty <code>optional</code>
instead of a temporary <code>nullopt_t</code>.
<p/>
Types that aren't affected: <code>nullptr_t</code> (fundamental type), <code>allocator_tag_t</code>, 
<code>piecewise_construct_t</code>, <code>in_place_t</code>, <code>in_place_type_t</code>, <code>in_place_index_t</code> 
(all basically defined as a <code>class <i>T</i> { explicit <i>T</i>() = default; }</code> which works fine for pass-by-value)
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p><i>[Daniel commented:]</i></p>

<p>
I would prefer to see the wording use
<code>is_trivially_copy_constructible_v</code>
and <code>trivially_copy_assignable_v</code>,
which is consistent with similar usage of trivial-requirements in
<code>std::optional</code>.
</p>
<p><i>[Tim commented:]</i></p>

<p>
We need to say that it models copyable and is trivially copyable
(not sure if we need the latter but might as well - does anyone do it differently?).
"has a copy constructor" isn't enough - <code>T(T&amp;)</code> is a copy constructor.
</p>



<p id="res-3613"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 22.5.5 <a href="https://timsong-cpp.github.io/cppwp/optional.nullopt">[optional.nullopt]</a> as indicated:</p>

<blockquote>
<pre>
struct nullopt_t{<i>see below</i>};
inline constexpr nullopt_t nullopt(<i>unspecified</i>);
</pre>
<blockquote>
<p>
-1- The struct <code>nullopt_t</code> is an empty class type used as a unique type to indicate 
the state of not containing a value for <code>optional</code> objects. In particular, 
<code>optional&lt;T&gt;</code> has a constructor with <code>nullopt_t</code> as a single
argument; this indicates that an optional object not containing a value shall be constructed.
<p/>
-2- Type <code>nullopt_t</code> shall not have a default constructor or an initializer-list 
constructor, <del>and</del> shall not be an aggregate<ins>, and shall have a copy constructor 
and a copy assignment operator, both shall be public and trivial</ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3614"><a href="3614">3614</a>. <code>iota_view::size</code> and the most negative signed integer values</h3>
<p><b>Section:</b> 25.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-10-01 <b>Last modified:</b> 2021-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.iota.view">issues</a> in [range.iota.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 25.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a>/15, when both <code>W</code> and <code>Bound</code> are 
integer-like, the expression in the return statement uses <code>-<i>value_</i></code> and <code>-<i>bound_</i></code>. 
These operations result in undefined behavior when <code>-</code> is applied to the most negative integer 
value of a promoted type.
<p/>
I believe that we can simply convert <code><i>value_</i></code> and <code><i>bound_</i></code> to the return type 
(<code><i>make-unsigned-like-t</i>&lt;common_type_t&lt;W, Bound&gt;&gt;</code>) and then perform the subtraction. 
Such method should give the same results with UB eliminated.
<p/>
Additionally, if we decide that <code>iota_view&lt;uint8_t, uint8_t&gt;(uint8_t(1)).size()</code> is well-defined 
(LWG <a href="3597" title="Unsigned integer types don't model advanceable (Status: C++23)">3597</a>), it should give the correct result. We can truncate the result to fit the type <code>W</code>.
</p>

<p><i>[2021-10-14; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3614"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> Just fixes the most negative values
</p>

<ol>
<li><p>Modify 25.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto size() const requires <i>see below</i>;
</pre>
<blockquote>
<p>
-15- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
if constexpr (<i>is-integer-like</i>&lt;W&gt; &amp;&amp; <i>is-integer-like</i>&lt;Bound&gt;) <ins>{</ins>
  <del>return (<i>value_</i> &lt; 0)
    ? ((<i>bound_</i> &lt; 0)
      ? <i>to-unsigned-like</i>(-<i>value_</i>) - <i>to-unsigned-like</i>(-<i>bound_</i>)
      : <i>to-unsigned-like</i>(<i>bound_</i>) + <i>to-unsigned-like</i>(-<i>value_</i>))
    : <i>to-unsigned-like</i>(<i>bound_</i>) - <i>to-unsigned-like</i>(<i>value_</i>);</del>
  <ins>using UC = <i>make-unsigned-like-t</i>&lt;common_type_t&lt;W, Bound&gt;&gt;;
  return UC(<i>bound_</i>) - UC(<i>value_</i>);</ins>
<ins>}</ins> else
  return <i>to-unsigned-like</i>(<i>bound_</i> - <i>value_</i>);
</pre></blockquote>
<p>
-16- <i>Remarks:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>

<p>
<b>Option B:</b> Also fixes pathological cases involving unsigned-integer-like types
</p>

<ol>
<li><p>Modify 25.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto size() const requires <i>see below</i>;
</pre>
<blockquote>
<p>
-15- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
if constexpr (<i>is-integer-like</i>&lt;W&gt; &amp;&amp; <i>is-integer-like</i>&lt;Bound&gt;) <ins>{</ins>
  <del>return (<i>value_</i> &lt; 0)
    ? ((<i>bound_</i> &lt; 0)
      ? <i>to-unsigned-like</i>(-<i>value_</i>) - <i>to-unsigned-like</i>(-<i>bound_</i>)
      : <i>to-unsigned-like</i>(<i>bound_</i>) + <i>to-unsigned-like</i>(-<i>value_</i>))
    : <i>to-unsigned-like</i>(<i>bound_</i>) - <i>to-unsigned-like</i>(<i>value_</i>);</del>
  <ins>using UC = <i>make-unsigned-like-t</i>&lt;common_type_t&lt;W, Bound&gt;&gt;;
  if constexpr (<i>is-signed-integer-like</i>&lt;W&gt;)
    return UC(<i>bound_</i>) - UC(<i>value_</i>);
  else
    return UC(W(UC(<i>bound_</i>) - UC(<i>value_</i>)));</ins>
<ins>}</ins> else
  return <i>to-unsigned-like</i>(<i>bound_</i> - <i>value_</i>);
</pre></blockquote>
<p>
-16- <i>Remarks:</i> [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3615"><a href="3615">3615</a>. The last specialization of <code>incrementable_traits</code> has wrong operand types</h3>
<p><b>Section:</b> 24.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/incrementable.traits">[incrementable.traits]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2021-09-30 <b>Last modified:</b> 2022-01-31</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#incrementable.traits">active issues</a> in [incrementable.traits].</p>
<p><b>View all other</b> <a href="lwg-index.html#incrementable.traits">issues</a> in [incrementable.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The last specialization of <code>incrementable_traits</code> requires <code>a - b</code> to be well-formed,    
where the types of both operands are <code>const</code> lvalue reference of type <code>T</code>. However inside 
the <code>struct</code>, it uses <code>decltype(declval&lt;T&gt;() - declval&lt;T&gt;())</code> to define the 
<code>difference_type</code>, that is, non-<code>const</code> rvalue reference of type <code>T</code>.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll that failed to reach consensus.
Some suggested NAD:
"Implicit expression variations ([concepts.equality]/6) apply here."
</p>



<p id="res-3615"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4892">N4892</a>.
</p>

<ol>
<li><p>Modify 24.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/incrementable.traits">[incrementable.traits]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  template&lt;class T&gt;
    requires (!requires { typename T::difference_type; } &amp;&amp;
              requires(const T&amp; a, const T&amp; b) { { a - b } -&gt; integral; })
  struct incrementable_traits&lt;T&gt; {
    using difference_type = make_signed_t&lt;decltype(declval&lt;<ins>const</ins> T<ins>&amp;</ins>&gt;() - declval&lt;<ins>const</ins> T<ins>&amp;</ins>&gt;())&gt;;
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3620"><a href="3620">3620</a>. What are execution character sets and execution wide-character sets (after P2314R4)?</h3>
<p><b>Section:</b> 16.3.3.3.4.1 <a href="https://timsong-cpp.github.io/cppwp/character.seq.general">[character.seq.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dawn Perchik <b>Opened:</b> 2021-10-17 <b>Last modified:</b> 2022-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definitions for execution character set and execution wide-character set were reworded and moved to 
16.3.3.3.4.1 <a href="https://timsong-cpp.github.io/cppwp/character.seq.general">[character.seq.general]</a>/p1.2 after applying CWG motion 10 "<a href="https://wg21.link/P2314R4" title=" Character sets and encodings">P2314R4</a> Character 
sets and encodings", but I can't figure out what these terms mean from the wording, which now reads:
</p>
<blockquote><p>
"The <i>execution character set</i> and the <i>execution wide-character set</i> are supersets of the 
basic literal character set (5.3 [lex.charset]). The encodings of the execution character sets and the 
sets of additional elements (if any) are locale-specific."
</p></blockquote>
<p>
Would it be possible to provide complete definitions for these and give examples of each?
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Should say <em>something</em>, even if just "unspecified".
<a href="https://wg21.link/P1885R9" title=" Naming Text Encodings to Demystify Them">P1885R9</a> will expose the possible encoding programmatically,
so could say it's implementationd-defined and implementations can document
that you should ask <code>std::text_encoding</code>.
</p>



<p id="res-3620"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3623"><a href="3623">3623</a>. Uses of <code>std::reverse_iterator</code> with containers should not require manually including <code>&lt;iterator&gt;</code></h3>
<p><b>Section:</b> 24.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators.general">[reverse.iterators.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-10-23 <b>Last modified:</b> 2022-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently it is unspecified whether the definitions of <code>std::reverse_iterator</code> and its related 
operators are available in <code>&lt;vector&gt;</code>, <code>&lt;array&gt;</code>, etc. So, it's unspecified 
now whether the following program is well-formed because it's unspecified whether the equality operator 
is available:
</p>
<blockquote><pre>
#include &lt;vector&gt;

int main()
{
  auto v = std::vector&lt;int&gt;(42);
  for (auto it = v.rbegin(); it != v.rend(); ++it);
  for (auto it = std::rbegin(v); it != std::rend(v); ++it);
}</pre></blockquote>
<p>
 Such underspecification also leaves the guarantee that <code>std::rbegin</code>, <code>std::rend</code>, 
 <code>std::crbegin</code>, and <code>std::crend</code> are available in some other headers seems not so meaningful. 
 In order to guarantee these function templates can be used meaningfully with containers, users are still 
 required to include <code>&lt;iterator&gt;</code> manually.
<p/>
I think the standard should guarantee that wherever the member <code>rbegin</code> (that returns <code>std::reverse_iterator</code>) 
or <code>std::rbegin</code> is provided, the definitions of <code>std::reverse_iterator</code> and its related operators 
are also provided. This strategy is already implemented by libc++, libstdc++, and MSVC STL, and thus I believe we 
should standardize it to reduce uncertainty for users.
<p/>
Note that the situation for <code>std::reverse_iterator</code> is different from LWG <a href="1361" title="Does use of std::size_t in a header imply that typedef name is available to users? (Status: NAD)">1361</a>, because every 
operation on <code>std::size_t</code> is still valid when the typedef-name itself is absent, but <code>==</code> and 
<code>!=</code> on <code>std::reverse_iterator</code> fail if the corresponding declarations are unavailable.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3623"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4901">N4901</a>.
</p>

<ol>
<li><p>Modify 24.5.1.1 <a href="https://timsong-cpp.github.io/cppwp/reverse.iterators.general">[reverse.iterators.general]</a> as indicated:</p>

<blockquote>
<p>
-1- Class template <code>reverse_iterator</code> is an iterator adaptor that iterates from the end of the sequence defined
by its underlying iterator to the beginning of that sequence.
<p/>
<ins>-?- In addition to being available via inclusion of the <code>&lt;iterator&gt;</code> header, class template 
<code>reverse_iterator</code> and function templates in 24.5.1.8 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.cmp">[reverse.iter.cmp]</a> and 24.5.1.9 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.nonmember">[reverse.iter.nonmember]</a> 
are available when any of the following headers are included: <code>&lt;array&gt;</code>  (23.3.2 <a href="https://timsong-cpp.github.io/cppwp/array.syn">[array.syn]</a>), 
<code>&lt;deque&gt;</code>  (23.3.4 <a href="https://timsong-cpp.github.io/cppwp/deque.syn">[deque.syn]</a>), <code>&lt;forward_list&gt;</code> (23.3.6 <a href="https://timsong-cpp.github.io/cppwp/forward.list.syn">[forward.list.syn]</a>), 
<code>&lt;list&gt;</code> (23.3.10 <a href="https://timsong-cpp.github.io/cppwp/list.syn">[list.syn]</a>), <code>&lt;map&gt;</code> (23.4.2 <a href="https://timsong-cpp.github.io/cppwp/associative.map.syn">[associative.map.syn]</a>), 
<code>&lt;regex&gt;</code> (28.6.3 <a href="https://timsong-cpp.github.io/cppwp/re.syn">[re.syn]</a>), <code>&lt;set&gt;</code> (23.4.5 <a href="https://timsong-cpp.github.io/cppwp/associative.set.syn">[associative.set.syn]</a>), 
<code>&lt;span&gt;</code> (23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a>), <code>&lt;stacktrace&gt;</code> (19.6.2 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.syn">[stacktrace.syn]</a>), 
<code>&lt;string&gt;</code> (27.4.2 <a href="https://timsong-cpp.github.io/cppwp/string.syn">[string.syn]</a>), <code>&lt;string_view&gt;</code> (27.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.synop">[string.view.synop]</a>), 
<code>&lt;unordered_map&gt;</code> (23.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.syn">[unord.map.syn]</a>), <code>&lt;unordered_set&gt;</code> (23.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.set.syn">[unord.set.syn]</a>), 
and <code>&lt;vector&gt;</code> (23.3.12 <a href="https://timsong-cpp.github.io/cppwp/vector.syn">[vector.syn]</a>).</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3624"><a href="3624">3624</a>. Inconsistency of <code>&lt;typeinfo&gt;</code>, <code>&lt;initializer_list&gt;</code>, and 
<code>&lt;compare&gt;</code> in the standard library</h3>
<p><b>Section:</b> 17.7 <a href="https://timsong-cpp.github.io/cppwp/support.rtti">[support.rtti]</a>, 17.11 <a href="https://timsong-cpp.github.io/cppwp/support.initlist">[support.initlist]</a>, 17.12 <a href="https://timsong-cpp.github.io/cppwp/cmp">[cmp]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-10-23 <b>Last modified:</b> 2022-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
 Standard library headers <code>&lt;typeinfo&gt;</code>, <code>&lt;initializer_list&gt;</code>, and <code>&lt;compare&gt;</code> 
 are required for some core language features, as specified in 7.6.1.8 <a href="https://timsong-cpp.github.io/cppwp/expr.typeid">[expr.typeid]</a>/7, 
 9.5.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.list">[dcl.init.list]</a>/2, and 7.6.8 <a href="https://timsong-cpp.github.io/cppwp/expr.spaceship">[expr.spaceship]</a>/8. In C++11 (via <a href="https://wg21.link/n2930">N2930</a>), 
 every header that has dependency on <code>std::initializer_list</code> is required to include 
 <code>&lt;initializer_list&gt;</code>. The similar requirements are added for <code>operator&lt;=&gt;</code> and 
 <code>&lt;compare&gt;</code> in C++20 (via LWG <a href="3330" title="Include &lt;compare&gt; from most library headers (Status: C++20)">3330</a>).
<p/>
As N2930 and LWG3330 have been adpoted, IMO there are some inconsistencies in the standard library now:
</p>
<ul>
<li><p>No operation is done for <code>&lt;typeinfo&gt;</code>, although <code>&lt;typeindex&gt;</code> (<code>std::type_index</code>), 
<code>&lt;functional&gt;</code> (<code>std::function</code>, since C++11), and <code>&lt;any&gt;</code> (<code>std::any</code>) 
have dependency on <code>std::type_info</code>;</p></li>
<li><p><code>&lt;iterator&gt;</code> has dependency on <code>std::initializer_list</code> since C++14/LWG <a href="2128" title="Absence of global functions cbegin&#47;cend (Status: C++14)">2128</a> 
(the <code>std::rbegin</code> overload and its friends), but it is not required to include <code>&lt;initializer_list&gt;</code>;</p></li>
<li><p><code>&lt;stacktrace&gt;</code> is not required to include <code>&lt;compare&gt;</code> while it provides operator 
<code>&lt;=&gt;</code> overloads.</p></li>
</ul>
<p>
The situation may be quite serious for <code>std::type_index</code>. Perhaps no expected operation on <code>std::type_index</code> 
is guaranteed to work when only <code>&lt;typeindex&gt;</code> but not <code>&lt;typeinfo&gt;</code> is included.
<p/>
libc++, libstdc++, and MSVC STL include <code>&lt;typeinfo&gt;</code> and <code>&lt;initializer_list&gt;</code> when 
the required standard interface depends on them. I think we should standardize the existing practice (except 
that <code>&lt;stackstrace&gt;</code> has not been implemented now) to reduce uncertainty for users.
</p>

<p><i>[2021-10-24; Daniel comments]</i></p>

<p>
This issue is related to and depending on LWG <a href="3625" title="Should &lt;stacktrace&gt; provide range access function templates? (Status: Open)">3625</a>.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3624"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4901">N4901</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The proposed wording below contains one conditional change, it is therefore depending upon
LWG <a href="3625" title="Should &lt;stacktrace&gt; provide range access function templates? (Status: Open)">3625</a>.]
</p>
</blockquote>

<ol>
<li><p>Add <code>#include &lt;typeinfo&gt;</code> to 22.7.2 <a href="https://timsong-cpp.github.io/cppwp/any.synop">[any.synop]</a>, 22.10.2 <a href="https://timsong-cpp.github.io/cppwp/functional.syn">[functional.syn]</a>, and 
17.7.6 <a href="https://timsong-cpp.github.io/cppwp/type.index.synopsis">[type.index.synopsis]</a>.</p></li>
<li><p>Add <code>#include &lt;initializer_list&gt;</code> to 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>.</p></li>
<li><p>Add <code>#include &lt;compare&gt;</code> to 19.6.2 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.syn">[stacktrace.syn]</a>.</p></li>
<li><p>If we decide to add range access function templates (24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>) to <code>&lt;stacktrace&gt;</code>, 
we should also add <code>#include &lt;initializer_list&gt;</code> to 19.6.2 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.syn">[stacktrace.syn]</a>.</p></li>
</ol>





<hr>
<h3 id="3625"><a href="3625">3625</a>. Should <code>&lt;stacktrace&gt;</code> provide range access function templates?</h3>
<p><b>Section:</b> 19.6.2 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.syn">[stacktrace.syn]</a>, 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-10-23 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#stacktrace.syn">issues</a> in [stacktrace.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Range access function templates (24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>) are available in every standard header 
for containers. As <code>std::basic_stacktrace</code> provides some container-like interfaces (member functions 
<code>begin</code>, <code>end</code>, <code>size</code>, etc.), should we add these free function templates to 
<code>&lt;stacktrace&gt;</code> for consistency?
</p>

<p><i>[2021-10-24; Daniel comments]</i></p>

<p>
This issue is related to LWG <a href="3624" title="Inconsistency of &lt;typeinfo&gt;, &lt;initializer_list&gt;, and 
&lt;compare&gt; in the standard library (Status: New)">3624</a>.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2025-10-07; Status updated New &rarr; Open]</i></p>

<p>
This will be resolved by <a href="https://wg21.link/P3016R6" title=" Resolve inconsistencies in begin/end for valarray and braced initializer lists">P3016R6</a>.
The <code>&lt;initializer_list&gt;</code> part is covered by <a href="3624" title="Inconsistency of &lt;typeinfo&gt;, &lt;initializer_list&gt;, and 
&lt;compare&gt; in the standard library (Status: New)">3624</a>.
</p>



<p id="res-3625"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The proposed wording below contains one conditional change, it is therefore depending upon
a decision]
</p>
</blockquote>

<ol>
<li><p>Modify 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> as indicated:</p>

<blockquote>
<p>
-1- In addition to being available via inclusion of the <code>&lt;iterator&gt;</code> header, the function templates 
in 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> are available when any of the following headers are included: 
<code>&lt;array&gt;</code> (23.3.2 <a href="https://timsong-cpp.github.io/cppwp/array.syn">[array.syn]</a>), <code>&lt;deque&gt;</code> (23.3.4 <a href="https://timsong-cpp.github.io/cppwp/deque.syn">[deque.syn]</a>), 
<code>&lt;forward_list&gt;</code> (23.3.6 <a href="https://timsong-cpp.github.io/cppwp/forward.list.syn">[forward.list.syn]</a>), <code>&lt;list&gt;</code> (23.3.10 <a href="https://timsong-cpp.github.io/cppwp/list.syn">[list.syn]</a>), 
<code>&lt;map&gt;</code> (23.4.2 <a href="https://timsong-cpp.github.io/cppwp/associative.map.syn">[associative.map.syn]</a>), <code>&lt;regex&gt;</code> (28.6.3 <a href="https://timsong-cpp.github.io/cppwp/re.syn">[re.syn]</a>), 
<code>&lt;set&gt;</code> (23.4.5 <a href="https://timsong-cpp.github.io/cppwp/associative.set.syn">[associative.set.syn]</a>), <code>&lt;span&gt;</code> (23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a>), 
<ins><code>&lt;stacktrace&gt;</code> (19.6.2 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.syn">[stacktrace.syn]</a>),</ins> <code>&lt;string&gt;</code> (27.4.2 <a href="https://timsong-cpp.github.io/cppwp/string.syn">[string.syn]</a>), 
<code>&lt;string_view&gt;</code> (27.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.synop">[string.view.synop]</a>), <code>&lt;unordered_map&gt;</code> (23.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.syn">[unord.map.syn]</a>), 
<code>&lt;unordered_set&gt;</code> (23.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.set.syn">[unord.set.syn]</a>), and <code>&lt;vector&gt;</code> (23.3.12 <a href="https://timsong-cpp.github.io/cppwp/vector.syn">[vector.syn]</a>).
[&hellip;]
</p>
</blockquote>
</li>
<li><p>If we decide that <code>&lt;initializer_list&gt;</code> should be included if the header has dependency on 
<code>std::initializer_list</code> (it may be introduce by <code>std::rbegin</code>, <code>std::data</code>, etc.), 
<code>#include &lt;initializer_list&gt;</code> should also be added to 19.6.2 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.syn">[stacktrace.syn]</a>.</p></li>
</ol>





<hr>
<h3 id="3626"><a href="3626">3626</a>. Is <code>std::basic_stacktrace</code> required to use contiguous storage?</h3>
<p><b>Section:</b> 19.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.basic.overview">[stacktrace.basic.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-10-23 <b>Last modified:</b> 2022-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently <code>std::basic_stacktrace</code> has an exposition-only <code>std::vector</code> member for 
storing its elements. According to 16.3.3.6 <a href="https://timsong-cpp.github.io/cppwp/objects.within.classes">[objects.within.classes]</a>/3, it seems that it is 
effectively required that elements of a <code>std::basic_stacktrace</code> are contiguously stored.
However, the implication seems not used otherwhere. The iterator type of a <code>std::basic_stacktrace</code> 
is only required to be random access iterator.
<p/>
IMO if it is required that <code>std::basic_stacktrace</code> uses contiguous storage, we should 
explicitly strengthen some requirements, perhaps a the member function data should be added.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
<br/>
"The problem here is that a handful of member functions
(<code>operator[]</code>, <code>at</code>, perhaps <code>begin</code>)
expose references to the vector elements directly,
which can be read to require contiguity.
We should rephrase the members at issue to not do that."
</p>



<p id="res-3626"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4901">N4901</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The proposed wording below contains also conditional changes, it is therefore depending upon
a decision]
</p>
</blockquote>

<ol>
<li><p>Modify 19.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.basic.overview">[stacktrace.basic.overview]</a> as indicated:</p>

<blockquote>
<p>
-1- The class template <code>basic_stacktrace</code> satisfies the requirements of an allocator-aware container 
(Table 80 [tab:container.alloc.req]), a sequence container (23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>), 
<ins>a contiguous container,</ins> and a reversible container (23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>) 
except that [&hellip;]
</p>
</blockquote>
</li>
<li><p>Modify 19.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.basic.obs">[stacktrace.basic.obs]</a> as indicated:</p>

<blockquote>
<pre>
using const_iterator = <i>implementation-defined</i>;
</pre>
<blockquote>
<p>
-1- The type models <code><del>random_access_iterator</del><ins>contiguous_iterator</ins></code> 
(<del>24.3.4.13 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.random.access">[iterator.concept.random.access]</a></del><ins>24.3.4.14 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.contiguous">[iterator.concept.contiguous]</a></ins>) and meets 
the <i>Cpp17RandomAccessIterator</i> requirements (24.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>).
</p>
</blockquote>
</blockquote>
</li>
</ol>

<p><b>Optional additional changes</b> (the following parts are proposed only if <code>data()</code> is wanted)</p>

<ol start="3">
<li><p>Modify 19.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.basic.overview">[stacktrace.basic.overview]</a>, class template <code>basic_stacktrace</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
const_reference operator[](size_type) const;
const_reference at(size_type) const;

<ins>const stacktrace_entry* data() const noexcept;</ins>

// 19.6.4.4 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.basic.cmp">[stacktrace.basic.cmp]</a>, comparisons
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 19.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/stacktrace.basic.obs">[stacktrace.basic.obs]</a> as indicated:</p>

<blockquote>
<pre>
const_reference at(size_type frame_no) const;
</pre>
<blockquote>
<p>
-13- [&hellip;]
<p/>
-14- [&hellip;]
</p>
</blockquote>
<pre>
<ins>const stacktrace_entry* data() const noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns:</i> <code>frames_.data()</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3627"><a href="3627">3627</a>. Inconsistent specifications for <code>std::make_optional</code> overloads</h3>
<p><b>Section:</b> 22.5.10 <a href="https://timsong-cpp.github.io/cppwp/optional.specalg">[optional.specalg]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-10-23 <b>Last modified:</b> 2022-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Three <code>std::make_optional</code> overloads are specified in 22.5.10 <a href="https://timsong-cpp.github.io/cppwp/optional.specalg">[optional.specalg]</a>. 
The first one is specified by "<i>Returns:</i>" and the other two are specified by "<i>Effects:</i> Equivalent to:".
According to 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>/4, such uses of "<i>Effects:</i> Equivalent to:" 
propagate the <i>Constraints</i> specified for constructors. As the selected constructor for the first 
overload has "<i>Constraints:</i>" (22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a>/22), it seems that inconsistency is introduced here.
<p/>
Existing implementations are inconsistent: libstdc++ constrains all three overloads, 
while libc++ and MSVC STL do not constrain any of them.
<p/>
IMO all three overloads should be constrained.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3627"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/n4901">N4901</a>.
</p>

<ol>
<li><p>Modify 22.5.10 <a href="https://timsong-cpp.github.io/cppwp/optional.specalg">[optional.specalg]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt; constexpr optional&lt;decay_t&lt;T&gt;&gt; make_optional(T&amp;&amp; v);
</pre>
<blockquote>
<p>
-3- <i><del>Returns</del><ins>Effects</ins>:</i> <ins>Equivalent to: </ins><code><ins>return </ins>optional&lt;decay_t&lt;T&gt;&gt;(std::forward&lt;T&gt;(v))<ins>;</ins></code><del>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3628"><a href="3628">3628</a>. "<i>Effects:</i> Equivalent to:" and uninitialized memory algorithms</h3>
<p><b>Section:</b> 26.11 <a href="https://timsong-cpp.github.io/cppwp/specialized.algorithms">[specialized.algorithms]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-10-23 <b>Last modified:</b> 2022-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#specialized.algorithms">active issues</a> in [specialized.algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Most uninitialized memory algorithms (26.11 <a href="https://timsong-cpp.github.io/cppwp/specialized.algorithms">[specialized.algorithms]</a>) are specified by 
plain "<i>Effects:</i> Equivalent to:". According to 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>/4, 
such wording requires propagation of "<i>Constraints</i>" of selected constructors. The first two 
overloads of <code>std::reduce</code> (26.10.4 <a href="https://timsong-cpp.github.io/cppwp/reduce">[reduce]</a>) are specified similarly.
<p/>
I feel the wording for uninitialized memory algorithms is incorrect, because it means that the 
constraints, especially for algorithms in the <code>std</code>, depend on "<code>Constraints</code>" in 
the specifications of many standard library types (but not any user-defined type), which is 
implementable but brings serious inconsistency.
<p/>
Perhaps we should add "<i>Mandates:</i>" to these algorithms (except for algorithms in <code>std::ranges</code>).
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
<br/>
Tim:
"P2. Not for this particular case (I'm pretty sure there'll be agreement
that this shouldn't induce any constraint), but for the more general
issue of "<em>Effects:</em> Equivalent to" propagating <em>Constraints:</em>;
I'm not sure that's the right approach in general (unlike the other elements,
<em>Constraints:</em> requires special handling beyond "use this code" and is
pretty hard to work through if we have a lengthy code block) - and it
certainly doesn't really make a lot of sense to propagate <em>Constraints:</em>
but not actual core-language constraints."
</p>



<p id="res-3628"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3630"><a href="3630">3630</a>. Inconsistent <code>basic_regex</code> construction and assignment from iterator range</h3>
<p><b>Section:</b> 28.6.7.2 <a href="https://timsong-cpp.github.io/cppwp/re.regex.construct">[re.regex.construct]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-10-31 <b>Last modified:</b> 2022-01-29</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.regex.construct">active issues</a> in [re.regex.construct].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex.construct">issues</a> in [re.regex.construct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have:
</p>

<pre>
template&lt;class ForwardIterator&gt;
  basic_regex(ForwardIterator first, ForwardIterator last,
              flag_type f = regex_constants::ECMAScript);
</pre>

<p>
and:
</p>

<pre>
template&lt;class InputIterator&gt;
  basic_regex&amp; assign(InputIterator first, InputIterator last,
                          flag_type f = regex_constants::ECMAScript);
</pre>

<p>
Ignoring the lack of proper requirements (which is LWG <a href="3341" title="basic_regex range constructor: Missing requirements for iterator types (Status: New)">3341</a>),
why does the constructor take forward iterators,
but the assign function takes input iterators?
Why could construction from input iterators not be implemented as simply
<code>assign(first, last, f)</code>?
</p>

<p>
The current constructor signature is the result of <a href="https://wg21.link/N2409" title=" Proposed Resolutions for the Outstanding Issues in Chapter 28: Regular expressions library">N2409</a>
which was resolving LWG <a href="682" title="basic_regex ctor takes InputIterator or ForwardIterator? (Status: CD1)">682</a>.
It looks like the <code>assign</code> function should have been changed
at the same time, to keep them consistent.
I see no reason why they can't both take input iterators.
The meta-programming needed to avoid an additional string copy for the
input iterator case is trivial with <code>if constexpr</code>
and C++20 iterator concepts.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3630"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="3633"><a href="3633">3633</a>. Atomics are copy constructible and copy assignable from <code>volatile</code> atomics</h3>
<p><b>Section:</b> 32.5 <a href="https://timsong-cpp.github.io/cppwp/atomics">[atomics]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Wesley Maxey <b>Opened:</b> 2021-11-05 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>atomic</code> and <code>atomic&lt;T*&gt;</code> (in 32.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic.general">[atomics.types.generic.general]</a> 
and 32.5.8.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.pointer">[atomics.types.pointer]</a>) explicitly deletes the following functions:
</p>
<blockquote>
<pre>
atomic(const atomic&amp;) = delete;
atomic&amp; operator=(const atomic&amp;) = delete;
atomic&amp; operator=(const atomic&amp;) volatile = delete;
</pre>
</blockquote>
<p>
The intent is to make atomic objects not copyable, so that initializing an atomic object 
from another atomic, or assigning an atomic object with a value from another atomic, 
must be an explicit operation.
<p/>
We also explicitly support <code>volatile</code> objects of types that are specializations of <code>std::atomic</code>; 
some of the functions that are vital for the support of volatile atomics are the following conversion operators:
</p>
<blockquote>
<pre>
operator T() const volatile noexcept; // for non-pointers
operator T*() const volatile noexcept; // for pointers
</pre>
</blockquote>
<p>
The presence of this conversion operator means that all the statements in the following piece of code 
compile successfully today, despite the deleted functions mentioned earlier:
</p>
<blockquote>
<pre>
volatile std::atomic&lt;int&gt; a;
volatile std::atomic&lt;int&gt; b(a);
std::atomic&lt;int&gt; c(a);
b = a;
c = a;
</pre>
</blockquote>
<p>
However, if <code>a</code> is not a volatile object, none of the last four lines compile.
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
<br/>
This PR would allow
<pre>
atomic&lt;int&gt; x, y = std::move(x);
</pre>
because const volatile&amp; doesn't bind to rvalues. It sounds like we'll
need to delete both const volatile&amp; and const volatile&amp;&amp;.
</p>



<p id="res-3633"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>
<li><p>Modify 32.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.generic.general">[atomics.types.generic.general]</a>, class template <code>atomic</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
atomic(const <ins>volatile</ins> atomic&amp;) = delete;
atomic&amp; operator=(const <ins>volatile</ins> atomic&amp;) = delete;
atomic&amp; operator=(const <ins>volatile</ins> atomic&amp;) volatile = delete;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 32.5.8.3 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.int">[atomics.types.int]</a>, class template <code>atomic&lt;<i>integral</i>&gt;</code> specialization 
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
atomic(const <ins>volatile</ins> atomic&amp;) = delete;
atomic&amp; operator=(const <ins>volatile</ins> atomic&amp;) = delete;
atomic&amp; operator=(const <ins>volatile</ins> atomic&amp;) volatile = delete;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 32.5.8.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.float">[atomics.types.float]</a>, class template <code>atomic&lt;<i>floating-point</i>&gt;</code> specialization 
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
atomic(const <ins>volatile</ins> atomic&amp;) = delete;
atomic&amp; operator=(const <ins>volatile</ins> atomic&amp;) = delete;
atomic&amp; operator=(const <ins>volatile</ins> atomic&amp;) volatile = delete;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 32.5.8.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.pointer">[atomics.types.pointer]</a>, class template <code>atomic&lt;T*&gt;</code> partial specialization 
synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
atomic(const <ins>volatile</ins> atomic&amp;) = delete;
atomic&amp; operator=(const <ins>volatile</ins> atomic&amp;) = delete;
atomic&amp; operator=(const <ins>volatile</ins> atomic&amp;) volatile = delete;
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3634"><a href="3634">3634</a>. When are static-duration <code>memory_resource</code> objects destroyed?</h3>
<p><b>Section:</b> 20.5.4 <a href="https://timsong-cpp.github.io/cppwp/mem.res.global">[mem.res.global]</a>, 19.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.objects">[syserr.errcat.objects]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2021-11-07 <b>Last modified:</b> 2022-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.res.global">issues</a> in [mem.res.global].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both <code>std::pmr::new_delete_resource</code> and <code>std::pmr::null_memory_resource</code> return pointers 
to static-duration objects. It seems unspecified when the pointed-to objects are destroyed, so users can't 
reliably use these objects during destructions of their static-duration objects.
<p/>
<code>std::generic_category</code> and <code>std::system_category</code> have the same issue, except that the 
referred-to objects may have different storage duration.
<p/>
Should we specify in which case can these objects be used in the termination of a program?
</p>

<p><i>[2022-01-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3634"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3637"><a href="3637">3637</a>. <code>pmr::memory_resource::do_allocate</code> needs clarification</h3>
<p><b>Section:</b> 20.5.2 <a href="https://timsong-cpp.github.io/cppwp/mem.res.class">[mem.res.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-11-12 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.res.class">issues</a> in [mem.res.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.5.2.3 <a href="https://timsong-cpp.github.io/cppwp/mem.res.private">[mem.res.private]</a> says that <code>pmr::memory_resource::do_allocate</code> 
returns "a pointer to allocated storage" and references 6.8.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/basic.stc.dynamic.allocation">[basic.stc.dynamic.allocation]</a>. 
But it's not really clear which parts of 6.8.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/basic.stc.dynamic.allocation">[basic.stc.dynamic.allocation]</a> define 
"allocated storage". <code>pmr::memory_resource::allocate</code> is not "an allocation function" 
and not a "replaceable allocation function", so "the value returned by a replaceable allocation 
function is a non-null pointer value" doesn't apply here, and neither does "different from any 
previously returned value".
<p/>
Is <code>pmr::memory_resource::allocate</code> allowed to return a null pointer on success? Is it 
allowed to return the same address twice, without an intervening deallocation? What about if you call 
<code>pmr::monotonic_buffer_resource::release()</code>, is that a deallocation?
<p/>
When discussed on the reflector the consensus was that returning null should not be allowed, 
it should throw an exception or return a valid dereferenceable pointer. The reference to 
6.8.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/basic.stc.dynamic.allocation">[basic.stc.dynamic.allocation]</a> doesn't work to specify this though, so we should 
restate the requirements without directly using the core wording for <code>operator new</code>.
<p/>
It was also suggested that returning the same value should not be allowed without an intervening 
deallocation, but that "deallocation" should not only mean a call to deallocate on the resource, 
but include things like <code>pmr::monotonic_buffer_resource::release()</code>, and when a memory 
resource's destructor returns memory to an upstream resource.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3637"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3638"><a href="3638">3638</a>. <code>vector&lt;bool&gt;::swap(reference, reference)</code> is useless</h3>
<p><b>Section:</b> 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-11-12 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.bool">active issues</a> in [vector.bool].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>vector&lt;bool&gt;</code> provides a static member function that can be used to swap 
rvalues of type <code>vector&lt;bool&gt;::reference</code> like so:
</p>
<blockquote><pre>
vector&lt;bool&gt; v{true, false};
vector&lt;bool&gt;::swap(v[0], v[1]);
</pre></blockquote>
<p>
This is not useful. Nobody calls <code>swap</code> like that. This fails to make <code>v[0]</code> swappable with 
<code>v[1]</code> as per 16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>. The similar SGI STL <code>bit_vector</code> class 
that <code>vector&lt;bool&gt;</code> is partially inspired by has a "global function" with the same signature, 
<a href="https://www.boost.org/sgi/stl/bit_vector.html">described as</a>:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
"Swaps the bits referred to by <code>x</code> and <code>y</code>. This is a global function, not a member function. 
It is necessary because the ordinary version of <code>swap</code> takes arguments of type <code>T&amp;</code>, and 
<code>bit_vector::reference</code> is a class, not a built-in C++ reference."
</p>
</blockquote>
<p>
For some reason this became a static member function of <code>vector&lt;bool&gt;</code> in the C++ standard.
<p/>
We should restore the intended functionality, and deprecate the useless function.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>

<li><p>Create a new subclause [vector.bool.general] below 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> and move paragraphs p1-p3 
(including the class template <code>vector&lt;bool, Allocator&gt;</code> partial specialization synopsis) into that 
subclause.</p>
</li>

<li><p>Add to the synopsis in [vector.bool.general] p1 (n&eacute;e 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> p1):</p>

<blockquote>
<pre>
[&hellip;]
<i>// bit reference</i>
class reference {
  friend class vector;
  constexpr reference() noexcept;
public:
  constexpr reference(const reference&amp;) = default;
  constexpr ~reference();
  constexpr operator bool() const noexcept;
  constexpr reference&amp; operator=(bool x) noexcept;
  constexpr reference&amp; operator=(const reference&amp; x) noexcept;
  constexpr const reference&amp; operator=(bool x) const noexcept;
  constexpr void flip() noexcept; <i>// flips the bit</i>
  
  <ins>friend constexpr void swap(reference x, reference y) noexcept;
  friend constexpr void swap(reference x, bool&amp; y) noexcept;
  friend constexpr void swap(bool&amp; x, reference y) noexcept;</ins>
};
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Remove the static <code>swap</code> function from the class template <code>vector&lt;bool, Allocator&gt;</code> 
partial specialization synopsis:</p>

<blockquote>
<pre>
[&hellip;]
constexpr void swap(vector&amp;);
<del>constexpr static void swap(reference x, reference y) noexcept;</del>
constexpr void flip() noexcept; <i>// flips all bits</i>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Create a new subclause [vector.bool.ref] after p3, with p4 as its first paragraph, and add after it:</p>

<blockquote>
<p>
<ins><b>22.3.12.? Class <code>vector&lt;bool, Allocator&gt;::reference</code> [vector.bool.ref]</b></ins>
<p/>
-1- <code>reference</code> is a class that simulates the behavior of references of a single bit in <code>vector&lt;bool&gt;</code>. 
The conversion function returns <code>true</code> when the bit is set, and <code>false</code> otherwise. The assignment 
operators set the bit when the argument is (convertible to) <code>true</code> and clear it otherwise. 
<code>flip</code> reverses the state of the bit.
</p>
<pre>
<ins>constexpr void flip() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> <code>*this = !*this;</code></ins>
</p>
</blockquote>
<pre>
 <ins>friend constexpr void swap(reference x, reference y) noexcept;
 friend constexpr void swap(reference x, bool&amp; y) noexcept;
 friend constexpr void swap(bool&amp; x, reference y) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Exchanges the contents of <code>x</code> and <code>y</code> as if by:</ins>
</p>
<blockquote><pre>
<ins>bool b = x;
x = y;
y = b;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Create a new subclause [vector.bool.mem] after that, containing the paragraphs 
describing <code>flip()</code> and the <code>hash</code> specialization:</p>

<blockquote>
<p>
<ins><b>22.3.12.? Class <code>vector&lt;bool, Allocator&gt;</code> members [vector.bool.mem]</b></ins>
</p>
<pre>
constexpr void flip() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Replaces each element in the container with its complement.
</p>
</blockquote>
<pre>
 <del>constexpr static void swap(reference x, reference y) noexcept;</del>
</pre>
<blockquote>
<p>
<del>-6- <i>Effects:</i> Exchanges the contents of <code>x</code> and <code>y</code> as if by:</del>
</p>
<blockquote><pre>
<del>bool b = x;
x = y;
y = b;</del>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;
</pre>
<blockquote>
<p>
-7- The specialization is enabled (22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>).
</p>
</blockquote>
</blockquote>
</li>

<li><p>Create a new subclause [depr.vector.bool.swap] after  [depr.string.capacity]</p>

<blockquote>
<p>
<ins><b>D.? Deprecated <code>vector&lt;bool, Allocator&gt;</code> swap [depr.vector.bool.swap]</b></ins>
<p/>
<ins>-?- The following member is declared in addition to those members specified in 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a>:</ins>
</p>
<pre>
<ins>namespace std {
  template&lt;class Allocator&gt; class vector&lt;bool, Allocator&gt; {
  public:
    constexpr static void swap(reference x, reference y) noexcept;
  };
}</ins>
</pre>
<pre>
<ins>constexpr static void swap(reference x, reference y) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> <code>swap(x, y)</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2022-01-22; Jonathan replaces <code>swap(x, y)</code> in the Annex D
wording, following reflector discussion about lookup for <code>swap</code>
finding itself in that context.
]</i></p>


<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>

<li><p>Create a new subclause [vector.bool.general] below 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> and move paragraphs p1-p3 
(including the class template <code>vector&lt;bool, Allocator&gt;</code> partial specialization synopsis) into that 
subclause.</p>
</li>

<li><p>Add to the synopsis in [vector.bool.general] p1 (n&eacute;e 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a> p1):</p>

<blockquote>
<pre>
[&hellip;]
<i>// bit reference</i>
class reference {
  friend class vector;
  constexpr reference() noexcept;
public:
  constexpr reference(const reference&amp;) = default;
  constexpr ~reference();
  constexpr operator bool() const noexcept;
  constexpr reference&amp; operator=(bool x) noexcept;
  constexpr reference&amp; operator=(const reference&amp; x) noexcept;
  constexpr const reference&amp; operator=(bool x) const noexcept;
  constexpr void flip() noexcept; <i>// flips the bit</i>
  
  <ins>friend constexpr void swap(reference x, reference y) noexcept;
  friend constexpr void swap(reference x, bool&amp; y) noexcept;
  friend constexpr void swap(bool&amp; x, reference y) noexcept;</ins>
};
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Remove the static <code>swap</code> function from the class template <code>vector&lt;bool, Allocator&gt;</code> 
partial specialization synopsis:</p>

<blockquote>
<pre>
[&hellip;]
constexpr void swap(vector&amp;);
<del>constexpr static void swap(reference x, reference y) noexcept;</del>
constexpr void flip() noexcept; <i>// flips all bits</i>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Create a new subclause [vector.bool.ref] after p3, with p4 as its first paragraph, and add after it:</p>

<blockquote>
<p>
<ins><b>22.3.12.? Class <code>vector&lt;bool, Allocator&gt;::reference</code> [vector.bool.ref]</b></ins>
<p/>
-1- <code>reference</code> is a class that simulates the behavior of references of a single bit in <code>vector&lt;bool&gt;</code>. 
The conversion function returns <code>true</code> when the bit is set, and <code>false</code> otherwise. The assignment 
operators set the bit when the argument is (convertible to) <code>true</code> and clear it otherwise. 
<code>flip</code> reverses the state of the bit.
</p>
<pre>
<ins>constexpr void flip() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> <code>*this = !*this;</code></ins>
</p>
</blockquote>
<pre>
 <ins>friend constexpr void swap(reference x, reference y) noexcept;
 friend constexpr void swap(reference x, bool&amp; y) noexcept;
 friend constexpr void swap(bool&amp; x, reference y) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Exchanges the contents of <code>x</code> and <code>y</code> as if by:</ins>
</p>
<blockquote><pre>
<ins>bool b = x;
x = y;
y = b;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Create a new subclause [vector.bool.mem] after that, containing the paragraphs 
describing <code>flip()</code> and the <code>hash</code> specialization:</p>

<blockquote>
<p>
<ins><b>22.3.12.? Class <code>vector&lt;bool, Allocator&gt;</code> members [vector.bool.mem]</b></ins>
</p>
<pre>
constexpr void flip() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Replaces each element in the container with its complement.
</p>
</blockquote>
<pre>
 <del>constexpr static void swap(reference x, reference y) noexcept;</del>
</pre>
<blockquote>
<p>
<del>-6- <i>Effects:</i> Exchanges the contents of <code>x</code> and <code>y</code> as if by:</del>
</p>
<blockquote><pre>
<del>bool b = x;
x = y;
y = b;</del>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;
</pre>
<blockquote>
<p>
-7- The specialization is enabled (22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>).
</p>
</blockquote>
</blockquote>
</li>

<li><p>Create a new subclause [depr.vector.bool.swap] after  [depr.string.capacity]</p>

<blockquote>
<p>
<ins><b>D.? Deprecated <code>vector&lt;bool, Allocator&gt;</code> swap [depr.vector.bool.swap]</b></ins>
<p/>
<ins>-?- The following member is declared in addition to those members specified in 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a>:</ins>
</p>
<pre>
<ins>namespace std {
  template&lt;class Allocator&gt; class vector&lt;bool, Allocator&gt; {
  public:
    constexpr static void swap(reference x, reference y) noexcept;
  };
}</ins>
</pre>
<pre>
<ins>constexpr static void swap(reference x, reference y) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Exchanges the contents of <code>x</code> and <code>y</code> as if by:</ins>
</p>
<blockquote><pre>
<ins>bool b = x;
x = y;
y = b;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2024-08-21; Jonathan provides improved wording]</i></p>

<p>
Rebase on the current draft, change "exchanges the contents" to
"exchanges the denoted values", and don't split the subclause into
new subclauses.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>

<li><p>Add to the synopsis in 23.3.14.1 <a href="https://timsong-cpp.github.io/cppwp/vector.bool.pspc">[vector.bool.pspc]</a> p1:</p>

<blockquote>
<pre>
[&hellip;]
<i>// bit reference</i>
class reference {
  friend class vector;
  constexpr reference() noexcept;

public:
  constexpr reference(const reference&amp;) = default;
  constexpr ~reference();
  constexpr operator bool() const noexcept;
  constexpr reference&amp; operator=(bool x) noexcept;
  constexpr reference&amp; operator=(const reference&amp; x) noexcept;
  constexpr const reference&amp; operator=(bool x) const noexcept;
  constexpr void flip() noexcept;   <i>// flips the bit</i>
  
<ins>  friend constexpr void swap(reference x, reference y) noexcept;
  friend constexpr void swap(reference x, bool&amp; y) noexcept;
  friend constexpr void swap(bool&amp; x, reference y) noexcept;</ins>
};
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Remove the static <code>swap</code> function from the same synopsis:</p>

<blockquote>
<pre>
[&hellip;]
constexpr void swap(vector&amp;)
  noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value ||
           allocator_traits&lt;Allocator&gt;::is_always_equal::value);
<del>static constexpr void swap(reference x, reference y) noexcept;</del>
constexpr void flip() noexcept;    <i>// flips all bits</i>
constexpr void clear() noexcept;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify the paragraphs below the synopsis as shown:</p>

<blockquote>
<p>
-4- <code>reference</code> is a class that simulates the behavior of references of a single bit in <code>vector&lt;bool&gt;</code>. 
The conversion function returns <code>true</code> when the bit is set, and <code>false</code> otherwise. The assignment 
operators set the bit when the argument
<del>is (convertible to)</del>
<ins>converts to</ins>
<code>true</code> and clear it otherwise. 
<code>flip</code> reverses the state of the bit.
</p>
<pre>
<ins>constexpr void reference::flip() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> <code>*this = !*this;</code></ins>
</p>
</blockquote>
<pre><ins>
 constexpr void swap(reference x, reference y) noexcept;
 constexpr void swap(reference x, bool&amp; y) noexcept;
 constexpr void swap(bool&amp; x, reference y) noexcept;
</ins></pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Exchanges the values denoted by <code>x</code> and <code>y</code> as if by:</ins>
</p>
<blockquote><pre>
<ins>bool b = x;
x = y;
y = b;</ins>
</pre></blockquote>
</blockquote>

<pre>
constexpr void flip() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Replaces each element in the container with its complement.
</p>
</blockquote>
<pre>
 <del>constexpr static void swap(reference x, reference y) noexcept;</del>
</pre>
<blockquote>
<p>
<del>-6- <i>Effects:</i> Exchanges the contents of <code>x</code> and <code>y</code> as if by:</del>
</p>
<blockquote><pre>
<del>bool b = x;
x = y;
y = b;</del>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;
</pre>
<blockquote>
<p>
-7- The specialization is enabled (22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>).
</p>
</blockquote>
</blockquote>
</li>

<li><p>Create a new subclause [depr.vector.bool.swap] after D.20 <a href="https://timsong-cpp.github.io/cppwp/depr.format">[depr.format]</a></p>

<blockquote>
<p>
<ins><b>D.? Deprecated <code>vector&lt;bool, Allocator&gt;</code> swap [depr.vector.bool.swap]</b></ins>
<p/>
<ins>-?- The following member is declared in addition to those members specified in 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a>:</ins>
</p>
<pre>
<ins>namespace std {
  template&lt;class Allocator&gt; class vector&lt;bool, Allocator&gt; {
  public:
    static constexpr void swap(reference x, reference y) noexcept;
  };
}</ins>
</pre>
<pre>
<ins>static constexpr void swap(reference x, reference y) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Exchanges the values denoted by <code>x</code> and <code>y</code> as if by:</ins>
</p>
<blockquote><pre>
<ins>bool b = x;
x = y;
y = b;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>

</blockquote>

<p><i>[2025-02-07; Jonathan provides improved wording]</i></p>

<p>
Add <code class='backtick'>swap</code> for <code class='backtick'>bitset::reference</code>, as proposed in LWG <a href="4187" title="bitset::reference should be const-assignable (Status: New)">4187</a>.
</p>



<p id="res-3638"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>

<li><p>Modify 22.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/template.bitset.general">[template.bitset.general]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t N&gt; class bitset {
  public:
    // <i>bit reference</i>
    class reference {
    public:
      constexpr reference(const reference&amp;) = default;
      constexpr ~reference();
      constexpr reference&amp; operator=(bool x) noexcept;           // <i>for b[i] = x;</i>
      constexpr reference&amp; operator=(const reference&amp;) noexcept; // <i>for b[i] = b[j];</i>
      constexpr bool operator~() const noexcept;                 // <i>flips the bit</i>
      constexpr operator bool() const noexcept;                  // <i>for x = b[i];</i>
      constexpr reference&amp; flip() noexcept;                      // <i>for b[i].flip();</i>
<ins>      friend constexpr void swap(reference x, reference y) noexcept;
      friend constexpr void swap(reference x, bool&amp; y) noexcept;
      friend constexpr void swap(bool&amp; x, reference y) noexcept;</ins>      
    };
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.3.14.1 <a href="https://timsong-cpp.github.io/cppwp/vector.bool.pspc">[vector.bool.pspc]</a> p1:</p>

<blockquote>
<pre>
[&hellip;]
<i>// bit reference</i>
class reference {
  friend class vector;
  constexpr reference() noexcept;

public:
  constexpr reference(const reference&amp;) = default;
  constexpr ~reference();
  constexpr operator bool() const noexcept;
  constexpr reference&amp; operator=(bool x) noexcept;
  constexpr reference&amp; operator=(const reference&amp; x) noexcept;
  constexpr const reference&amp; operator=(bool x) const noexcept;
  constexpr void flip() noexcept;   <i>// flips the bit</i>
  
<ins>  friend constexpr void swap(reference x, reference y) noexcept;
  friend constexpr void swap(reference x, bool&amp; y) noexcept;
  friend constexpr void swap(bool&amp; x, reference y) noexcept;</ins>
};
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Remove the static <code>swap</code> function from the same synopsis:</p>

<blockquote>
<pre>
[&hellip;]
constexpr void swap(vector&amp;)
  noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value ||
           allocator_traits&lt;Allocator&gt;::is_always_equal::value);
<del>static constexpr void swap(reference x, reference y) noexcept;</del>
constexpr void flip() noexcept;    <i>// flips all bits</i>
constexpr void clear() noexcept;
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify the paragraphs below the synopsis as shown:</p>

<blockquote>
<p>
-4- <code>reference</code> is a class that simulates the behavior of references of a single bit in <code>vector&lt;bool&gt;</code>. 
The conversion function returns <code>true</code> when the bit is set, and <code>false</code> otherwise. The assignment 
operators set the bit when the argument
<del>is (convertible to)</del>
<ins>converts to</ins>
<code>true</code> and clear it otherwise. 
<code>flip</code> reverses the state of the bit.
</p>
<pre>
<ins>constexpr void reference::flip() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> <code>*this = !*this;</code></ins>
</p>
</blockquote>
<pre><ins>
 constexpr void swap(reference x, reference y) noexcept;
 constexpr void swap(reference x, bool&amp; y) noexcept;
 constexpr void swap(bool&amp; x, reference y) noexcept;
</ins></pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Exchanges the values denoted by <code>x</code> and <code>y</code> as if by:</ins>
</p>
<blockquote><pre>
<ins>bool b = x;
x = y;
y = b;</ins>
</pre></blockquote>
</blockquote>

<pre>
constexpr void flip() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Replaces each element in the container with its complement.
</p>
</blockquote>
<pre>
 <del>constexpr static void swap(reference x, reference y) noexcept;</del>
</pre>
<blockquote>
<p>
<del>-6- <i>Effects:</i> Exchanges the contents of <code>x</code> and <code>y</code> as if by:</del>
</p>
<blockquote><pre>
<del>bool b = x;
x = y;
y = b;</del>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt;&gt;;
</pre>
<blockquote>
<p>
-7- The specialization is enabled (22.10.19 <a href="https://timsong-cpp.github.io/cppwp/unord.hash">[unord.hash]</a>).
</p>
</blockquote>
</blockquote>
</li>

<li><p>Create a new subclause [depr.vector.bool.swap] after D.20 <a href="https://timsong-cpp.github.io/cppwp/depr.format">[depr.format]</a></p>

<blockquote>
<p>
<ins><b>D.? Deprecated <code>vector&lt;bool, Allocator&gt;</code> swap [depr.vector.bool.swap]</b></ins>
<p/>
<ins>-?- The following member is declared in addition to those members specified in 23.3.14 <a href="https://timsong-cpp.github.io/cppwp/vector.bool">[vector.bool]</a>:</ins>
</p>
<pre>
<ins>namespace std {
  template&lt;class Allocator&gt; class vector&lt;bool, Allocator&gt; {
  public:
    static constexpr void swap(reference x, reference y) noexcept;
  };
}</ins>
</pre>
<pre>
<ins>static constexpr void swap(reference x, reference y) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Exchanges the values denoted by <code>x</code> and <code>y</code> as if by:</ins>
</p>
<blockquote><pre>
<ins>bool b = x;
x = y;
y = b;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3640"><a href="3640">3640</a>. Clarify which exceptions are propagated</h3>
<p><b>Section:</b> 16.4.4 <a href="https://timsong-cpp.github.io/cppwp/utility.requirements">[utility.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2021-11-01 <b>Last modified:</b> 2022-10-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.requirements">active issues</a> in [utility.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.requirements">issues</a> in [utility.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This originated from the editorial issues <a href="https://github.com/cplusplus/draft/issues/4863">#4863</a> 
and <a href="https://github.com/cplusplus/draft/issues/4869">#4869</a>.
<p/>
Some <i>Throws:</i> elements are specified to throw the exceptions an evaluation of <code><i>E</i></code> exits with. 
This wording excludes exceptions thrown involving the initialization and destruction of parameters 
of <code><i>E</i></code>, temporaries of <code><i>E</i></code>, and the destruction of the result of <code><i>E</i></code>.
<p/>
The proposed wording below fixes this with front matter. As if affects more than just <i>Throws:</i> elements, it talks 
about requirements and guarantees when <code><i>E</i></code> exits via an exception.
<p/>
As noted in the originating editorial issues, some LWG members prefer fixing each individual case 
of wording used to describe exception propagation rather than patching them up with front matter.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Any throwing destructor is library UB already, so there's no
need to contort the wording to accommodate those."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>

<li><p>Add a new subclause [exception.propagation] at the end of 16.4.4 <a href="https://timsong-cpp.github.io/cppwp/utility.requirements">[utility.requirements]</a> (after
16.4.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.completeness">[allocator.requirements.completeness]</a>):</p>

<blockquote>
<p>
<ins><b>16.4.4.? Exception propagation requirements [exception.propagation]</b></ins>
<p/>
<ins>-?- Some functions defined in the C++ standard library impose requirements and guarantees <i>R-G</i> 
when a described evaluation <code><i>E</i></code> exits via an exception. Let <code><i>F</i></code> be an evaluation that is 
implied by evaluating <code><i>E</i></code> up to the complete evaluation of its enclosing full-expression. Unless 
stated otherwise, an execution of <code><i>F</i></code> that exits via an exception also has <i>R-G</i> imposed.
[<i>Note ?</i>: This includes when initializing and destroying parameters, evaluating default arguments, 
and destroying temporaries (including discarded-value expressions) (7.6.1.3 <a href="https://timsong-cpp.github.io/cppwp/expr.call">[expr.call]</a>) exit via 
an exception. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2022-09-28; Johel provides revised wording]</i></p>




<p id="res-3640"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>

<li><p>Add a new subclause [exception.propagation] at the end of 16.4.4 <a href="https://timsong-cpp.github.io/cppwp/utility.requirements">[utility.requirements]</a> (after
16.4.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.completeness">[allocator.requirements.completeness]</a>):</p>

<blockquote>
<p>
<ins><b>16.4.4.? Exception propagation requirements [exception.propagation]</b></ins>
<p/>
<ins>-?- Some functions defined in the C++ standard library impose requirements and guarantees <i>R-G</i> when 
a described evaluation <code><i>E</i></code> of a constructor or construction exits via an exception. Let 
<code><i>F</i></code> be the initialization denoted by <code><i>E</i></code>. Unless stated otherwise, <code><i>F</i></code> 
also has <i>R-G</i> imposed.
[<i>Note ?</i>: This includes the initialization of parameters and the evaluation of default arguments as 
part of <code><i>F</i></code>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3641"><a href="3641">3641</a>. Add <code>operator==</code> to <code>format_to_n_result</code></h3>
<p><b>Section:</b> 28.5.1 <a href="https://timsong-cpp.github.io/cppwp/format.syn">[format.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mark de Wever <b>Opened:</b> 2021-11-14 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.syn">active issues</a> in [format.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.syn">issues</a> in [format.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the 2019 Cologne meeting the papers <a href="https://wg21.link/P1614R2" title=" The Mothership Has Landed: Adding <=> to the Library">P1614R2</a> "The Mothership has
Landed" and <a href="https://wg21.link/P0645R10" title=" Text Formatting">P0645R10</a> "Text Formatting" have been accepted. P1614R2 adds
<code>operator==</code> to <code>to_chars_result</code> and <code>from_chars_result</code>. P0645R10 
adds a similar type <code>format_to_n_result</code> <em>without</em> an <code>operator==</code>. 
LWG <a href="3373" title="{to,from}_chars_result and format_to_n_result need the
 &quot;we really mean what we say&quot; wording (Status: C++20)">3373</a> reaffirms these three types are similar by ensuring they can be used in
structured bindings.
<p/>
It seems due to accepting P1614R2 and P0645R10 during the same meeting the addition of 
<code>operator==</code> wasn't applied to <code>format_to_n_result</code>. I propose to add 
<code>operator==</code> to <code>format_to_n_result</code> to keep these types similar.
<p/>
The <code>Out</code> template argument of <code>format_to_n_result</code> is unconstrained. Since
it's returned from <code>format_to_n</code> it's indirectly constrained to an 
<code>output_iterator</code>. An <code>output_iterator</code> doesn't require <code>equality_comparable</code>,
thus the defaulted <code>operator==</code> can be defined deleted.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Several votes for NAD. Unclear why <code>to_chars_result</code> is equality
comparable, but whatever the reason, this is unrelated to them and doesn't
need to be.
</p>



<p id="res-3641"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>

<li><p>Modify 28.5.1 <a href="https://timsong-cpp.github.io/cppwp/format.syn">[format.syn]</a>, header <code>&lt;format&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class Out&gt; struct format_to_n_result {
  Out out;
  iter_difference_t&lt;Out&gt; size;
  <ins>friend bool operator==(const format_to_n_result&amp;, const format_to_n_result&amp;) = default;</ins>
};
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3642"><a href="3642">3642</a>. <code>move_only_function</code> assignment operators seem to be defined suboptimal</h3>
<p><b>Section:</b> 22.10.17.4.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.move.ctor">[func.wrap.move.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alexander Guteniev <b>Opened:</b> 2021-11-20 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.move.ctor">active issues</a> in [func.wrap.move.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.move.ctor">issues</a> in [func.wrap.move.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.10.17.4.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.move.ctor">[func.wrap.move.ctor]</a>/22 and 22.10.17.4.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.move.ctor">[func.wrap.move.ctor]</a>/25 define the effects 
of assignment as following:
</p>
<blockquote>
<pre>
move_only_function&amp; operator=(move_only_function&amp;&amp; f);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to: <code>move_only_function(std::move(f)).swap(*this);</code>
</p>
</blockquote>
[&hellip;]
<pre>
template&lt;class F&gt; move_only_function&amp; operator=(F&amp;&amp; f);
</pre>
<blockquote>
<p>
<i>Effects:</i> Equivalent to: <code>move_only_function(std::forward&lt;F&gt;(f)).swap(*this);</code>
</p>
</blockquote>
</blockquote>
<p>
The assignment via <code>swap</code> with temporary makes the implementation to do the following:
</p>
<ul>
<li><p>move out the previous target to a temporary location</p></li>
<li><p>move in the new target</p></li>
<li><p>finally destroy the previous target.</p></li>
</ul>
<p>
As everything is <code>noexcept</code> here, I think it can be short cut to just:
</p>
<ul>
<li><p>destroy the previous target.</p></li>
<li><p>move in the new target</p></li>
</ul>
<p>
Looks like the implementation cannot do such optimization in a generic case with small functor 
optimization enabled and non-trivial move constructor for the new target and with non-trivial 
destruction of the previous target, since the difference is observable.
<p/>
Apparently the optimization is precluded for no reason.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Some suggestions for NAD, but others disagreed.
</p>



<p id="res-3642"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>

<li><p>Modify 22.10.17.4.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.move.ctor">[func.wrap.move.ctor]</a> as indicated:</p>

<blockquote>
<pre>
move_only_function&amp; operator=(move_only_function&amp;&amp; f);
</pre>
<blockquote>
<p>
-22- <i>Effects:</i> <ins>Sets the target object of <code>this</code> to the target object of <code>f</code> 
before the assignment and leaves <code>f</code> in a valid state with an unspecified value.</ins><del>Equivalent to: <code>move_only_function(std::move(f)).swap(*this);</code></del>
</p>
</blockquote>
[&hellip;]
<pre>
template&lt;class F&gt; move_only_function&amp; operator=(F&amp;&amp; f);
</pre>
<blockquote>
<p>
-25- <i>Effects:</i> Equivalent to: <code><ins>*this = </ins>move_only_function(std::forward&lt;F&gt;(f))<del>.swap(*this)</del>;</code>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3644"><a href="3644">3644</a>. <code>std::format</code> does not define "integer presentation type"</h3>
<p><b>Section:</b> 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Charlie Barto <b>Opened:</b> 2021-11-23 <b>Last modified:</b> 2022-11-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.string.std">active issues</a> in [format.string.std].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.string.std">issues</a> in [format.string.std].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> specifies the behavior of several format specifiers in terms of 
"integer presentation types"; for example 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a>/4 states: 
</p>
<blockquote><p>
"The sign option is only valid for arithmetic types other than <code>charT</code> and <code>bool</code> or 
when an integer presentation type is specified". 
</p></blockquote>
<p>
Unfortunately nowhere does the standard actually define the term "integer presentation type". The 
closest it comes is in 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a>/19 and [tab:format.type.int], but that 
explicitly excludes <code>charT</code> and <code>bool</code>. [tab:format.type.char] and [tab:format.type.bool] 
then refer to [tab:format.type.int].
<p/> 
I can come up with many interpretations for what could happen when <code>'c'</code> is used with <code>charT</code> 
or <code>bool</code>, but the following table is what msvc does right now (throws is the same as does not 
compile after <a href="https://wg21.link/P2216" title=" std::format improvements">P2216</a> in all these cases, although not in general for <code>'c'</code>):
</p>
<blockquote>
<table border="1">
<tr style="text-align:center">
<th>Argument type</th>
<th>Specifiers</th>
<th>Throws?</th>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>#</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>#c</code></td>
<td>No</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>:+</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>+c</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>^</code></td>
<td>No</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>^c</code></td>
<td>No</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>0</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>0c</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>c</code></td>
<td>No</td>
</tr>
<tr>
<td><code>charT</code></td>
<td><code>#</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>charT</code></td>
<td><code>#c</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>charT</code></td>
<td><code>+</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>charT</code></td>
<td><code>+c</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>charT</code></td>
<td><code>^</code></td>
<td>No</td>
</tr>
<tr>
<td><code>charT</code></td>
<td><code>^c</code></td>
<td>No</td>
</tr>
<tr>
<td><code>charT</code></td>
<td><code>0</code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>charT</code></td>
<td><code>0c</code></td>
<td>Yes</td>
</tr>
</table>
</blockquote>
<p>
As you can see we don't interpret <code>'c'</code> as an "integer type specifier", except when <em>explicitly</em> 
specified for <code>bool</code> with <code>#</code>. I think this is because for <code>#</code> the standard states 
</p>
<blockquote><p>
"This option is valid for arithmetic types other than <code>charT</code> and <code>bool</code> or when an integer 
presentation type is specified, <em><u>and not otherwise</u></em>", 
</p></blockquote>
<p>
and [tab:format.type.bool] puts <code>'c'</code> in the same category as all the other "integer type specifiers", 
whereas [tab:format.type.char] separates it out into the char-specific types. If this issue's proposed resolution 
is adopted our behavior would become non-conforming (arguably it already is) and <code>"#c"</code> with <code>bool</code>s 
would become invalid.
</p>

<p><i>[2021-11-29; Tim comments]</i></p>

<p>
This issue touches the same wording area as LWG <a href="3586" title="Formatting character alignment inconsistencies (Status: New)">3586</a> does.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><i>[2021-11-29; Jonathan comments]</i></p>

<p>
LWG <a href="3648" title="format should not print bool with 'c' (Status: C++23)">3648</a> removed 'c' as a valid presentation type for <code>bool</code>.
The last change in the resolution below (and the drafting note) can be dropped.
</p>
<p>
LWG <a href="3586" title="Formatting character alignment inconsistencies (Status: New)">3586</a> could be resolved as part of this issue by using
"this is the default unless formatting a floating-point type or using
an integer presentation type" for '&lt;' and by using
"this is the default when formatting a floating-point type or using
an integer presentation type" for '&gt;'.
</p>



<p id="res-3644"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>

<li><p>Modify 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> as indicated:</p>

<blockquote>
<p>
-6- The <code>#</code> option causes the <i>alternate</i> form to be used for the conversion. This option is <ins>only</ins> 
valid for arithmetic types other than <code>charT</code> and <code>bool</code> or when an integer presentation type 
is specified<del>, and not otherwise</del>. For integral types, the alternate form inserts the base prefix 
(if any) specified in Table 65 into the output after the sign character (possibly space) if there is one, 
or before the output of <code>to_chars</code> otherwise. For floating-point types, the alternate form causes the 
result of the conversion of finite values to always contain a decimal-point character, even if no digits follow it. 
Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. 
In addition, for <code>g</code> and <code>G</code> conversions, trailing zeros are not removed from the result.
</p>
[&hellip;]
<blockquote class="note">
<p>
[<i>Drafting note:</i> This modification is a simple cleanup given the other changes further below, to bring the 
wording for <code>#</code> in line with the wording for the other modifiers, in the interest of preventing confusion.]
</p>
</blockquote>
[&hellip;]
<p>
-16- The <i>type</i> determines how the data should be presented.
<p/>
<ins>-?- An <i>integer presentation type</i> is one of the following type specifiers in Table 
[tab:format.type.integer_presentation], or none, if none is defined to have the same behavior 
as one of the type specifiers in Table [tab:format.type.integer_presentation].</ins>
</p>

<blockquote>
<table border="1">
<caption><ins>Table ? &mdash; Meaning of <i>type</i> options for integer representations [tab:format.type.integer_presentation]</ins></caption>
<tr style="text-align:center">
<th><ins>Type</ins></th>
<th><ins>Meaning</ins></th>
</tr>
<tr>
<td><ins><code>b</code></ins></td>
<td><ins><code>to_chars(first, last, value, 2);</code> the base prefix is <code>0b</code>.</ins></td>
</tr>
<tr>
<td><ins><code>B</code></ins></td>
<td><ins>The same as <code>b</code>, except that the base prefix is <code>0B</code>.</ins></td>
</tr>
<tr>
<td><ins><code>d</code></ins></td>
<td><ins><code>to_chars(first, last, value)</code>.</ins></td>
</tr>
<tr>
<td><ins><code>o</code></ins></td>
<td><ins><code>to_chars(first, last, value, 8)</code>; the base prefix is <code>0</code> if <code>value</code> is nonzero and is empty otherwise.</ins></td>
</tr>
<tr>
<td><ins><code>x</code></ins></td>
<td><ins><code>to_chars(first, last, value, 16)</code>; the base prefix is <code>0x</code>.</ins></td>
</tr>
<tr>
<td><ins><code>X</code></ins></td>
<td><ins>The same as <code>x</code>, except that it uses uppercase letters for digits above <code>9</code> and 
the base prefix is <code>0X</code>.</ins></td>
</tr>
</table>
</blockquote>

<blockquote class="note">
<p>
[<i>Drafting note:</i> This is the same as [tab:format.type.int] with "none" and <code>'c'</code> removed]
</p>
</blockquote>

<p>
-17- The available string presentation types are specified in Table 64 ([tab:format.type.string]).
</p>
[&hellip;]
<blockquote>
<table border="1">
<caption>Table 65 &mdash; Meaning of <i>type</i> options for integer types [tab:format.type.int]</caption>
<tr style="text-align:center">
<th>Type</th>
<th>Meaning</th>
</tr>
<tr>
<td><code>b</code><ins>, <code>B</code>, <code>d</code>, <code>o</code>, <code>x</code>, <code>X</code></ins></td>
<td><ins>As specified in Table [tab:format.type.integer_presentation]</ins><del><code>to_chars(first, last, value, 2);</code> the base prefix is <code>0b</code></del>.</td>
</tr>
<tr>
<td><del><code>B</code></del></td>
<td><del>The same as <code>b</code>, except that the base prefix is <code>0B</code>.</del></td>
</tr>
<tr>
<td><code>c</code></td>
<td>Copies the character <code>static_cast&lt;charT&gt;(value)</code> to the output. Throws <code>format_error</code> if <code>value</code> is not in the range of representable values for <code>charT</code>.</td>
</tr>
<tr>
<td><del><code>d</code></del></td>
<td><del><code>to_chars(first, last, value)</code>.</del></td>
</tr>
<tr>
<td><del><code>o</code></del></td>
<td><del><code>to_chars(first, last, value, 8)</code>; the base prefix is <code>0</code> if <code>value</code> is nonzero and is empty otherwise.</del></td>
</tr>
<tr>
<td><del><code>x</code></del></td>
<td><del><code>to_chars(first, last, value, 16)</code>; the base prefix is <code>0x</code>.</del></td>
</tr>
<tr>
<td><del><code>X</code></del></td>
<td><del>The same as <code>x</code>, except that it uses uppercase letters for digits above <code>9</code> and 
the base prefix is <code>0X</code>.</del></td>
</tr>
<tr>
<td>none</td>
<td>The same as <code>d</code>.
<del>[<i>Note 8</i>: If the formatting argument type is <code>charT</code> or <code>bool</code>, the default is instead <code>c</code> or <code>s</code>,
respectively. &mdash; <i>end note</i>]</del></td>
</tr>
</table>
</blockquote>
<blockquote>
<table border="1">
<caption>Table 66 &mdash; Meaning of <i>type</i> options for <code>charT</code> [tab:format.type.char]</caption>
<tr style="text-align:center">
<th>Type</th>
<th>Meaning</th>
</tr>
<tr>
<td>none, <code>c</code></td>
<td>Copies the character to the output.</td>
</tr>
<tr>
<td><code>b</code>, <code>B</code>, <code>d</code>, <code>o</code>, <code>x</code>, <code>X</code></td>
<td>As specified in Table <del>[tab:format.type.int]</del><ins>[tab:format.type.integer_presentation]</ins>.</td>
</tr>
</table>
</blockquote>
<blockquote>
<table border="1">
<caption>Table 67 &mdash; Meaning of <i>type</i> options for <code>bool</code> [tab:format.type.bool]</caption>
<tr style="text-align:center">
<th>Type</th>
<th>Meaning</th>
</tr>
<tr>
<td>none, <code>s</code></td>
<td>Copies textual representation, either <code>true</code> or <code>false</code>, to the output.</td>
</tr>
<tr>
<td><code>b</code>, <code>B</code>, <del><code>c</code>,</del> <code>d</code>, <code>o</code>, <code>x</code>, <code>X</code></td>
<td>As specified in Table <del>[tab:format.type.int]</del><ins>[tab:format.type.integer_presentation]</ins> for the value 
<code>static_cast&lt;unsigned char&gt;(value)</code>.</td>
</tr>
<tr>
<td><ins><code>c</code></ins></td>
<td><ins>Copies the character <code>static_cast&lt;unsigned char&gt;(value)</code> to the output.</ins></td>
</tr>
</table>
</blockquote>

<blockquote class="note">
<p>
[<i>Drafting note:</i> allowing the <code>'c'</code> specifier for <code>bool</code> is pretty bizarre behavior, 
but that's very clearly what the standard says now, so I'm preserving it. I would suggest keeping discussion 
of changing that behavior to a separate issue or defect report (the reworking of the tables in this issue makes 
addressing that easier anyway).
<p/>
The inconsistency with respect to using <code>static_cast&lt;unsigned char&gt;</code> here and 
<code>static_cast&lt;charT&gt;</code> in [tab:format.type.int] is pre-existing and should be addressed 
in a separate issue if needed.
]
</p>
</blockquote>

</blockquote>
</li>

</ol>





<hr>
<h3 id="3647"><a href="3647">3647</a>. <code><i>nothrow-input-iterator</i></code> constraints should not mention copying</h3>
<p><b>Section:</b> 26.11.2 <a href="https://timsong-cpp.github.io/cppwp/special.mem.concepts">[special.mem.concepts]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Konstantin Varlamov <b>Opened:</b> 2021-11-30 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.11.2 <a href="https://timsong-cpp.github.io/cppwp/special.mem.concepts">[special.mem.concepts]</a> states that a type qualifies as a <code><i>nothrow-input-iterator</i></code> 
only if no exceptions are thrown from, among other things, <em>copy</em> construction and <em>copy</em> 
assignment. However, being copyable isn't part of the requirements for an <code>input_iterator</code> on which 
<code><i>nothrow-input-iterator</i></code> is based (indeed, one of the things <code>forward_iterator</code> 
adds to <code>input_iterator</code> is copyability), and the <code><i>nothrow-input-iterator</i></code> concept 
doesn't add any new constraints related to copyability.
</p>

<p><i>[2021-12-19; Daniel comments]</i></p>

<p>
During LWG discussion of the issue one argument brought forward against the proposed wording was that it 
might be incomplete, because it doesn't adjust the <code><i>nothrow-forward-iterator</i></code> concept, 
which adds among other things the <code>copyable</code> requirements. But 
<code><i>nothrow-forward-iterator</i></code> also requires <code><i>nothrow-sentinel-for</i>&lt;I, I&gt;</code>, 
which already extends this necessary no-throw requirement for copy operations by p. 4:
</p>
<blockquote>
<p>
Types <code>S</code> and <code>I</code> model <code><i>nothrow-sentinel-for</i></code> only if no exceptions are thrown 
from copy construction, move construction, copy assignment, move assignment, or comparisons between valid 
values of type <code>I</code> and <code>S</code>.
</p>
</blockquote>
<p>
It should also be emphasized that the definitions of move construction (3.34 <a href="https://timsong-cpp.github.io/cppwp/defns.move.constr">[defns.move.constr]</a>) and
move assignment (3.33 <a href="https://timsong-cpp.github.io/cppwp/defns.move.assign">[defns.move.assign]</a>) are compatible even for copyable input iterator types, 
because these definitions refer just to expression conditions, and not to concrete operator overloads. So as long
as an implementation applies these expression conditions, we are safe.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3647"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>

<li><p>Modify 26.11.2 <a href="https://timsong-cpp.github.io/cppwp/special.mem.concepts">[special.mem.concepts]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class I&gt;
concept <i>nothrow-input-iterator</i> = <i>// exposition only</i>
  input_iterator&lt;I&gt; &amp;&amp;
  is_lvalue_reference_v&lt;iter_reference_t&lt;I&gt;&gt; &amp;&amp;
  same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;, iter_value_t&lt;I&gt;&gt;;
</pre>
<blockquote>
<p>
-2- A type <code>I</code> models <code><i>nothrow-input-iterator</i></code> only if no exceptions are thrown 
from increment, <del>copy construction,</del> move construction, <del>copy assignment,</del> move assignment, 
or indirection through valid iterators.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3651"><a href="3651">3651</a>. Unspecified lifetime guarantees for the format string</h3>
<p><b>Section:</b> 28.5 <a href="https://timsong-cpp.github.io/cppwp/format">[format]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2021-12-08 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format">active issues</a> in [format].</p>
<p><b>View all other</b> <a href="lwg-index.html#format">issues</a> in [format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is this program guaranteed to be valid:
</p>
<blockquote><pre>
#include &lt;format&gt;
#include &lt;algorithm&gt;

struct Thing { };

template &lt;>
struct std::formatter&lt;Thing> {
  std::string_view spec;

  constexpr auto parse(std::format_parse_context&amp; ctx) {
    auto end = std::find(ctx.begin(), ctx.end(), '}');
    spec = std::string_view(ctx.begin(), end);
    return end;
  }

  auto format(Thing, std::format_context&amp; ctx) {
    return std::ranges::copy(spec, ctx.out()).out;
  }
};

int main() {
  std::print("{:lwg issue}\n",  Thing{});
}
</pre></blockquote>
<p>
In <code>parse()</code>, the formatter for <code>Thing</code> holds onto a string view of its specifiers. 
And then in <code>format()</code>, it just prints them. I don't think we say anywhere that this works. 
Does this code print <code>"lwg issue"</code> because there's no issue or does it print some garbage 
memory somewhere because there is one?
<p/>
libfmt's implementation internally stores <code>string_view</code>'s into the format string (for named 
argument support), which implies that it should work. But it'd be nice to come out and say that.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
<br/>
"Presumably we need to say in [formatter.requirements] that
[<code>pc.begin()</code>, <code>pc.end()</code>)
is guaranteed to be a valid range until the
next call to <code>parse()</code> or <code>f</code> is destroyed,
whichever comes first."
</p>



<p id="res-3651"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3653"><a href="3653">3653</a>. <code>&lt;coroutine&gt;</code> is freestanding, but uses <code>std::hash</code> which is not</h3>
<p><b>Section:</b> 17.13.2 <a href="https://timsong-cpp.github.io/cppwp/coroutine.syn">[coroutine.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2021-12-17 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#coroutine.syn">issues</a> in [coroutine.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>&lt;coroutine&gt;</code> header is required for freestanding implementations, but it defines a 
specialization of <code>std::hash</code>, which is not required for freestanding implementations.
<p/>
Presumably we should make the <code>std::hash</code> specialization conditionally present.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Would be resolved by <a href="https://wg21.link/P1642" title=" Freestanding Library: Easy [utilities], [ranges], and [iterators]">P1642</a> for C++23,
but it's still a defect in C++20.
</p>



<p id="res-3653"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3658"><a href="3658">3658</a>. <code>basic_streambuf::sputn</code> is both overspecified and underspecified</h3>
<p><b>Section:</b> 31.6.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/streambuf.pub.put">[streambuf.pub.put]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2022-01-17 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification for <code>basic_streambuf::sputn</code> is:
</p>
<blockquote><p>
<i>Returns:</i> <code>xsputn(s, n)</code>.
</p></blockquote>
<p>
One interpretation of this implies that <code>sputn</code> can't insert characters directly into the 
put area if there is space for them, it has to make a virtual call. That has significant overhead 
for repeated calls, such as inserting many small strings/string_views in a loop.
<p/>
But another interpretation is that it doesn't use "<i>Effects:</i> Equivalent to" or anything like 
that, so doesn't say an actual call to <code>xsputn</code> happens. Strictly speaking, it only says it 
returns the value that <code>xsputn</code> would return, and doesn't even have to produce any of its effects!
<p/>
We should describe the effects, not the return value, and we should do so in a way that does not 
overconstrain the implementation. It should not be necessary to make a virtual call to <code>xsputn</code> 
if the put area has capacity for the characters. On the other hand, if it doesn't have capacity, then 
calling <code>xsputn</code> is the best option; it allows the derived <code>streambuf</code> to decide how 
best to handle large writes.
<p/>
The proposed resolution replaces the <i>Returns:</i> element with an <i>Effects:</i> element, so that 
we specify that those effects actually occur. A normative remark is added to give the implementation 
leeway to avoid the virtual call when it isn't needed.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Jonathan to revise P/R to also cover <code>sgetn</code>.
</p>



<p id="res-3658"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>. 
</p>

<ol>
<li><p>Modify 31.6.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/streambuf.pub.put">[streambuf.pub.put]</a> as indicated:</p>

<blockquote>
<pre>
streamsize sputn(const char_type* s, streamsize n);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <code>[s, s+n)</code> is a valid range.</ins>
<p/>
<ins>-?- <i>Effects:</i> <code>return xsputn(s, n)</code>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> When <code>(epptr() - pptr()) &gt;= n</code>, it is unspecified whether the characters 
are written directly to the output sequence without calling <code>xsputn</code>.</ins>
<p/>
<del>-2- <i>Returns:</i> <code>xsputn(s, n)</code>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3662"><a href="3662">3662</a>. <code>basic_string::append/assign(NTBS, pos, n)</code> suboptimal</h3>
<p><b>Section:</b> 27.4.3.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a>, 27.4.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2022-01-21 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.append">issues</a> in [string.append].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This will allocate temporary string, then copy one byte from it:
</p>
<blockquote>
<pre>
std::string s;
s.append("a very very long string that doesn't fit in SSO buffer", 13, 1);
</pre>
</blockquote>
<p>
The problem is that there is no overload accepting an NTBS there, so it converts to a temporary string using:
</p>
<blockquote><pre>
append(const basic_string&amp;, size_t, size_t = npos);
</pre></blockquote>
<p>
C++17 added a new overload for a <code>string_view</code>:
</p>
<blockquote><pre>
append(const T&amp;, size_t, size_t = npos);
</pre></blockquote>
<p>
But that overload is constrained to not allow <code>const char*</code> arguments, so we still create a temporary string.
<p/>
If we're going to accept those arguments, we should do so efficiently, without forcing an unnecessary allocation.
<p/>
We could do better if we split the <code>append(const T&amp;, ...)</code> overload into:
</p>
<blockquote><pre>
append(const T&amp;, size_t);
append(const T&amp;, size_t, size_t);
</pre></blockquote>
<p>
and then remove the <code>!is_convertible_v&lt;const T&amp;, const charT*&gt;</code> constraint from the second 
overload (<b>Option A</b> in the proposed resolution).
<p/>
Alternatively, we can leave the <code>append(const T&amp;, size_t, size_t)</code> overload alone and just add one 
taking exactly the arguments used above. That seems simpler to me, and I prefer that (<b>Option B</b> in the Proposed Resolution).
<p/>
The same problem applies to <code>assign("...", pos, n)</code>.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3662"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>. 
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b>
</p>

<ol>
<li><p>Modify 27.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/basic.string.general">[basic.string.general]</a>, class template <code>basic_string</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 27.4.3.7 <a href="https://timsong-cpp.github.io/cppwp/string.modifiers">[string.modifiers]</a>, modifiers</i>
[&hellip;]
template&lt;class T&gt;
  constexpr basic_string&amp; append(const T&amp; t);
<ins>template&lt;class T&gt;
  constexpr basic_string&amp; append(const T&amp; t, size_type pos);</ins>
template&lt;class T&gt;
  constexpr basic_string&amp; append(const T&amp; t, size_type pos, size_type n <del>= npos</del>);
constexpr basic_string&amp; append(const charT* s, size_type n);
[&hellip;]
template&lt;class T&gt;
  constexpr basic_string&amp; assign(const T&amp; t);
<ins>template&lt;class T&gt;
  constexpr basic_string&amp; assign(const T&amp; t, size_type pos);</ins>
template&lt;class T&gt;
  constexpr basic_string&amp; assign(const T&amp; t, size_type pos, size_type n <del>= npos</del>);
constexpr basic_string&amp; assign(const charT* s, size_type n);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 27.4.3.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr basic_string&amp; append(const T&amp; t);
</pre>
<blockquote>
<p>
-3- <i>Constraints:</i>
</p>
<ol style="list-style-type:none">
<li><p>(3.1) &mdash; <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> and</p></li>
<li><p>(3.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code>.</p></li>
</ol>
<p>
-4- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
basic_string_view&lt;charT, traits&gt; sv = t;
return append(sv.data(), sv.size());
</pre></blockquote>
</blockquote>
<pre>
<ins>template&lt;class T&gt;
  constexpr basic_string&amp; append(const T&amp; t, size_type pos);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i></ins>
</p>
<ol style="list-style-type:none">
<li><p><ins>(?.1) &mdash; <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> and</ins></p></li>
<li><p><ins>(?.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code>.</ins></p></li>
</ol>
<p>
<ins>-?- <i>Effects:</i> Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>basic_string_view&lt;charT, traits&gt; sv = t;
return append(sv.substr(pos));</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T&gt;
  constexpr basic_string&amp; append(const T&amp; t, size_type pos, size_type n <del>= npos</del>);
</pre>
<blockquote>
<p>
-5- <i>Constraints:</i>
</p>
<ol style="list-style-type:none">
<li><p><del>(5.1) &mdash;</del> <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> <del>and</del></p></li>
<li><p><del>(5.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code></del>.</p></li>
</ol>
<p>
-6- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
basic_string_view&lt;charT, traits&gt; sv = t;
return append(sv.substr(pos, n));
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.4.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr basic_string&amp; assign(const T&amp; t);
</pre>
<blockquote>
<p>
-4- <i>Constraints:</i>
</p>
<ol style="list-style-type:none">
<li><p>(4.1) &mdash; <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> and</p></li>
<li><p>(4.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code>.</p></li>
</ol>
<p>
-5- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
basic_string_view&lt;charT, traits&gt; sv = t;
return assign(sv.data(), sv.size());
</pre></blockquote>
</blockquote>
<pre>
<ins>template&lt;class T&gt;
  constexpr basic_string&amp; assign(const T&amp; t, size_type pos);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints:</i></ins>
</p>
<ol style="list-style-type:none">
<li><p><ins>(?.1) &mdash; <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> and</ins></p></li>
<li><p><ins>(?.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code>.</ins></p></li>
</ol>
<p>
<ins>-?- <i>Effects:</i> Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>basic_string_view&lt;charT, traits&gt; sv = t;
return assign(sv.substr(pos));</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T&gt;
  constexpr basic_string&amp; assign(const T&amp; t, size_type pos, size_type n <del>= npos</del>);
</pre>
<blockquote>
<p>
-6- <i>Constraints:</i>
</p>
<ol style="list-style-type:none">
<li><p><del>(6.1) &mdash;</del> <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> <del>and</del></p></li>
<li><p><del>(6.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code></del>.</p></li>
</ol>
<p>
-7- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
basic_string_view&lt;charT, traits&gt; sv = t;
return assign(sv.substr(pos, n));
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>

<p>
<b>Option B:</b>
</p>

<ol>
<li><p>Modify 27.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/basic.string.general">[basic.string.general]</a>, class template <code>basic_string</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 27.4.3.7 <a href="https://timsong-cpp.github.io/cppwp/string.modifiers">[string.modifiers]</a>, modifiers</i>
[&hellip;]
constexpr basic_string&amp; append(const charT* s, size_type n);
constexpr basic_string&amp; append(const charT* s);
<ins>constexpr basic_string&amp; append(const charT* s, size_type pos, size_type n);</ins>
constexpr basic_string&amp; append(size_type n, charT c);
[&hellip;]
constexpr basic_string&amp; assign(const charT* s, size_type n);
constexpr basic_string&amp; assign(const charT* s);
<ins>constexpr basic_string&amp; assign(const charT* s, size_type pos, size_type n);</ins>
constexpr basic_string&amp; assign(size_type n, charT c);
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 27.4.3.7.2 <a href="https://timsong-cpp.github.io/cppwp/string.append">[string.append]</a> as indicated:</p>

<blockquote>
<pre>
constexpr basic_string&amp; append(const charT* s, size_type n);
</pre>
<blockquote>
<p>
-7- <i>Preconditions:</i> <code>[s, s + n)</code> is a valid range.
<p/>
-8- <i>Effects:</i> Appends a copy of the range <code>[s, s + n)</code> to the string.
<p/>
-9- <i>Returns:</i> <code>*this</code>.
</p>
</blockquote>
<pre>
constexpr basic_string&amp; append(const charT* s);
</pre>
<blockquote>
<p>
-10- <i>Effects:</i> Equivalent to: <code>return append(s, traits::length(s));</code>
</p>
</blockquote>
<pre>
<ins>constexpr basic_string&amp; append(const charT* s, size_type pos, size_type n);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Equivalent to: <code>return append(basic_string_view&lt;charT, traits&gt;(s).substr(pos, n));</code></ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.4.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr basic_string&amp; assign(const charT* s, size_type n);
</pre>
<blockquote>
<p>
-8- <i>Preconditions:</i> <code>[s, s + n)</code> is a valid range.
<p/>
-9- <i>Effects:</i> Replaces the string controlled by <code>*this</code> with a copy of the range <code>[s, s + n)</code>.
<p/>
-10- <i>Returns:</i> <code>*this</code>.
</p>
</blockquote>
<pre>
constexpr basic_string&amp; assign(const charT* s);
</pre>
<blockquote>
<p>
-11- <i>Effects:</i> Equivalent to: <code>return assign(s, traits::length(s));</code>
</p>
</blockquote>
<pre>
<ins>constexpr basic_string&amp; assign(const charT* s, size_type pos, size_type n);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Equivalent to: <code>return assign(basic_string_view&lt;charT, traits&gt;(s).substr(pos, n));</code></ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3663"><a href="3663">3663</a>. <code>basic_string(const T&amp;, const Alloc&amp;)</code> turns moves into copies</h3>
<p><b>Section:</b> 27.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a>, 27.4.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2022-01-21 <b>Last modified:</b> 2022-01-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This will do a copy not a move:
</p>
<blockquote>
<pre>
struct Str : std::string {
  Str() = default;
  Str(Str&amp;&amp; s) : std::string(std::move(s)) { }
};
Str s;
Str s2(std::move(s));
</pre>
</blockquote>
<p>
The problem is that the new C++17 constructor:
</p>
<blockquote><pre>
basic_string(const T&amp;, const Alloc&amp; = Alloc());
</pre></blockquote>
<p>
is an exact match, but the <code>basic_string</code> move constructor requires a derived-to-base conversion.
<p/>
This is a regression since C++14, because the move constructor was called in C++14.
<p/>
This problem also exists for <code>assign(const T&amp;)</code> and <code>operator=(const T&amp;)</code>.
<p/>
We can fix this by constraining those functions with <code>!derived_from&lt;T, basic_string&gt;</code>, so 
that the move constructor is the only viable function. Libstdc++ has done something very similar since 
2017, but using <code>!is_convertible&lt;const T*, const basic_string*&gt;</code> instead of <code>derived_from</code>.
</p>

<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Jonathan to revise P/R to use <code>is_base_of</code> or
<code>is_convertible</code> instead of <code>derived_from</code>.
</p>



<p id="res-3663"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>. 
</p>

<ol>
<li><p>Modify 27.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/string.cons">[string.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr explicit basic_string(const T&amp; t, const Allocator&amp; a = Allocator());
</pre>
<blockquote>
<p>
-7- <i>Constraints:</i>
</p>
<ol style="list-style-type:none">
<li><p>(7.1) &mdash; <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> and</p></li>
<li><p><ins>(7.?) &mdash; <code>derived_from&lt;T, basic_string&gt;</code> is <code>false</code> and</ins></p></li>
<li><p>(7.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code>.</p></li>
</ol>
<p>
-8- <i>Effects:</i> Creates a variable, <code>sv</code>, as if by <code>basic_string_view&lt;charT, traits&gt; sv = t;</code> 
and then behaves the same as <code>basic_string(sv.data(), sv.size(), a)</code>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template&lt;class T&gt;
  constexpr basic_string&amp; operator=(const T&amp; t);
</pre>
<blockquote>
<p>
-27- <i>Constraints:</i>
</p>
<ol style="list-style-type:none">
<li><p>(27.1) &mdash; <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> and</p></li>
<li><p><ins>(27.?) &mdash; <code>derived_from&lt;T, basic_string&gt;</code> is <code>false</code> and</ins></p></li>
<li><p>(27.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code>.</p></li>
</ol>
<p>
-28- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
basic_string_view&lt;charT, traits&gt; sv = t;
return assign(sv);
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.4.3.7.3 <a href="https://timsong-cpp.github.io/cppwp/string.assign">[string.assign]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr basic_string&amp; assign(const T&amp; t);
</pre>
<blockquote>
<p>
-4- <i>Constraints:</i>
</p>
<ol style="list-style-type:none">
<li><p>(4.1) &mdash; <code>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</code> 
is <code>true</code> and</p></li>
<li><p><ins>(4.?) &mdash; <code>derived_from&lt;T, basic_string&gt;</code> is <code>false</code> and</ins></p></li>
<li><p>(4.2) &mdash; <code>is_convertible_v&lt;const T&amp;, const charT*&gt;</code> is <code>false</code>.</p></li>
</ol>
<p>
-5- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
basic_string_view&lt;charT, traits&gt; sv = t;
return assign(sv.data(), sv.size());
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3665"><a href="3665">3665</a>. Is <code>std::allocator_traits&lt;Alloc&gt;::rebind_alloc</code> SFINAE-friendly?</h3>
<p><b>Section:</b> 20.2.9.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.types">[allocator.traits.types]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-01-24 <b>Last modified:</b> 2022-03-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.traits.types">issues</a> in [allocator.traits.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.2.9.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.types">[allocator.traits.types]</a>/11 says that the instantiation of <code>rebind_alloc</code> is 
sometimes ill-formed, however, it's unclear such ill-formedness results in substitution failure or hard error.
It seems that current implementations (libc++, libstd++, MSVC STL) give substitution errors, and 
we should reword 20.2.9.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.types">[allocator.traits.types]</a>/11 with "<i>Constraints:</i>".
</p>

<p><i>[2022-01-29; Daniel comments]</i></p>

<p>
This issue has some overlap with LWG <a href="3545" title="std::pointer_traits should be SFINAE-friendly (Status: C++23)">3545</a> in regard to the question how we should handle
the <code>rebind</code> member template of the <code>pointer_traits</code> primary template as specified by 
20.2.3.2 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.types">[pointer.traits.types]</a> p3. It would seem preferable to decide for the same approach in both 
cases.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Probably NAD, since [allocator.requirements.general]/11 allows any allocator
instantiation to fail with a hard error outside the immediate context,
making it impossible to guarantee a SFINAE-friendly result.
Also unclear what motivation there is for it being SFINAE friendly.
</p>



<p id="res-3665"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3666"><a href="3666">3666</a>. <code>join_view</code>'s difference type is too small</h3>
<p><b>Section:</b> 25.7.14 <a href="https://timsong-cpp.github.io/cppwp/range.join">[range.join]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2022-01-30 <b>Last modified:</b> 2022-03-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join">issues</a> in [range.join].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Despite the fact that <code>join_view</code> may produce more elements than each joined view(s) 
contains, we require implementations to use the <code>common_type</code> of their difference types 
(per 25.7.14.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a> p3), which may lead to UB. As we already have provided 
implementation freedom to define extended integer-like types we should make provision for them 
to be used here as well. The same issue applies to the <code>join_with_view</code> as proposed by
<a href="https://wg21.link/P2441" title=" views::join_with">P2441</a>.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
Might be a design issue.
</p>



<p id="res-3666"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3668"><a href="3668">3668</a>. <code>[recursive_]directory_iterator</code> constructors refer to undefined <code>options</code></h3>
<p><b>Section:</b> 31.12.11.2 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a>, 31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2022-01-31 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.dir.itr.members">issues</a> in [fs.dir.itr.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
31.12.11.2 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a> p2 and 31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> p3 refer to the <code>options</code> 
parameter, but not all overloads have a parameter of that name.
<p/>
We need some "for the overloads with &hellip;" wording.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2022-12-18; Daniel comments and provides wording]</i></p>

<p>
It seems to me that we should differentiate the problems of <code>directory_iterator</code> and 
<code>recursive_directory_iterator</code> regarding the constructors that don't provide any <code>options</code> arguments
at least from a logical point of view:
<p/>
From the existing <i>Postconditions:</i> element of <code>recursive_directory_iterator</code> we can at least
guess that the intention of the existing wording is that these suppose to reflect that the effective options within 
the <i>Effects:</i> element are also equal to <code>directory_options::none</code>. 
But for <code>directory_iterator</code> we don't have any options "getter" nor <i>Postconditions</i> from deducing 
the intent. 
<p/>
Fortunately, existing implementations (I looked at the current V2 2022 library and libstdc++ implementation) 
seem to behave already as if <code>directory_options::none</code> is set for the affected constructors for both 
iterator types.
<p/>
Note that this issue here has some wording overlap with the the proposed wording of LWG <a href="2708" title="recursive_directory_iterator::recursion_pending() is incorrectly specified (Status: Open)">2708</a>,
I'm therefore using the exact wording form currently suggested there. If LWG would like to change this form (e.g.
by using the word "overload" instead of "signature") this should also be done in that other issue to reduce possible
merge conflicts. Note that the here suggested form using "signature" <em>has</em> existing practice in other places
of Clause 31.12 <a href="https://timsong-cpp.github.io/cppwp/filesystems">[filesystems]</a>, so I recommend keeping that form.
</p>


<p id="res-3668"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 31.12.11.2 <a href="https://timsong-cpp.github.io/cppwp/fs.dir.itr.members">[fs.dir.itr.members]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i><br/>
(1) The proposed wording form takes care to use the same wording form used in LWG <a href="2708" title="recursive_directory_iterator::recursion_pending() is incorrectly specified (Status: Open)">2708</a> 
for <code>recursive_directory_iterator</code> at the time of writing.<br/>
(2) We don't need similar wording for the default constructor because this creates
an end iterator and there exist no way for the user to observe the effects of
<code>directory_options</code> for such an iterator value.
]
</p>
</blockquote>

<blockquote>
<pre>
directory_iterator() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Constructs the end iterator.
</p>
</blockquote>
<pre>
explicit directory_iterator(const path&amp; p);
directory_iterator(const path&amp; p, directory_options options);
directory_iterator(const path&amp; p, error_code&amp; ec);
directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec);
</pre>
<blockquote>
<p>
<ins>-?- For the signatures with no parameter <code>options</code>, let <code>options</code> be
<code>directory_options::none</code>.</ins>
<p/>
-2- <i>Effects</i>: For the directory that <code>p</code> resolves to, constructs an iterator for the first element in a sequence of
<code>directory_entry</code> elements representing the files in the directory, if any; otherwise the end iterator.
However, if
</p>
<blockquote><pre>
(options &amp; directory_options::skip_permission_denied) != directory_options::none
</pre></blockquote>
<p>
and construction encounters an error indicating that permission to access <code>p</code> is denied, constructs the
end iterator and does not report an error.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 31.12.12.2 <a href="https://timsong-cpp.github.io/cppwp/fs.rec.dir.itr.members">[fs.rec.dir.itr.members]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i><br/>
(1) The proposed wording form takes care to be in sync with the wording form
used in LWG <a href="2708" title="recursive_directory_iterator::recursion_pending() is incorrectly specified (Status: Open)">2708</a> at the time of writing. This issue here doesn't
touch the wording for the <code>options</code> function though, and leaves any changes 
to LWG <a href="2708" title="recursive_directory_iterator::recursion_pending() is incorrectly specified (Status: Open)">2708</a>, because these changes don't seem essential to solve
the issue here.<br/>
(2) We don't need similar wording for the default constructor because this creates
an end iterator and from 31.12.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.class.rec.dir.itr.general">[fs.class.rec.dir.itr.general]</a> p2 we can
conclude that user code has no way to determine the effective <code>directory_options</code> value
of this iterator value (interestingly p15 quoted below can be read to apply here as well,
but 31.12.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.class.rec.dir.itr.general">[fs.class.rec.dir.itr.general]</a> p2 seems to be very prohibitive and
LWG <a href="2708" title="recursive_directory_iterator::recursion_pending() is incorrectly specified (Status: Open)">2708</a> is going to solve this special case as well).<br/>
(3) We easily simplify the wording of p3 as shown below, because the "scope" of the
introductory new paragraph includes the <i>Postconditions:</i> element. But similar to
the arguments provided in (1) we don't wish to introduce merge conflicts with the 
LWG <a href="2708" title="recursive_directory_iterator::recursion_pending() is incorrectly specified (Status: Open)">2708</a> wording and therefore intentionally leave any changes of p3 to
that issue.
]
</p>
</blockquote>

<blockquote>
<pre>
recursive_directory_iterator() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Constructs the end iterator.
</p>
</blockquote>
<pre>
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec);
recursive_directory_iterator(const path&amp; p, error_code&amp; ec);
</pre>
<blockquote>
<p>
<ins>-?- For the signatures with no parameter <code>options</code>, let <code>options</code> be
<code>directory_options::none</code>.</ins>
<p/>
-2- <i>Effects</i>: Constructs an iterator representing the first entry in the directory to which 
<code>p</code> resolves, if any; otherwise, the end iterator.
However, if
</p>
<blockquote><pre>
(options &amp; directory_options::skip_permission_denied) != directory_options::none
</pre></blockquote>
<p>
and construction encounters an error indicating that permission to access <code>p</code> is denied, constructs the
end iterator and does not report an error.
<p/>
-3- <i>Postconditions</i>: <code>options() == options</code> for the signatures with a <code>directory_options</code> argument,
otherwise <code>options() == directory_options::none</code>.
<p/>
[&hellip;]
</p>
</blockquote>
[&hellip;]
<pre>
directory_options options() const;
</pre>
<blockquote>
<p>
-15- <i>Returns</i>: The value of the argument passed to the constructor for the <code>options</code> parameter, if present,
otherwise <code>directory_options::none</code>.
<p/>
-16- <i>Throws</i>: Nothing.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3669"><a href="3669">3669</a>. <code>std::filesystem</code> operations should be observable behaviour</h3>
<p><b>Section:</b> 4.1.2 <a href="https://timsong-cpp.github.io/cppwp/intro.abstract">[intro.abstract]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2022-02-03 <b>Last modified:</b> 2022-03-04</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
4.1.2 <a href="https://timsong-cpp.github.io/cppwp/intro.abstract">[intro.abstract]</a> p6.2 should be amended to say that
<code>filesystem</code> operations such as <code>mkdir</code> are observable behaviour.
Any resolution would need CWG review.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3669"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3674"><a href="3674">3674</a>. Removal of requirement for locale names for construction of locales not explained</h3>
<p><b>Section:</b> 28.3.3.1.4 <a href="https://timsong-cpp.github.io/cppwp/locale.members">[locale.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2022-02-12 <b>Last modified:</b> 2022-03-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.members">issues</a> in [locale.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2394" title="locale::name specification unclear &mdash; what is implementation-defined? (Status: C++17)">2394</a> removed the only text in the wording that requires that the name of a locale 
is usable for constructing further locales.
<p/>
The relevant <a href="https://wiki.edg.com/bin/view/LWGChicago2016/ThursdayAfternoon">notes from the wiki</a> 
appear to make it seem like LWG thought the change was editorial.
<p/>
Perhaps the resolution was motivated by a different defect than the one that led to the change?
<p/>
Namely,
</p>
<blockquote><pre>
explicit locale(const char* std_name);
</pre></blockquote>
<p>
is said to use "standard C locale names".
<p/>
There is no <code>LC_MESSAGES</code> in standard C.
<p/>
Thus, it is a question whether the aforementioned constructor should be able to consume names produced by the 
C++ implementation.
<p/>
See also the use of the name of the C++ locale in <code>locale::global()</code> for use with <code>setlocale</code>.
<p/>
The following would restore the equivalence of locales that have the same name. It also addresses the 
suitability of the name for use with <code>setlocale</code> and the <code>locale(const char*)</code> constructor 
as a matter of QoI.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p id="res-3674"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>
<li><p>Modify 28.3.3.1.4 <a href="https://timsong-cpp.github.io/cppwp/locale.members">[locale.members]</a> as indicated:</p>

<blockquote>
<pre>
string name() const;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> The name of <code>*this</code>, if it has one; otherwise, the string <code>"*"</code>.
<p/>
<ins>-?- <i>Remarks:</i> Two locales have identical names only if their facets have identical 
virtual function semantics.</ins>
<p/>
<ins>-?- <i>Recommended practice:</i> The name of a locale that has a name should be such that 
<code>setlocale(LC_ALL, name().c_str())</code> returns a non-null pointer. [<i>Note 1:</i> With such a name 
<code>locale(name().c_str())</code> succeeds and does not throw <code>runtime_error</code>. &mdash; <i>end note</i>]
</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3675"><a href="3675">3675</a>. <code>std::ios_base::iword/pword</code> might be misspecified</h3>
<p><b>Section:</b> 31.5.2.6 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-02-14 <b>Last modified:</b> 2022-03-04</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently 31.5.2.6 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a> p5 and p8 say "On failure, a valid <code>long&amp;/void*&amp;</code> 
initialized to <code>0</code>". Such wording seems wrong, because a <code>long&amp;/void*&amp;</code> variable or 
return value can't be initialized with <code>0</code>. And the values of referenced objects may be underspecified, 
because an implementation may reuse the same <code>long/void*</code> objects on failure, and thus it's insufficient 
to specify the initial values of these objects only.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3675"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>
<li><p>Modify 31.5.2.6 <a href="https://timsong-cpp.github.io/cppwp/ios.base.storage">[ios.base.storage]</a> as indicated:</p>

<blockquote>
<pre>
long&amp; iword(int idx);
</pre>
<blockquote>
<p>
-3- [&hellip;]
<p/>
-4- [&hellip;]
<p/>
-5- <i>Returns:</i> On success <code>iarray[idx]</code>. On failure, a<ins>n</ins> <del>valid</del> <ins>lvalue of type</ins> 
<code>long<del>&amp;</del></code> <ins>with value <code>0L</code></ins><del>initialized to <code>0</code></del>.
</p>
</blockquote>
<pre>
void*&amp; pword(int idx);
</pre>
<blockquote>
<p>
-6- [&hellip;]
<p/>
-7- [&hellip;]
<p/>
-8- <i>Returns:</i> On success <code>parray[idx]</code>. On failure<ins>,</ins> a<ins>n</ins> <del>valid</del> 
<ins>lvalue of type</ins> <code>void*<del>&amp;</del></code> <ins>with a null pointer value</ins><del>initialized 
to <code>0</code></del>.
<p/>
-9- <i>Remarks:</i> After a subsequent call to <code>pword(int)</code> for the same object, the earlier return value may no
longer be valid.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3678"><a href="3678">3678</a>. Constructors of <code>std::chrono::time_zone</code> might be overly unspecified</h3>
<p><b>Section:</b> 30.11.5.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.overview">[time.zone.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-02-23 <b>Last modified:</b> 2025-03-19</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.11.5.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.overview">[time.zone.overview]</a>, only defaulted move constructor and move assignment operator for 
<code>std::chrono::time_zone</code> are shown, other constructors are said to be "unspecified additional constructors". 
Presumably the intent is that the default constructor is not declared (suppressed) and the copy constructor is 
implicitly deleted, but it is not clear if they are not "unspecified additional constructors" and hence 
implicitly specified.
<p/>
On the other hand, the defaulted definitions of move functions bring almost no specification, as no exposition 
only member is shown. So it is unspecified whether these functions are deleted, trivial, <code>constexpr</code>, 
or <code>noexcept</code>. Perhaps we want these functions to be non-deleted and <code>noexcept</code>, while triviality 
and <code>constexpr</code>-ness should be left unspecified.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>

<p><i>[2025-03-18; Jonathan provides wording]</i></p>

<p>
I don't think it matters whether they are trivial or constexpr, because they
cannot be used. Users only have access to <code class='backtick'>const time_zone</code> lvalues via
<code class='backtick'>locate_zone</code> and the <code class='backtick'>tzdb::zones</code> container.
The move constructor and move assignment operator only need to exist so that
the implementation can populate that container.
</p>



<p id="res-3678"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 30.11.5.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.overview">[time.zone.overview]</a> as indicated:</p>
<blockquote><pre><code>
namespace std::chrono {
  class time_zone {
    <ins>time_zone(<i>unspecified</i>);</ins>
  public:
    time_zone(time_zone&amp;&amp;) = default;
    time_zone&amp; operator=(time_zone&amp;&amp;) = default;

    <del><i>// unspecified additional constructors</i></del>

    <i>[...]</i>
  };
}</code></pre></blockquote>
<p>-1-
A <code class='backtick'>time_zone</code> represents all time zone transitions for a specific geographic
area.
<code class='backtick'>time_zone</code> construction is unspecified, and performed
<ins>only</ins>
as part of database initialization.
</p>
<p>
[<i>Note 1</i>:
<code class='backtick'>const time_zone</code> objects can be accessed via functions such as <code class='backtick'>locate_zone</code>.
&mdash; <i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3 id="3679"><a href="3679">3679</a>. Is <code>&lt;ranges&gt;</code> sufficient for <code>istream_view</code>?</h3>
<p><b>Section:</b> 25.6.6 <a href="https://timsong-cpp.github.io/cppwp/range.istream">[range.istream]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2022-02-24 <b>Last modified:</b> 2022-11-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following is rejected by libstdc++:
</p>
<blockquote><pre>
#include &lt;ranges&gt;

void call(std::ranges::istream_view&lt;int&gt;&amp; v);
</pre></blockquote>
<p>
The error is quite cryptic, but ultimately the issue is not including <code>&lt;istream&gt;</code>. I think 
this currently isn't required to work, so the fact that it does not work is conforming. But should it be 
required to work? 
<p/>
I think either this should work or we should add a note to 25.6.6 <a href="https://timsong-cpp.github.io/cppwp/range.istream">[range.istream]</a> about the include.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[Kona 2022-11-08; discussed at joint LWG/SG9 session. Send to LEWG (with suggested options)]</i></p>



<p id="res-3679"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3680"><a href="3680">3680</a>. Constructor of <code>move_only_function</code> with empty <code><i>ref</i></code>-qualifier is over-constrained</h3>
<p><b>Section:</b> 22.10.17.4.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.move.ctor">[func.wrap.move.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2022-02-27 <b>Last modified:</b> 2022-03-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.move.ctor">active issues</a> in [func.wrap.move.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.move.ctor">issues</a> in [func.wrap.move.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following test compiles and holds:
</p>
<blockquote><pre>
struct X
{
  int operator()() &amp; { return 1; }  // #1
  int operator()() &amp;&amp; { return 2; } // #2
};

using T = move_only_function&lt;int()&gt;;
assert(T(X{})() == 1);
</pre></blockquote>
<p>
In other words, <code>#2</code> is never used. But if you really remove <code>#2</code>, the code doesn't compile.
<p/>
The change was introduced between <a href="https://wg21.link/P0288R5" title=" any_invocable">P0288R5</a> and <a href="https://wg21.link/P0288R6" title=" any_invocable">P0288R6</a>, with 
an intention (assumed) to require <code>move_only_function&lt;R(Args...) <i>cv</i>&gt;</code>
erasing callable objects with <code>operator()</code> without <code><i>ref</i></code>-qualifiers. 
But the actual outcome outlawed programs that were valid when using <code>std::function</code>.
<p/>
It also outlaws future programs such as
</p>
<blockquote><pre>
T x = [captures](this auto&amp;) { return ...; }
</pre></blockquote>
<p>
where declaring <code>this auto&amp;&amp;</code> without forwarding only to satisfy
<code>move_only_function</code>'s constraints would be strange.
</p>

<p><i>[2022-03-04; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
Probably needs a paper for LEWG.
</p>



<p id="res-3680"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901" title=" Working Draft, Standard for Programming Language C++">N4901</a>.
</p>

<ol>
<li><p>Modify 22.10.17.4.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.move.ctor">[func.wrap.move.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class VT&gt;
  static constexpr bool <i>is-callable-from</i> = <i>see below</i>;
</pre>
<blockquote>
<p>
-1- If <code><i>noex</i></code> is <code>true</code>, <code><i>is-callable-from</i>&lt;VT&gt;</code> is equal to:
</p>
<blockquote><pre>
<del>is_nothrow_invocable_r_v&lt;R, VT <i>cv ref</i>, ArgTypes...&gt; &amp;&amp;</del>
is_nothrow_invocable_r_v&lt;R, VT <i>inv-quals</i>, ArgTypes...&gt;
</pre></blockquote>
<p>
Otherwise, <code><i>is-callable-from</i>&lt;VT&gt;</code> is equal to:
</p>
<blockquote><pre>
<del>is_invocable_r_v&lt;R, VT <i>cv ref</i>, ArgTypes...&gt; &amp;&amp;</del>
is_invocable_r_v&lt;R, VT <i>inv-quals</i>, ArgTypes...&gt;
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3681"><a href="3681">3681</a>. Further considerations on LWG 3679</h3>
<p><b>Section:</b> 20.5.1 <a href="https://timsong-cpp.github.io/cppwp/mem.res.syn">[mem.res.syn]</a>, 20.2.2 <a href="https://timsong-cpp.github.io/cppwp/memory.syn">[memory.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-02-28 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The issue reflected in LWG <a href="3679" title="Is &lt;ranges&gt; sufficient for istream_view? (Status: LEWG)">3679</a> is not limited to <code>&lt;ranges&gt;</code> and 
<code>std::ranges::istream_view</code>.
<p/>
Example:
</p>
<blockquote><pre>
 #include &lt;vector&gt;
// some standard headers other than &lt;memory&gt; and &lt;memory_resource&gt;

template&lt;class T&gt; my_ator {/*definition, meeting the requirements of <i>Cpp17Allocator</i>*/};

int main()
{
  std::vector&lt;int&gt; v1; // Generally works. Is this guaranteed?
  std::pmr::vector&lt;int&gt; v2; // Usually fails to work on libstdc++. Is this intendedly permitted??
  std::vector&lt;int, my_ator&lt;int&gt;&gt; v3; // Generally works. Is this guaranteed?
}
</pre></blockquote>
<p>
Currently libstdc++ only provides forward declarations of <code>std::pmr::polymorphic_allocator</code> 
in headers of standard allocator-aware containers, which means that users are required to include 
both <code>&lt;memory_resource&gt;</code> and <code>&lt;vector&gt;</code> in order to create a 
<code>std::pmr::vector&lt;T&gt;</code> object. If libstdc++ is technically conforming here, one may say 
the definition of <code>std::allocator</code> is also not guaranteed to be available in these headers, 
so <code>&lt;memory&gt;</code> is required to be included together with such a header to make 
<code><i>standard-container</i>&lt;T&gt;</code> work.
<p/>
Furthermore, the specification of allocator-aware containers are heavily dependent on 
<code>std::allocator_traits</code>. If these containers are not guaranteed to work when the definition of 
<code>std::allocator_traits</code> is not available, and the definition of <code>std::allocator_traits</code> 
is not guaranteed to be provided in headers of these containers, then users are effectively always 
required to include <code>&lt;memory&gt;</code> in order to create a container object, even if they are 
using their own allocators.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3681"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3682"><a href="3682">3682</a>. A <i>Cpp17Allocator</i> type can't silently ignore an unsupported alignment</h3>
<p><b>Section:</b> 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-03-18 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements.general">active issues</a> in [allocator.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements.general">issues</a> in [allocator.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently (at least since <a href="https://wg21.link/P0593R6" title=" Implicit creation of objects for low-level object manipulation">P0593R6</a>), the <code>allocate</code> function of an allocator is 
required to create an array of elements (16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a>), which means 
the allocated storage must be properly aligned (otherwise the array of requested size can't be created). 
However, according to paragraph 12 it is also allowed that "the allocator also may silently ignore the 
requested alignment".
<p/>
IMO the allowance is contradictory and should be removed.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"You can allocate from such an allocator but you can't construct objects
in the allocated memory without manually checking the alignment of the
returned pointer. That doesn't seem useful in practice."
</p>
<p>
"maybe even NAD/LEWG? I can't see us declaring most in-the-wild allocators
to no longer be allocators. If anything, a design change is necessary to have
a protocol for allocators to declare proper support for overalignment and for
<code>allocator_traits</code> to implement such support "manually" for older
allocators."
</p>



<p id="res-3682"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3684"><a href="3684">3684</a>. <code>std::allocator&lt;T&gt;::allocate_at_least</code> in constant evaluation</h3>
<p><b>Section:</b> 20.2.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-03-22 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::allocator&lt;T&gt;::allocate_at_least</code> is a constexpr function that allocates memory during 
constant evaluation, but its restrictions is not clear. Presumably the restrictions are same as those of 
<code>std::allocator&lt;T&gt;::allocate</code>, and we should specify <code>allocate_at_least</code> in term of <code>allocate</code>.
<p/>
The MSVC STL implementation returns <code>allocation_result&lt;T*&gt;{allocate(n), n}</code> now. Perhaps we 
should adopt this strategy for constant evaluation to avoid additional mechanism in the compiler.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Suggestion to fix this in Core instead.
</p>



<p id="res-3684"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 20.2.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a> as indicated:</p>

<blockquote>
<pre>
[[nodiscard]] constexpr allocation_result&lt;T*&gt; allocate_at_least(size_t n);
</pre>
<blockquote>
<p>
-6- <i>Mandates:</i> <code>T</code> is not an incomplete type (6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.types.general">[basic.types.general]</a>).
<p/>
-7- <i>Returns:</i> <code>allocation_result&lt;T*&gt;{ptr, count}</code>, where <code>ptr</code> is a pointer 
to the initial element of an array of <code>count T</code> and <code>count &ge; n</code>.
<p/>
-8- <i>Throws:</i> <code>bad_array_new_length</code> if <code>numeric_limits&lt;size_t&gt;::max() / sizeof(T) &lt; n</code>, 
or <code>bad_alloc</code> if the storage cannot be obtained.
<p/>
-9- <i>Remarks:</i> The storage for the array is obtained by calling <code>::operator new</code>, 
but it is unspecified when or how often this function is called. This function starts the 
lifetime of the array object, but not that of any of the array elements. <ins>This function returns 
<code>allocation_result&lt;T*&gt;{allocate(n), n}</code> within the evaluation of a core constant expression.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3685"><a href="3685">3685</a>. In <code>lazy_split_view</code>, CTAD doesn't work when given an <code>input_range</code> input and a <code><i>tiny-range</i></code> pattern</h3>
<p><b>Section:</b> 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Konstantin Varlamov <b>Opened:</b> 2022-03-23 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.lazy.split.view">active issues</a> in [range.lazy.split.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.lazy.split.view">issues</a> in [range.lazy.split.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <code>lazy_split_view</code>, the deduction guide that accepts two arbitrary types wraps the arguments in 
<code>views::all_t</code> (25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a>):
</p>
<blockquote><pre>
template&lt;class R, class P&gt;
  lazy_split_view(R&amp;&amp;, P&amp;&amp;) -&gt; lazy_split_view&lt;views::all_t&lt;R&gt;, views::all_t&lt;P&gt;&gt;;
</pre></blockquote>
<p>
When trying to use an <code>input_range</code> as the input, <code>lazy_split_view</code> requires the pattern 
type to satisfy the exposition-only concept <code><i>tiny-range</i></code>. Trying to use CTAD with an 
<code>input_range</code> and a <code><i>tiny-range</i></code> as arguments results in a compiler error, as demonstrated
in the <a href="https://godbolt.org/z/37bs9hq1T">demo link</a>:
</p>
<blockquote><pre>
// Assuming <code class='backtick'>InputRange</code> and <code class='backtick'>TinyRange</code> are valid types satisfying the
// corresponding concepts.
std::ranges::lazy_split_view view{InputRange(), TinyRange()}; // Compiler error
</pre></blockquote>
<p>
The underlying reason is that <code><i>tiny-range</i></code> requires the given type to contain a static member function 
<code>size()</code> that returns a number <code>&lt;=1</code> (25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a>):
</p>
<blockquote><pre>
template&lt;class R&gt;
  concept <i>tiny-range</i> =                                          // exposition only
    sized_range&lt;R&gt; &amp;&amp;
    requires { typename <i>require-constant</i>&lt;remove_reference_t&lt;R&gt;::size()&gt;; } &amp;&amp;
    (remove_reference_t&lt;R&gt;::size() &lt;= 1);
</pre></blockquote>
<p>
However, when given a range, <code>views::all_t</code> wraps the type in a <code>ranges::owning_view</code>. 
<code>owning_view</code> doesn't satisfy <code><i>tiny-range</i></code> for any template parameter because it 
never contains the static <code>size()</code> function required by the concept.
<p/>
A general resolution might be modifying <code>owning_view</code> so that it satisfies <code><i>tiny-range</i></code> 
when the given type is a <code><i>tiny-range</i></code> (that would require moving the <code><i>tiny-range</i></code> 
concept from 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> to 25.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>). A more 
localized solution can be to change the deduction guide in <code>lazy_split_view</code> to avoid wrapping 
a type satisfying <code><i>tiny-range</i></code> in <code>views::all_t</code>.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. One vote for NAD.
</p>



<p id="res-3685"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 25.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> This change effectively just moves the definitions of 
<code><i>require-constant</i></code> and <code><i>tiny-range</i></code> from 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a>
to 25.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>.]
</p>
</blockquote>

<blockquote>
<pre>
[&hellip;]
template&lt;class T, class U&gt;
  concept <i>different-from</i> = <i>// exposition only</i>
    !same_as&lt;remove_cvref_t&lt;T&gt;, remove_cvref_t&lt;U&gt;&gt;;

<ins>template&lt;auto&gt; struct <i>require-constant</i>; <i>// exposition only</i>

template&lt;class R&gt;
concept <i>tiny-range</i> = <i>// exposition only</i>
  sized_range&lt;R&gt; &amp;&amp;
  requires { typename <i>require-constant</i>&lt;remove_reference_t&lt;R&gt;::size()&gt;; } &amp;&amp;
  (remove_reference_t&lt;R&gt;::size() &lt;= 1);</ins>
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.6.3 <a href="https://timsong-cpp.github.io/cppwp/range.owning.view">[range.owning.view]</a>, class template <code>owning_view</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<ins>constexpr static auto size() requires <i>tiny-range</i>&lt;R&gt;
{ return R::size(); }</ins>
constexpr auto size() requires sized_range&lt;R&gt;
{ return ranges::size(<i>r_</i>); }
constexpr auto size() const requires sized_range&lt;const R&gt;
{ return ranges::size(<i>r_</i>); }
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a>, class template <code>lazy_split_view</code> synopsis, as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> This change effectively just moves the definitions of 
<code><i>require-constant</i></code> and <code><i>tiny-range</i></code> from 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a>
to 25.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>.]
</p>
</blockquote>

<blockquote>
<pre>
namespace std::ranges {
  <del>template&lt;auto&gt; struct <i>require-constant</i>; <i>// exposition only</i>
  
  template&lt;class R&gt;
  concept <i>tiny-range</i> = <i>// exposition only</i>
    sized_range&lt;R&gt; &amp;&amp;
    requires { typename <i>require-constant</i>&lt;remove_reference_t&lt;R&gt;::size()&gt;; } &amp;&amp;
    (remove_reference_t&lt;R&gt;::size() &lt;= 1);</del>
    
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
             (forward_range&lt;V&gt; || <i>tiny-range</i>&lt;Pattern&gt;)
  class lazy_split_view : public view_interface&lt;lazy_split_view&lt;V, Pattern&gt;&gt; {
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3686"><a href="3686">3686</a>. In <code>lazy_split_view</code>, comparing a default-constructed <code><i>outer-iterator</i></code> or 
<code><i>inner-iterator</i></code> with <code>std::default_sentinel</code> results in null pointer dereference</h3>
<p><b>Section:</b> 25.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.outer">[range.lazy.split.outer]</a>, 25.7.16.5 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.inner">[range.lazy.split.inner]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Konstantin Varlamov <b>Opened:</b> 2022-03-23 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.lazy.split.outer">active issues</a> in [range.lazy.split.outer].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.lazy.split.outer">issues</a> in [range.lazy.split.outer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The internal iterator types <code><i>outer-iterator</i></code> and <code><i>inner-iterator</i></code> of 
<code>lazy_split_view</code> are default-constructible, but trying to compare a default-constructed 
instance of either of these classes to <code>std::default_sentinel</code> results in null pointer 
dereference (and, in all likelihood, a crash), as demonstrated in this 
<a href="https://godbolt.org/z/cGs9jW1c6">demo link</a>:
</p>
<blockquote><pre>
// Assuming <code class='backtick'>OuterIter</code> is an alias for <code class='backtick'>outer-iterator</code> of
// some <code class='backtick'>lazy_split_view</code> instantiation.
OuterIter o;
o == std::default_sentinel; // Null pointer dereference

InnerIter i; // Similar to <code class='backtick'>OuterIter</code> above.
i == std::default_sentinel; // Null pointer dereference
</pre></blockquote>
<p>
This is due to unchecked pointer access in the implementation of <code><i>outer-iterator</i></code> 
(25.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.outer">[range.lazy.split.outer]</a> p8):
</p>
<blockquote><pre>
return x.<i>current</i> == ranges::end(x.<i>parent_</i>-&gt;<i>base_</i>) &amp;&amp; !x.<i>trailing_empty_</i>;
</pre></blockquote>
<p>
(<code><i>parent_</i></code> is null for a default-constructed iterator <code>x</code>, making the access 
to <code><i>base_</i></code> invalid)
<p/>
And similarly for <code><i>inner-iterator</i></code> (25.7.16.5 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.inner">[range.lazy.split.inner]</a> p7):
</p>
<blockquote><pre>
auto [pcur, pend] = subrange{x.<i>i_</i>.<i>parent_</i>-&gt;<i>pattern_</i>};
</pre></blockquote>
<p>
(For a default-constructed <code><i>inner-iterator</i> x</code>, <code><i>i_</i></code> is a default-constructed 
<code><i>outer-iterator</i></code> member variable and <code><i>i_</i>.<i>parent_</i></code> is null, making the 
access to <code><i>pattern_</i></code> invalid)
<p/>
It seems a reasonable expectation for users to expect comparing a default-constructed iterator to 
<code>std::default_sentinel</code> to be a well-defined operation that returns <code>true</code>. Alternatively, 
the corresponding <code>operator==</code> functions should add a non-normative note stating that the 
iterator cannot be default-constructed.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Three votes for NAD.
</p>



<p id="res-3686"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 25.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.outer">[range.lazy.split.outer]</a> as indicated:</p>

<blockquote>
<pre>
friend constexpr bool operator==(const <i>outer-iterator</i>&amp; x, default_sentinel_t);
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<ins>if (!x.<i>parent_</i>) return true;</ins>
return x.<i>current</i> == ranges::end(x.<i>parent_</i>-&gt;<i>base_</i>) &amp;&amp; !x.<i>trailing_empty_</i>;
</pre></blockquote>
</blockquote>
</blockquote>
</li>


<li><p>Modify 25.7.16.5 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.inner">[range.lazy.split.inner]</a>, as indicated:</p>

<blockquote>
<pre>
friend constexpr bool operator==(const <i>inner-iterator</i>&amp; x, default_sentinel_t);
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<ins>if (!x.<i>i_</i>.<i>parent_</i>) return true;</ins>
auto [pcur, pend] = subrange{x.<i>i_</i>.<i>parent_</i>-&gt;<i>pattern_</i>};
[&hellip;]
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3688"><a href="3688">3688</a>. Exception specifications of copy/move member functions of <code>std::bad_expected_access</code></h3>
<p><b>Section:</b> 22.8.4 <a href="https://timsong-cpp.github.io/cppwp/expected.bad">[expected.bad]</a>, 22.8.5 <a href="https://timsong-cpp.github.io/cppwp/expected.bad.void">[expected.bad.void]</a>, 22.8.6.6 <a href="https://timsong-cpp.github.io/cppwp/expected.object.obs">[expected.object.obs]</a>, 22.8.7.6 <a href="https://timsong-cpp.github.io/cppwp/expected.void.obs">[expected.void.obs]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-03-24 <b>Last modified:</b> 2024-07-24</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The move constructor and the move assignment operator of standard exception types are not covered by 
17.9.3 <a href="https://timsong-cpp.github.io/cppwp/exception">[exception]</a>/2, and thus it is currently effectively unspecified whether these move 
functions of <code>std::bad_expected_access&lt;void&gt;</code> are <code>noexcept</code>. Furthermore, 
<code>std::bad_expected_access&lt;void&gt;</code> has protected special member functions, which overrides 
(or conflicts with?) the general rule in 17.9.3 <a href="https://timsong-cpp.github.io/cppwp/exception">[exception]</a>/2.
<p/>
The primary template <code>std::bad_expected_access&lt;E&gt;</code> stores an <code>E</code> object, and copying 
the stored object may throw an exception. Is it intended that the copy functions of 
<code>std::bad_expected_access&lt;E&gt;</code> are <code>noexcept</code> while those of <code>E</code> are not? 
When the copy happens because a <code>std::bad_expected_access&lt;E&gt;</code> is caught by value, if the 
copy constructor of <code>E</code> throws, <code>std::terminate</code> is called no matter whether that of 
<code>std::bad_expected_access&lt;E&gt;</code> is <code>noexcept</code>. But 
<code>std::bad_expected_access&lt;E&gt;</code> may be copied/moved in other circumstances.
<p/>
I think the move constructor and the move assignment operator of a standard exception type should be 
specified to be public and <code>noexcept</code> when they exist, although sometimes whether they exist may be 
unspecified. And the move functions should also propagate the result of <code>what()</code> when the source 
and target have the same dynamic type, except that they can leave the result of <code>what()</code> from 
the source valid but unspecified.
<p/>
Related to this, <code>std::expected&lt;T, E&gt;::value</code> overloads are specified to throw 
<code>std::bad_expected_access&lt;std::decay_t&lt;E&gt;&gt;</code> when an <code>E</code> is contained. 
However, it seems that the copy constructor of <code>std::bad_expected_access</code> is implicitly 
deleted if <code>E</code> is move-only, so the <i>throw-expression</i> is ill-formed.
<p/>
Is it intended that <code>std::expected&lt;T, E&gt;::value</code> is ill-formed in such cases?
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><i>[2023-05-25; Jonathan comments]</i></p>

<p>
The last part was clarified by LWG <a href="3843" title="std::expected&lt;T,E&gt;::value() &amp; assumes E is copy constructible (Status: C++23)">3843</a>, confirming that
<code>value()</code> is ill-formed for move-only <code>E</code>.
</p>

<p><i>[2024-07-24; Jonathan comments]</i></p>

<p>
LWG <a href="4031" title="bad_expected_access&lt;void&gt; member functions should be noexcept (Status: WP)">4031</a> made the move (and copy) operations of
<code>bad_expected_access&lt;void&gt;</code> non-throwing.
</p>



<p id="res-3688"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3689"><a href="3689">3689</a>. <code>num_get</code> overflow determination unclear and incorrect</h3>
<p><b>Section:</b> 28.3.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2022-03-28 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.3.4.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.get.virtuals">[facet.num.get.virtuals]</a> stage 3 specifies that "by the rules of" various <code>strto*</code> functions, 
sequences of chars are converted to a numeric value (producing the "converted value" that is referred to).
<p/>
It then goes on to specify various error cases when the "field represents a value" that is outside the range 
of representable values. Clearly, the value that would be returned from the appropriate <code>strto*</code> function 
is not outside the range of representable values for <code>long long</code>, <code>unsigned long long</code>, <code>float</code>, 
<code>double</code>, and <code>long double</code>; therefore (unless if we expect no range-related errors for those types), 
the field "represents a value" other than the "converted value".
<p/>
Issue 1: It is too subtle to have two distinct values without calling more attention to them by giving them names 
aside from the prose descriptions.
<p/>
If the field "represents" a value other than the value that would be returned from the appropriate <code>strto*</code> 
function, then what value does the field "represent"?
Note that, strictly speaking, it is the process that results in the converted value that the wording says is obtained 
"by the rules of" the <code>strto*</code> functions, which is not the same thing as saying that the value represented is 
interpreted "by the rules of" the <code>strto*</code> functions.
<p/>
If the field "represents" the mathematical value, then for unsigned integer types, all negative values cannot be 
represented. This does not match existing practice.
<p/>
If negative integer values are interpreted using the rules of the <code>strto*</code> functions by obtaining the 
magnitude and then having it "negated (in the return type)", then the return type of <code>strtoull</code> is 
<code>unsigned long long</code>, meaning (where <code>unsigned long long</code> is 64-bit) that "<code>-18446744073709551615</code>" 
is <code>1</code> (even when converting to unsigned integer types of less width). That does not match existing practice.
It is also worth noting that negating in the return type does not work well if the magnitude is not representable as 
a positive value in the return type (e.g., for signed integer types and their most negative representable values).
<p/>
Issue 2: The effect of the minus sign with respect to unsigned integer types can reasonably be interpreted in ways 
that do not match existing practice (and are presumably unintended). The interpretation that works better for 
<code>unsigned long long</code> does not work as well for <code>signed long long</code>.
<p/>
If the field does not "represent" the mathematical value, then for floating-point types, it is unclear whether 
the minus sign takes effect before or after any possible rounding. For literals, the minus sign takes effect after 
rounding.
<p/>
Issue 3: The effect of the minus sign with respect to floating-point types is unclear.
<p/>
Lastly, for floating-point types with signed infinities, there are no finite values outside the range of 
representable values; therefore, conversions of all finite values to such types are specified to "succeed". That 
does not match existing implementation practice.
<p/>
Issue 4: The conditions for identifying range-related errors for conversions to floating-point types do not match 
the conditions that constitute overflow for floating-point types. There is implementation divergence: libc++ appears 
to check for floating-point overflow; libstdc++ appears to check for infinities.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3689"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3690"><a href="3690">3690</a>. <code>std::make_from_tuple</code> etc. should find all tuple-like <code>std::get</code> overloads</h3>
<p><b>Section:</b> 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>, 22.4.6 <a href="https://timsong-cpp.github.io/cppwp/tuple.apply">[tuple.apply]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-04-06 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#contents">issues</a> in [contents].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently it is not clear in 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>/3 whether all possible overloads in the 
standard library are considered to be found "in the context of <code>D</code>". As a result, it 
seems underspecified whether a certain <code>std::get</code> overload is found by <code>std::tuple_cat</code>, 
<code>std::make_from_tuple</code>, <code>std::apply</code>, or exposition-only concept <code><i>pair-like</i></code> 
or <code><i>has-tuple-element</i></code>.
<p/>
There is implementation divergence: MSVC STL's <code>std::make_from_tuple</code> accepts 
<code>std::ranges::subrange</code>, but libstdc++'s doesn't, which is originally discussed in 
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=102301">GCC bug #102301</a>.
<p/>
IMO <code>std::get</code> overloads need some special rules: when referred by tuple-like facilities, 
overloads for <code>std::variant</code> should be excluded (or at least leave whether it's found 
unspecified), and all other overloads should be found; and the opposite rule should be used 
when referred in 22.6 <a href="https://timsong-cpp.github.io/cppwp/variant">[variant]</a>.
</p>

<p><i>[2022-04-25; Jiang An comments and provides wording]</i></p>

<p>
 Currently this program is accepted when using MSVC STL and libstdc++, although the acception seems unintended and problematic.
</p>
<blockquote><pre>
#include &lt;variant&gt;
#include &lt;span&gt;
#include &lt;ranges&gt;

struct Foo : std::variant&lt;int, long&gt; {};

template&lt;&gt;
struct std::tuple_element&lt;0, Foo&gt; { using type = int; };

template&lt;&gt;
struct std::tuple_element&lt;1, Foo&gt; { using type = long; };

template&lt;&gt;
struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 2&gt; {};

constexpr auto bad_keys = std::span&lt;Foo&gt;{} | std::views::values;

int main() {} <i>// COMPILE-ONLY</i>
</pre></blockquote>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3690"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-3- Whenever an unqualified name other than <code>swap</code> is used in the specification of a declaration <code>D</code> 
in Clause 17 <a href="https://timsong-cpp.github.io/cppwp/support">[support]</a> through Clause 32 <a href="https://timsong-cpp.github.io/cppwp/thread">[thread]</a> or Annex D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a>, 
its meaning is established as-if by performing unqualified name lookup (6.5.3 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.unqual">[basic.lookup.unqual]</a>)
in the context of <code>D</code>.
<p/>
[<i>Note 1</i>: Argument-dependent lookup is not performed. &mdash; <i>end note</i>]
<p/>
Similarly, the meaning of a <i>qualified-id</i> is established as-if by performing qualified name lookup 
(6.5.5 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.qual">[basic.lookup.qual]</a>) in the context of <code>D</code>.
<p/>
[<i>Example 1</i>: The reference to <code>is_array_v</code> in the specification of <code>std::to_array</code> 
(23.3.3.6 <a href="https://timsong-cpp.github.io/cppwp/array.creation">[array.creation]</a>) refers to <code>::std::is_array_v</code>. &mdash; <i>end example</i>]
<p/>
[<i>Note 2</i>: Operators in expressions (12.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/over.match.oper">[over.match.oper]</a>) are not so constrained; see 
16.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a>. &mdash; <i>end note</i>]
The meaning of the unqualified name <code>swap</code> is established in an overload resolution context for 
swappable values (16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>).
<p/>
<ins>Certain entities in the standard library are specified to select <i>tuple-like <code>get</code> function templates</i>. 
An implementation shall behave as if every tuple-like <code>get</code> function template is found in the 
definition of such an entity. Furthermore, an implementation shall ensure that no <code>get</code> function 
template that is not tuple-like is found in the definition of such an entity.</ins>
</p>
</blockquote>
</li>

<li><p>Add to the end of 22.3.4 <a href="https://timsong-cpp.github.io/cppwp/pair.astuple">[pair.astuple]</a>, 22.4.8 <a href="https://timsong-cpp.github.io/cppwp/tuple.elem">[tuple.elem]</a>, 
23.3.3.7 <a href="https://timsong-cpp.github.io/cppwp/array.tuple">[array.tuple]</a>, and 25.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.access">[range.subrange.access]</a> as indicated:</p>

<blockquote>
<p>
<ins>The <code>get</code> function templates specified in this section are tuple-like (16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>).</ins>
</p>
</blockquote>

</li>

<li><p>Modify 22.4.6 <a href="https://timsong-cpp.github.io/cppwp/tuple.apply">[tuple.apply]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F, class Tuple&gt;
  constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Given the exposition-only function:
</p>
<blockquote><pre>
namespace std {
  template&lt;class F, class Tuple, size_t... I&gt;
  constexpr decltype(auto) <i>apply-impl</i>(F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) { <i>// exposition only</i>
    return <i>INVOKE</i>(std::forward&lt;F&gt;(f), get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...); <i>// see 22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a></i>
  }
}
</pre></blockquote>
<p>
Equivalent to:
</p>
<blockquote><pre>
return <i>apply-impl</i>(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t),
                  make_index_sequence&lt;tuple_size_v&lt;remove_reference_t&lt;Tuple&gt;&gt;&gt;{});
</pre></blockquote>
<p>
<ins>-?- <i>Remarks:</i> <code><i>apply-impl</i></code> selects tuple-like <code>get</code> function templates.</ins>
</p>
</blockquote>
<pre>
template&lt;class T, class Tuple&gt;
  constexpr T make_from_tuple(Tuple&amp;&amp; t);
</pre>
<blockquote>
<p>
-2- <i>Mandates:</i> If <code>tuple_size_v&lt;remove_reference_t&lt;Tuple&gt;&gt;</code> is <code>1</code>, then 
<code>reference_constructs_from_temporary_v&lt;T, decltype(get&lt;0&gt;(declval&lt;Tuple&gt;()))&gt;</code> is 
<code>false</code>.
<p/>
-3- <i>Effects:</i> Given the exposition-only function:
</p>
<blockquote><pre>
namespace std {
  template&lt;class T, class Tuple, size_t... I&gt;
    requires is_constructible_v&lt;T, decltype(get&lt;I&gt;(declval&lt;Tuple&gt;()))...&gt;
  constexpr T <i>make-from-tuple-impl</i>(Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) { <i>// exposition only</i>
    return T(get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
  }
}
</pre></blockquote>
<p>
Equivalent to:
</p>
<blockquote><pre>
return <i>make-from-tuple-impl</i>&lt;T&gt;(
          std::forward&lt;Tuple&gt;(t),
          make_index_sequence&lt;tuple_size_v&lt;remove_reference_t&lt;Tuple&gt;&gt;&gt;{});
</pre></blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> <code><i>make-from-tuple-impl</i></code> selects tuple-like <code>get</code> function templates.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Add at the end of 25.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.general">[range.subrange.general]</a> (after the synopsis) as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Although IIUC <code><i>pair-like</i></code> is not needed to handle <code>array</code> and 
<code>subrange</code>.]
</p>
</blockquote>

<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> <code><i>pair-like</i></code> selects tuple-like <code>get</code> function templates.</ins>
</p>
</blockquote>
</li>

<li><p>Add after the synopsis of 25.7.23.2 <a href="https://timsong-cpp.github.io/cppwp/range.elements.view">[range.elements.view]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> <code><i>has-tuple-element</i></code> selects tuple-like <code>get</code> function templates.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3691"><a href="3691">3691</a>. Replacement of keys in associative containers</h3>
<p><b>Section:</b> 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a>, 23.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2022-04-19 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts.general">active issues</a> in [associative.reqmts.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts.general">issues</a> in [associative.reqmts.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Keys for elements of associative containers are presented as <code>const</code> subobjects, 
preventing their modification by user code according to 9.2.9.2 <a href="https://timsong-cpp.github.io/cppwp/dcl.type.cv">[dcl.type.cv]</a> p4.
<p/>
However, that does not prevent those keys to be transparently replaced, for example via
</p>
<blockquote><pre>
std::map&lt;int, int&gt; map;
map.emplace(1, 2);
using KT = std::map&lt;int, int&gt;::key_type;
auto it = map.begin();
it-&gt;first.~KT();
new (const_cast&lt;int*&gt;(&amp;it-&gt;first)) KT(3);
</pre></blockquote>
<p>
This, of course, breaks the ordering of the keys, and should be undefined behavior.
<p/>
Related issue: <a href="https://wg21.link/cwg2514">CWG 2514</a>.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. One vote for NAD.
</p>



<p id="res-3691"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a> as indicated:</p>

<blockquote>
<p>
-5- For <code>set</code> and <code>multiset</code> the value type is the same as the key type. For 
<code>map</code> and <code>multimap</code> it is equal to <code>pair&lt;const Key, T&gt;</code>. 
<ins>Ending the lifetime of the key subobject of a container element by means other than 
invoking a member function of the container results in undefined behavior.</ins>
</p>
</blockquote>
</li>

<li><p>Modify 23.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> as indicated:</p>

<blockquote>
<p>
-7- For <code>unordered_set</code> and <code>unordered_multiset</code> the value type is the same as the key type. 
For <code>unordered_map</code> and <code>unordered_multimap</code> it is <code>pair&lt;const Key, T&gt;</code>.
<ins>Ending the lifetime of the key subobject of a container element by means other than 
invoking a member function of the container results in undefined behavior.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3693"><a href="3693">3693</a>. &sect;[c.math] Can any of <code>float/double/long double</code> overloads be fused into template overloads?</h3>
<p><b>Section:</b> 29.7 <a href="https://timsong-cpp.github.io/cppwp/c.math">[c.math]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-04-28 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
IIUC LWG <a href="3234" title="Sufficient Additional Special Math Overloads (Status: Resolved)">3234</a> will be resolved by the recently approved paper <a href="https://wg21.link/P1467R9" title=" Extended floating-point types and standard names">P1467R9</a>. 
While considering adding the newly required overloads of math special functions to MSVC STL, I found 
that it may be more convenient to implement the whole overload set as a single function template.
<p/>
However, it's unclear for me whether the every "overload for each <i>cv</i>-unqualified floating-point 
type", or every currently separately shown overloads in the synopsis of <code>&lt;cmath&gt;</code>, is 
required to be a separated function. As discussed in 
<a href="https://github.com/microsoft/STL/issues/1335">microsoft/STL#1335</a>, if there were only a 
separated <code>double</code> overload (usually comes from the C standard library) and a fused template 
overload, calling the overload set with <code>{}</code> would be accepted, which is definitely ambiguous 
when there are separated <code>float/double/long double</code> overloads.
<p/>
I think it may be better to allow implementations to arbitrarily fuse the required overloads.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll. One vote for NAD.
</p>



<p id="res-3693"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3694"><a href="3694">3694</a>. Should <code>traits_type::length</code> be customizable?</h3>
<p><b>Section:</b> 27.2.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.require">[char.traits.require]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-05-04 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#char.traits.require">active issues</a> in [char.traits.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.require">issues</a> in [char.traits.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
MSVC STL's implementation of the <code>std::quoted</code> overload for <code>const charT*</code> calculates 
the length of the NTCTS and stores the result within the return value. Because the returned value may  
be output by <code>std::basic_ostream</code> specializations with different <code>traits_type</code>s, this 
strategy can be conforming only if all possible <code>traits_type::length</code> functions for the same 
<code>char_type</code> have equivalent return values.
<p/>
It seems not clear whether <code>traits_type::length</code> should be customizable. In a related PR, 
<a href="https://github.com/microsoft/STL/pull/2676#discussion_r861407001">Stephan T. Lavavej said</a> :
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
I argue that you've found a defect in the <code>char_traits</code> specification &mdash; it should say 
that whatever <code>eq()</code> does, it should consider <code>charT()</code> to be distinct from all other 
values, which aligns with the common understanding of how null-terminated strings behave.
<p/>
The original implementation and the <code>char_traits::length</code> change both handle arbitrary character 
types &mdash; the only difference would be for custom <code>char_traits</code> that consider null terminators 
to be equal to other values, which I have never seen used in practice (e.g. case-insensitive traits 
don't do this).
</p>
</blockquote>
<p>
If it is decided that <code>traits_type::length</code> is customizable, then the implementation in MSVC STL 
should be fixed. Otherwise, we should explicitly require in 27.2.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.require">[char.traits.require]</a> that 
whenever <code>c</code> is not "equal" to <code>char_type()</code>, <code>traits_type::eq(c, char_type())</code> is 
<code>false</code>.
<p/>
However, equivalence of two <code>charT</code> values seems not easy to specify, as there may be no 
<code>operator==</code> for <code>charT</code>, or the <code>operator==</code> behaves pathologically. IMO possible 
way may be
</p>
<ul>
<li><p>using the equivalence relation of value representations, or</p></li>
<li><p>using <code>==</code> and only imposing the requirement when <code>char_type</code> is an encoded 
character type (or more generally, a scalar type, while treating an enum type as its underlying type).</p></li>
</ul>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. One vote for NAD.
</p>



<p id="res-3694"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3696"><a href="3696">3696</a>. "Basic integral types" should not be used</h3>
<p><b>Section:</b> 31.2.2 <a href="https://timsong-cpp.github.io/cppwp/stream.types">[stream.types]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-05-07 <b>Last modified:</b> 2025-06-16</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Raised from editorial issue <a href="https://github.com/cplusplus/draft/issues/5240">#5240</a>.
<p/>
The phrase "signed basic integral types" in 31.2.2 <a href="https://timsong-cpp.github.io/cppwp/stream.types">[stream.types]</a> has been present since C++98 but 
never defined. It is unclear whether "basic integral types" are "standard integer types" or "integer types" 
(including extended integer types).
<p/>
As <code>std::streamoff</code> should be wide enough to represent the largest possible file size, and 
<code>std::uintmax_t</code> is used as the return type of <code>std::filesystem::file_size</code>, we should not 
disallow <code>std::streamoff</code> to be an extended integer type which may be wider than <code>long long</code>. 
On the other hand, as <code>std::size_t</code> and <code>std::ptrdiff_t</code> have already been allowed to be 
extended integer types, <code>std::streamsize</code> should also be allowed to be an extended integer type for consistency.
<p/>
So I think we should just use "signed integer types" instead of "signed basic integral types" in 
31.2.2 <a href="https://timsong-cpp.github.io/cppwp/stream.types">[stream.types]</a>.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2025-06-16; Jonathan adds wording]</i></p>




<p id="res-3696"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 31.2.2 <a href="https://timsong-cpp.github.io/cppwp/stream.types">[stream.types]</a> as indicated:</p>

<blockquote>
<pre>using streamoff = implementation-defined;</pre>
<p>
-1- The type <code class='backtick'>streamoff</code> is a synonym for one of the
signed <del>basic</del> integral types
of sufficient size to represent the maximum possible file size
for the operating system.<sup>256</sup>
</p>
<pre>using streamsize = implementation-defined;</pre>
<p>
-2-
The type <code class='backtick'>streamsize</code> is a synonym for one of the
signed <del>basic</del> integral types.
It is used to represent the number of characters transferred
in an I/O operation, or the size of I/O buffers.<sup>257</sup>
</p>

<p>
<sub>256) Typically <code class='backtick'>long long</code>.</sub>
</p>
<p>
<sub>257) Most places where <code class='backtick'>streamsize</code> is used would use <code class='backtick'>size_t</code> in C,
or <code class='backtick'>ssize_t</code> in POSIX.</sub>
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3697"><a href="3697">3697</a>. Preconditions of <code>reference_constructs_from_temporary/reference_converts_from_temporary</code> seem wrong</h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-05-10 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::reference_constructs_from_temporary</code> and <code>std::reference_converts_from_temporary</code> are only 
useful when <code>T</code> is a reference type, and a reference type is always complete. Whenever <code>T</code> is an 
incomplete object type, it's clear that these traits inherit from <code>std::false_type</code>, without any further 
detection which may result in UB. However, when <code>T</code> is <code>X&amp;</code> or <code>X&amp;&amp;</code> where 
<code>X</code> is an incomplete object type, UB may be needed because of the potentially problematic detection in 
<code>std::is_constructible</code> or <code>std::is_convertible</code>.
<p/>
I'm not sure whether the general rule in 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>/5 affects these cases.
</p>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3697"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>, Table 46 ([tab:meta.unary.prop]) &mdash; 
"Type property predicates" &mdash; as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 46: Type property predicates [tab:meta.unary.prop]</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>template&lt;class T, class U&gt;<br/>
struct reference_constructs_from_temporary;</code>
</td>

<td>
<code>conjunction_v&lt;is_reference&lt;T&gt;, is_constructible&lt;T, U&gt;&gt;</code> is<br/> 
<code>true</code>, and the initialization <code>T t(<i>VAL</i>&lt;U&gt;);</code> binds <code>t</code> to a<br/> 
temporary object whose lifetime is extended (6.8.7 <a href="https://timsong-cpp.github.io/cppwp/class.temporary">[class.temporary]</a>).
</td>

<td>
<ins>If <code>T</code> is a reference type, <code>remove_reference_t&lt;T&gt;</code><br/> 
and <code>U</code></ins><del><code>T</code></del> shall be <del>a</del> complete type<ins>s</ins>,<br/>
<i>cv</i> <code>void</code>, or <del>an</del> array<ins>s</ins> of unknown bound.
</td>
</tr>

<tr>
<td>
<code>template&lt;class T, class U&gt;<br/>
struct reference_converts_from_temporary;</code>
</td>

<td>
<code>conjunction_v&lt;is_reference&lt;T&gt;, is_convertible&lt;U, T&gt;&gt;</code> is<br/> 
<code>true</code>, and the initialization <code>T t = <i>VAL</i>&lt;U&gt;;</code> binds <code>t</code> to a<br/> 
temporary object whose lifetime is extended (6.8.7 <a href="https://timsong-cpp.github.io/cppwp/class.temporary">[class.temporary]</a>).
</td>

<td>
<ins>If</ins> <code>T</code> <ins>is a reference type, <code>remove_reference_t&lt;T&gt;</code></ins><br/> 
and <code>U</code> shall be complete types,<br/>
<i>cv</i> <code>void</code>, or arrays of unknown bound.
</td>
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3 id="3699"><a href="3699">3699</a>. <code>lexically_relative</code> on UNC drive paths (<code>\\?\C:\...</code>) results in a default-constructed value</h3>
<p><b>Section:</b> 31.12.6.5.11 <a href="https://timsong-cpp.github.io/cppwp/fs.path.gen">[fs.path.gen]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicole Mazzuca <b>Opened:</b> 2022-05-12 <b>Last modified:</b> 2022-05-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.path.gen">issues</a> in [fs.path.gen].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As a resolution to LWG <a href="3070" title="path::lexically_relative causes surprising results if a filename can also be a 
root-name (Status: C++20)">3070</a>, in <code>path lexically_relative(const path&amp; base) const</code>, 
bullet 3.4 was added:
</p>
<blockquote><p>
If: [&hellip;] any <i>filename</i> in <code>relative_path()</code> or <code>base.relative_path()</code> can be interpreted as 
a <i>root-name</i>, [&hellip;] returns <code>path()</code>.
</p></blockquote>
<p>
This resolution was correct when we have really weird paths like <code>abc\X:\c</code>, but the MSVC standard library 
implementation treats UNC drive-relative paths as:
</p>
<blockquote><pre>
\\?\C:\foo\bar = { <i>root-name</i> = \\?, <i>root-directory</i> = \, <i>relative-path</i> = C:\foo\bar }
</pre></blockquote>
<p>
If we were able to go back in time, we might have <code><i>root-name</i> = \\?\C:</code>, but we can't make that 
change at that point without silently breaking users; therefore, we believe it would be best to instead change 
<code>lexically_relative()</code> to work around this issue.
<p/>
There exists a <a href="https://github.com/microsoft/STL/issues/2256">related github issue</a>.
<p/>
I don't yet have standard wording, but I think it would be reasonable to do something like:
</p>
<blockquote><p>
If <code>relative_path().has_root_path() &amp;&amp; base.relative_path().has_root_path()</code>, and 
<code>relative_path().root_path() == base.relative_path().root_path()</code>, then 
<code>return relative_path().lexically_relative(base.relative_path())</code>.
</p></blockquote>

<p><i>[2022-05-17; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3699"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3706"><a href="3706">3706</a>. How does <code>std::format</code> work with character arrays of unknown bound?</h3>
<p><b>Section:</b> 28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2022-05-31 <b>Last modified:</b> 2022-06-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.formatter.spec">active issues</a> in [format.formatter.spec].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.formatter.spec">issues</a> in [format.formatter.spec].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider
</p>
<blockquote>
<pre>
#include &lt;format&gt;
#include &lt;iostream&gt;

extern char str[];
auto result = std::format("{}", str);
char str[] = "hello";

int main()
{
  std::cout &lt;&lt; result &lt;&lt; std::endl;
}
</pre>
</blockquote>
<p>
Currently MSVC STL (as well as fmtlib when <code>fmt::format</code> is used instead of <code>std::format</code>) 
accepts the initializer of <code>result</code>, while libc++ produces an error (apparently because there's no 
<code>formatter</code> for <code>char[]</code>).
</p>
<p>
Should this be valid?
</p>
<p>
<b>Daniel:</b>
<p/>
This issue is similar to LWG <a href="3701" title="Make formatter&lt;remove_cvref_t&lt;const charT[N]&gt;, charT&gt; requirement explicit (Status: C++23)">3701</a>, but not the same, because the latter wants 
<code>template&lt;size_t N&gt; struct formatter&lt;charT[N], charT&gt;</code>, while this one needs 
<code>template&lt;&gt;struct formatter&lt;charT[], charT&gt;</code> (that is, without the array bound).
</p>

<p><i>[2022-06-21; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3706"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3716"><a href="3716">3716</a>. &sect;[iterator.concept.forward][forward.iterators] Two different definitions of multi-pass guarantee</h3>
<p><b>Section:</b> 24.3.4.11 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.forward">[iterator.concept.forward]</a>, 24.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/forward.iterators">[forward.iterators]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-06-15 <b>Last modified:</b> 2022-07-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two different definitions of multi-pass guarantee since <a href="https://wg21.link/P0896R4" title=" The One Ranges Proposal">P0896R4</a>. The old one (perhaps 
introduced by <a href="https://wg21.link/N3066" title=" Iterators in C++0x">N3066</a>) seems less reasonable because it requires increment on rvalue iterators of 
class types, and the semantics of such increment is largely unspecified.
<p/>
Perhaps only the new definition should be used.
</p>

<p><i>[2022-07-06; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3716"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3722"><a href="3722">3722</a>. <code>ranges::to</code> <code>reserve</code>s the wrong size</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-20 <b>Last modified:</b> 2025-02-27</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In bullet 1.1.4 of <code>ranges::to</code>, if the <code>Container</code> satisfies <code><i>container-insertable</i></code> 
and <code>R</code> models <code>sized_range</code>, it will first construct the <code>Container</code> with <code>args...</code> 
and then preallocate memory by calling <code>c.reserve()</code>.
</p>
<p>
However, this only makes sense when <code>c</code> is default-initialized. If instead the size of the <code>Container</code> 
created by <code>args...</code> is not <code>0</code>, the value passed into <code>c.reserve()</code> will be wrong, for example:
</p>
<blockquote><pre>
ranges::to&lt;std::string&gt;(std::views::single('o'), "hell");
</pre></blockquote>
<p>
The size of the <code>string</code> created by <code>"hell"</code> is already <code>4</code>, whereas the size of 
<code>R</code> is only <code>1</code>, which makes <code>c.reserve(1)</code> useless.
</p>

<p><i>[2022-07-08; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Some suggestions for NAD.
</p>
<ul>
<li>
"The intended use of those additional arguments is for allocators,
comparators, max load factors, and the like. Not...this. I can't really bring
myself to care about this example - and it adds some (admittedly small)
overhead for the by far common case."
</li>
<li>
"And it's not the right fix imo. if we wanted to put *some* constraints on Args, we could attempt to do so, although that might be challenging."
</li>
<li>
"calling reserve() is just an attempt at an optimization."
</li>
<li>
"I disagree with NAD given the fact that we have specifically designed
the "reserve" branch of the decision tree."
</li>
</ul>

<p><i>[2025-02-27; post-Hagenberg status]</i></p>

<p>
The proposed resolution needs rebasing after <a href="https://wg21.link/P2846R6" title=" reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges">P2846R6</a>
was approved in Hagenberg.
It also conflicts with LWG <a href="4066" title="ranges::to should reserve when sized_sentinel_for is satisfied (Status: New)">4066</a>.
</p>



<p id="res-3722"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If <code>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
<ol style="list-style-type: none">
<li><p>(1.1.1) &mdash; If <code>constructible_from&lt;C, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p>(1.1.2) &mdash; Otherwise, if <code>constructible_from&lt;C, from_range_t, R, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
<li><p>(1.1.3) &mdash; Otherwise, if</p>
<ol style="list-style-type: none">
<li><p>(1.1.3.1) &mdash; <code>common_range&lt;R&gt;</code> is <code>true</code>,</p></li>
<li><p>(1.1.3.2) &mdash; <code><i>cpp17-input-iterator</i>&lt;iterator_t&lt;R&gt;&gt;</code> is <code>true</code>, and</p></li>
<li><p>(1.1.3.3) &mdash; <code>constructible_from&lt;C, iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, Args...&gt;</code> is <code>true</code>:</p>
<blockquote><code>C(ranges::begin(r), ranges::end(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
</ol>
</li>
<li><p>(1.1.4) &mdash; Otherwise, if</p>
<ol style="list-style-type: none">
<li><p>(1.1.4.1) &mdash; <code>constructible_from&lt;C, Args...&gt;</code> is <code>true</code>, and</p></li>
<li><p>(1.1.4.2) &mdash; <code><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R&gt; &amp;&amp; <i>reservable-container</i>&lt;C&gt;) <ins>{
  using ST = range_size_t&lt;C&gt;;
  using CT = common_type_t&lt;ST, range_size_t&lt;R&gt;&gt;;
  auto sz = ST(CT(ranges::size(c)) + CT(ranges::size(r)));</ins>
  c.reserve(<ins>sz</ins><del>ranges::size(r)</del>);
<ins>}</ins>
ranges::copy(r, <i>container-inserter</i>&lt;range_reference_t&lt;R&gt;&gt;(c));
</pre></blockquote></li>
</ol>
</li>
</ol>
</li>
<li><p>(1.2) &mdash; Otherwise, if <code>input_range&lt;range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre></blockquote></li>
<li><p>(1.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3725"><a href="3725">3725</a>. <code>reverse_iterator::operator-&gt;</code> should not use <code>prev</code> for non-pointer iterators</h3>
<p><b>Section:</b> 24.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-06-26 <b>Last modified:</b> 2024-06-18</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.elem">issues</a> in [reverse.iter.elem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the underlying iterator is not a pointer type, <code>reverse_iterator::operator-&gt;</code> returns 
<code>prev(current).operator-&gt;()</code>. However, <code>prev</code> only works with 
<i>Cpp17BidirectionalIterator</i>, given that C++20 <code>bidirectional_iterator</code> may just be 
<i>Cpp17InputIterator</i>, we shouldn't use <code>prev</code> here.
</p>

<p><i>[2022-07-08; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Suggested to use <code>ranges::prev</code> instead.
</p>

<p><i>[2024-06-18; Jonathan adds a comment]</i></p>

<p>
It's not clear that <code class='backtick'>std::prev</code> requires <i>Cpp17InputIterator</i>,
that's the subject of LWG <a href="3197" title="std::prev should not require BidirectionalIterator (Status: New)">3197</a>.
</p>



<p id="res-3725"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 24.5.1.6 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.elem">[reverse.iter.elem]</a> as indicated:</p>

<blockquote>
<pre>
constexpr pointer operator-&gt;() const
  requires (is_pointer_v&lt;Iterator&gt; ||
            requires(const Iterator i) { i.operator-&gt;(); });
</pre>
<blockquote>
<p>
-2- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>Iterator</code> is a pointer type, equivalent to: <code>return prev(current);</code></p></li>
<li><p>(2.2) &mdash; Otherwise, equivalent to: <del><code>return prev(current).operator-&gt;();</code></del></p>
<blockquote><pre>
<ins>Iterator tmp = current;
--tmp;
return tmp.operator-&gt;();</ins>
</pre></blockquote>
</li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3728"><a href="3728">3728</a>. Can't make neither head nor tail of the description of <code>operator&lt;=&gt;(tuple, tuple)</code></h3>
<p><b>Section:</b> 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Corentin Jabot <b>Opened:</b> 2022-06-28 <b>Last modified:</b> 2022-07-08</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>operator&lt;=&gt;(tuple, tuple)</code> (22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>) is described in 
terms of imaginary tuples (<code>t<sub>tail</sub></code>, <code>u<sub>tail</sub></code>, <code>r<sub>tail</sub></code>) 
which is a bit confusing. Indeed, It is not clear that these imaginary tuples need to respect the order of 
elements of <code>u</code> and <code>t</code>, nor whether the value category of the elements in these imaginary 
tuples can or should be conserved. It is possible to reformulate and simplify that description so that  
no imaginary tuple is involved.
<p/>
The remark is copied from the similar wording of <code>operator==</code>
</p>

<p><i>[2022-07-08; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Some votes for NAD and preference for the current wording, adding "in order"
to clarify the order of elements in <code>r<sub>tail</sub></code>.
</p>



<p id="res-3728"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
    operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-4- <i><del>Effects</del><ins>Returns</ins></i>: <ins><code><i>synth-three-way</i>(get&lt;i&gt;(t), get&lt;i&gt;(u))</code> 
for the first <code>i</code> for which the result of that expression does not compare equal to <code>0</code>. If no such <code>i</code> 
exists, <code>strong_ordering::equal</code>.</ins><del>Performs a lexicographical comparison between <code>t</code> and <code>u</code>. 
For any two zero-length tuples <code>t</code> and <code>u</code>, <code>t &lt;=&gt; u</code> returns 
<code>strong_ordering::equal</code>. Otherwise, equivalent to:</del>
</p>
<blockquote><pre>
<del>if (auto c = <i>synth-three-way</i>(get&lt;0&gt;(t), get&lt;0&gt;(u)); c != 0) return c;
return t<sub>tail</sub> &lt;=&gt; u<sub>tail</sub>;</del>
</pre></blockquote>
<p>
<del>where <code>r<sub>tail</sub></code> for some tuple <code>r</code> is a tuple containing all but the first 
element of <code>r</code>.</del>
<p/>
<ins>-?- <i>Remarks</i>: The elementary <code><i>synth-three-way</i>(get&lt;i&gt;(t), get&lt;i&gt;(u))</code> 
expressions are evaluated in order from the zeroth index upwards. No element accesses are performed after 
the first invocation that results in a value that does not compare equal to <code>0</code>.</ins>
<p/>
<del>-5- [<i>Note 1</i>: The above definition does not require <code>t<sub>tail</sub></code> (or <code>u<sub>tail</sub></code>) 
to be constructed. It might not even be possible, as <code>t</code> and <code>u</code> are not required to be copy 
constructible. Also, all comparison operator functions are short circuited; they do not perform element 
accesses beyond what is required to determine the result of the comparison. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3729"><a href="3729">3729</a>. <code>std::tuple_element_t&lt;std::ranges::subrange&lt;I, S, K&gt;&gt;</code> should remove top-level <i>cv</i>-qualifiers</h3>
<p><b>Section:</b> 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-06-30 <b>Last modified:</b> 2022-07-08</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ranges.syn">active issues</a> in [ranges.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#ranges.syn">issues</a> in [ranges.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::ranges::subrange&lt;int * volatile&gt;&gt;</code> is weird but valid. The return type (deduced type for 
<code>auto</code>) of <code>std::ranges::get</code> for this type is <code>int*</code>, because the replacing of that 
(<i>cv</i>-unqualified) <code>auto</code> drops top-level <i>cv</i>-qualifiers. I think <code>get</code> is doing the 
right thing, and <code>std::tuple_element_t</code> should be consistent with the return types.
</p>

<p><i>[2022-07-08; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"This is just contrived, especially since lots of the iterator requirements
on such a type involve deprecated operations."
</p>



<p id="res-3729"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std {
  [&hellip;]
  
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;0, ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = <ins>remove_cv_t&lt;</ins>I<ins>&gt;</ins>;
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;1, ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = <ins>remove_cv_t&lt;</ins>S<ins>&gt;</ins>;
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;0, const ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = <ins>remove_cv_t&lt;</ins>I<ins>&gt;</ins>;
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;1, const ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = <ins>remove_cv_t&lt;</ins>S<ins>&gt;</ins>;
  };
}
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3730"><a href="3730">3730</a>. <code>std::ranges::drop_view</code> may have different size type from its underlying view</h3>
<p><b>Section:</b> 25.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-07-03 <b>Last modified:</b> 2022-07-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.drop.view">active issues</a> in [range.drop.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.drop.view">issues</a> in [range.drop.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The bodies of both overloads of <code>drop_view&lt;V&gt;::size</code> are specified as:
</p>
<blockquote><pre>
const auto s = ranges::size(<i>base_</i>);
const auto c = static_cast&lt;decltype(s)&gt;(<i>count_</i>);
return s &lt; c ? 0 : s - c;
</pre></blockquote>
<p>
Given the return type is specified with <code>auto</code>, the actual return type 
is the <em>promoted type</em> of the size type of the underlying view, which may be 
different from the underlying size type (e.g. if the underlying size is <code>unsigned short</code>).
<p/>
Note that <code>take_view</code> always has the same size type as its underlying view. 
So I think the difference on the size types is an oversight. On the other hand, the 
<code>const</code> used here seems redundant and inconsistent with other parts of the 
standard wording, although implementations may tend to use it.
</p>

<p><i>[2022-07-08; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"The PR is incorrect - integer-class types do not support mixed-signedess operations, so you 
have to cast one of the two first."
</p>

<p><i>[2022-07-17; Daniel comments]</i></p>

<p>
This issue should be resolved by keeping LWG <a href="3739" title="chunk_view::size should preserve the signedness of the size of the underlying range (Status: NAD)">3739</a> and <a href="3740" title="slide_view::size should preserve the signedness of underlying range's size (Status: NAD)">3740</a> in mind.
</p>


<p id="res-3730"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 25.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a>, class template <code>drop_view</code> synopsis, as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> <code>s</code> and <code><i>count_</i></code> usually have different types, but I think 
it's safe to perform comparison and subtraction, as <code><i>count_</i></code> is non-negative as long as 
the behavior is well-defined.]
</p>
</blockquote>

<blockquote>
<pre>
[&hellip;]
constexpr auto size() requires sized_range&lt;V&gt; {
  <del>const</del> auto s = ranges::size(<i>base_</i>);
  <del>const auto c = static_cast&lt;decltype(s)&gt;(<i>count_</i>);</del>
  return <ins>static_cast&lt;decltype(s)&gt;(</ins>s &lt; <del>c</del><ins><i>count_</i></ins> ? 0 : s - <del>c</del><ins><i>count_</i>)</ins>;
}

constexpr auto size() const requires sized_range&lt;const V&gt; {
  <del>const</del> auto s = ranges::size(<i>base_</i>);
  <del>const auto c = static_cast&lt;decltype(s)&gt;(<i>count_</i>);</del>
  return <ins>static_cast&lt;decltype(s)&gt;(</ins>s &lt; <del>c</del><ins><i>count_</i></ins> ? 0 : s - <del>c</del><ins><i>count_</i>)</ins>;
}
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3731"><a href="3731">3731</a>. <code>zip_view</code> and <code>adjacent_view</code> are underconstrained</h3>
<p><b>Section:</b> 25.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.view">[range.zip.view]</a>, 25.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.view">[range.adjacent.view]</a>, 25.7.33.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-07-04 <b>Last modified:</b> 2023-08-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.zip.view">issues</a> in [range.zip.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both <code>zip_view::<i>iterator</i></code>'s (25.7.25.3 <a href="https://timsong-cpp.github.io/cppwp/range.zip.iterator">[range.zip.iterator]</a>) and 
<code>adjacent_view::<i>iterator</i></code>'s (25.7.27.3 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.iterator">[range.adjacent.iterator]</a>) 
<code>operator*</code> have similar <i>Effects:</i> elements:
</p>
<blockquote><pre>
return <i>tuple-transform</i>([](auto&amp; i) -&gt; decltype(auto) { return *i; }, <i>current_</i>);
</pre></blockquote>
<p>
where <code><i>tuple-transform</i></code> is defined as:
</p>
<blockquote><pre>
template&lt;class F, class Tuple&gt;
constexpr auto <i>tuple-transform</i>(F&amp;&amp; f, Tuple&amp;&amp; tuple) { <i>// exposition only</i>
  return apply([&amp;]&lt;class... Ts&gt;(Ts&amp;&amp;... elements) {
    return <i>tuple-or-pair</i>&lt;invoke_result_t&lt;F&amp;, Ts&gt;...&gt;(
      invoke(f, std::forward&lt;Ts&gt;(elements))...
    );
  }, std::forward&lt;Tuple&gt;(tuple));
}
</pre></blockquote>
<p>
That is, <code>zip_view::<i>iterator</i></code> will invoke the <code>operator*</code> of each iterator of 
<code>Views</code> and return a <code>tuple</code> containing its <code>reference</code>.
<p/>
This is not a problem when the <code>reference</code> of iterators is actually the reference type. However, 
when the <code>operator*</code> returns a prvalue of non-movable type, <code><i>tuple-transform</i></code> will 
be ill-formed since there are no suitable constructors for <code>tuple</code>:
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct NonMovable {
  NonMovable() = default;
  NonMovable(NonMovable&amp;&amp;) = delete;
};

auto r = std::views::iota(0, 5)
       | std::views::transform([](int) { return NonMovable{}; });
auto z = std::views::zip(r);
auto f = *z.begin(); // <span style="color:red;font-weight:bolder">hard error</span>

</pre></blockquote>
<p>
We should constrain the <code>range_reference_t</code> of the underlying range to be <code>move_constructible</code> 
when it is not a reference type, which also solves similar issues in <code>zip_view::<i>iterator</i></code> and 
<code>adjacent_view::<i>iterator</i></code>'s <code>operator[]</code> and <code>iter_move</code>.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"The constraint should just be <code>move_constructible</code>."
</p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  <i>// 25.7.25 <a href="https://timsong-cpp.github.io/cppwp/range.zip">[range.zip]</a>, zip view</i>
  <ins>template&lt;class Ref&gt;
    concept <i>tuple-constructible-reference</i> = <i>see below</i>; <i>// exposition only</i></ins>

  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) <ins>&amp;&amp;
             (<i>tuple-constructible-reference</i>&lt;range_reference_t&lt;Views&gt;&gt; &amp;&amp; ...)</ins>
  class zip_view;

  [&hellip;]

  <i>// 25.7.27 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent">[range.adjacent]</a>, adjacent view</i>
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) <ins>&amp;&amp; 
             <i>tuple-constructible-reference</i>&lt;range_reference_t&lt;V&gt;&gt;</ins>
  class adjacent_view;
}
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.view">[range.zip.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  <ins>template&lt;class Ref&gt;
    concept <i>tuple-constructible-reference</i> =            <i>// exposition only</i>
      is_reference_v&lt;Ref&gt; || move_constructible&lt;Ref&gt;;</ins>
  [&hellip;]
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) <ins>&amp;&amp;
             (<i>tuple-constructible-reference</i>&lt;range_reference_t&lt;Views&gt;&gt; &amp;&amp; ...)</ins>
  class zip_view : public view_interface&lt;zip_view&lt;Views...&gt;&gt; {
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.view">[range.adjacent.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) <ins>&amp;&amp; 
             <i>tuple-constructible-reference</i>&lt;range_reference_t&lt;V&gt;&gt;</ins>
  class adjacent_view : public view_interface&lt;adjacent_view&lt;V, N&gt;&gt; {
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2022-09-25; Hewill provides improved wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]

  <ins>template&lt;class R&gt;
    concept <i>has-tuplable-ref</i> =            // <i>exposition only</i>
      move_constructible&lt;range_reference_t&lt;R&gt;&gt;;</ins>

  // <i>25.7.25 <a href="https://timsong-cpp.github.io/cppwp/range.zip">[range.zip]</a>, zip view</i>
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) <ins>&amp;&amp;
             (<i>has-tuplable-ref</i>&lt;Views&gt; &amp;&amp; ...)</ins>
  class zip_view;

  [&hellip;]

  // <i>25.7.27 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent">[range.adjacent]</a>, adjacent view</i>
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) <ins>&amp;&amp; <i>has-tuplable-ref</i>&lt;V&gt;</ins>
  class adjacent_view;

  [&hellip;]

  // <i>25.7.33 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian">[range.cartesian]</a>, cartesian product view</i>
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;) <ins>&amp;&amp;
             (<i>has-tuplable-ref</i>&lt;First&gt; &amp;&amp; ... &amp;&amp; <i>has-tuplable-ref</i>&lt;Vs&gt;)</ins>
  class cartesian_product_view;

  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.view">[range.zip.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) <ins>&amp;&amp;
             (<i>has-tuplable-ref</i>&lt;Views&gt; &amp;&amp; ...)</ins>
  class zip_view : public view_interface&lt;zip_view&lt;Views...&gt;&gt; {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.25.3 <a href="https://timsong-cpp.github.io/cppwp/range.zip.iterator">[range.zip.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) <ins>&amp;&amp;
             (<i>has-tuplable-ref</i>&lt;Views&gt; &amp;&amp; ...)</ins>
  template&lt;bool Const&gt;
  class zip_view&lt;Views...&gt;::<i>iterator</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.25.4 <a href="https://timsong-cpp.github.io/cppwp/range.zip.sentinel">[range.zip.sentinel]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) <ins>&amp;&amp;
             (<i>has-tuplable-ref</i>&lt;Views&gt; &amp;&amp; ...)</ins>
  template&lt;bool Const&gt;
  class zip_view&lt;Views...&gt;::<i>sentinel</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.view">[range.adjacent.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) <ins>&amp;&amp; <i>has-tuplable-ref</i>&lt;V&gt;</ins>
  class adjacent_view : public view_interface&lt;adjacent_view&lt;V, N&gt;&gt; {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.27.3 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.iterator">[range.adjacent.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) <ins>&amp;&amp; <i>has-tuplable-ref</i>&lt;V&gt;</ins>
  template&lt;bool Const&gt;
  class adjacent_view&lt;V, N&gt;::<i>iterator</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.27.4 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.sentinel">[range.adjacent.sentinel]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) <ins>&amp;&amp; <i>has-tuplable-ref</i>&lt;V&gt;</ins>
  template&lt;bool Const&gt;
  class adjacent_view&lt;V, N&gt;::<i>sentinel</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.33.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;) <ins>&amp;&amp;
             (<i>has-tuplable-ref</i>&lt;First&gt; &amp;&amp; ... &amp;&amp; <i>has-tuplable-ref</i>&lt;Vs&gt;)</ins>
  class cartesian_product_view : public view_interface&lt;cartesian_product_view&lt;First, Vs...&gt;&gt; {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.33.3 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.iterator">[range.cartesian.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;) <ins>&amp;&amp;
             (<i>has-tuplable-ref</i>&lt;First&gt; &amp;&amp; ... &amp;&amp; <i>has-tuplable-ref</i>&lt;Vs&gt;)</ins>
  template&lt;bool Const&gt;
  class cartesian_product_view&lt;First, Vs...&gt;::<i>iterator</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2023-08-08; Hewill provides improved wording]</i></p>




<p id="res-3731"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>
<li><p>Modify 26.2 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]

  <ins>// <i>25.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>, helper concepts</i>
  template&lt;class R&gt;
    concept <i>range-with-movable-references</i> = <i>see below</i>; // <i>exposition only</i></ins>

  // <i>25.5.3 <a href="https://timsong-cpp.github.io/cppwp/view.interface">[view.interface]</a>, class template view_interface</i>
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface;                                                             // <i>freestanding</i>

  [&hellip;]

  // <i>25.7.24 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate">[range.enumerate]</a>, enumerate view</i>
  template&lt;<del>input_range</del><ins>view</ins> V&gt;
    requires <ins><i>range-with-movable-references</i>&lt;V&gt;</ins><del>view&lt;View&gt;</del>
  class enumerate_view;                                                             // <i>freestanding</i>

  [&hellip;]

  // <i>25.7.25 <a href="https://timsong-cpp.github.io/cppwp/range.zip">[range.zip]</a>, zip view</i>
  template&lt;<ins><i>range-with-movable-references</i></ins><del>input_range</del>... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  class zip_view;                                                                   // <i>freestanding</i>

  [&hellip;]

  // <i>25.7.27 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent">[range.adjacent]</a>, adjacent view</i>
  template&lt;<ins><i>range-with-movable-references</i></ins><del>forward_range</del> V, size_t N&gt;
    requires <ins>forward_range&lt;V&gt; &amp;&amp;</ins> view&lt;V&gt; &amp;&amp; (N &gt; 0)
  class adjacent_view;                                                              // <i>freestanding</i>

  [&hellip;]

  // <i>25.7.33 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian">[range.cartesian]</a>, cartesian product view</i>
  template&lt;<ins><i>range-with-movable-references</i></ins><del>input_range</del> First, 
           <ins><i>range-with-movable-references</i></ins><del>forward_range</del>... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; <ins>(forward_range&lt;Vs&gt; &amp;&amp;</ins> view&lt;Vs&gt;<ins>)</ins>)
  class cartesian_product_view;                                                     // <i>freestanding</i>

  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.view">[range.zip.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  
  template&lt;<ins><i>range-with-movable-references</i></ins><del>input_range</del>... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  class zip_view : public view_interface&lt;zip_view&lt;Views...&gt;&gt; {
    [&hellip;]
  public:
    [&hellip;]
    constexpr auto begin() const requires (<ins><i>range-with-movable-references</i></ins><del>range</del>&lt;const Views&gt; &amp;&amp; ...) {
      return <i>iterator</i>&lt;true&gt;(<i>tuple-transform</i>(ranges::begin, <i>views_</i>));
    }
    [&hellip;]
    constexpr auto end() const requires (<ins><i>range-with-movable-references</i></ins><del>range</del>&lt;const Views&gt; &amp;&amp; ...) {
      if constexpr (!<i>zip-is-common</i>&lt;const Views...&gt;) {
        return <i>sentinel</i>&lt;true&gt;(<i>tuple-transform</i>(ranges::end, <i>views_</i>));
      } else if constexpr ((random_access_range&lt;const Views&gt; &amp;&amp; ...)) {
        return begin() + iter_difference_t&lt;<i>iterator</i>&lt;true&gt;&gt;(size());
      } else {
        return <i>iterator</i>&lt;true&gt;(<i>tuple-transform</i>(ranges::end, <i>views_</i>));
      }
    }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.25.3 <a href="https://timsong-cpp.github.io/cppwp/range.zip.iterator">[range.zip.iterator]</a> as indicated:</p>
<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;<ins><i>range-with-movable-references</i></ins><del>input_range</del>... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  template&lt;bool Const&gt;
  class zip_view&lt;Views...&gt;::<i>iterator</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.25.4 <a href="https://timsong-cpp.github.io/cppwp/range.zip.sentinel">[range.zip.sentinel]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;<ins><i>range-with-movable-references</i></ins><del>input_range</del>... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  template&lt;bool Const&gt;
  class zip_view&lt;Views...&gt;::<i>sentinel</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.27.2 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.view">[range.adjacent.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;<ins><i>range-with-movable-references</i></ins><del>forward_range</del> V, size_t N&gt;
    requires <ins>forward_range&lt;V&gt; &amp;&amp;</ins> view&lt;V&gt; &amp;&amp; (N &gt; 0)
  class adjacent_view : public view_interface&lt;adjacent_view&lt;V, N&gt;&gt; {
    [&hellip;]
  public:
    [&hellip;]
    constexpr auto begin() const requires <ins><i>range-with-movable-references</i></ins><del>range</del>&lt;const V&gt; {
      return <i>iterator</i>&lt;true&gt;(ranges::begin(<i>base_</i>), ranges::end(<i>base_</i>));
    }
    [&hellip;]
    constexpr auto end() const requires <ins><i>range-with-movable-references</i></ins><del>range</del>&lt;const V&gt; {
      if constexpr (common_range&lt;const V&gt;) {
        return <i>iterator</i>&lt;true&gt;(<i>as-sentinel</i>{}, ranges::begin(<i>base_</i>), ranges::end(<i>base_</i>));
      } else {
        return <i>sentinel</i>&lt;true&gt;(ranges::end(<i>base_</i>));
      }
    }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.27.3 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.iterator">[range.adjacent.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;<ins><i>range-with-movable-references</i></ins><del>forward_range</del> V, size_t N&gt;
    requires <ins>forward_range&lt;V&gt; &amp;&amp;</ins> view&lt;V&gt; &amp;&amp; (N &gt; 0)
  template&lt;bool Const&gt;
  class adjacent_view&lt;V, N&gt;::<i>iterator</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.27.4 <a href="https://timsong-cpp.github.io/cppwp/range.adjacent.sentinel">[range.adjacent.sentinel]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;<ins><i>range-with-movable-references</i></ins><del>forward_range</del> V, size_t N&gt;
    requires <ins>forward_range&lt;V&gt; &amp;&amp;</ins> view&lt;V&gt; &amp;&amp; (N &gt; 0)
  template&lt;bool Const&gt;
  class adjacent_view&lt;V, N&gt;::<i>sentinel</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.33.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;<ins><i>range-with-movable-references</i></ins><del>input_range</del> First, 
           <ins><i>range-with-movable-references</i></ins><del>forward_range</del>... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; <ins>(forward_range&lt;Vs&gt; &amp;&amp;</ins> view&lt;Vs&gt;<ins>)</ins>)
  class cartesian_product_view : public view_interface&lt;cartesian_product_view&lt;First, Vs...&gt;&gt; {
    [&hellip;]
  public:
    [&hellip;]
    constexpr <i>iterator</i>&lt;true&gt; begin() const
      requires (<ins><i>range-with-movable-references</i></ins><del>range</del>&lt;const First&gt; &amp;&amp; ... &amp;&amp; 
                <ins><i>range-with-movable-references</i></ins><del>range</del>&lt;const Vs&gt;);
    [&hellip;]
    constexpr <i>iterator</i>&lt;true&gt; end() const
      requires <ins>(<i>range-with-movable-references</i>&lt;const First&gt; &amp;&amp; ... &amp;&amp; 
                <i>range-with-movable-references</i>&lt;const Vs&gt;) &amp;&amp;</ins>
               <i>cartesian-product-is-common</i>&lt;const First, const Vs...&gt;;
    [&hellip;]
  };
}
</pre>
</blockquote>

<blockquote>
[&hellip;]
<pre>
constexpr <i>iterator</i>&lt;true&gt; begin() const
  requires (<ins><i>range-with-movable-references</i></ins><del>range</del>&lt;const First&gt; &amp;&amp; ... &amp;&amp; 
            <ins><i>range-with-movable-references</i></ins><del>range</del>&lt;const Vs&gt;);
</pre>
<p>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return <i>iterator</i>&lt;true&gt;(*this, <i>tuple-transform</i>(ranges::begin, <i>bases_</i>));
</pre></blockquote>
<pre>
constexpr <i>iterator</i>&lt;false&gt; end()
  requires ((!<i>simple-view</i>&lt;First&gt; || ... || !<i>simple-view</i>&lt;Vs&gt;)
    &amp;&amp; <i>cartesian-product-is-common</i>&lt;First, Vs...&gt;);
constexpr <i>iterator</i>&lt;true&gt; end() const
  requires <ins>(<i>range-with-movable-references</i>&lt;const First&gt; &amp;&amp; ... &amp;&amp; <i>range-with-movable-references</i>&lt;const Vs&gt;)
    &amp;&amp;</ins> <i>cartesian-product-is-common</i>&lt;const First, const Vs...&gt;;
</pre>
<p>
-4- Let:
</p>
<blockquote>
[&hellip;]
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.33.3 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.iterator">[range.cartesian.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;<ins><i>range-with-movable-references</i></ins><del>input_range</del> First, <ins><i>range-with-movable-references</i></ins><del>forward_range</del>... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; <ins>(forward_range&lt;Vs&gt; &amp;&amp;</ins> view&lt;Vs&gt;<ins>)</ins>)
  class cartesian_product_view&lt;First, Vs...&gt;::<i>iterator</i> {
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3744"><a href="3744">3744</a>. <code>copy_symlink(junction, new_symlink)</code>'s behavior is unclear</h3>
<p><b>Section:</b> 31.12.13.6 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy.symlink">[fs.op.copy.symlink]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicole Mazzuca <b>Opened:</b> 2022-07-25 <b>Last modified:</b> 2022-08-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification for <code>copy_symlink</code> is (31.12.13.6 <a href="https://timsong-cpp.github.io/cppwp/fs.op.copy.symlink">[fs.op.copy.symlink]</a>):
</p>
<blockquote><p>
<i>Effects</i>: Equivalent to <code><i>function</i>(read_symlink(existing_symlink), new_symlink)</code> 
or <code><i>function</i>(read_symlink(existing_symlink, ec), new_symlink, ec)</code>, respectively,
where in each case <code><i>function</i></code> is <code>create_symlink</code> or 
<code>create_directory_symlink</code> as appropriate.
</p></blockquote>
<p>
The specification for <code>read_symlink</code> is (31.12.13.29 <a href="https://timsong-cpp.github.io/cppwp/fs.op.read.symlink">[fs.op.read.symlink]</a>):
</p>
<blockquote><p>
<i>Returns</i>: If <code>p</code> resolves to a symbolic link, a path object containing the contents of 
that symbolic link.
</p></blockquote>
<p>
And finally, the definition of a "symbolic link" is (31.12.1 <a href="https://timsong-cpp.github.io/cppwp/fs.general">[fs.general]</a>):
</p>
<blockquote><p>
A <i>symbolic link</i> is a type of file with the property that when the file is encountered during pathname
resolution (31.12.6 <a href="https://timsong-cpp.github.io/cppwp/fs.class.path">[fs.class.path]</a>), a string stored by the file is used to modify the pathname resolution.
</p></blockquote>
<p>
On Unix, <code>symlink</code> is the only kind of symbolic link. However, on Windows, there are symbolic 
link files which are <em>not</em> <code>symlink</code>s (app execution aliases and junctions) &mdash; this 
means that <code>read_symlink</code> should almost certainly get the target of these files if possible. 
However, <code>copy_symlink</code> specifically requires creating a <em><code>symlink</code></em>, not whatever 
type of file was there originally. IMO, <code>copy_symlink</code> should require its target to be a symlink. 
I think the original assumption was that <code>read_symlink</code> would take care of that for 
<code>copy_symlink</code>; this is clearly not the case on Windows, though.
</p>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3744"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3748"><a href="3748">3748</a>. <code>common_iterator</code> and <code>counted_iterator</code>' <code>operator-</code> are missing cast to return type</h3>
<p><b>Section:</b> 24.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/common.iter.cmp">[common.iter.cmp]</a>, 24.5.7.5 <a href="https://timsong-cpp.github.io/cppwp/counted.iter.nav">[counted.iter.nav]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-08-01 <b>Last modified:</b> 2022-08-23</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both <code>common_iterator</code> and <code>counted_iterator</code> explicitly specify that the 
return type of their <code>operator-</code> is <code>iter_difference_t&lt;I2&gt;</code>, however, 
given that the calculated type may be <code>iter_difference_t&lt;I&gt;</code>, we should do 
an explicit conversion here since the latter is not necessarily implicitly convertible to the former:
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct Y;

struct X {
  X(Y);
  using difference_type =
#ifdef __GNUC__
  std::ranges::__detail::__max_diff_type;
#elif defined(_MSC_VER)
  std::_Signed128;
#endif
  int&amp; operator*() const;
  X&amp; operator++();
  void operator++(int);
};

struct Y {
  using difference_type = std::ptrdiff_t;
  int&amp; operator*() const;
  Y&amp; operator++();
  void operator++(int);
};

int main() {
  std::counted_iterator&lt;Y&gt; y;
  return std::counted_iterator&lt;X&gt;(y) - y; // <span style="color:red;font-weight:bolder">hard error in stdlibc++ and MSVC-STL</span>
}
</pre></blockquote>
<p>
<b>Daniel:</b>
</p>
<blockquote class="note">
<p>
This issue shouldn't we voted until a decision for LWG <a href="3749" title="common_iterator should handle integer-class difference types (Status: WP)">3749</a> has been made, because the first part of
it overlaps with LWG <a href="3749" title="common_iterator should handle integer-class difference types (Status: WP)">3749</a>'s second part.
</p>
</blockquote>

<p><i>[2022-08-23; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"I think <code>common_iterator</code> should <em>reject</em> iterators with
integer-class difference types since it can't possibly achieve the design intent
of adapting them to <i>Cpp17Iterator</i>s, so this issue should only affect
<code>counted_iterator</code>."
</p>
<p>
"If the difference types of <code>I</code> and <code>I2</code> are different
then the <code>operator-</code> can't be used to model
<code>sized_sentinel_for</code>,
since <code>i - i2</code> and <code>i2 - i</code> would have different types.
Providing <code>operator-</code> under such circumstances seems
to be of dubious value."
</p>



<p id="res-3748"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>
<li><p>Modify 24.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/common.iter.cmp">[common.iter.cmp]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;sized_sentinel_for&lt;I&gt; I2, sized_sentinel_for&lt;I&gt; S2>
  requires sized_sentinel_for&lt;S, I2&gt;
friend constexpr iter_difference_t&lt;I2&gt; operator-(
  const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</pre>
<blockquote>
<p>
-5- <i>Preconditions</i>: <code>x.v_.valueless_by_exception()</code> and <code>y.v_.valueless_by_exception()</code> 
are each <code>false</code>.
<p/>
-6- <i>Returns</i>: <code>0</code> if <code><i>i</i></code> and <code><i>j</i></code> are each <code>1</code>, and otherwise 
<ins><code>static_cast&lt;iter_difference_t&lt;I2&gt;&gt;(</code></ins><code>get&lt;<i>i</i>&gt;(x.v_) - 
get&lt;<i>j</i>&gt;(y.v_)</code><ins><code>)</code></ins>, where <code><i>i</i></code> is <code>x.v_.index()</code> 
and <code><i>j</i></code> is <code>y.v_.index()</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 24.5.7.5 <a href="https://timsong-cpp.github.io/cppwp/counted.iter.nav">[counted.iter.nav]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;common_with&lt;I&gt; I2&gt;
  friend constexpr iter_difference_t&lt;I2&gt; operator-(
    const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
</pre>
<blockquote>
<p>
-13- <i>Preconditions</i>: <code>x</code> and <code>y</code> refer to elements of the same sequence (24.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/counted.iterator">[counted.iterator]</a>).
<p/>
-14- <i>Effects</i>: Equivalent to: <code>return <ins>static_cast&lt;iter_difference_t&lt;I2&gt;&gt;(</ins>y.length - 
  x.length<ins>)</ins>;</code>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3758"><a href="3758">3758</a>. Element-relocating operations of <code>std::vector</code> and <code>std::deque</code> 
should conditionally require <i>Cpp17CopyInsertable</i> in their preconditions</h3>
<p><b>Section:</b> 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a>, 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>, 23.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a>, 23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-08-24 <b>Last modified:</b> 2022-11-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is raised from <a href="https://github.com/cplusplus/draft/issues/5776">editorial issue #5776</a>.
<p/>
In order to achieve strong exception safety, some operations of <code>std:vector</code> and 
<code>std::deque</code> may use copy insertion for relocation of old elements, if move construction 
of its element type is potentially throwing and copy insertion is available. However, currently 
only <i>Cpp17MoveInsertable</i> is mentioned in many of their Preconditions (e.g. those of 
<code>insert</code> for rvalues), which seemly fails to cover the cases in which copy insertion is 
formally invalid but the semantic requirements of <i>Cpp17CopyInsertable</i> are not met.
<p/>
Perhaps we should create a new named requirement for these operations, which is equivalent to 
<i>Cpp17CopyInsertable</i> when <code>!is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; 
is_copy_constructible_v&lt;T&gt;</code> is <code>true</code>, and equivalent to <i>Cpp17MoveInsertable</i> 
otherwise.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
Jonathan: I think the point (which LWG 3758 fails to explain clearly) is that today's implementations 
sometimes use copy insertion when move insertion is syntactically valid, but is potentially-throwing. 
But the preconditions don't require copy insertion. If <code>vector::resize(size_type)</code> decides to 
use copy construction, because move construction might throw and the type is copy constructible (which 
is implied to be permitted by the <i>Remarks</i>), do we require <i>Cpp17CopyInsertable</i>'s semantic 
requirement that the new value is equivalent to the one we copied? We don't say so.<br/>
tl;dr The user is trying to resize a vector and the value type is <i>Cpp17MoveInsertable</i> into the vector, 
but the implementation decides to copy not move. What are the preconditions on the user's type?
</p>

<p><i>[2022-11-06; Daniel comments]</i></p>

<p>
This issue has considerable overlap with LWG <a href="2158" title="Conditional copy&#47;move in std::vector (Status: Open)">2158</a>.
</p>


<p id="res-3758"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3763"><a href="3763">3763</a>. Should range adaptor iterators only provide <code>iterator_category</code> when its 
<code>difference_type</code> is not an integer-class type?</h3>
<p><b>Section:</b> 25.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.iterator">[range.repeat.iterator]</a>, 25.7.33.3 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.iterator">[range.cartesian.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-08-27 <b>Last modified:</b> 2023-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After <a href="https://wg21.link/P2259" title=" Repairing input range adaptors and counted_iterator">P2259</a>, the range adaptor' iterators only provide <code>iterator_category</code> member when 
the underlying range models <code>forward_range</code>, which is mainly based on the premise that all valid C++20 
forward iterators meet the C++17 input iterator requirements.
<p/>
However, this is not strictly correct. When the underlying range's <code>difference_type</code> is an integer-class 
type, its iterator does not conform <i>Cpp17InputIterator</i>.
<p/>
Although <code>iterator_traits&lt;I&gt;::iterator_category</code> will still deduce the correct category in this 
case since these iterators have no <code>reference</code> member, it might be misleading to provide these 
incorrect member types. 
<p/>
Do we need to aggressively prohibit these iterators from providing <code>iterator_category</code> when their 
difference type is an integer-class type?
<p/>
The proposed resolution makes <code>repeat_view::<i>iterator</i></code> conditionally provide 
<code>iterator_category</code>, because it explicitly mentions <code><i>IOTA-DIFF-T</i>(<i>index-type</i>)</code> 
in the definition of <code>difference_type</code>, which makes it consistent with LWG <a href="3670" title="Cpp17InputIterators don't have integer-class difference types (Status: C++23)">3670</a>.
<p/>
It also removes the <code>reference</code> member type of <code>cartesian_product_view::<i>iterator</i></code>, 
which prevents <code>iterator_traits&lt;I&gt;::iterator_category</code> from being aliased to its member 
<code>iterator_category</code>, so that <code>iterator_traits&lt;I&gt;::iterator_category</code> will not always 
be an <code>input_iterator_tag</code> when its <code>difference_type</code> is an integer-class type.
<p/>
This is also consistent with other range adaptors, as none of them have a <code>reference</code> member type.
</p>

<p><i>[2022-09-23; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3763"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>

<li><p>Modify 25.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.iterator">[range.repeat.iterator]</a> as indicated:</p>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;move_constructible W, semiregular Bound = unreachable_sentinel_t&gt;
    requires (is_object_v&lt;W> &amp;&amp; same_as&lt;W, remove_cv_t&lt;W&gt;&gt; &amp;&amp;
              (<i>is-integer-like</i>&lt;Bound> || same_as&lt;Bound, unreachable_sentinel_t&gt;))
  class repeat_view&lt;W, Bound>::<i>iterator</i> {
  private:
    using <i>index-type</i> =                  <i>// exposition only</i>
      conditional_t&lt;same_as&lt;Bound, unreachable_sentinel_t&gt;, ptrdiff_t, Bound&gt;;
    const W* <i>value_</i> = nullptr;          <i>// exposition only</i>
    <i>index-type</i> <i>current_</i> = <i>index-type</i>(); <i>// exposition only</i>

    constexpr explicit <i>iterator</i>(const W* value, <i>index-type</i> b = <i>index-type</i>());   <i>// exposition only</i>

  public:
    using iterator_concept = random_access_iterator_tag;
    using iterator_category = random_access_iterator_tag;           <ins><i>// present only if difference_type</i></ins>
                                                                    <ins><i>// is an integral type</i></ins>
    using value_type = W;
    using difference_type = conditional_t&lt;<i>is-signed-integer-like</i>&lt;<i>index-type</i>&gt;,
        <i>index-type</i>,
        <i>IOTA-DIFF-T</i>(<i>index-type</i>)>; 
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.33.3 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.iterator">[range.cartesian.iterator]</a> as indicated:</p>
<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;)
  template&lt;bool Const&gt;
  class cartesian_product_view&lt;First, Vs...&gt;::<i>iterator</i> {
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept  = <i>see below</i>;
    using value_type = tuple&lt;range_value_t&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt;,
      range_value_t&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;...&gt;;
    <del>using reference = tuple&lt;range_reference_t&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt;,
      range_reference_t&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;...&gt;;</del>
    using difference_type = <i>see below</i>;
    [&hellip;]
  
    constexpr <ins>auto</ins><del>reference</del> operator[](difference_type n) const
      requires <i>cartesian-product-is-random-access</i>&lt;Const, First, Vs...&gt;;
  
    [&hellip;]
  };
}
</pre>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
constexpr <ins>auto</ins><del>reference</del> operator[](difference_type n) const
  requires <i>cartesian-product-is-random-access</i>&lt;Const, First, Vs...&gt;;
</pre>
<blockquote>
<p>
-24- <i>Effects</i>: <code>return *((*this) + n);</code>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3777"><a href="3777">3777</a>. Common <code>cartesian_product_view</code> produces an invalid range if the first range is input and one of the ranges is empty</h3>
<p><b>Section:</b> 25.7.33.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2022-09-12 <b>Last modified:</b> 2023-02-07</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In case when <code>cartesian_product_view</code> is common and one of the inner ranges is empty, 
it needs to produce equal iterators from <code>begin</code>/<code>end</code>. We currently create a 
sequence of <code>begin</code> iterators as both <code>begin</code> and <code>end</code> iterators. This 
assumes that <code>begin</code> iterator is copyable, which may not be the case with the input range, 
even in the case if that range is common &mdash; in such case, we require that only sentinel 
is semantically copy-constructible, not begin even if they are the same type.
<p/>
To illustrate, C++98 input iterators (like <code>directory_iterator</code>) are syntactically 
copy-constructible, but only default constructed object, that corresponds to sentinels are 
semantically copyable &mdash; the copy produces an equivalent result. As a consequence for 
<code>directory_iterator d</code>, and empty <code>std::string_view sv</code>, the 
<code>view::cartesian_product(d, sv)</code> produces an invalid range.
<p/>
To fix the problem, we need to move the logic of adjusting the first range iterator to return 
<code>[end, begin, ..., begin]</code> for <code>begin</code>. This is safe, as we require the end 
to be always semantically copy-constructible. This again can be done only if computing the end 
can be done in <code>&#x1d4aa;(1)</code> i.e. the first range is common.
</p>

<p><i>[2022-09-28; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><i>[2022-09-28; LWG telecon]</i></p>

<p>
Discussed issue. Tim suggested to add a new semantic requirement to
<code>sentinel_for</code> that when <code>S</code> and <code>I</code> are the same type
then <code>i == i</code> is true for any non-singular <code>i</code> of type <code>I</code>.
</p>



<p id="res-3777"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a>.
</p>

<ol>

<li><p>Modify 25.7.33.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: We can optimize the comparison with <code>default_sentinel_t</code> to compare only the iterator
to the first range if the range is common. This is observable, as we call comparison of user-provided iterators.]
</p>
</blockquote>

<blockquote>
<pre>
constexpr <i>iterator</i>&lt;false&gt; begin()
  requires (!<i>simple-view</i>&lt;First&gt; || ... || !<i>simple-view</i>&lt;Vs&gt;);
</pre>
<blockquote>
<p>
<del>-2- <i>Effects</i>: Equivalent to: <code>return <i>iterator</i>&lt;false&gt;(<i>tuple-transform</i>(ranges::begin, <i>bases_</i>));</code></del>
</p>
</blockquote>
<pre>
constexpr <i>iterator</i>&lt;true&gt; begin() const
  requires (range&lt;const First&gt; &amp;&amp; ... &amp;&amp; range&lt;const Vs&gt;);
</pre>
<blockquote>
<p>
<del>-3- <i>Effects</i>: Equivalent to: <code>return <i>iterator</i>&lt;true&gt;(<i>tuple-transform</i>(ranges::begin, <i>bases_</i>));</code></del>
</p>
</blockquote>
<pre>
constexpr <i>iterator</i>&lt;false&gt; end()
  requires ((!<i>simple-view</i>&lt;First&gt; || ... || !<i>simple-view</i>&lt;Vs&gt;)
    &amp;&amp; <i>cartesian-product-is-common</i>&lt;First, Vs...&gt;);
constexpr <i>iterator</i>&lt;true&gt; end() const
  requires <i>cartesian-product-is-common</i>&lt;const First, const Vs...&gt;;
</pre>
<blockquote>
<p>
-4- Let:
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <code><i>is-const</i></code> be <code>true</code> for the const-qualified overload<ins>s</ins>, and <code>false</code> otherwise;</p></li>
<li><p><ins>(4.?) &mdash; <code><i>is-end</i></code> be <code>true</code> for the <code>end</code> overloads, and <code>false</code> otherwise;</ins></p></li>
<li><p>(4.2) &mdash; <code><i>is-empty</i></code> be <code>true</code> if the expression <code>ranges::empty(rng)</code> is <code>true</code> 
for any <code>rng</code> among the underlying ranges except the first one and <code>false</code> otherwise; and</p></li>
<li><p>(4.3) &mdash; <code><i>begin-or-first-end</i>(rng)</code> be expression-equivalent to 
<code><ins><i>is-end</i> || <i>is-empty</i> ? <i>cartesian-common-arg-end</i>(rng) : 
ranges::begin(rng)</ins><del><i>is-empty</i> ? ranges::begin(rng) : <i>cartesian-common-arg-end</i>(rng)</del></code> 
if <ins><code><i>cartesian-product-common-arg</i>&lt;<i>maybe-const</i>&lt;<i>is-const</i>, First&gt;&gt;</code> is <code>true</code> and</ins> 
<code>rng</code> is the first underlying range<ins>,</ins> and <code>ranges::begin(rng)</code>
otherwise.</p></li>
</ol>
<p>
-5- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
iterator&lt;<i>is-const</i>&gt; it(<i>tuple-transform</i>(
  [](auto&amp; rng){ return <i>begin-or-first-end</i>(rng); }, <i>bases_</i>));
return it;
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.33.3 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.iterator">[range.cartesian.iterator]</a> as indicated:</p>

<blockquote>
<pre>
friend constexpr bool operator==(const <i>iterator</i>&amp; x, default_sentinel_t);
</pre>
<blockquote>
<p>
-26- <i>Returns</i>:
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; If <code><i>cartesian-product-common-arg</i>&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt;</code> 
is <code>true</code>, returns <code>std::get&lt;0&gt;(x.<i>current_</i>) == 
ranges::end(std::get&lt;0&gt;(x.<i>parent_</i>-&gt;<i>bases_</i>))</code>.</ins></p></li>
<li><p><ins>(?.2) &mdash; Otherwise, </ins> <del><code>true</code></del> if <code>std::get&lt;<i>i</i>&gt;(x.<i>current_</i>) == 
ranges::end(std::get&lt;<i>i</i>&gt;(x.<i>parent_</i>-&gt;<i>bases_</i>))</code> is <code>true</code> 
for any integer <code>0 &le; <i>i</i> &le; sizeof...(Vs)</code><ins>,</ins><del>; otherwise, <code>false</code></del> 
<ins>returns <code>true</code>.</ins></p></li>
<li><p><ins>(?.3) &mdash; Otherwise, returns <code>false</code></ins>.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3783"><a href="3783">3783</a>. <code>views::common</code> may not be a range adaptor object</h3>
<p><b>Section:</b> 24.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/common.iterator">[common.iterator]</a>, 24.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/common.iter.cmp">[common.iter.cmp]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-09-18 <b>Last modified:</b> 2022-10-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#common.iterator">active issues</a> in [common.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#common.iterator">issues</a> in [common.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P2325R3" title=" Views should not be required to be default constructible">P2325R3</a> makes <code>input_or_output_iterator</code> no longer require <code>default_initializable</code>, 
which means that the template parameter <code>I</code> of <code>common_iterator</code> no longer requires 
<code>default_initializable</code>.
<p/>
In this case, since <code>common_iterator</code> itself cannot be default-constructed, it can never be a valid 
sentinel even if it can be compared to itself. Furthermore, this also makes <code>views::common</code> return a 
non-<code>range</code> even if it is well-formed (<a href="https://godbolt.org/z/dn4c7M57W">online example</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v;
  auto r = std::views::counted(std::back_inserter(v), 3);
  auto cr = r | std::views::common;
  static_assert(std::ranges::range&lt;decltype(cr)&gt;); // <span style="color:red;font-weight:bolder">failed</span>
}
</pre></blockquote>
<p>
which causes <code>views::common</code> to be unable to convert a <code>range</code> into a <code>view</code>, 
making it not a valid range adaptor.
<p/>
I think <code>common_iterator</code> should always be <code>default_initializable</code>, 
which makes it eligible to be a legitimate sentinel.
<p/>
The proposed resolution provides a default constructor for <code>common_iterator</code> when <code>I</code> is 
not <code>default_initializable</code>, in which case constructs the <code>variant</code> with an alternative type 
of <code>S</code>.
</p>

<p><i>[2022-09-28; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"The P/R means that sometimes the variant containers an iterator and sometimes
contains a sentinel, depending on whether the iterator is default constructible.
Always constructing a sentinel would be more consistent."
</p>



<p id="res-3783"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>

<li><p>Modify 24.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/common.iterator">[common.iterator]</a>, class template <code>common_iterator</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    requires (!same_as&lt;I, S&gt; &amp;&amp; copyable&lt;I&gt;)
  class common_iterator {
  public:
    constexpr common_iterator() requires default_initializable&lt;I&gt; = default;
    <ins>constexpr common_iterator();</ins>
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 24.5.5.3 <a href="https://timsong-cpp.github.io/cppwp/common.iter.const">[common.iter.const]</a> as indicated:</p>

<blockquote>
<pre>
<ins>constexpr common_iterator();</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes <code>v_</code> as if by <code>v_{in_place_type&lt;S&gt;}</code>.</ins>
</p>
</blockquote>
<pre>
constexpr common_iterator(I i);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code>v_</code> as if by <code>v_{in_place_type&lt;I&gt;, std::move(i)}</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3793"><a href="3793">3793</a>. Requirements for some algorithms' <code>Size</code> template parameters are unclear</h3>
<p><b>Section:</b> 26.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a>, 26.6.15 <a href="https://timsong-cpp.github.io/cppwp/alg.search">[alg.search]</a>, 26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>, 26.7.6 <a href="https://timsong-cpp.github.io/cppwp/alg.fill">[alg.fill]</a>, 26.7.7 <a href="https://timsong-cpp.github.io/cppwp/alg.generate">[alg.generate]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-10-05 <b>Last modified:</b> 2022-10-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.foreach">active issues</a> in [alg.foreach].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Algorithms <code>std::for_each_n</code>, <code>std::search_n</code>, <code>std::copy_n</code>, 
<code>std::fill_n</code>, and <code>std::generate_n</code> have similar requirements for the 
<code>Size</code> template parameter in <i>Mandates</i>, requiring <code>Size</code> to be 
convertible to an integral type.
<p/>
However, it is currently underspecified to which integral type <code>Size</code> is 
converted before further operations. There is implementation divergence:
</p>
<blockquote>
<ul>
<li><p><a href="https://github.com/gcc-mirror/gcc/blob/df4c584c567263fdcd57d8376f24f29477a892b2/libstdc%2B%2B-v3/include/bits/stl_algobase.h#L1005-L1052">libstdc++</a> 
and <a href="https://github.com/llvm/llvm-project/blob/3e97e9423742b8ad07358d01b63ffbedde23b2a4/libcxx/include/__utility/convert_to_integral.h#L24-L68">libc++</a> 
use an overload set to determine the target type, and</p></li>
<li><p><a href="https://github.com/microsoft/STL/blob/65aab97a8e75e7ba409002e518ed799006dfb285/stl/inc/xutility#L352-L353">MSVC STL</a> 
simply chooses <code>std::ptrdiff_t</code> when <code>Size</code> is not an integral 
type.</p></li>
</ul>
</blockquote>
<p>
It is also notable that when the conversion from the source type to integral types 
is sufficiently ambiguous, none of these implementations accepts such a source type.
<p/>
For example, currently the following program <a href="https://godbolt.org/z/KdK9dqWco">is rejected by all 
mainstream implementations</a>.
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;

struct BadFrom {
  operator short() const { return 1; }
  operator unsigned short() const { return 1; }
};

int main()
{
  int arr[42]{};
  std::for_each_n(arr, BadFrom{}, [&amp;arr](int i)
  {
    std::printf("%d\n", i);
  });
}
</pre></blockquote>
<p>
I think libc++'s strategy make the most sense. But is it really intended to support using a 
floating-point type or a class type as <code>Size</code>?
<p/>
<b>Daniel:</b>
<p/>
The conversion from class type was indeed intended, see the original wording for LWG
<a href="3213" title="for_each_n and copy_n missing requirements for Size (Status: Resolved)">3213</a>, which was transferred to <a href="https://wg21.link/P1718R2" title=" Mandating the Standard Library: Clause 25 - Algorithms library">P1718R2</a>.
<p/>
See also LWG <a href="3439" title="&quot;Distance&quot; template parameter is underspecified (Status: New)">3439</a> for a similar underspecified situation for template parameter 
<code>Distance</code> and for the underspecified <code>Size</code> template parameter in
various <code>uninitialized_*_n</code> and <code>destroy_n</code> algorithms in 
26.11.2 <a href="https://timsong-cpp.github.io/cppwp/special.mem.concepts">[special.mem.concepts]</a>.
<p/>
<code>ranges::destroy_n</code> has the luxury to simply require <code>iter_difference_t&lt;I&gt;</code>.
</p>

<p><i>[2022-10-12; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3793"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3794"><a href="3794">3794</a>. <code>std::filesystem::path::iterator::reference</code> should be allowed to be <code>std::filesystem::path</code></h3>
<p><b>Section:</b> 31.12.6.6 <a href="https://timsong-cpp.github.io/cppwp/fs.path.itr">[fs.path.itr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-10-17 <b>Last modified:</b> 2022-11-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.path.itr">issues</a> in [fs.path.itr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, 31.12.6.6 <a href="https://timsong-cpp.github.io/cppwp/fs.path.itr">[fs.path.itr]</a>/2 effectively requires <code>std::filesystem::path::iterator::reference</code> to be 
a reference type, due to the requirements for (legacy) bidirectional iterators. However, it's reasonable for the 
<code>operator*</code> to return <code>path</code> by value, which can make the iterator model <code>std::bidirectional_iterator</code>, 
be compatible with <code>std::reverse_iterator</code>, and avoid complicated data structures (e.g. those in libstdc++) 
for achieving such purpose.
<p/>
libc++ is already doing so. I think we should make such a strategy conforming.
</p>

<p><i>[2022-11-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3794"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 31.12.6.6 <a href="https://timsong-cpp.github.io/cppwp/fs.path.itr">[fs.path.itr]</a> as indicated:</p>

<blockquote>
<p>
-2- A <code>path::iterator</code> is a constant iterator meeting all the requirements of a bidirectional iterator 
(24.3.5.6 <a href="https://timsong-cpp.github.io/cppwp/bidirectional.iterators">[bidirectional.iterators]</a>) except that, for dereferenceable iterators <code>a</code> and <code>b</code> of 
type <code>path::iterator</code> with <code>a == b</code>, there is no requirement that <code>*a</code> and <code>*b</code> 
are bound to the same object<ins>, and its <code>reference</code> may be <code>path</code></ins>. Its <code>value_type</code> is <code>path</code>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3797"><a href="3797">3797</a>. <code>elements_view</code> insufficiently constrained</h3>
<p><b>Section:</b> 25.7.23.2 <a href="https://timsong-cpp.github.io/cppwp/range.elements.view">[range.elements.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hui Xie <b>Opened:</b> 2022-10-21 <b>Last modified:</b> 2022-11-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.elements.view">issues</a> in [range.elements.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue came up when I tried to integrate the C++23 changes to tuple-like into <code>ranges::elements_view</code> 
in libc++. Given the following test:
</p>
<blockquote><pre>
Using SubRange = ranges::subrange&lt;MoveOnlyIter, Sent&gt;;
std::vector&lt;SubRange&gt; srs = ...;  // a vector of subranges
for(auto&amp;&amp; iter : srs | views::elements&lt;0&gt;){
}
</pre></blockquote>
<p>
The above code results in a hard error in deciding the <code>iterator_category</code> (The base is a random access range 
so it should exist). The immediate hard error complains that the following expression is invalid. 
</p>
<blockquote><pre>
std::get&lt;N&gt;(*current_);
</pre></blockquote>
<p>
Note that even if <code>iterator_category</code> does not complain, it will complain later when we dereference the iterator.
<p/>
Here are the declarations of the "get" overloads for <code>subrange</code>:
</p>
<blockquote><pre>
template&lt;size_t N, class I, class S, subrange_kind K&gt;
  requires ((N == 0 &amp;&amp; copyable&lt;I&gt;) || N == 1)
  constexpr auto get(const subrange&lt;I, S, K&gt;&amp; r);

template&lt;size_t N, class I, class S, subrange_kind K&gt;
  requires (N &lt; 2)
  constexpr auto get(subrange&lt;I, S, K&gt;&amp;&amp; r);
</pre></blockquote>
<p>
Note that the first overload requires <code>copyable&lt;I&gt;</code> which is <code>false</code> and 
the second overload requires an rvalue, which is also not the case. So we don't have a valid "get" in this case.
<p/>
But why does <code>elements_view</code> allow the instantiation in the first place? Let's look at its requirements:
</p>
<blockquote><pre>
template&lt;class T, size_t N&gt;
  concept <i>returnable-element</i> =                  <i>// exposition only</i>
    is_reference_v&lt;T&gt; || move_constructible&lt;tuple_element_t&lt;N, T&gt;&gt;;

template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; has-tuple-element&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
             <i>has-tuple-element</i>&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt; &amp;&amp;
             <i>returnable-element</i>&lt;range_reference_t&lt;V&gt;, N&gt;
  class elements_view;
</pre></blockquote>
<p>
It passed the "<code>is_reference_v&lt;range_reference_t&lt;V&gt;&gt;</code>" requirement, because it is 
"<code>subrange&amp;</code>". Here the logic has an assumption: if the tuple-like is a reference, 
then we can always "<code>get</code>" and return a reference. This is not the case for <code>subrange</code>. 
<code>subrange</code>'s <code>get</code> always return by value.
</p>

<p><i>[2022-11-01; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
"The actual issue is that <a href="https://wg21.link/P2165" title=" Compatibility between tuple, pair and tuple-like objects">P2165</a> broke
<code><i>has-tuple-element</i></code> for this case. We should unbreak it."
</p>



<p id="res-3797"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Three mutually exclusive options are prepared, depicted below by <b>Option A</b>, 
<b>Option B</b>, and <b>Option C</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> Properly disallow this case (preferred solution)
</p>

<ol>
<li><p>Modify 25.7.23.2 <a href="https://timsong-cpp.github.io/cppwp/range.elements.view">[range.elements.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;class T, size_t N&gt;
  concept <i>returnable-element</i> =              <i>// exposition only</i>
    <ins>requires { std::get&lt;N&gt;(declval&lt;T&gt;()); } &amp;&amp;</ins>
    is_reference_v&lt;T&gt; || move_constructible&lt;tuple_element_t&lt;N, T&gt;&gt;;  
  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>

<p>
<b>Option B:</b> Relax <code>subrange</code>'s <code>get</code> to have more overloads. Since <code>subrange</code>'s 
non-<code>const begin</code> unconditionally moves the iterator (even for lvalue-reference), 
</p>
<blockquote><pre>
[[nodiscard]] constexpr I begin() requires (!copyable&lt;I&gt;);
Effects: Equivalent to: return std::move(<i>begin_</i>);
</pre></blockquote>
<p>
if we add more <code>get</code> overloads, it would work. The non-const lvalue-ref overload would work 
(and it also moves because non-<code>const</code> lvalue begin moves). This solution would make another way
to let <code>subrange</code>'s iterator in moved-from state, which is not good.
</p>

<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std::ranges {
  [&hellip;]

  template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires ((N == 0 &amp;&amp; copyable&lt;I&gt;) || N == 1)
    constexpr auto get(const subrange&lt;I, S, K&gt;&amp; r);

  template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires (N &lt; 2)
    constexpr auto get(subrange&lt;I, S, K&gt;&amp;&amp; r);
    
  <ins>template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires ((N == 0 &amp;&amp; constructible_from&lt;I, const I&amp;&amp;&gt;) || N == 1)
    constexpr auto get(const subrange&lt;I, S, K&gt;&amp;&amp; r);
  
  template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires (N &lt; 2)
    constexpr auto get(subrange&lt;I, S, K&gt;&amp; r);</ins>
}
[&hellip;]
</pre>
</blockquote>
</li>

</ol>

<p>
<b>Option C:</b> Make <code>subrange</code>'s get to return by reference. This seems to significantly 
change the <code>subrange</code>'s tuple protocol, which is not ideal.
</p>






<hr>
<h3 id="3799"><a href="3799">3799</a>. Should <code>&lt;math.h&gt;</code> provide 3-argument <code>::hypot</code> overloads?</h3>
<p><b>Section:</b> 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-10-22 <b>Last modified:</b> 2022-11-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.c.headers.other">active issues</a> in [support.c.headers.other].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.c.headers.other">issues</a> in [support.c.headers.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See also LWG <a href="3782" title="Should &lt;math.h&gt; declare ::lerp? (Status: C++23)">3782</a>. Like <code>lerp</code>, neither <code>&lt;math.h&gt;</code> nor C compatibility is mentioned in 
<a href="https://wg21.link/P0030R1" title=" Proposal to Introduce a 3-Argument Overload to std::hypot">P0030R1</a>, and MSVC STL decides not to declare 3-argument <code>hypot</code> overloads in the global namespace 
(perhaps so does libc++).
<p/>
Perhaps we should also avoid providing these overloads in the global namespace. However, such change seems a bit 
difficult for libstdc++'s <code>&lt;math.h&gt;</code>.
</p>

<p><i>[2022-11-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"This affects the exports of <code>std.compat</code>".
</p>



<p id="res-3799"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3802"><a href="3802">3802</a>. <code>flat_<i>foo</i></code> allocator-extended constructors lack move semantics</h3>
<p><b>Section:</b> 23.6.8 <a href="https://timsong-cpp.github.io/cppwp/flat.map">[flat.map]</a>, 23.6.9 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap">[flat.multimap]</a>, 23.6.11 <a href="https://timsong-cpp.github.io/cppwp/flat.set">[flat.set]</a>, 23.6.12 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset">[flat.multiset]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2022-10-25 <b>Last modified:</b> 2023-06-16</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#flat.map">active issues</a> in [flat.map].</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map">issues</a> in [flat.map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Compare 23.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/priqueue.cons">[priqueue.cons]</a>'s overload set
</p>
<blockquote><pre>
priority_queue(const Compare&amp;, const Container&amp;);
priority_queue(const Compare&amp;, Container&amp;&amp;);
template&lt;class Alloc&gt; priority_queue(const Compare&amp;, const Container&amp;, const Alloc&amp;);
template&lt;class Alloc&gt; priority_queue(const Compare&amp;, Container&amp;&amp;, const Alloc&amp;);
</pre></blockquote>
<p>
against 23.6.8 <a href="https://timsong-cpp.github.io/cppwp/flat.map">[flat.map]</a>'s overload set
</p>
<blockquote><pre>
flat_map(key_container_type, mapped_container_type);
template&lt;class Allocator&gt; flat_map(const key_container_type&amp;, const mapped_container_type&amp;, const Allocator&amp; a);
</pre></blockquote>
<p>
I see two issues here:
</p>
<ol style="list-style-type: none">
<li><p>(A) The allocator-extended ctor of <code>flat_map</code> always copies the <code>key_container</code> and <code>value_container</code>, 
when it should be move-enabled.</p></li>
<li><p>(B) Almost certainly the <code>Allocator</code> parameter should be named <code>Alloc</code> instead, and there should be a 
separate "Constructors with allocators" section with wording similar to 23.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/priqueue.cons.alloc">[priqueue.cons.alloc]</a> explaining that 
these ctors don't participate in overload resolution unless 
<code>uses_allocator_v&lt;KeyContainer, Alloc&gt; &amp;&amp; uses_allocator_v&lt;MappedContainer, Alloc&gt;</code>.</p></li>
</ol>
<p>
I suggest this overload set to replace the two overloads above:
</p>
<blockquote><pre>
flat_map(key_container_type, mapped_container_type);
template&lt;class Alloc&gt; flat_map(const key_container_type&amp;, const mapped_container_type&amp;, const Alloc&amp; a);
template&lt;class Alloc&gt; flat_map(const key_container_type&amp;, mapped_container_type&amp;&amp;, const Alloc&amp; a);
template&lt;class Alloc&gt; flat_map(key_container_type&amp;&amp;, const mapped_container_type&amp;, const Alloc&amp; a);
template&lt;class Alloc&gt; flat_map(key_container_type&amp;&amp;, mapped_container_type&amp;&amp;, const Alloc&amp; a);
</pre></blockquote>
<p>
This preserves the apparent assumption that <code>KeyContainer(std::move(kc))</code> is always efficient but 
<code>KeyContainer(std::move(kc), otheralloc)</code> might not be. Similar wording changes would have to be made to all the 
<code>flat_<i>foo</i></code> containers.
<p/>
Tony Table:
</p>
<blockquote><pre>
template&lt;class T, class Comp = std::less&lt;T&gt;, class Container = std::pmr::vector&lt;T&gt;&gt;
using pmr_flat_set = std::flat_set&lt;T, Comp, Container&gt;;

std::pmr::vector&lt;pmr_flat_set&lt;int&gt;&gt; vs;
std::pmr::vector&lt;int&gt; data = {1,2,3};

vs.reserve(1);
vs.emplace_back(std::move(data));
  // constructs-in-place with the argument list (std::move(data), get_allocator())
  // BEFORE: copies (causes heap traffic)
  // AFTER: moves (no heap traffic)
</pre></blockquote>

<p><i>[2022-11-04; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><i>[2023-06-14 Varna]</i></p>

<p>Mentioned in <a href="https://wg21.link/P2767R0" title=" flat_map/flat_set omnibus">P2767R0</a>, but not resolved by it.</p>



<p id="res-3802"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3804"><a href="3804">3804</a>. <code>flat_<i>foo</i></code> missing some allocator-extended deduction guides</h3>
<p><b>Section:</b> 23.6.8 <a href="https://timsong-cpp.github.io/cppwp/flat.map">[flat.map]</a>, 23.6.9 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap">[flat.multimap]</a>, 23.6.11 <a href="https://timsong-cpp.github.io/cppwp/flat.set">[flat.set]</a>, 23.6.12 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset">[flat.multiset]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2022-10-25 <b>Last modified:</b> 2022-11-04</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#flat.map">active issues</a> in [flat.map].</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map">issues</a> in [flat.map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Tony Table:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v;
std::flat_set s = std::flat_set(v, MyAllocator&lt;int&gt;());
std::flat_set s = std::flat_set(v, std::less(), MyAllocator&lt;int&gt;());
std::flat_set s = std::flat_set(v.begin(), v.end(), MyAllocator&lt;int&gt;());
std::flat_set s = std::flat_set(v.begin(), v.end(), std::less(), MyAllocator&lt;int&gt;());
// BEFORE: all fail to compile
// AFTER: all compile successfully
</pre></blockquote>
<p>
Contrast 23.6.11.3 <a href="https://timsong-cpp.github.io/cppwp/flat.set.cons">[flat.set.cons]</a> with 23.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/priqueue.cons">[priqueue.cons]</a>, where most of these are okay:
</p>
<blockquote><pre>
std::vector&lt;int, MyAllocator&lt;int&gt;&gt; v;
std::priority_queue pq1 = std::priority_queue(v, std::less(), MyAllocator&lt;int&gt;());
std::priority_queue pq2 = std::priority_queue(v.begin(), v.end(), MyAllocator&lt;int&gt;());
std::priority_queue pq3 = std::priority_queue(v.begin(), v.end(), std::less(), MyAllocator&lt;int&gt;());
// BEFORE AND AFTER: pq1 compiles successfully
// BEFORE AND AFTER: pq2 and pq3 also compile successfully thanks to LWG <a href="3506" title="Missing allocator-extended constructors for priority_queue (Status: C++23)">3506</a>
</pre></blockquote>

<p><i>[2022-11-04; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p id="res-3804"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3805"><a href="3805">3805</a>. Expression evaluating to a call wrapper is a prvalue, not an object</h3>
<p><b>Section:</b> 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a>, 25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a>, 25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Johel Ernesto Guerrero Pe&ntilde;a <b>Opened:</b> 2022-10-26 <b>Last modified:</b> 2022-11-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.10.3 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a> defines
</p>
<blockquote><p>
-6- A <i>call wrapper</i> is an object of a call wrapper type.
</p></blockquote>
<p>
Most importantly, a call wrapper is an object.
<p/>
A number of functions in 22.10 <a href="https://timsong-cpp.github.io/cppwp/function.objects">[function.objects]</a> and expressions in 
25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a> and 25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> 
are specified to result in a call wrapper. Most notably, the return type of 
<code>ranges::to</code> is <code>auto</code>, so its result is definitely a prvalue and not a "call wrapper" object.
<p/>
Where a prvalue result is meant, the wording should be clarified to mean 
"a prvalue whose object it initializes is a call wrapper".
</p>

<p><i>[2022-11-01; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3805"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3812"><a href="3812">3812</a>. [fund.ts.v3] Incorrect constraint on <code>propagate_const</code> conversion function</h3>
<p><b>Section:</b> 6.1.2.6 [fund.ts.v3::propagate_const.const_observers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Giuseppe D'Angelo <b>Opened:</b> 2022-11-04 <b>Last modified:</b> 2022-11-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v3</b></p>
<p>
This issue has its origin in the discussion of <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=107525">gcc issue 107525</a>.
<p/>
The current draft of LFTSv3 specifies this conversion function for <code>propagate_const</code> in 
6.1.2.6 [fund.ts.v3::propagate_const.const_observers]:
</p>
<blockquote>
<pre>
constexpr operator const element_type*() const;
</pre>
<blockquote>
<p>
-7- <i>Returns</i>: <code>get()</code>.
<p/>
-8- <i>Remarks</i>: This function shall not participate in overload resolution unless <code>T</code> is an 
object pointer type or has an implicit conversion to <code>const element_type*</code>. 
</p>
</blockquote>
</blockquote>
<p>
The constraint should however specify that <code>const T</code> (and not <code>T</code>) needs
to have an implicit conversion to <code>const element_type *</code>.
<p/>
Basically: if <code>const T</code> cannot do the conversion, then neither <code>const propagate_const&lt;T&gt;</code> 
should be able to.
<p/>
One can design a type <code>X</code> such as a <code>const X</code> cannot convert to <code>const element_type *</code> 
(for instance, by <code>=delete</code>ing the corresponding conversion function). If now one asks whether 
<code>const propagate_const&lt;X&gt;</code> is convertible to <code>const element_type *</code>, the answer is 
(surprisingly) "yes".
</p>

<p><i>[Kona 2022-11-12; Set priority to 3]</i></p>




<p id="res-3812"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4840" title=" Working Draft, C++ Extensions for Library Fundamentals, Version 3">N4840</a>.
</p>

<ol>
<li><p>Modify 6.1.2.6 [fund.ts.v3::propagate_const.const_observers] as indicated:</p>

<blockquote>
<pre>
constexpr operator const element_type*() const;
</pre>
<blockquote>
<p>
-7- <i>Returns</i>: <code>get()</code>.
<p/>
-8- <i>Remarks</i>: This function shall not participate in overload resolution unless <code>T</code> is an 
object pointer type or <ins><code>const T</code></ins> has an implicit conversion to <code>const element_type*</code>. 
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3813"><a href="3813">3813</a>. <code>std::span&lt;volatile T, E&gt;</code> is made ill-formed by P2278R4 when <code>T</code> is a normal class type</h3>
<p><b>Section:</b> 23.7.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.overview">[span.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-11-06 <b>Last modified:</b> 2025-03-22</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#span.overview">issues</a> in [span.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is discovered when implementing <a href="https://github.com/microsoft/STL/pull/3187#discussion_r1009941854">the 
<code>span</code> part of P2278R4 in MSVC STL</a>.
<p/>
<a href="https://wg21.link/P2278R4" title=" cbegin should always return a constant iterator">P2278R4</a> added the <code>const_iterator</code> member type to <code>std::span</code>, which required its 
<code>iterator</code> type to model <code>std::input_iterator</code> (same for <code>const_reverse_iterator</code> and 
<code>reverse_iterator</code>).
<p/>
However, when <code>element_type</code> is <code>volatile T</code> and <code>T</code> is a class type, the <code>iterator</code> 
type generally fails to satisfy <code>input_iterator</code>, because:
</p>
<ol>
<li><p><code>input_iterator&lt;iterator&gt;</code> requires <code>indirectly_readable&lt;iterator&gt;</code>;</p></li>
<li><p><code>indirectly_readable&lt;iterator&gt;</code> requires <code>common_reference_with&lt;iterator_reference_t&lt;iterator&gt;&amp;&amp;, 
iterator_rvalue_reference_t&lt;iterator&gt;&amp;&amp;&gt;</code>, that is 
<code>common_reference_with&lt;volatile T&amp;, volatile T&amp;&amp;&gt;</code>;</p></li>
<li><p><code>common_reference_t&lt;volatile T&amp;, volatile T&amp;&amp;&gt;</code> is <code>T</code> (which is problematic), 
and thus <code>common_reference_with&lt;volatile T&amp;, volatile T&amp;&amp;&gt;</code> requires both 
<code>convertible_to&lt;volatile T&amp;, T&gt;</code> and <code>convertible_to&lt;volatile T&amp;&amp;, T&gt;</code>;</p></li>
<li><p>However, the class type <code>T</code> generally doesn't have constructors from <code>volatile T</code> or 
<code>const volatile T</code> glvalues, and thus neither <code>convertible_to&lt;volatile T&amp;, T&gt;</code> and 
<code>convertible_to&lt;volatile T&amp;&amp;, T&gt;</code> is satisfied.</p></li>
</ol>
<p>
Ideally, <code>span</code> should not require any form of construction of <code>element_type</code>. Although usages of 
class types provided by the standard library via <code>volatile</code> glvalues are generally not supported, I think 
<code>span&lt;volatile T, E&gt;</code> is still useful for some user-defined class type <code>T</code>, and thus shouldn't be forbidden.
</p>

<p><i>[Kona 2022-11-12; Set priority to 2]</i></p>


<p><i>[2025-03-22; Jiang An comments and provides wording]</i></p>

<p>
The proposed resolution relaxes the <code class='backtick'>input_iterator</code> concept (which in turn relaxes stronger iterator concepts) 
and extends <code class='backtick'>iter_const_reference_t</code> and the exposition only <code><i>iter-const-rvalue-reference-t</i></code> 
aliases. Another approach can be just relaxing the <code class='backtick'>indirectly_readable</code> concept, but its impact may be larger 
than expected.
</p>


<p id="res-3813"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header <code>&lt;iterator&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 24.3.4.9 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.input">[iterator.concept.input]</a>, concept input_iterator</i>
<ins>template&lt;class I&gt;
  concept <i>deref-to-value-t</i> = <i>see below</i>;            <i>// freestanding</i>

template&lt;class I&gt;
  concept <i>weakly-indirectly-readable</i> = <i>see below</i>;  <i>// freestanding</i></ins>

template&lt;class I&gt;
concept input_iterator = <i>see below</i>;                <i>// freestanding</i>

[&hellip;]

<i>// 24.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.alias">[const.iterators.alias]</a>, alias templates</i>
template&lt;<del>indirectly_readable</del><ins><i>weakly-indirectly-readable</i></ins> I&gt;
  using iter_const_reference_t = <i>see below</i>;
</pre>
</blockquote>
</li>

<li><p>Modify 24.3.4.9 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.input">[iterator.concept.input]</a>, concept <code>input_iterator</code> synopsis, as indicated:</p>

<blockquote>
<pre>
<ins>template&lt;class I&gt;
  concept <i>deref-to-value-t-impl</i> =      <i>// exposition only</i>
    same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;, iter_value_t&lt;I&gt;&gt; &amp;&amp;
    is_object_v&lt;iter_value_t&lt;I&gt;&gt;;

template&lt;class I&gt;
  concept <i>deref-to-value-t</i> =           <i>// exposition only</i>
    <i>deref-to-value-t-impl</i>&lt;remove_cvref_t&lt;I&gt;&gt;;

template&lt;class I&gt;
  concept <i>weakly-indirectly-readable</i> = <i>// exposition only</i>
    <i>deref-to-value-t</i>&lt;I&gt; ||
    indirectly_readable&lt;I&gt;;</ins>

template&lt;class I&gt;
  concept input_iterator =
    input_or_output_iterator&lt;I&gt; &amp;&amp;
    <del>indirectly_readable</del><ins><i>weakly-indirectly-readable</i></ins>&lt;I&gt; &amp;&amp;
    requires { typename <i>ITER_CONCEPT</i>(I); } &amp;&amp;
    derived_from&lt;<i>ITER_CONCEPT</i>(I), input_iterator_tag&gt;;
</pre>
</blockquote>
</li>

<li><p>Modify 24.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.alias">[const.iterators.alias]</a> as indicated:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;
  using <i>ref-add-const-t</i> = <i>see below</i>;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Result</i>: If <code>is_lvalue_reference_v&lt;T&gt;</code> is <code class='backtick'>true</code>, 
<code>const remove_reference_t&lt;T&gt;&amp;</code>. Otherwise, if <code>is_rvalue_reference_v&lt;T&gt;</code> 
is <code class='backtick'>true</code>, <code>const remove_reference_t&lt;T&gt;&amp;&amp;</code>. Otherwise, <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;<del>indirectly_readable</del><ins><i>weakly-indirectly-readable</i></ins> It&gt;
  using iter_const_reference_t = <ins>see below;</ins>
    <del>common_reference_t&lt;const iter_value_t&lt;It&gt;&amp;&amp;, iter_reference_t&lt;It&gt;&gt;;</del>
</pre>
<blockquote>
<p>
<ins>-?- <i>Result</i>: If <code class='backtick'>It</code> models <code><i>deref-to-value-t</i></code>, 
<code><i>ref-add-const-t</i>&lt;iter_reference_t&lt;It&gt;&gt;</code>. Otherwise, 
<code>common_reference_t&lt;const iter_value_t&lt;It&gt;&amp;&amp;, iter_reference_t&lt;It&gt;&gt;</code>.</ins>
</p>
</blockquote>
</blockquote>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The simple <code><i>deref-to-value-t</i></code> case should be detected first, 
which avoids unnecessary instantiations and IFNDR-ness.]
</p>
</blockquote>

</li>

<li><p>Modify 24.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.iterator">[const.iterators.iterator]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;<del>indirectly_readable</del><ins><i>weakly-indirectly-readable</i></ins> I&gt;
  using <i>iter-const-rvalue-reference-t</i> =              <i>// exposition only</i>
    common_reference_t&lt;const iter_value_t&lt;I&gt;&amp;&amp;, iter_rvalue_reference_t&lt;I&gt;&gt;;
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3829"><a href="3829">3829</a>. <code>as_rvalue_view::end</code> should improve non-common case</h3>
<p><b>Section:</b> 25.7.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.as.rvalue.view">[range.as.rvalue.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-11-13 <b>Last modified:</b> 2022-11-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, when the underlying range is not a common range, <code>as_rvalue_view::begin</code> and <code>end</code> return 
<code>move_iterator</code> and <code>move_sentinel</code> respectively, this seems reasonable since <code>move_sentinel</code> 
is a sentinel adaptor introduced by C++20 specifically for comparison with <code>move_iterator</code>.
<p/>
However, in the case where the sentinel type of the underlying type is an input iterator, this may lead to some 
performance issues, <a href="https://godbolt.org/z/8KGdqzzTK">consider</a>:
</p>  
<blockquote><pre>
#include &lt;list&gt;
#include &lt;ranges&gt;
  
int main() {
  std::list&lt;std::tuple&lt;int&amp;&gt;&gt; l;
  auto k = std::move(l) | std::views::keys;
  auto s = std::ranges::subrange(std::cbegin(k), std::end(k));
  (void) std::ranges::next(s.begin(), s.end()); // <span style="color:red;font-weight:bolder">constant time</span>
  auto r = s | std::views::as_rvalue;
  (void) std::ranges::next(r.begin(), r.end()); // <span style="color:red;font-weight:bolder">linear time</span>
}
</pre></blockquote>
<p>
The above <code>subrange</code> is constructed by the <code>elements_view::<i>iterator</i>&lt;true&gt;</code> and 
<code>elements_view::<i>iterator</i>&lt;false&gt;</code> pair, and since the former can be assigned by the latter, 
when we use <code>ranges::next</code> to increment the <code>begin</code> of <code>s</code> to its <code>end</code>, the 
<code>assignable_from</code> branch will be executed, so we get a constant-time complexity.
<p/>
However, when we apply <code>views::as_rvalue</code> to <code>s</code>, the <code>as_rvalue_view::end</code> will go 
into the non-common branch and return <code>move_sentinel</code>. And because <code>move_iterator</code> cannot be 
assigned by <code>move_sentinel</code>, <code>ranges::next</code> will successively increment the <code>begin</code> of <code>s</code> 
until its end, we get the linear-time complexity this time.
<p/>
I think it is more appropriate to return <code>move_iterator</code> for the above case, as this preserves the 
assignability, but also preserves the iterator operability that the original sentinel type has.
<p/>
Another benefit of doing this is that when the sentinel type of underlying range can be subtracted from its 
iterator type but does not model <code>sized_sentinel_for</code>, returning different <code>move_iterator</code> makes 
them still subtractable, because its <code>operator-</code> only constrain the <code>x.base() - y.base()</code> being 
well-formed.
<p/>
This also solves the issue of <code>as_rvalue_view</code> being a valid type but does not model a <code>range</code> in 
some cases, <a href="https://godbolt.org/z/GM5sMarqP">for example</a>:
</p>
<blockquote><pre>
#include &lt;ranges&gt;

int main() {
  std::move_iterator&lt;int*&gt; i;
  std::move_iterator&lt;const int*&gt; ci;
  std::ranges::subrange s(i, ci);
  std::ranges::as_rvalue_view r(s); // not failed
  static_assert(std::ranges::range&lt;decltype(r)&gt;); // <span style="color:red;font-weight:bolder">failed</span>
}
</pre></blockquote>
<p>
This is because currently, <code>as_rvalue_view</code> does not explicitly specify the template parameters of the returned 
<code>move_iterator</code> and <code>move_sentinel</code>, so based on CTAD, its <code>begin</code> will return 
<code>move_iterator(move_iterator(...))</code> which is still <code>move_iterator&lt;int*&gt;</code>, and its <code>end</code> will 
return <code>move_sentinel&lt;move_iterator&lt;const int*&gt;&gt;</code>. Those two types are not comparable, so <code>r</code> 
does not constitute a valid <code>range</code>.
<p/>
The proposed resolution is to return  <code>move_iterator</code> when the sentinel type of the underlying range models 
<code>input_iterator</code>.
</p>

<p><i>[2022-11-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"NAD, these examples seem entirely contrived. If not NAD, don't need the
<code>common_range</code> check if we are checking that thesentinel models
<code>input_iterator</code>."
</p>



<p id="res-3829"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 25.7.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.as.rvalue.view">[range.as.rvalue.view]</a> as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class as_rvalue_view : public view_interface&lt;as_rvalue_view&lt;V&gt;&gt; {
    [&hellip;]
    constexpr auto begin() requires (!<i>simple-view</i>&lt;V&gt;)
    { return move_iterator(ranges::begin(base_)); }
    constexpr auto begin() const requires range&lt;const V&gt;
    { return move_iterator(ranges::begin(base_)); }
 
    constexpr auto end() requires (!<i>simple-view</i>&lt;V&gt;) {
      if constexpr (common_range&lt;V&gt; <ins>|| input_iterator&lt;sentinel_t&lt;V&gt;&gt;</ins>) {
        return move_iterator(ranges::end(base_));
      } else {
        return move_sentinel(ranges::end(base_));
      }
    }
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (common_range&lt;const V&gt; <ins>|| input_iterator&lt;sentinel_t&lt;const V&gt;&gt;</ins>) {
        return move_iterator(ranges::end(base_));
      } else {
        return move_sentinel(ranges::end(base_));
      }
    }
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>
</ol>






<hr>
<h3 id="3830"><a href="3830">3830</a>. <code>reverse_view</code> should not cache when <code>ranges::next</code> has constant time complexity</h3>
<p><b>Section:</b> 25.7.21.2 <a href="https://timsong-cpp.github.io/cppwp/range.reverse.view">[range.reverse.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-11-14 <b>Last modified:</b> 2022-11-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.reverse.view">issues</a> in [range.reverse.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to ensure that <code>begin</code> has an amortized constant time, when the underlying range is not a 
common range, <code>reverse_view</code> always caches the result of <code>ranges::next</code>.
<p/>
However, for some non-common ranges, incrementing its <code>begin</code> to <code>end</code> still guarantees constant time, 
for example:
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;vector&gt;
#include &lt;list&gt;

int main() {
  std::vector v{42};
  auto x = std::ranges::subrange(std::counted_iterator(v.begin(), 1), std::default_sentinel)
         | std::views::reverse;
  (void) x.begin(); // <span style="color:red;font-weight:bolder">still caches end iterator in MSVC-STL</span>

  std::list l{42};
  auto y = std::ranges::subrange(l.cbegin(), l.end())
         | std::views::reverse;
  (void) y.begin(); // <span style="color:red;font-weight:bolder">still caches end iterator in both libstdc++ and MSVC-STL</span>
}
</pre></blockquote>
<p>
In the above example, although neither <code>subrange</code> is a common range, applying <code>ranges::next</code> 
to their iterator-sentinel pairs is still constant time, in this case, there's no need to introduce a cache for 
<code>reverse_view</code> to store the results. We shouldn't pay for things we don't need to use.
</p>

<p><i>[2022-11-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"NAD as specified, the <i>Remarks</i> don't need to be precise, they already
allow caching to be omitted if not needed. But we could still enable const
overloads of <code>begin</code> for cases like these."
</p>
<p>
"NAD, no need to complicate constraints for such contrived examples.
We don't care about random access, sized, non-common ranges like the first case.
Any change here should be a paper covering all adaptors, not a piecemeal issue."
</p>



<p id="res-3830"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 25.7.21.2 <a href="https://timsong-cpp.github.io/cppwp/range.reverse.view">[range.reverse.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; begin();
</pre>
<blockquote>
<p>
-2- <i>Returns</i>:
</p>
<blockquote><pre>
make_reverse_iterator(ranges::next(ranges::begin(<i>base_</i>), ranges::end(<i>base_</i>)))
</pre></blockquote>
<p>
-3- <i>Remarks</i>: In order to provide the amortized constant time complexity required by the <code>range</code> concept, 
this function caches the result within the <code>reverse_view</code> for use on subsequent calls <ins>when both 
<code>assignable_from&lt;I&amp;, S&gt;</code> and <code>random_access_iterator&lt;I&gt; &amp;&amp; 
sized_sentinel_for&lt;S, I&gt;</code> are <code>false</code>, where <code>I</code> is <code>iterator_t&lt;V&gt;</code> and 
<code>S</code> is <code>sentinel_t&lt;V&gt;</code></ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3831"><a href="3831">3831</a>. Two-digit formatting of negative <code>year</code> is ambiguous</h3>
<p><b>Section:</b> 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>, 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Stephanson <b>Opened:</b> 2022-11-18 <b>Last modified:</b> 2022-11-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.format">active issues</a> in [time.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.format">issues</a> in [time.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
An <a href="https://github.com/microsoft/STL/issues/3166">issue</a> has been identified regarding the two-digit 
formatting of negative years according to Table [tab:time.format.spec] (30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>):
</p>
<blockquote><pre>
cout &lt;&lt; format("{:%y} ", 1976y)  // "76"
     &lt;&lt; format("{:%y}", -1976y); // also "76"?
</pre></blockquote>
<p>
The relevant wording is
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
The last two decimal digits of the year. If the result is a single digit it is prefixed by <code>0</code>. 
The modified command <code>%Oy</code> produces the locale's alternative representation. The modified command 
<code>%Ey</code> produces the locale's alternative representation of offset from <code>%EC</code> (year only).
</p>
</blockquote> 
<p>
MSVC STL treats the regular modified form symmetrically. Just as <code>%Ey</code> is the offset from 
<code>%EC</code>, so <code>%y</code> is the offset from <code>%C</code>, which is itself "[t]he year divided by 100 
using <em>floored division</em>." (emphasis added). Because -1976 is the 24th year of the -20th century, 
the above code will print "76 24" using MSVC STL. However, many users expect, and 
<a href="https://github.com/llvm/llvm-project/blob/8f3f15c1a208932689a8bdef22d6ca3d4c3408c5/libcxx/include/__chrono/formatter.h#L238-L240">libc++</a> 
gives, a result based on the literal wording, "76 76".
<p/>
<a href="https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/functions/strftime.html">IEEE 1003.1-2008 strftime</a>
expects the century to be nonnegative, but the glibc implementation 
<a href="https://godbolt.org/z/1jYoeYT9d">prints 24</a> for -1976. My own opinion is that this is the 
better result, because it consistently interprets <code>%C</code> and <code>%y</code> as the quotient and remainder 
of floored division by 100.
<p/>
Howard Hinnant, coauthor of the original 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> wording in <a href="https://wg21.link/P0355" title=" Extending <chrono> to Calendars and Time Zones">P0355</a> adds:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
On the motivation for this design it is important to remember a few things:
</p>
<ul>
<li><p>POSIX <code>strftime</code>/<code>strptime</code> doesn't handle negative years in this department, so this is an 
opportunity for an extension in functionality.</p></li>
<li><p>This is a formatting/parsing issue, as opposed to a computational issue. This means that human readability 
of the string syntax is the most important aspect. Computational simplicity takes a back seat (within reason).</p></li>
<li><p><code>%C</code> can't be truncated division, otherwise the years [-99, -1] would map to the same century as the years 
[0, 99]. So floored division is a pretty easy and obvious solution.</p></li>
<li><p><code>%y</code> is obvious for non-negative years: The last two decimal digits, or <code>y % 100</code>.</p></li>
</ul>
<p>
This leaves how to represent negative years with <code>%y</code>. I can think of 3 options:
</p>
<ol>
<li><p>Use the last two digits without negating:  -1976 &rarr; 76.</p></li>
<li><p>Use the last two digits and negate it:     -1976 &rarr; -76.</p></li>
<li><p>Use floored modulus arithmetic:            -1976 &rarr; 24.</p></li>
</ol>
<p>
The algorithm to convert <code>%C</code> and <code>%y</code> into a year is not important to the client because these are both 
strings, not integers. The client will do it with <code>parse</code>, not <code>100*C + y</code>.
<p/>
I discounted solution 3 as not sufficiently obvious. If the output for -1976 was 23, the human reader wouldn't 
immediately know that this is off by 1. The reader is expecting the POSIX spec:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
the last two digits of the year as a decimal number [00,99].
</p></blockquote>
<p>
24 just doesn't cut it.
<p/>
That leaves solution 1 or 2. I discounted solution 2 because having the negative in 2 places (the <code>%C</code> and <code>%y</code>) 
seemed overly complicated and more error prone. The negative sign need only be in one place, and it has to be in 
<code>%C</code> to prevent ambiguity.
<p/>
That leaves solution 1. I believe this is the solution for an extension of the POSIX spec to negative years with the 
property of least surprise to the client. The only surprise is in <code>%C</code>, not <code>%y</code>, and the surprise in 
<code>%C</code> seems unavoidable.
</p></blockquote>

<p><i>[2022-11-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>A few votes for priority 2. Might need to go to LEWG.</p>



<p id="res-3831"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> This is Howard Hinnant's choice (3)
</p>

<ol>
<li><p>Modify 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>, Table [tab:time.format.spec] as indicated:</p>

<blockquote>

<table border="1">
<caption>Table 102 &mdash; Meaning of conversion specifiers  [tab:time.format.spec]</caption>
<tr style="text-align:center">
<th>Specifier</th>
<th>Replacement</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>The <del>last two decimal digits of the year</del><ins>remainder after dividing the year by 100 using floored division</ins>.<br/>
If the result is a single digit it is prefixed by <code>0</code>.<br/>
The modified command <code>%Oy</code> produces the locale's alternative representation. The<br/>
modified command <code>%Ey</code> produces the locale's alternative representation of offset from<br/>
<code>%EC</code> (year only).</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>

</blockquote>
</li>

<li><p>Modify 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a>, Table [tab:time.parse.spec] as indicated:</p>

<blockquote>

<table border="1">
<caption>Table 103 &mdash; Meaning of <code>parse</code> flags  [tab:time.parse.spec]</caption>
<tr style="text-align:center">
<th>Flag</th>
<th>Parsed value</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>The <del>last two decimal digits of the year</del><ins>remainder after dividing the year by 100 using floored division</ins>.<br/> 
If the century is not otherwise specified (e.g.<br/>
with <code>%C</code>), values in the range [<code>69</code>, <code>99</code>] are presumed to refer to the years 1969 to 1999,<br/>
and values in the range [<code>00</code>, <code>68</code>] are presumed to refer to the years 2000 to 2068. The<br/>
modified command <code>%<i>N</i> y</code> specifies the maximum number of characters to read. If <i>N</i> is<br/>
not specified, the default is 2. Leading zeroes are permitted but not required. The<br/>
modified commands <code>%Ey</code> and <code>%Oy</code> interpret the locale's alternative representation.</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>

</blockquote>
</li>
</ol>

<p>
<b>Option B:</b> This is Howard Hinnant's choice (1)
</p>

<ol>
<li><p>Modify 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>, Table [tab:time.format.spec] as indicated:</p>

<blockquote>

<table border="1">
<caption>Table 102 &mdash; Meaning of conversion specifiers  [tab:time.format.spec]</caption>
<tr style="text-align:center">
<th>Specifier</th>
<th>Replacement</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>The last two decimal digits of the year<ins>, regardless of the sign of the year</ins>.<br/>
If the result is a single digit it is prefixed by <code>0</code>.<br/>
The modified command <code>%Oy</code> produces the locale's alternative representation. The<br/>
modified command <code>%Ey</code> produces the locale's alternative representation of offset from<br/>
<code>%EC</code> (year only).<br/>
<ins>[<i>Example ?:</i> <code>cout &lt;&lt; format("{:%C %y}", -1976y);</code> prints <code>-20 76</code>. &mdash; <i>end example</i>]</ins>
</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>

</blockquote>
</li>

<li><p>Modify 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a>, Table [tab:time.parse.spec] as indicated:</p>

<blockquote>

<table border="1">
<caption>Table 103 &mdash; Meaning of <code>parse</code> flags  [tab:time.parse.spec]</caption>
<tr style="text-align:center">
<th>Flag</th>
<th>Parsed value</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>The last two decimal digits of the year<ins>, regardless of the sign of the year</ins>.<br/> 
If the century is not otherwise specified (e.g.<br/>
with <code>%C</code>), values in the range [<code>69</code>, <code>99</code>] are presumed to refer to the years 1969 to 1999,<br/>
and values in the range [<code>00</code>, <code>68</code>] are presumed to refer to the years 2000 to 2068. The<br/>
modified command <code>%<i>N</i> y</code> specifies the maximum number of characters to read. If <i>N</i> is<br/>
not specified, the default is 2. Leading zeroes are permitted but not required. The<br/>
modified commands <code>%Ey</code> and <code>%Oy</code> interpret the locale's alternative representation.<br/>
<ins>[<i>Example ?:</i> <code>year y; istringstream{"-20 76"} &gt;&gt; parse("%3C %y", y);</code> results in<br/> 
<code>y == -1976y</code>. &mdash; <i>end example</i>]</ins>
</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>

</blockquote>
</li>
</ol>






<hr>
<h3 id="3832"><a href="3832">3832</a>. Missing change for <code>element_view::<i>iterator</i></code> in LWG 3798</h3>
<p><b>Section:</b> 25.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2022-11-23 <b>Last modified:</b> 2024-07-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.elements.iterator">active issues</a> in [range.elements.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.elements.iterator">issues</a> in [range.elements.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In LWG <a href="3798" title="Rvalue reference and iterator_category (Status: C++23)">3798</a> (voted into WP in November 2022), iterator types of several range adaptors may have 
<code>forward_iterator_tag</code> or stronger iterator tag types as their <code>iterator_category</code> type when 
their <code>operator*</code> returns rvalue references. However, the proposed resolution missed the similar change 
for <code>element_view::<i>iterator</i></code>.
</p>

<p><i>[2022-11-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"The proposed resolution is incorrect - just because the <code>get</code>
expression is an xvalue doesn't mean <code>operator*</code> returns by reference."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 25.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> as indicated:</p>

<blockquote>
<p>
-2- The member <i>typedef-name</i> <code>iterator_category</code> is defined if and only if <code><i>Base</i></code> 
models <code>forward_range</code>. In that case, <code>iterator_category</code> is defined as follows: Let <code>C</code> 
denote the type <code>iterator_traits&lt;iterator_t&lt;<i>Base</i>&gt;&gt;::iterator_category</code>.
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>std::get&lt;N&gt;(*<i>current_</i>)</code> is a<del>n</del> <ins>p</ins>rvalue, 
<code>iterator_category</code> denotes <code>input_iterator_tag</code>.</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code>C</code> models <code>derived_from&lt;random_access_iterator_tag&gt;</code>, 
<code>iterator_category</code> denotes <code>random_access_iterator_tag</code>.</p></li>
<li><p>(2.3) &mdash; Otherwise, <code>iterator_category</code> denotes <code>C</code>.</p></li>
</ol>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2023-01-22; Jiang An comments and provides improved wording]</i></p>

<p>
The old proposed resolution was incorrect. I think the correct criteria could be that determined from the return type of 
<code><i>get-element</i></code>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>
<li><p>Modify 25.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> as indicated:</p>

<blockquote>
<p>
-2- The member <i>typedef-name</i> <code>iterator_category</code> is defined if and only if <code><i>Base</i></code> 
models <code>forward_range</code>. In that case, <code>iterator_category</code> is defined as follows: Let <code>C</code> 
denote the type <code>iterator_traits&lt;iterator_t&lt;<i>Base</i>&gt;&gt;::iterator_category</code>.
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <ins><code>range_reference_t&lt;<i>Base</i>&gt;</code> is a reference type and</ins> 
<code>std::get&lt;N&gt;(*<i>current_</i>)</code> is a<del>n</del> <ins>p</ins>rvalue <ins>or neither 
<code>range_reference_t&lt;<i>Base</i>&gt;</code> nor <code>tuple_element_t&lt;N, range_reference_t&lt;<i>Base</i>&gt;</code> 
is a reference type</ins>, <code>iterator_category</code> denotes <code>input_iterator_tag</code>.</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code>C</code> models <code>derived_from&lt;random_access_iterator_tag&gt;</code>, 
<code>iterator_category</code> denotes <code>random_access_iterator_tag</code>.</p></li>
<li><p>(2.3) &mdash; Otherwise, <code>iterator_category</code> denotes <code>C</code>.</p></li>
</ol>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2024-07-08; Hewill Kang provides improved wording]</i></p>



<p id="res-3832"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 25.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> as indicated:</p>

<blockquote>
<p>
-2- The member <i>typedef-name</i> <code>iterator_category</code> is defined if and only if <code><i>Base</i></code> 
models <code>forward_range</code>. In that case, <code>iterator_category</code> is defined as follows: Let <code>C</code> 
denote the type <code>iterator_traits&lt;iterator_t&lt;<i>Base</i>&gt;&gt;::iterator_category</code>.
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <del><code>std::get&lt;N&gt;(*<i>current_</i>)</code></del><ins><code>is_reference_v&lt;decltype(<i>get-element</i>(<i>current_</i>))&gt;</code></ins> 
is <del>an rvalue</del><ins><code>false</code></ins>, <code>iterator_category</code> denotes <code>input_iterator_tag</code>.</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code>C</code> models <code>derived_from&lt;random_access_iterator_tag&gt;</code>, 
<code>iterator_category</code> denotes <code>random_access_iterator_tag</code>.</p></li>
<li><p>(2.3) &mdash; Otherwise, <code>iterator_category</code> denotes <code>C</code>.</p></li>
</ol>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3835"><a href="3835">3835</a>. Requirements for <code>CharT</code> in the regex library</h3>
<p><b>Section:</b> 28.6.1 <a href="https://timsong-cpp.github.io/cppwp/re.general">[re.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Xie He <b>Opened:</b> 2022-11-28 <b>Last modified:</b> 2023-01-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.6.1 <a href="https://timsong-cpp.github.io/cppwp/re.general">[re.general]</a>, the character type used in the regex library (<code>CharT</code>), 
is only required to be "char-like". This means "<code>struct A { int m; };</code>" satisfies the 
requirements for <code>CharT</code>. Clearly there have to be more requirements for <code>CharT</code>.
</p>
<ol>
<li><p>Comparison operators such as "<code>==</code>" or "<code>&lt;=</code>" must be defined between <code>CharT</code> 
objects, because these operators are used at various places of 28.6 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a>, including 
28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> paragraph 14 and 16, 28.6.6 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a> paragraph 12, and 
28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> paragraph 14. Similarly, "<code>==</code>" between a <code>CharT</code> object 
and integer 0 must also be defined, as it is used at 28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> paragraph 11.

<p/>
Alternatively, we can also interpret these operators in the text, as code implemented using 
"<code>std::char_traits&lt;CharT&gt;</code>" comparison functions. This interpretation has the advantage 
of keeping 28.6 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a> consistent with the strings library and string comparisons, which are 
also used in 28.6 <a href="https://timsong-cpp.github.io/cppwp/re">[re]</a>, including 28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> paragraph 7, 18, 20, and 
28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> paragraph 14.2. Also, only with this interpretation, can
28.6.6 <a href="https://timsong-cpp.github.io/cppwp/re.traits">[re.traits]</a> paragraph 3 be consistent with 28.6.2 <a href="https://timsong-cpp.github.io/cppwp/re.req">[re.req]</a> paragraph 11.</p></li>
<li><p>There must be a way to convert between <code>CharT</code> and <code>char</code>, otherwise there is no 
way to recognize regex syntactical characters, such as <code>'*'</code> or <code>'+'</code>. One way is to simply 
do a type conversion from <code>char</code> to <code>CharT</code> (which requires <code>char</code> to be convertible 
to <code>CharT</code>). But this doesn't allow us to convert between character encodings.
<p/>
Alternatively, if we have an object of the <code>Traits</code> class (28.6.12 <a href="https://timsong-cpp.github.io/cppwp/re.grammar">[re.grammar]</a> paragraph 2) 
denoted <code>v</code>, we can use "<code>use_facet&lt;ctype&lt;CharT&gt;&gt;(v.getloc()).widen</code>" to convert 
from <code>char</code> to <code>CharT</code>. This allows us to convert between character encodings. This requires 
that we can actually get this facet from this locale object.
</p></li>
</ol>

<p><i>[2023-01-06; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3835"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3837"><a href="3837">3837</a>. <code>std::erase_if</code> overloads for non-associative containers should move (and
not copy) their predicate object</h3>
<p><b>Section:</b> 27.4.4.5 <a href="https://timsong-cpp.github.io/cppwp/string.erasure">[string.erasure]</a>, 23.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/deque.erasure">[deque.erasure]</a>, 23.3.7.7 <a href="https://timsong-cpp.github.io/cppwp/forward.list.erasure">[forward.list.erasure]</a>, 23.3.11.6 <a href="https://timsong-cpp.github.io/cppwp/list.erasure">[list.erasure]</a>, 23.3.13.6 <a href="https://timsong-cpp.github.io/cppwp/vector.erasure">[vector.erasure]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Giuseppe D'Angelo <b>Opened:</b> 2022-12-04 <b>Last modified:</b> 2023-01-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consistent uniform erasure added several overloads of <code>std::erase_if</code>. 
All these overloads have fully specified effects, and are either implemented
through the <code>erase</code>/<code>remove_if</code> idiom (for <code>string</code>, <code>vector</code> and <code>deque</code>),
through calls to the container's own <code>remove_if</code> non-static member function 
(for <code>list</code> and <code>forward_list</code>), or through a hand-rolled loop (for
the associative containers &mdash; <code>map</code>, <code>set</code>, 
and their unordered and multi variants).
<p/>
For the overloads that deal with non-associative containers the predicate passed to 
<code>std::erase_if</code> is always <em>copied</em> into the inner call
to <code>std::remove_if</code> or the container's <code>remove_if</code> (see 
27.4.4.5 <a href="https://timsong-cpp.github.io/cppwp/string.erasure">[string.erasure]</a>, 23.3.13.6 <a href="https://timsong-cpp.github.io/cppwp/vector.erasure">[vector.erasure]</a>, 
23.3.11.6 <a href="https://timsong-cpp.github.io/cppwp/list.erasure">[list.erasure]</a>, 23.3.7.7 <a href="https://timsong-cpp.github.io/cppwp/forward.list.erasure">[forward.list.erasure]</a>, and
23.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/deque.erasure">[deque.erasure]</a>).
<p/>
Now, algorithms are generally allowed to take as many copies of
predicates as they want &mdash; this is 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>/9, 
but cf. LWG <a href="3049" title="Missing wording allowing algorithms to use copies of function objects as substitutes for their parameters (Status: Open)">3049</a>. 
However it still feels strange/sloppy that a copy here is <em>mandated</em> by the Standard.
An implementation that would otherwise make no copies of a predicate in an algorithm 
<em>must</em> make a copy in the <code>erase_if</code> overloads.
<p/>
The copy of the predicate could be instead replaced by a move without
any change in functionality; after being passed to the underlying
algorithm, the predicate object is never used again by <code>erase_if</code>. 
I am therefore proposing to add a <code>std::move</code> call for the predicate object.
<p/>
One could argue that <code>erase_if</code> should be re-specified so that it is not
necessarily implemented in terms of underlying calls to other
facilities, and could therefore even remove the need of a move on a
high-quality implementation. 
This is a design change, and so I consider it out of scope for a library issue.
<p/>
Of course, moving instead of copying is a detectable change, and
"pathological" predicate types that are copyable but have disabled moves
will get broken, but I don't think those deserve to be supported.
</p>

<p><i>[2023-01-06; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"An alternative resolution would be to wrap the predicate in reference_wrapper."
</p>
<p>
"I'd prefer blanket wording that says the actual number of copies and/or moves
is unspecified when the wording depicts a copy of a function object."
</p>
<p>
Related to LWG <a href="3049" title="Missing wording allowing algorithms to use copies of function objects as substitutes for their parameters (Status: Open)">3049</a>.
</p>



<p id="res-3837"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 27.4.4.5 <a href="https://timsong-cpp.github.io/cppwp/string.erasure">[string.erasure]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits, class Allocator, class Predicate&gt;
  constexpr typename basic_string&lt;charT, traits, Allocator&gt;::size_type
    erase_if(basic_string&lt;charT, traits, Allocator&gt;&amp; c, Predicate pred);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto it = remove_if(c.begin(), c.end(), <ins>std::move(</ins>pred<ins>)</ins>);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.5.5 <a href="https://timsong-cpp.github.io/cppwp/deque.erasure">[deque.erasure]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class Allocator, class Predicate&gt;
  typename deque&lt;T, Allocator&gt;::size_type
    erase_if(deque&lt;T, Allocator&gt;&amp; c, Predicate pred);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto it = remove_if(c.begin(), c.end(), <ins>std::move(</ins>pred<ins>)</ins>);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.7.7 <a href="https://timsong-cpp.github.io/cppwp/forward.list.erasure">[forward.list.erasure]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class Allocator, class Predicate&gt;
  typename forward_list&lt;T, Allocator&gt;::size_type
    erase_if(forward_list&lt;T, Allocator&gt;&amp; c, Predicate pred);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to: <code>return c.remove_if(<ins>std::move(</ins>pred<ins>)</ins>);</code>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.11.6 <a href="https://timsong-cpp.github.io/cppwp/list.erasure">[list.erasure]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class Allocator, class Predicate&gt;
  typename list&lt;T, Allocator&gt;::size_type
    erase_if(list&lt;T, Allocator&gt;&amp; c, Predicate pred);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to: <code>return c.remove_if(<ins>std::move(</ins>pred<ins>)</ins>);</code>
</p>
<blockquote><pre>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.13.6 <a href="https://timsong-cpp.github.io/cppwp/vector.erasure">[vector.erasure]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class Allocator, class Predicate&gt;
  constexpr typename vector&lt;T, Allocator&gt;::size_type
    erase_if(vector&lt;T, Allocator&gt;&amp; c, Predicate pred);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto it = remove_if(c.begin(), c.end(), <ins>std::move(</ins>pred<ins>)</ins>);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3838"><a href="3838">3838</a>. The last specialization of  <code>incrementable_traits</code> is under-constrained</h3>
<p><b>Section:</b> 24.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/incrementable.traits">[incrementable.traits]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2022-12-07 <b>Last modified:</b> 2023-01-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#incrementable.traits">active issues</a> in [incrementable.traits].</p>
<p><b>View all other</b> <a href="lwg-index.html#incrementable.traits">issues</a> in [incrementable.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The last specialization of <code>incremental_traits</code> requires that the result obtained 
by subtracting two objects of type <code>const T</code> must model <code>integral</code>, 
then apply <code>make_signed_t</code> to it as the difference type of type <code>T</code>.
<p/>
However, since <code>bool</code> also models <code>integral</code>, but is not a valid template argument 
for <code>make_signed_t</code>, we should ban such cases to avoid unnecessary hard errors 
(<a href="https://godbolt.org/z/bbTz1xh89">online example</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct Bool { 
  bool operator-(Bool) const; 
};

template&lt;class T&gt;
concept can_iota_view = requires(T t) { std::ranges::iota_view(t); };

static_assert(!can_iota_view&lt;Bool&gt;); // <span style="color:red;font-weight:bolder">hard error</span>
</pre></blockquote>

<p><i>[2022-12-13; Minor wording improvements after LWG reflector discussion]</i></p>

<p>
Remove <code>remove_cv_t</code> within <code><i>nonbool-integral</i></code>, because <code>bool</code> prvalues cannot be <i>cv</i>-qualified.
</p>

<p><i>[2023-01-06; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"I would prefer to place the new checks directly in the <i>requires-clause</i>
instead of introducing <i><code>nonbool-integral</code></i>."
</p>



<p id="res-3838"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 24.3.2.1 <a href="https://timsong-cpp.github.io/cppwp/incrementable.traits">[incrementable.traits]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  <ins>template&lt;class T&gt;
    concept <i>nonbool-integral</i> = integral&lt;T&gt; &amp;&amp; !same_as&lt;T, bool&gt;;         // <i>exposition only</i></ins>
  
  template&lt;class T&gt; struct incrementable_traits { };
  
  [&hellip;]

  template&lt;class T&gt;
    requires (!requires { typename T::difference_type; } &amp;&amp;
              requires(const T&amp; a, const T&amp; b) { { a - b } -&gt; <ins><i>nonbool-integral</i></ins><del>integral</del>; })
  struct incrementable_traits&lt;T&gt; {
    using difference_type = make_signed_t&lt;decltype(declval&lt;T&gt;() - declval&lt;T&gt;())&gt;;
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3840"><a href="3840">3840</a>. <code>filesystem::u8path</code> should be undeprecated</h3>
<p><b>Section:</b> D.22.1 <a href="https://timsong-cpp.github.io/cppwp/depr.fs.path.factory">[depr.fs.path.factory]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2022-12-10 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.fs.path.factory">issues</a> in [depr.fs.path.factory].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>filesystem::u8path</code> function became deprecated with the adoption of
<a href="https://wg21.link/P0482R6" title=" char8_t: A type for UTF-8 characters and strings (Revision 6)">P0482R6</a>, but the rationale for that change is rather thin:
</p>
<blockquote><p>
"The C++ standard must improve support for UTF-8 by removing the existing barriers that 
result in redundant tagging of character encodings, non-generic UTF-8 specific workarounds 
like <code>u8path</code>."
</p></blockquote>
<p>
The <code>u8path</code> function is still useful if my original string source is a <code>char</code> 
sequence and I <em>do know</em> that the encoding of this sequence is UTF-8. 
<p/>
The deprecation note suggests that one should use <code>std::u8string</code> instead, which costs me 
an additional transformation and doesn't work without <code>reinterpret_cast</code>.
<p/>
Even in the presence of <code>char8_t</code>, legacy code bases often are still ABI-bound to <code>char</code>. 
In the future we may solve this problem using the tools provided by <a href="https://wg21.link/P2626" title=" charN_t incremental adoption: Casting pointers of UTF character types">P2626</a> instead, 
but right now this is not part of the standard and it wasn't at the time when <code>u8path</code> became 
deprecated. 
This is in my opinion a good reason to undeprecate <code>u8path</code> <em>now</em> and decide later on the 
appropriate time to deprecate it again (if it really turns out to be obsolete by alternative
functionality).
<p/>
Billy O'Neal provides a concrete example where the current deprecation status causes pain:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Example: <a 
href="https://github.com/microsoft/vcpkg-tool/blob/c8b580319539ded6028f09ba710db68534ab0148/src/vcpkg/base/files.cpp#L21-L45">
vcpkg-tool files.cpp#L21-L45</a>
<p/>
Before p0482, we could just call <code>std::u8path</code> and it would do the right thing on both 
POSIX and Windows. After compilers started implementing '20, we have to make assumptions about 
the correct 'internal' <code>std::path</code> encoding because there is no longer a way to arrive to 
<code>std::path</code> with a <code>char</code> buffer that we know is UTF-8 encoded and get the correct results.
<p/>
It's one of the reasons we completely ripped out use of <code>std::filesystem</code> on most platforms 
from vcpkg, so you won't see this in current sources.
</p>
</blockquote>

<p><i>[2023-01-06; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Set status to LEWG.
</p>

<p><i>[2023-05-30; status to "Open"]</i></p>

<p>
LEWG discussed this in January and had no consensus for undeprecation.
</p>



<p id="res-3840"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Restore the <code>u8path</code> declarations to 31.12.4 <a href="https://timsong-cpp.github.io/cppwp/fs.filesystem.syn">[fs.filesystem.syn]</a>, header
<code>&lt;filesystem&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::filesystem {
  // <i>31.12.6 <a href="https://timsong-cpp.github.io/cppwp/fs.class.path">[fs.class.path]</a>, paths</i>
  class path;

  // <i>31.12.6.8 <a href="https://timsong-cpp.github.io/cppwp/fs.path.nonmember">[fs.path.nonmember]</a>, path non-member functions</i>
  void swap(path&amp; lhs, path&amp; rhs) noexcept;
  size_t hash_value(const path&amp; p) noexcept;
  
  <ins>// <i>[fs.path.factory], path factory functions</i></ins>
  <ins>template&lt;class Source&gt;
    path u8path(const Source&amp; source);
  template&lt;class InputIterator&gt;
    path u8path(InputIterator first, InputIterator last);</ins>

  // <i>31.12.7 <a href="https://timsong-cpp.github.io/cppwp/fs.class.filesystem.error">[fs.class.filesystem.error]</a>, filesystem errors</i>
  class filesystem_error;
[&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Restore the previous sub-clause [fs.path.factory] by copying the contents of 
D.22.1 <a href="https://timsong-cpp.github.io/cppwp/depr.fs.path.factory">[depr.fs.path.factory]</a> to a new sub-clause [fs.path.factory] between 
31.12.6.8 <a href="https://timsong-cpp.github.io/cppwp/fs.path.nonmember">[fs.path.nonmember]</a> and 31.12.6.10 <a href="https://timsong-cpp.github.io/cppwp/fs.path.hash">[fs.path.hash]</a> and without <i>Note 1</i>
as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: As additional stylistic adaption we replace the obsolete <i>Requires</i> 
element by a <i>Preconditions</i> element plus a <i>Mandates</i> element (similar to that of
31.12.6.5.1 <a href="https://timsong-cpp.github.io/cppwp/fs.path.construct">[fs.path.construct]</a> p5). 
<p/>
As a second stylistic improvement we convert the
now more unusual "if [&hellip;]; otherwise" construction in bullets by "Otherwise, if [&hellip;]"
constructions.]
</p>
</blockquote>

<blockquote>
<p>
<ins><b>? Factory functions [fs.path.factory]</b></ins>
</p>
<pre>
<ins>template&lt;class Source&gt;
  path u8path(const Source&amp; source);
template&lt;class InputIterator&gt;
  path u8path(InputIterator first, InputIterator last);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates:</i> The value type of <code>Source</code> and <code>InputIterator</code> is <code>char</code>
or <code>char8_t</code>.</ins>
<p/>
<ins>-?- <i>Preconditions:</i> The <code>source</code> and <code>[first, last)</code> sequences are UTF-8 encoded.</ins>
<p/>
<ins>-?- <i>Returns:</i></ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; If <code>value_type</code> is <code>char</code> and the current native narrow encoding 
(31.12.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.type.cvt">[fs.path.type.cvt]</a>) is UTF-8, return <code>path(source)</code> or <code>path(first, last)</code>.</ins></p></li>
<li><p><ins>(?.2) &mdash; Otherwise, if <code>value_type</code> is <code>wchar_t</code> and the native wide encoding is UTF-16, 
or if <code>value_type</code> is <code>char16_t</code> or <code>char32_t</code>, convert <code>source</code> or <code>[first, last)</code> 
to a temporary, <code>tmp</code>, of type <code>string_type</code> and return <code>path(tmp)</code>.</ins></p></li>
<li><p><ins>(?.3) &mdash; Otherwise, convert <code>source</code> or <code>[first, last)</code> to a temporary, <code>tmp</code>, 
of type <code>u32string</code> and return <code>path(tmp)</code>.</ins></p></li>
</ol>
<p>
<ins>-?- <i>Remarks:</i> Argument format conversion (31.12.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmt.cvt">[fs.path.fmt.cvt]</a>) applies to the arguments 
for these functions. How Unicode encoding conversions are performed is unspecified.</ins>
<p/>
<ins>-?- [<i>Example 1</i>: A string is to be read from a database that is encoded in UTF-8, and used to create a directory
using the native encoding for filenames:</ins>
</p>
<blockquote><pre>
<ins>namespace fs = std::filesystem;
std::string utf8_string = read_utf8_data();
fs::create_directory(fs::u8path(utf8_string));</ins>
</pre></blockquote>
<p>
<ins>For POSIX-based operating systems with the native narrow encoding set to UTF-8, no encoding or type
conversion occurs.</ins>
<p/>
<ins>For POSIX-based operating systems with the native narrow encoding not set to UTF-8, a conversion to UTF-32
occurs, followed by a conversion to the current native narrow encoding. Some Unicode characters may have no
native character set representation.</ins>
<p/>
<ins>For Windows-based operating systems a conversion from UTF-8 to UTF-16 occurs. &mdash; <i>end example</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Delete sub-clause D.22.1 <a href="https://timsong-cpp.github.io/cppwp/depr.fs.path.factory">[depr.fs.path.factory]</a> in its entirety.</p>
</li>
</ol>






<hr>
<h3 id="3844"><a href="3844">3844</a>. Non-numeric formats for negative durations</h3>
<p><b>Section:</b> 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2022-12-20 <b>Last modified:</b> 2023-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.format">active issues</a> in [time.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.format">issues</a> in [time.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording of 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> p4 seems to have some
unwanted consequences. It says:
</p>
<blockquote>
The result of formatting a <code>std::chrono::duration</code> instance holding a
negative value, or an <code>hh_mm_ss</code> object <code>h</code> for which
<code>h.is_negative()</code> is <code>true</code>, is equivalent to the output
of the corresponding positive value,
with a <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;("-")</code>
character sequence placed before the replacement of
the initial conversion specifier.
</blockquote>

<p>
Taken literally, I think that means:
</p>

<blockquote><pre>
format("{:%q}", -1s) == "-s"
format("{:%t%j}", -25h) == "-\t1"
format("{:%p%I}", -11h) == "-am11"
</pre></blockquote>

<p>
The last one probably doesn't matter (what does -11am mean anyway?)
but some of them do matter, for example something like
"<code>{:(%q)%t%Q}"</code> intends to put the unit suffix first in parens
but will print <code>"(-s)\t1"</code> which probably isn't what the user wanted.
</p>

<p>
I think we want to place the sign before the first <u>numeric</u>
conversion specifier, not "the initial conversion specifier".
That is what Howard's <code>date::format</code> and &lt;fmt&gt; both do.
</p>

<p><i>[Issaquah 2023-02-10; LWG issue processing]</i></p>

<p>
Set priority to 3. Proposed a hybrid resolution.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<blockquote class="note">
Two alternatives are presented,
choose one of <b>Option A</b> or <b>Option B</b>.
</blockquote>

<ol>
<li>
<p> Modify 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> as indicated: </p>
<blockquote>

<p><b>Option A</b></p>

<p>-4-
The result of formatting a <code><del>std::</del>chrono::duration</code>
instance holding a negative value, or a<del>n</del>
<code><ins>chrono::</ins>hh_mm_ss</code> object <code>h</code> for which
<code>h.is_negative()</code> is <code>true</code>,
is equivalent to the output
of the corresponding positive value,
with a <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;("-")</code>
character sequence placed before the replacement of
the <del>initial</del> <ins>first</ins>
conversion specifier
<ins>that is not one of %n, %p, %q, %t, or %%</ins>.
</p>

<p><b>Option B</b></p>

<p>-4-
<ins>Among the specifiers, %H, %I, %M, %S, and %T, the</ins> <del>The</del>
result of formatting a <code><del>std::</del>chrono::duration</code>
instance holding a negative value, or a<del>n</del>
<code><ins>chrono::</ins>hh_mm_ss</code> object <code>h</code> for which
<code>h.is_negative()</code> is <code>true</code>,
is equivalent to the output
of the corresponding positive value,
with a <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;("-")</code>
character sequence placed before the replacement of
the initial conversion specifier.
</p>

</blockquote>
</li>
</ol>
</blockquote>



<p id="res-3844"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>
<li>
<p> Modify 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> as indicated: </p>
<blockquote>
<p>-4-
The result of formatting a <code><del>std::</del>chrono::duration</code>
instance holding a negative value, or a<del>n</del>
<code><ins>chrono::</ins>hh_mm_ss</code> object <code>h</code> for which
<code>h.is_negative()</code> is <code>true</code>,
is equivalent to the output
of the corresponding positive value,
with a <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;("-")</code>
character sequence placed before the replacement of
the <del>initial</del> <ins>first</ins>
conversion specifier
<ins>that is one of %H, %I, %M, %S, or %T</ins>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3845"><a href="3845">3845</a>. <code>ranges::to</code>'s <code>from_range_t</code> tag branch has the wrong constraint</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-06 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In bullet (1.1.2), <code>ranges::to</code> checks whether the container type
<code>C</code> models <code>constructible_from&lt;from_range_t, ...&gt;</code>
and constructs it via <code>C(from_range, ...)</code>.
</p>
<p>
Since <code>from_range</code> is a <code>constexpr</code> variable here,
it would be more accurate to constrain <code>C</code> to be constructible from
a const lvalue tag rather than an rvalue tag.
</p>

<p><i>[2023-02-02; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Several votes for "Tentatively Ready", but also two objections, preferring NAD.
The proposed change would appear to bless unconventional uses of
<code>from_range</code>, and we don't want to support or encourage that.
The current wording is simpler, and works for the intended cases.
</p>



<p id="res-3845"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>
<ol>
<li><p>Modify 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
  template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
    constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
  <p>
    -1- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
    </p>
    <ol style="list-style-type:none">
    <li><p>(1.1)  If <code>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
    <ol style="list-style-type:none">
    <li><p>(1.1.1)  If <code>constructible_from&lt;C, R, Args...&gt;</code> is <code>true</code>:</p>
    <blockquote><code>C(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
    <li><p>(1.1.2)  Otherwise, if <code>constructible_from&lt;C, <ins>const </ins>from_range_t<ins>&amp;</ins>, R, Args...&gt;</code> is <code>true</code>:</p>
    <blockquote><code>C(from_range, std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code></blockquote></li>
    <li>[]</li>
    </ol></li>
  </ol>
</blockquote>
</blockquote>
</li>
</ol>
  





<hr>
<h3 id="3846"><a href="3846">3846</a>. <code>iota_view::<i>iterator</i>::operator-</code> is overconstrained</h3>
<p><b>Section:</b> 25.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.iota.iterator">[range.iota.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-06 <b>Last modified:</b> 2023-02-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.iota.iterator">active issues</a> in [range.iota.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.iota.iterator">issues</a> in [range.iota.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, two <code>iota_view::<i>iterator</i></code>s can be subtracted
only when the underlying <code>W</code> type models <code><i>advanceable</i></code>, 
where <code><i>advanceable</i></code> consists of a series of syntactic and semantic
requirements similar to the <code>random_access_iterator</code> concept.
</p>
<p>
However, when <code>W</code> is an C++20 iterator type, whether it provides
subtraction is irrelevant to its iterator category. 
In such cases, still requiring <code>W</code> to support a series of random access
iterator-like operations seems too restrictive. Consider:
</p>
<pre>
    #include &lt;list&gt;
    #include &lt;ranges&gt;

    int main() {
      std::list l{1, 2, 3, 4, 5};
      auto it = std::counted_iterator(l.begin(), l.size());
      auto r = std::views::iota(it, std::next(it, 3));
      auto sz = r.size();           // 3 as expected
      auto d = r.end() - r.begin(); // <span style="color:red;font-weight:bolder">error: no match for 'operator-'</span>
    }
</pre>
<p>
We can get the correct size of <code>iota_view</code> by subtracting two
<code>counted_iterator</code>s, 
but we cannot subtract two <code>iota_view::<i>iterator</i></code>s to get their
difference, even though the underlying <code>counted_iterator</code> already models
<code>sized_sentinel_for</code> for itself, which is not satisfactory.
</p>
<p>
I think we should relax the constraints of
<code>iota_view::<i>iterator</i>::operator-</code> to allow the above case,
which also makes it compatible with <code>iota_view::<i>sentinel</i>::operator-</code>.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Several P0 votes, but an objection to P0 on the basis that we don't
define what it means to use <code>sized_sentinel_for</code> on non-iterators.
Others responded that we don't need to, as we only use it with iterators,
and do not intend it to be usable with anything else.
</p>



<p id="res-3846"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 25.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.iota.iterator">[range.iota.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;weakly_incrementable W, semiregular Bound&gt;
    requires <i>weakly-equality-comparable-with</i>&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  struct iota_view&lt;W, Bound&gt;::<i>iterator</i> {
  private:
    W <i><i>value_</i></i> = W();             <i>// exposition only</i>
  public:
    []
    friend constexpr <i>iterator</i> operator-(<i>iterator</i> i, difference_type n)
      requires <i>advanceable</i>&lt;W&gt;;
    friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
      requires <i>advanceable</i>&lt;W&gt; <ins>|| sized_sentinel_for&lt;W, W&gt;</ins>;
  };
}
</pre>
</blockquote>
[]
<pre>
friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
  requires <i>advanceable</i>&lt;W&gt; <ins>|| sized_sentinel_for&lt;W, W&gt;</ins>;
</pre>
<blockquote>
<p>
-23- <i>Effects:</i> Equivalent to:
<pre>
  using D = difference_type;
  if constexpr (<i>is-integer-like</i>&lt;W&gt;) {
    if constexpr (<i>is-signed-integer-like</i>&lt;W&gt;)
      return D(D(x.<i>value_</i>) - D(y.<i>value_</i>));
    else
      return (y.<i>value_</i> &gt; x.<i>value_</i>)
        ? D(-D(y.<i>value_</i> - x.<i>value_</i>))
        : D(x.<i>value_</i> - y.<i>value_</i>);
  } else {
    return x.<i>value_</i> - y.<i>value_</i>;
  }
</pre>
</p></blockquote>
</blockquote></li>

</ol>





<hr>
<h3 id="3852"><a href="3852">3852</a>. <code>join_with_view::<i>iterator</i></code>'s <code>iter_move</code> and <code>iter_swap</code> should be conditionally <code>noexcept</code></h3>
<p><b>Section:</b> 25.7.15.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.iterator">[range.join.with.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-06 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.with.iterator">active issues</a> in [range.join.with.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.with.iterator">issues</a> in [range.join.with.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to preserve room for optimization, the standard always tries to
propagate the <code>noexcept</code> specification of custom
<code>iter_move</code>/<code>iter_swap</code> for different iterators.
</p>
<p>But for <code>join_with_view::<i>iterator</i></code>,
these two specializations are the only ones in the standard that do not have
a <code>noexcept</code> specification.
This is because both invoke <code>visit</code> in the function body,
and <code>visit</code> may throw an exception when the <code>variant</code>
does not hold a value.
</p>
<p>
However, implementors are not required to follow the standard practice.
Since the <code>join_with_view::<i>iterator</i></code>'s <code>variant</code> member
only contains two alternative types, both libstdc++ and MSVC-STL avoid
heavyweight <code>visit</code> calls by simply using multiple if statements.
This means that it is still possible to add a conditional <code>noexcept</code>
specification to these overloads, and there is already a precedent in the
standard, namely <code>common_iterator</code>.
All we need to do is add a <i>Preconditions</i>.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"The iter_swap specification is wrong since we can swap Pattern and Inner.
And this is something implementations can strengthen."
</p>



<p id="res-3852"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 25.7.15.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.iterator">[range.join.with.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
  requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
        &amp;&amp; view&lt;Pattern&gt; &amp;&amp; <i>compatible-joinable-ranges</i>&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  template&lt;bool Const&gt;
  class join_with_view&lt;V, Pattern&gt;::<i>iterator</i> {
    [&hellip;]
    <i>Parent</i>* <i>parent_</i> = nullptr;                                          <i>// exposition only</i>
    <i>OuterIter</i> <i>outer_it_</i> = <i>OuterIter()</i>;                                  <i>// exposition only</i>
    variant&lt;<i>PatternIter</i>, <i>InnerIter</i>&gt; <i>inner_it_</i>;                          <i>// exposition only</i>
    [&hellip;]
  public:
    [&hellip;]
    friend constexpr decltype(auto) iter_move(const <i>iterator</i>&amp; x) <ins>noexcept(<i>see below</i>);</ins> <del>{
      using rvalue_reference = common_reference_t&lt;
        iter_rvalue_reference_t&lt;<i>InnerIter</i>&gt;,
        iter_rvalue_reference_t&lt;<i>PatternIter</i>&gt;&gt;;
      return visit&lt;rvalue_reference&gt;(ranges::iter_move, x.<i>inner_it_</i>);
    }</del>

    friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) <ins>noexcept(<i>see below</i>)</ins>
      requires indirectly_swappable&lt;<i>InnerIter</i>, <i>PatternIter</i>&gt;<ins>;</ins><del>{
      visit(ranges::iter_swap, x.<i>inner_it_</i>, y.<i>inner_it_</i>);
    }</del>
  };
}
</pre>
</blockquote>
[&hellip;]
<pre><ins>friend constexpr decltype(auto) iter_move(const <i>iterator</i>&amp; x) noexcept(<i>see below</i>);</ins>
</pre>
<blockquote>
<p>
<ins>
-?- Let <code><i>rvalue_reference</i></code> be: 
</ins>
<pre>
<ins>  common_reference_t&lt;iter_rvalue_reference_t&lt;<i>InnerIter</i>&gt;, iter_rvalue_reference_t&lt;<i>PatternIter</i>&gt;&gt;
</ins></pre>
</p>
<p>
<ins>
-?- <i>Preconditions</i>: <code>x.<i>inner_it_</i>.valueless_by_exception()</code> is <code>false</code>.
</ins>
</p>
<p>
<ins>
-?- <i>Effects</i>: Equivalent to: <code>return visit&lt;<i>rvalue_reference</i>&gt;(ranges::iter_move, x.<i>inner_it_</i>);</code>
</ins>
</p>
<p>
<ins>
-?- <i>Remarks</i>: The exception specification is equivalent to:
</ins>
<pre>
<ins>  noexcept(ranges::iter_move(declval&lt;const <i>InnerIter</i>&amp;&gt;())) &amp;&amp;
  noexcept(ranges::iter_move(declval&lt;const <i>PatternIter</i>&amp;&gt;())) &amp;&amp;
  is_nothrow_convertible_v&lt;iter_rvalue_reference_t&lt;<i>InnerIter</i>&gt;, <i>rvalue_reference</i>&gt; &amp;&amp;
  is_nothrow_convertible_v&lt;iter_rvalue_reference_t&lt;<i>PatternIter</i>&gt;, <i>rvalue_reference</i>&gt;
</ins></pre>
</p>
</blockquote>
<pre><ins>friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) noexcept(<i>see below</i>)
  requires indirectly_swappable&lt;<i>InnerIter</i>, <i>PatternIter</i>&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>
-?- <i>Preconditions</i>: <code>x.<i>inner_it_</i>.valueless_by_exception()</code> and <code>y.<i>inner_it_</i>.valueless_by_exception()</code> are each <code>false</code>.
</ins>
</p>
<p>
<ins>
-?- <i>Effects</i>: Equivalent to: <code>visit(ranges::iter_swap, x.<i>inner_it_</i>, y.<i>inner_it_</i>)</code>.
</ins>
</p>
<p>
<ins>
-?- <i>Remarks</i>: The exception specification is equivalent to:
</ins>
<pre>
<ins>  noexcept(ranges::iter_swap(declval&lt;const <i>InnerIter</i>&amp;&gt;(), declval&lt;const <i>InnerIter</i>&amp;&gt;())) &amp;&amp;
  noexcept(ranges::iter_swap(declval&lt;const <i>PatternIter</i>&amp;&gt;(), declval&lt;const <i>PatternIter</i>&amp;&gt;()))</ins></pre>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3854"><a href="3854">3854</a>. &sect;[res.on.exception.handling]/3 should not be applied to all standard library types</h3>
<p><b>Section:</b> 16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-01-07 <b>Last modified:</b> 2023-02-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#res.on.exception.handling">active issues</a> in [res.on.exception.handling].</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.exception.handling">issues</a> in [res.on.exception.handling].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Some standard library types, such as <code>std::pair</code>, <code>std::tuple</code>, and <code>std::array</code>, 
are currently allowed to have a member or element type with a destructor that is <code>noexcept(false)</code>. 
In order to conform to 16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>/3, these types can't always have 
implicitly declared destructors because the implicit exception specification may be <code>noexcept(false)</code>.
<p/>
However, it may be intentional to implement these types with implicitly declared destructors, and 
mainstream implementations (libc++, libstdc++, and MSVC STL) are already doing so.
<p/>
Furtherly, explicitly declared destructors are not allowed for algorithm result types 
(26.5 <a href="https://timsong-cpp.github.io/cppwp/algorithms.results">[algorithms.results]</a>), while currently these class templates are allowed to be instantiated 
with classes with potentially throwing destructors, which is contradictory to 16.4.6.14 <a href="https://timsong-cpp.github.io/cppwp/res.on.exception.handling">[res.on.exception.handling]</a>/3.
</p>

<p><i>[2023-01-29; Daniel comments]</i></p>

<p>
This issue has very much overlap with LWG <a href="3229" title="&sect;[res.on.exception.handling]#3 cannot apply to types with implicitly declared destructors (Status: New)">3229</a>.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Unclear who the "shall" imposes requirements on. Maybe split into constraint
on the library to not put <code>noexcept(false)</code> on destructors, and
constraint on users that the library can assume destructors don't throw.
Should also make it clear which parts of the subclause are normative and
which are not.
</p>



<p id="res-3854"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3855"><a href="3855">3855</a>. <code><i>tiny-range</i></code> is not quite right</h3>
<p><b>Section:</b> 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-07 <b>Last modified:</b> 2025-04-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.lazy.split.view">active issues</a> in [range.lazy.split.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.lazy.split.view">issues</a> in [range.lazy.split.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>lazy_split_view</code> supports input range when the element of the pattern is less than or equal to 1. 
In order to ensure this condition at compile time, <code><i>tiny-range</i></code> constrains the type <code>R</code> to model 
<code>sized_range</code> and requires <code>(remove_reference_t&lt;R&gt;::size() &lt;= 1)</code> to be a constant expression.
<p/>
However, modeling a <code>sized_range</code> does not guarantee that <code>ranges::size</code> will be evaluated by <code>R::size()</code>.
For example, when <code>disable_sized_range&lt;R&gt;</code> is specialized to <code>true</code> or <code>R::size()</code> returns a non-integer-like type, 
<code>ranges::size</code> can still compute the size by subtracting the iterator-sentinel pair when both satisfy <code>sized_sentinel_for</code>.
<p/>
Since the <code>lazy_split_view</code>'s iterator uses <code>R::size()</code> to get the constant value of the pattern, 
we must ensure that this is indeed how <code>ranges::size</code> is calculated. Also, I think we can simplify 
<code><i>tiny-range</i></code> with <code>bool_constant</code> in a way similar to LWG <a href="3150" title="UniformRandomBitGenerator should validate min and max (Status: C++20)">3150</a>, which removes the 
introduction of <code><i>require-constant</i></code>.
</p>

<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Only matters for pathological types.
Maybe use <code>requires bool_constant&lt;ranges::size(r) &lt;= 1&gt;</code>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4917" title=" Working Draft, Standard for Programming Language C++">N4917</a>.
</p>

<ol>
<li><p>Modify 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  <del>template&lt;auto&gt; struct <i>require-constant</i>; <i>// exposition only</i></del>

  <del>template&lt;class R&gt;
  concept <i>tiny-range</i> = <i>// exposition only</i>
     sized_range&lt;R&gt; &amp;&amp;
     requires { typename <i>require-constant</i>&lt;remove_reference_t&lt;R&gt;::size()&gt;; } &amp;&amp;
     (remove_reference_t&lt;R&gt;::size() &lt;= 1);</del>
   
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
             (forward_range&lt;V&gt; || <i>tiny-range</i>&lt;Pattern&gt;)
  class lazy_split_view : public view_interface&lt;lazy_split_view&lt;V, Pattern&gt;&gt; {
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
<pre><ins>
template&lt;class R&gt;
concept <i>tiny-range</i> = <i>// exposition only</i>
   sized_range&lt;R&gt; &amp;&amp;
   requires { requires bool_constant&lt;(remove_reference_t&lt;R&gt;::size() &lt;= 1)&gt;::value; };
</ins></pre>
<blockquote>
<p><ins>
-?- Given an lvalue <code>r</code> of type <code>remove_reference_t&lt;R&gt;</code>, <code>R</code> models <code><i>tiny-range</i></code> only if
<code>ranges::size(r)</code> is evaluated by <code>remove_reference_t&lt;R&gt;::size()</code>.
</ins></p>
</blockquote>
<pre>
constexpr lazy_split_view(V base, Pattern pattern);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: : Initializes <code><i>base_</i></code> with <code>std::move(base)</code>, and <code><i>pattern_</i></code> with 
<code>std::move(pattern)</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-04-27, Hewill provides alternative wording]</i></p>



<p id="res-3855"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> This benefits from <a href="https://wg21.link/P2280" title=" Using unknown references in constant expressions">P2280</a> that a call to a
member function of a non-constexpr object can be a constant expression if it does 
not actually access the member.
<p/>
This would make <code>views::lazy_split(r, span&lt;int, 0&gt;{})</code> 
well-formed, which can be seen as an enhancement.]
</p>
</blockquote>

<blockquote>
<pre>
namespace std::ranges {
  <del>template&lt;auto&gt; struct <i>require-constant</i>;                       // <i>exposition only</i></del>

  template&lt;class R&gt;
  concept <i>tiny-range</i> =                                          // <i>exposition only</i>
    sized_range&lt;R&gt; &amp;&amp;
    <ins>requires (R&amp; r) { requires bool_constant&lt;ranges::size(r) &lt;= 1&gt;::value; }</ins>
    <del>requires { typename <i>require-constant</i>&lt;remove_reference_t&lt;R&gt;::size()>; } &amp;&amp;
    (remove_reference_t&lt;R&gt;::size() &lt;= 1)</del>;

  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
             (forward_range&lt;V&gt; || <i>tiny-range</i>&lt;Pattern&gt;)
  class lazy_split_view::view_interface&lt;lazy_split_view&lt;V, Pattern&gt;&gt; {
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.16.5 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.inner">[range.lazy.split.inner]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i>
We can't use <code>if constexpr (ranges::size(<i>i_</i>.<i>parent_</i>-&gt;<i>pattern_</i>) == 0)</code> 
here because it is not a constant expression, and it seems more intuitive to just use 
<code>ranges::empty</code> combined with runtime <code>if</code> which is always well-formed. 
Note that the PR does not seek the aggressive optimization that minimizes the instantiation as this is 
not the intent of the current design (for example, <code><i>outer-iterator</i>&amp; operator++()</code> 
can be specialized for the case where <code>Pattern::size() == 0</code> to save some O(1) comparisons), 
library implementations are free to optimize as it pleases.]
</p>
</blockquote>

<blockquote>
<pre>
constexpr <i>inner-iterator</i>&amp; operator++();
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<i>incremented_</i> = true;
if constexpr (!forward_range&lt;<i>Base</i>&gt;) {
  <ins>if (ranges::empty(<i>i_</i>.<i>parent_</i>-&gt;<i>pattern_</i>))</ins>
  <del>if constexpr (Pattern::size() == 0) {</del>
    return *this;
  }
}
++<i>i_</i>.<i>current</i>;
return *this;
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3856"><a href="3856">3856</a>. Unclear which conversion specifiers are valid for each chrono type</h3>
<p><b>Section:</b> 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tam S. B. <b>Opened:</b> 2023-01-14 <b>Last modified:</b> 2023-05-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.format">active issues</a> in [time.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.format">issues</a> in [time.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>/3:
<blockquote>
If the formatted object does not contain the information the conversion
specifier refers to, an exception of type <code>format_error</code> is thrown.
</blockquote>

30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>/6:
<blockquote>
If the type being formatted does not contain the information that the format
flag needs, an exception of type <code>format_error</code> is thrown.
</blockquote>
</p>

<p>
It's unclear how to determine if a type contain the needed information,
and implementations diverge.
</p>

<p>
For example, consider
</p>
<blockquote><pre>
#include &lt;chrono&gt;
#include &lt;format&gt;

auto f(std::chrono::month_day_last mdl) {
  return std::format("{:%j}", mdl);
}
</pre></blockquote>
<p>
Both libstdc++ and libc++ produce a compile-time error, claiming that the
argument does not contain the information, while MSVC STL throws
<code>format_error</code> at run time unless <code>mdl</code> is <code class='backtick'>January/last</code>,
in which case the function returns "031".
</p>
<p>
Another interesting case is <code>format("{:%d}", mdl)</code> where the value
can be printed for all months <i>except</i> February, which requires a year
to know how many days it has.
</p>

<p>
A related example from Jonathan Wakely:
</p>
<blockquote><pre>
std::chrono::weekday_indexed wdi(Monday, 7);  // 7th Monday in the month
assert( ! wdi.ok() );
assert( wdi.weekday().ok() );
std::format("{:%a}", wdi);
</pre></blockquote>
<p>
For <code>%a</code> the required information is "a valid weekday",
and arguably this does contain a valid weekday.
On the other hand, there's no 7th Monday, so this isn't valid.
Should this throw or not?
</p>
<p>
This was discussed by LWG and Howard Hinnant summarized the intended behaviour as:
<blockquote>
"The intention of 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>/6 is to address things like
formatting a <code>duration</code> with <code>%F</code>. A <code>duration</code> doesn't contain
the calendrical information that <code>%F</code> requires (year, month, day).
Ditto for using <code>%a</code> (weekday name) with a <code>year</code>.
It is meant to address mismatching <i>types</i> and flags,
and not meant to address <i>values</i>."
</blockquote>
</p>
<p>
The type <code>chrono::weekday</code> does contain the information needed to print
a weekday. A specific invalid value doesn't change that.
The type <code>chrono::month_day_last</code> does not contain the information
needed to print the day of the year.
A specific value where the day can be known doesn't change that.
The day of month is more interesting, and might need more discussion.
</p>
<p>
Jonathan proposed adding more examples to clarify the intention that only the
type matters, and not the value. There is some redundancy between p3 and p6.
Referring to "the formatted object" in p3 seems unclear.
Saying "type" as in p6 is better.
But p6 refers to "format flag" which is not defined,
whereas p3 uses "conversion specifier" (defined at the start of that paragraph).
The two uses of "flag" in p6 look like remnants from the earlier <code>chrono::format</code> 
feature that was replaced by integration with <code>std::format</code>.
</p>


<p><i>[2023-02-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2023-05-30; Jonathan adds wording]</i></p>




<p id="res-3856"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>
<li>
<p>Modify 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> as indicated:</p>

<blockquote>
<p> -3-
Each conversion specifier <i>conversion-spec</i> is replaced by appropriate
characters as described in Table 101 ([tab:time.format.spec]);
the formats specified in ISO 8601:2004 shall be used where so described.
Some of the conversion specifiers depend on the formatting locale.
If the string literal encoding is a Unicode encoding form and
the locale is among an implementation-defined set of locales,
each replacement that depends on the locale is performed as if
the replacement character sequence is converted to the string literal encoding.
If the <del>formatted object</del><ins>type being formatted</ins>
does not contain the information the conversion specifier refers to,
an exception of type <code>format_error</code> is thrown.
</p>
<p><ins>[<i>Example ?</i>:
A <code>duration</code> does not contain enough information to format as
a weekday using <code>%w</code>.
A <code>weekday_indexed</code> does contain enough information to format
using <code>%w</code> and <code>Monday[7]</code> can be formatted as
<code>"1"</code> even though <code>Monday[7].ok()</code> is <code>false</code>.
A <code>month_day</code> does not contain enough information to format as
the day of the year using <code>%j</code>, even when the <code>month()</code>
part is <code>January</code>.
&mdash; <i>end example</i>]</ins>
</p>
<p>
<ins>
However, if a flag refers to a "time of day"
(e.g., <code>%H</code>, <code>%I</code>, <code>%p</code>, etc.),
then a specialization of <code>duration</code> is interpreted as
the time of day elapsed since midnight.
</ins>
</p>

<p> -4-
The result of formatting a <code>std::chrono::duration</code> instance
holding a negative value, or an <code>hh_mm_ss</code> object <code>h</code>
for which <code>h.is_negative()</code> is <code>true</code>,
is equivalent to the output of the corresponding positive value,
with a <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;("-")</code>
character sequence placed before the replacement of the initial conversion
specifier.
</p>
<p>[<i>Example 1</i>:
<pre><code>
cout &lt;&lt; format("{:%T}", -10'000s);          // prints: -02:46:40
cout &lt;&lt; format("{:%H:%M:%S}", -10'000s);    // prints: -02:46:40
cout &lt;&lt; format("minutes {:%M, hours %H, seconds %S}", -10'000s);
                                            // prints: minutes -46, hours 02, seconds 40
</code></pre>
&mdash; <i>end example</i>]
</p>
<p> -5-
Unless explicitly requested, the result of formatting a chrono type
does not contain time zone abbreviation and time zone offset information.
If the information is available, the conversion specifiers <code>%Z</code> and
<code>%z</code> will format this information (respectively).
</p>
<p>[<i>Note 1</i>:
If the information is not available and a <code>%Z</code> or <code>%z</code>
conversion specifier appears in the <i>chrono-format-spec</i>,
an exception of type <code>format_error</code> is thrown, as described above.
&mdash; <i>end note</i>]
</p>
<p> <del>-6-
If the type being formatted does not contain the information that the format flag needs,
an exception of type <code>format_error</code> is thrown, as described above.
</del>
</p>
<p><del>[<i>Example 2</i>:
A <code>duration</code> does not contain enough information to format as a
<code>weekday</code>.
&mdash; <i>end example</i>]
</del>
</p>
<p>
<del>
However, if a flag refers to a "time of day"
(e.g., <code>%H</code>, <code>%I</code>, <code>%p</code>, etc.),
then a specialization of <code>duration</code> is interpreted as
the time of day elapsed since midnight.
</del>
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3863"><a href="3863">3863</a>. Is <code>input_iterator</code> guaranteed to have <code>iter_const_reference_t</code>?</h3>
<p><b>Section:</b> 24.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.alias">[const.iterators.alias]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-26 <b>Last modified:</b> 2023-02-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the C++20 iterator system, <code>input_iterator</code> is guaranteed to have a common reference, which 
reflects the <code>indirectly_readable</code> requires 
<code>common_reference_t&lt;iter_reference_t&lt;I&gt;&amp;&amp;, iter_value_t&lt;I&gt;&amp;&gt;</code> to be a valid type.
<p/>
However, for <code>iter_const_reference_t</code> which with a similar form:
</p>
<blockquote><pre>
template&lt;indirectly_readable It&gt;
  using iter_const_reference_t =
    common_reference_t&lt;const iter_value_t&lt;It&gt;&amp;&amp;, iter_reference_t&lt;It&gt;&gt;;
</pre></blockquote>
<p>
it is still theoretically possible to create an <code>input_iterator</code> that does not have a valid 
<code>iter_const_reference_t</code>, <a href="https://godbolt.org/z/oY3xoqPMa">for example</a>:
</p>
<blockquote><pre>
#include &lt;iterator&gt;

struct ref {
  ref(int&amp;);
};

struct rref {
  rref(const int&amp;);
  rref(const ref&amp;);
};

struct I {
  using value_type = int;
  using difference_type = std::ptrdiff_t;

  ref operator*() const;
  I&amp; operator++();
  I operator++(int);

  friend rref iter_move(const I&amp;);
};

static_assert(std::input_iterator&lt;I&gt;); // pass
using CR = std::iter_const_reference_t&lt;I&gt;;  // <span style="color:red;font-weight:bolder">error: no type named 'type' in 'struct std::common_reference&lt;const int&amp;&amp;, ref&gt;'</span>
</pre></blockquote>
<p>
which causes <code>basic_const_iterator&lt;I&gt;</code> to produce a hard error internally when it is instantiated.
</p>

<p><i>[2023-02-06; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
Seems contrived, should probably constrain not give a hard error.
The question of whether each range needs to have const reference to elems
is important.
</p>



<p id="res-3863"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3864"><a href="3864">3864</a>. <code>zip</code> over range of reference to an abstract type</h3>
<p><b>Section:</b> 25.7.25 <a href="https://timsong-cpp.github.io/cppwp/range.zip">[range.zip]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2023-01-28 <b>Last modified:</b> 2023-02-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct Abstract {
  virtual ~Abstract() = default;
  virtual int f() = 0;
};

struct Concrete : Abstract {
  int f() override { return 42; }
};

int main() {
  Concrete c[10];

  auto xformed = c | std::views::transform([](Concrete&amp; c) -&gt; Abstract&amp; {
    return c;
  });

  for (Abstract&amp; a : xformed) { }  // <span style="color:green;font-weight:bold">ok</span>

  auto zipped = std::views::zip(xformed);

  for (auto&amp;&amp; [a] : zipped) { }    // <span style="color:red;font-weight:bolder">error</span>
}
</pre></blockquote>
<p>
Here, <code>xformed</code> is a range whose reference type is <code>Abstract&amp;</code> and whose <code>value_type</code> is <code>Abstract</code>. 
Even though you can't actually create a value of that <code>value_type</code>, that's okay here, because no code is actually trying to do so.
<p/>
On the other hand, <code>zipped</code> is a range whose reference type is <code>std::tuple&lt;Abstract&amp;&gt;</code> and whose 
<code>value_type</code> is <code>std::tuple&lt;Abstract&gt;</code>. No code here is actually trying to construct a <code>value_type</code> either, 
but this code fails because simply instantiating <code>std::tuple&lt;Abstract&gt;</code> is an error. There's no other possible 
<code>value_type</code> for <code>zipped</code> to have, <code>std::tuple&lt;Abstract&gt;</code> is correct &mdash; it's just that it happens 
to be an ill-formed type in this context. There are workarounds for this case &mdash; you would have to make <code>xformed</code> 
be a range of <code>Abstract*</code> or, probably better, a range of <code>reference_wrapper&lt;Abstract&gt;</code> instead. 
<p/>
This is unfortunate because many (most?) algorithms don't actually make any use of a range's <code>value_type</code>. The ones that do 
(like <code>ranges::min</code>) obviously could not work, but currently we end up rejecting all uses. Probably the only possible way to 
make this work is to allow <code>value_type</code> to be <code>void</code> (or absent), but it is currently a fairly fundamental type due 
to its use in <code>indirectly_readable</code> to identify input iterators.
</p>

<p><i>[2023-02-06; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Several votes for NAD. Maybe <code>tuple&lt;Abstract&gt;</code> should be
explicitly made ill-formed (currently seems underspecified) or should be
"disabled" like invalid <code>hash</code> specializations and formatters.
</p>



<p id="res-3864"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3868"><a href="3868">3868</a>. Constrained algorithms should not require <code>output_iterator</code></h3>
<p><b>Section:</b> 26.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a>, 26.7.6 <a href="https://timsong-cpp.github.io/cppwp/alg.fill">[alg.fill]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-01-29 <b>Last modified:</b> 2024-06-28</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++20, <code>output_iterator</code> is required to support <code>*o++ = t</code> mainly for backward compatibility,
that is to say, in addition to avoiding needless breakage, this semantic is actually not very useful, as it can 
be equivalently replaced by <code>*o = t; ++o;</code>.
<p/>
This is reflected in the current implementation for constrained algorithms in libstdc++ and MSVC-STL. 
Even if the algorithm explicitly requires <code>output_iterator</code>, there is no code of the form <code>*o++ = t</code> in practice,
and the latter of a more generic form is used instead.
<p/>
It seems to me that constrained algorithms should never require <code>output_iterator</code>, since there really isn't
any desirable reason to use <code>*o++ = t</code> in the new iterator system.
It would be more appropriate to relax <code>output_iterator</code> to <code>weakly_incrementable</code> 
(or <code>input_or_output_iterator</code>) and <code>indirectly_writable</code>,
given that many constrained algorithms already do that.
</p>

<p><i>[2023-02-06; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Send to LEWG.
Several votes for NAD.
</p>

<p><i>[St. Louis 2024-06-28; LWG and SG9 joint session]</i></p>

<p>
Poll: SG9 and LWG believe this is not a defect, but we do agree that there are inconsistencies that need a paper to address more thoroughly
<pre>
|SF| F| N| A|SA|
| 6| 2| 0| 0| 0|
</pre>
</p>



<p id="res-3868"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>
<li><p>Modify 26.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a>, header <code>&lt;algorithm&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;initializer_list&gt;     // <i>see 17.11.2 <a href="https://timsong-cpp.github.io/cppwp/initializer.list.syn">[initializer.list.syn]</a></i>

namespace std {
  [&hellip;]
  namespace ranges {
    template&lt;class I, class O&gt;
      using replace_copy_result = in_out_result&lt;I, O&gt;;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T1, class T2,
             <ins>weakly_incrementable</ins><del>output_iterator&lt;const T2&amp;&gt;</del> O, class Proj = identity&gt;
      requires <ins>indirectly_writable&lt;O, const T2&amp;&gt; &amp;&amp;</ins> indirectly_copyable&lt;I, O&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T1*&gt;
      constexpr replace_copy_result&lt;I, O&gt;
        replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,
                     Proj proj = {});
    template&lt;input_range R, class T1, class T2, <ins>weakly_incrementable</ins><del>output_iterator&lt;const T2&amp;&gt;</del> O,
             class Proj = identity&gt;
      requires <ins>indirectly_writable&lt;O, const T2&amp;&gt; &amp;&amp;</ins> indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               indirect_binary_predicate&lt;ranges::equal_to,
                                         projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
      constexpr replace_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        replace_copy(R&amp;&amp; r, O result, const T1&amp; old_value, const T2&amp; new_value,
                     Proj proj = {});

    template&lt;class I, class O&gt;
      using replace_copy_if_result = in_out_result&lt;I, O&gt;;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, <ins>weakly_incrementable</ins><del>output_iterator&lt;const T&amp;&gt;</del> O,
             class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires <ins>indirectly_writable&lt;O, const T&amp;&gt; &amp;&amp;</ins> indirectly_copyable&lt;I, O&gt;
      constexpr replace_copy_if_result&lt;I, O&gt;
        replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,
                        Proj proj = {});
    template&lt;input_range R, class T, <ins>weakly_incrementable</ins><del>output_iterator&lt;const T&amp;&gt;</del> O, class Proj = identity,
             indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires <ins>indirectly_writable&lt;O, const T&amp;&gt; &amp;&amp;</ins> indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr replace_copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        replace_copy_if(R&amp;&amp; r, O result, Pred pred, const T&amp; new_value,
                        Proj proj = {});
  }
  [&hellip;]
  namespace ranges {
    template&lt;class T, <ins>input_or_output_iterator</ins><del>output_iterator&lt;const T&amp;&gt;</del> O, sentinel_for&lt;O&gt; S&gt;
      <ins>requires indirectly_writable&lt;O, const T&amp;&gt;</ins>
      constexpr O fill(O first, S last, const T&amp; value);
    template&lt;class T, output_range&lt;const T&amp;&gt; R&gt;
      constexpr borrowed_iterator_t&lt;R&gt; fill(R&amp;&amp; r, const T&amp; value);
    template&lt;class T, <ins>input_or_output_iterator</ins><del>output_iterator&lt;const T&amp;&gt;</del> O&gt;
      <ins>requires indirectly_writable&lt;O, const T&amp;&gt;</ins>
      constexpr O fill_n(O first, iter_difference_t&lt;O&gt; n, const T&amp; value);
  }
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 26.7.5 <a href="https://timsong-cpp.github.io/cppwp/alg.replace">[alg.replace]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T1, class T2, <ins>weakly_incrementable</ins><del>output_iterator&lt;const T2&amp;&gt;</del> O, 
         class Proj = identity&gt;
  requires <ins>indirectly_writable&lt;O, const T2&amp;&gt; &amp;&amp;</ins> indirectly_copyable&lt;I, O&gt; &amp;&amp;
           indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T1*&gt;
constexpr ranges::replace_copy_result&lt;I, O&gt;
  ranges::replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,
                       Proj proj = {});
template&lt;input_range R, class T1, class T2, <ins>weakly_incrementable</ins><del>output_iterator&lt;const T2&amp;&gt;</del> O,
         class Proj = identity&gt;
  requires <ins>indirectly_writable&lt;O, const T2&amp;&gt; &amp;&amp;</ins> indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
           indirect_binary_predicate&lt;ranges::equal_to, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
constexpr ranges::replace_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
  ranges::replace_copy(R&amp;&amp; r, O result, const T1&amp; old_value, const T2&amp; new_value,
                       Proj proj = {});

template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, <ins>weakly_incrementable</ins><del>output_iterator&lt;const T&amp;&gt;</del> O,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires <ins>indirectly_writable&lt;O, const T&amp;&gt; &amp;&amp;</ins> indirectly_copyable&lt;I, O&gt;
constexpr ranges::replace_copy_if_result&lt;I, O&gt;
  ranges::replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,
                          Proj proj = {});
template&lt;input_range R, class T, <ins>weakly_incrementable</ins><del>output_iterator&lt;const T&amp;&gt;</del> O, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires <ins>indirectly_writable&lt;O, const T&amp;&gt; &amp;&amp;</ins> indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
constexpr ranges::replace_copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
  ranges::replace_copy_if(R&amp;&amp; r, O result, Pred pred, const T&amp; new_value,
                          Proj proj = {});

</pre>
<blockquote>
<p>
-6- Let <i>E</i> be
<p/>
[&hellip;]
</p>
</blockquote>

</blockquote>
</li>


<li><p>Modify 26.7.6 <a href="https://timsong-cpp.github.io/cppwp/alg.fill">[alg.fill]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;class T, <ins>input_or_output_iterator</ins><del>output_iterator&lt;const T&amp;&gt;</del> O, sentinel_for&lt;O&gt; S&gt;
  <ins>requires indirectly_writable&lt;O, const T&amp;&gt;</ins>
  constexpr O ranges::fill(O first, S last, const T&amp; value);
template&lt;class T, output_range&lt;const T&amp;&gt; R&gt;
  constexpr borrowed_iterator_t&lt;R&gt; ranges::fill(R&amp;&amp; r, const T&amp; value);
template&lt;class T, <ins>input_or_output_iterator</ins><del>output_iterator&lt;const T&amp;&gt;</del> O&gt;
  <ins>requires indirectly_writable&lt;O, const T&amp;&gt;</ins>
  constexpr O ranges::fill_n(O first, iter_difference_t&lt;O&gt; n, const T&amp; value);
</pre>
<blockquote>
<p>
-1- Let <i>N</i> be max(0, <code>n</code>) for the <code>fill_n</code> algorithms, and <code>last - first</code> for the <code>fill</code> algorithms.
<p/>
[&hellip;]
</p>
</blockquote>

</blockquote>
</li>

</ol>




<hr>
<h3 id="3873"><a href="3873">3873</a>. <code>join_with_view</code>'s <code>const begin</code> is underconstrained</h3>
<p><b>Section:</b> 25.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.view">[range.join.with.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-02-04 <b>Last modified:</b> 2023-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.with.view">issues</a> in [range.join.with.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to ensure that the pattern range is compatible with the inner range, 
<code>join_with_view</code> requires that the two range types must satisfy <code><i>compatible-joinable-ranges</i></code>, 
which requires that the value type, reference type, and rvalue reference type of the two range types share a common type.
<p/>
However, when the two range types are <code>const</code>-qualified, there is no guarantee that their common 
reference type still exists, in which case a hard error may occur since <code>join_with_view</code>'s <code>const begin</code> 
does not check for this (<a href="https://godbolt.org/z/hb6c3rxM4">online example</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct S {
  S(const int&amp;);
  S(int&amp;&amp;);
  S(const int&amp;&amp;) = delete;
};

int main() {
  const auto r = std::views::single(std::views::single(0))
               | std::views::join_with(std::views::single(S{0}));
  auto e = std::ranges::iter_move(r.begin()); // <span style="color:red;font-weight:bolder">hard error</span>
}
</pre></blockquote>

<p><i>[Issaquah 2023-02-10; LWG issue processing]</i></p>

<p> Set priority to 3. </p>



<p id="res-3873"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3882"><a href="3882">3882</a>. <code>tuple</code> relational operators have confused friendships</h3>
<p><b>Section:</b> 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Corentin Jabot <b>Opened:</b> 2023-02-08 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>:
</p>
<blockquote><pre>
template&lt;class... TTypes, <i>tuple-like</i> UTuple>
  constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const UTuple&amp; u);
</pre></blockquote>
<p>
Is defined as a non-member non-friend function that "is to be found via argument-dependent lookup only."
<p/>
The intent is that it should be defined as a hidden friend in <code>tuple</code>.
<p/>
The current specification is confusing as to which class should contain that hidden friend, or how to otherwise 
implement that adl only restriction. (An hostile reading may consider it to be a hidden friend of <code>UTuple</code>), 
and does not follow the guidance of <a href="https://wg21.link/P1601" title=" Recommendations for Specifying Hidden Friends">P1601</a> "Recommendations for Specifying ``Hidden Friends''".
<p/>
We should consider making these <code>operator==</code> and <code>operator&lt;=&gt;</code> overloads hidden friends of 
<code>tuple</code>, i.e.
</p>
<blockquote><pre>
std::tuple {
  template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
  friend constexpr bool operator==(const tuple&amp; t, const UTuple&amp; u);
  template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
  friend constexpr <i>see below</i> operator&lt;=&gt;(const tuple&amp;, const UTuple&amp;);
};
</pre></blockquote>

<p><i>[2023-02-18; Daniel provides wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>
<li><p>Modify 22.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.syn">[tuple.syn]</a>, header <code>&lt;tuple&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  // <i>22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, relational operators</i>
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  <del>template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const UTuple&amp;);</del>
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
      operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  <del>template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
    constexpr <i>see below</i> operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const UTuple&amp;);</del>
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, class template <code>tuple</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class... Types&gt;
  class tuple {
  public:
    [&hellip;]

    template&lt;<i>tuple-like</i> UTuple&gt;
      constexpr tuple&amp; operator=(UTuple&amp;&amp;);
    template&lt;<i>tuple-like</i> UTuple&gt;
      constexpr const tuple&amp; operator=(UTuple&amp;&amp;) const;

    <ins>// <i>22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, relational operators</i></ins>
    <ins>template&lt;<i>tuple-like</i> UTuple&gt;
      friend constexpr bool operator==(const tuple&amp;, const UTuple&amp;);</ins>
    <ins>template&lt;<i>tuple-like</i> UTuple&gt;
      friend constexpr <i>see below</i> operator&lt;=&gt;(const tuple&amp;, const UTuple&amp;);</ins>

    // <i>22.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a>, tuple swap</i>
    constexpr void swap(tuple&amp;) noexcept(<i>see below</i>);
    constexpr void swap(const tuple&amp;) const noexcept(<i>see below</i>);
  };
}
</pre>
</blockquote>

</li>


<li><p>Modify 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
template&lt;<del>class... TTypes,</del> <i>tuple-like</i> UTuple&gt;
  <ins>friend</ins> constexpr bool operator==(const tuple<del>&lt;TTypes...&gt;</del>&amp; t, const UTuple&amp; u);
</pre>
<blockquote>
<p>
-1- For the first overload let <code>UTuple</code> be <code>tuple&lt;UTypes...&gt;</code>. <ins>For the second overload
let <code>TTypes</code> denote the pack <code>Types</code>.</ins>
<p/>
[&hellip;]
<p/>
-5- <i>Remarks</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; The elementary comparisons are performed in order from the zeroth index upwards. No comparisons
or element accesses are performed after the first equality comparison that evaluates to <code>false</code>.</p></li>
<li><p>(5.2) &mdash; The second overload is to be found via argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>) only.</p></li>
</ol>
</blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
    operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
template&lt;<del>class... TTypes,</del> <i>tuple-like</i> UTuple&gt;
  <ins>friend</ins> constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;<del>T</del>Types, Elems&gt;...&gt; 
    operator&lt;=&gt;(const tuple<del>&lt;TTypes...&gt;</del>&amp; t, const UTuple&amp; u);
</pre>
<blockquote>
<p>
-6- For the second overload, <ins>let <code>TTypes</code> denote the pack <code>Types</code> and</ins> <code>Elems</code> denotes the 
pack of types <code>tuple_element_t&lt;0, UTuple&gt;, tuple_element_t&lt;1, UTuple&gt;, ... , 
tuple_element_t&lt;tuple_size_v&lt;UTuple&gt; - 1, UTuple&gt;</code>.
<p/>
[&hellip;]
<p/>
-8- <i>Remarks</i>: The second overload is to be found via argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>) only.
</p>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2023-03-05; Daniel comments and provides improved wording]</i></p>

<p>
The revised wording ensures that no ambiguity exists between the overload candidates, furthermore the additional wording about
being found via argument-dependent lookup only has been eliminated, because the general conventions of 16.4.6.6 <a href="https://timsong-cpp.github.io/cppwp/hidden.friends">[hidden.friends]</a>
apply. 
<p/>
The reusage of the exposition-only concept <code><i>different-from</i></code> is already existing practice in various places of 
22.4 <a href="https://timsong-cpp.github.io/cppwp/tuple">[tuple]</a>. We have also existing wording practice where we have an extra <i>Constraints:</i> element added even though 
a prototype has already a language constraint as part of its signature.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3882"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>
<li><p>Modify 22.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.syn">[tuple.syn]</a>, header <code>&lt;tuple&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  // <i>22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, relational operators</i>
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  <del>template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const UTuple&amp;);</del>
  template&lt;class... TTypes, class... UTypes&gt;
    constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
      operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
  <del>template&lt;class... TTypes, <i>tuple-like</i> UTuple&gt;
    constexpr <i>see below</i> operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const UTuple&amp;);</del>
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 22.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.tuple">[tuple.tuple]</a>, class template <code>tuple</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class... Types&gt;
  class tuple {
  public:
    [&hellip;]

    template&lt;<i>tuple-like</i> UTuple&gt;
      constexpr tuple&amp; operator=(UTuple&amp;&amp;);
    template&lt;<i>tuple-like</i> UTuple&gt;
      constexpr const tuple&amp; operator=(UTuple&amp;&amp;) const;

    <ins>// <i>22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a>, relational operators</i></ins>
    <ins>template&lt;<i>tuple-like</i> UTuple&gt;
      friend constexpr bool operator==(const tuple&amp;, const UTuple&amp;);</ins>
    <ins>template&lt;<i>tuple-like</i> UTuple&gt;
      friend constexpr <i>see below</i> operator&lt;=&gt;(const tuple&amp;, const UTuple&amp;);</ins>

    // <i>22.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/tuple.swap">[tuple.swap]</a>, tuple swap</i>
    constexpr void swap(tuple&amp;) noexcept(<i>see below</i>);
    constexpr void swap(const tuple&amp;) const noexcept(<i>see below</i>);
  };
}
</pre>
</blockquote>

</li>


<li><p>Modify 22.4.9 <a href="https://timsong-cpp.github.io/cppwp/tuple.rel">[tuple.rel]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
template&lt;<del>class... TTypes,</del> <i>tuple-like</i> UTuple&gt;
  <ins>friend</ins> constexpr bool operator==(const tuple<del>&lt;TTypes...&gt;</del>&amp; t, const UTuple&amp; u);
</pre>
<blockquote>
<p>
-1- For the first overload let <code>UTuple</code> be <code>tuple&lt;UTypes...&gt;</code>. <ins>For the second overload
let <code>TTypes</code> denote the pack <code>Types</code>.</ins>
<p/>
<ins>-?- <i>Constraints</i>: For the second overload, <code><i>different-from</i>&lt;UTuple, tuple&gt;</code> 
(25.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>) is <code>true</code>.</ins>
<p/>
-2- <i>Mandates</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-5- <i>Remarks</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(5.1) &mdash;</del> The elementary comparisons are performed in order from the zeroth index upwards. No comparisons
or element accesses are performed after the first equality comparison that evaluates to <code>false</code>.</p></li>
<li><p><del>(5.2) &mdash; The second overload is to be found via argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>) only.</del></p></li>
</ol>
</blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
  constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;TTypes, UTypes&gt;...&gt;
    operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
template&lt;<del>class... TTypes,</del> <i>tuple-like</i> UTuple&gt;
  <ins>friend</ins> constexpr common_comparison_category_t&lt;<i>synth-three-way-result</i>&lt;<del>T</del>Types, Elems&gt;...&gt; 
    operator&lt;=&gt;(const tuple<del>&lt;TTypes...&gt;</del>&amp; t, const UTuple&amp; u);
</pre>
<blockquote>
<p>
-6- For the second overload, <ins>let <code>TTypes</code> denote the pack <code>Types</code> and</ins> <code>Elems</code> denotes the 
pack of types <code>tuple_element_t&lt;0, UTuple&gt;, tuple_element_t&lt;1, UTuple&gt;, ... , 
tuple_element_t&lt;tuple_size_v&lt;UTuple&gt; - 1, UTuple&gt;</code>.
<p/>
<ins>-?- <i>Constraints</i>: For the second overload, <code><i>different-from</i>&lt;UTuple, tuple&gt;</code> 
(25.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.helpers">[range.utility.helpers]</a>) is <code>true</code>.</ins>
<p/>
-7- <i>Effects</i>: [&hellip;]
<p/>
<del>-8- <i>Remarks</i>: The second overload is to be found via argument-dependent lookup (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>) only.</del>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3883"><a href="3883">3883</a>. &sect;[support.c.headers.other] Ambiguity in the requirements for includes</h3>
<p><b>Section:</b> 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alex Mills <b>Opened:</b> 2023-02-09 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.c.headers.other">active issues</a> in [support.c.headers.other].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.c.headers.other">issues</a> in [support.c.headers.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a>, it states that the <code>&lt;<i>name</i>.h&gt;</code> headers behave 
"as if each name placed in the standard library namespace by the corresponding header is placed within the 
global namespace scope". There are exceptions for several different definitions in the headers, but it's left 
ambiguous as to whether their inclusion in the <code>&lt;<i>name</i>.h&gt;</code> headers is required or unspecified.
<p/>
While it is clear that, for example, <code>::byte</code> is prohibited, it isn't clear whether <code>std::byte</code> 
is required to be included at all (this applies to the other listed exceptions as well). Though example 1 makes 
it appear that their inclusion requirements are meant to be left unspecified, paragraph 1 does not provide clarification. 
Adding specific wording will ensure this will not be misinterpreted in the future.
<p/>
To do this, we should append a sentence to [support.c.headers.other] p1:
</p>
<blockquote><p>
Whether the listed exceptions are included in their corresponding <code>&lt;<i>name</i>.h&gt;</code> headers under 
the standard library namespace is unspecified.
</p></blockquote>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"The new wording is confusingly inconsistent with the existing wording
in that paragraph. Would prefer '... Whether the listed exceptions are declared
in the namespace std by their corresponding <code>&lt;name.h&gt;</code>
headers is unspecified.'."
</p>



<p id="res-3883"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>
<li><p>Modify 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a> as indicated:</p>

<blockquote>
<p>
-1- Every C header other than <code>&lt;complex.h&gt;</code> (17.15.2 <a href="https://timsong-cpp.github.io/cppwp/complex.h.syn">[complex.h.syn]</a>), 
<code>&lt;iso646.h&gt;</code> (17.15.3 <a href="https://timsong-cpp.github.io/cppwp/iso646.h.syn">[iso646.h.syn]</a>), 
<code>&lt;stdalign.h&gt;</code> (17.15.4 <a href="https://timsong-cpp.github.io/cppwp/stdalign.h.syn">[stdalign.h.syn]</a>),
<code>&lt;stdatomic.h&gt;</code> (32.5.12 <a href="https://timsong-cpp.github.io/cppwp/stdatomic.h.syn">[stdatomic.h.syn]</a>), 
<code>&lt;stdbool.h&gt;</code> (17.15.5 <a href="https://timsong-cpp.github.io/cppwp/stdbool.h.syn">[stdbool.h.syn]</a>), and 
<code>&lt;tgmath.h&gt;</code> (17.15.6 <a href="https://timsong-cpp.github.io/cppwp/tgmath.h.syn">[tgmath.h.syn]</a>), each 
of which has a name of the form <code>&lt;<i>name</i>.h&gt;</code>, behaves as if each name placed in 
the standard library namespace by the corresponding <code>&lt;c<i>name</i>&gt;</code> header is placed 
within the global namespace scope, except for the functions described in 29.7.6 <a href="https://timsong-cpp.github.io/cppwp/sf.cmath">[sf.cmath]</a>,
the <code>std::lerp</code> function overloads (29.7.4 <a href="https://timsong-cpp.github.io/cppwp/c.math.lerp">[c.math.lerp]</a>), the declaration of 
<code>std::byte</code> (17.2.1 <a href="https://timsong-cpp.github.io/cppwp/cstddef.syn">[cstddef.syn]</a>), and the functions and function templates described 
in 17.2.5 <a href="https://timsong-cpp.github.io/cppwp/support.types.byteops">[support.types.byteops]</a>. 
It is unspecified whether these names are first declared or defined within namespace scope 
(6.4.6 <a href="https://timsong-cpp.github.io/cppwp/basic.scope.namespace">[basic.scope.namespace]</a>) of the namespace <code>std</code> and are then injected into the 
global namespace scope by explicit <i>using-declarations</i> (9.10 <a href="https://timsong-cpp.github.io/cppwp/namespace.udecl">[namespace.udecl]</a>).
<ins>Whether the listed exceptions are included in their corresponding <code>&lt;<i>name</i>.h&gt;</code> 
headers under the standard library namespace is unspecified.</ins>
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3888"><a href="3888">3888</a>. Most ranges uninitialized memory algorithms are underconstrained</h3>
<p><b>Section:</b> 26.11.8 <a href="https://timsong-cpp.github.io/cppwp/specialized.construct">[specialized.construct]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-02-17 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#specialized.construct">issues</a> in [specialized.construct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3870" title="Remove voidify (Status: C++23)">3870</a> removed the support for constructing objects via <i>cv</i>-qualified lvalues. 
However, it had not changed anything in the immediate context, which means some previously permitted 
usages become hard errors instead of substitution failures.
<p/>
Note that <code>ranges::uninitialized_default_construct</code> and <code>ranges::uninitialized_default_construct_n</code> 
are underconstrained even before LWG <a href="3870" title="Remove voidify (Status: C++23)">3870</a>, because <code>remove_reference_t&lt;iter_reference_t&lt;I&gt;&gt;</code> 
may be a <code>const</code> type, while only it's <i>cv</i>-unqualified version (<code>iter_value_t&lt;I&gt;</code>) 
is required to be <code>default_initializable</code>.
<p/>
<code>construct_at</code> and <code>ranges::construct_at</code> are also made underconstrained because the function 
body is no longer valid when <code>T</code> is <i>cv</i>-qualified, which is not reflected in <i>Constraints:</i>.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3888"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>
<li><p>Modify 26.11.2 <a href="https://timsong-cpp.github.io/cppwp/special.mem.concepts">[special.mem.concepts]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class I&gt;
concept <i>nothrow-input-iterator</i> = // <i>exposition only</i>
  input_iterator&lt;I&gt; &amp;&amp;
  is_lvalue_reference_v&lt;iter_reference_t&lt;I&gt;&gt; &amp;&amp;
  <ins>same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;, remove_reference_t&lt;iter_reference_t&lt;I&gt;&gt; &amp;&amp;</ins>
  same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;, iter_value_t&lt;I&gt;&gt;;
</pre>
</blockquote>

</li>

<li><p>Modify 26.11.8 <a href="https://timsong-cpp.github.io/cppwp/specialized.construct">[specialized.construct]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt;
  constexpr T* construct_at(T* location, Args&amp;&amp;... args);

namespace ranges {
  template&lt;class T, class... Args&gt;
    constexpr T* construct_at(T* location, Args&amp;&amp;... args);
}
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <ins><code>T</code> is a <i>cv</i>-unqualified type, and t</ins><del>T</del>he expression 
<code>::new (declval&lt;void*&gt;()) T(declval&lt;Args&gt;()...)</code> is well-formed when treated 
as an unevaluated operand (7.2.3 <a href="https://timsong-cpp.github.io/cppwp/expr.context">[expr.context]</a>).
<p/>
-2- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
return ::new (<i>voidify</i>(*location)) T(std::forward&lt;Args&gt;(args)...);
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3889"><a href="3889">3889</a>. <code>std::(ranges::)destroy_at</code> should destroy array elements in the decreasing index order</h3>
<p><b>Section:</b> 26.11.9 <a href="https://timsong-cpp.github.io/cppwp/specialized.destroy">[specialized.destroy]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-02-17 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>std::(ranges::)destroy_at</code> is specified to destroy array elements in the increasing index order 
(26.11.9 <a href="https://timsong-cpp.github.io/cppwp/specialized.destroy">[specialized.destroy]</a>/1.1), which is inconsistent with the decreasing order specified in the core language 
(11.4.7 <a href="https://timsong-cpp.github.io/cppwp/class.dtor">[class.dtor]</a>/13) and the order for arrays created by <code>std::make_shared</code> and 
<code>std::allocate_shared</code> (mandated by LWG <a href="3005" title="Destruction order of arrays by make_shared/allocate_shared only recommended? (Status: C++20)">3005</a>).
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>

<li><p>Modify 26.11.9 <a href="https://timsong-cpp.github.io/cppwp/specialized.destroy">[specialized.destroy]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr void destroy_at(T* location);

namespace ranges {
  template&lt;destructible T&gt;
    constexpr void destroy_at(T* location) noexcept;
}
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If <code>T</code> is an array type, equivalent to <code>destroy(<ins>rbegin</ins><del>begin</del>(*location), <ins>rend</ins><del>end</del>(*location))</code>.</p></li>
<li><p>(1.2) &mdash; Otherwise, equivalent to <code>location-&gt;~T()</code>.</p></li>
</ol>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2023-02-26; Daniel comments and provides alternative wording]</i></p>

<p>
The suggested fix indeed corrects an inconsistency, but also implies a silent behaviour change at runtime, since at least MSVC STL and
libstdc++ implement the array destruction order as specified (others not tested). 
The below wording therefore suggests to introduce a specific feature macro for this, so that user code can potentially react on this,
regardless of potential vendor API breakage hesitations. 
The natural feature macro to increase would be that which introduced the specific array destruction behavior of <code>destroy_at</code>, 
which was <a href="https://wg21.link/P0896R4" title=" The One Ranges Proposal">P0896R4</a>, and which introduced <code>__cpp_lib_ranges</code>, on the other hand the specification change affects 
both the <code>std::ranges</code> and the <code>std</code> forms of <code>destroy_at</code>, so it seems plausible to suggest a new, specific feature 
macro for both <code>destroy_at</code> function templates. This is what the proposed wording does.
<p/>
LWG should clarify whether an entry to C.2 <a href="https://timsong-cpp.github.io/cppwp/diff.cpp20">[diff.cpp20]</a> should be added as well.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3889"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>

<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a>, header <code>&lt;version&gt;</code> synopsis, as indicated and replace
the placeholder <code>YYYYMML</code> by the year and month of adoption of this issue:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_coroutine         201902L  // <i>also in &lt;coroutine&gt;</i>
<ins>#define __cpp_lib_destroy_at        YYYYMML  // <i>also in &lt;memory&gt;</i></ins>
#define __cpp_lib_destroying_delete 201806L  // <i>also in &lt;new&gt;</i>
[&hellip;]
</pre>
</blockquote>

</li>



<li><p>Modify 26.11.9 <a href="https://timsong-cpp.github.io/cppwp/specialized.destroy">[specialized.destroy]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr void destroy_at(T* location);

namespace ranges {
  template&lt;destructible T&gt;
    constexpr void destroy_at(T* location) noexcept;
}
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; If <code>T</code> is an array type, equivalent to <code>destroy(<ins>rbegin</ins><del>begin</del>(*location), <ins>rend</ins><del>end</del>(*location))</code>.</p></li>
<li><p>(1.2) &mdash; Otherwise, equivalent to <code>location-&gt;~T()</code>.</p></li>
</ol>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3890"><a href="3890">3890</a>. ABI issue for integer-class types</h3>
<p><b>Section:</b> 24.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-02-19 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.concept.winc">issues</a> in [iterator.concept.winc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently integer-class types are required to be wider than every integer type 
(24.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>/3). As a result, if compiler provides extended integer types 
later whose width are not less than that of an integer-class type, then integer-class types with 
that width must be abandoned, which seems ABI-breaking (see also LWG <a href="3828" title="Sync intmax_t and uintmax_t with C2x (Status: C++23)">3828</a>).
<p/>
I think we should allow some extended integer types to be wider than some integer-class types.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Proposed resolution is insufficient. A lot of the wording depends on the fact
that the range of widths of integer-class types and that of integer types are
disjoint. And it also disallows signed integer -> unsigned integer-class
conversion and by extension mixed ops, which is seriously breaking (e.g., it
disallows <code>x += 1</code>)."
</p>



<p id="res-3890"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>

<li><p>Modify 24.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a> as indicated:</p>

<blockquote>
<p>
-3- The range of representable values of an integer-class type is the continuous set of values over which it is
defined. For any integer-class type, its range of representable values is either <code>-2<sup><i>N</i>-1</sup></code> to 
<code>2<sup><i>N</i>-1</sup> - 1</code> (inclusive) for some integer <code><i>N</i></code>, in which case it is a 
<i>signed-integer-class type</i>, or <code>0</code> to <code>2<sup><i>N</i></sup> - 1</code> (inclusive) for some integer
<code><i>N</i></code>, in which case it is an <i>unsigned-integer-class type</i>. In both cases, <code><i>N</i></code> is called 
the <i>width</i> of the integer-class type. The width of an integer-class type is greater than that of every 
<ins>standard</ins> integral type of the same signedness.
<p/>
[&hellip;]
<p/>
-6- Expressions of integer-class type are explicitly convertible to any integer-like type, and implicitly convertible
to any <ins>integral type or</ins> integer-class type of equal or greater width and the same signedness. 
Expressions of integral type are <del>both implicitly and</del> explicitly convertible to any integer-class type<ins>, 
and implicitly convertible to any integer-class type that can represent all values of the source type</ins>. 
Conversions between integral and integer-class types and between two integer-class types do not exit via an exception. 
The result of such a conversion is the unique value of the destination type that is congruent to the source modulo 
<code>2<sup><i>N</i></sup></code>, where <code><i>N</i></code> is the width of the destination type.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3891"><a href="3891">3891</a>. LWG 3870 breaks <code>std::expected&lt;<i>cv</i> T, E&gt;</code></h3>
<p><b>Section:</b> 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-02-19 <b>Last modified:</b> 2024-10-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#expected.object.general">issues</a> in [expected.object.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the <code>value_type</code> of <code>std::expected</code> can be a <i>cv</i>-qualified type, which is  possibly intended.
However, LWG <a href="3870" title="Remove voidify (Status: C++23)">3870</a> disallows <code>std::construct_at</code> to construct objects via <code><i>cv</i> T*</code>, which
breaks <code>std::expected&lt;<i>cv</i> T, E&gt;</code> because some operations are specified with <code>std::construct_at</code>
(22.8.6.4 <a href="https://timsong-cpp.github.io/cppwp/expected.object.assign">[expected.object.assign]</a>, 22.8.6.5 <a href="https://timsong-cpp.github.io/cppwp/expected.object.swap">[expected.object.swap]</a>).
<p/>
I think when <code>T</code> is <i>cv</i>-qualified, it would be better to store <code>std::remove_cv_t&lt;T&gt;</code> subobject
while sometimes (other than construction/destruction) access it via a <i>cv</i>-qualified glvalue, which can also avoid UB
associated with <code>const</code>/<code>volatile</code> objects.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
"Not clear if all these wording changes are needed or desired."
"Unconvinced that the mixed-value-error swap should use <code>value()</code>,
source is destroyed immediately anyway. The else branch should use
<code>remove_cv_t</code> too."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: When assignment and <code>swap</code> need to backup the old value by move construction,
the source should be considered <i>cv</i>-unqualified, as the backup mechanism is only used internally.]
</p>
</blockquote>

<ol>

<li><p>Modify 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
bool <i>has_val</i>;      // <i>exposition only</i>
union {
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> <i>val</i>;       // <i>exposition only</i>
  E <i>unex</i>;          // <i>exposition only</i>
};
[&hellip;]
</pre>
</blockquote>

</li>

<li><p>Modify 22.8.6.4 <a href="https://timsong-cpp.github.io/cppwp/expected.object.assign">[expected.object.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr expected&amp; operator=(const expected&amp; rhs);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>this-&gt;has_value() &amp;&amp; rhs.has_value()</code> is <code>true</code>,
equivalent to <code><ins>value()</ins><del><i>val</i></del> = *rhs</code>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
[&hellip;]
<pre>
constexpr expected&amp; operator=(expected&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(6.1) &mdash; If <code>this-&gt;has_value() &amp;&amp; rhs.has_value()</code> is <code>true</code>,
equivalent to <code><ins>value()</ins><del><i>val</i></del> = std::move(*rhs)</code>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
[&hellip;]
<pre>
template&lt;class U = T&gt;
  constexpr expected&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(10.1) &mdash; If <code>has_value()</code> is <code>true</code>, equivalent to
 <code><ins>value()</ins><del><i>val</i></del> = std::forward&lt;U&gt;(v)</code>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>

</li>

<li><p>Modify Table 64: <code>swap(expected&amp;)</code> effects  [tab:expected.object.swap] as indicated:</p>

<blockquote>

<table border="1">
<caption>Table 64 &mdash; <code>swap(expected&amp;)</code> effects  [tab:expected.object.swap]</caption>
<tr style="text-align:center">
<th></th>
<th><code>this-&gt;has_value()</code></th>
<th><code>!this-&gt;has_value()</code></th>
</tr>
<tr>
<td><code>rhs.has_value()</code></td>
<td>equivalent to: <code>using std::swap;</code><br/>
<code>swap(<ins>value()</ins><del><i>val</i></del>, rhs.<ins>value()</ins><del><i>val</i></del>);</code></td>
<td>calls <code>rhs.swap(*this)</code></td>
</tr>

<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify 22.8.6.5 <a href="https://timsong-cpp.github.io/cppwp/expected.object.swap">[expected.object.swap]</a> as indicated:</p>

<blockquote>
<pre>
constexpr void swap(expected&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: [&hellip;]
<p/>
-2- <i>Effects</i>: See Table 64  [tab:expected.object.swap].
<p/>
For the case where <code>rhs.value()</code> is <code>false</code> and <code>this-&gt;has_value()</code> is <code>true</code>, equivalent to:
</p>
<blockquote>
<pre>
if constexpr (is_nothrow_move_constructible_v&lt;E&gt;) {
  E tmp(std::move(rhs.<i>unex</i>));
  destroy_at(addressof(rhs.<i>unex</i>));
  try {
    construct_at(addressof(rhs.<i>val</i>), std::move(<ins>value()</ins><del><i>val</i></del>));
    destroy_at(addressof(<i>val</i>));
    construct_at(addressof(<i>unex</i>), std::move(tmp));
  } catch(...) {
    construct_at(addressof(rhs.<i>unex</i>), std::move(tmp));
    throw;
  }
} else {
  T tmp(std::move(<i>val</i>));
  destroy_at(addressof(<i>val</i>));
  try {
    construct_at(addressof(<i>unex</i>), std::move(rhs.<i>unex</i>));
    destroy_at(addressof(rhs.<i>unex</i>));
    construct_at(addressof(rhs.<i>val</i>), std::move(tmp));
  } catch (...) {
    construct_at(addressof(<i>val</i>), std::move(tmp));
    throw;
  }
}
<i>has_val</i> = false;
rhs.<i>has_val</i> = true;
</pre>
</blockquote>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2024-10-02; Jonathan provides improved wording]</i></p>

<p>
Removed the use of <code class='backtick'>value()</code> in the [expected.object.swap] p2 <i>Effects</i>:
and added <code class='backtick'>remove_cv_t</code> to the local <code class='backtick'>T</code> in the <code class='backtick'>else</code>-branch.
</p>



<p id="res-3891"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: When assignment and <code>swap</code> need to backup the old value by move construction,
the source should be considered <i>cv</i>-unqualified, as the backup mechanism is only used internally.]
</p>
</blockquote>

<ol>

<li><p>Modify 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
bool <i>has_val</i>;      // <i>exposition only</i>
union {
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> <i>val</i>;       // <i>exposition only</i>
  E <i>unex</i>;          // <i>exposition only</i>
};
[&hellip;]
</pre>
</blockquote>

</li>

<li><p>Modify 22.8.6.4 <a href="https://timsong-cpp.github.io/cppwp/expected.object.assign">[expected.object.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr expected&amp; operator=(const expected&amp; rhs);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>this-&gt;has_value() &amp;&amp; rhs.has_value()</code> is <code>true</code>,
equivalent to <code><ins>value()</ins><del><i>val</i></del> = *rhs</code>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
[&hellip;]
<pre>
constexpr expected&amp; operator=(expected&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(6.1) &mdash; If <code>this-&gt;has_value() &amp;&amp; rhs.has_value()</code> is <code>true</code>,
equivalent to <code><ins>value()</ins><del><i>val</i></del> = std::move(*rhs)</code>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
[&hellip;]
<pre>
template&lt;class U = T&gt;
  constexpr expected&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(10.1) &mdash; If <code>has_value()</code> is <code>true</code>, equivalent to
 <code><ins>value()</ins><del><i>val</i></del> = std::forward&lt;U&gt;(v)</code>.</p></li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>

</li>

<li><p>Modify Table 64: <code>swap(expected&amp;)</code> effects  [tab:expected.object.swap] as indicated:</p>

<blockquote>

<table border="1">
<caption>Table 64 &mdash; <code>swap(expected&amp;)</code> effects  [tab:expected.object.swap]</caption>
<tr style="text-align:center">
<th></th>
<th><code>this-&gt;has_value()</code></th>
<th><code>!this-&gt;has_value()</code></th>
</tr>
<tr>
<td><code>rhs.has_value()</code></td>
<td>equivalent to: <code>using std::swap;</code><br/>
<code>swap(<ins>value()</ins><del><i>val</i></del>, rhs.<ins>value()</ins><del><i>val</i></del>);</code></td>
<td>calls <code>rhs.swap(*this)</code></td>
</tr>

<tr>
<td colspan="3" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify 22.8.6.5 <a href="https://timsong-cpp.github.io/cppwp/expected.object.swap">[expected.object.swap]</a> as indicated:</p>

<blockquote>
<pre>
constexpr void swap(expected&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: [&hellip;]
<p/>
-2- <i>Effects</i>: See Table 64  [tab:expected.object.swap].
<p/>
For the case where <code>rhs.value()</code> is <code>false</code> and <code>this-&gt;has_value()</code> is <code>true</code>, equivalent to:
</p>
<blockquote>
<pre>
if constexpr (is_nothrow_move_constructible_v&lt;E&gt;) {
  E tmp(std::move(rhs.<i>unex</i>));
  destroy_at(addressof(rhs.<i>unex</i>));
  try {
    construct_at(addressof(rhs.<i>val</i>), std::move(<i>val</i>));
    destroy_at(addressof(<i>val</i>));
    construct_at(addressof(<i>unex</i>), std::move(tmp));
  } catch(...) {
    construct_at(addressof(rhs.<i>unex</i>), std::move(tmp));
    throw;
  }
} else {
  <ins>remove_cv_t&lt;</ins>T<ins>&gt;</ins> tmp(std::move(<i>val</i>));
  destroy_at(addressof(<i>val</i>));
  try {
    construct_at(addressof(<i>unex</i>), std::move(rhs.<i>unex</i>));
    destroy_at(addressof(rhs.<i>unex</i>));
    construct_at(addressof(rhs.<i>val</i>), std::move(tmp));
  } catch (...) {
    construct_at(addressof(<i>val</i>), std::move(tmp));
    throw;
  }
}
<i>has_val</i> = false;
rhs.<i>has_val</i> = true;
</pre>
</blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3895"><a href="3895">3895</a>. Various relation concepts are missing default values of the second template parameters</h3>
<p><b>Section:</b> 18.3 <a href="https://timsong-cpp.github.io/cppwp/concepts.syn">[concepts.syn]</a>, 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> blacktea hamburger <b>Opened:</b> 2023-02-25 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::indirect_equivalence_relation</code> and <code>std::indirect_strict_weak_order</code> have default values 
for the second template parameters:
</p>
<blockquote><pre>
template&lt;class F, class I1, class I2 = I1&gt;
  concept indirect_equivalence_relation = <i>see below</i>;

template&lt;class F, class I1, class I2 = I1&gt;
  concept indirect_strict_weak_order = <i>see below</i>;
</pre></blockquote>
<p>
But <code>std::relation</code>, <code>std::equivalence_relation</code>, <code>std::strict_weak_order</code>, and
<code>std::indirect_binary_predicate</code> are missing such default values:
</p>
<blockquote><pre>
template&lt;class R, class T, class U&gt;
  concept relation = <i>see below</i>;

template&lt;class R, class T, class U&gt;
  concept equivalence_relation = <i>see below</i>;

template&lt;class R, class T, class U&gt;
  concept strict_weak_order = <i>see below</i>;
  
template&lt;class F, class I1, class I2&gt;
  concept indirect_binary_predicate = <i>see below</i>;
</pre></blockquote>
<p>
That makes them inconsistent and it should not be expected.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Borderline design change."
"Should not change <code>indirect_binary_predicate</code>."
"NAD, write a paper."
"NAD, default argument would make typos compile. Explicit is good."
</p>



<p id="res-3895"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>

<li><p>Modify 18.3 <a href="https://timsong-cpp.github.io/cppwp/concepts.syn">[concepts.syn]</a>, header <code>&lt;concepts&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
// <i>all freestanding</i>
namespace std {
  [&hellip;]
  
  // <i>18.7.5 <a href="https://timsong-cpp.github.io/cppwp/concept.relation">[concept.relation]</a>, concept relation</i>
  template&lt;class R, class T, class U <ins>= T</ins>&gt;
    concept relation = <i>see below</i>;
  
  // <i>18.7.6 <a href="https://timsong-cpp.github.io/cppwp/concept.equiv">[concept.equiv]</a>, concept equivalence_relation</i>
  template&lt;class R, class T, class U <ins>= T</ins>&gt;
    concept equivalence_relation = <i>see below</i>;
  
  // <i>18.7.7 <a href="https://timsong-cpp.github.io/cppwp/concept.strictweakorder">[concept.strictweakorder]</a>, concept strict_weak_order</i>
  template&lt;class R, class T, class U <ins>= T</ins>&gt;
    concept strict_weak_order = <i>see below</i>;
}
</pre>
</blockquote>

</li>

<li><p>Modify 18.7.5 <a href="https://timsong-cpp.github.io/cppwp/concept.relation">[concept.relation]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R, class T, class U <ins>= T</ins>&gt;
  concept relation =
    predicate&lt;R, T, T&gt; &amp;&amp; predicate&lt;R, U, U&gt; &amp;&amp;
    predicate&lt;R, T, U&gt; &amp;&amp; predicate&lt;R, U, T&gt;;
</pre>
</blockquote>

</li>

<li><p>Modify 18.7.6 <a href="https://timsong-cpp.github.io/cppwp/concept.equiv">[concept.equiv]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R, class T, class U <ins>= T</ins>&gt;
  concept equivalence_relation = relation&lt;R, T, U&gt;;
</pre>
</blockquote>

</li>

<li><p>Modify 18.7.7 <a href="https://timsong-cpp.github.io/cppwp/concept.strictweakorder">[concept.strictweakorder]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R, class T, class U <ins>= T</ins>&gt;
  concept strict_weak_order = relation&lt;R, T, U&gt;;
</pre>
</blockquote>

</li>

<li><p>Modify 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header <code>&lt;iterator&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std {
  [&hellip;]
  // <i>24.3.6.3 <a href="https://timsong-cpp.github.io/cppwp/indirectcallable.indirectinvocable">[indirectcallable.indirectinvocable]</a>, indirect callables</i>
  [&hellip;]
  template&lt;class F, class I1, class I2 <ins>= I1</ins>&gt;
    concept indirect_binary_predicate = <i>see below</i>; // <i>freestanding</i>

  template&lt;class F, class I1, class I2 = I1&gt;
    concept indirect_equivalence_relation = <i>see below</i>; // <i>freestanding</i>
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.3.6.3 <a href="https://timsong-cpp.github.io/cppwp/indirectcallable.indirectinvocable">[indirectcallable.indirectinvocable]</a> as indicated:</p>

<blockquote>
<p>
-1- The indirect callable concepts are used to constrain those algorithms that accept callable objects 
(22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>) as arguments.
</p>
<blockquote><pre>
[&hellip;]
template&lt;class F, class I1, class I2 <ins>= I1</ins>&gt;
  concept indirect_binary_predicate =
    indirectly_readable&lt;I1&gt; &amp;&amp; indirectly_readable&lt;I2&gt; &amp;&amp;
    copy_constructible&lt;F&gt; &amp;&amp;
    predicate&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
    predicate&lt;F&amp;, iter_value_t&lt;I1&gt;&amp;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
    predicate&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_value_t&lt;I2&gt;&amp;&gt; &amp;&amp;
    predicate&lt;F&amp;, iter_reference_t&lt;I1&gt;, iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
    predicate&lt;F&amp;, iter_common_reference_t&lt;I1&gt;, iter_common_reference_t&lt;I2&gt;&gt;;
[&hellip;]
</pre></blockquote>
</blockquote>

</li>


</ol>





<hr>
<h3 id="3896"><a href="3896">3896</a>. The definition of <code>viewable_range</code> is not quite right</h3>
<p><b>Section:</b> 25.4.6 <a href="https://timsong-cpp.github.io/cppwp/range.refinements">[range.refinements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-02-27 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.refinements">issues</a> in [range.refinements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements of <code>viewable_range</code> for <code>view</code> type is <code>view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; 
constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</code>, that is, when the decayed type of <code>T</code> models <code>view</code>, 
it must be constructible from <code>T</code>.
</p>
<p>
This part of the constraint corresponds to first bullet of <code>views::all</code> (25.7.6.1 <a href="https://timsong-cpp.github.io/cppwp/range.all.general">[range.all.general]</a>), 
which returns <code><i>decay-copy</i>(E)</code> if the decayed type of <code>E</code> models <code>view</code>.
</p>
<p>
However, <code><i>decay-copy</i>(E)</code> constraints <code>convertible_to&lt;T, decay_t&lt;T&gt;&gt;</code> which is a 
stronger requirement than <code>constructible_from</code>, which is reflected in its rejection of types with explicit 
copy constructors.
</p>
<p>
This inconsistency is such that the following causes the range adapter to produce a hard error when invoked 
(<a href="https://godbolt.org/z/PxWfs1Yco">online example</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct View : std::ranges::view_base 
{
  View();
  explicit View(const View&amp;); // explicit copy constructor
  View&amp; operator=(const View&amp;);
  View(View&amp;&amp;);
  
  int* begin();
  int* end();
};

int main() 
{
  View v;
  auto r = std::views::take(v, 5); // <span style="color:red;font-weight:bolder">hard error</span>
}
</pre></blockquote>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"About as contrived as it gets."
"Add generic front matter telling users the library doesn't support types
with explicit copy constructors."
</p>



<p id="res-3896"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>

<li><p>Modify 25.4.6 <a href="https://timsong-cpp.github.io/cppwp/range.refinements">[range.refinements]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  concept viewable_range =
    range&lt;T&gt; &amp;&amp;
    ((view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp; <ins>convertible_to&lt;T, remove_cvref_t&lt;T&gt;&gt;</ins><del>constructible_from&lt;remove_cvref_t&lt;T&gt;, T&gt;</del>) ||
     (!view&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      (is_lvalue_reference_v&lt;T&gt; || (movable&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp; !<i>is-initializer-list</i>&lt;T&gt;))));
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3898"><a href="3898">3898</a>. Possibly unintended preconditions for completion functions of <code>std::barrier</code></h3>
<p><b>Section:</b> 32.9.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.barrier.class">[thread.barrier.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-02 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.9.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.barrier.class">[thread.barrier.class]</a>/5 currently says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
[&hellip;] <code>is_nothrow_invocable_v&lt;CompletionFunction&amp;&gt;</code> shall be <code>true</code>.
</blockquote>
<p>
This requirement introduces a kind of undefined behavior and permits implementation divergence. Currently 
<a href="https://github.com/microsoft/STL/blob/16bb556afe5c56fe70a5508a6116842c226dd3be/stl/inc/barrier#L72-L77">MSVC STL</a>
enforces the requirement, while 
<a href="https://github.com/gcc-mirror/gcc/blob/4ea6bfedc8759cef739ae42eee162989112bd85a/libstdc%2B%2B-v3/include/std/barrier">libstdc++</a> 
and 
<a href="https://github.com/llvm/llvm-project/blob/9a77a6f80252288d536b3aa471f241786a54068b/libcxx/include/barrier">libc++</a> 
don't.
<p/>
If implementation divergence is not intended, I don't think it makes much sense to introduce UB in this way. 
I guess we should either strengthen the requirement to require well-formedness affection or relax it.
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> Effectively impose a <i>Mandates:</i> requirement.
</p>

<ol>

<li><p>Modify 32.9.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.barrier.class">[thread.barrier.class]</a> as indicated:</p>

<blockquote>
<p>
-5- <code>CompletionFunction</code> shall meet the <i>Cpp17MoveConstructible</i> (Table 32) and <i>Cpp17Destructible</i> (Table 36)
requirements. <ins>Instantiation of <code>barrier&lt;CompletionFunction&gt;</code> is ill-formed if 
<code>is_nothrow_invocable_v&lt;CompletionFunction&amp;&gt;</code> is not 
<code>true</code></ins><del><code>is_nothrow_invocable_v&lt;CompletionFunction&amp;&gt;</code> shall be <code>true</code></del>.
</p>
</blockquote>

</li>

</ol>

<p>
<b>Option B:</b> Clarify that we impose a no-throw precondition here, whose violation causes UB.
</p>

<ol>

<li><p>Modify 32.9.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.barrier.class">[thread.barrier.class]</a> as indicated:</p>

<blockquote>
<p>
-3- The <i>phase completion step</i> that is executed at the end of each phase has the following effects:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; Invokes the completion function, equivalent to <code>completion()</code>. <ins>If any invocation 
to the completion function throws an exception, the behavior is undefined.</ins></p></li>
<li><p>(3.2) &mdash; Unblocks all threads that are blocked on the phase synchronization point.</p></li>
</ol>
<p>
[&hellip;]
<p/>
-5- <code>CompletionFunction</code> shall meet the <i>Cpp17MoveConstructible</i> (Table 32) and <i>Cpp17Destructible</i> (Table 36)
requirements. <del><code>is_nothrow_invocable_v&lt;CompletionFunction&amp;&gt;</code> shall be <code>true</code>.</del>
</p>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2023-03-22; Jonathan provides improved wording]</i></p>




<p id="res-3898"><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.</p>

<ol>

<li><p>Modify 32.9.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.barrier.class">[thread.barrier.class]</a> as indicated:</p>

<blockquote>
<p>
-3- The <i>phase completion step</i> that is executed at the end of each phase has the following effects:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; Invokes the completion function, equivalent to
<code>completion()</code><ins>; if that invocation exits via an exception,
the function <code>std::terminate</code> is invoked</ins>.
</p></li>
<li><p>(3.2) &mdash; Unblocks all threads that are blocked on the phase synchronization point.</p></li>
</ol>
<p>
[&hellip;]
</p>
<p>
-5- <code>CompletionFunction</code> shall meet the <i>Cpp17MoveConstructible</i> (Table 32) and <i>Cpp17Destructible</i> (Table 36)
requirements.
<del>
<code>is_nothrow_invocable_v&lt;CompletionFunction&amp;&gt;</code>
shall be <code>true</code>.
</del>
<ins>
A program that instantiates <code>barrier&lt;CompletionFunction&gt;</code>
is ill-formed if <code>is_invocable_v&lt;CompletionFunction&amp;&gt;</code>
is <code>false</code>.
</ins>
</p>
</blockquote>

</li>

</ol>






<hr>
<h3 id="3902"><a href="3902">3902</a>. Return type of <code>std::declval&lt;<i>cv</i> void&gt;</code> should be (<i>cv</i>-unqualified) <code>void</code></h3>
<p><b>Section:</b> 22.2.6 <a href="https://timsong-cpp.github.io/cppwp/declval">[declval]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-07 <b>Last modified:</b> 2023-03-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#declval">active issues</a> in [declval].</p>
<p><b>View all other</b> <a href="lwg-index.html#declval">issues</a> in [declval].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently libc++ and libstdc++ determine the return type of <code>std::declval</code> like this:
</p>
<blockquote><pre>
template&lt;class _Tp&gt;
_Tp&amp;&amp; __declval_ret(int); // selected when _Tp is a referenceable type

template&lt;class _Tp&gt;
_Tp __declval_ret(long); // selected when _Tp is cv void

template&lt;class _Tp&gt;
decltype(__declval_ret&lt;_Tp&gt;(0)) declval() noexcept;
</pre></blockquote>
 <p>
This strategy avoids instantiation of class templates. But it also drops <i>cv</i>-qualifiers of the return type 
when the type is <i>cv</i> <code>void</code>, which is different from the standard requirements. Such difference has 
no impact in normal use of <code>std::declval</code>, but is observable via <code>decltype(std::declval&lt;const void&gt;)</code> 
and its friends.
<p/>
Given maintainers may think it's reasonable to keep the current implementation 
(see <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=109049">GCC Bugzilla #109049</a>), 
it may be worthwhile to legitimate such strategy.
<p/>
Should we make such construction ill-formed?
</p>

<p><i>[2023-03-22; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"The testcase isn't even valid with the previous 'conforming' libstdc++ implementation."
"<code>declval</code> isn't an addressable function, so would prefer if this
was ill-formed rather than complicating the definition for this case."
</p>



<p id="res-3902"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4928" title=" Working Draft, Standard for Programming Language C++">N4928</a>.
</p>

<ol>

<li><p>Modify 22.2.1 <a href="https://timsong-cpp.github.io/cppwp/utility.syn">[utility.syn]</a>, header <code>&lt;utility&gt;</code> synopsis, and 22.2.6 <a href="https://timsong-cpp.github.io/cppwp/declval">[declval]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  <ins>remove_cv_t&lt;</ins>add_rvalue_reference_t&lt;T&gt;<ins>&gt;</ins> declval() noexcept; // <i>as unevaluated operand</i>
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3906"><a href="3906">3906</a>. "Undefined address" is undefined</h3>
<p><b>Section:</b> 32.5.8.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.pointer">[atomics.types.pointer]</a>, 32.5.7.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.pointer">[atomics.ref.pointer]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-18 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.pointer">active issues</a> in [atomics.types.pointer].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.pointer">issues</a> in [atomics.types.pointer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This was originally <a href="https://github.com/cplusplus/draft/issues/6185">editorial issue #6185</a>.
<p/>
The term "undefined address" is used in 32.5.8.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.pointer">[atomics.types.pointer]</a>/8 and 
32.5.7.5 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.pointer">[atomics.ref.pointer]</a>/6, however, it seems not properly defined and the intended meaning is unclear.
The term originally appeared in the paper <a href="https://wg21.link/N2393" title=" C++ Atomic Types and Operations">N2393</a> and was reused by <a href="https://wg21.link/P0019R8" title=" Atomic Ref">P0019R8</a>, but 
no explanation can be found in these papers.
<p/>
Perhaps "undefined address" is related to the undefined behavior specified in 7.6.6 <a href="https://timsong-cpp.github.io/cppwp/expr.add">[expr.add]</a>.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3906"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3907"><a href="3907">3907</a>. Can iterator types of range adaptors and range factories be SCARY?</h3>
<p><b>Section:</b> 25.6 <a href="https://timsong-cpp.github.io/cppwp/range.factories">[range.factories]</a>, 25.7 <a href="https://timsong-cpp.github.io/cppwp/range.adaptors">[range.adaptors]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-18 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[For the term SCARY see <a href="https://wg21.link/N2911" title=" Minimizing Dependencies within Generic Classes for Faster and Smaller Programs">N2911</a> and <a href="https://wg21.link/N2913" title=" SCARY Iterator Assignment and Initialization">N2913</a>.]
<p/>
In 25.6 <a href="https://timsong-cpp.github.io/cppwp/range.factories">[range.factories]</a> and 25.7 <a href="https://timsong-cpp.github.io/cppwp/range.adaptors">[range.adaptors]</a>, many iterator types are specified 
as exposition-only nested classes or nested class templates.
<p/>
This has some observable differences from specifying them as class templates declared in the namespace scope:
</p>
<ol>
<li><p>value types are generally not associated entities of iterators or sentinels during ADL, which prevents 
unintended overloads to be found;</p></li>
<li><p>two different range adaptor/factory types, e.g. <code>iota_view&lt;I, S1&gt;</code> and <code>iota_view&lt;I, S2&gt;</code>, 
have different iterator types.</p></li>
</ol>
<p>
The ADL reduction seems preferable. However, is it intended to required to any two different range 
adaptor/factory types to have two different iterator types, even when the same iterator type can work as expected?
<p/>
Sentinel types don't seem able to be SCARY as they are dependent on iterator types.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"The ADL hiding stuff is a red herring - SCARY-ness doesn't prevent ADL hiding.
Shouldn't require them to be different types (and similarly should not require
const/non-const iterators to be implemented as class templates with a single
bool template parameter)."
</p>



<p id="res-3907"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3910"><a href="3910">3910</a>. The effects of including <code>&lt;iostream&gt;</code> on initialization are not yet precisely specified</h3>
<p><b>Section:</b> 31.4.2 <a href="https://timsong-cpp.github.io/cppwp/iostream.objects.overview">[iostream.objects.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#iostream.objects.overview">issues</a> in [iostream.objects.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3878" title="import std; should guarantee initialization of standard iostreams objects (Status: C++23)">3878</a> specified the effects of importing standard library modules on initialization.
However, the effects of including <code>&lt;iostream&gt;</code> are not yet precisely specified.
A hostile reading may consider this to allow the <code>ios_base::Init</code> variable to be
a function-local static variable or an inline variable, which defeats the purpose.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3910"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Change 31.4.2 <a href="https://timsong-cpp.github.io/cppwp/iostream.objects.overview">[iostream.objects.overview]</a>/5 as indicated:
</p>
<blockquote>
<p>
-5-
The results of including <code>&lt;iostream&gt;</code> in a translation unit
shall be as if <code>&lt;iostream&gt;</code>
defined an <del>instance of</del> <code>ios_base::Init</code> with
<del>static storage duration</del>
<ins>ordered initialization (6.10.3.3 <a href="https://timsong-cpp.github.io/cppwp/basic.start.dynamic">[basic.start.dynamic]</a>)</ins>.
Each C++ library module (16.4.2.4 <a href="https://timsong-cpp.github.io/cppwp/std.modules">[std.modules]</a>) in a hosted implementation
shall behave as if it contains an interface unit that defines an unexported
<code>ios_base::Init</code> variable with
ordered initialization <del>(6.10.3.3 <a href="https://timsong-cpp.github.io/cppwp/basic.start.dynamic">[basic.start.dynamic]</a>)</del>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3911"><a href="3911">3911</a>. <code>unique_ptr</code>'s <code>operator*</code> is missing a mandate</h3>
<p><b>Section:</b> 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a>, 20.3.1.4.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.runtime.observers">[unique.ptr.runtime.observers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Bi <b>Opened:</b> 2023-03-27 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unique.ptr.single.observers">active issues</a> in [unique.ptr.single.observers].</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.observers">issues</a> in [unique.ptr.single.observers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The return type of <code>std::unique_ptr&lt;T&gt;::operator*</code> is
<code>std::add_lvalue_reference_t&lt;T&gt;</code>,
but there is no mandate stating that <code>*get()</code> is convertible to that type.
There also does not appear to be a mandate that <code>*get()</code> is a valid expression;
dereferenceability is not part of the <i>Cpp17NullablePointer</i> requirements.
A similar issue appears to exist for <code>std::unique_ptr&lt;T[]&gt;::operator[]</code>.
</p>

<p><i>[2023-03-28; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"It would be nice to <i>Mandate</i> <code>!reference_converts_from_temporary_v&lt;add_lvalue_reference_t&lt;T&gt;, decltype(*get())&gt;</code>."
"noexcept-specifier isn't quite right, conversion from <code>*get()</code> to <code>T&amp;</code> can throw."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Add the following bullet before 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> paragraph 1:
</p>
<blockquote>
<pre><code>
constexpr add_lvalue_reference_t&lt;T&gt; operator*() const noexcept(noexcept(*declval&lt;pointer&gt;()));
</code></pre>
<blockquote>
<p><ins>-?-
<i>Mandates</i>:
<code>*get()</code> is a valid expression
that is convertible to <code>add_lvalue_reference_t&lt;T&gt;</code>.
</ins>
</p>
<p>
-1- <i>Preconditions</i>:
<code>get() != nullptr</code>.
</p>
<p>-2- <i>Returns</i>: <code>*get()</code>.</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Add the following bullet before 20.3.1.4.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.runtime.observers">[unique.ptr.runtime.observers]</a> paragraph 1:
</p>
<blockquote>
<pre><code>
constexpr T&amp; operator[](size_t i) const;
</code></pre>
<blockquote>
<p><ins>-?-
<i>Mandates</i>:
<code>get()[i]</code> is a valid expression
that is convertible to <code>T&amp;</code>.
</ins>
</p>
<p>
-1- <i>Preconditions</i>:
<code>i</code> &lt; the number of elements in the array to which the stored pointer points.
</p>
<p>-2- <i>Returns</i>: <code>get()[i]</code>.</p>
</blockquote>
</blockquote>
</li>

</ol>

</blockquote>

<p><i>[2023-04-03; Jonathan provides new wording as requested by LWG]</i></p>




<p id="res-3911"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>
Add the following bullet before 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> paragraph 1:
</p>
<blockquote>
<pre><code>
constexpr add_lvalue_reference_t&lt;T&gt; operator*() const noexcept(noexcept(*declval&lt;pointer&gt;()));
</code></pre>
<blockquote>
<p>
-1- <i>Preconditions</i>:
<code>get() != nullptr</code>.
</p>
<p>-2- <i><del>Returns</del> <ins>Effects</ins></i>:
<ins>Equivalent to: <code>return</code></ins>
<code>*get()<ins>;</ins></code><del>.</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Add the following bullet before 20.3.1.4.4 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.runtime.observers">[unique.ptr.runtime.observers]</a> paragraph 1:
</p>
<blockquote>
<pre><code>
constexpr T&amp; operator[](size_t i) const;
</code></pre>
<blockquote>
<p>
-1- <i>Preconditions</i>:
<ins><code>get() != nullptr</code></ins>
<del>
<code>i</code> &lt; the number of elements in the array to which the stored pointer points</del>.
</p>
<p>-2- <i><del>Returns</del> <ins>Effects</ins></i>:
<ins>Equivalent to: <code>return</code></ins>
<code>get()[i]<ins>;</ins></code><del>.</del>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3916"><a href="3916">3916</a>. <code>allocator</code>, <code>polymorphic_allocator</code>, and containers should forbid <i>cv</i>-qualified types</h3>
<p><b>Section:</b> 20.2.10 <a href="https://timsong-cpp.github.io/cppwp/default.allocator">[default.allocator]</a>, 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class.general">[mem.poly.allocator.class.general]</a>, 23.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements">[container.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2023-04-02 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#default.allocator">active issues</a> in [default.allocator].</p>
<p><b>View all other</b> <a href="lwg-index.html#default.allocator">issues</a> in [default.allocator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2447" title="Allocators and volatile-qualified value types (Status: C++17)">2447</a> adjusted what is now <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a> 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a>/2.1 
so that the <i>Cpp17Allocator</i> requirements are specified for <i>cv</i>-unqualified object types only.
<p/>
However, nothing in 20.2.10 <a href="https://timsong-cpp.github.io/cppwp/default.allocator">[default.allocator]</a> restricts what <code>T</code> in <code>allocator&lt;T&gt;</code> can be, 
except where 20.2.10.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.members">[allocator.members]</a>/2 and /6 require it to be complete for <code>allocate()</code> and 
<code>allocate_at_least()</code> (and by implication, for <code>deallocate()</code>). (Long ago, <code>allocator</code> had member functions 
whose signatures implied that <code>const</code>-qualified types were forbidden, but those signatures were deprecated and 
removed. This explains the phrasing of an MSVC static assertion.)
<p/>
20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class.general">[mem.poly.allocator.class.general]</a> says a bit more about <code>Tp</code> in <code>polymorphic_allocator&lt;Tp&gt;</code> 
but doesn't forbid anything. It says that if <code>Tp</code> is a <i>cv</i>-unqualified object type, then 
<code>polymorphic_allocator&lt;Tp&gt;</code> meets the <i>Cpp17Allocator</i> requirements and allocator completeness requirements, 
but that's all.
<p/>
There's some implementation variation here. libstdc++ and MSVC reject <code>allocator&lt;const int&gt;</code>. libc++ 
(as of LLVM 16) accepts it but this appears to have been an extension that they're trying to get rid of (their maintainers 
may be able to comment further; see 
<a href="https://github.com/llvm/llvm-project/commit/a54d028895c91da356a4aaf30e27a5a5b90dd313">llvm-project/commit/a54d028895c91da356a4aaf30e27a5a5b90dd313</a>).
These 3 implementations all reject <code>allocator&lt;volatile int&gt;</code>, <code>polymorphic_allocator&lt;const int&gt;</code>, 
and <code>polymorphic_allocator&lt;volatile int&gt;</code> with varying messages.
<p/>
The Standard should provide clarity here, by mandating that only <i>cv</i>-unqualified object types be given to <code>allocator</code>, 
<code>polymorphic_allocator</code>, and containers. (<code>allocator&lt;void&gt;</code> must also be allowed, of course. I forget 
if <code>polymorphic_allocator</code> is supposed to accept <code>void</code>.) This would simply Standardize existing/desired practice. 
While it may seem arcane, attempting to form <code>vector&lt;const T&gt;</code> is a common novice mistake &mdash; so common that 
MSVC had to add a <code>static_assert</code> to emit a clear error message.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3916"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3917"><a href="3917">3917</a>. Validity of <code>allocator&lt;void&gt;</code> and possibly <code>polymorphic_allocator&lt;void&gt;</code> should be clarified</h3>
<p><b>Section:</b> 20.2.10 <a href="https://timsong-cpp.github.io/cppwp/default.allocator">[default.allocator]</a>, 20.5.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class">[mem.poly.allocator.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2023-04-08 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#default.allocator">active issues</a> in [default.allocator].</p>
<p><b>View all other</b> <a href="lwg-index.html#default.allocator">issues</a> in [default.allocator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Before <a href="https://wg21.link/P0174" title=" Deprecating Vestigial Library Parts in C++17">P0174</a> had been approved for the working paper, the validity of using <code>void</code> as template argument for
<code>std::allocator</code> was obvious due to the existing specification of the explicit specialization <code>allocator&lt;void&gt;</code>.
<p/>
This specialization was first moved to Annex D ([depr.default.allocator]) and later completely eradicated from the working paper via
adoption of <a href="https://wg21.link/P0619" title=" Reviewing Deprecated Facilities of C++17 for C++20">P0619</a>.
<p/>
The problem is that, since then, we have no explicit wording for <code>std::allocator</code> to support <code>void</code> as template argument 
any more. We fall now under the constraints for template "components" specified in 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> bullet 2.5.
</p>
<blockquote><p>
-2- In particular, the behavior is undefined in the following cases:
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(2.5) &mdash; If an incomplete type (6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.types.general">[basic.types.general]</a>) is used as a template argument when instantiating a 
template component or evaluating a concept, unless specifically allowed for that component.</p></li>
</ol>
</blockquote>
<p>
But no such allowance wording exists for <code>allocator&lt;void&gt;</code> nor for <code>polymorphic_allocator&lt;void&gt;</code>, more
to the contrary, 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> only refers to <i>cv</i>-unqualified object types as value types
and <code>void</code> is not an object type.
<p/>
Now we could argue that the wording is clear that instantiations of these are invalid, but there exists at least some indication
that the instantiations are intended to be allowed.
<p/>
As of 25.8.5 <a href="https://timsong-cpp.github.io/cppwp/coro.generator.promise">[coro.generator.promise]</a> bullet (17.3) the static <code>operator new</code> members of <code>std::generator</code>
mention a fall-back of using <code>allocator&lt;void&gt;</code>.
<p/>
20.2.10.1 <a href="https://timsong-cpp.github.io/cppwp/default.allocator.general">[default.allocator.general]</a> says that all specializations of the default allocator meet the allocator completeness 
requirements (16.4.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.completeness">[allocator.requirements.completeness]</a>), but albeit this specification does not specifically exclude 
the existence of an incomplete value type, the wording here does also not provide a definite statement, that it is valid (The 
wording originally was provided when we started adding support for (yet) incomplete value types that at some point later will become
complete, but <code>void</code> can never be completed), since it is mostly focused on the completeness requirement for the allocator
type itself.
<p/>
The situation is similar (albeit maybe not that strong) for <code>polymorphic_allocator&lt;void&gt;</code>, since
20.5.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class">[mem.poly.allocator.class]</a> p1 has some unusual wording form that says
</p>
<blockquote><p>
-1- A specialization of class template <code>pmr::polymorphic_allocator</code> meets the <i>Cpp17Allocator</i> requirements
(16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a>) if its template argument is a <i>cv</i>-unqualified object type.
</p></blockquote>
<p>
and says then in p2:
</p>
<blockquote><p>
-2- A specialization of class template <code>pmr::polymorphic_allocator</code> meets the allocator completeness requirements
(16.4.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.completeness">[allocator.requirements.completeness]</a>) if its template argument is a <i>cv</i>-unqualified object type.
</p></blockquote>
<p>
Again, this wording is not conclusive, whether <code>void</code> is intended to be supported, it is certainly not completely ruled
out, but that is not strong enough to counterpart 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> (2.5). It is maybe worth pointing out that
for a while we were considering to use <code>void</code> as default template argument for <code>pmr::polymorphic_allocator</code>,
see e.g. <a href="https://wg21.link/P0339R0" title=" polymorphic_allocator<void> as a vocabulary type">P0339R0</a>, but that thought was later replaced by deciding for <code>std::byte</code> instead, which
is a complete object type.
<p/>
I assume that at least the intention exists that <code>std::allocator</code> is intended to support incomplete types, maybe also
for <code>polymorphic_allocator</code>. If <code>polymorphic_allocator</code> is intended to support incomplete types as well,
we should also amend 20.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> p1 and p8 with a <i>Mandates:</i> element similarly as we did 
for <code>std::allocator</code> via LWG <a href="3307" title="std::allocator&lt;void&gt;().allocate(n) (Status: C++20)">3307</a>.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3917"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>Add the following new paragraph at the end of 20.2.10.1 <a href="https://timsong-cpp.github.io/cppwp/default.allocator.general">[default.allocator.general]</a> as indicated:</p>

<blockquote>
<p>
-2- <code>allocator_traits&lt;allocator&lt;T&gt;&gt;::is_always_equal::value</code> is <code>true</code> for any <code>T</code>.
<p/>
<ins>-?- The template parameter <code>T</code> of <code>allocator</code> may be an incomplete type.</ins>
</p>
</blockquote>
</li>

<li>
<p>Add the following new paragraph at the end of 20.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.class.general">[mem.poly.allocator.class.general]</a> (possibly just after
the class template synopsis) as indicated:</p>

<blockquote>
<p>
<ins>-?- The template parameter <code>Tp</code> of <code>polymorphic_allocator</code> may be an incomplete type.</ins>
</p>
</blockquote>
</li>

<li>
<p>Modify 20.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The reference to <code>sizeof(Tp)</code> gives indirect evidence that we want to exclude incomplete types
here, but we cannot rely on the "equivalent to" magic formula, because that is defined conditionally]
</p>
</blockquote>

<blockquote>
<pre>
[[nodiscard]] Tp* allocate(size_t n);
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates:</i> <code>Tp</code> is not an incomplete type (6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.types.general">[basic.types.general]</a>).</ins>
<p/>
-1- <i>Effects:</i> If <code>numeric_limits&lt;size_t&gt;::max() / sizeof(Tp) &lt; n</code>, throws <code>bad_array_new_length</code>.
Otherwise equivalent to:
</p>
<blockquote><pre>
return static_cast&lt;Tp*&gt;(memory_rsrc-&gt;allocate(n * sizeof(Tp), alignof(Tp)));
</pre></blockquote>
</blockquote>

<blockquote class="note">
<p>
[<i>Drafting note:</i> We don't need extra wording for the member templates <code>allocate_object</code>, <code>deallocate_object</code>,
<code>new_object</code>, <code>delete_object</code>, or <code>construct</code>, because their semantics does not depend on template parameter
<code>Tp</code> and the general wording of 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> (2.5) again requires the completeness of <code>T</code> here.
<p/>
For <code>deallocate</code> we also omit the completeness requirement (as we did so for <code>allocator::deallocate</code>), because 
this is indirectly implied by the existing precondition. ]
</p>
</blockquote>

</blockquote>
</li>
</ol>





<hr>
<h3 id="3920"><a href="3920">3920</a>. Bad footnotes claiming external linkage for entities defined as macros</h3>
<p><b>Section:</b> 16.4.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/extern.names">[extern.names]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-04-12 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.4.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/extern.names">[extern.names]</a> p1 and p2 reserve certain names with external linkage to the implementation.
<p/>
Each paragraph has a footnote, stating that such names include <code>errno</code>, <code>setjmp(jmpbuf)</code>, and 
<code>va_end(va_list)</code>. These names are all defines as macros, not entities with that name and external linkage.
<p/>
Are these footnotes intended by a normative extension to the list of reserved names with external linkage?  
If so, they should be promoted to the main text, as they are no longer a note.
<p/>
If they intend to serve as examples, it is not clear to me what principle is being shown, as there are many 
other macros that might be in a similar position, and I do not see how to follow the a principle that is being 
noted, and presumably follows from the normative text.
<p/>
I <em>think</em> this is intended to be a normative extension to the set of reserved names with external linkage, 
is limited to exactly those three named macros, so should be promoted as a non-note into the main text, but want 
to hear what LWG consensus is before drafting wording.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3920"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3921"><a href="3921">3921</a>. Is <code>std::chrono::duration&lt;std::int64_t, std::ratio&lt;INT64_MAX - 1, INT64_MAX&gt;&gt;{40}</code> 
required to be correctly formatted?</h3>
<p><b>Section:</b> 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-04-14 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.format">active issues</a> in [time.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.format">issues</a> in [time.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently none of MSVC STL, libc++, and libstdc++ correctly formats 
<code>duration&lt;int64_t, ratio&lt;INT64_MAX -1, INT64_MAX&gt;&gt;{40}</code> 
(<a href="https://godbolt.org/z/GfaEsqMnz">Godbolt link</a>). For MSVC and libstdc++, 
<code>hh_mm_ss</code> is used when formatting <code>duration</code> and thus <code>duration_cast</code> 
is also involved. And it's extremely easy for <code>duration_cast</code> to cause UB when the 
source type is <code>duration&lt;int64_t, ratio&lt;INT64_MAX -1, INT64_MAX&gt;&gt;</code>.
<p/>
However, 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> doesn't say <code>hh_mm_ss</code> is equivalently used when 
formatting duration. And it seems that the current wording require <code>duration</code> (whose 
<code>rep</code> type is an arithmetic type) to be correctly formatted without UB, even if it is 
of a weird type or extremely large (e.g. when it is 
<code>duration&lt;int64_t, ratio&lt;INT64_MAX, 1&gt;&gt;{INT64_MAX}</code>).
<p/>
So, if it is intended that <code>hh_mm_ss</code> is used for formatting <code>duration</code>, 
perhaps we should explicitly so specify in 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>. And we may need to 
fix initialization of <code>hh_mm_ss</code> to reduce UB whenever suitable.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"NAD. A compile-time error is required when ratio arithmetic overflows,
21.5.4 <a href="https://timsong-cpp.github.io/cppwp/ratio.arithmetic">[ratio.arithmetic]</a> p2"
</p>



<p id="res-3921"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3922"><a href="3922">3922</a>. It's unclear whether <code>numeric_limits</code> can be specialized by users</h3>
<p><b>Section:</b> 17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Christopher Di Bella <b>Opened:</b> 2023-04-14 <b>Last modified:</b> 2024-07-31</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.limits.general">active issues</a> in [numeric.limits.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits.general">issues</a> in [numeric.limits.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>/p2 notes that "unless explicitly prohibited", a user may conditionally specialize 
any class template for program-defined types. 17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a>/p1 doesn't explicitly prohibit 
this, but it does create a bit of a grey area with its wording because it describes <code>numeric_limits</code> as a 
class template describing "the implementation's representation" of "the arithmetic types".
<p/>
Since this type is about what the implementation provides, and about arithmetic types only, it's not clear whether 
a user can specialize it for their own library type such as <code>ns::int256</code>. <code>ns::int256</code> isn't an 
arithmetic type (despite resembling one), so one can interpret 16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>/p2's (b) condition to 
mean that <code>numeric_limits&lt;ns::int256&gt;</code> needs to be explicitly specialized as if it were the primary 
template.
<p/>
<b>Daniel:</b>
<p/>
This issue has overlap with LWG <a href="3923" title="The specification of numeric_limits doesn't clearly distinguish between implementation requirements
and user requirements (Status: New)">3923</a>.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
Several votes for Tentatively Ready with <b>Option A</b>,
but a request to consider LWG <a href="3923" title="The specification of numeric_limits doesn't clearly distinguish between implementation requirements
and user requirements (Status: New)">3923</a> first/instead of this one.
</p>



<p id="res-3922"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> (This assumes that the above described scenario is intended to be supported)
</p>

<ol>
<li>
<p>Add the following new paragraph at the end of 17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> The particular wording form "emulating an arithmetic type" has been borrowed from
Table 99 &mdash; <i>Cpp17Clock</i> requirements [tab:time.clock] and 30.5.1 <a href="https://timsong-cpp.github.io/cppwp/time.duration.general">[time.duration.general]</a> p2,
respectively.] 
</p>
</blockquote>

<blockquote>
<p>
<ins>-?- The <code>numeric_limits</code> template may be specialized for program-defined types emulating arithmetic types.</ins>
</p>
</blockquote>
</li>
</ol>

<p>
<b>Option B:</b> (This assumes that the above described scenario is <em>not</em> intended to be supported)
</p>

<ol>
<li>
<p>Add the following new paragraph at the end of 17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> The particular wording form has been borrowed from
17.13.4.1 <a href="https://timsong-cpp.github.io/cppwp/coroutine.handle.general">[coroutine.handle.general]</a> p2 and 20.2.9.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.traits.general">[allocator.traits.general]</a> p1, 
respectively.] 
</p>
</blockquote>

<blockquote>
<p>
<ins>-?- If a program declares an explicit or partial specialization of <code>numeric_limits</code>, the program 
is ill-formed, no diagnostic required.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3923"><a href="3923">3923</a>. The specification of <code>numeric_limits</code> doesn't clearly distinguish between implementation requirements
and user requirements</h3>
<p><b>Section:</b> 17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2023-04-15 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#numeric.limits.general">active issues</a> in [numeric.limits.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.limits.general">issues</a> in [numeric.limits.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording of 17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a> seemingly has not been gone through a similar thorough 
rewording review which we performed in the past to clean-up the working draft as we did via the series of 
"Mandating" papers by Marshall Clow (<a href="https://wg21.link/P1458" title=" Mandating the Standard Library: Clause 16 - Language support library">P1458</a> - <a href="https://wg21.link/P1465" title=" Function optimization hint attributes: [[always_inline]], [[never_inline]]">P1465</a> and even more).
<p/>
17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a> contains several nowadays inappropriate wording forms, which don't 
distinguish well enough between requirements imposed on implementations (Where we shouldn't use "shall" wording 
in the ambiguous form of "Specializations shall be provided for each arithmetic type") and requirements imposed on
user types, this has also caused confusion as expressed in LWG <a href="3922" title="It's unclear whether numeric_limits can be specialized by users (Status: New)">3922</a>. It is "obvious"
that a program is intended to be allowed to provide program-defined specializations, but as 
LWG <a href="3922" title="It's unclear whether numeric_limits can be specialized by users (Status: New)">3922</a> points out, it is unclear how such a specialization is able to meet the requirement 
"(b) the specialization meets the standard library requirements for the original template" specified in 
16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> p2.
<p/>
Another problem is the usage of the unclear wording "Non-arithmetic standard types", which should be replaced by
a more precise wording form.
<p/>
An additional problem is that we actually already <em>do</em> require an implementation to provide specializations
for the (library-provided) integer-class types (24.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>), so contrary to what p6
says, we already have at least one exception, where the library is required to specialize <code>numeric_limits</code>
for a non-arithmetic type. We should make that a bit clearer here as well.
<p/>
This issue is related to LWG <a href="3922" title="It's unclear whether numeric_limits can be specialized by users (Status: New)">3922</a> and paper <a href="https://wg21.link/P1841" title=" Wording for Individually Specializable Numeric Traits">P1841</a>.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3923"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> This wording would also solve LWG issue <a href="3922" title="It's unclear whether numeric_limits can be specialized by users (Status: New)">3922</a> under the assumption that
option <b>A</b> is intended] 
</p>
</blockquote>

<ol>
<li>
<p>Modify 17.3.3 <a href="https://timsong-cpp.github.io/cppwp/limits.syn">[limits.syn]</a>, header <code>&lt;limits&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
// <i>17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a>, class template numeric_limits</i>
template&lt;class T&gt; class numeric_limits;

<ins>// <i>17.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/numeric.special">[numeric.special]</a>, numeric_limits specializations</i></ins>
template&lt;class T&gt; class numeric_limits&lt;const T&gt;;
template&lt;class T&gt; class numeric_limits&lt;volatile T&gt;;
template&lt;class T&gt; class numeric_limits&lt;const volatile T&gt;;

template&lt;&gt; class numeric_limits&lt;bool&gt;;
[&hellip;]
</pre>
</blockquote>
</li>

<li>
<p>Modify 17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a> as indicated:</p>

<blockquote>
<p>
-1- The <code>numeric_limits</code> class template provides a C++ program with information about various properties of
the implementation's representation of the arithmetic types.
<p/>
[&hellip;]
</p>
<blockquote class="note">
<p>
[<i>Drafting Note:</i> It is unclear whether the requirement in the following paragraph 2 is intended to apply to
program-defined specializations as well. Consider as an example a user-defined arithmetic-like type that provides 
arbitrary precision arithmetic which may require dynamic memory for certain object constructions. Is it invalid to specialize 
<code>numeric_limits</code> for such a type or may the program-defined specialization deviate from this requirement for 
at least some of its members?
<p/>
If we want to make this restriction relaxed for program-defined specializations, further wording would
be needed to give that permission] 
</p>
</blockquote>
<p>
-2- For all members declared <code>static constexpr</code> in the <code>numeric_limits</code> template, specializations shall 
define these values in such a way that they are usable as constant expressions.
<p/>
-3- For the <code>numeric_limits</code> primary template, all data members are value-initialized and all member functions
return a value-initialized object.
<p/>
[<i>Note 1</i>: This means all members have zero or <code>false</code> values unless <code>numeric_limits</code> is specialized for a 
type. &mdash; <i>end note</i>]
<p/>
-4- <ins>An implementation shall provide s</ins><del>S</del>pecializations <del>shall be provided</del> 
for each arithmetic type, both floating-point and integer, including <code>bool</code>.
The member <code>is_specialized</code> <del>shall be</del><ins>is</ins> <code>true</code> for all such specializations of 
<code>numeric_limits</code>.
<p/>
<del>-5- The value of each member of a specialization of <code>numeric_limits</code> on a cv-qualified type <code>cv T</code> shall 
be equal to the value of the corresponding member of the specialization on the unqualified type <code>T</code>.</del>
</p>
<blockquote class="note">
<p>
[<i>Drafting Note:</i> If we had introduced <code>numeric_limits</code> today we would likely have only allowed to
provide specializations for <i>cv</i>-unqualified program-defined types, but that ship has sailed long ago.
<p/>
Interestingly currently there doesn't exist a specification that defines under which situations the static member
<code>is_specialized</code> should be defined <code>true</code> or <code>false</code> (This touches LWG <a href="205" title=" numeric_limits unclear on how to determine floating point types (Status: NAD)">205</a>). 
The wording below does not attempt to improve that situation, but at least clarifies that its value may be different
from that of the primary template.
<p/>
Note that this proposed wording does &mdash; opposed to the approach of LWG <a href="3922" title="It's unclear whether numeric_limits can be specialized by users (Status: New)">3922</a> &mdash; not restrict 
that specializations can only be provided by program-defined types "emulating an arithmetic type", because that would 
break existing specializations and is also problematic in the light of the non-existing definition of that term.
<p/>
The below wording strategy gives permission to specialize <code>numeric_limits</code> only for non-array object types.
An alternative approach could make it a precondition instead to instantiate the template for non-array object types, 
for example.] 
</p>
</blockquote>
<p>
<ins>-?- A program may specialize the <code>numeric_limits</code> template for a program-defined non-array object type. 
Such a specialization is permitted to define a value for any static member that differs from what the primary 
template would have defined, as appropriate for that type.</ins> 
<p/>
<ins>[<i>Note</i>: It still has to meet the general requirements specified in subclause 
17.3.5.1 <a href="https://timsong-cpp.github.io/cppwp/numeric.limits.general">[numeric.limits.general]</a> and subclause 17.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/numeric.special">[numeric.special]</a> &mdash; <i>end note</i>].</ins>
</p>
<blockquote class="note">
<p>
[<i>Drafting Note:</i> The following restriction is carefully drafted to ensure that a library has the freedom to provide such
specializations for "extended" types (That are not necessarily integer-class types). The restriction is intended to apply only 
to "official" (strict) C++ standard library types] 
</p>
</blockquote>
<p>
-6- <ins>An implementation shall not provide specializations for n</ins><del>N</del>on-arithmetic <del>standard</del> types
<ins>of the C++ standard library</ins>, such as <code>complex&lt;T&gt;</code> (29.4.3 <a href="https://timsong-cpp.github.io/cppwp/complex">[complex]</a>)<ins>, unless specified
otherwise (e.g. for integer-class types, 24.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>)</ins><del>, shall not have 
specializations</del>.
</p>
</blockquote>
</li>

<li>
<p>Modify 17.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/numeric.special">[numeric.special]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> I have left the "shall" usage in p1, because this seems to be a requirement for program-defined
specializations as well. The second sentence of p1 is one of the funny ones which partially look like introductory
wording, but also seems to indicate requirements, albeit specified in an unusual way ("meaningful").
<p/>
The extra wording added after p2 below attempts to improve the wording situation caused by LWG <a href="559" title="numeric_limits&lt;const T&gt; (Status: CD1)">559</a>
and does that by following a similar approach as done in 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>.
] 
</p>
</blockquote>

<blockquote>
<p>
-1- All members shall be provided for all specializations. However, many values are only required to be meaningful
under certain conditions (for example, <code>epsilon()</code> is only meaningful if <code>is_integer</code> is <code>false</code>). 
Any value that is not "meaningful" shall be set to <code>0</code> or <code>false</code>.
<p/>
-2- [<i>Example 1</i>: 
<p/>
[&hellip;]
<p/>
&mdash; <i>end note</i>]
</p>
<blockquote><pre>
<ins>template&lt;class T&gt; class numeric_limits&lt;const T&gt;;
template&lt;class T&gt; class numeric_limits&lt;volatile T&gt;;
template&lt;class T&gt; class numeric_limits&lt;const volatile T&gt;;</ins>
</pre></blockquote>
<p>
<ins>-?- Let <code>NL</code> denote <code>numeric_limits&lt;T&gt;</code> of the cv-unqualified type <code>T</code>. Then the 
value of each member of these specializations of <code>numeric_limits</code> is equal to the value of the corresponding 
member of the specialization <code>NL</code>.</ins>
<p/>
-3- The specialization for <code>bool</code> <del>shall be</del><ins>is</ins> provided as follows:
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="3924"><a href="3924">3924</a>. Stop token data race avoidance requirements unclear</h3>
<p><b>Section:</b> 32.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.stoptoken.intro">[thread.stoptoken.intro]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Bi <b>Opened:</b> 2023-04-16 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The first sentence of 32.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.stoptoken.intro">[thread.stoptoken.intro]</a>/5 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Calls to the functions <code>request_stop</code>, <code>stop_requested</code>, and <code>stop_possible</code> do not introduce data races.
</p>
</blockquote>
<p>
This could be read as saying that if you have a program that doesn't contain data races, 
and you change it by adding a call to any of these three functions, such a change does not 
"introduce" data races into the program. In other words, it could be read as saying that 
these three functions don't race with any other member functions on the same 
<code>stop_token</code> or <code>stop_source</code> object.
<p/>
I'm guessing the actual intended meaning is that calls to these three functions do not race
with each other, because it would be more expensive if concurrent calls with 
<code>stop_token::operator=</code> were also required to not race. (Also, none of these functions 
can avoid racing with the destructor.)
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"What about <code>get_token</code>? <code>operator==</code>?"
</p>
<p>
"Other functions like <code>get_stop_token</code> can also be called
concurrently. I think the text is actually correct."
</p>



<p id="res-3924"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>
<ol>
<li>
<p>Modify 32.3.1 <a href="https://timsong-cpp.github.io/cppwp/thread.stoptoken.intro">[thread.stoptoken.intro]</a> as indicated:</p>

<blockquote>
<p>
-5- Calls to the functions <code>request_stop</code>, <code>stop_requested</code>, and <code>stop_possible</code> 
do not introduce data races <ins>with each other</ins>.
A call to <code>request_stop</code> that returns <code>true</code> synchronizes with a call to 
<code>stop_requested</code> on an associated <code>stop_token</code> or <code>stop_source</code> object that 
returns <code>true</code>. Registration of a callback synchronizes with the invocation of that callback.
</p>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3926"><a href="3926">3926</a>. Which namespace <code>std</code> is the mentioned one?</h3>
<p><b>Section:</b> 16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2023-04-19 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#namespace.std">active issues</a> in [namespace.std].</p>
<p><b>View all other</b> <a href="lwg-index.html#namespace.std">issues</a> in [namespace.std].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> p1 says
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Unless otherwise specified, the behavior of a C++ program is undefined if it adds declarations or definitions to namespace 
<code>std</code> or to a namespace within namespace <code>std</code>.
</p>
</blockquote>
<p>
Which <code>std</code> namespace does the rule intend to refer to? Does the text refer to any namespace named <code>std</code>? 
Consider this case:
</p>
<blockquote><pre>
namespace A{
   namespace std{  // UB or not? 
      void show(){}
      namespace B{
         void fun(){}  // UB or not? 
     }
  }
}
int main(){  
}
</pre></blockquote>
<p>
A resemble usage like the above example can be seen in a <a href="https://github.com/NVIDIA/libcudacxx">libcudacxx github code</a>, 
for example.
<p/>
Suggested resolution:
<p/>
We may want to say the namespace <code>std</code> only refers to the namespace whose declaration <b>inhabits</b> the global scope.
<p/>
16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> p2, p7 that refers to namespace <code>std</code> have a similar issue.
</p>

<p><i>[2023-04-24; Ville provides wording]</i></p>


<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3926"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>Modify 16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> as indicated:</p>

<blockquote>
<p>
<ins>-?- The restrictions on the use of namespace <code>std</code> apply only to a top-level
namespace named <code>std</code>. Namespaces named <code>std</code> nested in program-defined 
namespaces are not restricted this way or otherwise reserved.</ins>
<p/>
-1- Unless otherwise specified, the behavior of a C++ program is undefined if it adds declarations or definitions
to namespace <code>std</code> or to a namespace within namespace <code>std</code>.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3928"><a href="3928">3928</a>. Non-top-level namespace <code>posix</code> shouldn't be reserved</h3>
<p><b>Section:</b> 16.4.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/namespace.posix">[namespace.posix]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-04-29 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The namespace <code>posix</code> is made reserved by <a href="https://wg21.link/N2667" title=" Reserved namespaces for POSIX">N2667</a>. 
<p/>
It is clear in the paper that only <code>::posix</code> is intendedly reserved, 
but the current normative wording is not clear enough on this (see also LWG <a href="3926" title="Which namespace std is the mentioned one? (Status: New)">3926</a>).
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3928"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>Modify 16.4.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/namespace.posix">[namespace.posix]</a> as indicated:</p>

<blockquote>
<p>
-1- The behavior of a C++ program is undefined if it adds declarations or definitions to <ins>top-level</ins>
namespace <code>posix</code> or to a namespace within <ins>that</ins> namespace <del><code>posix</code></del> unless 
otherwise specified. The <ins>top-level</ins> namespace <code>posix</code> is reserved for use by ISO/IEC/IEEE 9945
and other POSIX standards.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3929"><a href="3929">3929</a>. <i>Preconditions</i> for type traits should be <i>Mandates</i></h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>, 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-05-01 <b>Last modified:</b> 2023-06-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since we have adopted the <i>Constraints</i>/<i>Mandates</i>/<i>Preconditions</i> form of wording,
"preconditions" refer to runtime requirements, not compile-time.  As such, the
column labeled "preconditions" in Table 47: Type property predicates [tab:meta.unary.prop]
would be better labeled as "Mandates".
<p/>
This is an LWG issue and not editorial, and "Mandates" would require the library
to diagnose violations, but after reviewing all traits in this table, I believe that is
reasonable.
<p/>
Table 48: Type property queries [tab:meta.unary.prop.query] shows how <i>Mandates:</i>
elements can be integrated into the "Value" column if we preferred that approach, but for the
number of entries in the first table seems like an aggressive change for consistency.
<p/>
Similarly, for Table 49: Type relationship predicates [tab:meta.rel] the "Comments"
column serves as a "Mandates" feature without using that term, so I suggest changing
that column title too.
<p/>
The other tables and type traits wording already appear to be adapted to the Mandates
wording style.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
See also issue <a href="2939" title="Some type-completeness constraints of traits are overspecified (Status: Open)">2939</a>. We should not turn the preconditions into
<i>Mandates</i> without fixing them first.
</p>

<p><i>[2023-06-12; Varna]</i></p>

<p>During the review <a href="https://wg21.link/P2874R1" title=" Mandating Annex D">P2874R1</a> the group decided to not change the now decided for
<i>Preconditions:</i> element in D.13 <a href="https://timsong-cpp.github.io/cppwp/depr.meta.types">[depr.meta.types]</a> p3 into a <i>Mandates:</i> element 
but would like to solve this by this issue.</p>


<p id="res-3929"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>Change in 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>, Table 47: Type property predicates [tab:meta.unary.prop] 
the column title "<b>Preconditions</b>" to "<b>Mandates</b>".</p>
</li>

<li>
<p>Change in 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a>, Table 49: Type relationship predicates [tab:meta.rel] the column 
title "<b>Comments</b>" to "<b>Mandates</b>".</p>
</li>

</ol>





<hr>
<h3 id="3931"><a href="3931">3931</a>. Too many paper bump <code>__cpp_lib_ranges</code></h3>
<p><b>Section:</b> 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-03 <b>Last modified:</b> 2024-07-27</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently MSVC STL implements <a href="https://wg21.link/P2602R2" title=" Poison Pills are Too Toxic">P2602R2</a> and <a href="https://wg21.link/P2609R3" title=" Relaxing Ranges Just A Smidge">P2609R3</a> in C++20 mode 
as if they were defect reports. However, since <a href="https://wg21.link/P2387R3" title=" Pipe support for user-defined range adaptors">P2387R3</a> and <a href="https://wg21.link/P2494R2" title=" Relaxing range adaptors to allow for move only types">P2494R2</a>, 
which are possibly considered pure functionality extensions in C++23, also bump <code>__cpp_lib_ranges</code>, 
it's impossible to detect the status of P2602R2 and P2609R3 in C++20 mode (see 
<a href="https://github.com/microsoft/STL/pull/3486#discussion_r1112178364">the discussion in MSVC STL repo</a>).
<p/>
This may be a non-defect as P2602R2 and P2609R3 are not officially DRs. However, if these papers 
(including upcoming <a href="https://wg21.link/P2538R1" title=" ADL-proof std::projected">P2538R1</a>) are expected to be implemented in C++20 modes, it seems better 
to establish another feature-test macro (e.g., <code>__cpp_lib_ranges_mechanism</code>) for them.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"Needs a more descriptive name than <code>mechanism</code>."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4944" title=" Working Draft, Standard for Programming Language C++">N4944</a>.
</p>

<ol>
<li>
<p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: It is proposed to restore <code>__cpp_lib_ranges</code> to the value denoting 
<a href="https://wg21.link/P2494R2" title=" Relaxing range adaptors to allow for move only types">P2494R2</a>.]
</p>
</blockquote>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_ranges                            <del>202302L</del><ins>202207L</ins>
[&hellip;]
#define __cpp_lib_ranges_join_with                  202202L <i>// also in &lt;ranges&gt;</i>
<ins>#define __cpp_lib_ranges_mechanism                  202302L</ins>
  <ins><i>// also in &lt;algorithm&gt;, &lt;functional&gt;, &lt;iterator&gt;, &lt;memory&gt;, &lt;ranges&gt;</i></ins>
#define __cpp_lib_ranges_repeat                     202207L <i>// also in &lt;ranges&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>

</ol>

</blockquote>

<p><i>[2024-07-24; Jiang An comments and provides improved wording]</i></p>

<p>
All utilities changed by <a href="https://wg21.link/P2602R2" title=" Poison Pills are Too Toxic">P2602R2</a>, <a href="https://wg21.link/P2609R3" title=" Relaxing Ranges Just A Smidge">P2609R3</a>, and <a href="https://wg21.link/P2997R1" title=" Removing the common reference requirement from the indirectly invocable concepts">P2997R1</a> 
are now freestanding, so these proposed macros should also be freestanding.
</p>


<p id="res-3931"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li>
<p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting notes</i>: 
</p>
<ul>
<li><p>It is proposed to restore <code>__cpp_lib_ranges</code> to the value denoting <a href="https://wg21.link/P2494R2" title=" Relaxing range adaptors to allow for move only types">P2494R2</a>.</p></li>
<li><p><code>__cpp_lib_ranges_accessors</code> will cover <a href="https://wg21.link/P2602R2" title=" Poison Pills are Too Toxic">P2602R2</a>.</p></li>
<li><p><code>__cpp_lib_ranges_indirect_invocation</code> will cover <a href="https://wg21.link/P2609R3" title=" Relaxing Ranges Just A Smidge">P2609R3</a> and 
<a href="https://wg21.link/P2997R1" title=" Removing the common reference requirement from the indirectly invocable concepts">P2997R1</a>.</p></li>
<li><p>None of <a href="https://wg21.link/P2602R2" title=" Poison Pills are Too Toxic">P2602R2</a>, <a href="https://wg21.link/P2609R3" title=" Relaxing Ranges Just A Smidge">P2609R3</a>, and <a href="https://wg21.link/P2997R1" title=" Removing the common reference requirement from the indirectly invocable concepts">P2997R1</a> 
really affected utilities in <code>&lt;functional&gt;</code>, so these two proposed macros are 
not required to be also in <code>&lt;functional&gt;</code>.</p></li>
<li><p>Proposed macros are freestanding because utilities changed by these papers are all freestanding now.</p></li>
</ul>
<p>
]
</p>
</blockquote>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_ranges                            <del>202406L</del><ins>202207L</ins>
  // <i>also in</i> &lt;algorithm&gt;, &lt;functional&gt;, &lt;iterator&gt;, &lt;memory&gt;, &lt;ranges&gt;
<ins>#define __cpp_lib_ranges_accessors                  202211L
  // <i>freestanding, also in</i> &lt;algorithm&gt;, &lt;iterator&gt;, &lt;memory&gt;, &lt;ranges&gt;</ins>
[&hellip;]
#define __cpp_lib_ranges_generate_random            202403L // <i>also in</i> &lt;random&gt;
<ins>#define __cpp_lib_ranges_indirect_invocation        202406L
  // <i>freestanding, also in</i> &lt;algorithm&gt;, &lt;iterator&gt;, &lt;memory&gt;, &lt;ranges&gt;</ins>
#define __cpp_lib_ranges_iota                       202202L // <i>also in</i> &lt;numeric&gt;
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3932"><a href="3932">3932</a>. Expression-equivalence is sometimes unimplementable when passing prvalue expressions to comparison CPOs</h3>
<p><b>Section:</b> 17.12.6 <a href="https://timsong-cpp.github.io/cppwp/cmp.alg">[cmp.alg]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-04 <b>Last modified:</b> 2023-05-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cmp.alg">active issues</a> in [cmp.alg].</p>
<p><b>View all other</b> <a href="lwg-index.html#cmp.alg">issues</a> in [cmp.alg].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, comparison CPOs may call ADL-found <code>strong_order</code>, <code>weak_order</code>, and <code>partial_order</code> 
functions. It might be impossible to meet the expression-equivalent requirement if one passed argument is a prvalue 
and an ADL-found function is selected, because temporary materialization must take place before entering the CPO's 
<code>operator()</code>.
<p/>
Perhaps we should say when <code>E</code> or <code>F</code> is a prvalue expression of an object type, temporary 
materialization takes place first, and then an xvalue referring to the temporary object is used instead of the original 
<code>E</code> or <code>F</code>.
<p/>
There is currently implementation divergence in these CPOs: when performing internal comparison, libstdc++ and libc++ 
perfect-forward arguments, while MSVC STL always treats arguments as lvalues.
</p>

<p><i>[2023-05-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3932"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3933"><a href="3933">3933</a>. P1467R9 accidentally changed the signatures of certain constructors of <code>std::complex</code></h3>
<p><b>Section:</b> 29.4.3 <a href="https://timsong-cpp.github.io/cppwp/complex">[complex]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-16 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex">active issues</a> in [complex].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex">issues</a> in [complex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++20 and earlier revisions, there are constructors taking two floating-point numbers by value in explicit 
specializations of <code>std::complex</code> for standard floating-point types. Since <a href="https://wg21.link/P1467R9" title=" Extended floating-point types and standard names">P1467R9</a> has 
removed these explicit specializations, the corresponding constructor in the primary template that takes arguments 
by <code>const T&amp;</code> are used instead. As a result, the following program becomes ill-formed after the changes.
</p>
<blockquote><pre>
#include &lt;complex&gt;

int main()
{
  volatile double x = 0.0;
  std::complex&lt;double&gt; z{x, x}; // <span  style="color:#C80000;font-weight:bold">ill-formed due to P1467R9 because const double&amp; cannot be bound to a volatile double lvalue</span>
}
</pre></blockquote>
<p>
Currently, libstdc++ has implemented complex specializations for extended floating-point types, but the corresponding 
constructors of these specializations takes two arguments by value, which is consistent with old specializations.
<p/>
It seems that it's unintended to change the signatures of these constructors. Perhaps we should restore the signatures for 
required specializations.
</p>

<p>
<b>Daniel:</b>
<p/>
Not only constructors are affected, but also all assignment operators taking the <code>value_type</code> as
parameter and I suggest that LEWG should have a look at this issue.
</p>

<p><i>[2023-05-20; Daniel comments and suggests wording]</i></p>

<p>
The wording below attempts to restore the exact previous behaviour: For all floating-point types the 
function parameter types are "by value" and for other types are "by const reference". The wording adds for 
specification purposes a dependency to the concept <code>std::floating_point</code>, but that doesn't mean that an 
implementation couldn't realize the required effects without usage of concepts or the <code>&lt;type_traits&gt;</code>
header.
<p/>
Note that we have already precedence for similar cases where we later reintroduced concept requirements to library
parts where no concept dependencies had exist before, such as the <code>iterator_traits</code> specialization for
pointers (to object) or the additional constraints of <code>set</code>'s member function 
<code>iterator erase(const_iterator position)</code> or the constraint for <code>reverse_iterator::operator-&gt;()</code>,
just to name a few.
<p/>
One alternative approach could be to switch to "by-value" signatures only for the affected signatures. This could 
affect user-defined floating-point-like types such as those with an arbitrary precision, therefore I started with 
the most conservative approach restoring the original effects that was present in the
working draft <a href="https://wg21.link/N4910" title=" Working Draft, Standard for Programming Language C++">N4910</a> and older ones. It might we worth pointing out that the existing "setter"
functions <code>imag</code> and <code>real</code> have always been using "by-value" signatures for all specializations.
<p/>
There exists also the possible argument to close this issue as NAD based on the argument that all existing 
non-member operators taking a <code>value_type</code> argument had always been defined to use <code>const T&amp;</code>
as parameter (such as the <code>operator@(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs)</code> forms).
<p/>
My main argument to solve this issue as shown below is based on the ground that the refactoring done by
<a href="https://wg21.link/P1467R9" title=" Extended floating-point types and standard names">P1467R9</a> was mainly inspired to simplify the existing wording and to make it more easy to
integrate the addition of the extended floating-point types here, as quoted from 
<a href="https://wg21.link/p1467r9#complex">P1467R9 section 6.6. <code>&lt;complex&gt;</code></a>:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
[&hellip;] The explicit specializations of <code>std::complex&lt;T&gt;</code> are removed. The only differences between 
the explicit specializations was the explicit-ness of the constructors that take a complex number of a different type. 
</blockquote>
<p>
This issue has some overlap with LWG <a href="3934" title="std::complex&lt;T&gt;::operator=(const T&amp;) has no specification (Status: New)">3934</a>, which suggests a yet missing specification for
the assignment operator taking the <code>value_type</code> as parameter.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p>
Several votes for NAD, as this only affects <code>volatile</code> arguments,
so this might even be an accidental improvement.
</p>



<p id="res-3933"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>
<li>
<p>Modify 29.4.3 <a href="https://timsong-cpp.github.io/cppwp/complex">[complex]</a>, class template <code>complex</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T&gt; class complex {
  public:
    using value_type = T;

    <ins>constexpr complex(T re = T(), T im = T()) requires floating_point&lt;T&gt;;</ins>
    constexpr complex(const T&amp; re = T(), const T&amp; im = T()) <ins>requires (!floating_point&lt;T&gt;)</ins>;
    [&hellip;]
    <ins>constexpr complex&amp; operator= (T) requires floating_point&lt;T&gt;;</ins>
    constexpr complex&amp; operator= (const T&amp;) <ins>requires (!floating_point&lt;T&gt;)</ins>;
    <ins>constexpr complex&amp; operator+=(T) requires floating_point&lt;T&gt;;</ins>
    constexpr complex&amp; operator+=(const T&amp;) <ins>requires (!floating_point&lt;T&gt;)</ins>;
    <ins>constexpr complex&amp; operator-=(T) requires floating_point&lt;T&gt;;</ins>
    constexpr complex&amp; operator-=(const T&amp;) <ins>requires (!floating_point&lt;T&gt;)</ins>;
    <ins>constexpr complex&amp; operator*=(T) requires floating_point&lt;T&gt;;</ins>
    constexpr complex&amp; operator*=(const T&amp;) <ins>requires (!floating_point&lt;T&gt;)</ins>;
    <ins>constexpr complex&amp; operator/=(T) requires floating_point&lt;T&gt;;</ins>
    constexpr complex&amp; operator/=(const T&amp;) <ins>requires (!floating_point&lt;T&gt;)</ins>;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li>
<p>Modify 29.4.4 <a href="https://timsong-cpp.github.io/cppwp/complex.members">[complex.members]</a> as indicated:</p>

<blockquote>
<pre>
<ins>constexpr complex(T re = T(), T im = T()) requires floating_point&lt;T&gt;;</ins>
constexpr complex(const T&amp; re = T(), const T&amp; im = T()) <ins>requires (!floating_point&lt;T&gt;)</ins>;
</pre>
<blockquote>
<p>
-1- <i>Postconditions</i>: <code>real() == re &amp;&amp; imag() == im</code> is <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>Modify 29.4.5 <a href="https://timsong-cpp.github.io/cppwp/complex.member.ops">[complex.member.ops]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: We have an pre-existing specification hole that the effects of the non-compound assignment 
operator taking the <code>value_type</code> as parameter are nowhere specified. This is going to be submitted as a
separate issue, see LWG <a href="3934" title="std::complex&lt;T&gt;::operator=(const T&amp;) has no specification (Status: New)">3934</a>.]
</p>
</blockquote>

<blockquote>
<pre>
<ins>constexpr complex&amp; operator+=(T rhs) requires floating_point&lt;T&gt;;</ins>
constexpr complex&amp; operator+=(const T&amp; rhs) <ins>requires (!floating_point&lt;T&gt;)</ins>;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Adds the scalar value <code>rhs</code> to the real part of the complex value <code>*this</code> and 
stores the result in the real part of <code>*this</code>, leaving the imaginary part unchanged.
<p/>
-2- <i>Returns</i>: <code>*this</code>.
</p>
</blockquote>
<pre>
<ins>constexpr complex&amp; operator-=(T rhs) requires floating_point&lt;T&gt;;</ins>
constexpr complex&amp; operator-=(const T&amp; rhs) <ins>requires (!floating_point&lt;T&gt;)</ins>;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Subtracts the scalar value <code>rhs</code> from the real part of the complex value <code>*this</code> and 
stores the result in the real part of <code>*this</code>, leaving the imaginary part unchanged.
<p/>
-4- <i>Returns</i>: <code>*this</code>.
</p>
</blockquote>
<pre>
<ins>constexpr complex&amp; operator*=(T rhs) requires floating_point&lt;T&gt;;</ins>
constexpr complex&amp; operator*=(const T&amp; rhs) <ins>requires (!floating_point&lt;T&gt;)</ins>;
</pre>
<blockquote>
<p>
-5- <i>Effects</i>: Multiplies the scalar value <code>rhs</code> by the complex value <code>*this</code> and 
stores the result in <code>*this</code>.
<p/>
-6- <i>Returns</i>: <code>*this</code>.
</p>
</blockquote>
<pre>
<ins>constexpr complex&amp; operator/=(T rhs) requires floating_point&lt;T&gt;;</ins>
constexpr complex&amp; operator/=(const T&amp; rhs) <ins>requires (!floating_point&lt;T&gt;)</ins>;
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Divides the scalar value <code>rhs</code> into the complex value <code>*this</code> and 
stores the result in <code>*this</code>.
<p/>
-8- <i>Returns</i>: <code>*this</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3934"><a href="3934">3934</a>. <code>std::complex&lt;T&gt;::operator=(const T&amp;)</code> has no specification</h3>
<p><b>Section:</b> 29.4.3 <a href="https://timsong-cpp.github.io/cppwp/complex">[complex]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2023-05-20 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex">active issues</a> in [complex].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex">issues</a> in [complex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template <code>complex</code> synopsis in 29.4.3 <a href="https://timsong-cpp.github.io/cppwp/complex">[complex]</a> shows the following member function:
</p>
<blockquote><pre>
constexpr complex&amp; operator= (const T&amp;);
</pre></blockquote>
<p>
but does not specify its semantics. This affects a code example such as the following one:
</p>
<blockquote><pre>
#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
  std::complex&lt;double&gt; z(1, 1);
  z = 2;
  std::cout &lt;&lt; z &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
This problem exists since the 1998 version of the standard (at that time this was declared in subclause [lib.complex]),
but fortunately the three major implementations all behave consistently by assigning the provided value to the real
part and nullifying the imaginary part, causing the output <code>(2, 0)</code>, which is consistent with the expected
behaviour of usual mathematical convention and that of C's built-in <code>complex</code> types. We should specify this.
<p/>
The lack of this member specification was observed while a proposed wording for LWG <a href="3933" title="P1467R9 accidentally changed the signatures of certain constructors of std::complex (Status: New)">3933</a> was prepared.
</p>


<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3934"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording forms used below intentionally deviate from the rest of the [complex.member.ops]
wording forms, because it seems much simpler and clearer to follow the wording forms used that specify the effects
of <code>imag</code> and <code>real</code> functions. I decided to use "part" instead of "component", which is shorter and
more often used in the rest of the specification]
</p>
</blockquote>

<p>
<b>Option A:</b> This assumes that LWG <a href="3933" title="P1467R9 accidentally changed the signatures of certain constructors of std::complex (Status: New)">3933</a> is considered as NAD and just adds the missing prototype
specification assuming that the parameter style of the current working draft is intended.
</p>

<ol>

<li>
<p>Add a new prototype specification at the very beginning of 29.4.5 <a href="https://timsong-cpp.github.io/cppwp/complex.member.ops">[complex.member.ops]</a> as indicated:</p>

<blockquote>
<pre>
<ins>constexpr complex&amp; operator=(const T&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Assigns the value <code>rhs</code> to the real part and the value <code>T()</code> 
to the imaginary part of the complex value <code>*this</code>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <code>*this</code>.</ins>
</p>
</blockquote>
<pre>
constexpr complex&amp; operator+=(const T&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>

<p>
<b>Option b:</b> This assumes that LWG <a href="3933" title="P1467R9 accidentally changed the signatures of certain constructors of std::complex (Status: New)">3933</a> will be resolved as initially presented and just adds the missing prototype
specification assuming that the parameter style suggesting two mutually excluded overloads is intended. The wording delta is presented
against the proposed wording of LWG <a href="3933" title="P1467R9 accidentally changed the signatures of certain constructors of std::complex (Status: New)">3933</a>.
</p>

<ol>

<li>
<p>Add a new prototype specification at the very beginning of 29.4.5 <a href="https://timsong-cpp.github.io/cppwp/complex.member.ops">[complex.member.ops]</a> as indicated:</p>

<blockquote>
<pre>
<ins>constexpr complex&amp; operator=(T rhs) requires floating_point&lt;T&gt;;
constexpr complex&amp; operator=(const T&amp; rhs) requires (!floating_point&lt;T&gt;);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Assigns the value <code>rhs</code> to the real part and the value <code>T()</code> 
to the imaginary part of the complex value <code>*this</code>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <code>*this</code>.</ins>
</p>
</blockquote>
<pre>
constexpr complex&amp; operator+=(T) requires floating_point&lt;T&gt;;
constexpr complex&amp; operator+=(const T&amp;) requires (!floating_point&lt;T&gt;);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3937"><a href="3937">3937</a>. I/O manipulators should be specified in terms of base classes</h3>
<p><b>Section:</b> 31.7.7 <a href="https://timsong-cpp.github.io/cppwp/std.manip">[std.manip]</a>, 31.7.8 <a href="https://timsong-cpp.github.io/cppwp/ext.manip">[ext.manip]</a>, 31.7.9 <a href="https://timsong-cpp.github.io/cppwp/quoted.manip">[quoted.manip]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-05-25 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#std.manip">active issues</a> in [std.manip].</p>
<p><b>View all other</b> <a href="lwg-index.html#std.manip">issues</a> in [std.manip].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All the manipulators in 31.7.7 <a href="https://timsong-cpp.github.io/cppwp/std.manip">[std.manip]</a> and 31.7.8 <a href="https://timsong-cpp.github.io/cppwp/ext.manip">[ext.manip]</a>
use language of the form:
</p>
<blockquote>
An object of unspecified type such that if <code>out</code>
is an object of type <code>basic_ostream&lt;charT, traits&gt;</code>
then the expression <code>out &lt;&lt; resetiosflags(mask)</code> behaves as if
[...]
</blockquote>
<p>
This needs to work for any object with a public and unambiguous base class
of type <code>basic_ostream&lt;charT, traits&gt;</code>, not only objects
of exactly that type.
</p>
<p>
In C++98 and C++03, <code>setfill</code> did actually get this right
("if <code>out</code> is (or is derived from)
<code>basic_ostream&lt;charT,traits&gt;</code>"),
but that was "fixed" for C++11 to be consistent with the other manipulators.
</p>
<p>
31.7.9 <a href="https://timsong-cpp.github.io/cppwp/quoted.manip">[quoted.manip]</a> is slightly different, talking about
"an instance of <code>basic_ostream</code>", but that's not right either.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3937"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="3939"><a href="3939">3939</a>. &sect;[format.string.std] <code>char</code> is not formatted as a character when <code>charT</code> is <code>wchar_t</code></h3>
<p><b>Section:</b> 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2023-05-26 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.string.std">active issues</a> in [format.string.std].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.string.std">issues</a> in [format.string.std].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(See discussion at <a href="https://github.com/microsoft/STL/pull/3723">microsoft/STL/pull/3723</a>)
<p/>
28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> p21 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
The available integer presentation types for integral types other than <code>bool</code> and <code>charT</code> are 
specified in Table 68.
</p>
</blockquote>
<p>
When <code>charT</code> is <code>wchar_t</code>, the ordinary character type <code>char</code> falls into this category, and thus a 
<code>char</code> gets formatted as an integer by default, not as a character.
<p/>
This arguably doesn't affect the <code>std::format</code> family, because they are specified in terms of <code>make_format_args</code>, 
which calls the <code>basic_format_arg</code> constructor, which converts <code>char</code> to <code>wchar_t</code> 
(28.5.8.1 <a href="https://timsong-cpp.github.io/cppwp/format.arg">[format.arg]</a> (6.2)). But it does affect the <code>std::formatter&lt;char, wchar_t&gt;</code> specialization, 
which isn't specified to use <code>basic_format_arg</code>.
<p/>
This is especially problematic after <a href="https://wg21.link/P2286R8" title=" Formatting Ranges">P2286R8</a>, which makes <code>std::formatter&lt;char, wchar_t&gt;</code> 
debug-enabled, but there's no debug format for integral types other than <code>charT</code>.
<p/>
Perhaps [format.string.std] should say that the formatting arguments are converted as if through the <code>basic_format_arg</code> 
constructor.
<p/>
At the time of writing, on libstdc++ and libc++, <code>std::formatter&lt;char, wchar_t&gt;</code> formats the argument as 
a character when no specifier is given (<a href="https://godbolt.org/z/nnsEcvna3">godbolt.org/z/nnsEcvna3</a>), while 
MSVC STL's <code>std::formatter&lt;char, wchar_t&gt;</code> outputs the integer value. But I'm about to change MSVC STL to 
match the other implementations.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3939"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3941"><a href="3941">3941</a>. &sect;[atomics.order] inadvertently prohibits widespread implementation techniques</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2023-05-27 <b>Last modified:</b> 2025-02-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[Discovered by Ori Lahav, lead author of <a href="https://plv.mpi-sws.org/scfix/paper.pdf">Repairing Sequential Consistency in C/C++11</a>,
which <a href="https://wg21.link/P0668" title=" Revising the C++ memory model">P0668</a> more or less tried to implement. This description also includes observations 
from Olivier Giroux and David Goldblatt.]
<p/>
Currently, we require that the sequential consistency order S is consistent with the extended coherence order, 
which includes "reads before" and "reads from". This may require sc reads to be consistently ordered 
even if they see non-sc writes. This is not enforced by some "fence-after-store"/"trailing fence" sc 
implementations, notably on X86. It may also be violated by compiler transformations that eliminate a 
sequentially consistent load after a store into the same location, e.g. on sequentially consistent hardware.
<p/>
As Ori pointed out, this is exhibited by their (SB + rfis) example on x86 reproduced below. I would expect 
this also happens on other platforms. The (SB + rfis) example:
</p>
<blockquote>
<pre>
Thread 1: x.store(1, mo_release); r1 = x.load() /* sees 1 */; r2 = y.load() /* sees 0 */
Thread 2: y.store(1, mo_release); r1 = y.load() /* sees 1 */; r2 = x.load() /* sees 0 */
</pre>
</blockquote>
<p>
This is unintentionally and unexpectedly disallowed by the current standard. We can see this as follows:
<p/>
We have the following coherence-ordered-before relationships:
</p>
<ol style="list-style-type: none">
<li><p>By 3.1 in 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> (reads-from): The store in each thread is coherence-ordered-before the 
immediately following load.</p></li>
<li><p>By 3.3 (reads-before): The final load in each thread is coherence-ordered before the store in the other thread.</p></li>
<li><p>By 3.4 (transitivity): The final load in each thread is coherence-ordered-before the initial load in the other thread.</p></li>
</ol>
<p>
On the other hand, the initial load in each thread is sequenced-before and thus strongly-happens-before 
6.10.2.2 <a href="https://timsong-cpp.github.io/cppwp/intro.races">[intro.races]</a> p12.1 the final load in that thread. Thus coherence-ordered-before union strongly-happens-before 
is cyclic. But the S relation 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p4 must order all the loads, consistent with both strongly-happens-before 
(p4) and coherence-ordered-before (p4.1), which is clearly impossible.
<p/>
With the standard x86 implementation, no fences are inserted. Thread 1 and Thread 2 see the stores to <code>x</code> and 
<code>y</code> in inconsistent orders, which is allowed by TSO, since each thread can see its own write early. Thus the 
implementation allows the outcome in question, as expected.
<p/>
The problem here is an error during the attempt to simplify and translate 
<a href="https://plv.mpi-sws.org/scfix/paper.pdf">plv.mpi-sws.org/scfix/paper.pdf</a> to standardese. There is no known 
issue with the underlying paper.
<p/>
I have not yet wrapped my head around this sufficiently to be able to suggest a solution, or to understand how difficult 
that will be. This happened as a consequence of attempting to strengthen SC fences, and <em>not</em> fixing the Power 
compilation problem (<a href="https://wg21.link/P0668" title=" Revising the C++ memory model">P0668</a>). So we could probably improve matters by reverting the strengthening of sc fences. 
Clearly, we'd prefer to avoid that. We could just adopt the formulation in the paper, though that seems even harder to motivate 
informally. Fundamentally, it feels like we inadvertently strengthened (and broke) the semantics of ordinary sc operations, 
when we intended to only affect fences. The original paper makes more of a distinction there. The question is how we can 
reformulate that suitably here.
<p/>
[ Meta-observation from a small off-line discussion that may be relevant to how we phrase the resolution here: The fact that 
nobody noticed this for a very long time, and implementers were not bothered by it, suggests that the audience for this part 
of the standard is nearly empty. We conjecture that implementers actually rely on atomics mappings generated by memory model 
experts, who are more interested in formal models than standardese. A more formal description is likely to increase the size 
of the audience, and would definitely ease verification and reduce the probability of mistakes like this.]
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Send to SG1.
</p>

<p><i>[2025-02-10; SG1 reviewed the issue in March 2024 ]</i></p>

<p>
"we want to address LWG3941 in a way that preserves existing implementations
like X86" - unanimous consent.
</p>



<p id="res-3941"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3942"><a href="3942">3942</a>. Inconsistent use of <code>const char_type&amp;</code> in standard specializations of <code>std::char_traits</code></h3>
<p><b>Section:</b> 27.2.4 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations">[char.traits.specializations]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-05-27 <b>Last modified:</b> 2023-06-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.specializations">issues</a> in [char.traits.specializations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the standard specializations of <code>std::char_traits</code> (<code>std::char_traits&lt;char&gt;</code> etc.), there 
are a few member functions take a single character via a <code>const char_type&amp;</code> parameter, while other functions 
take a single character by value.
<p/>
In C++98, there were more functions taking <code>const char_type&amp;</code>. <a href="https://wg21.link/N2349" title=" Constant Expressions in the Standard Library Revision 2">N2349</a> changed this in 
C++11 by making some, but not all of them take <code>char_type</code>. It is unclear whether the inconsistency is 
intended, and it seems better for these standard specializations to take a character by value.
<p/>
However, libstdc++ hasn't implemented the signature changes, perhaps due to ABI concerns. So it might be better 
to loose the restrictions for the purpose of standardization.
</p>

<p><i>[2023-06-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3942"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> This assumes that "by-value" arguments are intended.
</p>

<ol>
<li>
<p>Modify the class template <code>char_traits</code> specialization synopses in 27.2.4.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char">[char.traits.specializations.char]</a>, 
27.2.4.3 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char8.t">[char.traits.specializations.char8.t]</a>, 27.2.4.4 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char16.t">[char.traits.specializations.char16.t]</a>, 
27.2.4.5 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char32.t">[char.traits.specializations.char32.t]</a>, and 27.2.4.6 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.wchar.t">[char.traits.specializations.wchar.t]</a> 
as indicated:</p>

<blockquote>
<pre>
[&hellip;]
    static constexpr void assign(char_type&amp; c1, <del>const </del>char_type<del>&amp;</del> c2) noexcept;
[&hellip;]
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           <del>const </del>char_type<del>&amp;</del> a);
[&hellip;]
</pre>
</blockquote>
</li>

</ol>

<p>
<b>Option B:</b> This assumes that implementation-freedom to keep ABI stability is intended.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> It is intended to keep the <code>assign(s, n, a)</code> taking the character by value, 
because the argument may be a character in <code>[s, s + n)</code>.] 
</p>
</blockquote>

<ol>
<li>
<p>Add a paragraph at the end of 27.2.4.1 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.general">[char.traits.specializations.general]</a> as indicated:</p>

<blockquote>
<p>
<ins>-?- For each occurrence of the placeholder <code><i>const-char-t</i></code> in the synopsis of each of these 
specializations, it is unspecified whether it denotes <code>char_type</code> or <code>const char_type&amp;</code>. 
Likewise, for each occurrence of the placeholder <code><i>const-int-t</i></code> in the synopsis of each of 
these specializations, it is unspecified whether it denotes <code>int_type</code> or <code>const int_type&amp;</code></ins>
</p>
</blockquote>
</li>

<li>
<p>Modify the class template <code>char_traits</code> specialization synopses in 27.2.4.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char">[char.traits.specializations.char]</a>, 
27.2.4.3 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char8.t">[char.traits.specializations.char8.t]</a>, 27.2.4.4 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char16.t">[char.traits.specializations.char16.t]</a>, 
27.2.4.5 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char32.t">[char.traits.specializations.char32.t]</a>, and 27.2.4.6 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.wchar.t">[char.traits.specializations.wchar.t]</a> 
as indicated:</p>

<blockquote>
<pre>
[&hellip;]
    static constexpr void assign(char_type&amp; c1, <del>const char_type&amp;</del><ins><i>const-char-t</i></ins> c2) noexcept;
    static constexpr bool eq(<del>char_type</del><ins><i>const-char-t</i></ins> c1, <del>char_type</del><ins><i>const-char-t</i></ins> c2) noexcept;
    static constexpr bool lt(<del>char_type</del><ins><i>const-char-t</i></ins> c1, <del>char_type</del><ins><i>const-char-t</i></ins> c2) noexcept;
[&hellip;]
    static constexpr const char_type* find(const char_type* s, size_t n,
                                           <del>const char_type&amp;</del><ins><i>const-char-t</i></ins> a);
[&hellip;]
    static constexpr int_type not_eof(<del>int_type</del><ins><i>const-int-t</i></ins> c) noexcept;
    static constexpr char_type to_char_type(<del>int_type</del><ins><i>const-int-t</i></ins> c) noexcept;
    static constexpr int_type to_int_type(<del>char_type</del><ins><i>const-char-t</i></ins> c) noexcept;
    static constexpr bool eq_int_type(<del>int_type</del><ins><i>const-int-t</i></ins> c1, <del>int_type</del><ins><i>const-int-t</i></ins> c2) noexcept;
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="3943"><a href="3943">3943</a>. Clarify lifetime requirements of <i>BasicFormatter</i> and <i>Formatter</i></h3>
<p><b>Section:</b> 28.5.6.3 <a href="https://timsong-cpp.github.io/cppwp/format.formattable">[format.formattable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mark de Wever <b>Opened:</b> 2023-06-01 <b>Last modified:</b> 2023-06-08</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.formattable">active issues</a> in [format.formattable].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.formattable">issues</a> in [format.formattable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A <a href="https://github.com/llvm/llvm-project/issues/62074">bug</a> has been
filed against libc++'s format implementation. The question arose whether
the parsed <i>chrono-specs</i> should still be available during executing the
formatter's <code>format</code> member function. Libc++'s implementation requires
this MSVC STL's implementation does not.
<p/>
It turns out there is a lifetime a requirement in the Standard, but it
would be good to clarify the intention of the wording. Prosed a small
wording improvement and a note to clarify the intention.
<p/>
Currently the <code>format</code> function may use elements in the range <code>[pc.begin(),
pc.end())</code> that have not been parsed. This does not seem to be in the
spirit of the formatting library. The wording change proposes to
restrict this range to the parsed range.
</p>

<p><i>[2023-06-08; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
The proposed resolution is missing a guarantee that the parsed portion of the
range is unchanged between the calls to <code>parse</code> and
<code>format</code>. It must remain valid <em>and</em> unchanged.
</p>



<p id="res-3943"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>
<li><p>Modify <i>BasicFormatter</i> requirements [tab:formatter.basic] as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 73: <i>BasicFormatter</i> requirements [tab:formatter.basic]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td colspan="3" align="center">
<code>&hellip;</code>
</td>
</tr>

<tr>
<td>
<code>f.format(u, fc)</code>
</td>
<td>
<code>FC::iterator</code>
</td>
<td>
Formats <code>u</code> according to the specifiers stored in<br/>
<code>*this</code>, writes the output to <code>fc.out()</code>, and returns<br/>
an iterator past the end of the output range.<br/>
The output shall only depend on <code>u</code>, <code>fc.locale()</code>,<br/>
<code>fc.arg(n)</code> for any value <code>n</code> of type <code>size_t</code>, and<br/>
the <ins>elements in the parsed</ins> range <ins>of</ins> <code>[pc.begin(), pc.end())</code><br/> 
from the last call to <code>f.parse(pc)</code>.
<p/>
<ins>[<i>Note ?</i>: Using elements in the parsed range of <code>[pc.begin(),<br/>
pc.end())</code> allows the formatter to store references, pointers, or<br/>
iterators to elements in the parsed range. For example,<br/>
<code>formatter&lt;chrono::day&gt;</code> might store the parsed <i>chrono-specs</i><br/>
(30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>) in a <code>basic_string_view</code>. &mdash; <i>end note</i>]</ins>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify <i>Formatter</i> requirements [tab:formatter] as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 74: <i>Formatter</i> requirements [tab:formatter]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<code>f.format(t, fc)</code>
</td>
<td>
<code>FC::iterator</code>
</td>
<td>
Formats <code>t</code> according to the specifiers stored in<br/>
<code>*this</code>, writes the output to <code>fc.out()</code>, and returns<br/>
an iterator past the end of the output range.<br/>
The output shall only depend on <code>t</code>, <code>fc.locale()</code>,<br/>
<code>fc.arg(n)</code> for any value <code>n</code> of type <code>size_t</code>, and<br/>
the <ins>elements in the parsed</ins> range <ins>of</ins> <code>[pc.begin(), pc.end())</code><br/>
from the last call to <code>f.parse(pc)</code>.
<p/>
<ins>[<i>Note ?</i>: Using elements in the parsed range of <code>[pc.begin(),<br/>
pc.end())</code> allows the formatter to store references, pointers, or<br/>
iterators to elements in the parsed range. For example,<br/>
<code>formatter&lt;chrono::day&gt;</code> might store the parsed <i>chrono-specs</i><br/>
(30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>) in a <code>basic_string_view</code>. &mdash; <i>end note</i>]</ins>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>
</li>

</ol>






<hr>
<h3 id="3945"><a href="3945">3945</a>. &sect;[cstdarg.syn] 'Compatible types' are undefined</h3>
<p><b>Section:</b> 17.14.2 <a href="https://timsong-cpp.github.io/cppwp/cstdarg.syn">[cstdarg.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lukas Barth <b>Opened:</b> 2023-06-08 <b>Last modified:</b> 2023-06-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cstdarg.syn">active issues</a> in [cstdarg.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdarg.syn">issues</a> in [cstdarg.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Subclause 17.14.2 <a href="https://timsong-cpp.github.io/cppwp/cstdarg.syn">[cstdarg.syn]</a> p1 bullet (1.2) states (among other things): 
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
[&hellip;]  If the parameter <code>parmN</code> is of a reference type, or of a type that is not
compatible with the type that results when passing an argument for which there is no parameter, 
the behavior is undefined.
</p></blockquote>
<p>
Unlike the C standard, the C++ standard has no notion of 'compatible
types', thus the meaning of this sentence unclear.
</p>


<p><i>[2023-06-12; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3945"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3952"><a href="3952">3952</a>. <code>iter_common_reference_t</code> does not conform to the definition of <code>indirectly_readable</code></h3>
<p><b>Section:</b> 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, 24.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.alias">[const.iterators.alias]</a>, 24.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.iterator">[const.iterators.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-06-28 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in [iterator.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>indirectly_readable</code> concept (24.3.4.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.readable">[iterator.concept.readable]</a>) requires 
<code>iter_reference_t&lt;In&gt;&amp;&amp;</code> and <code>iter_value_t&lt;In&gt;&amp;</code> to model 
<code>common_reference_with</code>, which ensures that the input iterator always has a common reference type.
<p/>
However, <code>iter_common_reference_t</code> for computing such types is defined as
<code>common_reference_t&lt;iter_reference_t&lt;T&gt;, <i>indirect-value-t</i>&lt;T&gt;&gt;</code>.
<p/>
It is  unclear why the formula here drop the <code>&amp;&amp;</code> part of <code>iter_reference_t&lt;In&gt;</code>, 
but theoretically it is not completely equivalent to the former, <a href="https://godbolt.org/z/h6GKn6oss">for example</a>:    
</p>
<blockquote><pre>
#include &lt;iterator&gt;

struct Ref {
  Ref(const Ref&amp;) = delete;
};

struct Val {
  operator const Ref&amp;() const &amp;;
};

struct I {
  using value_type = Val;
  using difference_type = int;
  Ref operator*() const;
  I&amp; operator++();
  I operator++(int);
};

static_assert(std::input_iterator&lt;I&gt;);
using reference  = std::iter_reference_t&lt;I&gt;;
using value_type = std::iter_value_t&lt;I&gt;;
static_assert(std::same_as&lt;std::common_reference_t&lt;reference&amp;&amp;, value_type&amp;&gt;, const Ref&amp;&gt;);
static_assert(std::same_as&lt;std::common_reference_t&lt;reference  , value_type&amp;&gt;,       Ref &gt;);

std::iter_value_t&lt;I&gt; val;
std::iter_common_reference_t&lt;I&gt; cr = val; // <span style="color:red;font-weight:bolder">failed</span>
</pre></blockquote>
<p>
In the above example, <code>input_iterator</code> ensures that the iterator's lvalue value type and rvalue reference type 
can be bound to its common reference type, namely <code>const Ref&amp;</code>, but the type calculated by 
<code>iter_common_reference_t</code> is <code>Ref</code>, which cannot be bound by both.
<p/>
The proposed resolution re-adds the <code>&amp;&amp;</code> to <code>iter_reference_t&lt;In&gt;</code> in formulas of similar 
form to conform to the definition of <code>indirectly_readable</code>.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"NAD - This can easily lead to dangling references. This only matters if
<code>iter_reference_t</code> isn't a language reference type,
and the change causes <code>common_reference</code> to produce
a language reference type. So binding to the common reference requires
a temporary. That's not going to work if the type is used as a return type
(as the const-cases are).
As written I think it also causes significant damage to constant-iterator."
</p>



<p id="res-3952"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>
<li><p>Modify 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header <code>&lt;iterator&gt;</code> synopsis, as indicated:</p>


<blockquote>
<pre>
[&hellip;]
template&lt;indirectly_readable T&gt;
  using iter_common_reference_t =                                                 // <i>freestanding</i>
    common_reference_t&lt;iter_reference_t&lt;T&gt;<ins>&amp;&amp;</ins>, <i>indirect-value-t</i>&lt;T&gt;&gt;;
[&hellip;]
</pre>
</blockquote>

</li>

<li><p>Modify 24.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.alias">[const.iterators.alias]</a> as indicated:</p>


<blockquote>
<pre>
template&lt;indirectly_readable It&gt;
  using iter_const_reference_t =
    common_reference_t&lt;const iter_value_t&lt;It&gt;&amp;&amp;, iter_reference_t&lt;It&gt;<ins>&amp;&amp;</ins>&gt;;
</pre>
</blockquote>

</li>

<li><p>Modify 24.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.iterator">[const.iterators.iterator]</a> as indicated:</p>


<blockquote>
<pre>
namespace std {
  template&lt;class I&gt;
    concept <i>not-a-const-iterator</i> = <i>see below</i>;                   // <i>exposition only</i>

  template&lt;indirectly_readable I&gt;
    using <i>iter-const-rvalue-reference-t</i> =                       // <i>exposition only</i>
      common_reference_t&lt;const iter_value_t&lt;I&gt;&amp;&amp;, iter_rvalue_reference_t&lt;I&gt;<ins>&amp;&amp;</ins>&gt;;
  [&hellip;]
};
</pre>
</blockquote>

</li>
</ol>





<hr>
<h3 id="3954"><a href="3954">3954</a>. Feature-test macros in C headers (<code>&lt;stddef.h&gt;</code> etc.)</h3>
<p><b>Section:</b> 17.15.1 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.general">[support.c.headers.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-07-06 <b>Last modified:</b> 2024-02-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several feature-test macros are available in C++ versions of C headers (e.g. <code>__cpp_lib_byte</code> is available in 
<code>&lt;cstddef&gt;</code>). However, the current standard wording doesn't seem to make the distinction between C++ library 
feature-test macros and macros from C, so it's not very clear that whether <code>&lt;stddef.h&gt;</code> and its friends are 
required to provide <code>__cpp_lib_*</code> macros in C++.
<p/>
Presumably, <code><i>name</i>.h</code> should provide macros shown in the synopsis of its corresponding <code>c<i>name</i></code> 
(as required in C), but should not be required to provide C++ library feature-test macros because such requirement would 
generally require implementations of the C standard library to change. I think we should make clarification in 
17.15.1 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.general">[support.c.headers.general]</a>.
</p>

<p><i>[2024-02-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll in July 2023.
</p>
<p><i>[Jonathan commented]</i></p>

<p>
The issue says that "such requirement would generally require implementations
of the C standard library to change" but this is not true.
A conforming C++ library already needs a C++-aware <code>&lt;stdlib.h&gt;</code> and <code>&lt;math.h&gt;</code>, and has done so since C++98! We should be cautious about expanding the set of C headers that need to be C++-aware, but if we require <code>&lt;stdlib.h&gt;</code> to define these functions:
<pre><code>
constexpr long abs(long);
constexpr long long abs(long long);
</code></pre>
then it can also define <code>__cpp_lib_constexpr_math</code>.
</p>
<p>
We have these <code>&lt;cxxx&gt;</code> headers providing feature test macros:
</p>
<pre>
&lt;cmath&gt;:
__cpp_lib_constexpr_cmath
 __cpp_lib_hypot
__cpp_lib_interpolate
__cpp_lib_math_special_functions

&lt;cstddef&gt;:
__cpp_lib_byte

&lt;cstdlib&gt;:
__cpp_lib_constexpr_cmath
</pre>
<p>
For <code>&lt;stdlib.h&gt;</code> and <code>&lt;math.h&gt;</code>
the implementation already needs a C++-specific version of the header,
because <code>::abs</code> is required to be overloaded (and constexpr) in
<code>&lt;stdlib.h&gt;</code> and <code>&lt;math.h&gt;</code>
(and all the math functions have to be constexpr even if you include
<code>&lt;math.h&gt;</code>).
So I see no issue here: the <code>&lt;xxx.h&gt;</code> headers should obviously
define the same macros as the <code>&lt;cxxx&gt;</code> headers.
</p>
<p>
We do not require <code>::byte</code> to be in <code>&lt;stddef.h&gt;</code>,
so maybe we should not require the macro there either.
Except that <code>std::byte</code> is permitted to be in
<code>&lt;stddef.h&gt;</code>,
just not in the global namespace (see LWG <a href="3883" title="&sect;[support.c.headers.other] Ambiguity in the requirements for includes (Status: New)">3883</a>).
So maybe SD-6 should simply clarify that the macro indicates the presence
of <code>std::byte</code>, not <code>::byte</code>,
and whether <code>std::byte</code> and its macro are defined
by <code>&lt;stddef.h&gt;</code> is unspecified.
Also related to LWG <a href="3484" title="Should &lt;stddef.h&gt; declare ::nullptr_t? (Status: New)">3484</a>.
</p>

<p><i>[Jens commented]</i></p>


<p>
It seems 17.15 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers">[support.c.headers]</a> is silent on which macros
from the <code>&lt;cxxx&gt;</code> headers are made available via the <code>&lt;xxx.h&gt;</code> headers,
given that 17.15.7 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers.other">[support.c.headers.other]</a> talks about names placed in
the standard library namespace (macros don't fit that description).
</p>

<p><i>[Ben noted some additional macros]</i></p>

<pre><code>
#define __cpp_lib_freestanding_cstdlib      <em>new-val // freestanding, also in &lt;cstdlib&gt;, &lt;cmath&gt;</em>
#define __cpp_lib_freestanding_cstring      <em>new-val // freestanding, also in &lt;cstring&gt;</em>
#define __cpp_lib_freestanding_cwchar       <em>new-val // freestanding, also in &lt;cwchar&gt;</em>
#define __cpp_lib_freestanding_errc         <em>new-val // freestanding, also in &lt;cerrno&gt;, &lt;system_error&gt;</em>
</code></pre>



<p id="res-3954"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3955"><a href="3955">3955</a>. Add <code>noexcept</code> to several <code>repeat_view[::<i>iterator</i>]</code> member functions</h3>
<p><b>Section:</b> 25.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.view">[range.repeat.view]</a>, 25.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.iterator">[range.repeat.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-07-06 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.repeat.view">issues</a> in [range.repeat.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several member functions of <code>repeat_view::<i>iterator</i></code> only operate on its integer member, indicating that 
they do not throw.
<p/>
Similarly, <code>repeat_view::size</code> should also be <code>noexcept</code> since it just performs the integer conversion.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Some votes for NAD.
"The iterator changes violate the Lakos rule."
</p>



<p id="res-3955"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>
<li><p>Modify 25.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.view">[range.repeat.view]</a>, class template <code>repeat_view</code> synopsis, as indicated:</p>


<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;move_constructible T, semiregular Bound = unreachable_sentinel_t&gt;
    requires (is_object_v&lt;T&gt; &amp;&amp; same_as&lt;T, remove_cv_t&lt;T&gt;&gt; &amp;&amp;
              (<i>integer-like-with-usable-difference-type</i>&lt;Bound&gt; ||
               same_as&lt;Bound, unreachable_sentinel_t&gt;))
  class repeat_view : public view_interface&lt;repeat_view&lt;T, Bound&gt;&gt; {
  private:
    [&hellip;]
  public:
    [&hellip;]

    constexpr auto size() const <ins>noexcept</ins> requires (!same_as&lt;Bound, unreachable_sentinel_t&gt;);
  };
  [&hellip;]
}
</pre>
<p>[&hellip;]</p>
<pre>
constexpr auto size() const <ins>noexcept</ins> requires (!same_as&lt;Bound, unreachable_sentinel_t&gt;);
</pre>
<blockquote>
<p>
-9- <i>Effects:</i> Equivalent to: <code>return <i>to-unsigned-like</i>(<i>bound_</i>);</code>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 25.6.5.3 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.iterator">[range.repeat.iterator]</a>, class <code>repeat_view::<i>iterator</i></code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;move_constructible T, semiregular Bound&gt;
    requires (is_object_v&lt;T&gt; &amp;&amp; same_as&lt;T, remove_cv_t&lt;T&gt;&gt; &amp;&amp;
              (<i>integer-like-with-usable-difference-type</i>&lt;Bound&gt; ||
               same_as&lt;Bound, unreachable_sentinel_t&gt;))
  class repeat_view&lt;T, Bound&gt;::<i>iterator</i> {
  private:
   using <i>index-type</i> =                          // <i>exposition only</i>
      conditional_t&lt;same_as&lt;Bound, unreachable_sentinel_t&gt;, ptrdiff_t, Bound&gt;;
   const T* <i>value_</i> = nullptr;                  // <i>exposition only</i>
   <i>index-type current_</i> = <i>index-type()</i>;         // <i>exposition only</i>

   constexpr explicit <i>iterator</i>(const T* value, <i>index-type</i> b = <i>index-type</i>());   // <i>exposition only</i>

  public:
    [&hellip;]
    constexpr <i>iterator</i>&amp; operator++() <ins>noexcept</ins>;
    constexpr <i>iterator</i> operator++(int) <ins>noexcept</ins>;

    constexpr const T&amp; operator[](difference_type n) const noexcept;

    friend constexpr bool operator==(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) <ins>noexcept</ins>;
    friend constexpr auto operator&lt;=&gt;(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) <ins>noexcept</ins>;

    friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) <ins>noexcept</ins>;
  };
}
</pre>
<p>
[&hellip;]
</p>
<pre>
constexpr <i>iterator</i>&amp; operator++() <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
++<i>current_</i>;
return *this;
</pre></blockquote>
</blockquote>
<pre>
constexpr <i>iterator</i> operator++(int) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
auto tmp = *this;
++*this;
return tmp;
</pre></blockquote>
</blockquote>
<p>[&hellip;]</p>
<pre>
friend constexpr bool operator==(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-15- <i>Effects:</i> Equivalent to: <code>return x.<i>current_</i> == y.<i>current_</i>;</code>
</p>
</blockquote>
<pre>
friend constexpr auto operator&lt;=&gt;(const <i>iterator</i>&amp;x, const <i>iterator</i>&amp; y) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-16- <i>Effects:</i> Equivalent to: <code>return x.<i>current_</i> &lt;=&gt; y.<i>current_</i>;</code>
</p>
</blockquote>
<p>[&hellip;]</p>
<pre>
friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-19- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
return static_cast&lt;difference_type&gt;(x.<i>current_</i>) - static_cast&lt;difference_type&gt;(y.<i>current_</i>);
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3959"><a href="3959">3959</a>. Should the comparator of <code>std::flat_map</code>/<code>std::flat_multimap</code> be copied twice in some operations?</h3>
<p><b>Section:</b> 23.6.8 <a href="https://timsong-cpp.github.io/cppwp/flat.map">[flat.map]</a>, 23.6.9 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap">[flat.multimap]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-07-23 <b>Last modified:</b> 2023-07-23</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#flat.map">active issues</a> in [flat.map].</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map">issues</a> in [flat.map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, some operations of <code>std::flat_map</code> are specified to construct a <code>key_equiv</code> 
object for calling <code>ranges::unique</code> to remove duplicated elements. It seems that the comparator 
is required to be copied twice before calling <code>ranges::unique</code>.
<p/>
If we make <code>key_equiv</code> to an aggregate class, then the comparator will be only copied once. 
Furtherly, if we use a <code>std::reference_wrapper&lt;const key_compare&gt;</code> as the member of 
<code>key_equiv</code>, then we will be able to avoid copying. Such differences seem to be observable.
<p/>
Should we require to avoid copying, or explicitly say that implementations can either make copies or avoid copying?
<p/>
Likewise, <code>std::flat_map::value_comp</code> and <code>std::flat_multimap::value_comp</code> seem to be 
required to copy the comparator twice due to the exposition-only constructor of <code>value_compare</code>. 
<p/>
Should we make the constructor take a <code>const</code> reference?
</p>


<p id="res-3959"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3960"><a href="3960">3960</a>. How does <code>chrono::parse</code> handle duplicated data?</h3>
<p><b>Section:</b> 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-07-28 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.parse">active issues</a> in [time.parse].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.parse">issues</a> in [time.parse].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A call to <code>chrono::parse</code> can encounter redundant or contradictory
data, e.g.
<pre><blockquote>stringstream("2023 2022") &gt;&gt; chrono::parse("%Y %C%y", yr);
</blockquote></pre>
or even simpler:
<pre><blockquote>stringstream("2023 2022") &gt;&gt; chrono::parse("%Y %Y", yr);
</blockquote></pre>
These cases can both be successfully parsed, as the input stream contains the
expected values in the expected format. But what value will <code>yr</code> have
after it returns?
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Should allow setting <code>failbit</code> if an implementation does detect
inconsistent values."
"Yes, that's what MSVC does, so the wording needs something like:
<ins>it is unspecified whether <code>setstate(ios_base::failbit)</code>
is called on the <code>basic_istream</code> or whether an unspecified value
is assigned to the <code>p</code> argument.</ins>"
</p>



<p id="res-3960"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> as indicated:</p>

<blockquote>
<p>
-17-
If the <code>from_stream</code> overload fails to parse everything specified by
the format string, or if insufficient information is parsed to specify
a complete duration, time point, or calendrical data structure,
<code>setstate(ios_base::failbit)</code> is called on the <code>basic_istream</code>.
</p>
<p><ins>
-?-
A format string can contain multiple flags that correspond to the same
information, (e.g., <code>"%Y %C%y"</code> or <code>"%R %H:%M"</code>). If such a
format string is successfully parsed but the extracted dates or times are
not consistent, the value assigned to the <code>tp</code> argument is unspecified.
</ins>
</p>
<p><ins>
[<i>Example</i>:
</ins>
<pre><blockquote><ins>chrono::year y;
stringstream("1905 1915") &gt;&gt; parse("%Y %C%y", y);
</ins></blockquote></pre>
<ins>
The value of <code>y</code> is unspecified; <code>y.ok()</code> can be <code>false</code>.
&mdash; <i>end example</i>]
</ins>
</p>

</blockquote>
</li>
</ol>





<hr>
<h3 id="3961"><a href="3961">3961</a>. Does <code>chrono::parse</code> check format strings?</h3>
<p><b>Section:</b> 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-07-28 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.parse">active issues</a> in [time.parse].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.parse">issues</a> in [time.parse].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> p16 says:
"If the type being parsed cannot represent the information that the format flag refers to, <code>is.setstate(ios_base::failbit)</code> is called."
Note it says "the format flag" singular. I had interpreted this as meaning that if the entire format string doesn't provide the info 
needed by the type, it fails. But that's not what it says.
It says that parsing fails if the type cannot represent
"the information that the format flag refers to". Which format flag?
Presumably this rule applies to each of them in turn.
So <code>"Monday 13:00" &gt;&gt; parse("%a %R", sec)</code> is required to fail,
rather than ignore the %a part and set <code>sec</code> to <code>13h</code>.
I don't think that is the intended design.
I think the phrasing of this rule is backwards. It shouldn't be focused on what info is provided by the format flag, 
but what info is needed by the type.
</p>

<p>
What should happen when <code>chrono::parse</code> is given a meaningless
format string like "%", or "%E", or "%Ea" or "%99a"?
Presumably that should set failbit, but I don't think we actually say so.
If the implementation should set failbit, is it conforming to do so before
extracting any characters?
</p>
<p>
Is it conforming to set failbit before extracting any characters if the
format string can never succeed for the parsable type?
Consider:
<pre><blockquote>std::chrono::seconds sec;
std::cin &gt;&gt; parse("%a", sec);
</blockquote></pre>

The type being parsed (<code>seconds</code>) cannot represent the information that
%a (a weekday) refers to, so we should set <code>cin.setstate(ios_base::failbit)</code>.
But should that happen before extracting any characters, or after extracting
a weekday string? If it's unspecified, should we say so explicitly?
</p>

<p>
Can a conforming implementation validate the format string before extracting
any characters, and fail early if parsing the actual istream contents can never
succeed? Or is <code>parse("%a", sec)</code> required to try to parse a valid
weekday name before setting <code>failbit</code>?
</p>


<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3961"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> as indicated:</p>

<blockquote>
<p>
-15-
All <code>from_stream</code> overloads behave as unformatted input functions,
except that they have an unspecified effect on the value returned by subsequent 
calls to <code><del>basic_istream&lt;&gt;::</del><ins>is.</ins>gcount()</code>.
Each overload takes a format string containing ordinary characters and
flags which have special meaning.
Each flag begins with a <code>%</code>.
Some flags can be modified by <code>E</code> or <code>O</code>.
During parsing each flag interprets characters as parts of date and time types
according to Table 102.
Some flags can be modified by a width parameter given as
a positive decimal integer called out as <code><i>N</i></code> below
which governs how many characters are parsed from the stream
in interpreting the flag.
All characters in the format string that are not represented in Table 102,
except for whitespace, are parsed unchanged from the stream.
A whitespace character matches zero or more whitespace characters
in the input stream.
</p>
<p>
<ins>
-?-
If a format string contains a <code>%</code> character that is not part of a flag
shown in Table 102, or a modifier that is not allowed for a flag,
<code>is.setstate(ios_base::failbit)</code> is called.
It is unspecified how many characters (if any) are extracted before the call
to <code>is.setstate(ios_base::failbit)</code>.
</ins>
</p>
<p>
-16-
If <ins>a value cannot be determined for</ins> the type being parsed
<ins>from the flags in the format string</ins>
<del>cannot represent the information that the format flag refers to</del>
<code>is.setstate(ios_base::failbit)</code> is called.
<ins>
It is unspecified how many characters (if any) are extracted before the call
to <code>is.setstate(ios_base::failbit)</code>.
</ins>
</p>
<p>
[<i>Example</i>:
A <code>duration</code> cannot represent a <del><code>weekday</code></del> <ins>weekday,
so <code>parse("%a", dur)</code> will always fail if the type of <code>dur</code>
is a specialization of <code>duration</code>.
Implementations can check the format string and set <code>failbit</code>
before extracting any characters.
</ins>
&mdash; <i>end example</i>]
</p>

</blockquote>
</li>
</ol>





<hr>
<h3 id="3962"><a href="3962">3962</a>. What is the "decimal precision of the input"?</h3>
<p><b>Section:</b> 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-07-28 <b>Last modified:</b> 2024-01-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.parse">active issues</a> in [time.parse].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.parse">issues</a> in [time.parse].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>%j</code> flag talks about "the type being parsed" and <code>%S</code> talks about
"the input time" and "the input", but doesn't really define which types
those are.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3962"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 30.13 <a href="https://timsong-cpp.github.io/cppwp/time.parse">[time.parse]</a> as indicated:</p>

<blockquote>
<p>
<ins>
-?-
In Table 102 the type <code>Parsable</code> denotes the type of the second
argument to <code>from_stream</code>.
</ins>
</p>

<table>
<tr><td><code style="padding:3em; text-align: center">%j</code></td>
<td>
If <del>the type being parsed</del> <ins><code>Parsable</code></ins>
is a specialization of <code>duration</code>, a decimal number of days.
</td></tr>
<tr><td>&nbsp;</td><td></td></tr>
<tr><td><code style="padding:3em; text-align: center">%S</code></td>
<td>
The seconds as a decimal number.
The modified command <code>%<i>N</i>S</code> specifies the maximum number of
characters to read.
If <code><i>N</i></code> is not specified, the default is 2
<ins>if <code>Parsable</code> is a calendrical type (30.8 <a href="https://timsong-cpp.github.io/cppwp/time.cal">[time.cal]</a>)</ins>
<del>if the input time has a precision convertible to seconds</del>.
Otherwise the default width is determined by the decimal precision of
<del>the input</del> <ins><code>Parsable</code>,
determined in the same manner as <code>hh_mm_ss::fractional_width</code>
(30.9 <a href="https://timsong-cpp.github.io/cppwp/time.hms">[time.hms]</a>). If the number of fractional decimal digits for
the type is zero, then the default for <code><i>N</i></code> is 2. Otherwise, it is
3 + W, where W is the number of fractional decimal digits.
If <code><i>N</i></code> is less than 3, the field is interpreted as a decimal integer, 
otherwise </ins><del>and</del>
the field is interpreted as a <code>long double</code> in a fixed format.
If encountered, the locale determines the decimal point character.
Leading zeroes are permitted but not required.
The modified command <code>%OS</code> interprets the locale's alternative
representation.
</td></tr>
</table>

</blockquote>
</li>
</ol>





<hr>
<h3 id="3963"><a href="3963">3963</a>. Different <code>std::flat_map</code>/<code>std::flat_multimap</code> specializations should be able to share same nested classes</h3>
<p><b>Section:</b> 23.6.8.2 <a href="https://timsong-cpp.github.io/cppwp/flat.map.defn">[flat.map.defn]</a>, 23.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap.defn">[flat.multimap.defn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-07-24 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map.defn">issues</a> in [flat.map.defn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Per current wording, <code>std::flat_map&lt;K, V, C1, KCont, VCont&gt;::containers</code> and 
<code>std::flat_multimap&lt;K, V, C2, KCont, VCont&gt;::containers</code> need to be different types 
since they are specified as nested classes. Likewise, 
<code>std::flat_map&lt;K, V, C, KCont1, VCont1&gt;::value_compare</code> and 
<code>std::flat_multimap&lt;K, V, C, KCont2, VCont2&gt;::value_compare</code> also need to be different types.
<p/>
It may be better to allow implementations to make different <code>std::flat_map</code>/<code>std::flat_multimap</code> 
specializations share same nested classes.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"This would mean we have to care about whether the template parameters are
associated entities of the <code>containers</code> type, for ADL purposes."
"That only matters if you're doing silly things, we shouldn't design the
library with silly people in mind."
"Nobody asked to be able to do this for <code>value_compare</code> in
associative containers, why do we think vendors would take advantage of this
freedom here? NAD."
</p>



<p id="res-3963"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Add the new paragraph after 23.6.8.2 <a href="https://timsong-cpp.github.io/cppwp/flat.map.defn">[flat.map.defn]</a> p1 and 23.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap.defn">[flat.multimap.defn]</a> p1 (twice):</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The intent is to keep the property that key/mapped types, key/mapped containers, 
and the comparator type are not the associated types of these nested classes during ADL. ]
</p>
</blockquote>

<blockquote>
<p>
<ins>
-?- Implementations may define member types <code>containers</code> and <code>value_compare</code> as nested 
classes of another templated class and introduce them as <i>typedef-name</i>s. Implementations shall ensure that 
these nested classes are not themselves class templates and have the specified names.
</ins>
</p>

</blockquote>
</li>
</ol>





<hr>
<h3 id="3964"><a href="3964">3964</a>. <code>std::atan2</code> and <code>std::pow</code> overloads that take two <code>std::valarray</code> parameters 
should require the arguments to have the same length</h3>
<p><b>Section:</b> 29.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/valarray.transcend">[valarray.transcend]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-07-28 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All binary operation between <code>std::valarray</code>s expect them to have the same length. 
But <code>std::atan2</code> and <code>std::pow</code> lack such <i>Preconditions</i>.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"Also need to say what those functions return."
"Paragraph 1 needs a correction for the functions that takes two operands."
"And those are arguments not operands."
</p>



<p id="res-3964"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 29.6.3.3 <a href="https://timsong-cpp.github.io/cppwp/valarray.transcend">[valarray.transcend]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt; valarray&lt;T&gt; abs (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; acos (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; asin (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const valarray&lt;T&gt;&amp;, const typename valarray&lt;T&gt;::value_type&amp;);
template&lt;class T&gt; valarray&lt;T&gt; atan2(const typename valarray&lt;T&gt;::value_type&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; cos (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; cosh (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; exp (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; log (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; log10(const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow (const valarray&lt;T&gt;&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow (const valarray&lt;T&gt;&amp;, const typename valarray&lt;T&gt;::value_type&amp;);
template&lt;class T&gt; valarray&lt;T&gt; pow (const typename valarray&lt;T&gt;::value_type&amp;, const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; sin (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; sinh (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; sqrt (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; tan (const valarray&lt;T&gt;&amp;);
template&lt;class T&gt; valarray&lt;T&gt; tanh (const valarray&lt;T&gt;&amp;);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: A unique function with the indicated name can be applied (unqualified) to an operand of
type <code>T</code>. This function returns a value of type <code>T</code> or which can be unambiguously implicitly converted to
type <code>T</code>.
<p/>
<ins>-?- <i>Preconditions</i>: For <code>atan2</code> and <code>pow</code> overloads that take two <code>valarray</code> parameters, 
the corresponding array arguments have the same length.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3966"><a href="3966">3966</a>. The <code>value_type</code> and <code>reference</code> members of <code>std::flat_(multi)map::(const_)iterator</code> are unclear</h3>
<p><b>Section:</b> 23.6.8.1 <a href="https://timsong-cpp.github.io/cppwp/flat.map.overview">[flat.map.overview]</a>, 23.6.9.1 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap.overview">[flat.multimap.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-08-04 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map.overview">issues</a> in [flat.map.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.6.8.1 <a href="https://timsong-cpp.github.io/cppwp/flat.map.overview">[flat.map.overview]</a> and 23.6.9.1 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap.overview">[flat.multimap.overview]</a> currently only require that the iterator types 
meet <i>Cpp17InputIterator</i> requirements and model the <code>std::random_access_iterator</code> concept.
<p/>
The intent seems to be that
</p>
<ul>
<li><p>the <code>operator*()</code> returns proxy references of type <code>std::pair&lt;const K&amp;, V&amp;&gt;</code> or 
<code>std::pair&lt;const K&amp;, const V&amp;&gt;</code> (same as the <code>reference</code> or <code>const_reference</code> 
types of the container adaptors), and</p></li>
<li><p>the <code>value_type</code> of these iterators is <code>std::pair&lt;K, V&gt;</code> (same as the <code>value_type</code> 
of the container adaptors).</p></li>
</ul>
<p>
However, such intent doesn't seem to be clear.
<p/>
Moreover, given such possibly intended iterator types don't meet <i>Cpp17ForwardIterator</i> requirements, 
we may need to mention the exceptions in 23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a> or 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a>.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3966"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3967"><a href="3967">3967</a>. The specification for <code>std::is_nothrow_*</code> traits may be ambiguous in some cases involving <code>noexcept(false)</code></h3>
<p><b>Section:</b> 21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-08-04 <b>Last modified:</b> 2023-08-05</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::is_nothrow_*</code> traits are currently specified in the form "(some operation) is known not to throw any exceptions". 
Under the following circumstance, the current specification may be ambiguous:
</p>
<ul>
<li><p>a trait detects an explicitly defaulted special member function, and</p></li>
<li><p>the implicit except specification of that function would be <code>noexcept(true)</code>, but</p></li>
<li><p>the function is explicitly marked with <code>noexcept(false)</code>.</p></li>
</ul>
<p>
It seems that an implementation may decompose the defaulted special member function and then conclude that the trait 
should give a <code>true</code> result, or may just use the exception specification which gives a <code>false</code> result.
<p/>
Implementors seemingly hold different opinions, see <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106611">GCC Bug 106611</a> 
and <a href="https://quuxplusone.github.io/blog/2023/04/17/noexcept-false-equals-default/">this blog post</a>.
<p/> 
Perhaps we may need to clarify that the implementation divergence is permitted, or unambiguously specify these 
traits to give results consistent with exception specifications.
</p>


<p id="res-3967"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3968"><a href="3968">3968</a>. <code>std::endian::native</code> value should be more specific about object representations</h3>
<p><b>Section:</b> 22.11.8 <a href="https://timsong-cpp.github.io/cppwp/bit.endian">[bit.endian]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Bi <b>Opened:</b> 2023-08-06 <b>Last modified:</b> 2024-02-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.11.8 <a href="https://timsong-cpp.github.io/cppwp/bit.endian">[bit.endian]</a> says that "big-endian" and "little-endian" refer to whether bytes are stored 
in descending or ascending order of significance. In other words, when <code>std::endian::native</code> is either 
<code>std::endian::big</code> or <code>std::endian::little</code>, we are told something about the object representations o
f multi-byte scalar types. However, the guarantee provided in this case is not strong enough to fully specify 
the object representation, even in the common situation where padding bits are not present. It would be more 
useful to provide a stronger guarantee.
<p/>
Consider, for example, if <code>char</code> is 8 bits and there is an <code>uint32_t</code> type on the current platform. 
If <code>std::endian::native</code> is <code>std::endian::little</code>, then the program should be able to rely on the 
fact that if a <code>uint32_t</code> object is copied into an array of 4 <code>unsigned char</code>, then the value of 
the first element of that array actually equals the original value modulo 256. However, because 
<a href="https://wg21.link/P1236R1" title=" Alternative Wording for P0907R4 Signed Integers are Two's Complement">P1236R1</a> removed the core language specification of the value representation of unsigned integer 
types, the program cannot actually rely on this. It is conceivable (though unlikely), for example, that 
<code>std::endian::native</code> could be <code>std::endian::little</code> but the first byte in a <code>uint32_t</code> 
object is actually the least significant 8 bits flipped, or the least significant 8 bits permuted, or something 
like that.
</p>

<p><i>[2024-02-22; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll in August 2023.
</p>
<p><i>[Jonathan expressed shock that <a href="https://wg21.link/P1236R1" title=" Alternative Wording for P0907R4 Signed Integers are Two's Complement">P1236R1</a> remove portability guarantees that were previously present.]</i></p>

<p><i>[Jens explained that no observable guarantees were ever present anyway, which is why Core removed the wording.]</i></p>

<p>
I agree with the thrust of the issue (i.e. the special values for
<code>std::endian</code> should permit reliance on a particular object
representation), but I disagree with the wording chosen.  The
"pure binary" phrasing that is sort-of defined in a footnote
is bad.  I think we want to say that all scalar types have no
padding bits and that the base-2 representation of
an unsigned integer type is formed by the bit concatenation
of the base-2 representations of the "unsigned char" values that
comprise the object representation of that unsigned integer type.
"bit concatenation" should best be phrased in math, e.g.
given a value <em>x</em> of some unsigned integer type and the
sequence of unsigned char values c<sup>j</sup> (each having width M)
comprising the object representation of x,
the coefficients of the base-2 representation of x are
 x<sub>i</sub> = c<sup>&lfloor;i/M&rfloor;</sup><sub>i mod M</sub>
or somesuch.  See 7.6.11 <a href="https://timsong-cpp.github.io/cppwp/expr.bit.and">[expr.bit.and]</a> for some phrasing in this area.
</p>



<p id="res-3968"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify the 22.11.8 <a href="https://timsong-cpp.github.io/cppwp/bit.endian">[bit.endian]</a> as indicated; using 
<a href="https://timsong-cpp.github.io/cppwp/n4659/basic.fundamental#7">removed wording from C++17</a>:</p>

<blockquote>
<p>
-2- <del>If all scalar types have size 1 byte, then all of <code>endian::little</code>, <code>endian::big</code>, 
and <code>endian::native</code> have the same value. Otherwise, <code>endian::little</code> is not equal to 
<code>endian::big</code>. If all scalar types are big-endian, <code>endian::native</code> is equal to 
<code>endian::big</code>. If all scalar types are little-endian, <code>endian::native</code> is equal to 
<code>endian::little</code>. Otherwise, <code>endian::native</code> is not equal to either <code>endian::big</code> or
<code>endian::little</code>.</del><ins><code>endian::little</code> is equal to <code>endian::big</code> if and only if 
all scalar types have size 1 byte. If the value representation (6.9 <a href="https://timsong-cpp.github.io/cppwp/basic.types">[basic.types]</a>) of every 
unsigned integer type uses a pure binary numeration system<sup>footnote ?</sup>, then:</ins>
</p>
<ul>
<li><p><ins>If all scalar types have size 1 byte, then <code>endian::native</code> is equal to the common value 
of <code>endian::little</code> and <code>endian::big</code>.</ins></p></li>
<li><p><ins>Otherwise, if all scalar types are big-endian, <code>endian::native</code> is equal to <code>endian::big</code>.</ins></p></li>
<li><p><ins>Otherwise, if all scalar types are little-endian, <code>endian::native</code> is equal to <code>endian::little</code>.</ins></p></li>
<li><p><ins>Otherwise, <code>endian::native</code> is not equal to either <code>endian::big</code> or <code>endian::little</code>.</ins></p></li>
</ul>
<p>
<ins>Otherwise, <code>endian::native</code> is not equal to either <code>endian::big</code> or <code>endian::little</code>.</ins>
</p>
<blockquote><p>
<ins>footnote ?) A positional representation for integers that uses the binary digits 0 and 1, in which the 
values represented by successive bits are additive, begin with 1, and are multiplied by successive integral 
powers of 2, except perhaps for the bit with the highest position. (Adapted from the American National 
Dictionary for Information Processing Systems.)</ins>
</p></blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3969"><a href="3969">3969</a>. <code>std::ranges::fold_left_first_with_iter</code> should be more ADL-proof</h3>
<p><b>Section:</b> 26.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-08-10 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.fold">active issues</a> in [alg.fold].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.fold">issues</a> in [alg.fold].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following program is currently ill-formed, because 26.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a>/10 requires evaluating 
<code>*init</code>, where <code>init</code> is an object of an <code>optional</code> specialization, which triggers 
ADL and finds unwanted overloads.
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;optional&gt;

namespace myns {
  struct Foo {};
  
  void operator*(std::optional&lt;Foo&gt;&amp;);
  void operator*(const std::optional&lt;Foo&gt;&amp;);
}

int main()
{
  myns::Foo x[1]{};
  std::ranges::fold_left_first_with_iter(x, []&lt;class T&gt;(T lhs, T) { return lhs; });
}
</pre></blockquote>
<p>
I think only the member <code>operator*</code> overload is intendedly used.
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>Many votes for NAD.
"Yuck, can we just use <code>.value()</code> instead?"
"The example is not good motivation, but we should ADL-proof to avoid
attempting to complete incomplete associated classes."
</p>



<p id="res-3969"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4950" title=" Working Draft, Standard for Programming Language C++">N4950</a>.
</p>

<ol>

<li><p>Modify 26.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S,
         <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
  requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
  constexpr <i>see below</i> ranges::fold_left_first_with_iter(I first, S last, F f);
template&lt;input_range R, <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
  requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
  constexpr <i>see below</i> ranges::fold_left_first_with_iter(R&amp;&amp; r, F f);
</pre>
<blockquote>
<p>
-9- Let <code>U</code> be
</p>
<blockquote><pre>
decltype(ranges::fold_left(std::move(first), last, iter_value_t&lt;I&gt;(*first), f))
</pre></blockquote>
<p>
-10- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return {std::move(first), optional&lt;U&gt;()};
optional&lt;U&gt; init(in_place, *first);
for (++first; first != last; ++first)
  <del>*init</del><ins>init.operator*()</ins> = invoke(f, std::move(<del>*init</del><ins>init.operator*()</ins>), *first);
return {std::move(first), std::move(init)};
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="3972"><a href="3972">3972</a>. Issues with <code>join_with_view::<i>iterator</i></code>'s <code>iter_swap</code></h3>
<p><b>Section:</b> 25.7.15.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.iterator">[range.join.with.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-09-04 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.with.iterator">active issues</a> in [range.join.with.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.with.iterator">issues</a> in [range.join.with.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>iter_swap</code> customization for <code>join_with_view::<i>iterator</i></code> allows swapping iterators 
with different element types, potentially leading to unsafe behavior, <a href="https://godbolt.org/z/5qzGb881x">for example</a>:
</p>
<blockquote>
<pre>
vector&lt;vector&lt;string&gt;&gt; x{{"a"}, {"b"}, {"c"}};
vector&lt;string_view&gt;    y{"-"};
auto r = x | views::join_with(y);
auto i = r.begin();
auto j = ranges::next(i);
ranges::iter_swap(j, i);
for (auto&amp;&amp; elem : r)
  cout &lt;&lt; elem &lt;&lt; " "; // <span style="color:red;font-weight:bolder">AddressSanitizer: stack-use-after-return on address</span>
</pre>
</blockquote>
<p>
The above swaps two iterators whose reference are <code>string_view&amp;</code> and <code>string&amp;</code> respectively, 
which ultimately results in <code>string_view</code> being referenced to a local variable and left dangling.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p id="res-3972"><b>Proposed resolution:</b></p>






<hr>
<h3 id="3976"><a href="3976">3976</a>. What does it mean for a type to be "allocator aware"?</h3>
<p><b>Section:</b> 23.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.alloc.reqmts">[container.alloc.reqmts]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-08-14 <b>Last modified:</b> 2023-09-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#container.alloc.reqmts">issues</a> in [container.alloc.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Trying to interpret the specification for <i>allocator-aware container</i>s, 23.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.alloc.reqmts">[container.alloc.reqmts]</a>.
<p/>
P1 establishes that <code>std::array</code> is <em>not</em> an allocator-aware container, but all other containers in
the standard are.
<p/>
P2 then adds vocabulary, with ruling that if a container type <code>X</code> is not allocator-aware then
the specification is as-if the allocator were <code>std::allocator&lt;T&gt;</code>. I cannot find a specification
for allocator-aware, and do not believe we should treat this as a recursive definition, as
the only standard container that would be affected would be <code>std::array</code>, which absolutely
does not want to apply all the terms in this subclause.
<p/>
It looks like we might mean types that do not have everything specified by the first
sentence, such as an <code>allocator_type</code> member. Perhaps we want to say a container
type <code>X</code> is allocator-aware using allocator <code>A</code> if [&hellip;], and then that <code>basic_string</code> and
containers that are not otherwise allocator aware are are treated as-if they were
allocator-aware using <code>std::allocator&lt;typename X::value_type&gt;</code> (where <code>value_type</code>
is already guaranteed to exist by the <i>container</i> requirements, 23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a> p1).
</p>


<p id="res-3976"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3977"><a href="3977">3977</a>. <code>constexpr</code> and <code>noexcept</code> for operators for bitmask types</h3>
<p><b>Section:</b> 16.3.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-08-19 <b>Last modified:</b> 2024-02-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#bitmask.types">active issues</a> in [bitmask.types].</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, no operator in 16.3.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a>/2 is specified as <code>noexcept</code>, and the compound assignment 
operators are not specified as <code>constexpr</code>.
<p/>
Implementations are divergent on this. E.g., MSVC STL 
<a href="https://github.com/microsoft/STL/blob/8f67ece4a654625220642c92fa029a5cfc77afa8/stl/inc/type_traits#L2266-L2297">consistently 
marks them <code>constexpr</code> and <code>noexcept</code></a> (given MSVC STL doesn't support pre-C++14 modes), while libstdc++'s 
<a href="https://github.com/gcc-mirror/gcc/blob/fab08d12b40ad637c5a4ce8e026fb43cd3f0fad1/libstdc%2B%2B-v3/include/bits/regex_constants.h#L395-L408">compound 
assignment operators for <code>match_flag_type</code></a> are <code>constexpr</code> since C++14 but lack <code>noexcept</code>, and 
<a href="https://github.com/gcc-mirror/gcc/blob/fab08d12b40ad637c5a4ce8e026fb43cd3f0fad1/libstdc%2B%2B-v3/include/std/future#L176-L183">the 
operators for <code>launch</code></a> are <code>noexcept</code> but not <code>constexpr</code>.
<p/>
I think it's better to ensure more consistency be integer types and non-integer bitmask types, i.e., require the 
compound assignment operators to be <code>constexpr</code> (only available in C++14 and later) and all operators to be <code>noexcept</code>.
</p>

<p><i>[2024-02-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll in September 2023.
</p>
<p><i>[Jonathan commented]</i></p>

<p>
"The proposed change only affects an example showing a possible way to implement
a made-up example type. It doesn't change any requirements on bitmask types,
or change anything for any of the bitmask types defined in the standard library.
It doesn't say that implementing them without noexcept and constexpr would be
invalid.
This change has no normative effect and certainly doesn't achieve the stated
aim of requiring these assignments to be constexpr and non-throwing."
</p>
<p><i>[Casey agreed]</i></p>

<p>
"We should strike paragraph two completely and write up the actual requirements
that a bitmask type is required to meet, but that's a lot of work for someone."
</p>



<p id="res-3977"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 16.3.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/bitmask.types">[bitmask.types]</a> as indicated:</p>

<blockquote>
<p>
-2- The bitmask type <code><i>bitmask</i></code> can be written:
</p>
<blockquote>
<pre>
// <i>For exposition only.</i>
// <i>int_type is an integral type capable of representing all values of the bitmask type.</i>
enum <i>bitmask</i> : int_type {
  <i>V</i><sub>0</sub> = 1 &lt;&lt; 0, <i>V</i><sub>1</sub> = 1 &lt;&lt; 1, <i>V</i><sub>2</sub> = 1 &lt;&lt; 2, <i>V</i><sub>3</sub> = 1 &lt;&lt; 3, &hellip;
};

inline constexpr <i>bitmask</i> <i>C</i><sub>0</sub>(<i>V</i><sub>0</sub>);
inline constexpr <i>bitmask</i> <i>C</i><sub>1</sub>(<i>V</i><sub>1</sub>);
inline constexpr <i>bitmask</i> <i>C</i><sub>2</sub>(<i>V</i><sub>2</sub>);
inline constexpr <i>bitmask</i> <i>C</i><sub>3</sub>(<i>V</i><sub>3</sub>);

[&hellip;]

constexpr bitmask operator&amp;(bitmask X, bitmask Y) <ins>noexcept</ins> {
  return static_cast&lt;bitmask&gt;(
    static_cast&lt;int_type&gt;(X) &amp; static_cast&lt;int_type&gt;(Y));
}
constexpr bitmask operator|(bitmask X, bitmask Y) <ins>noexcept</ins> {
  return static_cast&lt;bitmask&gt;(
    static_cast&lt;int_type&gt;(X) | static_cast&lt;int_type&gt;(Y));
}
constexpr bitmask operator^(bitmask X, bitmask Y) <ins>noexcept</ins> {
  return static_cast&lt;bitmask&gt;(
    static_cast&lt;int_type&gt;(X) ^ static_cast&lt;int_type&gt;(Y));
}
constexpr bitmask operator~(bitmask X) <ins>noexcept</ins> {
  return static_cast&lt;bitmask&gt;(~static_cast&lt;int_type&gt;(X));
}
<ins>constexpr</ins> bitmask&amp; operator&amp;=(bitmask&amp; X, bitmask Y) <ins>noexcept</ins> {
  X = X &amp; Y; return X;
}
<ins>constexpr</ins> bitmask&amp; operator|=(bitmask&amp; X, bitmask Y) <ins>noexcept</ins> {
  X = X | Y; return X;
}
<ins>constexpr</ins> bitmask&amp; operator^=(bitmask&amp; X, bitmask Y) <ins>noexcept</ins> {
  X = X ^ Y; return X;
}
</pre>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3979"><a href="3979">3979</a>. Should we reject <code>std::bind_front&lt;42&gt;()</code> and its friends?</h3>
<p><b>Section:</b> 22.10.13 <a href="https://timsong-cpp.github.io/cppwp/func.not.fn">[func.not.fn]</a>, 22.10.14 <a href="https://timsong-cpp.github.io/cppwp/func.bind.partial">[func.bind.partial]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-08-22 <b>Last modified:</b> 2024-02-22</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.not.fn">issues</a> in [func.not.fn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::bind_front&lt;42&gt;()</code> seems to be currently well-formed, but the result isn't invocable with any arguments. 
Given we are already detecting types and values of the NTTP for new overloads of <code>std::bind_front</code>, 
<code>std::bind_back</code>, and <code>std::not_fn</code>, it might be better to diagnose such cases when NTTP is of a scalar type.
<p/>
Note that we might need to separately handle NTTP of scalar and class types for these functions when 
<a href="https://wg21.link/CWG2459">CWG2459</a> is not resolved, because it might be necessary to avoid copying a 
template parameter object.
</p>

<p><i>[2024-02-22; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll in September 2023.
</p>
<p>
"Not convinced it's worth adding a small amount of future maintenance burden
to catch a tiny amount of nonsense-but-not-dangerous code slightly earlier
(at the point of call instead of point of use)."
</p>
<p>
"NAD. We reject <code>bind_front&lt;null_f&gt;()</code> because
<code>bind_front(null_f)()</code> compiles but gives UB.
Neither <code>bind_front(42)()</code> nor <code>bind_front&lt;42&gt;()</code>
compiles."
</p>



<p id="res-3979"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 22.10.13 <a href="https://timsong-cpp.github.io/cppwp/func.not.fn">[func.not.fn]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;auto f&gt; constexpr <i>unspecified</i> not_fn() noexcept;
</pre>
<blockquote>
<p>
-6- [&hellip;]
<p/>
-7- <i>Mandates</i>: If <del><code>is_pointer_v&lt;F&gt; || is_member_pointer_v&lt;F&gt;</code> is <code>true</code>, then 
<code>f != nullptr</code> is <code>true</code></del><ins><code>is_scalar_v&lt;F&gt;</code> is <code>true</code>, then either 
<code>is_pointer_v&lt;F&gt; &amp;&amp; is_function_v&lt;remove_pointer_t&lt;F&gt;&gt;</code> is <code>true</code> or 
<code>is_member_pointer_v&lt;F&gt;</code> is <code>true</code>, and <code>f != nullptr</code> is <code>true</code> in either case</ins>.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 22.10.14 <a href="https://timsong-cpp.github.io/cppwp/func.bind.partial">[func.bind.partial]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;auto f, class... Args&gt;
  constexpr <i>unspecified</i> bind_front(Args&amp;&amp;... args);
template&lt;auto f, class... Args&gt;
  constexpr <i>unspecified</i> bind_back(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-6- [&hellip;]
<p/>
-7- <i>Mandates</i>:
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; [&hellip;]</p></li>
<li><p>(7.2) &mdash; [&hellip;]</p></li>
<li><p>(7.3) &mdash; if <del><code>is_pointer_v&lt;F&gt; || is_member_pointer_v&lt;F&gt;</code> is <code>true</code>, then 
<code>f != nullptr</code> is <code>true</code></del><ins><code>is_scalar_v&lt;F&gt;</code> is <code>true</code>, then either 
<code>is_pointer_v&lt;F&gt; &amp;&amp; is_function_v&lt;remove_pointer_t&lt;F&gt;&gt;</code> is <code>true</code> or 
<code>is_member_pointer_v&lt;F&gt;</code> is <code>true</code>, and <code>f != nullptr</code> is <code>true</code> in either case</ins>.</p></li>
</ol>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3983"><a href="3983">3983</a>. <code>ranges::to</code> adaptors are underconstrained</h3>
<p><b>Section:</b> 25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-23 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>ranges::to</code> adaptor returns a range adaptor closure object that stores a copy of the decayed parameter pack.
<p/>
However, the function signature does not constrain the type of arguments, which leads to hard errors within the function 
body when they cannot be copied (<a href="https://godbolt.org/z/9f8q3zvb5">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;vector&gt;

struct NonMovable {
  NonMovable() = default;
  NonMovable(NonMovable&amp;&amp;) = delete;
};

int main() {
  auto r = std::ranges::to&lt;std::vector&gt;(NonMovable{}); // <span style="color:red;font-weight:bolder">hard error in MSVC-STL and libc++</span>
}
</pre></blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;compare&gt;              // <i>see <a href="https://wg21.link/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see <a href="https://wg21.link/iterator.synopsis">[iterator.synopsis]</a></i>

namespace std::ranges {
  [&hellip;]
  // <i>25.5.7 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv">[range.utility.conv]</a>, range conversions</i>
  template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;&gt;)
    constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);                                          // <i>freestanding</i>
  template&lt;template&lt;class...&gt; class C, input_range R, class... Args&gt;
    constexpr auto to(R&amp;&amp; r, Args&amp;&amp;... args);                                       // <i>freestanding</i>
  template&lt;class C, class... Args&gt;
    requires (!view&lt;C&gt;) <ins>&amp;&amp; (constructible_from&lt;decay_t&lt;Args&gt;, Args&gt; &amp;&amp; ...)</ins>
    constexpr auto to(Args&amp;&amp;... args);                                              // <i>freestanding</i>
  template&lt;template&lt;class...&gt; class C, class... Args&gt;
    <ins>requires (constructible_from&lt;decay_t&lt;Args&gt;, Args&gt; &amp;&amp; ...)</ins>
    constexpr auto to(Args&amp;&amp;... args);                                              // <i>freestanding</i>
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, class... Args&gt;
  requires (!view&lt;C&gt;) <ins>&amp;&amp; (constructible_from&lt;decay_t&lt;Args&gt;, Args&gt; &amp;&amp; ...)</ins>
  constexpr auto to(Args&amp;&amp;... args);
template&lt;template&lt;class...&gt; class C, class... Args&gt;
  <ins>requires (constructible_from&lt;decay_t&lt;Args&gt;, Args&gt; &amp;&amp; ...)</ins>
  constexpr auto to(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: For the first overload, <code>C</code> is a cv-unqualified class type.
<p/>
-2- <i>Returns</i>: A range adaptor closure object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>) <code>f</code> that is a 
perfect forwarding call wrapper (22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>) with the following properties:
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Votes split between NAD and using <em>Mandates</em> instead of constraints.
</p>


<p><i>[2023-09-28; Hewill provides alternative wording]</i></p>

<p>
The new wording form is consistent with the current wording, that is, it has a similar structure 
with 25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> p1 and 25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> p8.
</p>



<p id="res-3983"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr auto to(Args&amp;&amp;... args);
template&lt;template&lt;class...&gt; class C, class... Args&gt;
  constexpr auto to(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: For the first overload, <code>C</code> is a cv-unqualified class type.
<p/>
-2- <i>Returns</i>: A range adaptor closure object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>) <code>f</code> that is a 
perfect forwarding call wrapper (22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>) with the following properties:
</p>
<ol style="list-style-type:none">
<li><p>(2.1) &mdash; It has no target object.</p></li>
<li><p>(2.2) &mdash; Its bound argument entities <code>bound_args</code> consist of objects of types <code>decay_t&lt;Args&gt;...</code> 
direct-non-list-initialized with <code>std::forward&lt;Args&gt;(args)...</code>, respectively. </p></li>
<li><p>(2.3) &mdash; Its call pattern is <code>to&lt;C&gt;(r, bound_args...)</code>, where <code>r</code> is the argument used in a 
function call expression of <code>f</code>.</p></li>
</ol>
<p><ins>
-?- <i>Remarks</i>: The expression <code>to(args...)</code> is well-formed if and only if the initialization of the bound argument entities 
of the result, as specified above, are all well-formed.
</ins></p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3985"><a href="3985">3985</a>. <code>ranges::to</code> should <i>Mandates</i> <code>C</code> not to be view</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a>, 25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-25 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to solve issues in LWG <a href="3787" title="ranges::to's template parameter C should not be a reference type (Status: Resolved)">3787</a> and LWG <a href="3847" title="ranges::to can still return views (Status: C++23)">3847</a> that the template parameter <code>C</code> 
can be specified as an unreasonable type, <code>ranges::to</code> adds a <i>Mandates</i> that requires <code>C</code> to be a 
<i>cv</i>-unqualified class type.
</p>
<p>
However, the earliest requirement that <code>C</code> not be a view was still imposed by the constraints of function signatures,
although it is unclear why <i>Constraints</i> were used in the first place, such a way of kicking out the function candidate 
does bring undesirable hard errors and poor diagnostics (<a href="https://godbolt.org/z/K1f15K71n">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

int main() {
  auto iota = std::views::iota(0, 10);
  auto take = std::ranges::to&lt;std::ranges::take_view&gt;(iota, 5);  // <span style="color:red;font-weight:bolder">hard error in function body</span>
  auto drop = iota | std::ranges::to&lt;std::ranges::drop_view&gt;(5); // <span style="color:red;font-weight:bolder">poor diagnostics</span>
}
</pre></blockquote>
<p>
I think consistent use of <i>Mandates</i> for template parameter <code>C</code> is more appropriate, as <code>static_assert</code> 
provide clearer and more readable diagnostics.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3985"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a> as indicated:</p>

<blockquote>
<pre>
#include &lt;compare&gt;              // <i>see 17.12.1 <a href="https://timsong-cpp.github.io/cppwp/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see 17.11.2 <a href="https://timsong-cpp.github.io/cppwp/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a></i>

namespace std::ranges {
  [&hellip;]
  // <i>25.5.7 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv">[range.utility.conv]</a>, range conversions</i>
  template&lt;class C, input_range R, class... Args&gt; <del>requires (!view&lt;C&gt;)</del>
    constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);                                          // <i>freestanding</i>
  template&lt;template&lt;class...&gt; class C, input_range R, class... Args&gt;
    constexpr auto to(R&amp;&amp; r, Args&amp;&amp;... args);                                       // <i>freestanding</i>
  template&lt;class C, class... Args&gt; <del>requires (!view&lt;C&gt;)</del>
    constexpr auto to(Args&amp;&amp;... args);                                              // <i>freestanding</i>
  template&lt;template&lt;class...&gt; class C, class... Args&gt;
    constexpr auto to(Args&amp;&amp;... args);                                              // <i>freestanding</i>
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>template&lt;class C, input_range R, class... Args&gt; <del>requires (!view&lt;C&gt;)</del>
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>C</code> is a cv-unqualified class type <ins>and does not satisfy <code>view</code></ins>.
</p>
[&hellip;]
</blockquote>
</blockquote>

</li>

<li><p>Modify 25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a> as indicated:</p>

<blockquote>
<pre>template&lt;class C, class... Args&gt; <del>requires (!view&lt;C&gt;)</del>
  constexpr auto to(Args&amp;&amp;... args);
template&lt;template&lt;class...&gt; class C, class... Args&gt;
  constexpr auto to(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: For the first overload, <code>C</code> is a cv-unqualified class type <ins>and does not satisfy <code>view</code></ins>.
</p>
[&hellip;]
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3986"><a href="3986">3986</a>. <code>basic_const_iterator</code> doesn't work with <code>optional</code></h3>
<p><b>Section:</b> 24.5.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators">[const.iterators]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-26 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#const.iterators">active issues</a> in [const.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#const.iterators">issues</a> in [const.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The heterogeneous comparison operators of <code>basic_const_iterator</code> only constrain type <code>I</code> to be 
comparable with the underlying iterator type, which allows non-iterator types such as <code>optional</code>, and 
the heterogeneous comparison operators of the latter would make the situation worse 
(<a href="https://godbolt.org/z/76evPfGnh">demo</a>):
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;optional&gt;
  
int main() {
  std::basic_const_iterator&lt;const int*&gt; it;
  std::optional opt{it};
  auto c = opt &lt; it; // <span style="color:red;font-weight:bolder">infinite meta-recursion</span>
  auto d = it - opt; // <span style="color:red;font-weight:bolder">infinite meta-recursion</span>
}
</pre></blockquote>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-3986"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3988"><a href="3988">3988</a>. Should <code>as_const_view</code> and <code>basic_const_iterator</code> provide <code>base()</code>?</h3>
<p><b>Section:</b> 24.5.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators">[const.iterators]</a>, 25.7.22.2 <a href="https://timsong-cpp.github.io/cppwp/range.as.const.view">[range.as.const.view]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-08-28 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#const.iterators">active issues</a> in [const.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#const.iterators">issues</a> in [const.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, both <code>as_const_view</code> and <code>basic_const_iterator</code> provide <code>base()</code> members to 
return the underlying range and iterator, which seems to expose vulnerabilities in modifying them:
</p>
<blockquote><pre>
#include &lt;vector&gt;
#include &lt;ranges&gt;

int main() {
  std::vector v{1, 2, 3};
  
  auto f = [](std::span&lt;int&gt;::const_iterator i) {
    *i.base() = 4;
  };
  f(std::span{v}.cbegin());

  auto g = [](const std::ranges::constant_range auto&amp; r) {
    r.begin().base()[1] = 5;
    r.base()[2] = 6;
  };
  g(std::ranges::as_const_view(v));

  // v now becomes [4, 5, 6]
}
</pre></blockquote>
<p>
I don't think such a shortcut should be provided as it doesn't seem to be the intention and could be harmful.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Send to SG9.
</p>

<p><i>[Kona 2023-11-07; move to Ready]</i></p>


<p><i>[2024-03-15; move back to Open following LEWG feedback]</i></p>


<p>
SG9 approved the proposed change but then LEWG had no consensus for change.
LWG should revisit in Tokyo.
</p>



<p id="res-3988"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 24.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.iterator">[const.iterators.iterator]</a>, class template <code>basic_const_iterator</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]

  template&lt;input_iterator Iterator&gt;
  class basic_const_iterator {
    [&hellip;]
    <del>constexpr const Iterator&amp; base() const &amp; noexcept;</del>
    <del>constexpr Iterator base() &amp;&amp;;</del>
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.ops">[const.iterators.ops]</a> as indicated:</p>

<blockquote>
<pre>
<del>constexpr const Iterator&amp; base() const &amp; noexcept;</del>
</pre>
<blockquote>
<p>
<del>-4- <i>Effects</i>: Equivalent to: <code>return <i>current_</i>;</code></del>
</p>
</blockquote>
<pre>
<del>constexpr Iterator base() &amp;&amp;;</del>
</pre>
<blockquote>
<p>
<del>-5- <i>Effects</i>: Equivalent to: <code>return std::move(<i>current_</i>);</code></del>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 25.7.22.2 <a href="https://timsong-cpp.github.io/cppwp/range.as.const.view">[range.as.const.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class as_const_view : public view_interface&lt;as_const_view&lt;V&gt;&gt; {
    [&hellip;]
    <del>constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return <i>base_</i>; }</del>
    <del>constexpr V base() &amp;&amp; { return std::move(<i>base_</i>); }</del>
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3989"><a href="3989">3989</a>. The whole range for an iterator obtained from a <code>std::span</code> or <code>std::basic_string_view</code> is not clear</h3>
<p><b>Section:</b> 27.3 <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a>, 23.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/views.span">[views.span]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-08-29 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.view">active issues</a> in [string.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view">issues</a> in [string.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear whether the following program has undefined behavior:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;span&gt;
#include &lt;string_view&gt;

int main()
{
  int arr[2]{42, 84};
  std::span&lt;int&gt; sp1{arr, 1};
  std::span&lt;int&gt; sp2{arr + 1, 1};

  assert(sp2.begin() - sp1.begin() == 1); // Is this well-defined?
  assert(sp2.begin() == sp1.end());       // ditto
  assert(*sp1.end() == 84);               // ditto

  const char str[]{"string"};
  std::string_view sv1{str, 3};
  std::string_view sv2{str + 3, 3};

  assert(sv2.begin() - sv1.begin() == 3); // Is this well-defined?
  assert(sv2.begin() == sv1.end());       // ditto
  assert(*sv1.end() == 'i');              // ditto
}
</pre></blockquote>
<p>
Currently MSVC STL strictly diagnose the arithmetic between different <code>span</code>s/<code>basic_string_view</code>s, 
even the views are on the same underlying range (see <a href="https://github.com/microsoft/STL/issues/1435">this Github issue</a>). 
libstdc++ and libc++ silently accept these operations.
<p/>
Perhaps the standard should clarify what the whole ranges are when determining whether operations between iterators 
from different views on the same underlying range is well-defined.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Libc++ diagnoses the example with the right macros defined.
"Should <code>substr</code> and <code>remove_suffix</code> tighten the
bounds or copy them from the original view?"
</p>



<p id="res-3989"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3991"><a href="3991">3991</a>. <code>variant</code>'s move assignment should not be guaranteed to produce a valueless by exception state</h3>
<p><b>Section:</b> 22.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.assign">[variant.assign]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Bi <b>Opened:</b> 2023-08-29 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#variant.assign">active issues</a> in [variant.assign].</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.assign">issues</a> in [variant.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.assign">[variant.assign]</a> bullet 8.4 states that an alternative-changing move assignment on <code>std::variant</code> 
is equivalent to a call to <code>emplace</code>. However, bullet 10.1 also states that if the construction of the new 
alternative exits via an exception, then the destination of the assignment is guaranteed to become valueless 
by exception. This is inconsistent with the specification of <code>emplace</code>, 22.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a>/11, 
which permits (but does not require) the variant to become valueless.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"The remark is normatively redundant with the spec of <code>emplace</code>,
strike it."
</p>



<p id="res-3991"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 22.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/variant.assign">[variant.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr variant&amp; operator=(variant&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-6- Let <code><i>j</i></code> be <code>rhs.index()</code>.
<p/>
[&hellip;]
<p/>
-8- <i>Effects</i>:
</p>
<ol style="list-style-type:none">
<li><p>(8.1) &mdash; If neither <code>*this</code> nor <code>rhs</code> holds a value, there is no effect.</p></li>
<li><p>(8.2) &mdash; Otherwise, if <code>*this</code> holds a value but <code>rhs</code> does not, destroys the value 
contained in <code>*this</code> and sets <code>*this</code> to not hold a value.</p></li>
<li><p>(8.3) &mdash; Otherwise, if <code>index() == <i>j</i></code>, assigns <code>get&lt;<i>j</i>&gt;(std::move(rhs))</code> 
to the value contained in <code>*this</code>.</p></li>
<li><p>(8.4) &mdash; Otherwise, equivalent to <code>emplace&lt;<i>j</i>&gt;(get&lt;<i>j</i>&gt;(std::move(rhs)))</code>.</p></li>
</ol>
<p>
[&hellip;]
<p/>
-10- <i>Remarks:</i> [&hellip;]
</p>
<ol style="list-style-type:none">
<li><p><del>(10.1) &mdash; If an exception is thrown during the call to <code>T<sub><i>j</i></sub></code>'s move construction 
(with <code><i>j</i></code> being <code>rhs.index()</code>), the <code>variant</code> will hold no value.</del></p></li>
<li><p><del>(10.2) &mdash;</del> If an exception is thrown during the call to <code>T<sub><i>j</i></sub></code>'s move assignment, 
the state of the contained value is as defined by the exception safety guarantee of <code>T<sub><i>j</i></sub></code>'s move 
assignment; <code>index()</code> will be <code><i>j</i></code>.</p></li>
</ol>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3992"><a href="3992">3992</a>. <code>basic_stringbuf::str()&amp;&amp;</code> should enforce &#x1d4aa;(1)</h3>
<p><b>Section:</b> 31.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.members">[stringbuf.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2023-10-05 <b>Last modified:</b> 2023-10-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#stringbuf.members">issues</a> in [stringbuf.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Recent discussions on <a href="https://github.com/llvm/llvm-project/issues/64644">llvm-64644</a>
came to the conclusion that <code>basic_stringbuf() &amp;&amp;</code> introduced by <a href="https://wg21.link/P0408" title=" Efficient Access to basic_stringbufs Buffer">P0408</a>
might just copy the underlying buffer into a string object and not actually move the allocated space. 
While the wording tried to encourage that, especially with the postcondition that the buffer must 
be empty afterwards, it failed to specify that the move is never a copy.
<p/>
I suggest to amend the specification to enforce implementors to do the <code>&#x1d4aa;(1)</code> thing. 
There might be ABI issues for those who still copy.
<p/>
Some investigation into 23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a> p.16 and 27.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/basic.string.general">[basic.string.general]</a> 
shows that a <code>basic_string</code> as a standard container should move with <code>&#x1d4aa;(1)</code>.
<p/>
Unfortunately, we cannot say
</p>
<blockquote><p>
<ins><code>str().data() == buf.data()</code> before calling <code>str()</code></ins>
</p></blockquote>
<p>
as a postcondition due to SSO. Maybe a note could be added to eliminate the confusion.
</p>


<p id="res-3992"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 31.8.2.4 <a href="https://timsong-cpp.github.io/cppwp/stringbuf.members">[stringbuf.members]</a> as indicated:</p>

<blockquote>
<pre>
basic_string&lt;charT, traits, Allocator&gt; str() &amp;&amp;;
</pre>
<blockquote>
<p>
-9- <i>Postconditions</i>: The underlying character sequence <code>buf</code> is empty and <code>pbase()</code>, <code>pptr()</code>, 
<code>epptr()</code>, <code>eback()</code>, <code>gptr()</code>, and <code>egptr()</code> are initialized as if by calling 
<code>init_buf_ptrs()</code> with an empty <code>buf</code>.
<p/>
-10- <i>Returns</i>: A <code>basic_string&lt;charT, traits, Allocator&gt;</code> object move constructed from the 
<code>basic_stringbuf</code>'s underlying character sequence in <code>buf</code>. This can be achieved by first adjusting <code>buf</code> 
to have the same content as <code>view()</code>.
<p/>
<ins>[<i>Note:</i> &mdash; 23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a> require the move construction of the return
value to be <code>&#x1d4aa;(1)</code> <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="3993"><a href="3993">3993</a>. The <code>parse</code> function of a <i>BasicFormatter</i> type needs to be <code>constexpr</code></h3>
<p><b>Section:</b> 28.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/formatter.requirements">[formatter.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-10-10 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#formatter.requirements">issues</a> in [formatter.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Format strings need to be checkable at compile-time since <a href="https://wg21.link/P2216R3" title=" std::format improvements">P2216R3</a>. In order to check a 
compile-time format string, the <code>parse</code> functions of the formatters need to be called. However, 
currently there is seemingly no requirement for the <code>parse</code> function to be <code>constexpr</code>, 
and hence whether a format string is correct for formatted types may be not well-defined at compile-time.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Should be OK to provide a non-constexpr <code>parse</code> if you only use it
with <code>std::vformat</code> and not <code>std::format</code>."
"Only the <code>std::formatter</code> specializations in the standard library
should be required to have constexpr <code>parse</code>."
"No need to require this, but a note with this text explaining when a call
to <code>parse</code> can be a constant expression might be nice."
</p>



<p id="res-3993"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4958" title=" Working Draft, Programming Languages  C++">N4958</a>.
</p>

<ol>

<li><p>Modify 28.5.6.1 <a href="https://timsong-cpp.github.io/cppwp/formatter.requirements">[formatter.requirements]</a>, Table 73, <i>BasicFormatter</i> requirements [tab:formatter.basic] as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 73: <i>BasicFormatter</i> requirements [tab:formatter.basic]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<code>g.parse(pc)</code>
</td>
<td>
<code>PC::iterator</code>
</td>
<td>
Parses <i>format-spec</i> (28.5.2 <a href="https://timsong-cpp.github.io/cppwp/format.string">[format.string]</a>) for type <code>T</code> in the<br/>
range <code>[pc.begin(), pc.end())</code> until the first unmatched<br/>
character. Throws <code>format_error</code> unless<br/>
the whole range is parsed or the unmatched<br/>
character is <code>}</code>.<br/>
[<i>Note 1</i>: This allows formatters to emit meaningful<br/>
error messages. &mdash; <i>end note</i>]<br/>
Stores the parsed format specifiers in <code>*this</code> and<br/>
returns an iterator past the end of the parsed<br/>
range.
<ins>The expression shall be a core constant expression if <code>g</code>,<br/>
<code>pc.begin()</code>, <code>pc.end()</code>, and lvalue-to-rvalue conversion<br/>
for each element in <code>[pc.begin(), pc.end())</code> are core constant<br/>
expressions, and no exception is thrown.</ins>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<code>&hellip;</code>
</td>
</tr>

</table>
</blockquote>


</li>

</ol>





<hr>
<h3 id="3994"><a href="3994">3994</a>. <code>adaptor(args...)(r)</code> is not equivalent to <code>std::bind_back(adaptor, args...)(r)</code></h3>
<p><b>Section:</b> 25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-11 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.adaptor.object">active issues</a> in [range.adaptor.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.adaptor.object">issues</a> in [range.adaptor.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> p8 specifies that:
</p>
<blockquote><p> 
The expression <code>adaptor(args...)</code> produces a range adaptor closure object <code>f</code> that is a perfect forwarding 
call wrapper (22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>) with the following properties:
</p></blockquote>
<p>
According to the subsequent description, it can be inferred that the behavior is similar to 
<code>std::bind_back(adaptor, args...)</code> which also returns a perfect forwarding call wrapper.
<p/>
Among them, "A <i>perfect forwarding call wrapper</i> is an argument forwarding call wrapper 
that forwards its state entities to the underlying call expression" according to <a href="https://wg21.link/func.require">[func.require]</a>/4, and call wrapper in <a href="https://wg21.link/func.require">[func.require]</a>/3 is described as:
</p>
<blockquote><p>
Every call wrapper (22.10.3 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a>) meets the <i>Cpp17MoveConstructible</i> and <i>Cpp17Destructible</i> requirements.
</p></blockquote>
<p>
In order to conform with the specification, standard functions that return perfect forwarding call wrappers such as 
<code>std::bind_front/back</code> and <code>std::not_fn</code> all <i>Mandates</i> that 
<code>(is_constructible_v&lt;BoundArgs, Args&gt; &amp;&amp; ...)</code> and 
<code>(is_move_constructible_v&lt;BoundArgs&gt; &amp;&amp; ...)</code> are each <code>true</code>, 
the former condition corresponds to 25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a> p8:
</p>
<blockquote><p>
The expression <code>adaptor(args...)</code> is well-formed if and only if the initialization of the bound argument 
entities of the result, as specified above, are all well-formed.
</p></blockquote>
<p>
However, the latter does not have a corresponding description in <code>&lt;ranges&gt;</code>. In other words, range 
adaptor objects do not explicitly indicate that the bound argument must be move-constructible.
This results in implementation divergence for some uncommon types (<a href="https://godbolt.org/z/r6Gq8W6qe">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;string_view&gt;

constexpr struct WeirdFive {
  WeirdFive() = default;
  WeirdFive(const WeirdFive&amp;) = default;
  constexpr operator int() const { return 5; }

  WeirdFive(WeirdFive&amp;&amp;) = delete;
} five;

constexpr std::string_view sv{"hello"};
static_assert(sv == std::views::take(five)(sv)); // <span style="color:red;font-weight:bolder">libstdc++/libc++ reject, MSVC-STL accepts</span>
</pre></blockquote>
<p>
Above, libstdc++ always moves arguments into internal members, which leads to hard errors in the member initializer list;
libc++ uses <code>std::bind_back</code> for argument binding, which also leads to hard errors in the function body as the 
former requires arguments to be move-constructible; MSVC-STL is the most compliant with current wording.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3994"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3995"><a href="3995">3995</a>. Issue with custom index conversion in <code>&lt;mdspan&gt;</code></h3>
<p><b>Section:</b> 23.7.3 <a href="https://timsong-cpp.github.io/cppwp/views.multidim">[views.multidim]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-11 <b>Last modified:</b> 2023-10-30</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>std::layout_<i>meow</i>::mapping::operator()</code> has the following definition (23.7.3.4.5.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.obs">[mdspan.layout.left.obs]</a>):
</p>
<blockquote>
<pre>
template&lt;class... Indices&gt;
  constexpr index_type operator()(Indices... i) const noexcept;</pre>
<blockquote>
<p>
-2- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code>sizeof...(Indices) == extents_type::rank()</code> is <code>true</code>,</p></li>
<li><p>(2.2) &mdash; <code>(is_convertible_v&lt;Indices, index_type&gt; &amp;&amp; ...)</code> is <code>true</code>, and</p></li>
<li><p>(2.3) &mdash; <code>(is_nothrow_constructible_v&lt;index_type, Indices&gt; &amp;&amp; ...)</code> is <code>true</code>.</p></li>       
</ol>
<p>
<i>Preconditions</i>: <code>extents_type::<i>index-cast</i>(i)</code> is a multidimensional index in <code><i>extents_</i></code> 
(23.7.3.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.overview">[mdspan.overview]</a>).
<p/>
<i>Effects</i>: Let <code>P</code> be a parameter pack such that
</p>
<blockquote><pre>
is_same_v&lt;index_sequence_for&lt;Indices...&gt;, index_sequence&lt;P...&gt;&gt;
</pre></blockquote>
<p>  
is <code>true</code>. Equivalent to:
</p>
<blockquote><pre>
return ((static_cast&lt;index_type&gt;(i) * stride(P)) + ... + 0);
</pre></blockquote>
</blockquote>
</blockquote>
<p>
Above, <code>is_convertible_v&lt;Indices, index_type&gt;</code> implies that <code>index_type</code> can be constructed through 
rvalue-qualified conversion operators. However, we cast the lvalue <code>i</code> in the return statement, which makes the 
expression possibly ill-formed. The same goes for <code>extents_type::<i>index-cast(i)</i></code>.
</p>
<p>
However, if we use <code>std::move</code> before casting, this will result in the rvalue-qualified conversion operator 
being called in <i>Preconditions</i> via <code>extents_type::<i>index-cast(i)</i></code> before the mapping index is actually calculated,
so that the expression may no longer be valid. And such an issue already exists in <code>mdspan::operator[]</code>.
</p>
<p>
In addition, the variadic version of <code>mdspan::operator[]</code> constraints 
<code>is_convertible_v&lt;OtherIndexTypes, index_type&gt;</code>, but its <code>array</code>/<code>span</code> version constraints 
<code>is_convertible_v&lt;const OtherIndexType&amp;, index_type&gt;</code>.
<p/>
This seems to bring inconsistency as <code>mdspan[arr]</code> may not necessarily guarantee <code>mdspan[arr[i]...]</code>.
</p>
<p>
I think we should unanimously require that custom indexes can be converted to <code>index_type</code> via <code>const</code> 
lvalue references, which eliminates the worry of conversion expiration.
</p>

<p><i>[2023-10-30; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"P4 - doesn't affect 'normal' uses of custom index types.
Only affects expert users that interface with the mapping directly,
because <code>mdspan</code> does the conversions."
</p>



<p id="res-3995"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3997"><a href="3997">3997</a>. <code>std::formatter</code> specializations should be consistently restricted to supported character types</h3>
<p><b>Section:</b> 28.5.1 <a href="https://timsong-cpp.github.io/cppwp/format.syn">[format.syn]</a>, 30.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>, 32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-10-15 <b>Last modified:</b> 2023-11-04</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.syn">active issues</a> in [format.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.syn">issues</a> in [format.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a>/2 requires some <code>std::formatter</code> specializations are only enabled 
for character types <code>char</code> and <code>wchar_t</code>. But for specializations that are explicitly shown in 
the synopses (28.5.1 <a href="https://timsong-cpp.github.io/cppwp/format.syn">[format.syn]</a>, 30.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a>, and 32.4.3.2 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.id">[thread.thread.id]</a>), 
there is no such restrictions for <code>charT</code>. The difference may be observable via the <code>std::formattable</code> 
concept, e.g. <code>std::formattable&lt;std::chrono::second, char8_t&gt;</code> is currently satisfied, even though 
there would be a hard error during formatting due to <code><i>STATICALLY-WIDEN</i></code>.
<p/>
Perhaps we should introduce an exposition-only concept that is only satisfied (and modeled) by <code>char</code> and 
<code>wchar_t</code> for now, and constrain the <code>charT</code> template parameter of all <code>std::formatter</code> 
specializations that are explicitly mentioned in synopses with that concept. This is what libc++ currently 
implements (e.g. the 
<a href="https://github.com/llvm/llvm-project/blob/6dfea561ba96974b205c31546c5e2069429c75b1/libcxx/include/__format/concepts.h#L32-L38"><code>__fmt_char_type</code></a> 
concept and <a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__chrono/formatter.h#L580-L825">its 
usage in <code>&lt;chrono&gt;</code></a>).
</p>

<p><i>[2023-11-03; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"Problem looks theoretical, all entry points to formatters are constrained."
</p>



<p id="res-3997"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3998"><a href="3998">3998</a>. Constants in <code>std::regex_constants</code> should be allowed to be enumerators</h3>
<p><b>Section:</b> 28.6.4 <a href="https://timsong-cpp.github.io/cppwp/re.const">[re.const]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-10-18 <b>Last modified:</b> 2024-02-22</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.const">issues</a> in [re.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, MSVC STL and libc++ implement constants in <code>std::regex_constants</code> as 
enumerators of unscoped enumerations, while the standard specify them to be <code>constexpr</code> variables.
<p/>
<a href="https://github.com/microsoft/STL/issues/4100#issuecomment-1767717721">Casey Carter argued</a> 
that it would be better to make these constants prvalues to avoid wasting space in object files. And 
presumably almost all users just use their values without odr-using them or relying on their value category.
<p/>
Perhaps we should allow these constants to be enumerators of the corresponding type (<code>syntax_option_type</code>, 
<code>match_flag_type</code>, or <code>error_type</code>) if the corresponding type is an enumeration.
<p/>
Notes: since C++20, we can even make the enumeration types scoped and expose the enumerators to the 
namespace by using-declaration or using-enum-declaration. <a href="https://wg21.link/P0439R0" title=" Make memory_order a scoped enumeration">P0439R0</a> might be related, 
since it changed former enumerators to <code>constexpr</code> variables.
</p>

<p><i>[2024-02-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll in October 2023.
</p>
<p><i>[Jonathan commented]</i></p>

<p>
"Why only change the <code class='backtick'>regex_constants</code> bitmask constants,
and not those for <code>ctype_base::mask</code>,
<code>ios_base::fmtflags</code>, <code>ios_base::iostate</code>,
and <code>ios_base::openmode</code>?"
</p>



<p id="res-3998"><b>Proposed resolution:</b></p>





<hr>
<h3 id="3999"><a href="3999">3999</a>. P0439R0 changed the value category of memory order constants</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-10-18 <b>Last modified:</b> 2023-11-03</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P0439R0" title=" Make memory_order a scoped enumeration">P0439R0</a> made <code>std::memory_order</code> an scoped enumeration type. However, it also 
changed former enumerators (<code>std::memory_order_seq_cst</code>) to <code>constexpr</code> variables.
<p/>
It is unclear the additional change is intended while it presumably bothered nobody in practice. 
Given there is <code>using enum</code> (<a href="https://wg21.link/P1099R5" title=" Using Enum">P1099R5</a>) in C++20, it may be better to keep 
these constants being prvalues.
</p>

<p><i>[2023-11-02; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-3999"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 32.5.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.syn">[atomics.syn]</a>, header <code>&lt;atomic&gt;</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  // <i>32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>, order and consistency</i>
  enum class memory_order : <i>unspecified</i>;                        // <i>freestanding</i>
  <del>inline constexpr memory_order memory_order_relaxed = memory_order::relaxed</del><ins>using memory_order::memory_order_relaxed</ins>; // <i>freestanding</i>
  <del>inline constexpr memory_order memory_order_consume = memory_order::consume</del><ins>using memory_order::memory_order_consume</ins>; // <i>freestanding</i>
  <del>inline constexpr memory_order memory_order_acquire = memory_order::acquire</del><ins>using memory_order::memory_order_acquire</ins>; // <i>freestanding</i>
  <del>inline constexpr memory_order memory_order_release = memory_order::release</del><ins>using memory_order::memory_order_release</ins>; // <i>freestanding</i>
  <del>inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel</del><ins>using memory_order::memory_order_acq_rel</ins>; // <i>freestanding</i>
  <del>inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst</del><ins>using memory_order::memory_order_seq_cst</ins>; // <i>freestanding</i>
  
  [&hellip;]
}
[&hellip;]
</pre></blockquote>

</li>

<li><p>Modify 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> as indicated:</p>

<blockquote><pre>
namespace std {
  enum class memory_order : <i>unspecified</i> {
    relaxed, consume, acquire, release, acq_rel, seq_cst<ins>,
    memory_order_relaxed = relaxed, memory_order_consume = consume, memory_order_acquire = acquire,
    memory_order_release = release, memory_order_acq_rel = acq_rel, memory_order_seq_cst = seq_cst</ins>
  };
}</pre></blockquote>

</li>

</ol>





<hr>
<h3 id="4000"><a href="4000">4000</a>. <code>flat_map::insert_range</code>'s <i>Effects</i> is not quite right</h3>
<p><b>Section:</b> 23.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.modifiers">[flat.map.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-23 <b>Last modified:</b> 2025-09-05</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#flat.map.modifiers">active issues</a> in [flat.map.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map.modifiers">issues</a> in [flat.map.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>flat_map::insert_range</code> adds elements to the <code>containers</code> member via:
</p>
<blockquote><pre>
for (const auto&amp; e : rg) {
  c.keys.insert(c.keys.end(), e.first);
  c.values.insert(c.values.end(), e.second);
}
</pre></blockquote>
<p>
which is incorrect because <code>rg</code>'s value type may not be a <code>pair</code> (<code>tuple</code>, for instance), 
which means that <code>.first</code> and <code>.second</code> are not valid in such cases.
</p>

<p><i>[2024-02-22; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll in October 2023.
</p>

<p>
"This is <a href="https://wg21.link/P2767" title=" flat_map/flat_set omnibus">P2767</a> section 6 which LWG looked at in Varna."
</p>

<p><i>[2025-09-05; LWG telecon]</i></p>

<p>This will be resolved by <a href="https://wg21.link/P3567" title=" `flat_meow` Fixes">P3567</a>.</p>



<p id="res-4000"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 23.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.modifiers">[flat.map.modifiers]</a> as indicated:</p>

<blockquote><pre>
template&lt;<i>container-compatible-range</i>&lt;value_type&gt; R&gt;
  void insert_range(R&amp;&amp; rg);
</pre>
<blockquote>
<p>
-12- <i>Effects</i>: Adds elements to <code>c</code> as if by:
</p>
<blockquote><pre>
for (<ins>value_type</ins><del>const auto&amp;</del> e : rg) {
  c.keys.insert(c.keys.end(), <ins>std::move(</ins>e.first<ins>)</ins>);
  c.values.insert(c.values.end(), <ins>std::move(</ins>e.second<ins>)</ins>);
}
</pre></blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4002"><a href="4002">4002</a>. The definition of <code>iota_view::<i>iterator</i>::iterator_concept</code> should be improved</h3>
<p><b>Section:</b> 25.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.iota.iterator">[range.iota.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-10-27 <b>Last modified:</b> 2023-11-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.iota.iterator">active issues</a> in [range.iota.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.iota.iterator">issues</a> in [range.iota.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <code>W</code> models <code>incrementable</code>, the <code>iota_view</code> iterator will be a <code>forward_iterator</code>, 
which accidentally makes <code>iota_view&lt;istream_iterator&lt;int&gt;&gt;</code> satisfies <code>forward_range</code>, 
which is obviously incorrect.
<p/>
Since iterator types are well within the domain of <code>W</code>, it seems more appropriate and accurate to define 
the <code>iterator_concept</code> through the iterator concept in this case.
</p>

<p><i>[2023-11-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"This would change the iterator concept for types which model <code>advanceable</code> but do not model <code>random_access_iterator</code>. A type with +=
and -= and operator* will currently get <code>random_access_iterator_tag</code>
but this proposed resolution would change it to <code>bidirectional_iterator_tag</code>."
"If we want to handle this case (and not leave it as IFNDR - the type
satisfies-but-not-models <code>incrementable</code>) then we need to account
for it everywhere we are currently using <code>incrementable</code>
(and possibly <code>equality_comparable</code>?), and not just in the concept."
</p>



<p id="res-4002"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.6.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.iota.iterator">[range.iota.iterator]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: When <code>W</code> only models <code>input_or_output_iterator</code>, it implies that its 
pre- and post-increment are not equality-preserving, so <code>iterator_concept</code> should be <code>input_iterator_tag</code>.]
</p>
</blockquote>

<blockquote>
<p>
-1- <code><i>iterator</i>::iterator_concept</code> is defined as follows:
</p>
<ol style="list-style-type: none">
<li><p>(?.?) <ins>&mdash; If <code>W</code> models <code>input_or_output_iterator</code>, then</ins></p>
<ol style="list-style-type: none">
<li><p>(?.?) <ins>&mdash; if <code>W</code> models <code>random_access_iterator</code>, then <code>iterator_concept</code> is 
<code>random_access_iterator_tag</code>;</ins></p></li>
<li><p>(?.?) <ins>&mdash; otherwise, if <code>W</code> models <code>bidirectional_iterator</code>, then <code>iterator_concept</code> 
is <code>bidirectional_iterator_tag</code>;</ins></p></li>
<li><p>(?.?) <ins>&mdash; otherwise, if <code>W</code> models <code>forward_iterator</code>, then <code>iterator_concept</code> 
is <code>forward_iterator_tag</code>;</ins></p></li>
<li><p>(?.?) <ins>&mdash; otherwise, <code>iterator_concept</code> is <code>input_iterator_tag</code>.</ins></p></li>
</ol>
</li>
<li><p>(1.1) &mdash; <ins>Otherwise, i</ins><del>I</del>f <code>W</code> models <code><i>advanceable</i></code>, then 
<code>iterator_concept</code> is <code>random_access_iterator_tag</code>.</p></li>
<li><p>(1.2) &mdash; Otherwise, if <code>W</code> models <code><i>decrementable</i></code>, then <code>iterator_concept</code> is 
<code>bidirectional_iterator_tag</code>.</p></li>
<li><p>(1.3) &mdash; Otherwise, if <code>W</code> models <code>incrementable</code>, then <code>iterator_concept</code> is 
<code>forward_iterator_tag</code>.</p></li>
<li><p>(1.4) &mdash; Otherwise, <code>iterator_concept</code> is <code>input_iterator_tag</code>.</p></li>
</ol>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4004"><a href="4004">4004</a>. The load and store operation in &sect;[atomics.order] p1 is ambiguous</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2023-10-30 <b>Last modified:</b> 2024-05-19</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p1 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<ol style="list-style-type: none">
<li><p>(1.2) &mdash; <code>memory_order::release</code>, <code>memory_order::acq_rel</code>, and <code>memory_order::seq_cst</code>: a store operation 
performs a release operation on the affected memory location.</p></li>
<li><p>(1.3) &mdash; <code>memory_order::consume</code>: a load operation performs a consume operation on the affected memory location. 
[&hellip;]</p></li>
<li><p>(1.4) &mdash; <code>memory_order::acquire</code>, <code>memory_order::acq_rel</code>, and <code>memory_order::seq_cst</code>: a 
load operation performs an acquire operation on the affected memory location.</p></li>
</ol>
</blockquote>
<p>
What do the store and load operations intend to mean in this context? If there is no extra specification, 
it is easy to consider them as the operations performed by the non-static member functions "store" and "load" 
defined in the <code>atomic</code> class (template).
<p/>
32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p2 says
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
An atomic operation <i>A</i> that performs a release operation on an atomic object <i>M</i> synchronizes with 
an atomic operation <i>B</i> that performs an acquire operation on <i>M</i> and takes its value from any side 
effect in the release sequence headed by <i>A</i>.
</p>
</blockquote>
<p>
According to the above interpretation, <i>A</i> is an operation performed by the non-static member function 
<code>store</code>, however, I think the following example can establish the synchronization relationship
</p>
<blockquote><pre>
std::atomic&lt;int&gt; x{0};

Thread 1:
int expected = 0;
x.compare_exchange_strong(expected, 1, memory_order::release, memory_order::relaxed); // #1

Thread 2:
int expected = 1;
while(x.compare_exchange_strong(expected, 2, memory_order::acquire, memory_order::relaxed)){} // #2
</pre></blockquote>
<p>
Assuming the RMW operations are successful in the two threads, I think <code>#1</code> intends to perform a 
release operation while <code>#2</code> performs an acquire operation, and hence they can establish the 
synchronization relationship, however, they both are RMW operations.
<p/>
It should be clearly defined which are store operations and which are load operations. 
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll in November 2023. Ask SG1 to look.
</p>
<p>
Jonathan:
"Interpreting this to only mean the <code>store</code> and <code>load</code>
member functions wouldn't even be self-consistent. Could be clearer though,
6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a> talks about reads and writes (and RMW ops)
and only uses "store" and "load" informally. Maybe just add something saying
"reads are also called loads and writes are also called stores".
</p>

<p><i>[2024-05-15; jim x comments and expands the discussion]</i></p>

<p>
This is an addition to this issue, consider this example:
</p>
<blockquote><pre>
std::atomic&lt;int&gt; x{0};

Thread 1:
int expected = 0;
x.compare_exchange_strong(expected, 1, memory_order::acq_rel, memory_order::relaxed); // #1

Thread 2:
int expected = 1;
while(x. compare_exchange_strong(expected, 2, memory_order::acq_rel, memory_order::relaxed)){} // #2
</pre></blockquote>
<p>
<code>memory_order::acq_rel</code> performs a release operation when the operation is a store and is 
an acquire operation when the operation is a load. It is unclear what operations <code>#1</code> and 
<code>#2</code> are considered when they succeed, as pointed out in the original issue, we still don't 
specify whether RMW is classified as load or store operation or can be both.
<p/>
We should specify how the <code>success</code> order affects the RMW when it is viewed as a load or store 
operation.
</p>


<p id="res-4004"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4005"><a href="4005">4005</a>. "Required behavior" too narrowly defined</h3>
<p><b>Section:</b> 3.48 <a href="https://timsong-cpp.github.io/cppwp/defns.required.behavior">[defns.required.behavior]</a>, 16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a>, 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2023-11-03 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library's definition of the term "required behavior" (3.48 <a href="https://timsong-cpp.github.io/cppwp/defns.required.behavior">[defns.required.behavior]</a>) makes it specific to 
certain replaceable functions such as the replaceable global allocation functions. Notably, it is not one of the elements 
that are allowed to appear in the descriptions of general function semantics. That is, it isn't in the list in 
16.3.2.4 <a href="https://timsong-cpp.github.io/cppwp/structure.specifications">[structure.specifications]</a> p3.
<p/>
However, the specification of the random number generator library uses "Required behavior" as such a descriptive element 
of its functions' semantics (e.g., 29.5.6 <a href="https://timsong-cpp.github.io/cppwp/rand.predef">[rand.predef]</a>).
<p/>
I think that's a fine use of "Required behavior", so I would like the term to be more generally applicable to the behavior 
of any stdlib function that may be customized by users. This is relevant for <code>std::execution</code>, where algorithms are 
customizable but the customizations are required to behave a certain way. 
<p/>
<b>Daniel:</b>
<p/>
Bullet (2.4) of 16.4.5.8 <a href="https://timsong-cpp.github.io/cppwp/res.on.functions">[res.on.functions]</a> also contradicts to the more narrow definition of 
3.48 <a href="https://timsong-cpp.github.io/cppwp/defns.required.behavior">[defns.required.behavior]</a> by suddenly extending it to "destructor operations".
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><i>[2024-06-24; The approval of <a href="https://wg21.link/P2810R4" title=" is_debugger_present is_replaceable">P2810R4</a> means that
"required behavior" is now being incorrectly used in the working paper.]</i></p>



<p id="res-4005"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4007"><a href="4007">4007</a>. Mystic prohibition of calling a <code>volatile</code>-qualified perfect forwarding call wrapper</h3>
<p><b>Section:</b> 22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-11-05 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.require">active issues</a> in [func.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.require">issues</a> in [func.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a>/4 says:
</p>
<blockquote><p>
[&hellip;] This forwarding step delivers a state entity of type <code>T</code> as <i>cv</i> <code>T&amp;</code> 
when the call is performed on an lvalue of the call wrapper type and as <i>cv</i> <code>T&amp;&amp;</code> 
otherwise, where <i>cv</i> represents the cv-qualifiers of the call wrapper and where <i>cv</i> shall 
be neither <code>volatile</code> nor <code>const volatile</code>.
</p></blockquote>
<p>
The "shall" seemingly indicates a requirement for user codes that calling a volatile perfect forwarding 
call wrapper is undefined behavior. Such requirement seems to be combined with requirements for 
implementations in an unusual way.
<p/>
Moreover, it is unclear whether UB is intended here. Perhaps we only want calling such a <code>volatile</code> 
wrapper to be conditionally-supported. E.g. when the <code>operator()</code> happens to be implementable as a 
static member function, calling a <code>volatile</code> wrapper can be naturally supported and have expected 
behavior.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
LWG <a href="2487" title="bind() should be const-overloaded, not cv-overloaded (Status: C++17)">2487</a> doesn't seem to intend to forbid <code>volatile</code>
support as a conforming extension.
</p>
<p>
<a href="https://wg21.link/P1065R2" title=" constexpr INVOKE">P1065R2</a> made it ill-formed for <code>std::bind</code> but didn't
make the same change to the definition of perfect forwarding call wrapper.
So given an <code class='backtick'>as_volatile</code> function that works like <code class='backtick'>std::as_const</code>,
<code>as_volatile(std::bind(&amp;T::fn))(t)</code> is ill-formed but
<code>as_volatile(std::mem_fn(&amp;T::fn))(t)</code> is undefined.
Supporting it as a conforming extension is fine, but making it UB is not.
Maybe "conditionally supported" instead?
</p>



<p id="res-4007"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a> as indicated:</p>

<blockquote>
<p>
4 A <i>perfect forwarding call wrapper</i> is an argument forwarding call wrapper that forwards its state entities
to the underlying call expression. This forwarding step delivers a state entity of type <code>T</code> as 
<i>cv</i> <code>T&amp;</code> when the call is performed on an lvalue of the call wrapper type and as <i>cv</i> 
<code>T&amp;&amp;</code> otherwise, where <i>cv</i> represents the cv-qualifiers of the call wrapper <del>and where 
<i>cv</i> shall be neither <code>volatile</code> nor <code>const volatile</code></del><ins>, except that if <i>cv</i> 
is either <code>volatile</code> or <code>const volatile</code>, it is unspecified whether the call is well-formed</ins>.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4008"><a href="4008">4008</a>. &sect;[range.utility.conv.to] <code>ranges::to</code> may cause infinite recursion if <code>range_value_t&lt;C&gt;</code> 
is a non-move-constructible range</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2023-11-08 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a>/2 says:
</p>
<blockquote>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>C</code> does not satisfy <code>input_range</code> or 
<code>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
</ol></li>
<li><p>(2.2) &mdash; Otherwise, if <code>input_range&lt;range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:
</p>
<blockquote>
<pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre>
</blockquote>
</li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
<p>
That is, if <code>range_reference_t&lt;R&gt;</code> is not convertible to <code>range_value_t&lt;C&gt;</code>, and 
<code>range_reference_t&lt;R&gt;</code> is an input range, <code>views::transform</code> is applied to convert the 
inner range to <code>range_value_t&lt;C&gt;</code> (through <code>to&lt;range_value_t&lt;C&gt;&gt;</code>), and then 
the transformed range is converted to <code>C</code> (through <code>to&lt;C&gt;</code>).
<p/>
Consider:
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct ImmovableRange {
  ImmovableRange(int*, int*);
  ImmovableRange(ImmovableRange&amp;&amp;) = delete;

  int* begin();
  int* end();
};

struct C {
  ImmovableRange* begin();
  ImmovableRange* end();
};

using R = int[1][2];

void test() {
  (void)std::ranges::to&lt;C&gt;(R{});
}
</pre></blockquote>
<p>
Here:
</p>
<ol>
<li><p><code>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</code> is <code>false</code>.</p></li>
<li><p><code>range_reference_t&lt;R&gt;</code> satisfies <code>input_range</code>.</p></li>
<li><p><code>range_reference_t&lt;R&gt;</code> can be converted to <code>range_value_t&lt;C&gt;</code> through 
<code>to&lt;range_value_t&lt;C&gt;&gt;</code>. (If it couldn't, an error would be produced immediately.)</p></li>
</ol>
<p>
So <code>to&lt;C&gt;</code> is called recursively, constructing <code>C</code> with the transformed range (whose 
<code>range_reference_t&lt;R&gt;</code> is the same as <code>range_value_t&lt;C&gt;</code>). For the construction 
from the transformed range:
</p>
<ol>
<li><p><code>range_reference_t&lt;R&gt;</code> and <code>range_value_t&lt;C&gt;</code> are both <code>ImmovableRange</code>.</p></li>
<li><p><code>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</code> (i.e. 
<code>convertible_to&lt;ImmovableRange, ImmovableRange&gt;</code>) is <code>false</code>.</p></li>
<li><p><code>range_reference_t&lt;R&gt;</code> (i.e. <code>ImmovableRange</code>) satisfies <code>input_range</code>.</p></li>
<li><p><code>range_reference_t&lt;R&gt;</code> can be converted to <code>range_value_t&lt;C&gt;</code> through 
<code>to&lt;range_value_t&lt;C&gt;&gt;</code>.</p></li>
</ol>
<p>
So <code>to&lt;C&gt;</code> is called recursively again, transforming the range for the second time. This time,
the transformation does not change any of the above four facts. As a result, <code>to&lt;C&gt;</code> is called 
yet again, leading to an infinite recursion.
<p/>
I believe this can be fixed by stop calling <code>to&lt;C&gt;</code> recursively when <code>range_reference_t&lt;R&gt;</code> 
is the same as <code>range_value_t&lt;C&gt;</code>.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"Do we want <code>same_as</code> or <code>!<em>different-from</em></code>?"
</p>



<p id="res-4008"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>C</code> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>C</code> does not satisfy <code>input_range</code> or 
<code>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
</ol></li>
<li><p>(2.2) &mdash; Otherwise, if <ins><code>same_as&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</code> 
is <code>false</code> and</ins> <code>input_range&lt;range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:
</p>
<blockquote>
<pre>
to&lt;C&gt;(r | views::transform([](auto&amp;&amp; elem) {
  return to&lt;range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));
}), std::forward&lt;Args&gt;(args)...);
</pre>
</blockquote>
</li>
<li><p>(2.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>
</blockquote>
</blockquote>


</li>

</ol>





<hr>
<h3 id="4009"><a href="4009">4009</a>. <code>drop_view::begin const</code> may have &#x1d4aa;(n) complexity</h3>
<p><b>Section:</b> 25.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-08 <b>Last modified:</b> 2023-11-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.drop.view">active issues</a> in [range.drop.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.drop.view">issues</a> in [range.drop.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>drop_view::begin const</code> is specified to return <code>ranges::next(ranges::begin(<i>base_</i>), 
<i>count_</i>, ranges::end(<i>base_</i>))</code>, which has &#x1d4aa;(n) complexity when <i>base_</i> 
is a random-access-sized but non-common range (<a href="https://godbolt.org/z/jYdo9K6jn">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

int main() {
  const auto s = std::ranges::subrange(std::views::iota(0uz), size_t(-1));
  const auto r = std::ranges::drop_view(s, s.size() - 1);
  const auto b = r.begin(); // <span style="color:red;font-weight:bolder">time out</span>
}
</pre></blockquote>



<p id="res-4009"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a> as indicated:</p>

<pre>
constexpr auto begin()
  requires (!(<i>simple-view</i>&lt;V&gt; &amp;&amp;
              random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;));
<del>constexpr auto begin() const
  requires random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;;</del>
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: 
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.?) &mdash; If <code>V</code> models <code>random_access_range</code> and <code>sized_range</code>,</ins></p>
<blockquote><pre>
<ins><code>ranges::begin(<i>base_</i>) + (ranges::distance(<i>base_</i>) - range_difference_t&lt;V&gt;(size()))</code></ins>
</pre></blockquote>
</li>
<li><p><ins>(?.?) &mdash; Otherwise,</ins> <code>ranges::next(ranges::begin(<i>base_</i>), <i>count_</i>, 
ranges::end(<i>base_</i>))</code>.</p></li>
</ol>
<p>
-4- <i>Remarks</i>: In order to provide the amortized constant-time complexity required by the <code>range</code> 
concept when <ins><code>V</code></ins><del><code>drop_view</code></del> <ins>does not</ins> model<del>s</del> 
<ins><code>random_access_range</code> and <code>sized_range</code></ins><del><code>forward_range</code></del>, 
<ins>this function</ins><del>the first overload</del> caches the result within the <code>drop_view</code> for 
use on subsequent calls.
<p/>
[<i>Note 1</i>: Without this, applying a <code>reverse_view</code> over a <code>drop_view</code> would have quadratic 
iteration complexity. &mdash; <i>end note</i>]
</p>
</blockquote>
<pre><ins>
constexpr auto begin() const
  requires random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;;</ins>
</pre>
<blockquote>
<p><ins>-?- <i>Returns</i>: <code>ranges::begin(<i>base_</i>) + (ranges::distance(<i>base_</i>) - 
range_difference_t&lt;const V&gt;(size()))</code>.</ins></p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4010"><a href="4010">4010</a>. <code>subrange::advance</code> should be improved</h3>
<p><b>Section:</b> 25.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.access">[range.subrange.access]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-09 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.subrange.access">issues</a> in [range.subrange.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>subrange::advance</code> always increments <code><i>begin_</i></code> via <code>ranges::advance(<i>begin_</i>, 
n, <i>end_</i>)</code>, which has &#x1d4aa;(<code>n</code>) complexity for non-common random-access ranges,
which can be improved to &#x1d4aa;(1) with the help of the <code><i>size_</i></code> member (if provided).
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
Jonathan: The "Effects: Equivalent to" wording strongly suggests doing exactly
what it suggests there, and  the difference would be observable in the number
of times the iterator is compared to the sentinel. I'm not sure if we care
about that, or if an implementation would be free to make this change as QoI.
Regarding the proposed resolution, we know the type of <code>n</code>
so we don't need to use <code>decltype(n)</code> in the cast.
</p>



<p id="res-4010"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.access">[range.subrange.access]</a> as indicated:</p>

<pre>
constexpr subrange&amp; advance(iter_difference_t&lt;I&gt; n);
</pre>
<blockquote>
<p>
-9- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if constexpr (bidirectional_iterator&lt;I&gt;) {
  if (n &lt; 0) {
    ranges::advance(<i>begin_</i>, n);
    if constexpr (<i>StoreSize</i>)
      <i>size_</i> += <i>to-unsigned-like</i>(-n);
    return *this;
  }
}

<del>auto d = n - ranges::advance(<i>begin_</i>, n, <i>end_</i>);</del>
if constexpr (<i>StoreSize</i>) <ins>{
  n = std::min(n, static_cast&lt;decltype(n)&gt;(<i>size_</i>));
  ranges::advance(<i>begin_</i>, n);</ins>
  <i>size_</i> -= <i>to-unsigned-like</i>(<ins>n</ins><del>d</del>);
<ins>} else {
  ranges::advance(<i>begin_</i>, n, <i>end_</i>);
}</ins>
return *this;
</pre></blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4015"><a href="4015">4015</a>. LWG 3973 broke <code>const</code> overloads of <code>std::optional</code> monadic operations</h3>
<p><b>Section:</b> 22.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/optional.monadic">[optional.monadic]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2023-11-24 <b>Last modified:</b> 2024-10-02</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of LWG <a href="3973" title="Monadic operations should be ADL-proof (Status: WP)">3973</a> (adopted in Kona) changed all
occurrences of <code>value()</code> to <code>*val</code>.
The intention was not to change the meaning, just avoid the non-freestanding
<code>value()</code> function, and avoid ADL that would be caused by using
<code>**this</code>.
However, in the <code>const</code> overloads such as
<code>and_then(F&amp;&amp;) const</code> the type of <code>value()</code>
was <code>const T&amp;</code>, but the type of <code>*val</code> is always
<code>T&amp;</code>. This implies that the const overloads invoke the callable
with a non-const argument, which is incorrect (and would be undefined
behaviour for a <code>const std::optional&lt;T&gt;</code>).

</p>
<p>
On the LWG reflector it was suggested that we should rewrite the specification
of <code>std::optional</code> to stop using an exposition-only data member
of type <code>T*</code>. No such member ever exists in real implemetations,
so it is misleading and leads to specification bugs of this sort.
</p>
<p>
Change the class definition in 22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a>
to use a union, and update every use of <code>val</code> accordingly
throughout 22.5.3 <a href="https://timsong-cpp.github.io/cppwp/optional.optional">[optional.optional]</a>.
For consistency with 22.8.6.1 <a href="https://timsong-cpp.github.io/cppwp/expected.object.general">[expected.object.general]</a> we might
also want to introduce a <code>bool has_val</code> member and refer to
that in the specification.
</p>
<blockquote>
<pre><code>
  private:
    <del>T *val;         <em>// exposition only</em></del>
    <ins>bool has_val;   <em>// exposition only</em></ins>
    <ins>union {</ins>
      <ins>T val;        <em>// exposition only</em></ins>
    <ins>};</ins>
  };
</code></pre>
</blockquote>
<p>For example, in 22.5.3.9 <a href="https://timsong-cpp.github.io/cppwp/optional.mod">[optional.mod]</a>:</p>
<blockquote>
<p>
-1- <i>Effects</i>:
If <code>*this</code> contains a value, calls
<code>val<del>-&gt;</del><ins>.</ins>T::~T()</code> to destroy the contained
value<ins> and sets <code>has_val</code> to <code>false</code></ins>;
otherwise no effect.
</p>
</blockquote>

<p><i>[2023-11-26; Daniel provides wording]</i></p>

<p>
The proposed wording is considerably influenced by that of the specification of <code>expected</code>, but
attempts to reduce the amount of changes to not perfectly mimic it. Although "the contained value" is
a magic word of power it seemed feasible and simpler to use the new exposition-only member <code><i>val</i></code>
directly in some (but not all) places, usually involved with initializations.
<p/>
Furthermore, I have only added "and sets <code><i>has_val</i></code> to <code>true/false</code>"
where either the <i>Effects</i> wording says "otherwise no effect" or in other cases if the postconditions
did not already say that indirectly. I also added extra mentioning of <code><i>has_val</i></code> changes in tables
where different cells had very different effects on that member (unless these cells specify postconditions),
to prevent misunderstanding.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll in November 2023.
Six votes for 'Tentatively Ready' but enough uncertainty to deserve
discussion at a meeting.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a> <em>after</em> application of the wording of LWG <a href="3973" title="Monadic operations should be ADL-proof (Status: WP)">3973</a>.
</p>

<ol>

<li><p>Modify 22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a>, class template <code>optional</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T&gt;
  class optional {
  public:
    using value_type = T;
    [&hellip;]
  private:
    <ins>bool <i>has_val</i>; // <i>exposition only</i>
    union {</ins>
      T <ins><i>val</i></ins><del>*val</del>; // <i>exposition only</i>
    <ins>};</ins>
  };

  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a> as indicated:</p>

<blockquote>
<p>
-2- <ins>Member <code><i>has_val</i></code> indicates whether an <code>optional&lt;T&gt;</code> object contains a
value</ins><del>When an <code>optional&lt;T&gt;</code> object contains a value, member <code>val</code> points to
the contained value</del>.
</p>
</blockquote>
</li>

<li><p>Modify 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: Normatively, this subclause doesn't require any changes, but I'm suggesting to replace
phrases of the form "[&hellip;]initializes the contained value with"] by "[&hellip;]initializes <code><i>val</i></code> with"
as we do in 22.8.6.2 <a href="https://timsong-cpp.github.io/cppwp/expected.object.cons">[expected.object.cons]</a>. I intentionally did not add extra
"and sets <code><i>has_val</i></code> to <code>true/false</code>" since those effects are already guaranteed by the postconditions]
</p>
</blockquote>

<blockquote>
<pre>
constexpr optional(const optional&amp; rhs);
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: If <code>rhs</code> contains a value, direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code><del>*</del>rhs<ins>.<i>val</i></ins></code>.
<p/>
-5- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr optional(optional&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-8- <i>Constraints</i>: [&hellip;]
<p/>
-9- <i>Effects</i>: If <code>rhs</code> contains a value, direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code>.
<code>rhs.has_value()</code> is unchanged.
<p/>
-10- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
-14- <i>Effects</i>: Direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code>std::forward&lt;Args&gt;(args)...</code>.
<p/>
-15- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-18- <i>Constraints</i>: [&hellip;]
<p/>
-19- <i>Effects</i>: Direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code>il, std::forward&lt;Args&gt;(args)...</code>.
<p/>
-20- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U = T&gt; constexpr explicit(<i>see below</i>) optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-23- <i>Constraints</i>: [&hellip;]
<p/>
-24- <i>Effects</i>: Direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code>std::forward&lt;U&gt;(v)</code>.
<p/>
-25- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr explicit(<i>see below</i>) optional(const optional&lt;U&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-28- <i>Constraints</i>: [&hellip;]
<p/>
-29- <i>Effects</i>: If <code>rhs</code> contains a value, direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code><del>*</del>rhs<ins>.<i>val</i></ins></code>.
<p/>
-30- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr explicit(<i>see below</i>) optional(optional&lt;U&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-33- <i>Constraints</i>: [&hellip;]
<p/>
-34- <i>Effects</i>: If <code>rhs</code> contains a value, direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with
<code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code>. <code>rhs.has_value()</code> is unchanged.
<p/>
-35- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/optional.dtor">[optional.dtor]</a> as indicated:</p>

<blockquote>
<pre>
constexpr ~optional();
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: If <code>is_trivially_destructible_v&lt;T&gt; != true</code> and <code>*this</code> contains a value,
calls <code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code><ins>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr optional&lt;T&gt;&amp; operator=(nullopt_t) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: If <code>*this</code> contains a value, calls
<code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code> to destroy the contained
value <ins>and sets <code><i>has_val</i></code> to <code>false</code></ins>; otherwise no effect.
<p/>
-2- <i>Postconditions</i>: <code>*this</code> does not contain a value.
</p>
</blockquote>
<pre>
constexpr optional&lt;T&gt;&amp; operator=(const optional&amp; rhs);
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: See Table 58.
</p>
<table border="1">
<caption>Table 58 &mdash; <code>optional::operator=(const optional&amp;)</code> effects [tab:optional.assign.copy]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>assigns <code><del>*</del>rhs<ins>.<i>val</i></ins></code> to <ins><code><i>val</i></code></ins><del>the contained value</del></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code><del>*</del>rhs<ins>.<i>val</i></ins></code><br/>
<ins>and sets <code><i>has_val</i></code> to <code>true</code></ins>
</td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>destroys the contained value by calling <code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code><br/>
<ins>and sets <code><i>has_val</i></code> to <code>false</code></ins>
</td>
<td>no effect</td>
</tr>
</table>
<p>
-5- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr optional&lt;T&gt;&amp; operator=(optional&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-8- <i>Constraints</i>: [&hellip;]
<p/>
-9- <i>Effects</i>: See Table 59. The result of the expression <code>rhs.has_value()</code> remains unchanged.
<p/>
-10- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
-11- <i>Returns</i>: <code>*this</code>.
</p>
<table border="1">
<caption>Table 59 &mdash; <code>optional::operator=(optional&amp;&amp;)</code> effects [tab:optional.assign.move]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>assigns <code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code> to <ins><code><i>val</i></code></ins><del>the contained value</del></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del> with
<code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code> <ins>and sets <code><i>has_val</i></code> to <code>true</code></ins></td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>destroys the contained value by calling<br/>
<code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code><ins>and sets <code><i>has_val</i></code> to <code>false</code></ins></td>
<td>no effect</td>
</tr>
</table>
<p>
-12- <i>Remarks</i>: [&hellip;]
<p/>
-13- If any exception is thrown, the result of the expression <code>this-&gt;has_value()</code> remains
unchanged. If an exception is thrown during the call to <code>T</code>'s move constructor, the state
of <code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception
safety guarantee of <code>T</code>'s move constructor. If an exception is thrown during the call to
<code>T</code>'s move assignment, the state of <code><del>*</del><ins><i>val</i></ins><del>val</del></code>
and <code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception
safety guarantee of <code>T</code>'s move assignment.
</p>
</blockquote>
<pre>
template&lt;class U = T&gt; constexpr optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-14- <i>Constraints</i>: [&hellip;]
<p/>
-15- <i>Effects</i>: If <code>*this</code> contains a value, assigns <code>std::forward&lt;U&gt;(v)</code>
to <ins><code><i>val</i></code></ins><del>the contained value</del>; otherwise direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code>std::forward&lt;U&gt;(v)</code>.
<p/>
-16- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
-17- <i>Returns</i>: <code>*this</code>.
<p/>
-18- <i>Remarks</i>: If any exception is thrown, the result of the expression <code>this-&gt;has_value()</code>
remains unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of
<code>v</code> is determined by the exception safety guarantee of <code>T</code>'s constructor. If an exception
is thrown during the call to <code>T</code>'s assignment, the state of <code><ins><i>val</i></ins><del>*val</del></code>
and <code>v</code> is determined by the exception safety guarantee of <code>T</code>'s assignment.
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-19- <i>Constraints</i>: [&hellip;]
<p/>
-20- <i>Effects</i>: See Table 60.
</p>
<table border="1">
<caption>Table 60 &mdash; <code>optional::operator=(const optional&lt;U&gt;&amp;)</code> effects [tab:optional.assign.copy.templ]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>assigns <code><del>*</del>rhs<ins>.<i>val</i></ins></code> to <ins><code><i>val</i></code></ins><del>the contained value</del></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code><del>*</del>rhs<ins>.<i>val</i></ins></code> <ins>and sets <code><i>has_val</i></code> to <code>true</code></ins></td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>destroys the contained value by calling<br/>
<code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code> <ins>and sets <code><i>has_val</i></code> to <code>false</code></ins></td>
<td>no effect</td>
</tr>
</table>
<p>
-21- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
-22- <i>Returns</i>: <code>*this</code>.
<p/>
-23- If any exception is thrown, the result of the expression <code>this-&gt;has_value()</code> remains
unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s
assignment, the state of <code><ins><i>val</i></ins><del>*val</del></code> and
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>T</code>'s assignment.
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-24- <i>Constraints</i>: [&hellip;]
<p/>
-25- <i>Effects</i>: See Table 61. The result of the expression <code>rhs.has_value()</code> remains unchanged.
</p>
<table border="1">
<caption>Table 61 &mdash; <code>optional::operator=(optional&lt;U&gt;&amp;&amp;)</code> effects [tab:optional.assign.move.templ]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>assigns <code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code> to <ins><code><i>val</i></code></ins><del>the contained value</del></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del> with<br/>
<code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code> <ins>and sets <code><i>has_val</i></code> to <code>true</code></ins></td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>destroys the contained value by calling<br/>
<code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code> <ins>and sets <code><i>has_val</i></code> to <code>false</code></ins></td>
<td>no effect</td>
</tr>
</table>
<p>
-26- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
-27- <i>Returns</i>: <code>*this</code>.
<p/>
-28- If any exception is thrown, the result of the expression <code>this-&gt;has_value()</code> remains
unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s
assignment, the state of <code><ins><i>val</i></ins><del>*val</del></code> and
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>T</code>'s assignment.
</p>
</blockquote>
<pre>
template&lt;class... Args&gt; constexpr T&amp; emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-29- <i>Mandates</i>: [&hellip;]
<p/>
-30- <i>Effects</i>: Calls <code>*this = nullopt</code>. Then direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code>std::forward&lt;Args&gt;(args)...</code>.
<p/>
-31- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
-32- <i>Returns</i>: <ins><code><i>val</i></code></ins><del>A reference to the new contained value</del>.
<p/>
[&hellip;]
<p/>
-34- <i>Remarks</i>: If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code>
does not contain a value, and the previous <code><ins><i>val</i></ins><del>*val</del></code> (if any)
has been destroyed.
</p>
</blockquote>
<pre>
template&lt;class U, class... Args&gt; constexpr T&amp; emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-35- <i>Constraints</i>: [&hellip;]
<p/>
-36- <i>Effects</i>: Calls <code>*this = nullopt</code>. Then direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code>il, std::forward&lt;Args&gt;(args)...</code>.
<p/>
-37- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
-38- <i>Returns</i>: <ins><code><i>val</i></code></ins><del>A reference to the new contained value</del>.
<p/>
[&hellip;]
<p/>
-40- <i>Remarks</i>: If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code>
does not contain a value, and the previous <code><ins><i>val</i></ins><del>*val</del></code> (if any)
has been destroyed.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/optional.swap">[optional.swap]</a> as indicated:</p>

<blockquote>
<pre>
constexpr void swap(optional&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: [&hellip;]
<p/>
-2- <i>Preconditions</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: See Table 62.
</p>
<table border="1">
<caption>Table 62 &mdash; <code>optional::swap(optional&amp;)</code> effects [tab:optional.swap]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>calls <code>swap(<ins><i>val</i></ins><del>*(*this)</del>, <del>*</del>rhs<ins>.<i>val</i></ins>)</code></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value of <code>*this</code></del><br/>
with <code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code>, followed by <code>rhs.<ins><i>val</i>.</ins><del>val-&gt;</del>T::~T()</code>;<br/>
postcondition is that <code>*this</code> contains a value and <code>rhs</code> does<br/>
not contain a value</td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>direct-non-list-initializes <del>the contained value of</del> <code>rhs<ins>.<i>val</i></ins></code><br/>
with <code>std::move(<ins><i>val</i></ins><del>*(*this)</del>)</code>, followed by <code><ins><i>val</i>.</ins><del>val-&gt;</del>T::~T()</code>;<br/>
postcondition is that <code>*this</code> does not contain a value and <code>rhs</code><br/>
contains a value</td>
<td>no effect</td>
</tr>
</table>
<p>
-4- <i>Throws</i>: [&hellip;]
<p/>
-5- <i>Remarks</i>: [&hellip;]
<p/>
-6- If any exception is thrown, the results of the expressions <code>this-&gt;has_value()</code> and
<code>rhs.has_value()</code> remain unchanged. If an exception is thrown during the call to function <code>swap</code>,
the state of <code><ins><i>val</i></ins><del>*val</del></code> and
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>swap</code> for lvalues of <code>T</code>. If an exception is thrown during the call to
<code>T</code>'s move constructor, the state of <code><ins><i>val</i></ins><del>*val</del></code> and
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>T</code>'s move constructor.
<p/>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> as indicated:</p>

<blockquote>
<pre>
constexpr const T* operator-&gt;() const noexcept;
constexpr T* operator-&gt;() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: <code>*this</code> contains a value.
<p/>
-2- <i>Returns</i>: <code><ins>addressof(<i>val</i>)</ins><del>val</del></code>.
<p/>
-3- [&hellip;]
</p>
</blockquote>
<pre>
constexpr const T&amp; operator*() const &amp; noexcept;
constexpr T&amp; operator*() &amp; noexcept;
</pre>
<blockquote>
<p>
-4- <i>Preconditions</i>: <code>*this</code> contains a value.
<p/>
-5- <i>Returns</i>: <code><ins><i>val</i></ins><del>*val</del></code>.
<p/>
-6- [&hellip;]
</p>
</blockquote>
<pre>
constexpr T&amp;&amp; operator*() &amp;&amp; noexcept;
constexpr const T&amp;&amp; operator*() const &amp;&amp; noexcept;
</pre>
<blockquote>
<p>
-7- <i>Preconditions</i>: <code>*this</code> contains a value.
<p/>
-8- <i>Effects</i>: Equivalent to: <code>return std::move(<ins><i>val</i></ins><del>*val</del>);</code>
</p>
</blockquote>
<pre>
constexpr explicit operator bool() const noexcept;
</pre>
<blockquote>
<p>
<del>-9- <i>Returns</i>: <code>true</code> if and only if <code>*this</code> contains a value.</del>
<p/>
<del>-10- <i>Remarks</i>: This function is a constexpr function.</del>
</p>
</blockquote>
<pre>
constexpr bool has_value() const noexcept;
</pre>
<blockquote>
<p>
-11- <i>Returns</i>: <ins><code><i>has_val</i></code></ins><del><code>true</code> if and only if <code>*this</code> contains a value</del>.
<p/>
-12- <i>Remarks</i>: <ins>These functions are</ins><del>This function is a</del> constexpr function<ins>s</ins>.
</p>
</blockquote>
<pre>
constexpr const T&amp; value() const &amp;;
constexpr T&amp; value() &amp;;
</pre>
<blockquote>
<p>
-13- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? <ins><i>val</i></ins><del>*val</del> : throw bad_optional_access();
</pre></blockquote>
</blockquote>
<pre>
constexpr T&amp;&amp; value() &amp;&amp;;
constexpr const T&amp;&amp; value() const &amp;&amp;;
</pre>
<blockquote>
<p>
-14- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? std::move(<ins><i>val</i></ins><del>*val</del>) : throw bad_optional_access();
</pre></blockquote>
</blockquote>
<pre>
template&lt;class U&gt; constexpr T value_or(U&amp;&amp; v) const &amp;;
</pre>
<blockquote>
<p>
-15- <i>Mandates</i>: [&hellip;]
<p/>
-16- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? <ins><i>val</i></ins><del>**this</del> : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v));
</pre></blockquote>
</blockquote>
<pre>
template&lt;class U&gt; constexpr T value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
-17- <i>Mandates</i>: [&hellip;]
<p/>
-18- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? std::move(<ins><i>val</i></ins><del>**this</del>) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v));
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/optional.monadic">[optional.monadic]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-1- Let <code>U</code> be <code>invoke_result_t&lt;F, decltype(<ins>(<i>val</i>)</ins><del>*val</del>)&gt;</code>.
<p/>
-2- <i>Mandates</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (*this) {
  return invoke(std::forward&lt;F&gt;(f), <ins><i>val</i></ins><del>*val</del>);
} else {
  return remove_cvref_t&lt;U&gt;();
}
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-4- Let <code>U</code> be <code>invoke_result_t&lt;F, decltype(std::move(<ins><i>val</i></ins><del>*val</del>))&gt;</code>.
<p/>
-5- <i>Mandates</i>: [&hellip;]
<p/>
-6- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (*this) {
  return invoke(std::forward&lt;F&gt;(f), std::move(<ins><i>val</i></ins><del>*val</del>));
} else {
  return remove_cvref_t&lt;U&gt;();
}
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-7- Let <code>U</code> be <code>remove_cv_t&lt;invoke_result_t&lt;F, decltype(<ins>(<i>val</i>)</ins><del>*val</del>)&gt;&gt;</code>.
<p/>
-8- <i>Mandates</i>: <code>U</code> is a non-array object type other than <code>in_place_t</code> or <code>nullopt_t</code>. The declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), <ins><i>val</i></ins><del>*val</del>));
</pre></blockquote>
<p>
is well-formed for some invented variable <code>u</code>.
<p/>
[&hellip;]
<p/>
-9- <i>Returns</i>: If <code>*this</code> contains a value, an <code>optional&lt;U&gt;</code> object whose contained value is
direct-non-list-initialized with <code>invoke(std::forward&lt;F&gt;(f), <ins><i>val</i></ins><del>*val</del>)</code>; otherwise,
<code>optional&lt;U&gt;()</code>.
</p>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-10- Let <code>U</code> be <code>remove_cv_t&lt;invoke_result_t&lt;F, decltype(std::move(<ins><i>val</i></ins><del>*val</del>))&gt;&gt;</code>.
<p/>
-11- <i>Mandates</i>: <code>U</code> is a non-array object type other than <code>in_place_t</code> or <code>nullopt_t</code>. The declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), std::move(<ins><i>val</i></ins><del>*val</del>)));
</pre></blockquote>
<p>
is well-formed for some invented variable <code>u</code>.
<p/>
[&hellip;]
<p/>
-12- <i>Returns</i>: If <code>*this</code> contains a value, an <code>optional&lt;U&gt;</code> object whose contained value is
direct-non-list-initialized with <code>invoke(std::forward&lt;F&gt;(f), std::move(<ins><i>val</i></ins><del>*val</del>))</code>; otherwise,
<code>optional&lt;U&gt;()</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.9 <a href="https://timsong-cpp.github.io/cppwp/optional.mod">[optional.mod]</a> as indicated:</p>

<blockquote>
<pre>
constexpr void reset() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: If <code>*this</code> contains a value, calls <code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code>
to destroy the contained value <ins>and sets <code><i>has_val</i></code> to <code>false</code></ins>; otherwise no effect.
<p/>
-2- <i>Postconditions</i>: <code>*this</code> does not contain a value.
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[St. Louis 2024-06-24; Jonathan provides improved wording]</i></p>

<p><i>[2024-08-21; LWG telecon]</i></p>

<p>
During telecon review it was suggested to replace
22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a> p1 and p2.
On the reflector Daniel requested to keep the "additional storage" prohibition,
so that will be addressed by issue <a href="4141" title="Improve prohibitions on &quot;additional storage&quot; (Status: WP)">4141</a> instead.
</p>

<p><i>[2024-10-02; Jonathan tweaks proposed resolution]</i></p>

<p>
On the reflector we decided that the union member should use <code class='backtick'>remove_cv_t</code>,
as proposed for <code class='backtick'>expected</code> by issue <a href="3891" title="LWG 3870 breaks std::expected&lt;cv T, E&gt; (Status: New)">3891</a>.
The rest of the proposed resolution is unchanged, so that edit was made
in-place below, instead of as a new resolution that supersedes the old one.
</p>



<p id="res-4015"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>

<li><p>Modify 22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a>, class template <code>optional</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T&gt;
  class optional {
  public:
    using value_type = T;
    [&hellip;]
  private:
    <del>*val // <i>exposition only</i></del>;
    <ins>union {</ins>
      <ins>remove_cv_t&lt;T&gt; <i>val</i>; // <i>exposition only</i></ins>
    <ins>};</ins>
  };

  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.general">[optional.optional.general]</a> as indicated:</p>

<blockquote>
<p>
-1-
<ins>
When its member <code><i>val</i></code> is active
(11.5.1 <a href="https://timsong-cpp.github.io/cppwp/class.union.general">[class.union.general]</a>),
an instance of <code>optional&lt;T&gt;</code> is said to
<i>contain a value</i>, and <code><i>val</i></code> is referred to as its
<i>contained value</i>.
</ins>
<del>
Any instance of <code>optional&lt;T&gt;</code> at any given time either
contains a value or does not contain a value.
When an instance of <code>optional&lt;T&gt;</code> <i>contains a value</i>,
it means that an object of type <code>T</code>,
referred to as the</del>
<ins>An</ins>
optional object's
<ins>contained value</ins>
<del><i>contained value</i>, </del>
is allocated within the storage of the optional object.
Implementations are not permitted to use additional storage,
such as dynamic memory, to allocate its contained value.
<del>
When an object of type <code>optional&lt;T&gt;</code>
is contextually converted to <code>bool</code>,
the conversion returns <code class='backtick'>true</code> if the object contains a value;
otherwise the conversion returns <code class='backtick'>false</code>.
</del>
</p>
<p>
<del>
-2- When an <code>optional&lt;T&gt;</code> object contains a value,
member <code>val</code>
points to the contained value.
</del>
</p>
</blockquote>
</li>

<li><p>Modify 22.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/optional.ctor">[optional.ctor]</a> as indicated:</p>

<blockquote>
<pre>
constexpr optional(const optional&amp; rhs);
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: If <code>rhs</code> contains a value, direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code><del>*</del>rhs<ins>.<i>val</i></ins></code>.
<p/>
-5- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr optional(optional&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-8- <i>Constraints</i>: [&hellip;]
<p/>
-9- <i>Effects</i>: If <code>rhs</code> contains a value, direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code>.
<code>rhs.has_value()</code> is unchanged.
<p/>
-10- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
-14- <i>Effects</i>: Direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code>std::forward&lt;Args&gt;(args)...</code>.
<p/>
-15- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-18- <i>Constraints</i>: [&hellip;]
<p/>
-19- <i>Effects</i>: Direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code>il, std::forward&lt;Args&gt;(args)...</code>.
<p/>
-20- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U = T&gt; constexpr explicit(<i>see below</i>) optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-23- <i>Constraints</i>: [&hellip;]
<p/>
-24- <i>Effects</i>: Direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code>std::forward&lt;U&gt;(v)</code>.
<p/>
-25- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr explicit(<i>see below</i>) optional(const optional&lt;U&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-28- <i>Constraints</i>: [&hellip;]
<p/>
-29- <i>Effects</i>: If <code>rhs</code> contains a value, direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code><del>*</del>rhs<ins>.<i>val</i></ins></code>.
<p/>
-30- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr explicit(<i>see below</i>) optional(optional&lt;U&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-33- <i>Constraints</i>: [&hellip;]
<p/>
-34- <i>Effects</i>: If <code>rhs</code> contains a value, direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with
<code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code>. <code>rhs.has_value()</code> is unchanged.
<p/>
-35- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/optional.dtor">[optional.dtor]</a> as indicated:</p>

<blockquote>
<pre>
constexpr ~optional();
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: If <code>is_trivially_destructible_v&lt;T&gt; != true</code> and <code>*this</code> contains a value,
calls <code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code><ins>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr optional&lt;T&gt;&amp; operator=(nullopt_t) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: If <code>*this</code> contains a value, calls
<code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code> to destroy the contained
value; otherwise no effect.
<p/>
-2- <i>Postconditions</i>: <code>*this</code> does not contain a value.
</p>
</blockquote>
<pre>
constexpr optional&lt;T&gt;&amp; operator=(const optional&amp; rhs);
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: See Table 58.
</p>
<table border="1">
<caption>Table 58 &mdash; <code>optional::operator=(const optional&amp;)</code> effects [tab:optional.assign.copy]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>assigns <code><del>*</del>rhs<ins>.<i>val</i></ins></code> to <ins><code><i>val</i></code></ins><del>the contained value</del></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code><del>*</del>rhs<ins>.<i>val</i></ins></code><br/>
</td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>destroys the contained value by calling <code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code><br/>
</td>
<td>no effect</td>
</tr>
</table>
<p>
-5- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr optional&lt;T&gt;&amp; operator=(optional&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-8- <i>Constraints</i>: [&hellip;]
<p/>
-9- <i>Effects</i>: See Table 59. The result of the expression <code>rhs.has_value()</code> remains unchanged.
<p/>
-10- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
-11- <i>Returns</i>: <code>*this</code>.
</p>
<table border="1">
<caption>Table 59 &mdash; <code>optional::operator=(optional&amp;&amp;)</code> effects [tab:optional.assign.move]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>assigns <code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code> to <ins><code><i>val</i></code></ins><del>the contained value</del></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del> with
<code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code></td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>destroys the contained value by calling<br/>
<code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code></td>
<td>no effect</td>
</tr>
</table>
<p>
-12- <i>Remarks</i>: [&hellip;]
<p/>
-13- If any exception is thrown, the result of the expression <code>this-&gt;has_value()</code> remains
unchanged. If an exception is thrown during the call to <code>T</code>'s move constructor, the state
of <code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception
safety guarantee of <code>T</code>'s move constructor. If an exception is thrown during the call to
<code>T</code>'s move assignment, the <ins>states</ins> <del>state</del> of <code><del>*</del><ins><i>val</i></ins><del>val</del></code>
and <code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> <ins>are</ins> <del>is</del> determined by the exception
safety guarantee of <code>T</code>'s move assignment.
</p>
</blockquote>
<pre>
template&lt;class U = T&gt; constexpr optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-14- <i>Constraints</i>: [&hellip;]
<p/>
-15- <i>Effects</i>: If <code>*this</code> contains a value, assigns <code>std::forward&lt;U&gt;(v)</code>
to <ins><code><i>val</i></code></ins><del>the contained value</del>; otherwise direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code>std::forward&lt;U&gt;(v)</code>.
<p/>
-16- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
-17- <i>Returns</i>: <code>*this</code>.
<p/>
-18- <i>Remarks</i>: If any exception is thrown, the result of the expression <code>this-&gt;has_value()</code>
remains unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of
<code>v</code> is determined by the exception safety guarantee of <code>T</code>'s constructor. If an exception
is thrown during the call to <code>T</code>'s assignment, the <ins>states</ins> <del>state</del> of <code><ins><i>val</i></ins><del>*val</del></code>
and <code>v</code> <ins>are</ins> <del>is</del> determined by the exception safety guarantee of <code>T</code>'s assignment.
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-19- <i>Constraints</i>: [&hellip;]
<p/>
-20- <i>Effects</i>: See Table 60.
</p>
<table border="1">
<caption>Table 60 &mdash; <code>optional::operator=(const optional&lt;U&gt;&amp;)</code> effects [tab:optional.assign.copy.templ]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>assigns <code><del>*</del>rhs<ins>.<i>val</i></ins></code> to <ins><code><i>val</i></code></ins><del>the contained value</del></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del>
with <code><del>*</del>rhs<ins>.<i>val</i></ins></code> </td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>destroys the contained value by calling<br/>
<code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code> </td>
<td>no effect</td>
</tr>
</table>
<p>
-21- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
-22- <i>Returns</i>: <code>*this</code>.
<p/>
-23- If any exception is thrown, the result of the expression <code>this-&gt;has_value()</code> remains
unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s
assignment, the <ins>states</ins> <del>state</del> of <code><ins><i>val</i></ins><del>*val</del></code> and
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> <ins>are</ins> <del>is</del> determined by the exception safety
guarantee of <code>T</code>'s assignment.
</p>
</blockquote>
<pre>
template&lt;class U&gt; constexpr optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-24- <i>Constraints</i>: [&hellip;]
<p/>
-25- <i>Effects</i>: See Table 61. The result of the expression <code>rhs.has_value()</code> remains unchanged.
</p>
<table border="1">
<caption>Table 61 &mdash; <code>optional::operator=(optional&lt;U&gt;&amp;&amp;)</code> effects [tab:optional.assign.move.templ]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>assigns <code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code> to <ins><code><i>val</i></code></ins><del>the contained value</del></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value</del> with<br/>
<code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code> </td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>destroys the contained value by calling<br/>
<code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code> </td>
<td>no effect</td>
</tr>
</table>
<p>
-26- <i>Postconditions</i>: <code>rhs.has_value() == this-&gt;has_value()</code>.
<p/>
-27- <i>Returns</i>: <code>*this</code>.
<p/>
-28- If any exception is thrown, the result of the expression <code>this-&gt;has_value()</code> remains
unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s
assignment, the <ins>states</ins> <del>state</del> of <code><ins><i>val</i></ins><del>*val</del></code> and
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> <ins>are</ins> <del>is</del> determined by the exception safety
guarantee of <code>T</code>'s assignment.
</p>
</blockquote>
<pre>
template&lt;class... Args&gt; constexpr T&amp; emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-29- <i>Mandates</i>: [&hellip;]
<p/>
-30- <i>Effects</i>: Calls <code>*this = nullopt</code>. Then direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code>std::forward&lt;Args&gt;(args)...</code>.
<p/>
-31- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
-32- <i>Returns</i>: <ins><code><i>val</i></code></ins><del>A reference to the new contained value</del>.
<p/>
[&hellip;]
<p/>
-34- <i>Remarks</i>: If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code>
does not contain a value, and the previous <code><ins><i>val</i></ins><del>*val</del></code> (if any)
has been destroyed.
</p>
</blockquote>
<pre>
template&lt;class U, class... Args&gt; constexpr T&amp; emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-35- <i>Constraints</i>: [&hellip;]
<p/>
-36- <i>Effects</i>: Calls <code>*this = nullopt</code>. Then direct-non-list-initializes
<ins><code><i>val</i></code></ins><del>the contained value</del> with <code>il, std::forward&lt;Args&gt;(args)...</code>.
<p/>
-37- <i>Postconditions</i>: <code>*this</code> contains a value.
<p/>
-38- <i>Returns</i>: <ins><code><i>val</i></code></ins><del>A reference to the new contained value</del>.
<p/>
[&hellip;]
<p/>
-40- <i>Remarks</i>: If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code>
does not contain a value, and the previous <code><ins><i>val</i></ins><del>*val</del></code> (if any)
has been destroyed.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/optional.swap">[optional.swap]</a> as indicated:</p>

<blockquote>
<pre>
constexpr void swap(optional&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: [&hellip;]
<p/>
-2- <i>Preconditions</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: See Table 62.
</p>
<table border="1">
<caption>Table 62 &mdash; <code>optional::swap(optional&amp;)</code> effects [tab:optional.swap]</caption>

<tr>
<th></th>
<th><b><code>*this</code> contains a value</b></th>
<th><b><code>*this</code> does not contain a value</b></th>
</tr>

<tr>
<td><b><code>rhs</code> contains a value</b></td>
<td>calls <code>swap(<ins><i>val</i></ins><del>*(*this)</del>, <del>*</del>rhs<ins>.<i>val</i></ins>)</code></td>
<td>direct-non-list-initializes <ins><code><i>val</i></code></ins><del>the contained value of <code>*this</code></del><br/>
with <code>std::move(<del>*</del>rhs<ins>.<i>val</i></ins>)</code>, followed by <code>rhs.<ins><i>val</i>.</ins><del>val-&gt;</del>T::~T()</code>;<br/>
postcondition is that <code>*this</code> contains a value and <code>rhs</code> does<br/>
not contain a value</td>
</tr>

<tr>
<td><b><code>rhs</code> does not contain a value</b></td>
<td>direct-non-list-initializes <del>the contained value of</del> <code>rhs<ins>.<i>val</i></ins></code><br/>
with <code>std::move(<ins><i>val</i></ins><del>*(*this)</del>)</code>, followed by <code><ins><i>val</i>.</ins><del>val-&gt;</del>T::~T()</code>;<br/>
postcondition is that <code>*this</code> does not contain a value and <code>rhs</code><br/>
contains a value</td>
<td>no effect</td>
</tr>
</table>
<p>
-4- <i>Throws</i>: [&hellip;]
<p/>
-5- <i>Remarks</i>: [&hellip;]
<p/>
-6- If any exception is thrown, the results of the expressions <code>this-&gt;has_value()</code> and
<code>rhs.has_value()</code> remain unchanged. If an exception is thrown during the call to function <code>swap</code>,
the state of <code><ins><i>val</i></ins><del>*val</del></code> and
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> is determined by the exception safety
guarantee of <code>swap</code> for lvalues of <code>T</code>. If an exception is thrown during the call to
<code>T</code>'s move constructor, the <ins>states</ins> <del>state</del> of <code><ins><i>val</i></ins><del>*val</del></code> and
<code><del>*</del>rhs.<ins><i>val</i></ins><del>val</del></code> <ins>are</ins> <del>is</del> determined by the exception safety
guarantee of <code>T</code>'s move constructor.
<p/>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> as indicated:</p>

<blockquote>
<pre>
constexpr const T* operator-&gt;() const noexcept;
constexpr T* operator-&gt;() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: <code>*this</code> contains a value.
<p/>
-2- <i>Returns</i>: <code><ins>addressof(<i>val</i>)</ins><del>val</del></code>.
<p/>
-3- [&hellip;]
</p>
</blockquote>
<pre>
constexpr const T&amp; operator*() const &amp; noexcept;
constexpr T&amp; operator*() &amp; noexcept;
</pre>
<blockquote>
<p>
-4- <i>Preconditions</i>: <code>*this</code> contains a value.
<p/>
-5- <i>Returns</i>: <code><ins><i>val</i></ins><del>*val</del></code>.
<p/>
-6- [&hellip;]
</p>
</blockquote>
<pre>
constexpr T&amp;&amp; operator*() &amp;&amp; noexcept;
constexpr const T&amp;&amp; operator*() const &amp;&amp; noexcept;
</pre>
<blockquote>
<p>
-7- <i>Preconditions</i>: <code>*this</code> contains a value.
<p/>
-8- <i>Effects</i>: Equivalent to: <code>return std::move(<ins><i>val</i></ins><del>*val</del>);</code>
</p>
</blockquote>
<pre>
constexpr explicit operator bool() const noexcept;
</pre>
<blockquote>
<p>
-9- <i>Returns</i>: <code>true</code> if and only if <code>*this</code> contains a value.
<p/>
-10- <i>Remarks</i>: This function is a constexpr function.
</p>
</blockquote>
<pre>
constexpr bool has_value() const noexcept;
</pre>
<blockquote>
<p>
-11- <i>Returns</i>: <code>true</code> if and only if <code>*this</code> contains a value.
<p/>
-12- <i>Remarks</i>: This function is a constexpr function.
</p>
</blockquote>
<pre>
constexpr const T&amp; value() const &amp;;
constexpr T&amp; value() &amp;;
</pre>
<blockquote>
<p>
-13- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? <ins><i>val</i></ins><del>*val</del> : throw bad_optional_access();
</pre></blockquote>
</blockquote>
<pre>
constexpr T&amp;&amp; value() &amp;&amp;;
constexpr const T&amp;&amp; value() const &amp;&amp;;
</pre>
<blockquote>
<p>
-14- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? std::move(<ins><i>val</i></ins><del>*val</del>) : throw bad_optional_access();
</pre></blockquote>
</blockquote>
<pre>
template&lt;class U&gt; constexpr T value_or(U&amp;&amp; v) const &amp;;
</pre>
<blockquote>
<p>
-15- <i>Mandates</i>: [&hellip;]
<p/>
-16- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? <ins><i>val</i></ins><del>**this</del> : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v));
</pre></blockquote>
</blockquote>
<pre>
template&lt;class U&gt; constexpr T value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
-17- <i>Mandates</i>: [&hellip;]
<p/>
-18- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? std::move(<ins><i>val</i></ins><del>**this</del>) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v));
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/optional.monadic">[optional.monadic]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-1- Let <code>U</code> be <code>invoke_result_t&lt;F, decltype(<ins>(<i>val</i>)</ins><del>*val</del>)&gt;</code>.
<p/>
-2- <i>Mandates</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (*this) {
  return invoke(std::forward&lt;F&gt;(f), <ins><i>val</i></ins><del>*val</del>);
} else {
  return remove_cvref_t&lt;U&gt;();
}
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto and_then(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-4- Let <code>U</code> be <code>invoke_result_t&lt;F, decltype(std::move(<ins><i>val</i></ins><del>*val</del>))&gt;</code>.
<p/>
-5- <i>Mandates</i>: [&hellip;]
<p/>
-6- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (*this) {
  return invoke(std::forward&lt;F&gt;(f), std::move(<ins><i>val</i></ins><del>*val</del>));
} else {
  return remove_cvref_t&lt;U&gt;();
}
</pre></blockquote>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;;
</pre>
<blockquote>
<p>
-7- Let <code>U</code> be <code>remove_cv_t&lt;invoke_result_t&lt;F, decltype(<ins>(<i>val</i>)</ins><del>*val</del>)&gt;&gt;</code>.
<p/>
-8- <i>Mandates</i>: <code>U</code> is a non-array object type other than <code>in_place_t</code> or <code>nullopt_t</code>. The declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), <ins><i>val</i></ins><del>*val</del>));
</pre></blockquote>
<p>
is well-formed for some invented variable <code>u</code>.
<p/>
[&hellip;]
<p/>
-9- <i>Returns</i>: If <code>*this</code> contains a value, an <code>optional&lt;U&gt;</code> object whose contained value is
direct-non-list-initialized with <code>invoke(std::forward&lt;F&gt;(f), <ins><i>val</i></ins><del>*val</del>)</code>; otherwise,
<code>optional&lt;U&gt;()</code>.
</p>
</blockquote>
<pre>
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) &amp;&amp;;
template&lt;class F&gt; constexpr auto transform(F&amp;&amp; f) const &amp;&amp;;
</pre>
<blockquote>
<p>
-10- Let <code>U</code> be <code>remove_cv_t&lt;invoke_result_t&lt;F, decltype(std::move(<ins><i>val</i></ins><del>*val</del>))&gt;&gt;</code>.
<p/>
-11- <i>Mandates</i>: <code>U</code> is a non-array object type other than <code>in_place_t</code> or <code>nullopt_t</code>. The declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), std::move(<ins><i>val</i></ins><del>*val</del>)));
</pre></blockquote>
<p>
is well-formed for some invented variable <code>u</code>.
<p/>
[&hellip;]
<p/>
-12- <i>Returns</i>: If <code>*this</code> contains a value, an <code>optional&lt;U&gt;</code> object whose contained value is
direct-non-list-initialized with <code>invoke(std::forward&lt;F&gt;(f), std::move(<ins><i>val</i></ins><del>*val</del>))</code>; otherwise,
<code>optional&lt;U&gt;()</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.3.9 <a href="https://timsong-cpp.github.io/cppwp/optional.mod">[optional.mod]</a> as indicated:</p>

<blockquote>
<pre>
constexpr void reset() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: If <code>*this</code> contains a value, calls <code><del>val-&gt;</del><ins><i>val</i>.</ins>T::~T()</code>
to destroy the contained value; otherwise no effect.
<p/>
-2- <i>Postconditions</i>: <code>*this</code> does not contain a value.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4017"><a href="4017">4017</a>. Behavior of <code>std::views::split</code> on an empty range</h3>
<p><b>Section:</b> 25.7.17.3 <a href="https://timsong-cpp.github.io/cppwp/range.split.iterator">[range.split.iterator]</a>, 25.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.outer">[range.lazy.split.outer]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Stone <b>Opened:</b> 2023-11-19 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following example (which uses <code>fmt::println</code> instead of <code>std::println</code>, 
but they do the same thing in C++23):
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;ranges&gt;
#include &lt;fmt/ranges.h&gt;

int main()
{
  fmt::println("{}", std::views::split(std::string(" x "), ' '));
  fmt::println("{}", std::views::split(std::string(" "), ' '));
  fmt::println("{}", std::views::split(std::string("x"), ' '));
  fmt::println("{}", std::views::split(std::string(""), ' '));
}
</pre></blockquote>
<p>
The output of this program (as specified today) is 
</p>
<blockquote><pre>
[[], ['x'], []]
[[], []]
[['x']]
[]
</pre></blockquote>
<p>
The principle set out in LWG <a href="3478" title="views::split drops trailing empty range (Status: Resolved)">3478</a> is that splitting a sequence containing <code>N</code> 
delimiters should lead to <code>N+1</code> subranges. That principle was broken if the <code>N</code>-th 
delimiter was at the end of the sequence, which was fixed by <a href="https://wg21.link/P2210" title=" Superior String Splitting">P2210</a>. 
<p/>
However, the principle is still broken if the sequence contains zero delimiters. A non-empty sequence 
will split into one range, but an empty sequence will split into zero ranges. That last line is incorrect 
&mdash; splitting an empty range on a delimiter should yield a range of an empty range &mdash; not 
simply an empty range.
<p/>
Proposed Resolution: Currently, <code>split_view::iterator</code>'s constructor unconditionally initializes 
<code><i>trailing_empty_</i></code> to <code>false</code>. Instead, change 25.7.17.3 <a href="https://timsong-cpp.github.io/cppwp/range.split.iterator">[range.split.iterator]</a>/1 
to initialize <code><i>trailing_empty_</i></code> to <code><i>cur_</i> == <i>next_</i>.begin()</code> (i.e. 
<code><i>trailing_empty_</i></code> is typically <code>false</code>, but if we're empty on initialization then we 
have to have a trailing empty range).
<p/>
The following demo shows Barry Revzin's implementation from <a href="https://wg21.link/P2210" title=" Superior String Splitting">P2210</a>, adjusted to fix this: 
<a href="https://godbolt.org/z/axWb64j9f">godbolt.org/z/axWb64j9f</a>
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2024-03; Reflector comments]</i></p>

<p>
"For <code class='backtick'>split</code>, we need to adjust the definition of <code class='backtick'>end()</code> for the
<code class='backtick'>common_range</code> case
(which may require introducing a new constructor to the iterator);
right now it would compare <code class='backtick'>ranges::end(base_)</code> against a value-initialized
iterator, which is not in the domain of <code class='backtick'>==</code>.
For <code class='backtick'>lazy_split</code>, we need to also change the non-forward overload."
</p>
<p>
"What should splitting an empty range on an empty pattern produce?
Right now the behavior is that splitting a range of N &gt; 0 elements
with an empty pattern produces a range of N single-element ranges.
I suppose you can argue that an empty pattern matches between adjacent elements
but not at the start or end, so that an empty range, like a single-element range,
contains 0 delimiters so should produce a range of one empty range.
But it's also at least arguable that this should produce an empty range instead,
so that we maintain the N element &lt;-&gt; N subrange
and 1 element per subrange invariant.
</p>



<p id="res-4017"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.7.17.3 <a href="https://timsong-cpp.github.io/cppwp/range.split.iterator">[range.split.iterator]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>iterator</i>(split_view&amp; parent, iterator_t&lt;V&gt; current, subrange&lt;iterator_t&lt;V&gt;&gt; next);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes <code><i>parent_</i></code> with <code>addressof(parent)</code>, <code><i>cur_</i></code> with 
<code>std::move(current)</code>, <del>and</del> <code><i>next_</i></code> with <code>std::move(next)</code><ins>, and
<code><i>trailing_empty_</i></code> with <code><i>cur_</i> == <i>next_</i>.begin()</code></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.outer">[range.lazy.split.outer]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>outer-iterator</i>(<i>Parent</i>&amp; parent, iterator_t&lt;<i>Base</i>&gt; current)
  requires forward_range&lt;<i>Base</i>&gt;;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Initializes <code><i>parent_</i></code> with <code>addressof(parent)</code><ins>,</ins> <del>and</del> 
<code><i>current_</i></code> with <code>std::move(current)</code><ins>, and <code><i>trailing_empty_</i></code> with 
<code><i>current_</i> == ranges::end(parent.<i>base_</i>)</code></ins>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4018"><a href="4018">4018</a>. <code>ranges::to</code>'s copy branch is underconstrained</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2023-11-25 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike other branches that return a prvalue <code>C</code>, this branch's <code>C</code> is returned by elidable move, 
indicating that <code>C</code> needs to be move constructible (<a href="https://godbolt.org/z/dfqnx6Txq">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;vector&gt;

struct nonmovable {
  nonmovable() = default;
  nonmovable(const nonmovable&amp;) = delete;
  nonmovable&amp; operator=(const nonmovable&amp;) = delete;
};

template&lt;class T&gt;
struct nonmovable_vector : std::vector&lt;T&gt;, nonmovable { };

int main() {
  int arr[] = {42};
  auto v = std::ranges::to&lt;nonmovable_vector&lt;int&gt;&gt;(arr); // <span style="color:red;font-weight:bolder">hard error</span>
}
</pre></blockquote>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4018"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>C</code> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code>C</code> does not satisfy <code>input_range</code> or 
<code>convertible_to&lt;range_reference_t&lt;R&gt;, range_value_t&lt;C&gt;&gt;</code> is <code>true</code>:</p>
<ol style="list-style-type: none">
<li><p>(2.1.1) &mdash; [&hellip;]</p></li>
<li><p>(2.1.2) &mdash; [&hellip;]</p></li>
<li><p>(2.1.3) &mdash; [&hellip;]</p></li>
<li><p>(2.1.4) &mdash; Otherwise, if</p>
<ol style="list-style-type: none">
<li><p><ins>(2.1.4.?) &mdash; <code>move_constructible&lt;C&gt;</code> is <code>true</code>,</ins></p></li>
<li><p>(2.1.4.1) &mdash; <code>constructible_from&lt;C, Args...&gt;</code> is <code>true</code>, and</p></li>
<li><p>(2.1.4.2) &mdash; <code><i>container-insertable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</code> is <code>true</code>:</p>
<blockquote><pre>
C c(std::forward&lt;Args&gt;(args)...);
if constexpr (sized_range&lt;R> &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
  c.reserve(static_cast&lt;range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::copy(r, <i>container-inserter</i>&lt;range_reference_t&lt;R&gt;&gt;(c));
</pre></blockquote></li>
</ol>
</li>
<li><p>(2.1.5) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol></li>
<li><p>(2.2) &mdash; [&hellip;]</p></li>
<li><p>(2.3) &mdash; Otherwise, the program is ill-formed.</p></li>
</ol>

</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4019"><a href="4019">4019</a>. Reversing an infinite range leads to an infinite loop</h3>
<p><b>Section:</b> 25.7.21 <a href="https://timsong-cpp.github.io/cppwp/range.reverse">[range.reverse]</a> <b>Status:</b> <a href="lwg-active.html#SG9">SG9</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2023-11-25 <b>Last modified:</b> 2024-11-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.reverse">issues</a> in [range.reverse].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG9">SG9</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following:
</p>
<blockquote><pre>
auto a = views::iota(0) | views::reverse;
auto b = views::repeat(42) | views::reverse;
</pre></blockquote>
<p>
Here, <code>views::iota(0)</code> and <code>views::repeat(42)</code> are both non-common bidirectional (even random-access) ranges. 
They are also infinite ranges, even if the standard doesn't really recognize that. 
<p/>
<code>views::reverse</code> on a non-common range will actually compute the end iterator for you. So while both declarations 
of <code>a</code> and <code>b</code> above compile, attempting to use either in any way will lead to an infinite loop when you 
<code>try a.begin()</code> or <code>b.begin()</code>.
<p/>
A reddit post suggested disallowing reversing a non-common range but that likely breaks reasonable use-cases. We could at
the very least recognize ranges whose sentinel is <code>unreachable_t</code> and reject those from consideration. For instance, 
we could change 24.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.iter.op.next">[range.iter.op.next]</a>/3 to <i>Mandate</i> that <code>S</code> is not <code>unreachable_t</code>.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Ask SG9 to look. Probably needs a paper.
</p>
<p>
Infinite ranges are invalid and giving an invalid range to the library is
undefined. But this is not a particularly satisfactory answer given that
we provide such ranges ourselves...
</p>

<p><i>[St. Louis 2024-06-28; LWG and SG9 joint session]</i></p>

<p>
Poll: SG9 and LWG believe this is not a defect?
<pre>
|SF| F| N| A|SA|
| 3| 3| 0| 2| 0|
</pre>
Weak consensus => needs to go to LEWG
</p>
<p>
Poll: SG9 and LWG agree that standard could do something to create
fewer sharp edges here, and we encourage a paper exploring options.
<pre>
|SF| F| N| A|SA|
| 4| 2| 2| 0| 0|
</pre>
</p>

<p><i>[2024-11-14; Related to LWG <a href="4097" title="views::reverse should be specialized for some view types (Status: LEWG)">4097</a>.]</i></p>



<p id="res-4019"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4020"><a href="4020">4020</a>. <code>extents::<i>index-cast</i></code> weirdness</h3>
<p><b>Section:</b> 23.7.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.extents.expo">[mdspan.extents.expo]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2023-11-29 <b>Last modified:</b> 2023-12-02</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The exposition-only static member <code><i>index-cast</i></code> of <code>extents</code> is specified as 
(23.7.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.extents.expo">[mdspan.extents.expo]</a>/9):
</p>
<blockquote>
<pre>
template&lt;class OtherIndexType&gt;
static constexpr auto <i>index-cast</i>(OtherIndexType&amp;&amp; i) noexcept;
</pre>
<blockquote>
<p>
-9- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If <code>OtherIndexType</code> is an integral type other than <code>bool</code>, then equivalent 
to <code>return i;</code>,</p></li>
<li><p>(9.2) &mdash; otherwise, equivalent to <code>return static_cast&lt;index_type&gt;(i);</code>.</p></li>
</ol>
<p>
[<i>Note 1</i>: This function will always return an integral type other than <code>bool</code>. Since this function's 
call sites are constrained on convertibility of <code>OtherIndexType</code> to <code>index_type</code>, integer-class types 
can use the <code>static_cast</code> branch without loss of precision. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
<p>
This function returns <code>T</code> when passed an rvalue of <i>cv</i>-unqualified integral type <code>T</code>, 
but <code>index_type</code> when passed a <i>cv</i>-qualified and/or lvalue argument of any integral type. It 
would seem more consistent and easier to reason about if 9.1 was instead conditional on 
<code>remove_cvref_t&lt;OtherIndexType&gt;</code>.
</p>


<p id="res-4020"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 23.7.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.extents.expo">[mdspan.extents.expo]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherIndexType&gt;
  static constexpr auto <i>index-cast</i>(OtherIndexType&amp;&amp; i) noexcept;
</pre>
<blockquote>
<p>
-9- <i>Effects</i>:
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If <code><ins>remove_cvref_t&lt;</ins>OtherIndexType<ins>&gt;</ins></code> 
is an integral type other than <code>bool</code>, then equivalent to <code>return i;</code>,</p></li>
<li><p>(9.2) &mdash; otherwise, equivalent to <code>return static_cast&lt;index_type&gt;(i);</code>.</p></li>
</ol>
<p>
[<i>Note 1</i>: This function will always return an integral type other than <code>bool</code>. Since this function's 
call sites are constrained on convertibility of <code>OtherIndexType</code> to <code>index_type</code>, integer-class types 
can use the <code>static_cast</code> branch without loss of precision. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4021"><a href="4021">4021</a>. <code>mdspan::is_always_<i>meow</i>()</code> should be <code>noexcept</code></h3>
<p><b>Section:</b> 23.7.3.6.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.overview">[mdspan.mdspan.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2023-12-07 <b>Last modified:</b> 2023-12-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It can easily be proven that <code>mdspan::is_always_<i>meow</i>()</code> is preconditionless and can never throw exceptions. 
microsoft/STL has already shipped a <code>noexcept</code>-strengthened implementation, libc++ would like to (see 
<a href="https://github.com/llvm/llvm-project/pull/74254">llvm/llvm-project#74254</a>), and together we believe that the 
Standard should simply mandate <code>noexcept</code> so users can rely on this. The proof is:
</p>
<ul>
<li><p>N4964 23.7.3.6.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.overview">[mdspan.mdspan.overview]</a>/3:</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<code>LayoutPolicy</code> shall meet the layout mapping policy requirements (23.7.3.4.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.policy.reqmts">[mdspan.layout.policy.reqmts]</a>) [&hellip;]
</p>
</blockquote>
</li>
<li>
<p>
23.7.3.4.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.policy.reqmts">[mdspan.layout.policy.reqmts]</a>/1: 
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
A type <code>MP</code> meets the <i>layout mapping policy</i> requirements 
if for a type <code>E</code> that is a specialization of <code>extents</code>, <code>MP::mapping&lt;E&gt;</code> is valid and denotes 
a type <code>X</code> that meets the layout mapping requirements (23.7.3.4.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.reqmts">[mdspan.layout.reqmts]</a>) [&hellip;]
</p>
</blockquote>
</li>
<li><p>23.7.3.4.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.reqmts">[mdspan.layout.reqmts]</a>/1, /1.5, /22, /24, /26:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
A type <code>M</code> meets the <i>layout mapping</i> requirements if
<p/>
[&hellip;]
</p>
<ol style="list-style-type: none">
<li><p>
&mdash; the following types and expressions are well-formed and have the specified semantics.
<p/>
[&hellip;]
<p/>
<code>M::is_always_unique()</code>
<p/>
<i>Result</i>: A constant expression (7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) of type <code>bool</code>.
<p/>
[&hellip;]
<p/>
<code>M::is_always_exhaustive()</code>
<p/>
<i>Result</i>: A constant expression (7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) of type <code>bool</code>.
<p/>
[&hellip;]
<p/>
<code>M::is_always_strided()</code>
<p/>
<i>Result</i>: A constant expression (7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>) of type <code>bool</code>.
</p></li>
</ol>
</blockquote>
</li>
</ul>
<p>
Constant expressions can surely be obtained without throwing exceptions.
</p>


<p id="res-4021"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<ol>

<li><p>Modify 23.7.3.6.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.overview">[mdspan.mdspan.overview]</a>, class template <code>mdspan</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
static constexpr bool is_always_unique() <ins>noexcept</ins>
  { return mapping_type::is_always_unique(); }
static constexpr bool is_always_exhaustive() <ins>noexcept</ins>
  { return mapping_type::is_always_exhaustive(); }
static constexpr bool is_always_strided() <ins>noexcept</ins>
  { return mapping_type::is_always_strided(); }
[&hellip;]
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4022"><a href="4022">4022</a>. Ambiguity in the formatting of negative years with format specifier <code>%C</code></h3>
<p><b>Section:</b> 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-12-08 <b>Last modified:</b> 2023-12-09</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.format">active issues</a> in [time.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.format">issues</a> in [time.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 101, [tab:time.format.spec] reads:
</p>
<table border="1">
<caption>Table 101 &mdash; Meaning of conversion specifiers  [tab:time.format.spec]</caption>
<tr style="text-align:center">
<th>Specifier</th>
<th>Replacement</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td><code>%C</code></td>
<td>The year divided by <code>100</code> using floored division. If the result is a single decimal digit, it<br/>
is prefixed with <code>0</code>. The modified command <code>%EC</code> produces the locale's alternative<br/>
representation of the century.</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>

<p>
When the year is in range <code>[-99, -10]</code>, it is unclear whether the result (in range <code>[-9, -1]</code>) 
is considered as a single decimal digit, and there is implementation divergence 
(<a href="https://github.com/llvm/llvm-project/issues/74727">llvm/llvm-project#74727</a>).
<p/>
<b>Daniel:</b>
<p/>
This issue is somewhat related to LWG <a href="3831" title="Two-digit formatting of negative year is ambiguous (Status: New)">3831</a>.
</p>


<p id="res-4022"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4964" title=" Working Draft, Programming Languages  C++">N4964</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b>
</p>

<ol>

<li><p>Modify 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>, Table 101 [tab:time.format.spec], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 101 &mdash; Meaning of conversion specifiers  [tab:time.format.spec]</caption>
<tr style="text-align:center">
<th>Specifier</th>
<th>Replacement</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td><code>%C</code></td>
<td>The year divided by <code>100</code> using floored division. If the result is <del>a single decimal digit</del><ins>in range <code>[0, 9]</code></ins>, it<br/>
is prefixed with <code>0</code>. The modified command <code>%EC</code> produces the locale's alternative<br/>
representation of the century.</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>
</li>
</ol>

<p>
<b>Option B:</b>
</p>

<ol>

<li><p>Modify 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a>, Table 101 [tab:time.format.spec], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 101 &mdash; Meaning of conversion specifiers  [tab:time.format.spec]</caption>
<tr style="text-align:center">
<th>Specifier</th>
<th>Replacement</th>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
<tr>
<td><code>%C</code></td>
<td>The year divided by <code>100</code> using floored division. If the result is <del>a single decimal digit</del><ins>in range <code>[-9, 9]</code></ins>, it<br/>
is prefixed with <code>0</code>. The modified command <code>%EC</code> produces the locale's alternative<br/>
representation of the century.</td>
</tr>
<tr>
<td colspan="2" align="center">
<code>[&hellip;]</code>
</td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4026"><a href="4026">4026</a>. Assignment operators of <code>std::expected</code> should propagate triviality</h3>
<p><b>Section:</b> 22.8.6.4 <a href="https://timsong-cpp.github.io/cppwp/expected.object.assign">[expected.object.assign]</a>, 22.8.7.4 <a href="https://timsong-cpp.github.io/cppwp/expected.void.assign">[expected.void.assign]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-12-16 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#expected.object.assign">active issues</a> in [expected.object.assign].</p>
<p><b>View all other</b> <a href="lwg-index.html#expected.object.assign">issues</a> in [expected.object.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, only copy and move constructors of <code>std::expected</code> are required to propagate triviality, 
while copy and move assignment operators are not. Given that the assignment operators of <code>std::optional</code> 
and <code>std::variant</code> are already required to propagate triviality, it seems to me that we should also 
apply such requirements for <code>std::expected</code>.
<p/>
Such changes are being made in libc++ (<a href="https://github.com/llvm/llvm-project/pull/74768">llvm/llvm-project#74768</a>). 
And it may be desired to make the triviality improvement portable.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll in January 2024.
A few votes for Tentatively Ready, others thought it needed more consideration.
</p>



<p id="res-4026"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>

<li><p>Modify 22.8.6.4 <a href="https://timsong-cpp.github.io/cppwp/expected.object.assign">[expected.object.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr expected&amp; operator=(const expected&amp; rhs);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-4- <i>Remarks</i>: This operator is defined as deleted unless:
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
</ol>
<p>
<ins>-?- This operator is trivial if:</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; <code>is_trivially_copy_constructible_v&lt;T&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.2) &mdash; <code>is_trivially_copy_assignable_v&lt;T&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.3) &mdash; <code>is_trivially_destructible_v&lt;T&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.4) &mdash; <code>is_trivially_copy_constructible_v&lt;E&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.5) &mdash; <code>is_trivially_copy_assignable_v&lt;E&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.6) &mdash; <code>is_trivially_destructible_v&lt;E&gt;</code> is <code>true</code>.</ins></p></li>
</ol>
</blockquote>
<pre>
constexpr expected&amp; operator=(expected&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-5- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-8- <i>Remarks</i>: The exception specification is equivalent to:
<p/>
[&hellip;]
</p>
<p>
<ins>-?- This operator is trivial if:</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; <code>is_trivially_move_constructible_v&lt;T&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.2) &mdash; <code>is_trivially_move_assignable_v&lt;T&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.3) &mdash; <code>is_trivially_destructible_v&lt;T&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.4) &mdash; <code>is_trivially_move_constructible_v&lt;E&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.5) &mdash; <code>is_trivially_move_assignable_v&lt;E&gt;</code> is <code>true</code>, and</ins></p></li>
<li><p><ins>(?.6) &mdash; <code>is_trivially_destructible_v&lt;E&gt;</code> is <code>true</code>.</ins></p></li>
</ol>

</blockquote>
</blockquote>
</li>

<li><p>Modify 22.8.7.4 <a href="https://timsong-cpp.github.io/cppwp/expected.void.assign">[expected.void.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr expected&amp; operator=(const expected&amp; rhs);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-3- <i>Remarks</i>: This operator is defined as deleted unless <code>is_copy_assignable_v&lt;E&gt;</code> 
is <code>true</code> and <code>is_copy_constructible_v&lt;E&gt;</code> is <code>true</code>.
<p/>
<ins>-?- This operator is trivial if <code>is_trivially_copy_constructible_v&lt;E&gt;</code>, 
<code>is_trivially_copy_assignable_v&lt;E&gt;</code>, and <code>is_trivially_destructible_v&lt;E&gt;</code> are 
all <code>true</code>.</ins>
</p>
</blockquote>
<pre>
constexpr expected&amp; operator=(expected&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-6- <i>Remarks</i>: The exception specification is equivalent to <code>is_nothrow_move_constructible_v&lt;E&gt; &amp;&amp;
is_nothrow_move_assignable_v&lt;E&gt;</code>.
<p/>
-7- This operator is defined as deleted unless <code>is_move_constructible_v&lt;E&gt;</code> is <code>true</code> 
and <code>is_move_assignable_v&lt;E&gt;</code> is <code>true</code>.
<p/>
<ins>-?- This operator is trivial if <code>is_trivially_move_constructible_v&lt;E&gt;</code>, 
<code>is_trivially_move_assignable_v&lt;E&gt;</code>, and <code>is_trivially_destructible_v&lt;E&gt;</code> are 
all <code>true</code>.</ins>
</p>

</blockquote>
</blockquote>
</li>

</ol>







<hr>
<h3 id="4028"><a href="4028">4028</a>. <code>std::is_(nothrow_)convertible</code> should be reworded to avoid dependence on the <code>return</code> statement</h3>
<p><b>Section:</b> 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-12-18 <b>Last modified:</b> 2023-12-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.rel">active issues</a> in [meta.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification for <code>std::is_convertible</code> is sensitive to the requirements for the <code>return</code> 
statements. As a result, the requirements were accidentally changed by <a href="https://wg21.link/P0135R1" title=" Wording for guaranteed copy elision through simplified value categories">P0135R1</a> and then changed back by 
CWG issue <a href="https://wg21.link/cwg2426">2426</a>. The current revision of <a href="https://wg21.link/P2748" title=" Disallow Binding a Returned Glvalue to a Temporary">P2748</a> also plans to 
change the wording for <code>std::is_convertible</code> to avoid actual behavioral changing.
<p/>
IMO it's better to specify <code>std::is_convertible</code> in a such way that is independent to <code>return</code> statements. 
The proposed resolution matches what mainstream implementations do, and should resolve LWG <a href="3400" title="Does is_nothrow_convertible consider destruction of the destination type? (Status: New)">3400</a> together.
</p>


<p id="res-4028"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>

<li><p>Modify 21.3.8 <a href="https://timsong-cpp.github.io/cppwp/meta.rel">[meta.rel]</a> as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 49 &mdash; Type relationship predicates [tab:meta.rel]</caption>
<tr style="text-align:center">
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>
<tr>
<td>[&hellip;]</td>
<td>[&hellip;]</td>
<td>[&hellip;]</td>
</tr>
<tr>
<td>
<pre>
template&lt;class From, class To&gt;
struct is_convertible;
</pre>
</td>
<td><i>see below</i></td>
<td>
<code>From</code> and <code>To</code> shall be<br/>
complete types, <code><i>cv</i> void</code>, or arrays of<br/>
unknown bound.
</td>
</tr>
<tr>
<td>
<pre>
template&lt;class From, class To&gt;
struct is_nothrow_convertible;
</pre>
</td>
<td>
<code>is_convertible_v&lt;From,<br/>
To&gt;</code> is <code>true</code> and <del>the</del><br/>
<del>conversion, as defined by</del><br/>
<del><code>is_convertible</code>, is known</del><br/>
<del>not to throw any exceptions</del><br/>
<ins>either both <code>From</code> and <code>To</code><br/>
are <code><i>cv</i> void</code>, or the function call<br/>
expression used for specifying <code>is_convertible</code><br/>
is non-throwing</ins> (7.6.2.7 <a href="https://timsong-cpp.github.io/cppwp/expr.unary.noexcept">[expr.unary.noexcept]</a>)
</td>
<td>
<code>From</code> and <code>To</code> shall be<br/>
complete types, <code><i>cv</i> void</code>, or arrays of<br/>
unknown bound.
</td>
</tr>
<tr>
<td>[&hellip;]</td>
<td>[&hellip;]</td>
<td>[&hellip;]</td>
</tr>
</table>

<p>
-5- The predicate condition for a template specialization <code>is_convertible&lt;From, To&gt;</code> 
shall be satisfied if and only if <del>the return expression in the following code would be well-formed, 
including any implicit conversions to the return type of the function:</del>
</p>
<blockquote><pre>
<del>To test() {
  return declval&lt;From&gt;();
}</del>
</pre></blockquote>
<p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; either both <code>From</code> and <code>To</code> are <code><i>cv</i> void</code>, or</ins></p></li>
<li><p><ins>(?.2) &mdash; <code>To</code> is neither array nor function type and the function call expression 
<code><i>conv-dest</i>(declval&lt;From&gt;())</code> would be well-formed when treated as an unevaluated operand, 
where <code><i>conv-dest</i></code> is a hypothetical function declared as</ins></p>
<blockquote><pre>
<ins>void <i>conv-dest</i>(To) noexcept;</ins>
</pre></blockquote>
<p>
<ins>.</ins>
</p>
</li>
</ol>
<p/>
[<i>Note 2</i>: This requirement gives well-defined results for reference types, array types, function types, 
and <i>cv</i> <code>void</code>. &mdash; <i>end note</i>]
<p/>
Access checking is performed in a context unrelated to <code>To</code> and <code>From</code>. Only the validity of the 
immediate context of the expression of the <del>return statement (8.8.4 <a href="https://timsong-cpp.github.io/cppwp/stmt.return">[stmt.return]</a>)</del>
<ins>function call expression (7.6.1.3 <a href="https://timsong-cpp.github.io/cppwp/expr.call">[expr.call]</a>)</ins> (including initialization of the 
<del>returned</del><ins>parameter</ins> object or reference) is considered.
</p>
</blockquote>
</li>

</ol>







<hr>
<h3 id="4029"><a href="4029">4029</a>. <code>basic_string</code> accidentally fails to meet the reversible container requirements</h3>
<p><b>Section:</b> 27.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/basic.string.general">[basic.string.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2023-12-18 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string.general">issues</a> in [basic.string.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity requirements for a reversible container (23.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/container.rev.reqmts">[container.rev.reqmts]</a>) are that each 
function must have constant complexity. The corresponding member functions in 27.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.iterators">[string.iterators]</a> 
have no complexity requirements, and <code>basic_string</code> unintentionally is not a reversible container 
(unless the implementation coincidentally provides constant complexity member functions).
</p>

<p><i>[2024-03-15; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>Could harmonize with <code>vector</code> by saying:
"A basic_string meets all of the requirements of a contiguous container
(23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a>) and of a reversible container
(23.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/container.rev.reqmts">[container.rev.reqmts]</a>)."
It's not a sequence container (see LWG <a href="718" title="basic_string is not a sequence (Status: NAD Editorial)">718</a>)
but as per 23.2.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.alloc.reqmts">[container.alloc.reqmts]</a> p1 it is allocator-aware
(although it doesn't use <code>construct</code> and <code>destroy</code>).
</p>
<p>
Not comfortable removing the detailed descriptions for those members.
We don't have the "Descriptions are only provided here for operations on [...]
that are not described in one of these tables" wording that the containers have.
</p>



<p id="res-4029"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> The proposed wording is similar to the specification in 23.3.13.1 <a href="https://timsong-cpp.github.io/cppwp/vector.overview">[vector.overview]</a> p2 
and suggests to simply strike 27.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.iterators">[string.iterators]</a> because it doesn't say anything new compared to 
23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a> and 23.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/container.rev.reqmts">[container.rev.reqmts]</a>.
<p/>
Alternatively, one could add a
<p/>
<ins><i>Complexity</i>: Constant.</ins>
<p/>
paragraph to each function in 27.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.iterators">[string.iterators]</a>, but that would be less clearer and would not
explicitly say <code>basic_string</code> meets the reversible container requirements.
] 
</p>
</blockquote>

<ol>

<li><p>Modify 27.4.3.1 <a href="https://timsong-cpp.github.io/cppwp/basic.string.general">[basic.string.general]</a> as indicated:</p>

<blockquote>
<p>
-2- A specialization of <code>basic_string</code> is a contiguous container (23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a>) <ins>and a
reversible container (23.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/container.rev.reqmts">[container.rev.reqmts]</a>)</ins>.
<p/>
-3- In all cases, <code>[data(), data() + size()]</code> is a valid range, <code>data() + size()</code> points at 
an object with value <code>charT()</code> (a "null terminator"), and <code>size() &lt;= capacity()</code> is <code>true</code>.
</p>
<blockquote><pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
           class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
    [&hellip;]
    // <i><del>27.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.iterators">[string.iterators]</a>,</del> iterators</i>
    constexpr iterator begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator end() noexcept;
    constexpr const_iterator end() const noexcept;
  
    constexpr reverse_iterator rbegin() noexcept;
    constexpr const_reverse_iterator rbegin() const noexcept;
    constexpr reverse_iterator rend() noexcept;
    constexpr const_reverse_iterator rend() const noexcept;
  
    constexpr const_iterator cbegin() const noexcept;
    constexpr const_iterator cend() const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend() const noexcept;
  
    // <i>27.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a>, capacity</i>
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
[&hellip;]
</blockquote>
</li>

<li><p>Remove subclause 27.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/string.iterators">[string.iterators]</a> in its entirety:</p>

<blockquote>
<p>
<del><b>23.4.3.4 Iterator support [string.iterators]</b></del>
</p>
<pre>
<del>constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr const_iterator cbegin() const noexcept;</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Returns</i>: An iterator referring to the first character in the string.</del>
</p>
</blockquote>
[&hellip;]
<pre>
<del>constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;</del>
</pre>
<blockquote>
<p>
<del>-4- <i>Returns</i>: An iterator which is semantically equivalent to <code>reverse_iterator(begin())</code>.</del>
</p>
</blockquote>
</blockquote>

</li>

</ol>







<hr>
<h3 id="4032"><a href="4032">4032</a>. Possibly invalid types in the constraints of constructors of <code>std::shared_ptr</code></h3>
<p><b>Section:</b> 20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2023-12-25 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, 20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a>/3 and /9.1 says <code>Y(*)[N]</code> and <code>Y(*)[]</code>, 
however, they may be invalid types when <code>Y</code> is an array type of unknown bound or a function type. 
Presumably, the constraints should be satisfied only when the mentioned <code>Y(*)[N]</code> or <code>Y(*)[]</code> is valid.
</p>

<p><i>[2024-03-15; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p>
Jens pointed out that "convertible", as a core language concept,
goes from "expression" to "type", not from "type" to "type".
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>

<li><p>Modify 20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: When <code>T</code> is an array type, the expression <code>delete[] p</code> is well-formed 
and either <code>T</code> is <code>U[N]</code> and <code>Y(*)[N]</code> is <ins>a valid type and</ins> convertible to 
<code>T*</code>, or <code>T</code> is <code>U[]</code> and <code>Y(*)[]</code> is <ins>a valid type and</ins> convertible to 
<code>T*</code>. When <code>T</code> is not an array type, the expression <code>delete p</code> is well-formed and 
<code>Y*</code> is convertible to <code>T*</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template&lt;class D&gt; shared_ptr(nullptr_t p, D d);
template&lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-9- <i>Constraints</i>: <code>is_move_constructible_v&lt;D&gt;</code> is <code>true</code>, and <code>d(p)</code> 
is a well-formed expression. For the first two overloads:
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If <code>T</code> is an array type, then either <code>T</code> is <code>U[N]</code> and 
<code>Y(*)[N]</code> is <ins>a valid type and</ins> convertible to <code>T*</code>, or <code>T</code> is <code>U[]</code> and
<code>Y(*)[]</code> is <ins>a valid type and</ins> convertible to <code>T*</code>.</p></li>
<li><p>(9.2) &mdash; If <code>T</code> is not an array type, then <code>Y*</code> is convertible to <code>T*</code>.</p></li>
</ol>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>


</blockquote>

<p><i>[2024-03-15; Jonathan provides alternative wording]</i></p>

<p>
Can we just use <code>is_convertible_v&lt;Y(*)[N], T*&gt;</code>?
With <code class='backtick'>enable_if</code>-style SFINAE an invalid type will cause substitution failure
and with a <em>requires-clause</em> the constraints won't be satisfied.
Either way we get the desired outcome.
Also, the delete expression is already required to be well-formed, which
rules out function types, so that part of the issue is NAD.
</p>



<p id="res-4032"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>

<li><p>Modify 20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: When <code>T</code> is an array type, the expression <code>delete[] p</code> is well-formed 
and either<ins>:</ins>
<del><code>T</code> is <code>U[N]</code> and <code>Y(*)[N]</code> is convertible to 
<code>T*</code>, or <code>T</code> is <code>U[]</code> and <code>Y(*)[]</code> is convertible to 
<code>T*</code>.</del>
</p>
<ol style="list-style-type: none">
<li>&mdash;
<ins>
<code>is_bounded_array_v&lt;T&gt; &amp;&amp;
is_convertible_v&lt;Y(*)[rank_v&lt;T&gt;], T*&gt;</code> is <code>true</code>,
or
</ins>
</li>
<li>&mdash;
<ins>
<code>is_unbounded_array_v&lt;T&gt; &amp;&amp; is_convertible_v&lt;Y(*)[], T*&gt;</code> is <code>true</code>.
</ins>
</li>
</ol>
<p>
When <code>T</code> is not an array type, the expression <code>delete p</code> is well-formed and
<del><code>Y*</code> is convertible to <code>T*</code></del>
<ins><code>is_convertible_v&lt;Y*, T*&gt;</code> is <code>true</code></ins>.
</p>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
template&lt;class D&gt; shared_ptr(nullptr_t p, D d);
template&lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);
</pre>
<blockquote>
<p>
-9- <i>Constraints</i>: <code>is_move_constructible_v&lt;D&gt;</code> is <code>true</code>, and <code>d(p)</code>
is a well-formed expression. For the first two overloads:
</p>
<ol style="list-style-type: none">
<li><p>(9.1) &mdash; If <code>T</code> is an array type, then either<ins>:</ins>
<del>
<code>T</code> is <code>U[N]</code> and
<code>Y(*)[N]</code> is convertible to <code>T*</code>, or <code>T</code> is <code>U[]</code> and
<code>Y(*)[]</code> is convertible to <code>T*</code>.
</del>
</p>
<ol style="list-style-type: none">
<li>&mdash;
<ins>
<code>is_bounded_array_v&lt;T&gt; &amp;&amp;
is_convertible_v&lt;Y(*)[rank_v&lt;T&gt;], T*&gt;</code> is <code>true</code>,
or
</ins>
</li>
<li>&mdash;
<ins>
<code>is_unbounded_array_v&lt;T&gt; &amp;&amp;
is_convertible_v&lt;Y(*)[], T*&gt;</code> is <code>true</code>.
</ins>
</li>
</ol>
</li>
<li><p>(9.2) &mdash; If <code>T</code> is not an array type, then
<del><code>Y*</code> is convertible to <code>T*</code></del>
<ins><code>is_convertible_v&lt;Y*, T*&gt;</code> is <code>true</code></ins>.
</p></li>
</ol>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>







<hr>
<h3 id="4033"><a href="4033">4033</a>. &sect;[macro.names] defining macros after importing the standard library</h3>
<p><b>Section:</b> 16.4.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2023-12-27 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#macro.names">active issues</a> in [macro.names].</p>
<p><b>View all other</b> <a href="lwg-index.html#macro.names">issues</a> in [macro.names].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are several places where the standard talks about what happens when including
a header, and only sometimes do we address the notion of importing a header unit, or
importing a standard library module.

One global concern is that 16.4.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> prohibits users defining macros with a name
that matches a name from any standard library header, but only if a standard library header
is included. We should maintain that same prohibition on importing a standard header unit,
and importing a standard library module.

In general, we probably want some front matter to address the include vs. import wording
issue in one place, rather than trying to update every usage &mdash; if it is already there I could
not find it. It is also likely that some uses will want to say specific things about import vs.
include and those cases will be handed to audit for if we have blanket front-matter wording.

I also question whether "shall not" is the right way to prohibit users defining macros in their
own code. Must a "shall not" restriction be diagnosed? I think the "right" answer is to make
the program ill-formed, no diagnostic required. That is a foul answer, but UB does not really
fit as there is no actual behavior to be undefined, unless we mean the process of translating
the program is undefined, in which case IFNDR is the better way to say that.

If we expect implementations to diagnose users defining macros that match library names we
should say so more clearly, but I am not aware of any current tool-chain that does so.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Why should <code class='backtick'>import std</code> care if I <code class='backtick'>#define vector potato</code>?"
</p>



<p id="res-4033"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>

<li><p>Modify 16.4.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> as indicated:</p>

<blockquote>
<p>
-1- <ins>If a translation unit includes a standard header, imports a standard header unit, or imports a
standard library module, and provides a name specified in the standard library as an argument to <code>#define</code> 
or <code>#undef</code>, the program is ill-formed, no diagnostic required</ins><del>A translation unit that includes 
a standard library header shall not <code>#define</code> or <code>#undef</code> names declared in any standard library header</del>.
<p/>
-2- A translation unit shall not <code>#define</code> or <code>#undef</code> names lexically identical to keywords, to the identifiers 
listed in Table [tab:lex.name.special], or to the <i>attribute-token</i>s described in 9.13 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr">[dcl.attr]</a>, except that 
the names <code>likely</code> and <code>unlikely</code> may be defined as function-like macros (15.7 <a href="https://timsong-cpp.github.io/cppwp/cpp.replace">[cpp.replace]</a>).
</p>
</blockquote>

</li>

</ol>







<hr>
<h3 id="4034"><a href="4034">4034</a>. Clarify specification of <code>std::min</code> and <code>std::max</code></h3>
<p><b>Section:</b> 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2023-12-29 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All standard libraries effectively use the same implementation for <code>std::min(a, b)</code>, 
namely something along the lines of
</p>
<blockquote>
<pre>
return __b &lt; __a ? __b : __a;
</pre>
</blockquote>
<ul>
<li><p><a href="https://github.com/microsoft/STL/blob/a8888806c6960f1687590ffd4244794c753aa819/stl/inc/utility#L100C22-L100C22">MSVC STL</a></p></li>
<li><p><a href="https://github.com/gcc-mirror/gcc/blob/748a4e9069e41bec1f27aa369c19f9756d8c1494/libstdc%2B%2B-v3/include/bits/stl_algobase.h#L237">libstdc++</a></p></li>
<li><p><a href="https://github.com/llvm/llvm-project/blob/b6daac023a72235108bddc17a5245a9371cd6147/libcxx/include/__algorithm/min.h#L36">libc++</a></p></li>
</ul>
<p>
However, the wording in 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> is not so clear:
</p>
<blockquote>
<p>
<i>Returns</i>: The smaller value. Returns the first argument when the arguments are equivalent.
</p>
</blockquote>
<p>
This leaves a few questions open:
</p>
<ul>
<li><p>How is the smaller value determined? Must it be through the less-than operator?</p></li>
<li><p>For <code>std::max</code>, can the "larger" value be determined through the greater-than operator or must it be through less-than?</p></li>
</ul>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Suggestions for NAD. "The result can be determined in any way that is allowed
by the constaints the function imposes on its arguments. Since the arguments
must be <i>Cpp17LessThanComparable</i>, obviously it has to use a less-than
operation, because it can't assume any other operation is possible."
Some of the submitter's questions could be addressed with an
<a href="https://github.com/cplusplus/draft/pull/6776">editorial change</a>.
</p>



<p id="res-4034"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>

<li><p>Modify 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>T</code> meets the <i>Cpp17LessThanComparable</i> requirements (Table 29).</ins>
<p/>
<ins>-?- <i>Returns</i>: <code>b &lt; a ? b : a</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;class T, class Compare&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <code>comp(b, a) ? b : a</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;class T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
constexpr const T&amp; ranges::min(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
</pre>
<blockquote>
<p>
<del>-1- <i>Preconditions</i>: For the first form, <code>T</code> meets the <i>Cpp17LessThanComparable</i> requirements (Table 29).</del>
<p/>
-2- <i>Returns</i>: <ins><code>comp(proj(b), proj(a)) ? b : a</code></ins><del>The smaller value. Returns the first 
argument when the arguments are equivalent</del>.
<p/>
<del>-3- <i>Complexity</i>: Exactly one comparison and two applications of the projection, if any.</del>
<p/>
<del>-4- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code> of the
overloads in namespace <code>std</code>.</del>
</p>
</blockquote>
<pre>
template&lt;class T&gt;
  constexpr T min(initializer_list&lt;T&gt; r);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>. <code>T</code> meets the <i>Cpp17CopyConstructible</i> 
(Table 32) and <i>Cpp17LessThanComparable</i> (Table 29) requirements.</ins>
<p/>
<ins>-?- <i>Returns</i>: The leftmost element <code>x</code> in <code>r</code> where <code>y &lt; x</code> is <code>false</code> 
for all subsequent elements <code>y</code>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons.</ins>
<p/>
<ins>-?- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;class T, class Compare&gt;
  constexpr T min(initializer_list&lt;T&gt; r, Compare comp);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>. <code>T</code> meets the <i>Cpp17CopyConstructible</i> 
requirements (Table 32).</ins>
<p/>
<ins>-?- <i>Returns</i>: The leftmost element <code>x</code> in <code>r</code> where <code>comp(y, x)</code> is <code>false</code> 
for all subsequent elements <code>y</code>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons.</ins>
<p/>
<ins>-?- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;copyable T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr T ranges::min(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
  requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
  constexpr range_value_t&lt;R&gt;
    ranges::min(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
</pre>
<blockquote>
<p>
-5- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>. <del>For the overloads in namespace <code>std</code>, 
<code>T</code> meets the <i>Cpp17CopyConstructible</i> requirements. For the first form, <code>T</code> meets the 
<i>Cpp17LessThanComparable</i> requirements (Table 29).</del>
<p/>
-6- <i>Returns</i>: <ins>The leftmost element <code>x</code> in <code>r</code> where <code>comp(proj(y), proj(x))</code> 
is <code>false</code> for all subsequent elements <code>y</code></ins><del>The smallest value in the input range. 
Returns a copy of the leftmost element when several elements are equivalent to the smallest</del>.
<p/>
-7- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons and twice as many applications of the
projection<del>, if any</del>.
<p/>
<del>-8- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code> of the
overloads in namespace <code>std</code>.</del>
</p>
</blockquote>
<pre>
template&lt;class T&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>T</code> meets the <i>Cpp17LessThanComparable</i> requirements (Table 29).</ins>
<p/>
<ins>-?- <i>Returns</i>: <code>a &lt; b ? b : a</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;class T, class Compare&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <code>comp(a, b) ? b : a</code>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;class T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr const T&amp; ranges::max(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
</pre>
<blockquote>
<p>
<del>-9- <i>Preconditions</i>: For the first form, <code>T</code> meets the <i>Cpp17LessThanComparable</i> requirements (Table 29).</del>
<p/>
-10- <i>Returns</i>: <ins><code>comp(proj(a), proj(b)) ? b : a</code></ins><del>The larger value. Returns the first 
argument when the arguments are equivalent</del>.
<p/>
<del>-11- <i>Complexity</i>: Exactly one comparison and two applications of the projection, if any.</del>
<p/>
<del>-12- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code> 
of the overloads in namespace <code>std</code>.</del>
</p>
</blockquote>
<pre>
template&lt;class T&gt;
  constexpr T max(initializer_list&lt;T&gt; r);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>. <code>T</code> meets the <i>Cpp17CopyConstructible</i> 
(Table 32) and <i>Cpp17LessThanComparable</i> (Table 29) requirements.</ins>
<p/>
<ins>-?- <i>Returns</i>: The leftmost element <code>x</code> in <code>r</code> where <code>x &lt; y</code> is <code>false</code> 
for all subsequent elements <code>y</code>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons.</ins>
<p/>
<ins>-?- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;class T, class Compare&gt;
  constexpr T max(initializer_list&lt;T&gt; r, Compare comp);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>. <code>T</code> meets the <i>Cpp17CopyConstructible</i> 
requirements (Table 32).</ins>
<p/>
<ins>-?- <i>Returns</i>: The leftmost element <code>x</code> in <code>r</code> where <code>comp(x, y)</code> is <code>false</code> 
for all subsequent elements <code>y</code>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons.</ins>
<p/>
<ins>-?- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code>.</ins>
</p>
</blockquote>
<pre>
template&lt;copyable T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr T ranges::max(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
  requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
  constexpr range_value_t&lt;R&gt;
    ranges::max(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
</pre>
<blockquote>
<p>
-13- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>. <del>For the overloads in namespace <code>std</code>, 
<code>T</code> meets the <i>Cpp17CopyConstructible</i> requirements. For the first form, <code>T</code> meets the 
<i>Cpp17LessThanComparable</i> requirements (Table 29).</del>
<p/>
-14- <i>Returns</i>: <ins>The leftmost element <code>x</code> in <code>r</code> where <code>comp(proj(x), proj(y)</code> 
is <code>false</code> for all subsequent elements <code>y</code></ins><del>The largest value in the input range. 
Returns a copy of the leftmost element when several elements are equivalent to the largest</del>.
<p/>
-15- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons and twice as many applications of the
projection<del>, if any</del>.
<p/>
<del>-16- <i>Remarks</i>: An invocation may explicitly specify an argument for the template parameter <code>T</code> 
of the overloads in namespace <code>std</code>.</del>
</p>
</blockquote>
</blockquote>

</li>

</ol>







<hr>
<h3 id="4039"><a href="4039">4039</a>. &sect;[ostream.formatted.print]: Inappropriate usage of <code>badbit</code> in definition of 
<code>vprint_unicode</code>/<code>vprint_nonunicode</code></h3>
<p><b>Section:</b> 31.7.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.print">[ostream.formatted.print]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Kokemller <b>Opened:</b> 2024-01-13 <b>Last modified:</b> 2024-01-20</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.formatted.print">issues</a> in [ostream.formatted.print].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 31.7.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.print">[ostream.formatted.print]</a>, bullet 3.2 there is a mention of <code>badbit</code>:
</p>
<blockquote>
<p>
any exception thrown by the call to <code>vformat</code> is propagated without regard to the
value of <code>os.exceptions()</code> and without turning on <code>ios_base::badbit</code> in the error state of <code>os</code>.
</p>
</blockquote>
<p>
Now the affected functions <code>vprint_unicode</code> and <code>vprint_nonunicode</code> are specified to behave as 
formatted output functions (31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>), which distinguishes two phases:
</p>
<ol>
<li><p>Output <em>generation</em>, which would call <code>setstate(ios_base::failbit)</code> in case of a failure
(which may throw an exception)</p></li>
<li><p>The actual output itself, which would call <code>setstate(ios_base::badbit)</code> in case of an exception</p></li>
</ol>
<p>
The <code>vformat</code> call is obviously part of the first phase (since it generates the output sequence and not
yet the actual output), and any failure here (such as an exception) would under regular formatted output function 
rules set <code>ios_base::failbit</code> and <em>not</em> <code>ios_base::badbit</code> (the latter would indicate a loss 
of the actual output sequence integrity and is therefore set by the second phase in case of an exception).
<p/>
Therefore mentioning <code>ios_base::badbit</code> in (3.2) doesn't really make sense, it could only meaningfully 
refer to <code>ios_base::failbit</code> instead.
</p>


<p id="res-4039"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 31.7.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.print">[ostream.formatted.print]</a> as indicated:</p>

<blockquote>
<pre>
void vprint_unicode(ostream&amp; os, string_view fmt, format_args args);
void vprint_nonunicode(ostream&amp; os, string_view fmt, format_args args);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Behaves as a formatted output function (31.7.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>) 
of <code>os</code>, except that:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; failure to generate output is reported as specified below, and</p></li>
<li><p>(3.2) &mdash; any exception thrown by the call to <code>vformat</code> is propagated without regard 
to the value of <code>os.exceptions()</code> and without turning on <code>ios_base::<ins>failbit</ins><del>badbit</del></code> 
in the error state of <code>os</code>.</p></li>
</ol>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4040"><a href="4040">4040</a>. Contradictory specification of <code>std::tuple_size</code></h3>
<p><b>Section:</b> 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-01-20 <b>Last modified:</b> 2024-03-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>/1 currently says:
</p>
<blockquote>
<p>
All specializations of <code>tuple_size</code> meet the <i>Cpp17UnaryTypeTrait</i> requirements 
(21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) with a base characteristic of <code>integral_constant&lt;size_t, N&gt;</code> 
for some <code>N</code>.
</p>
</blockquote>
<p>
which is probably wrong for <code>std::tuple_size&lt;int&gt;</code> and 
<code>std::tuple_size&lt;std::vector&lt;int&gt;&gt;</code> whose definitions are not provided, and 
contradicts with 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>/4
</p>
<blockquote>
<p>
[&hellip;] Otherwise, it has no member <code>value</code>.
</p>
</blockquote>
<p>
Also, there's currently implementation divergence on whether <code>std::tuple_size&lt;<i>cv</i> T&gt;</code> 
is a complete type when <code>std::tuple_size&lt;T&gt;::value</code> is absent (related to LWG <a href="2770" title="tuple_size&lt;const T&gt; specialization is not SFINAE compatible and breaks decomposition declarations (Status: C++17)">2770</a>). 
Some implementations (e.g. 
<a href="https://github.com/llvm/llvm-project/blob/b1d4265a5f5345065e5c2aedf50787da05ddcc08/libcxx/include/__tuple/tuple_size.h#L29-L47">libc++</a> 
and <a href="https://github.com/gcc-mirror/gcc/blob/615e25c82de97acc17ab438f88d6788cf7ffe1d6/libstdc%2B%2B-v3/include/bits/utility.h#L55-L71">libstdc++</a>) 
treat 22.4.7 <a href="https://timsong-cpp.github.io/cppwp/tuple.helper">[tuple.helper]</a>/4 and D.15 <a href="https://timsong-cpp.github.io/cppwp/depr.tuple">[depr.tuple]</a>/2 as "<code>std::tuple_size&lt;<i>cv</i> T&gt;</code> 
is generated from partial specializations only if <code>std::tuple_size&lt;T&gt;</code> meets the aforementioned conditions", 
while others (e.g. <a href="https://github.com/microsoft/STL/blob/442029c6fa37f1b6f9203357de09672d5704077c/stl/inc/utility#L598-L612">MSVC STL</a>) 
always consider <code>std::tuple_size&lt;<i>cv</i> T&gt;</code> needs to be defined. The latter 
reading seems to be justified by 16.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/contents">[contents]</a>/1 and 22.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.syn">[tuple.syn]</a>.
</p>

<p><i>[2024-03-11; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
The first part of the issue was
<a href="https://github.com/cplusplus/draft/pull/6777">fixed editorially</a>.
</p>



<p id="res-4040"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4041"><a href="4041">4041</a>. The requirements on literal type in [concept.swappable] should be removed</h3>
<p><b>Section:</b> 18.4.9 <a href="https://timsong-cpp.github.io/cppwp/concept.swappable">[concept.swappable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-01-20 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concept.swappable">active issues</a> in [concept.swappable].</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.swappable">issues</a> in [concept.swappable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.4.9 <a href="https://timsong-cpp.github.io/cppwp/concept.swappable">[concept.swappable]</a> bullet (2.3.1) currently requires <code>T</code> to be a literal type in order 
to make the swapping expression a constant expression in that case. The requirement was likely automatically 
enforced by the core language rules in C++20 and thus essentially redundant.
<p/>
However, as <a href="https://wg21.link/P2448R2" title=" Relaxing some constexpr restrictions">P2448R2</a> relaxed the restrictions on constexpr functions, it seems that the 
swapping expression can be a constant expression even if <code>T</code> is not a literal type.
<p/>
E.g. the following program is accepted by GCC/libstdc++ in C++23 mode 
(<a href="https://godbolt.org/z/dWeb3xTxd">demo</a>).
</p>
<blockquote><pre>
#include &lt;concepts&gt;

struct NonLiteral {
  NonLiteral() {} // <span style="color:red;font-weight:bolder">non-constexpr</span>
  constexpr NonLiteral(const NonLiteral&amp;) noexcept {};
  constexpr NonLiteral&amp; operator=(const NonLiteral&amp;) noexcept { return *this; };
};

int main()
{
  NonLiteral x;
  static_assert((std::ranges::swap(x, x), true));
}
</pre></blockquote>
<p>
IMO there's no good reason to additionally require literal types since C++23, which would complicate implementations.
</p>

<p><i>[2024-03-15; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p>
Concerned about 7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>/5.16 (can only modify non-volatile
lvalues of literal type in constant expressions).
Unable see a non-contrived case where this issue matters.
</p>
<p>
N.B. <code>ranges::swap</code> needs the "reified object" treatment;
the repetitions of <code class='backtick'>E1</code> and <code class='backtick'>E2</code> are not pure textual repetitions of the
argument expressions.
</p>
<p>
Can we just eliminate all uses of "literal type"?
</p>
<p>
Wouldn't we still require a constexpr destructor?
</p>



<p id="res-4041"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 18.4.9 <a href="https://timsong-cpp.github.io/cppwp/concept.swappable">[concept.swappable]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>ranges::swap</code> denotes a customization point object (16.3.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a>). 
The expression <code>ranges::swap(E1, E2)</code> for subexpressions <code>E1</code> and <code>E2</code> is expression-equivalent 
to an expression <code>S</code> determined as follows:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>(2.2) &mdash; [&hellip;]</p></li>
<li><p>(2.3) &mdash; Otherwise, if <code>E1</code> and <code>E2</code> are lvalues of the same type <code>T</code> that 
models <code>move_constructible&lt;T&gt;</code> and <code>assignable_from&lt;T&amp;, T&gt;</code>, <code>S</code> is an 
expression that exchanges the denoted values. <code>S</code> is a constant expression if</p>
<ol style="list-style-type: none">
<li><p><del>(2.3.1) &mdash; <code>T</code> is a literal type (6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.types.general">[basic.types.general]</a>),</del></p></li>
<li><p>(2.3.2) &mdash; both <code>E1 = std::move(E2)</code> and <code>E2 = std::move(E1)</code> are constant subexpressions 
(3.15 <a href="https://timsong-cpp.github.io/cppwp/defns.const.subexpr">[defns.const.subexpr]</a>), and</p></li>
<li><p>(2.3.3) &mdash; the full-expressions of the initializers in the declarations</p>
<blockquote><pre>
T t1(std::move(E1));
T t2(std::move(E2));
</pre></blockquote>
<p>
are constant subexpressions.
</p></li>
</ol>
<p>
<code>noexcept(S)</code> is equal to <code>is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;T&gt;</code>.
</p>
</li>
<li><p>(2.4) &mdash; Otherwise, <code>ranges::swap(E1, E2)</code> is ill-formed.</p></li>
</ol>
<p>
[&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4046"><a href="4046">4046</a>. Effects of inserting into or erasing from flat container adaptors when an exception is thrown need to be more permissive</h3>
<p><b>Section:</b> 23.2.7.2 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.except">[associative.reqmts.except]</a>, 23.6.8.1 <a href="https://timsong-cpp.github.io/cppwp/flat.map.overview">[flat.map.overview]</a>, 23.6.9.1 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap.overview">[flat.multimap.overview]</a>, 23.6.11.1 <a href="https://timsong-cpp.github.io/cppwp/flat.set.overview">[flat.set.overview]</a>, 23.6.12.1 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset.overview">[flat.multiset.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-01-23 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The issue was originally discovered while implementing <code>flat_(multi_)set</code> in MSVC STL 
(<a href="https://github.com/microsoft/STL/issues/4059">microsoft/STL#4059</a>).
<p/>
Currently, the effects of inserting a single element into or erasing elements from a flat container 
adaptor when an exception is thrown, are implicitly specified in 23.2.7.2 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.except">[associative.reqmts.except]</a>.
<p/>
However, given erasing elements from a <code>vector</code> or a <code>deque</code> generally needs to assign elements, 
which is not guaranteed to be non-throwing, it seems unreasonable to require <code>erase</code> of flat container 
adaptors not to throw in such a case. Likewise, as inserting a single value into <code>deque</code> is not 
guaranteed to be effectless when an exception is thrown, so flat container adaptors are unlike to provide such 
a guarantee.
<p/>
Perhaps we should conditionally relax the requirements when the underlying containers can't provide them.
</p>

<p><i>[2024-03-15; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p> <a href="https://wg21.link/P2767" title=" flat_map/flat_set omnibus">P2767</a> 3.5 is related/conflicting.  </p>



<p id="res-4046"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4047"><a href="4047">4047</a>. Explicitly specifying template arguments for <code>std::swap</code> should not be supported</h3>
<p><b>Section:</b> 16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-01-25 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#namespace.std">active issues</a> in [namespace.std].</p>
<p><b>View all other</b> <a href="lwg-index.html#namespace.std">issues</a> in [namespace.std].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::swap</code> overloads are separately declared in many standard library headers. It is likely expected 
that when a program includes correct headers for standard library types to be swapped, a <code>std::swap</code> call, 
with template argument deduced from arguments, selects the correct overload.
<p/>
However, if one explicitly specifies template arguments for a <code>std::swap</code> call, there would be possibly 
undesired overloads for which templates arguments are fully obtained, and thus undesired instantiation and 
ill-formed may be triggered.
<p/>
Perhaps we should explicitly state that explicitly specifying templates for <code>std::swap</code> is unsupported 
(having unspecified effects and possibly ill-formed), like taking address of non-address functions 
(16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>/6) and explicitly specifying template arguments for most standard algorithms 
(26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>/15), to avoid possible reading that there are some guarantees, derived 
from signatures of overloads, for doing so.
</p>

<p><i>[2024-03-15; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p> NAD - if a user does this and it breaks, so be it.</p>
<p>NAD as an issue creating a new kind of library policy for the first time.
Needs a paper.</p>
<p>
Not unique to <code>std::swap</code>. We should forbid this throughout
the standard library.
</p>
<p>Closely related to LWG <a href="2146" title="Are reference types CopyConstructible&#47;MoveConstructible&#47;CopyAssignable&#47;MoveAssignable&#47;Destructible? (Status: Open)">2146</a>.</p>



<p id="res-4047"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4048"><a href="4048">4048</a>. Inconsistent preconditions for transparent insertion of <code>std::flat_map/std::flat_set</code></h3>
<p><b>Section:</b> 23.6.11 <a href="https://timsong-cpp.github.io/cppwp/flat.set">[flat.set]</a>, 23.6.8.1 <a href="https://timsong-cpp.github.io/cppwp/flat.map.overview">[flat.map.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-01-26 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The preconditions for transparent insertion of associative containers (23.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/map.modifiers">[map.modifiers]</a>/13, 
23.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/map.modifiers">[map.modifiers]</a>/29, and 23.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/set.modifiers">[set.modifiers]</a>/3) detect the results of <code>equal_range</code>, 
while those for <code>std::flat_set</code> and <code>std::flat_map</code> (23.6.11.5 <a href="https://timsong-cpp.github.io/cppwp/flat.set.modifiers">[flat.set.modifiers]</a>/2 and 
23.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.modifiers">[flat.map.modifiers]</a>/20) currently detect the results of <code>find</code>, which is inconsistent.
<p/>
During implementing <code>std::flat_set</code> in MSVC STL, it was reported 
(<a href="https://github.com/microsoft/STL/issues/4105">microsoft/STL#4105</a>) that the current preconditions 
for <code>std::flat_set::insert</code> can lead to inconsistent results. Tim Song told that the current preconditions 
were copied from old revisions of <a href="https://wg21.link/P2363" title=" Extending associative containers with the remaining heterogeneous overloads">P2363</a>. So, presumably we should change these preconditions for 
flat container adaptors to consistently use <code>equal_range</code>.
</p>

<p><i>[2024-03-15; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
We didn't want <code>equal_range(k) == equal_range(u)</code> because the two sides of the
<code>==</code> need to be evaluated at different times.
</p>
<p>
It seems to me that <code>equal_range(k) == equal_range(u)</code> ought to be
true before the insertion, and still true after the insertion.
The wording in 23.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/set.modifiers">[set.modifiers]</a>/3 and
23.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/map.modifiers">[map.modifiers]</a>/13 requires only that the condition be true
before the insertion.
We either want to change the wording here to be consistent with those places;
or else change 23.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/set.modifiers">[set.modifiers]</a> and 23.4.3.4 <a href="https://timsong-cpp.github.io/cppwp/map.modifiers">[map.modifiers]</a>
to be consistent with the saner wording here. I'd vote for the latter.
</p>



<p id="res-4048"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 23.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.modifiers">[flat.map.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class K, class... Args&gt;
  pair&lt;iterator, bool&gt; try_emplace(K&amp;&amp; k, Args&amp;&amp;... args);
template&lt;class K, class... Args&gt;
  iterator try_emplace(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-20- <i>Preconditions</i>: The conversion from <code>k</code> into <code>key_type</code> constructs an 
object <code>u</code>, for which <code><del>find(k) == find(u)</del><ins>equal_range(k) == equal_range(u)</ins></code> 
is <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.6.11.5 <a href="https://timsong-cpp.github.io/cppwp/flat.set.modifiers">[flat.set.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class K&gt; pair&lt;iterator, bool&gt; insert(K&amp;&amp; x);
template&lt;class K&gt; iterator insert(const_iterator hint, K&amp;&amp; x);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Preconditions</i>: The conversion from <code>x</code> into <code>value_type</code> constructs an 
object <code>u</code>, for which <code><del>find(x) == find(u)</del><ins>equal_range(x) == equal_range(u)</ins></code> 
is <code>true</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4049"><a href="4049">4049</a>. C <code>&lt;<i>foo</i>.h&gt;</code> headers not in freestanding</h3>
<p><b>Section:</b> 16.4.2 <a href="https://timsong-cpp.github.io/cppwp/organization">[organization]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ben Craig <b>Opened:</b> 2024-01-26 <b>Last modified:</b> 2024-08-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are many C-ish <code>&lt;c<i>foo</i>&gt;</code> headers in freestanding. There isn't anything that 
requires the matching C <code>&lt;<i>foo</i>.h&gt;</code> headers to be in freestanding.
</p>

<p><i>[2024-08-21; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Some discomfort requiring <code class='backtick'>errno.h</code> and <code class='backtick'>wchar.h</code> to be freestanding in C++
when they are not in C23. <code class='backtick'>string.h</code> is not freestanding in C17, but is in C23
(but C++ is still based on C17).
<code class='backtick'>stdlib.h</code> is "conditionally partially freestanding" in C23, but not in C17.
Suggestion to incorporate this into <a href="https://wg21.link/P3348" title=" C++26 should refer to C23 not C17">P3348</a>.
</p>



<p id="res-4049"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 16.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a> as indicated:</p>

<blockquote>
<p>
-9- 17.15 <a href="https://timsong-cpp.github.io/cppwp/support.c.headers">[support.c.headers]</a>, C standard library headers, describes the effects of using the 
<code><i>name</i>.h</code> (C header) form in a C++ program. <ins>The <code><i>name</i>.h</code> form is the 
<i>corresponding C header form</i>.</ins>
</p>
</blockquote>
</li>

<li><p>Modify 16.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/compliance">[compliance]</a> as indicated:</p>

<blockquote>
<p>
-2- A freestanding implementation has an implementation-defined set of headers. This set shall include at least
the headers shown in Table 27 <ins>and the corresponding C header form (16.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/headers">[headers]</a>) of each of the 
C++ headers for C library facilities (Table 25) included in Table 27</ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4050"><a href="4050">4050</a>. Should <code>views::iota(0) | views::take(5)</code> be <code>views::iota(0, 5)</code>?</h3>
<p><b>Section:</b> 25.7.10.1 <a href="https://timsong-cpp.github.io/cppwp/range.take.overview">[range.take.overview]</a>, 25.7.10.1 <a href="https://timsong-cpp.github.io/cppwp/range.take.overview">[range.take.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-01-28 <b>Last modified:</b> 2024-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.take.overview">active issues</a> in [range.take.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.take.overview">issues</a> in [range.take.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given that C++20 ranges does not introduce the <i>infinite range</i> notification present in range/v3, 
this means that <code>views::iota(0) | views::take(5)</code> will currently return a <code>take_view</code> object 
that does not model <code>sized_range</code>.
</p>
<p>
However, with the introduction of C++23 <code>repeat_view</code>, its interaction with <code>views::take</code>/<code>drop</code> 
does have special handling depending on whether it is an infinite range, which causes 
<code>views::repeat(0) | views::take(5)</code> to return a <code>repeat_view</code> objects that satisfy <code>sized_range</code>.
</p>
<p>
This inconsistency leads to very different behavior of these two range factories in the case of infinite ranges 
(<a href="https://godbolt.org/z/4bvToE96x">demo</a>):
</p>
<blockquote>
<pre>
#include &lt;ranges&gt;

auto take_and_drop = std::views::drop(5)
                   | std::views::take(4)
                   | std::views::drop(3)
                   | std::views::take(2)
                   | std::views::drop(1);

// The type of iota is drop_view&lt;take_view&lt;drop_view&lt;take_view&lt;drop_view&lt;iota_view&lt;int, unreachable_sentinel_t&gt;&gt;&gt;&gt;&gt;&gt;, which is indeed a template bloat.
auto iota = std::views::iota(0) | take_and_drop;
static_assert(std::ranges::sized_range&lt;decltype(iota)&gt;); // <span style="color:red;font-weight:bolder">failed</span>

// The type of repeat is simply std::ranges::repeat_view&lt;int, long&gt;
std::ranges::sized_range auto repeat = std::views::repeat(0) | take_and_drop; // ok
</pre>
</blockquote>
<p>
If we do account for the infinity of <code>repeat_view</code>, then I see no reason not to do it for <code>iota_view</code>, 
as this is obviously intuitive and can indeed be considered an enhancement.
</p>


<p id="res-4050"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 25.7.10.1 <a href="https://timsong-cpp.github.io/cppwp/range.take.overview">[range.take.overview]</a> as indicated:</p>

<blockquote>
<p>
  -2- The name <code>views::take</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
  Let <code>E</code> and <code>F</code> be expressions, let <code>T</code> be <code>remove_cvref_t&lt;decltype((E))&gt;</code>,
  and let <code>D</code> be <code>range_difference_t&lt;decltype((E))&gt;</code>.
  If <code>decltype((F))</code> does not model <code>convertible_to&lt;D&gt;</code>, <code>views::take(E, F)</code>
  is ill-formed. Otherwise, the expression <code>views::take(E, F)</code> is expression-equivalent to:
</p>
<ol style="list-style-type: none">
  <li>
    <p>(2.1) &mdash; if <code>T</code> is a specialization of <code>empty_view</code> (25.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.empty.view">[range.empty.view]</a>),
      then <code>((void)F, <i>decay-copy</i>(E))</code>, except that the evaluations of <code>E</code>
      and <code>F</code> are indeterminately sequenced.
    </p>
  </li>
  <li>
    <p>(2.2) &mdash; Otherwise, if <code>T</code> models <code>random_access_range</code> and <code>sized_range</code>
      and is a specialization of <code>span</code> (23.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/views.span">[views.span]</a>),
      <code>basic_string_view</code> (27.3 <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a>), or <code>ranges::subrange</code> 
      (25.5.4 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a>), then <code>U(ranges::begin(E), ranges::begin(E) + 
      std::min&lt;D&gt;(ranges::distance(E), F))</code>, except that <code>E</code> is evaluated only once, 
      where <code>U</code> is a type determined as follows:
    </p>
    <ol style="list-style-type: none">
      <li>
        <p>(2.2.1) &mdash; if <code>T</code> is a specialization of <code>span</code>, then <code>U</code> is
          <code>span&lt;typename T::element_type&gt;</code>;
        </p>
      </li>
      <li>
        <p>(2.2.2) &mdash; otherwise, if <code>T</code> is a specialization of <code>basic_string_view</code>, then
          <code>U</code> is <code>T</code>;
        </p>
      </li>
      <li>
        <p>(2.2.3) &mdash; otherwise, <code>T</code> is a specialization of <code>subrange</code>,
          and <code>U</code> is <code>subrange&lt;iterator_t&lt;T&gt;&gt;</code>;</p>
      </li>
    </ol>
  </li>
  <li>
    <p>(2.3) &mdash; otherwise, if <code>T</code> is a specialization of <code>iota_view</code> 
      (25.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a>) that models <code>random_access_range</code> and <code>sized_range</code>, then
      <code>iota_view(*ranges::begin(E), *(ranges::begin(E) + std::min&lt;D&gt;(ranges::distance(E), F)))</code>,
      except that <code>E</code> is evaluated only once.
    </p>
  </li>
  <li>
    <p>(2.?) &mdash; <ins>Otherwise, if <code>T</code> is a specialization of <code>iota_view</code>
        that models <code>random_access_range</code> and <code>same_as&lt;sentinel_t&lt;T&gt;,
          unreachable_sentinel_t&gt;</code> is <code>true</code>, then
        <code>views::iota(*ranges::begin(E), *(ranges::begin(E) + static_cast&lt;D&gt;(F)))</code>,
        except that <code>E</code> is evaluated only once.</ins></p>
  </li>

  <li>
    <p>(2.4) &mdash; Otherwise, if <code>T</code> is a specialization of <code>repeat_view</code> 
       (25.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.view">[range.repeat.view]</a>):
    </p>
    <ol style="list-style-type: none">
      <li>
        <p>(2.4.1) &mdash; if <code>T</code> models <code>sized_range</code>, then
        <pre>  views::repeat(*E.<i>value_</i>, std::min&lt;D&gt;(ranges::distance(E), F))</pre>
        except that <code>E</code> is evaluated only once;</p>
      </li>
      <li>
        <p>(2.4.2) &mdash; otherwise, <code>views::repeat(*E.<i>value_</i>, static_cast&lt;D&gt;(F))</code>.
        </p>
      </li>
    </ol>
  </li>
  <li>
    <p>(2.5) &mdash; Otherwise, <code>take_view(E, F)</code>.</p>
  </li>
</ol>
</blockquote>
</li>

<li><p>Modify 25.7.12.1 <a href="https://timsong-cpp.github.io/cppwp/range.drop.overview">[range.drop.overview]</a> as indicated:</p>

<blockquote>
<p>
  -2- The name <code>views::drop</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
  Let <code>E</code> and <code>F</code> be expressions, let <code>T</code> be <code>remove_cvref_t&lt;decltype((E))&gt;</code>,
  and let <code>D</code> be <code>range_difference_t&lt;decltype((E))&gt;</code>.
  If <code>decltype((F))</code> does not model <code>convertible_to&lt;D&gt;</code>, <code>views::drop(E, F)</code>
  is ill-formed. Otherwise, the expression <code>views::drop(E, F)</code> is expression-equivalent to:
</p>
<ol style="list-style-type: none">
  <li>
    <p>(2.1) &mdash; if <code>T</code> is a specialization of <code>empty_view</code> (25.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.empty.view">[range.empty.view]</a>),
      then <code>((void)F, <i>decay-copy</i>(E))</code>, except that the evaluations of <code>E</code>
      and <code>F</code> are indeterminately sequenced.
    </p>
  </li>
  <li>
    <p>(2.2) &mdash; Otherwise, if <code>T</code> models <code>random_access_range</code> and <code>sized_range</code>
      and is
    </p>
    <ol style="list-style-type: none">
      <li>
        <p>(2.2.1) &mdash; a specialization of <code>span</code> (23.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/views.span">[views.span]</a>),</p>
      </li>
      <li>
        <p>(2.2.2) &mdash; a specialization of <code>basic_string_view</code> (27.3 <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a>), </p>
      </li>
      <li>
        <p>(2.2.3) &mdash; a specialization of <code>iota_view</code> (25.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a>), or</p>
      </li>
      <li>
        <p>(2.2.4) &mdash; a specialization of <code>subrange</code> (25.5.4 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a>)
          where <code>T::<i>StoreSize</i></code> is <code>false</code>,</p>
      </li>
    </ol>
    <p>then <code>U(ranges::begin(E) + std::min&lt;D&gt;(ranges::distance(E), F), ranges::end(E))</code>,
      except that <code>E</code> is evaluated only once, where <code>U</code> is <code>span&lt;typename
        T::element_type&gt;</code>
      if <code>T</code> is a specialization of <code>span</code> and <code>T</code> otherwise.
    </p>
  </li>
  <li>
    <p>(2.?) &mdash; <ins>Otherwise, if <code>T</code> is a specialization of <code>iota_view</code>
        that models
        <code>random_access_range</code> and <code>same_as&lt;sentinel_t&lt;T&gt;,
          unreachable_sentinel_t&gt;</code> is <code>true</code>, then
        <code>views::iota(*(ranges::begin(E) + static_cast&lt;D&gt;(F)))</code>.</ins>
    </p>
  </li>
  <li>
    <p>(2.3) &mdash; Otherwise, if <code>T</code> is a specialization of <code>subrange</code>
      (25.5.4 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a>) that models
      <code>random_access_range</code> and <code>sized_range</code>, then
      <code>T(ranges::begin(E) + std::min&lt;D&gt;(ranges::distance(E), F), ranges::end(E),
        <i>to-unsigned-like</i>(ranges::distance(E) - std::min&lt;D&gt;(ranges::distance(E), F)))</code>,
      except that <code>E</code> and <code>F</code> are each evaluated only once.
    </p>
  </li>
  <li>
    <p>(2.4) &mdash; Otherwise, if <code>T</code> is a specialization of <code>repeat_view</code> (25.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.view">[range.repeat.view]</a>):
    </p>
    <ol style="list-style-type: none">
      <li>
        <p>(2.4.1) &mdash; if <code>T</code> models <code>sized_range</code>, then
        <pre>  views::repeat(*E.<i>value_</i>, ranges::distance(E) - std::min&lt;D&gt;(ranges::distance(E), F))</pre>
        except that <code>E</code> is evaluated only once;</p>
      </li>
      <li>
        <p>(2.4.2) &mdash; otherwise, <code>((void)F, <i>decay-copy</i>(E))</code>, except that the evaluations of
          <code>E</code> and <code>F</code> are indeterminately sequenced.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>(2.5) &mdash; Otherwise, <code>drop_view(E, F)</code>.
    </p>
  </li>

</ol>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4051"><a href="4051">4051</a>. A less hacky and more useful way to compare comparison category types</h3>
<p><b>Section:</b> 17.12.2 <a href="https://timsong-cpp.github.io/cppwp/cmp.categories">[cmp.categories]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Corentin Jabot <b>Opened:</b> 2024-01-31 <b>Last modified:</b> 2024-02-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#cmp.categories">issues</a> in [cmp.categories].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Comparison categories can only be compared to the literal <code>0</code>.
It does not make sense for them to be comparable to anything else, so conceptually, the design of 
<a href="https://wg21.link/P0515" title=" Consistent comparison">P0515</a> makes sense, however in practice it's a pain point from users and implementations
alike, as the desired semantics is barely implementable.
</p>
<ul>
<li><p>One implementation strategy is to use <code>nullptr_t</code>. This produces warnings in implementations
because using a <code>0</code> pointer constant is not recommended, and filtering out these warnings would be unreliable.</p></li>
<li><p>Another implementation strategy is to require a <code>consteval</code> expression but</p>
<ul>
<li><p>This permits <code>1-1</code>, which ought to be totally fine and yet it exposes users to UB</p></li>
<li><p>It is not SFINAE friendly (and attempts at SFINAE are presumably UB).</p></li>
</ul>
</li>
</ul>
<p>
And there are use cases where SFINAE friendliness is important, notably testing frameworks.
<p/>
The status quo has engendered multiple issues being reported to at least 3 vendors
<p/>
Suggestion:
</p>
<ul>
<li><p>Allow any <code>0</code> constant expression</p></li>
<li><p>Require compile magic to SFINAE on non zero values</p></li>
<li><p>Remove the gratuitous UB</p></li>
</ul>
<p>
The proposed wording requires compiler magic and has been 
<a href="https://godbolt.org/z/1xr9Wx38T">implemented in clang</a>.
(Other possible way to implement that would for example be a magic type attribute, or a magic type)
<p/>
Related vendor issues:
<p/>
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96278">GCC Bugzilla issue 96278</a>
<p/>
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100903">GCC Bugzilla issue 100903</a>
<p/>
<a href="https://github.com/llvm/llvm-project/issues/43670">LLVM issue 43670</a>
<p/>
<a href="https://github.com/llvm/llvm-project/pull/79465">LLVM pulls request 79465</a>
<p/>
<a href="https://github.com/microsoft/STL/issues/4359">Microsoft STL issue 4359</a>
<p/>
<a href="https://github.com/microsoft/STL/pull/3581">Microsoft STL pull request 3581</a>
<p/>
<a href="https://developercommunity.visualstudio.com/t/Regression:-False-positive-C7595:-std::/10509214">Visual Studio issue 10509214</a>
<p/>
<a href="https://github.com/snitch-org/snitch/issues/140">snitch issue 140</a>
</p>


<p id="res-4051"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 17.12.2.1 <a href="https://timsong-cpp.github.io/cppwp/cmp.categories.pre">[cmp.categories.pre]</a> as indicated:</p>

<blockquote>
<p>
-3- The relational and equality operators for the comparison category types are specified with an anonymous
parameter of unspecified type. This type shall be selected by the implementation such that these parameters
can <ins>only</ins> accept <ins>an integral constant expression evaluating to</ins><del>literal</del> <code>0</code> 
as a corresponding argument.
<p/>
<del>[<i>Example 1</i>: <code>nullptr_t</code> meets this requirement. &mdash; <i>end example</i>]</del>
<p/>
<del>In this context, the behavior of a program that supplies an argument other than a literal <code>0</code> is undefined.</del>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4052"><a href="4052">4052</a>. Bogus requirements for <code>piecewise_linear_distribution</code></h3>
<p><b>Section:</b> 29.5.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a>, 29.5.9.6.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.plinear">[rand.dist.samp.plinear]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-02-05 <b>Last modified:</b> 2025-10-11</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the second constructor of 29.5.9.6.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.plinear">[rand.dist.samp.plinear]</a>,
<a href="https://wg21.link/P1719R2" title=" Mandating the Standard Library: Clause 26 - Numerics library">P1719R2</a> replaced:

<blockquote>
<pre><code>
template&lt;class InputIteratorB, class InputIteratorW&gt;
  piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                InputIteratorW firstW);
</code></pre>
<p>
<em>Effects</em>: [...] Moreover, the <em>id-expressions</em>
<code>iterator_traits&lt;InputIteratorB&gt;::value_type</code>
and
<code>iterator_traits&lt;InputIteratorW&gt;::value_type</code>
shall each denote a type that is convertible to
<code>double</code>.
</p>
</blockquote>
with
<blockquote>
<pre><code>
template&lt;class InputIteratorB, class InputIteratorW&gt;
  piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                InputIteratorW firstW);
</code></pre>
<p>
<em>Mandates</em>: 
<code>is_invocable_r_v&lt;double, UnaryOperation&amp;, double&gt;</code>
is <code>true</code>.
</p>
<p><em>Preconditions</em>: [...]</p>
<p><em>Effects</em>: [...]</p>

</blockquote>
</p>
<p>
This was a copy &amp; paste error from the next constructor,
and was obviously not intended. There is no <code>UnaryOperation</code>
in that constructor.
</p>
<p>A less obviously wrong issue is the use of <code>double</code> there
in the first place. Shouldn't it be <code>RealType</code> instead?
That seems to be incorrect throughout both
29.5.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a>
and
29.5.9.6.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.plinear">[rand.dist.samp.plinear]</a>,
and was only partially fixed by LWG <a href="1439" title="Return from densities() functions? (Status: C++11)">1439</a>.
</p>

<p>
Finally, the  preconditions also say:
</p>
<blockquote>
<em>Preconditions</em>: [...]
If <code>firstB == lastB</code> or <code>++firstB == lastB</code>,
let <em>n</em> = 1, <em></em><sub>0</sub> = <em></em><sub>1</sub> = 1,
<em>b</em><sub>0</sub> = 0, and <em>b</em><sub>1</sub> = 1.
Otherwise, [<code>firstB</code>, <code>lastB</code>)
forms a sequence <em>b</em> of length <em>n</em> + 1,
the length of the sequence <em>w</em> starting
from <code>firstW</code> is at least <em>n</em>,
and any <em>w<sub>k</sub></em> for <em>k</em>  <em>n</em>
are ignored by the distribution.
</blockquote>
<p>
These are not preconditions. I think it is trying to say something like:
</p>
<blockquote>
<p>
<em>Preconditions</em>: [...]
[<code>firstB</code>, <code>lastB</code>) is a valid range and
[<code>firstW</code>, <code>firstW + (lastB - firstB)</code>)
is a valid range.
</p>
<p>
<em>Effects</em>:
If <code>firstB == lastB</code> or <code>++firstB == lastB</code>,
let <em>n</em> = 1, <em></em><sub>0</sub> = <em></em><sub>1</sub> = 1,
<em>b</em><sub>0</sub> = 0, and <em>b</em><sub>1</sub> = 1.
Otherwise, let [<code>firstB</code>, <code>lastB</code>) form a sequence
<em>b</em><sub>0</sub>, &hellip;, <em>b</em><sub>n</sub>,
and let <em>w<sub>k</sub></em> = <code>*firstW++</code>
for <em>k</em> = 0, &hellip;, <em>n</em>.
</p>
</blockquote>

<p>
The equivalent constructor for <code>piecewise_constant_distribution</code>
has similar problems with its preconditions in terms of <em>n</em> + 1.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
The copy &amp; paste error was
<a href="https://github.com/cplusplus/draft/pull/6794">fixed editorially</a>.
</p>

<p><i>[2025-10-06; Hewill comments and provides wording]</i></p>

<p>
We should fix the constructor, otherwise the following should be rejected according to the standard:
</p>
<blockquote><pre>
#include &lt;random&gt;

struct Op {
  float operator()(float);
  void operator()(auto) = delete;
};

static_assert(!std::is_invocable_r_v&lt;double, Op&amp;, double&gt;);

int main() {
  std::initializer_list&lt;float&gt; l;
  std::piecewise_linear_distribution&lt;float&gt; dist(l, Op{});
}
</pre></blockquote>
<p>
This is, because it violates <i>Mandates</i>. However, all three compilers accept it because 
<code>Op&amp;</code> can take <code class='backtick'>float</code> and return <code class='backtick'>float</code>.
</p>


<p id="res-4052"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.5.9.6.2 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.pconst">[rand.dist.samp.pconst]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIteratorB, class InputIteratorW&gt;
  piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                  InputIteratorW firstW);
</pre>
<blockquote>
<p>
-4- <i>Mandates</i>: Both of
</p>
<ol style="list-style-type: none">
<li><p>
(4.1) &mdash; <code>is_convertible_v&lt;iterator_traits&lt;InputIteratorB>::value_type, <ins>result_type</ins><del>double</del>&gt;</code>
</p></li>
<li><p>
(4.2) &mdash; <code>is_convertible_v&lt;iterator_traits&lt;InputIteratorW>::value_type, <ins>result_type</ins><del>double</del>&gt;</code>
</p></li>
</ol>
<p>
are <code class='backtick'>true</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class UnaryOperation&gt;
  piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, UnaryOperation fw);
</pre>
<blockquote>
<p>
-7- <i>Mandates</i>: <code>is_invocable_r_v&lt;<ins>result_type</ins><del>double</del>, UnaryOperation&amp;, 
<ins>result_type</ins><del>double</del>&gt;</code> is <code class='backtick'>true</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class UnaryOperation&gt;
  piecewise_constant_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
</pre>
<blockquote>
<p>
-10- <i>Mandates</i>: <code>is_invocable_r_v&lt;<ins>result_type</ins><del>double</del>, UnaryOperation&amp;, 
<ins>result_type</ins><del>double</del>&gt;</code> is <code class='backtick'>true</code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>


<li><p>Modify 29.5.9.6.3 <a href="https://timsong-cpp.github.io/cppwp/rand.dist.samp.plinear">[rand.dist.samp.plinear]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIteratorB, class InputIteratorW&gt;
  piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                InputIteratorW firstW);
</pre>
<blockquote>
<p>
-4- <i>Mandates</i>: Both of
</p>
<ol style="list-style-type: none">
<li><p>
(4.1) &mdash; <code>is_convertible_v&lt;iterator_traits&lt;InputIteratorB>::value_type, <ins>result_type</ins><del>double</del>&gt;</code>
</p></li>
<li><p>
(4.2) &mdash; <code>is_convertible_v&lt;iterator_traits&lt;InputIteratorW>::value_type, <ins>result_type</ins><del>double</del>&gt;</code>
</p></li>
</ol>
<p>
are <code class='backtick'>true</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class UnaryOperation&gt;
  piecewise_linear_distribution(initializer_list&lt;RealType&gt; bl, UnaryOperation fw);
</pre>
<blockquote>
<p>
-7- <i>Mandates</i>: <code>is_invocable_r_v&lt;<ins>result_type</ins><del>double</del>, UnaryOperation&amp;, 
<ins>result_type</ins><del>double</del>&gt;</code> is <code class='backtick'>true</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class UnaryOperation&gt;
  piecewise_linear_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
</pre>
<blockquote>
<p>
-10- <i>Mandates</i>: <code>is_invocable_r_v&lt;<ins>result_type</ins><del>double</del>, UnaryOperation&amp;, 
<ins>result_type</ins><del>double</del>&gt;</code> is <code class='backtick'>true</code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4055"><a href="4055">4055</a>. &sect;[iterator.operations] <code>std::distance</code> is missing a precondition</h3>
<p><b>Section:</b> 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2024-02-25 <b>Last modified:</b> 2024-03-12</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.operations">active issues</a> in [iterator.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::distance</code> for random access iterators is defined in terms of 
<code>(last - first)</code> (24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> p5) for 
<i>Cpp17RandomAccessIterators</i>.
<p/>
However, this subtraction is not guaranteed to be well-defined
(24.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>, Table [tab:randomaccessiterator]):
</p>
<blockquote>
<table border="1">
<caption>Table 91: <i>Cpp17RandomAccessIterator</i> requirements (in addition to 
<i>Cpp17BidirectionalIterator</i>) [tab:randomaccessiterator]</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td colspan="4" align="center">
<code>[&hellip;]</code>
</td>
</tr>

<tr>
<td>
<code>b - a</code>
</td>
<td>
<code>difference_type</code>
</td>
<td>
<code>return n;</code>
</td>
<td>
<i>Preconditions</i>: there exists a<br/>
value <code>n</code> of type <code>difference_type</code><br/> 
such that <code>a + n == b</code>.<br/>
<code>b == a + (b - a)</code>.
</td>
</tr>

</table>

</blockquote>
<p>
For example, pointer subtraction is undefined if the result isn't representable 
as <code>std::ptrdiff_t</code>, and user-defined types with random access iterators 
aren't required to have a difference which is always representable by 
<code>difference_type</code>.
<p/>
<code>std::distance(&amp;a, &amp;b)</code> can't be well-defined when 
<code>&amp;b - &amp;a</code> is not, so <code>std::distance</code> is missing a precondition.
</p>

<p><i>[2024-03-12; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p>
The proposed change is wrong, the new wording only associates with the second
condition, but should also apply when "<code>last</code> is reachable from
<code>first</code>".
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  constexpr typename iterator_traits&lt;InputIterator&gt;::difference_type
    distance(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-4-<i>Preconditions</i>: <code>last</code> is reachable from <code>first</code>, or <code>InputIterator</code> 
meets the <i>Cpp17RandomAccessIterator</i> requirements<ins>,</ins> <del>and</del> <code>first</code> 
is reachable from <code>last</code> <ins>, and 
<code>typename iterator_traits&lt;InputIterator&gt;::difference_type</code> can represent the result of 
this function call</ins>.
<p/>
-5- <i>Effects</i>: If <code>InputIterator</code> meets the <i>Cpp17RandomAccessIterator</i> 
requirements, returns <code>(last - first)</code>; otherwise, increments <code>first</code> until <code>last</code> 
is reached and returns the number of increments.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2024-03-12; Jonathan provides improved wording]</i></p>




<p id="res-4055"><b>Proposed resolution:</b></p>

<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 24.4.3 <a href="https://timsong-cpp.github.io/cppwp/iterator.operations">[iterator.operations]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  constexpr typename iterator_traits&lt;InputIterator&gt;::difference_type
    distance(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-4-<i>Preconditions</i>: <code>last</code> is reachable from <code>first</code>, or <code>InputIterator</code> 
meets the <i>Cpp17RandomAccessIterator</i> requirements and <code>first</code> 
is reachable from <code>last</code>.
<ins>The return type can represent the result.</ins>
<p/>
-5- <i>Effects</i>: If <code>InputIterator</code> meets the <i>Cpp17RandomAccessIterator</i> 
requirements, returns <code>(last - first)</code>; otherwise, increments <code>first</code> until <code>last</code> 
is reached and returns the number of increments.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4057"><a href="4057">4057</a>. <code>generator::iterator</code>'s <code>operator*</code> is not <code>noexcept</code> when it can be</h3>
<p><b>Section:</b> 25.8.6 <a href="https://timsong-cpp.github.io/cppwp/coro.generator.iterator">[coro.generator.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2024-03-01 <b>Last modified:</b> 2024-09-17</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#coro.generator.iterator">active issues</a> in [coro.generator.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#coro.generator.iterator">issues</a> in [coro.generator.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>generator::<i>iterator</i></code>'s <code>operator*</code> is specified to have the following noexcept-specifier:
</p>
<blockquote><pre>
noexcept(is_nothrow_copy_constructible_v&lt;<i>reference</i>&gt;)
</pre></blockquote>
<p>
When <code><i>reference</i></code> is an rvalue reference type, <code>is_nothrow_copy_constructible_v&lt;<i>reference</i>&gt;</code>
is <code>false</code> (because <code><i>reference</i></code> is not copy constructible), which means <code>operator*</code>
is not <code>noexcept</code>.
<p/>
However, <code>operator*</code> doesn't perform any potentially-throwing operation in this case. It's effect is
equivalent to <code>return static_cast&lt;<i>reference</i>&gt;(*p.<i>value_</i>);</code> (where the type of <code>p.<i>value_</i></code>
is effectively <code>add_pointer_t&lt;<i>reference</i>&gt;</code>). Neither the dereference nor the cast to rvalue
reference can throw an exception.
<p/>
I think the expression inside the noexcept-specifier should be changed to
<code>noexcept(static_cast&lt;<i>reference</i>&gt;(*p.<i>value_</i>))</code>.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Just remove the noexcept-specifier."
"Maybe add <code>is_reference_v&lt;reference&gt; || ...</code>"
</p>

<p><i>[2024-09-16; Casey provides wording]</i></p>

<p>
In the prioritization thread, LWG discussed a couple of alternatives without much enthusiasm. One
of the alternatives was to simply remove the <i>noexcept-specifier</i>, which seems to be the most
efficient use of LWG's time.
</p>



<p id="res-4057"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 25.8.6 <a href="https://timsong-cpp.github.io/cppwp/coro.generator.iterator">[coro.generator.iterator]</a> as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class Ref, class Val, class Allocator&gt;
  class generator&lt;Ref, Val, Allocator&gt;::<i>iterator</i> {
    [&hellip;]
    <i>reference</i> operator*() const <del>noexcept(is_nothrow_copy_constructible_v&lt;reference&gt;)</del>;
    [&hellip;]
  };
}
</pre>
[&hellip;]
<p>-3- <i>Returns</i>: <code>*this</code>.</p>
<pre>
<i>reference</i> operator*() const <del>noexcept(is_nothrow_copy_constructible_v&lt;<i>reference</i>&gt;l)</del>;
</pre>
<p>-4- <i>Preconditions</i>: For some generator object <code>x</code>, <i><code>coroutine_</code></i> is in <code>*x.<i>active_</i></code> and
<code>x.<i>active_</i>-&gt;top()</code> refers to a suspended coroutine with promise object <code>p</code>.</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4058"><a href="4058">4058</a>. <code>std::to_address()</code> should be SFINAE-friendly</h3>
<p><b>Section:</b> 20.2.4 <a href="https://timsong-cpp.github.io/cppwp/pointer.conversion">[pointer.conversion]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Kasting <b>Opened:</b> 2024-03-13 <b>Last modified:</b> 2024-03-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#pointer.conversion">issues</a> in [pointer.conversion].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3545" title="std::pointer_traits should be SFINAE-friendly (Status: C++23)">3545</a> made <code>std::pointer_traits</code> SFINAE-friendly.
However, <code>std::to_address</code> is still not required to be SFINAE-friendly.
</p>
<p>
This requires callers who wish to accept both pointer-like and non-pointer-like
types to guard calls with a constraint that reimplements the core logic of
<code>to_address</code>, such as the following:
</p>
<pre><code>
template&lt;typename T&gt;
concept IsPointerLike = requires { typename std::pointer_traits&lt;T&gt;::pointer; }
                         || requires (const T&amp; t) { t.operator-&gt;(); };
</code></pre>
<p>
Making <code class='backtick'>to_address</code> not be SFINAE-friendly
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=113074#c7">was seen as desirable</a>,
so <code class='backtick'>std::contiguous_iterator</code> would produce a hard error for types marked with
<code class='backtick'>contiguous_iterator_tag</code> that do not properly support <code class='backtick'>to_address</code>.
Thus any fix should not regress that unless LWG explicitly decides to do so.
Also note that libc++'s current implementation of <code class='backtick'>to_address</code>,
which is SFINAE-friendly,
<a href="https://godbolt.org/z/e681Ynhf1">does not produce such a hard error</a>.
</p>


<p id="res-4058"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li>
<p>Modify 20.2.4 <a href="https://timsong-cpp.github.io/cppwp/pointer.conversion">[pointer.conversion]</a> as indicated:</p>
<blockquote>
<p><code>
template&lt;class Ptr&gt; constexpr auto to_address(const Ptr&amp; p) noexcept;
</code></p>
<p><ins>
-?- <em>Constraints</em>:
Either the expression
<code>pointer_traits&lt;Ptr&gt;::to_address(p)</code> is well-formed
(see 20.2.3.4 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.optmem">[pointer.traits.optmem]</a>),
or the expression <code>p.operator-&gt;()</code> is well-formed.
</ins></p>
<p>
-3- <em>Returns</em>:
<code>pointer_traits&lt;Ptr&gt;::to_address(p)</code>
if that expression is well-formed
<del>(see 20.2.3.4 <a href="https://timsong-cpp.github.io/cppwp/pointer.traits.optmem">[pointer.traits.optmem]</a>)</del>,
otherwise <code>to_address(p.operator-&gt;())</code>.
</p>
</blockquote>
</li>
<li>
<p>Modify 24.3.4.14 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.contiguous">[iterator.concept.contiguous]</a> as indicated:</p>
<blockquote>
<p>
-1- The <code>contiguous_iterator</code> concept provides a guarantee that
the denoted elements are stored contiguously in memory.
</p>
<pre><code>
template&lt;class I&gt;
  concept contiguous_iterator =
    random_access_iterator&lt;I&gt; &amp;&amp;
    derived_from&lt;ITER_CONCEPT(I), contiguous_iterator_tag&gt; &amp;&amp;
    is_lvalue_reference_v&lt;iter_reference_t&lt;I&gt;&gt; &amp;&amp;
    same_as&lt;iter_value_t&lt;I&gt;, remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;&gt; &amp;&amp;
    <del>requires(const I&amp; i) {
      { to_address(i) } -&gt; same_as&lt;add_pointer_t&lt;iter_reference_t&lt;I&gt;&gt;&gt;;
    }</del>
    <ins>std::same_as&lt;decltype([] { return std::to_address(std::declval&lt;I&gt;()); }()),
                 std::add_pointer_t&lt;std::iter_reference_t&lt;I&gt;&gt;&gt;</ins>;
</code></pre>
</blockquote>
<p><i>[The submitter welcomes less awkward alternatives to achieve the desired hard error for <code>contiguous_iterator</code>.]</i></p>

</li>
</ol>





<hr>
<h3 id="4059"><a href="4059">4059</a>. Leaky abstraction in <code>join_with_view</code>'s iterator</h3>
<p><b>Section:</b> 25.7.15.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.iterator">[range.join.with.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2024-03-23 <b>Last modified:</b> 2024-08-11</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.with.iterator">active issues</a> in [range.join.with.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.with.iterator">issues</a> in [range.join.with.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>join_with_view</code>'s iterator is defined in terms of <code>variant</code>, <code>visit</code> and <code>get</code>, 
which implies that the iterator operations throw <code>bad_variant_access</code> if the underlying variant is 
valueless-by-exception (which can happen if an underlying iterator has a throwing copy constructor).
<p/>
IMO, the <code>variant</code> is an implementation detail and shouldn't be exposed. It's confusing for users to 
get <code>bad_variant_access</code> when user code does not deal with <code>variant</code>.
<p/>
The spec of <code>join_with_view</code> is also inconsistent with <code>concat_view</code> as recently added to the
working draft by <a href="https://wg21.link/P2542R8" title=" views::concat">P2542R8</a>. The latter has "<code><i>it_</i>.valueless_by_exception()</code> is 
<code>false</code>" as a precondition.
<p/>
I believe that <code>join_with_view</code> should similarly require that <code><i>inner_it_</i>.valueless_by_exception()</code> 
is <code>false</code> for each iterator operation.
<p/>
(FWIW, MSVC STL implements <code>join_with_view</code> with a trimmed-down version of <code>variant</code>, and having 
to throw <code>bad_variant_access</code> causes a small maintenance burden.)
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
We like the suggestion to require "not valueless" as a precondition.
</p>

<p><i>[2024-08-08, Inbal Levi provides wording]</i></p>



<p id="res-4059"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>

<li><p>Modify 25.7.15.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.iterator">[range.join.with.iterator]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>iterator</i>(<i>iterator</i>&lt;!Const&gt; i)
    requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, <i>OuterIter</i>&gt; &amp;&amp;
             convertible_to&lt;iterator_t&lt;<i>InnerRng</i>&gt;, <i>InnerIter</i>&gt; &amp;&amp;
             convertible_to&lt;iterator_t&lt;Pattern&gt;, <i>PatternIter</i>&gt;;
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <code><i>inner_it_</i>.valueless_by_exception()</code> is <code>false</code>.</ins>
<p/>
-10- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
constexpr decltype(auto) operator*() const;
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <code><i>inner_it_</i>.valueless_by_exception()</code> is <code>false</code>.</ins>
<p/>
-12- <i>Effects</i>: Equivalent to: [&hellip;]
</p>
</blockquote>
<pre>
constexpr <i>iterator</i>&amp; operator++();
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <code><i>inner_it_</i>.valueless_by_exception()</code> is <code>false</code>.</ins>
<p/>
-13- <i>Effects</i>: Equivalent to: [&hellip;]
</p>
</blockquote>
<pre>
constexpr void operator++(int);
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <code><i>inner_it_</i>.valueless_by_exception()</code> is <code>false</code>.</ins>
<p/>
-14- <i>Effects</i>: Equivalent to: <code>++*this</code>.
</p>
</blockquote>
<pre>
constexpr <i>iterator</i> operator++(int)
  requires <i>ref-is-glvalue</i> &amp;&amp; forward_iterator&lt;<i>OuterIter</i>&gt; &amp;&amp; forward_iterator&lt;<i>InnerIter</i>&gt;;
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <code><i>inner_it_</i>.valueless_by_exception()</code> is <code>false</code>.</ins>
<p/>
-15- <i>Effects</i>: Equivalent to: [&hellip;]
</p>
</blockquote>
<pre>
constexpr <i>iterator</i>&amp; operator--()
  requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
           <i>bidirectional-common</i>&lt;<i>InnerBase</i>&gt; &amp;&amp; <i>bidirectional-common</i>&lt;<i>PatternBase</i>&gt;;
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions:</i> <code><i>inner_it_</i>.valueless_by_exception()</code> is <code>false</code>.</ins>
<p/>
-16- <i>Effects</i>: Equivalent to: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4062"><a href="4062">4062</a>. <code>ranges::empty</code> has no semantic requirements for <code>forward_range</code>s</h3>
<p><b>Section:</b> 25.3.13 <a href="https://timsong-cpp.github.io/cppwp/range.prim.empty">[range.prim.empty]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-03-30 <b>Last modified:</b> 2024-03-30</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is a small part of issues raised by already-closed <a href="https://wg21.link/P3156" title=" empty_checkable_range">P3156</a>.
<p/>
Currently, <code>ranges::empty</code> (25.3.13 <a href="https://timsong-cpp.github.io/cppwp/range.prim.empty">[range.prim.empty]</a>) is always a valid expression when applied
to <code>forward_range</code>s, because even if it does not have <code>.empty()</code> or <code>.size()</code> we can always
check whether it is empty by comparing its <code>begin()</code> and <code>end()</code>, which is reflected in the 
standard preference to use it to check whether a certain <code>forward_range</code> is empty,
such as in the <i>Effects</i> of <code>split_view::<i>find-next</i>()</code> (25.7.17.2 <a href="https://timsong-cpp.github.io/cppwp/range.split.view">[range.split.view]</a>) 
and <code>cartesian_product_view::end()</code> (25.7.33.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a>).
<p/>
In addition, MSVC-STL also uses <code>ranges::empty</code> in the <a
href="https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/algorithm#L1455">implementation</a>
of <code>ranges::contains_subrange</code> for the check.
<p/>
However, unlike <code>ranges::size</code>, which has a <code>sized_range</code> concept to ensure semantics,
<code>ranges::empty</code> has no corresponding one. This makes it lack of time complexity guarantees and semantics 
for the meaning of the returned value when using the bullets (2.2) and (2.3) of 25.3.13 <a href="https://timsong-cpp.github.io/cppwp/range.prim.empty">[range.prim.empty]</a>
to check emptiness.
<p/>
Perhaps we need to add semantic requirements for <code>ranges::empty</code>, but this seems
inconsistent with the current wording as no other CPOs have.
<p/>
Alternatively, maybe we could move bullets targeting <code>forward_range</code>s to the very beginning so that
<code>ranges::empty</code> always has correct semantics with <code>bool(ranges::begin(t) == ranges::end(t))</code> when
applied to <code>forward_range</code>s.
</p>


<p id="res-4062"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4063"><a href="4063">4063</a>. Freestanding <code>std::char_traits&lt;char&gt;::eof</code> depends on non-freestanding <code>EOF</code></h3>
<p><b>Section:</b> 27.2.4.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.specializations.char">[char.traits.specializations.char]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-04-03 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.specializations.char">issues</a> in [char.traits.specializations.char].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently <code>EOF</code> is not yet freestanding, because it's only specified to be provided in 
<code>&lt;stdio.h&gt;</code> in C, or together with <code>&lt;cstdio&gt;</code> in C++.
<p/>
However, <code>std::char_traits&lt;char&gt;::eof</code> (required to be freestanding since C++26 by 
<a href="https://wg21.link/P2338R4" title=" Freestanding Library: Character primitives and the C library">P2338R4</a>) is required to return the value of <code>EOF</code>. It's unclear what is 
expected to be done in a freestanding implementation.
<p/>
Related to <a href="https://github.com/llvm/llvm-project/issues/85158">LLVM issue #85158</a>.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
"The <code class='backtick'>eof</code>, <code class='backtick'>not_eof</code>, <code class='backtick'>to_int_type</code> and <code class='backtick'>to_char_type</code> members of <code class='backtick'>char_traits</code>
are only needed by iostreams, so I see no reason for them to be freestanding.
In libstdc++ <code class='backtick'>eof</code> and <code class='backtick'>not_eof</code> depend on hosted, so are not freestanding.
Now that we can have partially freestanding classes in the library,
that seems like the right solution here."
</p>
<p>
"<code class='backtick'>int_type</code>/<code class='backtick'>char_type</code>/<code class='backtick'>eof</code> is kind of poor-man (or C)'s
<code>optional&lt;char_type&gt;</code>. Inclined to support it in freestanding
on that basis, even if the only standard component that uses it is iostreams."
</p>
<p>
"No implementer is confused about the value of <code class='backtick'>eof()</code>/<code class='backtick'>EOF</code>.
Having the value specified in the non-freestanding part of the standard
should be good enough."
</p>
<p>
"Prefer to make EOF freestanding, but don't feel strongly about it.
The important thing is keeping <code class='backtick'>string_view</code> working."
</p>



<p id="res-4063"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4065"><a href="4065">4065</a>. Requirements for fancy pointers might be insufficient for self-referential implementation of containers</h3>
<p><b>Section:</b> 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-04-07 <b>Last modified:</b> 2024-05-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements.general">active issues</a> in [allocator.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements.general">issues</a> in [allocator.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a>/2.12 imposes a precondition for 
<code>pointer_traits::pointer_to</code> that <code>r</code> denotes an object whose storage is allocated 
by the allocator.
<p/>
However, as mentioned in <a href="https://wg21.link/P0773R0" title=" Towards meaningful fancy pointers">P0773R0</a>, some containers are self-referential in current 
implementations, and thus a fancy pointer stored in the last node (as required by LWG <a href="2261" title="Are containers required to use their 'pointer' type internally? (Status: C++17)">2261</a>) 
needs to be able to point to a sentinel node in the container object. Given the container object can 
be constructed at any location, perhaps we should specify that <code>pointer_traits::pointer_to</code> 
works on any lvalue.
</p>

<p><i>[2024-05-01; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>"This applies to small-object optimizations too."</p>
<p>"An alternative way to support P0773's "near pointers" would be to require
that a sentinel-node container using a "near allocator" must itself be
constructed in the near segment. (This is P0773 (B) (2).)"</p>



<p id="res-4065"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> as indicated:</p>

<blockquote>
<p>
-2- In subclause 16.4.4.6 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements">[allocator.requirements]</a>,
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(2.10) &mdash; <code>p</code> denotes a value of type <code>XX::pointer</code> obtained by calling 
<code>a1.allocate</code>, where <code>a1 == a</code>,</p></li>
<li><p>(2.11) &mdash; [&hellip;],</p></li>
<li><p>(2.12) &mdash; <code>r</code> denotes a<ins>n l</ins>value of type <code>T<del>&amp;</del></code> 
<del>obtained by the expression <code>*p</code></del>,</p></li>
<li><p>[&hellip;]</p></li>
</ol>
<p>
[&hellip;]
</p>
<pre>
pointer_traits&lt;XX::pointer&gt;::pointer_to(r)
</pre>
<blockquote>
<p>
-33- <i>Result:</i> <code>XX::pointer</code>
<p/>
-34- <i>Postconditions:</i> <del>Same as <code>p</code></del><ins>Let <code>p1</code> denote the return value. 
<code>*p1</code> refers to the same object as <code>r</code></ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4066"><a href="4066">4066</a>. <code>ranges::to</code> should reserve when <code>sized_sentinel_for</code> is satisfied</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-13 <b>Last modified:</b> 2025-02-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>ranges::to</code> currently only reserves when <code>r</code> satisfies <code>sized_range</code>.
However, we can also extract its size when <code>r</code> is an <code>input_range</code> that its sentinel-iterator 
pair satisfies <code>sized_sentinel_for</code>.
<p/>
Given that we have specifically designed the decision tree, I see no reason not to reserve in this case, 
since we'd be calling <code>ranges::begin(r)</code> anyway.
</p>

<p><i>[2025-02-27; post-Hagenberg status]</i></p>

<p>
The proposed resolution needs rebasing after <a href="https://wg21.link/P2846R6" title=" reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges">P2846R6</a>
was approved in Hagenberg.
It also conflicts with LWG <a href="3722" title="ranges::to reserves the wrong size (Status: New)">3722</a>.
</p>



<p id="res-4066"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>
<li><p>Modify 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>C</code> is a cv-unqualified class type.
</p>
<p>
-2- <i>Returns</i>: An object of type <code>C</code> constructed from the elements of <code>r</code> in the following manner:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p>
<ol style="list-style-type: none">
<li><p>(2.1.1) &mdash; [&hellip;]</p></li>
<li><p>(2.1.2) &mdash; [&hellip;]</p></li>
<li><p>(2.1.3) &mdash; [&hellip;]</p></li>
<li><p>(2.1.4) &mdash; Otherwise, if</p>
<ol style="list-style-type: none">
<li><p>(2.1.4.1) &mdash; <code>constructible_from&lt;C, Args...&gt;</code> is <code>true</code>, and</p></li>
<li><p>(2.1.4.2) &mdash; <code><i>container-appendable</i>&lt;C, range_reference_t&lt;R&gt;&gt;</code> is
<code>true</code>:</p>
<blockquote>
<pre>
C c(std::forward&lt;Args&gt;(args)...);
<ins>subrange s{r};</ins>
if constexpr (<del>sized_range&lt;R&gt;</del><ins>requires { s.size(); }</ins> &amp;&amp; <i>reservable-container</i>&lt;C&gt;)
  c.reserve(static_cast&lt;range_size_t&lt;C&gt;&gt;(<del>ranges::size(r)</del><ins>s.size()</ins>));
ranges::for_each(<del>r</del><ins>s</ins>, <i>container-append</i>(c));
</pre>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>

</blockquote>
</li>
</ol>





<hr>
<h3 id="4067"><a href="4067">4067</a>. Inconsistency and potential infinity meta-recursion in <code>std::chrono::zoned_time</code>'s constructors</h3>
<p><b>Section:</b> 30.11.7.2 <a href="https://timsong-cpp.github.io/cppwp/time.zone.zonedtime.ctor">[time.zone.zonedtime.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-04-14 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.zone.zonedtime.ctor">issues</a> in [time.zone.zonedtime.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, there are no requirements on a program-defined <code>std::chrono::zoned_traits</code> specialization. 
So a <code>zoned_traits&lt;<i>UserDefinedTzPtr</i>&gt;::locate_zone</code> possibly returns a <code>string_view</code>, 
which leads to infinite meta-recursion when checking the constraints of <code>zoned_time</code>'s constructors 
that take a <code>string_view</code>.
<p/>
Also, the constructor of <code>zoned_time</code> taking only one <code>string_view</code> is inconsistent with others 
and even self-inconsistent. For other constructors taking <code>string_view</code>, it is expected that the return 
value of <code>locate_zone</code> is only implicitly converted to a <code>TimeZonePtr</code>. But the return value is 
permitted to be convertible to <code>zoned_time</code> or <code>sys_time&lt;Duration&gt;</code> in this constructor. 
And given the <code>locate_name</code> function may be an overload set that distinguishes lvalues and rvalues of 
<code>string_view</code>, the use of <code>locate_time(string_view{})</code> in the constraints doesn't always reflect 
<code>locate_time(name)</code> in the effects as the return types can be different.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"Such a <code class='backtick'>UserDefinedTzPtr</code> would be ridiculous and not useful,
but it wouldn't hurt to tighten the spec a bit."
"Would prefer a much simpler resolution saying 'dont do that'.
I don't like that <code><i>locatable-as-tzptr</i></code> doesn't look like
a dependent expression, but it is really.
Saying '<code class='backtick'>TimeZonePtr</code> is implicit convertible from its return type'
should be phrased in terms of converting <i>to</i>, and should talk about
conversion from an expression to a type (see LWG <a href="3105" title="T1 is convertible to T2 (Status: New)">3105</a>)."
</p>



<p id="res-4067"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4971" title=" Working Draft, Programming Languages  C++">N4971</a>.
</p>

<ol>
<li><p>Modify 30.11.7.2 <a href="https://timsong-cpp.github.io/cppwp/time.zone.zonedtime.ctor">[time.zone.zonedtime.ctor]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> Add the following two paragraphs to the very beginning of subclause
30.11.7.2 <a href="https://timsong-cpp.github.io/cppwp/time.zone.zonedtime.ctor">[time.zone.zonedtime.ctor]</a>] 
</p>
</blockquote>

<blockquote>
<p>
<ins>-?- Let <code><i>locatable-as-tzptr</i></code> be <code>true</code> if given an lvalue <code>sv</code> of type 
<code>string_view</code>, <code>traits::locate_zone(sv)</code> is well-formed and <code>TimeZonePtr</code> is implicitly 
convertible from its return type, and <code>false</code> otherwise. Only the validity of the immediate context 
of the invocation and conversion is considered.</ins>
<p/>
<ins>-?- In every constructor that takes a <code>string_view</code> parameter <code>name</code>, let 
<code><i>converted-tzptr</i></code> be a variable of type <code>TimeZonePtr</code> that is copy-initialized 
from <code>traits::locate_zone(name)</code>.</ins>
<p/>
[&hellip;]
</p>
<pre>
explicit zoned_time(string_view name);
</pre>
<blockquote>
<p>
-7- <i>Constraints:</i> <del><code>traits::locate_zone(string_view{})</code> is a well-formed expression and 
<code>zoned_time</code> is constructible from the return type of <code>traits::locate_zone(string_view{})</code></del>
<ins><code><i>locatable-as-tzptr</i></code> is <code>true</code></ins>.
<p/>
-8- <i>Effects:</i> Initializes <code>zone_</code> with <code>traits::locate_zone(name)</code> and default 
constructs <code>tp_</code>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
zoned_time(string_view name, const sys_time&lt;Duration&gt;&amp; st);
</pre>
<blockquote>
<p>
-13- <i>Constraints:</i> <del><code>zoned_time</code> is constructible from the return type of 
<code>traits::locate_zone(name)</code> and <code>st</code></del><ins><code><i>locatable-as-tzptr</i></code> is 
<code>true</code></ins>.
<p/>
-14- <i>Effects:</i> Equivalent to construction with 
<code>{<del>traits::locate_zone(name)</del><ins>std::move(<i>converted-tzptr</i>)</ins>, st}</code>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
zoned_time(string_view name, const local_time&lt;Duration&gt;&amp; tp);
</pre>
<blockquote>
<p>
-18- <i>Constraints:</i> <ins><code><i>locatable-as-tzptr</i></code> is <code>true</code> and</ins>
<code>zoned_time</code> is constructible from <del>the return type of 
<code>traits::locate_zone(name)</code></del><ins><code>TimeZonePtr</code></ins> and <code>tp</code>.
<p/>
-19- <i>Effects:</i> Equivalent to construction with 
<code>{<del>traits::locate_zone(name)</del><ins>std::move(<i>converted-tzptr</i>)</ins>, tp}</code>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
zoned_time(string_view name, const local_time&lt;Duration&gt;&amp; tp, choose c);
</pre>
<blockquote>
<p>
-23- <i>Constraints:</i> <ins><code><i>locatable-as-tzptr</i></code> is <code>true</code> and</ins> 
<code>zoned_time</code> is constructible from <del>the return type of 
<code>traits::locate_zone(name)</code></del><ins><code>TimeZonePtr</code></ins>, 
<code>local_time&lt;Duration&gt;</code>, and <code>choose</code>.
<p/>
-24- <i>Effects:</i> Equivalent to construction with 
<code>{<del>traits::locate_zone(name)</del><ins>std::move(<i>converted-tzptr</i>)</ins>, tp, c}</code>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template&lt;class Duration2, class TimeZonePtr2&gt;
  zoned_time(string_view name, const zoned_time&lt;Duration2, TimeZonePtr2&gt;&amp; y);
</pre>
<blockquote>
<p>
-32- <i>Constraints:</i> <ins><code><i>locatable-as-tzptr</i></code> is <code>true</code> and</ins>
<code>zoned_time</code> is constructible from <del>the return type of 
<code>traits::locate_zone(name)</code></del><ins><code>TimeZonePtr</code></ins> 
and the type <code>zoned_time&lt;Duration2, TimeZonePtr2&gt;</code>.
<p/>
-33- <i>Effects:</i> Equivalent to construction with 
<code>{<del>traits::locate_zone(name)</del><ins>std::move(<i>converted-tzptr</i>)</ins>, y}</code>.
</p>
</blockquote>
<pre>
template&lt;class Duration2, class TimeZonePtr2&gt;
  zoned_time(string_view name, const zoned_time&lt;Duration2, TimeZonePtr2&gt;&amp; y, choose c);
</pre>
<blockquote>
<p>
-34- <i>Constraints:</i> <ins><code><i>locatable-as-tzptr</i></code> is <code>true</code> and</ins> 
<code>zoned_time</code> is constructible from <del>the return type of 
<code>traits::locate_zone(name)</code></del><ins><code>TimeZonePtr</code></ins>, the type 
<code>zoned_time&lt;Duration2, TimeZonePtr2&gt;</code>, and the type <code>choose</code>.
<p/>
-35- <i>Effects:</i> Equivalent to construction with 
<code>{<del>traits::locate_zone(name)</del><ins>std::move(<i>converted-tzptr</i>)</ins>, y, c}</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4068"><a href="4068">4068</a>. Terminology for objects whose types model a concept</h3>
<p><b>Section:</b> 16.4.5.11 <a href="https://timsong-cpp.github.io/cppwp/res.on.requirements">[res.on.requirements]</a>, 16.3.2.3 <a href="https://timsong-cpp.github.io/cppwp/structure.requirements">[structure.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-04-19 <b>Last modified:</b> 2024-04-19</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#res.on.requirements">active issues</a> in [res.on.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.requirements">issues</a> in [res.on.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During <a href="https://wg21.link/P2300" title=" `std::execution`">P2300</a> review the suggestion was raised that it might
be helpful to be able to talk about "an object that models <code class='backtick'>Concept</code>"
instead of "an object whose type models <code class='backtick'>Concept</code>" or other more verbose forms.
</p>


<p id="res-4068"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4070"><a href="4070">4070</a>. Transcoding by <code>std::formatter&lt;std::filesystem::path&gt;</code></h3>
<p><b>Section:</b> 31.12.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmtr.funcs">[fs.path.fmtr.funcs]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-04-19 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
31.12.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmtr.funcs">[fs.path.fmtr.funcs]</a> says:

<blockquote>
If <code class='backtick'>charT</code> is <code class='backtick'>char</code>, <code class='backtick'>path::value_type</code> is <code class='backtick'>wchar_t</code>,
and the literal encoding is UTF-8, then the escaped path is
transcoded from the native encoding for wide character strings to UTF-8
with maximal subparts of ill-formed subsequences substituted with
<span style="font-variant:small-caps">u+fffd</span>
replacement character per the Unicode Standard [...].
Otherwise, transcoding is implementation-defined.
</blockquote>
</p>

<p>
This seems to mean that the Unicode substitutions are only done
for an escaped path, i.e. when the <code class='backtick'>?</code> option is used. Otherwise, the form
of transcoding is completely implementation-defined.
However, this makes no sense.
An escaped string will have no ill-formed subsequences, because they will
already have been replaced as per 28.5.6.5 <a href="https://timsong-cpp.github.io/cppwp/format.string.escaped">[format.string.escaped]</a>:
<blockquote>
Otherwise (<em>X</em> is a sequence of ill-formed code units),
each code unit <em>U</em> is appended to <em>E</em> in order as
the sequence <code>\x{<em>hex-digit-sequence</em>}</code>,
where <code><em>hex-digit-sequence</em></code> is the shortest hexadecimal
representation of <em>U</em> using lower-case hexadecimal digits.
</blockquote>
</p>
<p>
So only unescaped strings can have ill-formed sequences by the time
we do transcoding to <code class='backtick'>char</code>, but whether or not any
<span style="font-variant:small-caps">u+fffd</span> substitution
occurs is just implementation-defined.
</p>

<p>
I believe we want to specify the substitutions are done when transcoding
an <em>unescaped</em> path (and it doesn't matter whether we specify it
for escaped paths, because it's a no-op if escaping happens first,
as is apparently intended).
</p>

<p>
It does matter whether we escape first or perform substitutions first.
If we escape first then every code unit in an ill-formed sequence is
individually escaped as <code class='backtick'>\x{hex-digit-sequence}</code>.
So an ill-formed sequence of two <code class='backtick'>wchar_t</code> values will be escaped as
two <code class='backtick'>\x{...}</code> strings, which are then transcoded to UTF-8.
If we transcode (with substitutions first) then the entire
ill-formed sequence is replaced with a single replacement character,
which will then be escaped as <code class='backtick'>\x{fffd}</code>.
SG16 should be asked to confirm that escaping first is intended,
so that an escaped string shows the original invalid code units.
For a non-escaped string, we want the ill-formed sequence to be
formatted as &#xfffd;, which the proposed resolution tries to ensure.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>
<ol>
<li><p>Modify 31.12.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmtr.funcs">[fs.path.fmtr.funcs]</a> as indicated:</p>

<blockquote>
<pre><code>
template&lt;class FormatContext&gt;
  typename FormatContext::iterator
    format(const filesystem::path&amp; p, FormatContext&amp; ctx) const;
</code></pre>
<blockquote>-5-
<em>Effects</em>:
Let <code class='backtick'>s</code> be <code>p.generic_string&lt;filesystem::path::value_type&gt;()</code>
if the <code class='backtick'>g</code> option is used, otherwise <code class='backtick'>p.native()</code>.
Writes <code class='backtick'>s</code> into <code class='backtick'>ctx.out()</code>, adjusted according to the path-format-spec.
If <code class='backtick'>charT</code> is <code class='backtick'>char</code>, <code class='backtick'>path::value_type</code> is <code class='backtick'>wchar_t</code>,
and the literal encoding is UTF-8, then the
<del>escaped path</del>
<ins>(possibly escaped) string</ins>
is transcoded from the native encoding for wide character strings to UTF-8
with maximal subparts of ill-formed subsequences substituted with
<span style="font-variant:small-caps">u+fffd</span> replacement character per
the Unicode Standard, Chapter 3.9 <span style="font-variant:small-caps">u+fffd</span>
Substitution in Conversion.
If <code class='backtick'>charT</code> and <code class='backtick'>path::value_type</code> are the same then no transcoding is performed.
Otherwise, transcoding is implementation-defined.
</blockquote>
</blockquote>
</li>
<li>
Modify the entry in the index of implementation-defined behavior as indicated:
<blockquote>
transcoding of a formatted <code class='backtick'>path</code> when <code class='backtick'>charT</code> and <code class='backtick'>path::value_type</code> differ
<ins>and not converting from <code class='backtick'>wchar_t</code> to UTF-8</ins>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-06-11; SG16 comments and improves wording]</i></p>

<p>
The "and not converting from <code class='backtick'>wchar_t</code> to UTF-8" wording added in the index of implementation-defined 
behavior by the current proposed resolution should be changed to "and the literal encoding is not UTF-8".
<p/>
It was noted that "the literal encoding" is ambiguous in both the normative wording in 
31.12.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmtr.funcs">[fs.path.fmtr.funcs]</a> p5 and in the new wording quoted above. In both cases, the intent 
is to refer to the "ordinary literal encoding". However, some SG16 participants were reluctant to include 
a drive-by fix with the proposed resolution for this issue since the ambiguous literal encoding reference i
s a pre-existing and separable issue. Those same SG16 participants were more concerned that the same 
wording was used in both 31.12.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmtr.funcs">[fs.path.fmtr.funcs]</a> p5 and in the corresponding entry of the 
implementation-defined behavior index. I would defer to the LWG chair to decide whether to address this 
as an additional related clarification with this change or as a separate editorial or LWG issue.
<p/>
The minimal change is to replace "and not converting from <code class='backtick'>wchar_t</code> to UTF-8" with "and the literal encoding 
is not UTF-8". The optional change is to insert "ordinary" before "literal encoding" as well. Once that is done, 
I'll have SG16 confirm they are content with the new proposed resolution.
</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>
<li><p>Modify 31.12.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmtr.funcs">[fs.path.fmtr.funcs]</a> as indicated:</p>

<blockquote>
<pre><code>
template&lt;class FormatContext&gt;
  typename FormatContext::iterator
    format(const filesystem::path&amp; p, FormatContext&amp; ctx) const;
</code></pre>
<blockquote>
<p>
-5-
<em>Effects</em>:
Let <code class='backtick'>s</code> be <code>p.generic_string&lt;filesystem::path::value_type&gt;()</code>
if the <code class='backtick'>g</code> option is used, otherwise <code class='backtick'>p.native()</code>.
Writes <code class='backtick'>s</code> into <code class='backtick'>ctx.out()</code>, adjusted according to the <i>path-format-spec</i>.
If <code class='backtick'>charT</code> is <code class='backtick'>char</code>, <code class='backtick'>path::value_type</code> is <code class='backtick'>wchar_t</code>, and the <ins>ordinary</ins> literal encoding 
is UTF-8, then the <del>escaped path</del> <ins>(possibly escaped) string</ins>
is transcoded from the native encoding for wide character strings to UTF-8
with maximal subparts of ill-formed subsequences substituted with
<span style="font-variant:small-caps">u+fffd replacement character</span> per
the Unicode Standard, Chapter 3.9 <span style="font-variant:small-caps">u+fffd</span>
Substitution in Conversion.
If <code class='backtick'>charT</code> and <code class='backtick'>path::value_type</code> are the same then no transcoding is performed.
Otherwise, transcoding is implementation-defined.
</p>
</blockquote>
</blockquote>
</li>

<li>
Modify the entry in the index of implementation-defined behavior as indicated:
<blockquote>
transcoding of a formatted <code class='backtick'>path</code> when <code class='backtick'>charT</code> and <code class='backtick'>path::value_type</code> differ
<ins>and the ordinary literal encoding is not UTF-8</ins>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-07-30; SG16 meeting]</i></p>

<p>
SG16 unanimously approved new wording produced during the discussion.
The group concluded that the intended behavior would be best specified by
introducing additional names to denote the sequence of transformations
that produce the intended effect. Status updated SG16 &rarr; Open.
</p>



<p id="res-4070"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>
<ol>
<li><p>Modify 31.12.6.9.2 <a href="https://timsong-cpp.github.io/cppwp/fs.path.fmtr.funcs">[fs.path.fmtr.funcs]</a> as indicated:</p>

<blockquote>
<pre><code>
template&lt;class FormatContext&gt;
  typename FormatContext::iterator
    format(const filesystem::path&amp; p, FormatContext&amp; ctx) const;
</code></pre>
<blockquote>
<p>
-5-
<em>Effects</em>:
Let <code class='backtick'>s</code> be
<code>p.generic_string<del>&lt;filesystem::path::value_type&gt;</del>()</code>
if the <code class='backtick'>g</code> option is used, otherwise <code class='backtick'>p.native()</code>.
<ins>Let <code class='backtick'>s2</code> be <code class='backtick'>s</code> adjusted according to the <em>path-format-spec</em>.
Let <code class='backtick'>s3</code> be defined as follows:</ins>
<ol style="list-style-type: none">
<li>
<ins>
(5.1) &mdash;
If <code class='backtick'>charT</code> is <code class='backtick'>char</code>, <code class='backtick'>path::value_type</code> is <code class='backtick'>wchar_t</code>,
and the ordinary literal encoding is UTF-8,
<code class='backtick'>s3</code> is the result of transcoding <code class='backtick'>s2</code>
from the native encoding for wide character strings to UTF-8
with maximal subparts of ill-formed subsequences substituted
with <span style="font-variant:small-caps">U+FFFD REPLACEMENT CHARACTER</span>
per the Unicode Standard, Chapter 3.9
<span style="font-variant:small-caps">U+FFFD</span> Substitution in Conversion.
</ins>
</li>
<li>
<ins>
(5.2) &mdash;
If <code class='backtick'>charT</code> and <code class='backtick'>path::value_type</code> are the same, then <code class='backtick'>s3</code> is the same as <code class='backtick'>s2</code>.
</ins>
</li>
<li>
<ins>
(5.3) &mdash;
Otherwise, <code class='backtick'>s3</code> is the result of an implementation-defined transcoding of <code class='backtick'>s2</code>.
</ins>
</li>
</ol>
<ins>Writes <code>s3</code> into <code class='backtick'>ctx.out()</code>.</ins>
<del>
Writes <code class='backtick'>s</code> into <code class='backtick'>ctx.out()</code>,
adjusted according to the <i>path-format-spec</i>.
If <code class='backtick'>charT</code> is <code class='backtick'>char</code>, <code class='backtick'>path::value_type</code> is <code class='backtick'>wchar_t</code>, and the literal encoding 
is UTF-8, then the escaped path
is transcoded from the native encoding for wide character strings to UTF-8
with maximal subparts of ill-formed subsequences substituted with
<span style="font-variant:small-caps">u+fffd replacement character</span> per
the Unicode Standard, Chapter 3.9 <span style="font-variant:small-caps">u+fffd</span>
Substitution in Conversion.
If <code class='backtick'>charT</code> and <code class='backtick'>path::value_type</code> are the same then no transcoding is performed.
Otherwise, transcoding is implementation-defined.
</del>
</p>
</blockquote>
</blockquote>
</li>

<li>
Modify the entry in the index of implementation-defined behavior as indicated:
<blockquote>
transcoding of a formatted <code class='backtick'>path</code> when <code class='backtick'>charT</code> and <code class='backtick'>path::value_type</code> differ
<ins>and the ordinary literal encoding is not UTF-8</ins>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4073"><a href="4073">4073</a>. <code class='backtick'>concat_view::size</code> may overflow</h3>
<p><b>Section:</b> 25.7.18.2 <a href="https://timsong-cpp.github.io/cppwp/range.concat.view">[range.concat.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-21 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.concat.view">active issues</a> in [range.concat.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.concat.view">issues</a> in [range.concat.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>concat_view::size</code> returns the sum of sizes of all underlying ranges, 
and the return type is specified to be the common type of all sizes, which may lead to 
potential overflow:
</p>
<blockquote><pre>
auto r = std::views::iota(0uz, SIZE_MAX);
std::print("{}\n", r.size());            // 18446744073709551615 (size_t)
std::print("{}\n", r.end() - r.begin()); // 18446744073709551615 (__int128)

auto c = std::views::concat(r, r);    
std::print("{}\n", c.size());            // <span style="color:red;font-weight:bolder">18446744073709551614 (size_t)</span>
std::print("{}\n", c.end() - c.begin()); // 36893488147419103230 (__int128)
</pre></blockquote>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Same behaviour as <code class='backtick'>join_view</code>, was there some discussion of this being
covered by general wording?
</p>



<p id="res-4073"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4075"><a href="4075">4075</a>. Thread stability requirement on constructors and destructors</h3>
<p><b>Section:</b> 16.4.4 <a href="https://timsong-cpp.github.io/cppwp/utility.requirements">[utility.requirements]</a> <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2024-04-21 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.requirements">active issues</a> in [utility.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.requirements">issues</a> in [utility.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P0260R8" title=" C++ Concurrent Queues">P0260R8</a> had a requirement for constructors and destructors of
concurrent queue value types to return on the same thread where it was called.
<p/>
During the discussion in Tokyo, SG1 decided this to be a general
issue and not specific to concurrent queues.
</p>


<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Send to SG1.
</p>



<p id="res-4075"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4077"><a href="4077">4077</a>. Unclear preconditions of <code class='backtick'>std::ranges::generate_random</code></h3>
<p><b>Section:</b> 26.12.2 <a href="https://timsong-cpp.github.io/cppwp/alg.rand.generate">[alg.rand.generate]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-04-21 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.rand.generate">issues</a> in [alg.rand.generate].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Per discussion in <a href="https://github.com/cplusplus/draft/pull/6904">cplusplus/draft#6904</a>, 
the preconditions of <code class='backtick'>std::ranges::generate_random</code> are specified in an unusual way. 
It also appears that the "shall be equivalent" imposes requirements on both implementation and user code, 
and the requirements are not very clear. 
Perhaps we should clarify the conditions in usual <i>Preconditions</i> paragraphs.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
When reviewing this we were clear this imposes requirements on users.
</p>



<p id="res-4077"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4078"><a href="4078">4078</a>. What if arguments alias the output buffer in <code class='backtick'>std::format_to</code>?</h3>
<p><b>Section:</b> 28.5.5 <a href="https://timsong-cpp.github.io/cppwp/format.functions">[format.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2024-04-24 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#format.functions">issues</a> in [format.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>
int main() {
  int x = 12345;
  // note: this is "awoo" followed by 28 zeros (9.5.3 <a href="https://timsong-cpp.github.io/cppwp/dcl.init.string">[dcl.init.string]</a> p3)
  char buffer[32] = "awoo";
  std::format_to(buffer, "{}{}", x, buffer);
  std::println("{}", buffer);
}
</pre></blockquote>
<p>
The output of this code is unspecified to be either <code>"1234512345"</code> or <code>"12345awoo"</code>, 
where GCC currently outputs the former. Formatting occurs through function calls 
(see 28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> p1) and those cannot be unsequenced, however, it's also 
nowhere stated in what order the arguments get formatted and how the output iterator is advanced 
between calls to the formatters.
<p/>
The status quo is undesirable because unspecified formatting output is not useful to the user, 
and the lack of a precondition which would forbid aliasing between arguments and the output buffer 
restricts the implementation.
<p/>
My intuition is to add <i>Preconditions</i> specifications to functions in 28.5.5 <a href="https://timsong-cpp.github.io/cppwp/format.functions">[format.functions]</a> 
which would forbid the output range of the output iterator to overlap ranges of the arguments.
<p/>
A friend of mine has suggested to add a <i>Preconditions</i> to the <i>BasicFormatter</i> requirements 
instead, dealing with the issue at the root (<code>f.format(u, fc)</code>).
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p>
We should prohibit aliasing, so this is undefined.
</p>



<p id="res-4078"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4080"><a href="4080">4080</a>. Presumed value and difference types of an iterator type in ranges and non-ranges algorithms</h3>
<p><b>Section:</b> 24.3.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.assoc.types">[iterator.assoc.types]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-04-26 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given an iterator type <code>I</code>, currently both <code>std::iter_value_t&lt;I&gt;</code> and 
<code>std::iterator_traits&lt;I&gt;::value_type</code> can be called the value type of <code>I</code>. 
These two types can be different if one specializes <code>std::indirect_readable_traits</code> for 
<code>I</code> such that <code>std::indirect_readable_traits&lt;I&gt;::value_type</code> is different 
from <code>I::value_type</code>.
<p/>
It seems intended that ranges algorithms use <code>std::iter_value_t&lt;I&gt;</code> and non-ranges algorithms, 
along with other legacy iterator-related mechanisms, use <code>std::iterator_traits&lt;I&gt;::value_type</code>. 
But this doesn't seem clarified anywhere.
<p/>
<a href="https://wg21.link/P2408R5" title=" Ranges iterators as inputs to non-Ranges algorithms">P2408R5</a> made the situation more complicated. In C++23, the type requirements of 
non-mutating iterators passed to many legacy algorithms were changed to C++20 iterator concepts, 
which are strongly associated with <code>std::iter_value_t</code>. It didn't seem intended that 
implementations were expected to use possibly different value types since C++23, but such reading
might be suggested by the use of concepts.
<p/>
Likewise, a non-random-access iterator type <code>I</code> can have two different difference types 
if one specializes <code>std::incrementable_traits</code> for <code>I</code> such that 
<code>std::incrementable_traits&lt;I&gt;::difference_type</code> is different from <code>I::difference_type</code>. 
It's also unclear which one should be used for non-mutating iterator in algorithms.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4080"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4081"><a href="4081">4081</a>. <code>concat_view::<i>iterator</i>::operator-</code> is overconstrained</h3>
<p><b>Section:</b> 25.7.18.3 <a href="https://timsong-cpp.github.io/cppwp/range.concat.iterator">[range.concat.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-26 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.concat.iterator">active issues</a> in [range.concat.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.concat.iterator">issues</a> in [range.concat.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, two <code>concat_view::<i>iterator</i></code>s can only be subtracted if
<code><i>concat-is-random-access</i></code> is satisfied, which seems overconstrained since the implementation
does not rely on all underlying ranges being <code>random_access_range</code> or <code>common_range</code>.
<p/>
Generally speaking, iterators provide <code>operator-</code> mainly based on whether it satisfies 
<code>sized_sentinel_for</code> rather than being category-specific.
For example, <code>counted_iterator</code>s that only model <code>input_iterator</code> can still be subtracted.
We have no reason to reject the following:
</p>
<blockquote><pre>
std::list l = {1, 2, 3};
auto r = l | std::views::take(3);
auto c = std::ranges::concat_view{r};
auto it = c.begin();
it++;
auto d = it - c.begin(); // <span style="color:red;font-weight:bolder">error: no match for 'operator-'</span>
</pre></blockquote>
<p>
The proposed resolution lists a minimal constraint formula based on the implementation details of <code>operator-</code>.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4081"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>
<li><p>Modify 25.7.18.3 <a href="https://timsong-cpp.github.io/cppwp/range.concat.iterator">[range.concat.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp;
              <i>concatable</i>&lt;Views...&gt;
  template&lt;bool Const&gt;
  class concat_view&lt;Views...&gt;::<i>iterator</i> {

  public:
    [&hellip;]
    friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
      requires <del><i>concat-is-random-access</i>&lt;Const, Views...&gt;</del><ins><i>see below</i></ins>;
    [&hellip;]
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y)
  requires <del><i>concat-is-random-access</i>&lt;Const, Views...&gt;</del><ins><i>see below</i></ins>;
</pre>
<blockquote>
<p>
-32- <i>Preconditions</i>: <code>x.<i>it_</i>.valueless_by_exception()</code> and
<code>y.<i>it_</i>.valueless_by_exception()</code> are each <code>false</code>.
</p>
<p>
-33- <i>Effects</i>: Let <code><i>i</i><sub>x</sub></code> denote <code>x.<i>it_</i>.index()</code> and
<code><i>i</i><sub>y</sub></code> denote <code>y.<i>it_</i>.index()</code>.
</p>
<ol style="list-style-type: none">
<li>
<p>(33.1) &mdash; if <code><i>i</i><sub>x</sub> &gt; <i>i</i><sub>y</sub></code>, let
  <code><i>d</i><sub>y</sub></code> be <code>ranges::distance(std::get&lt;<i>i</i><sub>y</sub>&gt;(y.<i>it_</i>),
    ranges::end(std::get&lt;<i>i</i><sub>y</sub>&gt;(y.<i>parent_</i>-&gt;<i>views_</i>)))</code>,
  <code><i>d</i><sub>x</sub></code> be
  <code>ranges::distance(ranges::begin(std::get&lt;<i>i</i><sub>x</sub>&gt;(x.<i>parent_</i>-&gt;<i>views_</i>)),
    std::get&lt;<i>i</i><sub>x</sub>&gt;(x.<i>it_</i>))</code>. 
  Let <code><i>s</i></code> denote the sum of the sizes of all the ranges
  <code>std::get&lt;<i>i</i>&gt;(x.<i>parent_</i>-><i>views_</i>)</code> for every integer <code><i>i</i></code> in
  the range <code>[<i>i</i><sub>y</sub> + 1, <i>i</i><sub>x</sub>)</code>
  if there is any, and <code>0</code> otherwise, of type <code>difference_type</code>, equivalent to:
</p>
<blockquote>
<pre>return <i>d</i><sub>y</sub> + <i>s</i> + <i>d</i><sub>x</sub>;</pre>
</blockquote>
<p>(33.2) &mdash; otherwise, if <code><i>i</i><sub>x</sub> &lt; <i>i</i><sub>y</sub></code>
  is <code>true</code>, equivalent to:</p>
<blockquote>
<pre>return -(y - x);</pre>
</blockquote>
<p>(33.3) &mdash; otherwise, equivalent to:</p>
<blockquote>
<pre>return std::get&lt;<i>i</i><sub>x</sub>&gt;(x.<i>it_</i>) - std::get&lt;<i>i</i><sub>y</sub>&gt;(y.<i>it_</i>);</pre>
</blockquote>
</li>
</ol>
<p>
<ins>-?- <i>Remarks</i>: Let <code>Fs</code> be the pack that consists of all elements of <code>Views</code> except the
last element, and let <code>Rs</code> be the pack that consists of all elements of <code>Views</code> except the first
element. The expression in the <i>requires-clause</i> is equivalent to:</ins>
</p>
<blockquote>
<pre><ins>(sized_sentinel_for&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;,
                    iterator_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...) &amp;&amp;
(sized_sentinel_for&lt;sentinel_t&lt;<i>maybe-const</i>&lt;Const, Fs&gt;&gt;,
                    iterator_t&lt;<i>maybe-const</i>&lt;Const, Fs&gt;&gt;&gt; &amp;&amp; ...) &amp;&amp;
<i>all-forward</i>&lt;Const, Rs...&gt;</ins></pre>
</blockquote>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4087"><a href="4087">4087</a>. Standard exception messages have unspecified encoding</h3>
<p><b>Section:</b> 17.9.3 <a href="https://timsong-cpp.github.io/cppwp/exception">[exception]</a> <b>Status:</b> <a href="lwg-active.html#SG16">SG16</a>
 <b>Submitter:</b> Victor Zverovich <b>Opened:</b> 2024-04-28 <b>Last modified:</b> 2024-05-08</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#exception">issues</a> in [exception].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG16">SG16</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The null-terminated multibyte string returned by the <code>what</code> method of <code>std::exception</code> 
and its subclasses in the standard has an unspecified encoding. The closest thing in the specification 
is the "suitable for conversion and display as a <code>wstring</code>" part in <i>Remarks</i> 
(17.9.3 <a href="https://timsong-cpp.github.io/cppwp/exception">[exception]</a> p6) but it is too vague to be useful because anything can be converted to 
<code>wstring</code> in one way or another:
</p>
<blockquote>
<pre>
virtual const char* what() const noexcept;
</pre>
<blockquote>
<p>
<i>Returns</i>: An implementation-defined <span style="font-variant:small-caps">ntbs</span>.
<p/>
<i>Remarks</i>: The message may be a null-terminated multibyte string (16.3.3.3.4.3 <a href="https://timsong-cpp.github.io/cppwp/multibyte.strings">[multibyte.strings]</a>), 
suitable for conversion and display as a <code>wstring</code> (27.4 <a href="https://timsong-cpp.github.io/cppwp/string.classes">[string.classes]</a>, 
28.3.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a>). The return value remains valid until the exception object from which it 
is obtained is destroyed or a non-<code>const</code> member function of the exception object is called.
</p>
</blockquote>
</blockquote>
<p>
As a result, it is impossible to portably use the exception message, e.g. print it. Since exception 
messages are commonly combined with string literals and are often constructed from string literals, 
at the very least the standard should say that the message is compatible with them, i.e. that it is 
in the ordinary literal encoding or its subset.
<p/>
To give a specific example of this problem, consider the following code compiled on Windows with 
Microsoft Visual C++, the ordinary literal encoding of UTF-8 and the system locale set to Belarusian 
(the language of the text in this example):
</p>
<blockquote>
<pre>
std::uintmax_t size = 0;
try {
  size = std::filesystem::file_size(L"");
} catch (const std::exception&amp; e) {
  std::print(": {}", e.what());
}
</pre>
</blockquote>
<p>
Since both <code>std::filesystem::path</code> and <code>std::print</code> support Unicode one would expect this 
to work and, when run, print a readable error message if the file "" doesn't exist. However, 
the output will be corrupted instead. The reason for the corruption is that <code>filesystem_error</code> 
requires including the path in the message but doesn't say that it should be transcoded 
(31.12.7.2 <a href="https://timsong-cpp.github.io/cppwp/fs.filesystem.error.members">[fs.filesystem.error.members]</a> p7):
</p>
<blockquote>
<pre>
virtual const char* what() const noexcept;
</pre>
<blockquote>
<p>
<i>Returns</i>: An <span style="font-variant:small-caps">ntbs</span> that incorporates the <code>what_arg</code> 
argument supplied to the constructor. The exact format is unspecified. Implementations should include the 
<code>system_error::what()</code> string and the pathnames of <code>path1</code> and <code>path2</code> in the native 
format in the returned string.
</p>
</blockquote>
</blockquote>
<p>
Therefore, the message will contain literal text in the ordinary literal encoding (UTF-8) combined with a 
path, most likely in the operating system dependent current encoding for pathnames which in this case is CP1251. 
So different parts of the output will be in two incompatible encodings and therefore unusable with 
<code>std::print</code> or any other facility.
<p/>
The actual observable behavior for the above example is no output in the Windows console which 
is extremely broken but appears to be conformant with the current specification. It was reproduced with 
{fmt}'s implementation of <code>print</code> since Microsoft STL doesn't implement <code>std::print</code> yet. 
Replacing <code>std::print</code> with another output facility produces a different but equally unusable form 
of mojibake.
</p>

<p><i>[2024-05-04; Daniel comments]</i></p>

<p>
The proposed wording is incomplete. There are about 12 other <code>what</code> specifications in the Standard
Library with exactly the same specification as <code>exception::what</code> that would either need to get the 
same treatment or we would need general wording somewhere that says that the specification "contract" of 
<code>exception::what</code> extends to all of its derived classes. A third choice could be that we introduce 
a new definition such as an <span style="font-variant:small-caps">lntbs</span> (or maybe "literal 
<span style="font-variant:small-caps">ntbs</span>") that is essentially an 
<span style="font-variant:small-caps">ntbs</span> in the ordinary literal encoding.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Send to SG16.
</p>



<p id="res-4087"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 17.9.3 <a href="https://timsong-cpp.github.io/cppwp/exception">[exception]</a> as indicated:</p>

<blockquote>
<pre>
virtual const char* what() const noexcept;
</pre>
<blockquote>
<p>
<i>Returns</i>: An implementation-defined <span style="font-variant:small-caps">ntbs</span> 
<ins>in the ordinary literal encoding</ins>.
<p/>
<i>Remarks</i>: The message may be a null-terminated multibyte string (16.3.3.3.4.3 <a href="https://timsong-cpp.github.io/cppwp/multibyte.strings">[multibyte.strings]</a>), 
suitable for conversion and display as a <code>wstring</code> (27.4 <a href="https://timsong-cpp.github.io/cppwp/string.classes">[string.classes]</a>, 
28.3.4.2.5 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt">[locale.codecvt]</a>). The return value remains valid until the exception object from which it 
is obtained is destroyed or a non-<code>const</code> member function of the exception object is called.
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4089"><a href="4089">4089</a>. <code>concat_view::<i>iterator</i></code>'s <code>iter_swap</code> is overconstrained</h3>
<p><b>Section:</b> 25.7.18.3 <a href="https://timsong-cpp.github.io/cppwp/range.concat.iterator">[range.concat.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-04-30 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.concat.iterator">active issues</a> in [range.concat.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.concat.iterator">issues</a> in [range.concat.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the underlying iterator of two <code>concat_view::<i>iterator</i></code>s are of different types,
their <code>iter_swap</code> will dispatch <code>ranges::swap</code> to swap elements, which is reflected 
in its constraints of <code>swappable_with&lt;iter_reference_t&lt;<i>iterator</i>&gt;,
iter_reference_t&lt;<i>iterator</i>&gt;&gt;</code>.
<p/>
However, when the underlying iterators are all of the same type, <code>ranges::swap</code> will never 
be invoked, making checking for <code>swappable_with</code> unnecessary in this case.
<p/>
This results in the current wording rejecting the following:
</p>
<blockquote>
<pre>
struct I {
  using value_type = int;
  using difference_type = int;
  std::reference_wrapper&lt;int&gt; operator*() const;
  I&amp; operator++();
  void operator++(int);
  bool operator==(const I&amp;) const;
  friend void iter_swap(const I&amp;, const I&amp;); // custom iter_swap
};

static_assert(std::indirectly_swappable&lt;I&gt;);

int main() {
  std::ranges::subrange&lt;I, I&gt; s1, s2;
  std::ranges::swap_ranges(s1, s2);
  std::ranges::concat_view c1{s1}, c2{s2};
  std::ranges::swap_ranges(c1, c2); // <span style="color:red;font-weight:bolder">ill-formed</span>
}
</pre>
</blockquote>
<p>
Because <code>reference_wrapper</code> does not satisfy <code>swappable_with</code>, <code>concat_view::<i>iterator</i></code>
does not have a valid <code>iter_swap</code>, leading to the constraints of <code>swap_ranges</code> being unsatisfied.
<p/>
This doesn't seem like it should be, and I think providing a simplified homogeneous <code>iter_swap</code> specialization
for <code>concat_view::<i>iterator</i></code> is reasonable.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
An extreme corner case, probably not worth caring about.
</p>



<p id="res-4089"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 25.7.18.3 <a href="https://timsong-cpp.github.io/cppwp/range.concat.iterator">[range.concat.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp;
              <i>concatable</i>&lt;Views...&gt;
  template&lt;bool Const&gt;
  class concat_view&lt;Views...&gt;::<i>iterator</i> {

  public:
    using iterator_category = <i>see below</i>;                                // <i>not always present.</i>
    using iterator_concept = <i>see below</i>;
    using value_type = <i>concat-value-t</i>&lt;<i>maybe-const</i>&lt;Const, Views&gt;...&gt;;
    using difference_type = common_type_t&lt;range_difference_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;...&gt;;

  private:
    <ins>static constexpr bool <i>concat-is-homogeneous</i> = <i>see below</i>;                // <i>exposition only</i></ins>
    using <i>base-iter</i> =                                                       // <i>exposition only</i>
      variant&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;...&gt;;
    
    [&hellip;]

    <ins>friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) noexcept(<i>see below</i>)
      requires <i>concat-is-homogeneous</i> &amp;&amp; 
               indirectly_swappable&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, Views...[0]&gt;&gt;&gt;;</ins>
    friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) noexcept(<i>see below</i>)
      requires <del><i>see below</i></del><ins>(!<i>concat-is-homogeneous</i>) &amp;&amp;
               swappable_with&lt;iter_reference_t&lt;<i>iterator</i>&gt;, iter_reference_t&lt;<i>iterator</i>&gt;&gt; &amp;&amp;
               (... &amp;&amp; indirectly_swappable&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;&gt;)</ins>;
  }
  [&hellip;]
}
</pre>
</blockquote>
<p>
<ins>-?- <code><i>concat-is-homogeneous</i></code> is <code>true</code> if and only if the pack of types
<code>iterator_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;...</code> are all the same.</ins>
<p/>
-1- <code>iterator::<i>iterator_concept</i></code> is defined as follows:
<p/>
[&hellip;]
</p>
<pre>
<ins>friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) noexcept(<i>see below</i>)
  requires <i>concat-is-homogeneous</i> &amp;&amp;
           indirectly_swappable&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, Views...[0]&gt;&gt;&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: <code>x.<i>it_</i>.valueless_by_exception()</code> and
<code>y.<i>it_</i>.valueless_by_exception()</code> are each <code>false</code>.</ins>
<p/>
<ins>-?- <i>Effects</i>: Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>std::visit(ranges::iter_swap, x.<i>it_</i>, y.<i>it_</i>);</ins>
</pre></blockquote>
<p>
<ins>-?- <i>Remarks</i>: The exception specification is equivalent to</ins>
</p>
<blockquote><pre>
<ins>noexcept(ranges::iter_swap(std::get&lt;0&gt;(x.<i>it_</i>), std::get&lt;0&gt;(y.<i>it_</i>)))</ins>
</pre></blockquote>
</blockquote>
<pre>
friend constexpr void iter_swap(const <i>iterator</i>&amp; x, const <i>iterator</i>&amp; y) noexcept(<i>see below</i>)
  requires <del><i>see below</i></del><ins>(!<i>concat-is-homogeneous</i>) &amp;&amp;
           swappable_with&lt;iter_reference_t&lt;<i>iterator</i>&gt;, iter_reference_t&lt;<i>iterator</i>&gt;&gt; &amp;&amp;
           (... &amp;&amp; indirectly_swappable&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;&gt;)</ins>;
</pre>
<blockquote>
<p>
-42- <i>Preconditions</i>: <code>x.<i>it_</i>.valueless_by_exception()</code> and
<code>y.<i>it_</i>.valueless_by_exception()</code> are each <code>false</code>.
<p/>
-43- <i>Effects</i>: Equivalent to:
</p>
<blockquote>
<pre>
std::visit([&amp;](const auto&amp; it1, const auto&amp; it2) {
    if constexpr (is_same_v&lt;decltype(it1), decltype(it2)&gt;) {
      ranges::iter_swap(it1, it2);
    } else {
      ranges::swap(*x, *y);
    }
  },
  x.<i>it_</i>, y.<i>it_</i>);
</pre>
</blockquote>
<p>
-44- <i>Remarks</i>: The exception specification is equivalent to
</p>
<blockquote><pre>
(noexcept(ranges::swap(*x, *y)) &amp;&amp; ... &amp;&amp; noexcept(ranges::iter_swap(its, its)))
</pre></blockquote>
<p>
where <code>its</code> is a pack of lvalues of type <code>const iterator_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;</code> 
respectively.
</p>
<p>
<del>The expression in the <i>requires-clause</i> is equivalent to</del>
</p>
<blockquote><pre>
<del>swappable_with&lt;iter_reference_t&lt;<i>iterator</i>&gt;, iter_reference_t&lt;<i>iterator</i>&gt;&gt; &amp;&amp;
(... &amp;&amp; indirectly_swappable&lt;iterator_t&lt;<i>maybe-const</i>&lt;Const, Views&gt;&gt;&gt;)</del>
</pre></blockquote>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4090"><a href="4090">4090</a>. Underspecified use of locale facets for locale-dependent <code>std::format</code></h3>
<p><b>Section:</b> 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2024-04-30 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.string.std">active issues</a> in [format.string.std].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.string.std">issues</a> in [format.string.std].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are <code>std::format</code> variants that take an explicit <code>std::locale</code> parameter.
There is the <code>"L"</code> format specifier that uses that locale (or some environment
locale) for formatting, according to 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> p17:
</p>
<blockquote>
<p>
"For integral types, the locale-specific form causes the context's locale to
be used to insert the appropriate digit group separator characters."
</p>
</blockquote>
<p>
It is unclear which specific facets are used to make this happen.
This is important, because users can install their own facets into
a given locale. Specific questions include:
</p>
<ul>
<li><p>Is <code>num_put&lt;&gt;</code> being used? Or just <code>numpunct&lt;&gt;</code>?</p></li>
<li><p> Are any of the <code>_byname</code> facets being used?</p></li>
</ul>
<p>
Assuming the encoding for <code>char</code> is UTF-8, the use of a user-provided
<code>num_put&lt;&gt;</code> facet (as opposed to <code>std::format</code> creating the output based on
<code>numpunct&lt;&gt;</code>) would allow digit separators that are not expressibly as a
single UTF-8 code unit.
</p>

<p><i>[2024-05-08; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2024-06-12; SG16 meeting]</i></p>

<p>
The three major implementations all use <code class='backtick'>numpunct</code> but not <code class='backtick'>num_put</code>,
clarify that this is the intended behaviour.
</p>

<p><i>[2025-06-12; Jonathan provides wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> as indicated:</p>

<blockquote>
-17-
When the <code class='backtick'>L</code> option is used, the form used for the conversion is called the
<i>locale-specific</i> form.
The <code class='backtick'>L</code> option is only valid for arithmetic types,
and its effect depends upon the type.
<ol style="list-style-type: none">
<li>
(17.1) &mdash;
For integral types, the locale-specific form causes the contexts locale
to be used to insert the appropriate digit group separator characters
<ins>
as if obtained with <code>numpunct<ins>&lt;charT&gt;</ins>::grouping</code>
and <code>numpunct<ins>&lt;charT&gt;</ins>::thousands_sep</code>
</ins>.
</li>
<li>
(17.2) &mdash;
For floating-point types, the locale-specific form causes the contexts locale to be used to insert the
appropriate digit group and radix separator characters
<ins>
as if obtained with <code>numpunct<ins>&lt;charT&gt;</ins>::grouping</code>,
<code>numpunct<ins>&lt;charT&gt;</ins>::thousands_sep</code>, and
<code>numpunct<ins>&lt;charT&gt;</ins>::decimal_point</code>
</ins>.
</li>
<li>
(17.3) &mdash;
For the textual representation of <code class='backtick'>bool</code>, the locale-specific form causes
the contexts locale to be used to insert the appropriate string
as if obtained with <code>numpunct<ins>&lt;charT&gt;</ins>::truename</code>
or <code>numpunct<ins>&lt;charT&gt;</ins>::falsename</code>.
</li>
</ol>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2025-08-27; SG16 meeting]</i></p>

<p>
SG16 unanimously approved new wording from Victor.
The new wording incorporates similar wording as added by <a href="https://wg21.link/P2419R2" title=" Clarify handling of encodings in localized formatting of chrono types">P2419R2</a>
to address <a href="3565" title="Handling of encodings in localized formatting of chrono types is underspecified (Status: Resolved)">3565</a>. Status updated SG16 &rarr; Open.
</p>



<p id="res-4090"><b>Proposed resolution:</b></p>

<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>
<li><p>Modify 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> as indicated:</p>

<blockquote>
-17-
When the <code class='backtick'>L</code> option is used, the form used for the conversion is called the
<i>locale-specific</i> form.
The <code class='backtick'>L</code> option is only valid for arithmetic types,
and its effect depends upon the type.
<ol style="list-style-type: none">
<li>
(17.1) &mdash;
For integral types, the locale-specific form causes the contexts locale
to be used to insert the appropriate digit group separator characters
<ins>
as if obtained with <code>numpunct<ins>&lt;charT&gt;</ins>::grouping</code>
and <code>numpunct<ins>&lt;charT&gt;</ins>::thousands_sep</code>
</ins>.
</li>
<li>
(17.2) &mdash;
For floating-point types, the locale-specific form causes the contexts locale to be used to insert the
appropriate digit group and radix separator characters
<ins>
as if obtained with <code>numpunct<ins>&lt;charT&gt;</ins>::grouping</code>,
<code>numpunct<ins>&lt;charT&gt;</ins>::thousands_sep</code>, and
<code>numpunct<ins>&lt;charT&gt;</ins>::decimal_point</code>
</ins>.
</li>
<li>
(17.3) &mdash;
For the textual representation of <code class='backtick'>bool</code>, the locale-specific form causes
the contexts locale to be used to insert the appropriate string
as if obtained with <code>numpunct<ins>&lt;charT&gt;</ins>::truename</code>
or <code>numpunct<ins>&lt;charT&gt;</ins>::falsename</code>.
</li>
</ol>
<ins>
If the string literal encoding is a Unicode encoding form
and the locale is among an implementation-defined set of locales,
each replacement that depends on the locale is performed as if
the replacement character sequence is converted to the string literal encoding.
</ins>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4091"><a href="4091">4091</a>. <code>concat_view</code> rejects non-movable references</h3>
<p><b>Section:</b> 25.7.18.2 <a href="https://timsong-cpp.github.io/cppwp/range.concat.view">[range.concat.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-01 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.concat.view">active issues</a> in [range.concat.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.concat.view">issues</a> in [range.concat.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to prevent non-equality-preserving behavior of <code>operator*</code> and <code>iter_move</code>, 
<code>concat_view</code> introduces the <code><i>concat-indirectly-readable</i></code> concept, part of which is:
</p>
<blockquote><pre>
template&lt;class Ref, class RRef, class It&gt;
  concept <i>concat-indirectly-readable-impl</i> =                         // <i>exposition only</i>
    requires (const It it) {
      { *it } -&gt; convertible_to&lt;Ref&gt;;
      { ranges::iter_move(it) } -&gt; convertible_to&lt;RRef&gt;;
    };
</pre></blockquote>
<p>
This isn't quite right because <code>convertible_to</code> checks <code>is_convertible_v</code> which doesn't 
understand copy elision. This makes the current <code>concat_view</code> unable to work with ranges whose 
reference is non-movable prvalue:
</p>
<blockquote><pre>
auto r = std::views::iota(0, 5)
       | std::views::transform([](int) { return NonMovable{}; });
auto c1 = std::ranges::concat_view(r);    // <span style="color:red;font-weight:bolder">ill-formed, concat_indirectly_readable not satisfied</span>
auto c2 = std::ranges::concat_view(r, r); // <span style="color:red;font-weight:bolder">ditto</span>
</pre></blockquote>
<p>
Since <code>std::visit&lt;R&gt;</code> is used in the implementation to perform reference conversion for the 
underlying iterator, the more accurate one should be <code>is_invocable_r</code> which does understand guaranteed 
elision.
<p/>
Note that <code>join_with_view</code> has the same issue because <code><i>compatible-joinable-ranges</i></code> 
requires that the <code>value_type</code> of the inner range and pattern range must satisfy <code>common_with</code>, 
which always fails for non-movable types. However, this can be automatically resolved by LWG 
<a href="4074" title="compatible-joinable-ranges is underconstrained (Status: WP)">4074</a>'s resolution.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"Proposed resolution loses the existing requirement that the conversion
is equality-preserving."
"Don't care about rejecting non-movable reference types."
</p>



<p id="res-4091"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 25.7.18.2 <a href="https://timsong-cpp.github.io/cppwp/range.concat.view">[range.concat.view]</a> as indicated:</p>

<blockquote>
<p>
-1- The exposition-only <code><i>concat-indirectly-readable</i></code> concept is equivalent to:
</p>
<blockquote>
<pre>
<ins>template&lt;class Ref, class CRef&gt;
concept <i>concat-ref-compatible-with</i> = is_invocable_r_v&lt;CRef, Ref()&gt;;  // <i>exposition only</i></ins>
  
template&lt;class Ref, class RRef, class It&gt;
concept <i>concat-indirectly-readable-impl</i> =                         // <i>exposition only</i>
  requires (const It it) {
    { *it } -&gt; <del>convertible_to</del><ins><i>concat-ref-compatible-with</i></ins>&lt;Ref&gt;;
    { ranges::iter_move(it) } -&gt; <del>convertible_to</del><ins><i>concat-ref-compatible-with</i></ins>&lt;RRef&gt;;
  };

template&lt;class... Rs&gt;
  concept <i>concat-indirectly-readable</i> =                              // <i>exposition only</i>
    common_reference_with&lt;<i>concat-reference-t</i>&lt;Rs...&gt;&amp;&amp;,
                          <i>concat-value-t</i>&lt;Rs...&gt;&amp;&gt; &amp;&amp;
    common_reference_with&lt;<i>concat-reference-t</i>&lt;Rs...&gt;&amp;&amp;,
                          <i>concat-rvalue-reference-t</i>&lt;Rs...&gt;&amp;&amp;&gt; &amp;&amp;
    common_reference_with&lt;<i>concat-rvalue-reference-t</i>&lt;Rs...&gt;&amp;&amp;,
                          <i>concat-value-t</i>&lt;Rs...&gt; const&amp;&gt; &amp;&amp;
    (<i>concat-indirectly-readable-impl</i>&lt;<i>concat-reference-t</i>&lt;Rs...&gt;,
                                     <i>concat-rvalue-reference-t</i>&lt;Rs...&gt;,
                                     iterator_t&lt;Rs&gt;&gt; &amp;&amp; ...);
</pre>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4092"><a href="4092">4092</a>. The monotonic version of <code>common_iterator::operator==</code> is underconstrained</h3>
<p><b>Section:</b> 24.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/common.iterator">[common.iterator]</a>, 24.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/common.iter.cmp">[common.iter.cmp]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-01 <b>Last modified:</b> 2024-07-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#common.iterator">active issues</a> in [common.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#common.iterator">issues</a> in [common.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>common_iterator</code> has the following equality operator:
</p>
<blockquote><pre>
template&lt;class I2, sentinel_for&lt;I&gt; S2&gt;
    requires sentinel_for&lt;S, I2&gt;
  friend constexpr bool operator==(
    const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</pre></blockquote>
<p>
which is quite useful when wrapping a C++20 <code>input_iterator</code> that does not model <code>equality_comparable</code> 
so that the quality operator required by the <i>Cpp17InputIterator</i> can still be synthesized.
<p/>
However, the function signature does not check the correlation between <code>I2</code> and <code>I</code>, 
which allows a <code>common_iterator</code> wrapping two completely unrelated iterators to validly compare 
(<a href="https://godbolt.org/z/Erce8dETT">demo</a>):
</p>
<blockquote><pre>
common_iterator&lt;string::iterator, unreachable_sentinel_t&gt; i1;
common_iterator&lt;list&lt;int&gt;::iterator, unreachable_sentinel_t&gt; i2;
i1 == i2; // <span style="color:red;font-weight:bolder">unfortunately compile</span>
</pre></blockquote>
<p>
The proposed resolution requires <code>common_with&lt;I, I2&gt;</code> to be satisfied to enhance semantics, 
which is also consistent with the signature of <code>counted_iterator::operator==</code>.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Seems unlikely to be a problem in practice.
Proposed resolution would make the two <code class='backtick'>operator==</code> overloads ambiguous.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 24.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/common.iterator">[common.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    requires (!same_as&lt;I, S&gt; &amp;&amp; copyable&lt;I&gt;)
  class common_iterator {
  public:
    [&hellip;]
    template&lt;<del>class</del><ins>common_with&lt;I&gt;</ins> I2, sentinel_for&lt;I&gt; S2&gt;
      requires sentinel_for&lt;S, I2&gt;
    friend constexpr bool operator==(
      const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/common.iter.cmp">[common.iter.cmp]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<del>class</del><ins>common_with&lt;I&gt;</ins> I2, sentinel_for&lt;I&gt; S2&gt;
  requires sentinel_for&lt;S, I2&gt;
friend constexpr bool operator==(
  const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: <code>x.v_.valueless_by_exception()</code> and <code>y.v_.valueless_by_exception()</code> 
are each <code>false</code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2024-07-09; Hewill provides improved wording]</i></p>



<p id="res-4092"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>

<li><p>Modify 24.5.5.1 <a href="https://timsong-cpp.github.io/cppwp/common.iterator">[common.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    requires (!same_as&lt;I, S&gt; &amp;&amp; copyable&lt;I&gt;)
  class common_iterator {
  public:
    [&hellip;]
    template&lt;<del>class</del><ins>common_with&lt;I&gt;</ins> I2, sentinel_for&lt;I&gt; S2&gt;
      requires sentinel_for&lt;S, I2&gt;
    friend constexpr bool operator==(
      const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
    template&lt;<del>class</del><ins>common_with&lt;I&gt;</ins> I2, sentinel_for&lt;I&gt; S2&gt;
      requires sentinel_for&lt;S, I2&gt; &amp;&amp; equality_comparable_with&lt;I, I2&gt;
    friend constexpr bool operator==(
      const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.5.5.6 <a href="https://timsong-cpp.github.io/cppwp/common.iter.cmp">[common.iter.cmp]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<del>class</del><ins>common_with&lt;I&gt;</ins> I2, sentinel_for&lt;I&gt; S2&gt;
  requires sentinel_for&lt;S, I2&gt;
friend constexpr bool operator==(
  const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: <code>x.v_.valueless_by_exception()</code> and <code>y.v_.valueless_by_exception()</code> 
are each <code>false</code>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;<del>class</del><ins>common_with&lt;I&gt;</ins> I2, sentinel_for&lt;I&gt; S2&gt;
  requires sentinel_for&lt;S, I2&gt; &amp;&amp; equality_comparable_with&lt;I, I2&gt;
friend constexpr bool operator==(
  const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: <code>x.v_.valueless_by_exception()</code> and <code>y.v_.valueless_by_exception()</code> 
are each <code>false</code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4093"><a href="4093">4093</a>. <code>ranges::fold_left_first_with_iter</code> incorrectly constructs <code>optional&lt;U&gt;</code></h3>
<p><b>Section:</b> 26.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-03 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.fold">active issues</a> in [alg.fold].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.fold">issues</a> in [alg.fold].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>ranges::fold_left_first_with_iter</code> constructs the initial value through 
<code>optional&lt;U&gt;(in_place, *first)</code> which is not quite right, because the exposure 
constraint only ensures that <code>U</code> can be constructed from the value type of the iterator 
rather than its reference (<a href="https://godbolt.org/z/xbEqdxoK8">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;algorithm&gt;

struct Op {
  Op() = default;
  Op(std::tuple&lt;int&gt;);
  Op(std::tuple&lt;int&amp;&gt;) = delete;
  Op operator()(Op, std::tuple&lt;int&amp;&gt;) const;
};

int main() {
  std::ranges::fold_left_first_with_iter(
    std::views::zip(std::views::single(0)), 
    Op{}
  ); // <span style="color:red;font-weight:bolder">hard error in libstdc++ and MSVC-STL</span>
}
</pre></blockquote>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Unclear what "exposure constraint" means.
"Don't want to require an extra copy to accommodate this corner case."
</p>



<p id="res-4093"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 26.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S
         <i>indirectly-binary-left-foldable</i>&lt;iter_value_t&lt;I&gt;, I&gt; F&gt;
  requires constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;
  constexpr <i>see below</i> ranges::fold_left_first_with_iter(I first, S last, F f);
template&lt;input_range R, <i>indirectly-binary-left-foldable</i>&lt;range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; F&gt;
  requires constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;
  constexpr <i>see below</i> ranges::fold_left_first_with_iter(R&amp;&amp; r, F f);
</pre>
<blockquote>
<p>
-9- Let <code>U</code> be
</p>
<blockquote><pre>
decltype(ranges::fold_left(std::move(first), last, iter_value_t&lt;I&gt;(*first), f))
</pre></blockquote>
<p>
-10- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return {std::move(first), optional&lt;U&gt;()};
optional&lt;U&gt; init(in_place, <ins>iter_value_t&lt;I&gt;(</ins>*first<ins>)</ins>);
for (++first; first != last; ++first)
  *init = invoke(f, std::move(*init), *first);
return {std::move(first), std::move(init)};
</pre></blockquote>
<p>
-11- <i>Remarks</i>: The return type is <code>fold_left_first_with_iter_result&lt;I, optional&lt;U&gt;&gt;</code>
for the first overload and <code>fold_left_first_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;, optional&lt;U&gt;&gt;</code> 
for the second overload.
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4094"><a href="4094">4094</a>. <code>ranges::fold_<i>meow</i></code> is overconstrained</h3>
<p><b>Section:</b> 26.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-03 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.fold">active issues</a> in [alg.fold].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.fold">issues</a> in [alg.fold].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The two <code>convertible_to</code> constraints required by <code>ranges::fold_<i>meow</i></code> mainly 
check whether the decayed result type of the binary operator can be constructed by both the invoke type 
and the initial value type.
<p/>
However, using <code>constructible_from</code> seems more appropriate here because we don't need to care whether 
the two types can be converted implicitly and explicitly.
Taking <code>string</code> and <code>string_view</code> as examples, the former can only be explicitly constructed by 
the latter and can be assigned by the latter, which makes <code>ranges::fold_<i>meow</i></code> unable to fold 
ranges whose elements are of type <code>string</code> with an initial value of type <code>string_view</code>:
</p>
<blockquote><pre>
vector&lt;string&gt; vs{"a", "b", "c"};
string_view init{"d"};
auto result = ranges::fold_right(vs, init, plus{}); // <span style="color:red;font-weight:bolder">still ill-formed after <a href="https://wg21.link/P2591R5" title=" Concatenation of strings and string views">P2591R5</a> as the constraint is not satisfied</span>
</pre></blockquote>
<p>
In addition, the two <code>movable</code> constraints in the function signature seem to be too strict as well since we 
only need to check that the decayed result type and the initial type can be move-constructible (one for returned by 
elidable move and one for move into other overloads) instead of whether they can be move-assignable.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"NAD. Constraining algorithms is not about limiting the constraints to
the bare minimum required by implementation details. That's what the C++0x
attempt did - in an effort to maintain backward compatibility - and it's a mess.
While the <code class='backtick'>string</code>/<code class='backtick'>string_view</code> case might look superficially appealing,
it would also allow <code>vector&lt;string&gt;</code>/<code>int</code>,
which is much less so."
</p>



<p id="res-4094"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 26.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a>, header <code>&lt;algorithm&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
#include &lt;initializer_list&gt;     // <i>see 17.11.2 <a href="https://timsong-cpp.github.io/cppwp/initializer.list.syn">[initializer.list.syn]</a></i>

namespace std {
  [&hellip;]
  namespace ranges {
    [&hellip;]
    template&lt;class F, class T, class I, class U&gt;
      concept <i>indirectly-binary-left-foldable-impl</i> =  // <i>exposition only</i>
        <del>movable</del><ins>move_constructible</ins>&lt;T&gt; &amp;&amp; <del>movable</del><ins>move_constructible</ins>&lt;U&gt; &amp;&amp;
        <del>convertible_to</del><ins>constructible_from</ins>&lt;<del>T, </del>U<ins>, T</ins>&gt; &amp;&amp; invocable&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        assignable_from&lt;U&amp;, invoke_result_t&lt;F&amp;, U, iter_reference_t&lt;I&gt;&gt;&gt;;

    template&lt;class F, class T, class I&gt;
      concept <i>indirectly-binary-left-foldable</i> =      // <i>exposition only</i>
        copy_constructible&lt;F&gt; &amp;&amp; indirectly_readable&lt;I&gt; &amp;&amp;
        invocable&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        <del>convertible_to</del><ins>constructible_from&lt;decay_t</ins>&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;<ins>&gt;</ins>,
               <del>decay_t&lt;</del>invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;<del>&gt;</del> &amp;&amp;
        <i>indirectly-binary-left-foldable-impl</i>&lt;F, T, I,
                        decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;&gt;;
    [&hellip;]
  }
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 26.6.18 <a href="https://timsong-cpp.github.io/cppwp/alg.fold">[alg.fold]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
         <i>indirectly-binary-right-foldable</i>&lt;T, I&gt; F&gt;
  constexpr auto ranges::fold_right(I first, S last, T init, F f);
template&lt;bidirectional_range R, class T = range_value_t&lt;R&gt;,
         <i>indirectly-binary-right-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
  constexpr auto ranges::fold_right(R&amp;&amp; r, T init, F f);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
using U = decay_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;I&gt;, T&gt;&gt;;
if (first == last)
  return U(std::move(init));
I tail = ranges::next(first, last);
U accum<del> =</del><ins>(</ins>invoke(f, *--tail, std::move(init))<ins>)</ins>;
while (first != tail)
  accum = invoke(f, *--tail, std::move(accum));
return accum;
</pre></blockquote>
[&hellip;]
</blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T = iter_value_t&lt;I&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, I&gt; F&gt;
  constexpr <i>see below</i> ranges::fold_left_with_iter(I first, S last, T init, F f);
template&lt;input_range R, class T = range_value_t&lt;R&gt;,
         <i>indirectly-binary-left-foldable</i>&lt;T, iterator_t&lt;R&gt;&gt; F&gt;
  constexpr <i>see below</i> ranges::fold_left_with_iter(R&amp;&amp; r, T init, F f);
</pre>
<blockquote>
<p>
-6- Let <code>U</code> be <code>decay_t&lt;invoke_result_t&lt;F&amp;, T, iter_reference_t&lt;I&gt;&gt;&gt;</code>.
<p/>
-7- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (first == last)
  return {std::move(first), U(std::move(init))};
U accum<del> =</del><ins>(</ins>invoke(f, std::move(init), *first)<ins>)</ins>;
for (++first; first != last; ++first)
  accum = invoke(f, std::move(accum), *first);
return {std::move(first), std::move(accum)};
</pre></blockquote>
<p>
-8- <i>Remarks</i>: The return type is <code>fold_left_with_iter_result&lt;I, U&gt;</code>
for the first overload and <code>fold_left_with_iter_result&lt;borrowed_iterator_t&lt;R&gt;, U&gt;</code> 
for the second overload.
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4097"><a href="4097">4097</a>. <code>views::reverse</code> should be specialized for some view types</h3>
<p><b>Section:</b> 25.7.21.1 <a href="https://timsong-cpp.github.io/cppwp/range.reverse.overview">[range.reverse.overview]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-09 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, when <code>views::reverse</code> is applied to <code>empty_view</code>, <code>single_view</code>, or 
<code>repeat_view</code>, a <code>reverse_view</code> with the iterator type <code>reverse_iterator</code> will 
be produced.
<p/>
Such an amount of instantiation seems less necessary for these three simple view types, since returning a copy 
of them is sufficient.
<p/>
Note that this also makes <code>views::repeat(0) | views::reverse | views::take(5)</code> no longer timeout, 
which seems to be an improvement.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Send to LEWG for review.
The <code class='backtick'>repeat</code> part is related to LWG <a href="4019" title="Reversing an infinite range leads to an infinite loop (Status: SG9)">4019</a>.
</p>



<p id="res-4097"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 25.7.21.1 <a href="https://timsong-cpp.github.io/cppwp/range.reverse.overview">[range.reverse.overview]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>reverse_view</code> takes a bidirectional view and produces another view that 
iterates the same elements in reverse order.
<p/>
-2- The name <code>views::reverse</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Given a subexpression <code>E</code>, the expression <code>views::reverse(E)</code>
is expression-equivalent to:</p>
<ol style="list-style-type: none">
<li>
<p>(2.1) &mdash; If the type of <code>E</code> is a (possibly cv-qualified) specialization of
<code>reverse_view</code>, equivalent to <code>E.base()</code>.</p></li>
<li><p><ins>(2.?) &mdash; Otherwise, if the type of <code>E</code> is a (possibly cv-qualified) specialization of 
<code>empty_view</code> (25.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.empty.view">[range.empty.view]</a>), <code>single_view</code> 
(25.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/range.single.view">[range.single.view]</a>), or <code>repeat_view</code> (25.6.5.2 <a href="https://timsong-cpp.github.io/cppwp/range.repeat.view">[range.repeat.view]</a>),
equivalent to <code><i>decay-copy</i>(E)</code>.</ins></p></li>
<li><p>(2.2) &mdash; Otherwise, if the type of <code>E</code> is <i>cv</i> 
<code>subrange&lt;reverse_iterator&lt;I&gt;, reverse_iterator&lt;I&gt;, K&gt;</code> for some iterator 
type <code>I</code> and value <code>K</code> of type <code>subrange_kind</code>,</p>
<ol style="list-style-type: none">
<li>
<p>(2.2.1) &mdash; if <code>K</code> is <code>subrange_kind::sized</code>, equivalent to:</p>
<blockquote>
<pre>subrange&lt;I, I, K&gt;(E.end().base(), E.begin().base(), E.size())</pre>
</blockquote>
</li>
<li>
<p>(2.2.2) &mdash; otherwise, equivalent to:</p>
<blockquote>
<pre>subrange&lt;I, I, K&gt;(E.end().base(), E.begin().base())</pre>
</blockquote>
</li>
</ol>
<p>However, in either case <code>E</code> is evaluated only once.</p>
</li>
<li>
<p>(2.3) &mdash; Otherwise, equivalent to <code>reverse_view{E}</code>.</p>
</li>
</ol>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4099"><a href="4099">4099</a>. The simple case of <code>views::as_rvalue</code> and <code>views::common</code> are not strictly correct</h3>
<p><b>Section:</b> 25.7.7.1 <a href="https://timsong-cpp.github.io/cppwp/range.as.rvalue.overview">[range.as.rvalue.overview]</a>, 25.7.20.1 <a href="https://timsong-cpp.github.io/cppwp/range.common.overview">[range.common.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-10 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.as.rvalue.overview">issues</a> in [range.as.rvalue.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, these two adaptors return <code>views::all(E)</code> when the type of subexpression <code>E</code> 
models <code>common_range</code> or its reference is the same as the rvalue reference.
<p/>
However, the current wording does not require that a <code>const</code>-qualified object of a <code>range</code> 
type must have the same non-commonality or value category of the reference as the non-<code>const</code> one,
this makes it theoretically possible for these two to still return non-common ranges or ranges whose reference 
are lvalue when acting on a <code>const</code>-qualified lvalue <code>view</code> object, because 
<code>views::all(E)</code> will remove the <code>const</code>-qualifier.
<p/>
The proposed wording pedantically checks <code>views::all_t&lt;decltype((E))&gt;</code> instead of <code>decltype((E))</code>.
</p>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"Not aware of any use case for making <code class='backtick'>const</code> affect those properties".
</p>



<p id="res-4099"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 25.7.7.1 <a href="https://timsong-cpp.github.io/cppwp/range.as.rvalue.overview">[range.as.rvalue.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::as_rvalue</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Let <code>E</code> be an expression and let <code>T</code> be <code>decltype((E))</code>. The expression
<code>views::as_rvalue(E)</code> is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>
(2.1) &mdash; <code>views::all(E)</code> if <code>same_as&lt;range_rvalue_reference_t&lt;<ins>views::all_t&lt;</ins>T<ins>&gt;</ins>&gt;,
range_reference_t&lt;<ins>views::all_t&lt;</ins>T<ins>&gt;</ins>&gt;&gt;</code> is <code>true</code>.
</p></li>
<li><p>
(2.2) &mdash; Otherwise, <code>as_rvalue_view(E)</code>.
</p></li>
</ol>
</blockquote>

</li>

<li><p>Modify 25.7.20.1 <a href="https://timsong-cpp.github.io/cppwp/range.common.overview">[range.common.overview]</a> as indicated:</p>

<blockquote>
<p>
-3- The name <code>views::common</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Given a subexpression <code>E</code>, the expression
<code>views::common(E)</code> is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>
(3.1) &mdash; <code>views::all(E)</code>, if <del><code>decltype((E))</code></del><ins><code>views::all_t&lt;T&gt;</code></ins> 
models <code>common_range</code> <del>and <code>views::all(E)</code> is a well-formed expression</del>.
</p></li>
<li><p>
(3.2) &mdash; Otherwise, <code>common_view{E}</code>.
</p></li>
</ol>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4100"><a href="4100">4100</a>. Default arguments and signatures of standard library non-member functions</h3>
<p><b>Section:</b> 16.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-05-11 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#global.functions">issues</a> in [global.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>std::from_chars</code> and <code>std::to_chars</code> are specified with default arguments. 
Some implementors want to split them into more overloads to determine the base 10 at compile time 
(LLVM issue <a href="https://github.com/llvm/llvm-project/issues/91268">#91268</a>). However, the 
current standard wording doesn't clearly allow such technique.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
"It's a lot of new text just to say you can't do that, lose the example?"
"Might be NAD, is this already disallowed?" "Only for member functions."
</p>



<p id="res-4100"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 16.4.6.4 <a href="https://timsong-cpp.github.io/cppwp/global.functions">[global.functions]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-2- A call to a non-member function signature described in 17 <a href="https://timsong-cpp.github.io/cppwp/support">[support]</a> through 
32 <a href="https://timsong-cpp.github.io/cppwp/thread">[thread]</a> and D <a href="https://timsong-cpp.github.io/cppwp/depr">[depr]</a> shall behave as if the implementation declared 
no additional non-member function signatures. <ins>However, for each non-member function specified 
with at least one default argument, an implementation may declare additional function signatures 
with one or more trailing parameters that have default arguments removed.</ins>
<p/>
<ins>[<i>Example</i> 1: The following program is possibly ill-formed because of ambiguity in overload 
resolution.</ins>
</p>
<blockquote><pre>
<ins>#include &lt;cstddef&gt;
#include &lt;string&gt;

// One overload of std::stoi ([string.conversions]) is specified as
// int stoi(const string&amp; str, size_t* idx = nullptr, int base = 10);
// An implementation can declare these overloads instead of using default arguments:
// int stoi(const string&amp; str, size_t* idx, int base);
// int stoi(const string&amp; str, size_t* idx);
// int stoi(const string&amp; str);

namespace usr {
  int stoi(const std::string&amp;);
  int stoi(const std::string&amp;, std::size_t*);
}

int main() {
  using std::stoi;
  using usr::stoi;
  int (*p1)(const std::string&amp;) = stoi;                 // possibly ill-formed
  int (*p2)(const std::string&amp;, std::size_t*) = stoi;   // possibly ill-formed
}</ins>
</pre></blockquote>
<p>
<ins>&mdash; end example]</ins>
</p>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4101"><a href="4101">4101</a>. LWG 117 loses the sign for negative NaN on some architectures</h3>
<p><b>Section:</b> 31.7.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.arithmetic">[ostream.inserters.arithmetic]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-05-10 <b>Last modified:</b> 2024-05-15</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.inserters.arithmetic">issues</a> in [ostream.inserters.arithmetic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="117" title="basic_ostream uses nonexistent num_put member functions (Status: CD1)">117</a> fixed insertion of a <code class='backtick'>float</code> into an ostream by
requiring a cast to <code class='backtick'>double</code>. This gives a surprising result on RISC-V when
inserting a negative NaN, because RISC-V floating-point instructions do
not preserve the sign or payload of NaN values. This means that
<code>std::cout &lt;&lt; -std::numeric_limits&lt;float&gt;::quiet_NaN()</code>
prints <code class='backtick'>"nan"</code> rather than <code class='backtick'>"-nan"</code> as most users probably expect.
</p>
<p>
11.3 section of the RISC-V ISA manual (20191213): 
</p>
<blockquote>
Except when otherwise stated, if the result of a floating-point operation
is NaN, it is the canonical NaN. The canonical NaN has a positive sign
and all significand bits clear except the MSB, a.k.a. the quiet bit.
For single-precision floating-point, this corresponds to the pattern
0x7fc00000.
</blockquote>
<p>
This is allowed by IEEE 754 (2019), as per section 6.3:
</p>
<blockquote>
When either an input or result is a NaN, this standard does not interpret
the sign of a NaN.
</blockquote>

<p>
So it is standard-conforming for <code>static_cast&lt;double&gt;(val)</code>
to lose the sign (and payload) of a NaN.
This might also affect Apple M1 chips, if they use the ARMv8 default-NaN mode.
</p>
<p>
The current wording does not permit an implementation to use something like
<code>std::copysign(static_cast&lt;double&gt;(val), std::signbit(val) ? -1.0 : +1.0)</code>
to restore the sign bit. Should this be allowed? Maybe we should say that it's
unspecified whether the cast to <code class='backtick'>double</code> preserves the sign of a NaN?
If not, should we add a note about the surprising behaviour?
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>
<ol>
<li>
<p>Modify 31.7.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.arithmetic">[ostream.inserters.arithmetic]</a> as indicated:</p>
<blockquote>
-3-
When <code class='backtick'>val</code> is of type <code class='backtick'>float</code> the formatting conversion occurs as if
it performed the following code fragment:
<pre><code>
  bool failed = use_facet&lt;
    num_put&lt;charT, ostreambuf_iterator&lt;charT, traits&gt;&gt;
      >(getloc()).put(*this, *this, fill(),
        static_cast&lt;double&gt;(val)).failed();
</code></pre>
<ins>
[<i>Note ?</i>: When <code class='backtick'>val</code> is a NaN value, the conversion to <code class='backtick'>double</code>
can alter the sign and payload. &mdash; <i>end note</i>]
</ins>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2024-05-15; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><i>[2024-05-15; Peter Dimov provides improved wording]</i></p>

<p>Jonathan observes that the same problem exists for
<code>operator&lt;&lt;(<em>extended-floating-point-type</em>)</code>.
</p>



<p id="res-4101"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>
<ol>
<li>
<p>Modify 31.7.6.3.2 <a href="https://timsong-cpp.github.io/cppwp/ostream.inserters.arithmetic">[ostream.inserters.arithmetic]</a> as indicated:</p>
<blockquote>
-3-
When <code class='backtick'>val</code> is of type <code class='backtick'>float</code> the formatting conversion occurs as if
it performed the following code fragment:
<pre><code>
  bool failed = use_facet&lt;
    num_put&lt;charT, ostreambuf_iterator&lt;charT, traits&gt;&gt;
      >(getloc()).put(*this, *this, fill(),
        <del>static_cast&lt;double&gt;(val)</del><ins><em>dval</em></ins>).failed();
</code></pre>
<ins>
where <code><em>dval</em></code> is <code class='backtick'>val</code> converted to type <code class='backtick'>double</code>
as if by <code>static_cast&lt;double&gt;(val)</code>,
except that the sign and payload of NaN values may be preserved
rather than discarded.
</ins>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4102"><a href="4102">4102</a>. <code class='backtick'>string_view(Iter, Iter)</code> constructor breaks existing code</h3>
<p><b>Section:</b> 27.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.cons">[string.view.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Derek Zhang <b>Opened:</b> 2024-05-14 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view.cons">issues</a> in [string.view.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As a result of the new constructor added by <a href="https://wg21.link/P1391" title=" Range constructor for std::string_view">P1391</a>,
this stopped working in C++20: 
</p>
<pre><code>
void fun(string_view);
void fun(vector&lt;string_view&gt;);
fun({"a", "b"});
</code></pre>
<p>
Previously the first <code class='backtick'>fun</code> wasn't viable, so it constructed a
<code>vector&lt;string_view&gt;</code>
of two elements using its initializer-list constructor
and then called the second <code class='backtick'>fun</code>.
Now <code class='backtick'>{"a", "b"}</code> could also be a call to the new <code class='backtick'>string_view(Iter, Iter)</code>,
so it's ambiguous and fails to compile.
</p>
<p>
The following case is arguably worse as it doesn't become ill-formed in C++20,
it still compiles but now has undefined behaviour:
</p>
<pre><code>
fun({{"a", "b"}});
</code></pre>
<p>
Previously the first <code class='backtick'>fun</code> wasn't viable, so this constructed a
<code>vector&lt;string_view&gt;</code> of two elements
(via somewhat bizarre syntax, but using the same initializer-list constructor
as above).
Now it constructs a <code class='backtick'>vector</code> from an <code class='backtick'>initializer_list</code> with <em>one</em>
element, where that element is constructed from the two <code class='backtick'>const char*</code>
using <code class='backtick'>string_view(Iter, Iter)</code>.
But those two pointers are unrelated and do not form a valid range,
so this violates the constructor's precondition and has undefined behaviour.
If you're lucky it crashes at runtime when trying to reach <code class='backtick'>"b"</code> from <code class='backtick'>"a"</code>,
but it could also form a <code class='backtick'>string_view</code> that reads arbitrary secrets from the
memory between the two pointers.
</p>
<p><i>[Jonathan comments]</i></p>

<p>
At the very least, we should have an Annex C entry documenting the change.
Making the new <code class='backtick'>string_view(Iter, Iter)</code> constructor <code class='backtick'>explicit</code> would prevent
the runtime behaviour change for the second example,
but GCC thinks the first example would still be ambiguous
(it seems to depend on how list-initialization handles explicit constructors,
which has implementation divergence).
</p>
<p>
Maybe we should have a deleted constructor matching string literals:
<pre><code>
template&lt;size_t N1, size_t N2&gt;
basic_string_view(const charT(&amp;)[N1], const charT(&amp;)[N2]) = delete;
</code></pre>
Or to handle both <code class='backtick'>const char[N]</code> and <code class='backtick'>char[N]</code>:
<pre><code>
template&lt;class A1, class A2&gt;
requires (rank_v&lt;A1&gt; == 1) &amp;&amp; (rank_v&lt;A2&gt; == 1)
basic_string_view(A1&amp;, A2&amp;) = delete;
</code></pre>
Both options would prevent this currently valid (but weird) code:
<pre><code>
const char arr[] = "str";
std::string_view s(arr, arr); // s.size() == 0 and s.data() == arr
</code></pre>
That seems acceptable, because <code class='backtick'>std::string_view s(arr, 0)</code>
is simpler and clearer anyway.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
"The constructor should be made <code class='backtick'>explicit</code> as part of any resolution for this."
</p>



<p id="res-4102"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4103"><a href="4103">4103</a>. <code>ranges::unique_copy</code>'s constraints for the case where <code>result</code> is an
    <code>input_iterator</code> are not quite right</h3>
<p><b>Section:</b> 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-14 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.unique">active issues</a> in [alg.unique].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <code>r</code> is only an <code>input_range</code> and <code>result</code> is also an
<code>input_iterator</code>, <code>ranges::unique_copy</code> writes the elements of <code>r</code> 
into <code>result</code> and reads the value of <code>result</code> in the next iteration.
<p/>
However, in this case, the function only requires that the <code>value_type</code> of <code>r</code> 
and the <code>value_type</code> of <code>result</code> are the same, which seems too loose because 
the <code>value_type</code> is not particularly useful in the ranges world compared to the
<code>reference</code>, which is also reflected in the fact that the implementation applies the 
compare function on both dereferenced values (<a href="https://godbolt.org/z/jWTnsdGYv">demo</a>):
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() {
  auto r = std::views::istream&lt;bool&gt;(std::cin);
  std::vector&lt;bool&gt; v(10);
  auto proj = [](std::same_as&lt;bool&gt; auto b) { return b; }; // ban vector&lt;bool&gt;::reference
  std::ranges::unique_copy(r, v.begin(), {}, proj);        // <span style="color:red;font-weight:bolder">hard error in libstdc++, libc++ and MSVC-STL</span>
}
</pre></blockquote>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4103"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 26.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a>, header <code>&lt;algorithm&gt;</code> synopsis, as indicated:</p>

<blockquote><pre>
#include &lt;initializer_list&gt;     // <i>see <a href="https://wg21.link/initializer.list.syn">[initializer.list.syn]</a></i>

namespace std {
  [&hellip;]
  namespace ranges {
    template&lt;class I, class O&gt;
      using unique_copy_result = in_out_result&lt;I, O&gt;;

    template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O, class Proj = identity,
             indirect_equivalence_relation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&gt;
      requires indirectly_copyable&lt;I, O&gt; &amp;&amp;
               (forward_iterator&lt;I&gt; ||
                (input_iterator&lt;O&gt; &amp;&amp; <del>same_as&lt;iter_value_t&lt;I&gt;, iter_value_t&lt;O&gt;&gt;</del>
                 <ins>indirect_equivalence_relation&lt;C, projected&lt;I, Proj&gt;, projected&lt;O, Proj&gt;&gt;</ins>) ||
                indirectly_copyable_storable&lt;I, O&gt;)
      constexpr unique_copy_result&lt;I, O&gt;
        unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
    template&lt;input_range R, weakly_incrementable O, class Proj = identity,
             indirect_equivalence_relation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&gt;
      requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               (forward_iterator&lt;iterator_t&lt;R&gt;&gt; ||
                (input_iterator&lt;O&gt; &amp;&amp; <del>same_as&lt;range_value_t&lt;R&gt;, iter_value_t&lt;O&gt;&gt;</del>
                 <ins>indirect_equivalence_relation&lt;C, projected&lt;iterator_t&lt;R&gt;, Proj&gt;,
                                                  projected&lt;O, Proj&gt;&gt;</ins>) ||
                indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, O&gt;)
      constexpr unique_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
        unique_copy(R&amp;&amp; r, O result, C comp = {}, Proj proj = {});
  }
  [&hellip;]
}
</pre></blockquote>

</li>

<li><p>Modify 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O, class Proj = identity,
         indirect_equivalence_relation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&gt;
  requires indirectly_copyable&lt;I, O&gt; &amp;&amp;
           (forward_iterator&lt;I&gt; ||
            (input_iterator&lt;O&gt; &amp;&amp; <del>same_as&lt;iter_value_t&lt;I&gt;, iter_value_t&lt;O&gt;&gt;</del>
             <ins>indirect_equivalence_relation&lt;C, projected&lt;I, Proj&gt;, projected&lt;O, Proj&gt;&gt;</ins>) ||
            indirectly_copyable_storable&lt;I, O&gt;)
  constexpr ranges::unique_copy_result&lt;I, O&gt;
    ranges::unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
template&lt;input_range R, weakly_incrementable O, class Proj = identity,
         indirect_equivalence_relation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&gt;
  requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
           (forward_iterator&lt;iterator_t&lt;R&gt;&gt; ||
           (input_iterator&lt;O&gt; &amp;&amp; <del>same_as&lt;range_value_t&lt;R&gt;, iter_value_t&lt;O&gt;&gt;</del>
            <ins>indirect_equivalence_relation&lt;C, projected&lt;iterator_t&lt;R&gt;, Proj&gt;,
                                             projected&lt;O, Proj&gt;&gt;</ins>) ||
            indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, O&gt;)
  constexpr ranges::unique_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
    ranges::unique_copy(R&amp;&amp; r, O result, C comp = {}, Proj proj = {});
</pre>
<blockquote>
<p>
-6- Let <code>pred</code> be <code>equal_to{}</code> for the overloads in namespace <code>std</code> with no parameter 
<code>pred</code>, [&hellip;]
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4104"><a href="4104">4104</a>. <code>basic_const_iterator&lt;volatile int*&gt;</code> is not a <code>contiguous_iterator</code></h3>
<p><b>Section:</b> 24.5.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators">[const.iterators]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-14 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#const.iterators">active issues</a> in [const.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#const.iterators">issues</a> in [const.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Although <code>volatile int*</code> satisfies <code>contiguous_iterator</code>, due to the formula design of
<code>iter_const_reference_t</code>, its result for the former will be <code>int</code>, which makes 
<code>basic_const_iterator&lt;volatile int*&gt;</code> no longer a <code>contiguous_iterator</code> even though its
<code>iterator_concept</code> is defined as <code>contiguous_iterator_tag</code> and it has a valid 
<code>operator-&gt;()</code> that returns <code>const volatile int*</code>.
<p/>
This seems to defeat the purpose of <code>basic_const_iterator</code> to preserve the behavior of the underlying 
iterator (except for indirection operators). The same goes for 
<code>basic_const_iterator&lt;const volatile int*&gt;</code>:
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;span&gt;

int main() {
  int i = 42;

  const volatile int* p = &amp;i;
  static_assert(std::contiguous_iterator&lt;decltype(p)&gt;);
  std::span sp1{p, 1}; // ok
  
  std::basic_const_iterator it{p};
  static_assert(std::same_as&lt;decltype(it.operator-&gt;()), const volatile int*&gt;);
  static_assert(std::same_as&lt;decltype(it)::iterator_concept, std::contiguous_iterator_tag&gt;);
  static_assert(std::contiguous_iterator&lt;decltype(it)&gt;); // <span style="color:red;font-weight:bolder">failed</span>
  std::span sp2{it, 1}; // <span style="color:red;font-weight:bolder">failed</span>
}
</pre></blockquote>

<p><i>[2024-06-24; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
See also LWG <a href="3813" title="std::span&lt;volatile T, E&gt; is made ill-formed by P2278R4 when T is a normal class type (Status: New)">3813</a>.
</p>



<p id="res-4104"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4107"><a href="4107">4107</a>. Map formatter may conflict with user-defined specializations of <code>pair</code>/<code>tuple</code> formatters</h3>
<p><b>Section:</b> 28.5.7.4 <a href="https://timsong-cpp.github.io/cppwp/format.range.fmtmap">[format.range.fmtmap]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Victor Zverovich <b>Opened:</b> 2024-05-18 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following <a href="https://www.godbolt.org/z/e6Pr537EY">example</a>:
</p>
<blockquote><pre>
#include &lt;format&gt;
#include &lt;map&gt;
#include &lt;print&gt;

struct x {};

template&lt;typename K&gt;
struct std::formatter&lt;std::pair&lt;K, x&gt;&gt; : std::formatter&lt;std::string_view&gt; {
  auto format(const std::pair&lt;K, x&gt;&amp; p, auto&amp; ctx) const {
    return std::format_to(ctx.out(), "x/x");
  }
};

int main() {
  std::print("{}", std::map&lt;x, x&gt;());
}
</pre></blockquote>
<p>
It doesn't compile because the formatter for maps requires the element formatter to have 
<code>set_brackets</code> and <code>set_separator</code> (28.5.7.4 <a href="https://timsong-cpp.github.io/cppwp/format.range.fmtmap">[format.range.fmtmap]</a>):
</p>
<blockquote><pre>
<i>underlying_</i>.underlying().set_brackets({}, {});
<i>underlying_</i>.underlying().set_separator(<i>STATICALLY-WIDEN</i>&lt;charT&gt;(": "));
</pre></blockquote>
<p>
The specialization <code>std::formatter&lt;std::pair&lt;K, x&gt;&gt;</code> itself is allowed according to 
16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a>:
</p>
<blockquote>
<p>
Unless explicitly prohibited, a program may add a template specialization for any standard library class 
template to namespace <code>std</code> provided that
</p>
<ul>
<li><p>the added declaration depends on at least one program-defined type, and</p></li>
<li><p>the specialization meets the standard library requirements for the original template.</p></li>
</ul>
</blockquote>
<p>
but it's unclear what exactly the part "the specialization meets the standard library requirements for 
the original template" means for this formatter. Does it mean that the specialization must provide 
<code>set_brackets</code> and <code>set_separator</code> and does the output have to be consistent with the main 
template? The latter would render the specialization useless. On the other hand if users are allowed to 
customize pair and tuple formatting the current specification of the map formatter is broken.
<p/>
The correct resolution appears to be to not restrict user-defined formatter specializations of <code>pair</code>s 
and <code>tuple</code>s, and make map be responsible for its own structural formatting rather than delegating 
part of it to other formatters in an arbitrary way. This resolution has been applied to {fmt}'s implementation 
of range formatting to address <a href="https://github.com/fmtlib/fmt/issues/3685">#3685</a>.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Several votes for NAD (a specialization must provide <code class='backtick'>set_brackets</code> etc.),
and suggestions it's a design change that LEWG should see.
</p>



<p id="res-4107"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 28.5.8.3 <a href="https://timsong-cpp.github.io/cppwp/format.args">[format.args]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;ranges::input_range R, class charT&gt;
  struct <i>range-default-formatter</i>&lt;range_format::map, R, charT&gt; {
  private:
    using <i>maybe-const-map</i> = <i>fmt-maybe-const</i>&lt;R, charT&gt;;            // <i>exposition only</i>
    using <i>element-type</i> =                                          // <i>exposition only</i>
      remove_cvref_t&lt;ranges::range_reference_t&lt;<i>maybe-const-map</i>&gt;&gt;;
    <del>range_formatter&lt;<i>element-type</i>, charT&gt; <i>underlying_</i>;             // <i>exposition only</i></del>
    <ins>using <i>key-type</i> = tuple_element_t&lt;0, <i>element-type</i>&gt;;            // <i>exposition only</i>
    using <i>value-type</i> = tuple_element_t&lt;1, <i>element-type</i>&gt;;          // <i>exposition only</i>
    formatter&lt;<i>key-type</i>, charT&gt; <i>key-formatter_</i>;                    // <i>exposition only</i>
    formatter&lt;<i>value-type</i>, charT> <i>value-formatter_</i>;                // <i>exposition only</i></ins>

  public:
    constexpr <i>range-default-formatter</i>();
    
    template&lt;class ParseContext&gt;
      constexpr typename ParseContext::iterator
        parse(ParseContext&amp; ctx);
        
    template&lt;class FormatContext&gt;
      typename FormatContext::iterator
        format(<i>maybe-const-map</i>&amp; r, FormatContext&amp; ctx) const;
  };
}
</pre>
</blockquote>
<pre>
constexpr <i>range-default-formatter</i>();
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: Either:
</p>
<ol style="list-style-type:none">
<li><p>(1.1) &mdash; <code><i>element-type</i></code> is a specialization of <code>pair</code>, or</p></li>
<li><p>(1.2) &mdash; <code><i>element-type</i></code> is a specialization of <code>tuple</code> and 
<code>tuple_size_v&lt;<i>element-type</i>&gt; == 2</code>.</p></li>
</ol>
<p>
<del>-2- <i>Effects</i>: Equivalent to:</del>
</p>
<blockquote><pre>
<del><i>underlying_</i>.set_brackets(<i>STATICALLY-WIDEN</i>&lt;charT&gt;("{"), <i>STATICALLY-WIDEN</i>&lt;charT&gt;("}"));
<i>underlying_</i>.underlying().set_brackets({}, {});
<i>underlying_</i>.underlying().set_separator(<i>STATICALLY-WIDEN</i>&lt;charT&gt;(": "));</del>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class ParseContext&gt;
  constexpr typename ParseContext::iterator
    parse(ParseContext&amp; ctx);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <del>Equivalent to: <code>return <i>underlying_</i>.parse(ctx);</code></del>
<ins>Parses the format specifiers as a <i>range-format-spec</i> and stores the parsed specifiers in <code>*this</code>.</ins>
<p/>
<ins>If <code><i>key-formatter_</i>.set_debug_format()</code> is a valid expression, and there is no <i>range-underlying-spec</i>, 
then calls <code><i>key-formatter_</i>.set_debug_format()</code>.</ins>
<p/>
<ins>If <code><i>value-formatter_</i>.set_debug_format()</code> is a valid expression, and there is no <i>range-underlying-spec</i>, 
then calls <code><i>value-formatter_</i>.set_debug_format()</code>.</ins>
<p/>
<ins>-?- <i>Returns</i>: An iterator past the end of the <i>range-format-spec</i>.</ins>
</p>
</blockquote>
<pre>
template&lt;class FormatContext&gt;
  typename FormatContext::iterator
    format(<i>maybe-const-map</i>&amp; r, FormatContext&amp; ctx) const;
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: <del>Equivalent to: <code>return <i>underlying_</i>.format(r, ctx);</code></del>
<ins>Writes the following into <code>ctx.out()</code>, adjusted according to the <i>range-format-spec</i>:</ins>
</p>
<ol style="list-style-type:none">
<li><p><ins>&mdash; <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;("{")</code> unless the <code>n</code> option is specified,</ins></p></li>
<li><p><ins>&mdash; for each element <code>e</code> of the range <code>r</code>:</ins></p>
<ol style="list-style-type:none">
<li><p><ins>&mdash; the result of writing <code>get&lt;0&gt;(e)</code> via <code><i>key-formatter_</i></code>,</ins></p></li>
<li><p><ins>&mdash; <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;(": ")</code>,</ins></p></li>
<li><p><ins>&mdash; the result of writing <code>get&lt;1&gt;(e)</code> via <code><i>value-formatter_</i></code>,</ins></p></li>
<li><p><ins>&mdash; <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;(", ")</code>, unless <code>e</code> is the last element of <code>r</code>, and</ins></p></li>
</ol>
</li>
<li><p><ins>&mdash; <code><i>STATICALLY-WIDEN</i>&lt;charT&gt;("}")</code> unless the <code>n</code> option is specified.</ins></p></li>
</ol>
<p>
<ins>-?- <i>Returns</i>: An iterator past the end of the output range.</ins>
</p>
</blockquote>
</blockquote>

</li>
</ol>





<hr>
<h3 id="4108"><a href="4108">4108</a>. <code>lazy_split_view</code> should be <code>sized_range</code> when pattern is empty <code><i>tiny-range</i></code></h3>
<p><b>Section:</b> 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a>, 25.7.17.2 <a href="https://timsong-cpp.github.io/cppwp/range.split.view">[range.split.view]</a> <b>Status:</b> <a href="lwg-active.html#SG9">SG9</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-05-23 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.lazy.split.view">active issues</a> in [range.lazy.split.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.lazy.split.view">issues</a> in [range.lazy.split.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG9">SG9</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the pattern range is empty, <code>lazy_split_view</code> will split each element into individual subranges, 
which means its size is equal to the size of the underlying range.
<p/>
Since we already have a <code><i>tiny-range</i></code> that can determine whether the range is empty by its type, 
it seems valuable to provide a <code>size</code> for <code>lazy_split_view</code> in this case, given that we already 
specifically checked for it by <code>Pattern::size() == 0</code> in <code><i>inner-iterator</i>::operator++()</code>.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Set Status to SG9.
"Design change".
"<code>tiny-range</code> should accept <code>span&lt;T, 0|1&gt;</code> or <code>ref_view&lt;array&lt;T, 0|1&gt;&gt;</code>,
see related paper <a href="https://wg21.link/P1419" title=" A SFINAE-friendly trait to determine the extent of statically sized containers">P1419</a>."
</p>



<p id="res-4108"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>

<li><p>Modify 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;auto&gt; struct <i>require-constant</i>;                        // <i>exposition only</i>

  template&lt;class R&gt;
  concept <i>tiny-range</i> =                                           // <i>exposition only</i>
     sized_range&lt;R&gt; &amp;&amp;
     requires { typename <i>require-constant</i>&lt;remove_reference_t&lt;R&gt;::size()&gt;; } &amp;&amp;
     (remove_reference_t&lt;R&gt;::size() &lt;= 1);
  
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
             (forward_range&lt;V&gt; || <i>tiny-range</i>&lt;Pattern&gt;)
  class lazy_split_view : public view_interface&lt;lazy_split_view&lt;V, Pattern&gt;&gt; {
    [&hellip;]
    <ins>constexpr auto size()
      requires sized_range&lt;V&gt; &amp;&amp;
               <i>tiny-range</i>&lt;Pattern&gt; &amp;&amp; (Pattern::size() == 0) {
      return ranges::size(<i>base_</i>);
    }</ins>

    <ins>constexpr auto size() const
      requires sized_range&lt;const V&gt; &amp;&amp;
               <i>tiny-range</i>&lt;Pattern&gt; &amp;&amp; (Pattern::size() == 0) {
      return ranges::size(<i>base_</i>);
    }</ins>
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.7.17.2 <a href="https://timsong-cpp.github.io/cppwp/range.split.view">[range.split.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;forward_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  class split_view : public view_interface&lt;split_view&lt;V, Pattern&gt;&gt; {
    [&hellip;]
    <ins>constexpr auto size()
      requires sized_range&lt;V&gt; &amp;&amp;
               <i>tiny-range</i>&lt;Pattern&gt; &amp;&amp; (Pattern::size() == 0) {
      return ranges::size(<i>base_</i>);
    }</ins>

    <ins>constexpr auto size() const
      requires sized_range&lt;const V&gt; &amp;&amp;
               <i>tiny-range</i>&lt;Pattern&gt; &amp;&amp; (Pattern::size() == 0) {
      return ranges::size(<i>base_</i>);
    }</ins>
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>
</ol>





<hr>
<h3 id="4109"><a href="4109">4109</a>. Instantiating templates in &sect;[rand] with <code>int8_t</code>/<code>uint8_t</code> is undefined behavior</h3>
<p><b>Section:</b> 29.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.req.genl">[rand.req.genl]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2024-05-25 <b>Last modified:</b> 2024-05-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.genl">issues</a> in [rand.req.genl].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As pointed out in LWG issue <a href="2326" title="uniform_int_distribution&lt;unsigned char&gt; should be permitted (Status: NAD)">2326</a> (closed as NAD) and 
<a href="https://www.reddit.com/r/cpp/comments/1czwa5h/is_instantiating_stduniform_int_distributionuint8/">on reddit</a>, 
instantiating e.g. <code>uniform_int_distribution&lt;uint8_t&gt;</code> is undefined behavior 
because of the requirement 29.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.req.genl">[rand.req.genl]</a> bullet (1.5):
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
-1- Throughout this subclause 29.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a>, the effect of instantiating a template:
</p>
<ol style="list-style-type:none">
<li><p>[&hellip;]</p></li>
<li><p>(1.4) &mdash; that has a template type parameter named <code>RealType</code> is undefined 
unless the corresponding template argument is cv-unqualified and is one of <code>float</code>, 
<code>double</code>, or <code>long double</code>.</p></li>
<li><p>(1.5) &mdash; that has a template type parameter named <code>IntType</code> is undefined unless 
the corresponding template argument is cv-unqualified and is one of <code>short</code>, <code>int</code>, 
<code>long</code>, <code>long long</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, 
or <code>unsigned long long</code>.</p></li>
<li><p>(1.6) &mdash; that has a template type parameter named <code>UIntType</code> is undefined unless 
the corresponding template argument is cv-unqualified and is one of <code>unsigned short</code>, 
<code>unsigned int</code>, <code>unsigned long</code>, or <code>unsigned long long</code>.</p></li>
</ol>
</blockquote>
<p>
This is, in my opinion, a defect; such uses should either be rejected
at compile time (made ill-formed), or permitted (as 2326 proposes.)
<p/>
UB here has undesirable safety implications, because it's possible to
write code that produces a random, or a seemingly random, sequence
of <code>uint8_t</code> numbers on platform A, but an arbitrarily non-random
sequence on platform B (e.g. all zeroes.)
<p/>
If that sequence is then used in e.g. a cryptographic algorithm, bad
things will happen on platform B, and the tests on platform A won't
catch the issue.
</p>

<p><i>[2024-05-26; Daniel comments]</i></p>

<p>
I think that all violations of the bullets 29.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.req.genl">[rand.req.genl]</a> (1.4), (1.5), and (1.6)
are missed opportunities of <i>Mandates</i> (That is: Make the program ill-formed), because
they can be all checked (easily) at compile-time, regardless whether we agree on
the question to support <code>int8_t</code>/<code>uint8_t</code> (Violations of (1.1), (1.2), and (1.3)
still have to be remain undefined because of additional runtime requirements imposed).
<p/>
Given that I also think that we should consider to either normatively extend all of (1.4), (1.5), 
and (1.6) to corresponding <i>extended floating point</i> types and <i>extended (unsigned) integer types</i>, 
or to the minimum make these extended types conditionally-supported with implementation-defined 
semantics (A word of power that is used at several places).
</p>


<p id="res-4109"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> As suggested in issue LWG <a href="2326" title="uniform_int_distribution&lt;unsigned char&gt; should be permitted (Status: NAD)">2326</a>
</p>

<ol>

<li><p>Modify 29.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.req.genl">[rand.req.genl]</a> as indicated:</p>

<blockquote>
<p>
-1- Throughout this subclause 29.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a>, the effect of instantiating a template:
</p>
<ol style="list-style-type:none">
<li><p>[&hellip;]</p></li>
<li><p>(1.4) &mdash; that has a template type parameter named <code>RealType</code> is undefined 
unless the corresponding template argument is cv-unqualified and is one of <code>float</code>, 
<code>double</code>, or <code>long double</code>.</p></li>
<li><p>(1.5) &mdash; that has a template type parameter named <code>IntType</code> is undefined unless 
the corresponding template argument is cv-unqualified and is <ins>a standard integer type 
(6.9.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>)</ins><del>one of <code>short</code>, <code>int</code>, 
<code>long</code>, <code>long long</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, 
or <code>unsigned long long</code></del>.</p></li>
<li><p>(1.6) &mdash; that has a template type parameter named <code>UIntType</code> is undefined unless 
the corresponding template argument is cv-unqualified and is <ins>a standard unsigned integer type 
(6.9.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>)</ins><del>one of <code>unsigned short</code>, 
<code>unsigned int</code>, <code>unsigned long</code>, or <code>unsigned long long</code></del>.</p></li>
</ol>
</blockquote>

</li>

</ol>

<p>
<b>Option B:</b> Make ill-formed.
</p>

<ol>

<li><p>Modify 29.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/rand.req.genl">[rand.req.genl]</a> as indicated:</p>

<blockquote>
<p>
-1- Throughout this subclause 29.5 <a href="https://timsong-cpp.github.io/cppwp/rand">[rand]</a>, the effect of instantiating a template:
</p>
<ol style="list-style-type:none">
<li><p>[&hellip;]</p></li>
<li><p>(1.4) &mdash; that has a template type parameter named <code>RealType</code> is undefined 
unless the corresponding template argument is cv-unqualified and is one of <code>float</code>, 
<code>double</code>, or <code>long double</code>.</p></li>
<li><p>(1.5) &mdash; that has a template type parameter named <code>IntType</code> <ins>renders the 
program ill-formed</ins><del>is undefined</del> unless the corresponding template argument is 
cv-unqualified and is one of <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, 
<code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, or 
<code>unsigned long long</code>.</p></li>
<li><p>(1.6) &mdash; that has a template type parameter named <code>UIntType</code> <ins>renders the 
program ill-formed</ins><del>is undefined</del> unless the corresponding template argument is 
cv-unqualified and is one of <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, 
or <code>unsigned long long</code>.</p></li>
</ol>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4110"><a href="4110">4110</a>. <code class='backtick'>shared_ptr(nullptr_t, Deleter)</code> is overconstrained, breaking some sensible deleters</h3>
<p><b>Section:</b> 20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Louis Dionne <b>Opened:</b> 2024-06-11 <b>Last modified:</b> 2024-06-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.const">active issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.const">issues</a> in [util.smartptr.shared.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code doesn't compile on conforming implementations:
<pre><code>
    #include &lt;memory&gt;

    void f() {
        std::shared_ptr&lt;int&gt;(new int, [](auto pointer) { delete pointer; });
    }
</code></pre>
<a href="https://gcc.godbolt.org/z/7hs34ded7">(Godbolt)</a>
</p><p>
This is caused by the constraint on <code class='backtick'>shared_ptr(nullptr_t p, D d);</code>
being that <code class='backtick'>d(p)</code> is valid (20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a> p9),
which leads to a hard error inside the lambda since it is called with a
<code class='backtick'>nullptr_t</code>. This seems unintended.
</p><p>
See <a href="https://github.com/llvm/llvm-project/pull/93071#issuecomment-2158494851">LLVM issue 93071 comment</a> for additional context.
</p>


<p id="res-4110"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>
<ol>
<li>
In 20.3.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.const">[util.smartptr.shared.const]</a>/9, specify that
<code class='backtick'>shared_ptr(nullptr_t p, D d);</code> checks whether
<code>d(static_cast&lt;T*&gt;(nullptr))</code>
is well-formed. This requires expressing the the constraints for
the <code class='backtick'>Y*</code> constructors and the <code class='backtick'>nullptr_t</code> constructors separately,
which is mostly editorial:
<blockquote>
<pre><code>
template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);
template&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);
<del>template&lt;class D&gt; shared_ptr(nullptr_t p, D d);
template&lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);</del>
</code></pre>
<p>-9-
<i>Constraints</i>:
<code>is_move_constructible_v&lt;D&gt;</code> is <code class='backtick'>true</code>,
and <code class='backtick'>d(p)</code> is a well-formed expression.
<del>For the first two overloads:</del>
<ol style="list-style-type:none">
<li>
(9.1) If <code class='backtick'>T</code> is an array type, then either <code class='backtick'>T</code> is <code class='backtick'>U[N]</code> and <code class='backtick'>Y(*)[N]</code>
is convertible to <code class='backtick'>T*</code>, or <code class='backtick'>T</code> is <code class='backtick'>U[]</code> and <code class='backtick'>Y(*)[]</code> is convertible to <code class='backtick'>T*</code>.
</li>
<li>
(9.2) If <code class='backtick'>T</code> is not an array type, then <code class='backtick'>Y*</code> is convertible to <code class='backtick'>T*</code>.
</li>
</ol>
</p>
<pre><code>
<ins>template&lt;class D&gt; shared_ptr(nullptr_t p, D d);
template&lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);</ins>
</code></pre>
<p><ins>-?-
<i>Constraints</i>:
<code>is_move_constructible_v&lt;D&gt;</code> is <code class='backtick'>true</code>,
and <code>d(static_cast&lt;T*&gt;(p))</code> is a well-formed expression.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4111"><a href="4111">4111</a>. LWG 270 and ranges version of binary search algorithms</h3>
<p><b>Section:</b> 26.8.4 <a href="https://timsong-cpp.github.io/cppwp/alg.binary.search">[alg.binary.search]</a>, 26.8.1 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting.general">[alg.sorting.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-06-18 <b>Last modified:</b> 2024-06-24</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.binary.search">issues</a> in [alg.binary.search].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="270" title="Binary search requirements overly strict (Status: CD1)">270</a> relaxed the requirements for <code>comp</code> of binary search algorithms 
(26.8.4 <a href="https://timsong-cpp.github.io/cppwp/alg.binary.search">[alg.binary.search]</a>). However, the relaxation doesn't seem automatically applied 
to <code>ranges</code> versions, because <code>ranges</code> versions of these algorithms constrain the 
<code>Comp</code> types with <code>indirect_strict_weak_order</code>.
<p/>
Perhaps we should additionally say some semantic requirements of <code>indirect_strict_weak_order</code> 
aren't imposed for these algorithms or change the constraints.
</p>

<p><i>[St. Louis 2024-06-24; set priority to P3]</i></p>




<p id="res-4111"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4114"><a href="4114">4114</a>. <code>elements_view::<i>iterator</i>::operator*</code> missing conditional <code>noexcept</code> specification</h3>
<p><b>Section:</b> 25.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-07-02 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.elements.iterator">active issues</a> in [range.elements.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.elements.iterator">issues</a> in [range.elements.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>views::elements</code>, which can be seen as a specialization of <code>views::transform</code>, 
is used to <i>transform</i> the original tuple into its elements.
<p/>
Since neither has a specialization for <code>iter_move</code>, the customization point is dispatched 
to the default implementation. However, unlike the latter, <code>elements_view::<i>iterator</i>::operator*</code> 
does not have a <code>noexcept</code> specification, which makes calls to <code>iter_move</code> never 
<code>noexcept</code>, which seems to be an oversight (<a href="https://godbolt.org/z/aGe8EP6Wd">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;vector&gt;

std::vector v{std::pair{1, "a"}, {2, "b"}};

auto r1 = v | std::views::keys;
auto i1 = r1.begin();
static_assert(noexcept(*i1));                        // <span  style="color:#C80000;font-weight:bold">failed</span>
static_assert(noexcept(std::ranges::iter_move(i1))); // <span  style="color:#C80000;font-weight:bold">failed</span>

auto get_key = [](auto&amp; t) noexcept -&gt; auto&amp; { return std::get&lt;0&gt;(t); };
auto r2 = v | std::views::transform(get_key);
auto i2 = r2.begin();
static_assert(noexcept(*i2));
static_assert(noexcept(std::ranges::iter_move(i2)));
</pre></blockquote>
<p>
The proposed resolution is aligned with the <i>strengthened</i> implementation of MSVC-STL.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4114"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>
<li><p>Modify 25.7.23.3 <a href="https://timsong-cpp.github.io/cppwp/range.elements.iterator">[range.elements.iterator]</a> as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; <i>has-tuple-element</i>&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
             <i>has-tuple-element</i>&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt; &amp;&amp;
             <i>returnable-element</i>&lt;range_reference_t&lt;V&gt;, N&gt;
  template&lt;bool Const&gt;
  class elements_view&lt;V, N&gt;::<i>iterator</i> {
    [&hellip;]

    static constexpr decltype(auto) <i>get-element</i>(const iterator_t&lt;<i>Base</i>&gt;&amp; i)<del>;</del>     // <i>exposition only</i>
      <ins>noexcept(noexcept(std::get&lt;N&gt;(*i))) requires is_reference_v&lt;range_reference_t&lt;<i>Base</i>&gt;&gt; {
      return std::get&lt;N&gt;(*i);
    }</ins>
    <ins>
    static constexpr decltype(auto) <i>get-element</i>(const iterator_t&lt;<i>Base</i>&gt;&amp; i)      // <i>exposition only</i>
      noexcept(noexcept(std::get&lt;N&gt;(*i)) &amp;&amp;
               is_nothrow_move_constructible_v&lt;tuple_element_t&lt;N, range_reference_t&lt;<i>Base</i>&gt;&gt;&gt;) {
      using E = remove_cv_t&lt;tuple_element_t&lt;N, range_reference_t&lt;<i>Base</i>&gt;&gt;&gt;;
      return static_cast&lt;E&gt;(std::get&lt;N&gt;(*i));
    }</ins>

  public:
    [&hellip;]

    constexpr decltype(auto) operator*() const
      <ins>noexcept(noexcept(<i>get-element</i>(<i>current_</i>)))</ins>
    { return <i>get-element</i>(<i>current_</i>); }

    [&hellip;]
  };
}
</pre></blockquote>
<p>
[&hellip;]
</p>
<pre><del>static constexpr decltype(auto) <i>get-element</i>(const iterator_t&lt;<i>Base</i>&gt;&amp; i);</del></pre>
<p>
<del>-3- <i>Effects</i>: Equivalent to:</del>
</p>
<blockquote><pre>
<del>if constexpr (is_reference_v&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;) {
  return std::get&lt;N&gt;(*i);
} else {
  using E = remove_cv_t&lt;tuple_element_t&lt;N, range_reference_t&lt;<i>Base</i>&gt;&gt;&gt;;
  return static_cast&lt;E&gt;(std::get&lt;N&gt;(*i));
}</del>
</pre></blockquote>

</li>
</ol>





<hr>
<h3 id="4115"><a href="4115">4115</a>. <code>move_iterator::operator*</code> should have conditional <code>noexcept</code> specification</h3>
<p><b>Section:</b> 24.5.4.6 <a href="https://timsong-cpp.github.io/cppwp/move.iter.elem">[move.iter.elem]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-07-03 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#move.iter.elem">issues</a> in [move.iter.elem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <code>move_iterator</code>, dereferencing it is actually equivalent to applying <code>iter_move</code> to it.
<p/>
However, unlike the latter, <code>move_iterator</code>'s dereference operator lacks a <code>noexcept</code> 
specification, which seems to be an oversight given that the standard goes to such great lengths to 
preserve the noexceptness of <code>iter_move</code>, and the main purpose of <code>move_iterator</code> is 
precisely to apply <code>iter_move</code> to the underlying iterator via dereferencing.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
"Do we have evidence conditional noexcept matters here?
Do we have a policy that <code class='backtick'>operator*</code> should be noexcept whenever possible?
What criteria are we using to decide here?"
</p>



<p id="res-4115"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>
<li><p>Modify 24.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/move.iterator">[move.iterator]</a> as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class Iterator&gt;
  class move_iterator {
  public:
    [&hellip;]
    constexpr reference operator*() const <ins>noexcept(noexcept(ranges::iter_move(current)))</ins>;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Modify 24.5.4.6 <a href="https://timsong-cpp.github.io/cppwp/move.iter.elem">[move.iter.elem]</a> as indicated:</p>

<blockquote>
<pre>
constexpr reference operator*() const <ins>noexcept(noexcept(ranges::iter_move(current)))</ins>;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Equivalent to: <code>return ranges::iter_move(current);</code>
</p>
</blockquote>
</blockquote>

</li>
</ol>





<hr>
<h3 id="4116"><a href="4116">4116</a>. <code>enumerate_view::<i>iterator</i></code> and <code>cartesian_product_view::<i>iterator</i></code> should not
    always provide <code>iterator_category</code></h3>
<p><b>Section:</b> 25.7.24.3 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.iterator">[range.enumerate.iterator]</a>, 25.7.33.3 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.iterator">[range.cartesian.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-07-07 <b>Last modified:</b> 2024-07-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.enumerate.iterator">active issues</a> in [range.enumerate.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.enumerate.iterator">issues</a> in [range.enumerate.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
These two iterators do not support <code>*r++</code> for non-forward iterators,
so we should not provide <code>iterator_category</code> as they are not C++17 iterators.
</p>


<p id="res-4116"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>
<li><p>Modify 25.7.24.3 <a href="https://timsong-cpp.github.io/cppwp/range.enumerate.iterator">[range.enumerate.iterator]</a> as indicated:</p>

<blockquote><pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires <i>range-with-movable-references</i>&lt;V&gt;
  template&lt;bool Const&gt;
  class enumerate_view&lt;V&gt;::<i>iterator</i> {
    using <i>Base</i> = <i>maybe-const</i>&lt;Const, V&gt;;                         // <i>exposition only</i>

  public:
    using iterator_category = input_iterator_tag;      <ins>// present only if <i>Base</i>
                                                       // models forward_range</ins>
    using iterator_concept = <i>see below</i>;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Modify 25.7.33.3 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.iterator">[range.cartesian.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range First, forward_range... Vs&gt;
    requires (view&lt;First&gt; &amp;&amp; ... &amp;&amp; view&lt;Vs&gt;)
  template&lt;bool Const&gt;
  class cartesian_product_view&lt;First, Vs...&gt;::<i>iterator</i> {
  public:
    using iterator_category = input_iterator_tag;      <ins>// present only if <i><i>maybe-const</i>&lt;Const, First&gt;</i>
                                                       // models forward_range</ins>
    using iterator_concept  = see below;
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>
</ol>





<hr>
<h3 id="4117"><a href="4117">4117</a>. <code>generator::<i>iterator</i></code> should provide <code>iterator_concept</code></h3>
<p><b>Section:</b> 25.8.6 <a href="https://timsong-cpp.github.io/cppwp/coro.generator.iterator">[coro.generator.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-07-07 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#coro.generator.iterator">active issues</a> in [coro.generator.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#coro.generator.iterator">issues</a> in [coro.generator.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>generator::<i>iterator</i></code> currently does not provide an <code>iterator_concept</code>.
While this does not affect it being an <code>input_iterator</code>, providing <code>iterator_concept</code> 
does improve consistency given that other C++20 iterators have such a member type alias.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Six votes for P0 (tentatively ready) but one NAD vote saying that if this
has no effect on the category then there's no reason to add it.
</p>



<p id="res-4117"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4981" title=" Working Draft, Programming Languages  C++">N4981</a>.
</p>

<ol>
<li><p>Modify 25.8.6 <a href="https://timsong-cpp.github.io/cppwp/coro.generator.iterator">[coro.generator.iterator]</a> as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class Ref, class V, class Allocator&gt;
  class generator&lt;Ref, V, Allocator&gt;::<i>iterator</i> {
  public:
    <ins>using iterator_concept = input_iterator_tag;</ins>
    using value_type = value;
    using difference_type = ptrdiff_t;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

</ol>





<hr>
<h3 id="4118"><a href="4118">4118</a>. How should <code class='backtick'>duration</code> formatters format custom <code class='backtick'>rep</code> types?</h3>
<p><b>Section:</b> 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-07-08 <b>Last modified:</b> 2024-07-31</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.format">active issues</a> in [time.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.format">issues</a> in [time.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>formatter&lt;chrono::duration&lt;Rep, Period&gt;, charT&gt;</code>
partial specialization needs to be able to format the <code class='backtick'>Rep</code> type, because
the <code class='backtick'>%Q</code> conversion specifier says to format the value returned by <code class='backtick'>.count()</code>
which is of type <code class='backtick'>Rep</code>. This implies that the <code class='backtick'>Rep</code> type must be formattable,
although the precise method of formatting it is not specified. Presumably
either <code>format("{}", d.count())</code> or
<code>ostrm &lt;&lt; d.count()</code> needs to work.
</p>

<p>
28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> p2 (2.3) says:
<blockquote>
For each <code class='backtick'>charT</code>, for each cv-unqualified arithmetic type <code class='backtick'>ArithmeticT</code>
other than <code class='backtick'>char</code>, <code class='backtick'>wchar_t</code>, <code class='backtick'>char8_t</code>, <code class='backtick'>char16_t</code>, or <code class='backtick'>char32_t</code>,
a specialization:
<code>template&lt;&gt; struct formatter&lt;ArithmeticT, charT&gt;;</code>
</blockquote>
However, nothing prevents the excluded types being used as the <code class='backtick'>rep</code> for a
<code class='backtick'>chrono::duration</code>.
This means you can use <code>chrono::duration&lt;wchar_t&gt;</code> and
<code>chrono::duration&lt;char8_t&gt;</code> as durations,
but you can't format them to <code class='backtick'>char</code> strings.
</p>

<p>
I think only the <code class='backtick'>%Q</code> conversion specifier formats the <code class='backtick'>rep</code> type directly
(without converting durations to formattable types like <code class='backtick'>hours</code> or <code class='backtick'>seconds</code>),
and so I don't think this problem exists for other chrono <code class='backtick'>formatter</code>
specializations, because <code class='backtick'>%Q</code> can only be used for durations
(that's not <i>entirely</i> clear, since <code class='backtick'>%q</code> and <code class='backtick'>%Q</code> are specified to format
"the duration's unit suffix" and "the duration's numeric value",
but presumably that means they can only be used for <code class='backtick'>duration</code> types).
</p>

<p>
Should the specialization of <code class='backtick'>formatter</code> for <code class='backtick'>chrono::duration</code> be constrained
to require that the <code class='backtick'>rep</code> type can be formatted?
Or should the <code class='backtick'>%Q</code> conversion specifier say that the numeric value is
formatted by inserting into an <code class='backtick'>ostream</code> (which would treat <code class='backtick'>wchar_t</code> and
<code class='backtick'>char8_t</code> rep types as characters, not integers)?
Or should <code class='backtick'>%Q</code> say that the numeric value is converted to an integral type,
which we know how to format?
</p>

<p>
This is somewhat related to issue <a href="953" title="Various threading bugs #3 (Status: Resolved)">953</a>, since it's unclear
which operations "a class emulating an arithmetic type" needs to support.
</p>


<p><i>[2024-07-31; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"Don't convert to an integer type, that would be wrong for
<code>duration&lt;long double&gt;</code> and could overflow for
<code>duration&lt;BigInt&gt;</code>."
</p>
<p>"<code class='backtick'>%Q</code> could format using <code class='backtick'>+d.count()</code>"</p>
<p>
Some requests to disallow using code unit types as duration reps,
e.g. <code>duration&lt;char&gt;</code>. Alternatively it just shouldn't
be formattable. Alternatively, don't bother preventing dumb things.
</p>
<p>
There's a similar issue in <code>operator&lt;&lt;</code> for
<code class='backtick'>duration</code>, which writes <code class='backtick'>d.count()</code> to the stream. For a custom rep type
that might be ill-formed. For character types it might print as a character
not an integer.
</p>



<p id="res-4118"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>
<ol>
<li><p>Modify 30.2 <a href="https://timsong-cpp.github.io/cppwp/time.syn">[time.syn]</a> as indicated:</p>

<blockquote>
<pre><code>
namespace std {
  template&lt;class Rep, class Period, class charT&gt;
    <ins>requires formattable&lt;Rep, charT&gt;</ins>
    struct formatter&lt;chrono::duration&lt;Rep, Period&gt;, charT&gt;;
  template&lt;class Duration, class charT&gt;
    struct formatter&lt;chrono::sys_time&lt;Duration&gt;, charT&gt;;
</code></pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4120"><a href="4120">4120</a>. <code>move_iterator</code> should provide <code>iterator_category</code> only when it models
<code>forward_iterator</code></h3>
<p><b>Section:</b> 24.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/move.iterator">[move.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-07-12 <b>Last modified:</b> 2024-08-31</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#move.iterator">active issues</a> in [move.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#move.iterator">issues</a> in [move.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Following up LWG <a href="4116" title="enumerate_view::iterator and cartesian_product_view::iterator should not
    always provide iterator_category (Status: New)">4116</a>, when the underlying iterator does not satisfy <code>forward_iterator</code>,
<code>move_iterator::operator++(int)</code> will return <code>void</code>, which fails to meet the C++17 iterator
requirements, which should not provide <code>iterator_category</code>.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"NAD, would be a major breaking change to something present since C++11."
</p>
<p>
"We're knowingly breaking the rules here for backwards compatibility.
Should have a note here indicating that the rule is broken for good reason,
and that you should do as the Standard says and not as the Standard does."
</p>



<p id="res-4120"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 24.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/move.iterator">[move.iterator]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> <code>Iterator</code> that models <code>forward_iterator</code> implies that
<code>iterator_traits&lt;Iterator&gt;::iterator_category</code> is always valid as it satisfies the
exposition-only concept <code><i>cpp17-iterator</i></code>.]
</p>
</blockquote>

<blockquote>
<p>
-2-
The member <i>typedef-name</i> <code>iterator_category</code> is defined if and only if <del>the <i>qualified-id</i>
  <code>iterator_traits&lt;Iterator&gt;::iterator_category</code> is valid and denotes a
  type</del><ins><code>Iterator</code> models <code>forward_iterator</code></ins>. In that case,
<code>iterator_category</code> denotes
</p>
<ol style="list-style-type: none">
<li>
<p>(2.1) &mdash; <code>random_access_iterator_tag</code> if the type
<code>iterator_traits&lt;Iterator&gt;::iterator_category</code> models
<code>derived_from&lt;random_access_iterator_tag&gt;</code>, and</p>
</li>
<li>
<p>(2.2) &mdash; <code>iterator_traits&lt;Iterator&gt;::iterator_category</code> otherwise.</p>
</li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4121"><a href="4121">4121</a>. <code>ranges::to</code> constructs associative containers via <code>c.emplace(c.end(), *it)</code></h3>
<p><b>Section:</b> 25.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.general">[range.utility.conv.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-07-16 <b>Last modified:</b> 2025-03-17</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <code>ranges::to</code> constructs an associative container, if there is no range version constructor 
for <code>C</code> and the input range is not common range, <code>ranges::to</code> will dispatch to the
bullet 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> (2.1.4), which first default-constructs the container 
and emplaces the element through <code>c.emplace(c.end(), *it)</code>.
<p/>
However, this is not the correct way to call <code>emplace()</code> on an associative container as it does 
not expect an iterator as the first argument, and since <code>map::emplace()</code>, for instance, is not 
constrained, which turns out a hard error because we are trying to make a <code>pair</code> with 
<code>{it, pair}</code>.
<p/>
Given that libstdc++ currently does not implement the range constructor for associative containers, the following
illustrates the <a href="https://godbolt.org/z/q8MzP8bb1">issue</a>:
</p>
<blockquote><pre>
#include &lt;ranges&gt;
#include &lt;set&gt;
  
auto s = std::views::iota(0)
       | std::views::take(5)
       | std::ranges::to&lt;std::set&gt;(); // <span  style="color:#C80000;font-weight:bold">hard error</span>
</pre></blockquote>
<p>
The proposed resolution simply removes the <code>emplace()</code> branch. Although this means that we always use
<code>insert()</code> to fill associative containers, such an impact seems negligible.
</p>

<p><i>[2024-07-23; This was caused by LWG <a href="4016" title="container-insertable checks do not match what container-inserter does (Status: WP)">4016</a>.]</i></p>



<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
"Would like to preserve the ability to use <code class='backtick'>emplace</code>. Tim suggested trying
<code class='backtick'>emplace_hint</code> first, then <code class='backtick'>emplace</code>."
"I tried it, it gets very verbose, because we might also want to try
<code class='backtick'>insert(*it)</code> instead of <code class='backtick'>insert(c.end(), *it)</code> if <code class='backtick'>emplace(*it)</code> is not valid
for associative containers, because <code class='backtick'>c.end()</code> might not be a good hint."
"It might be suboptimal, but it still works."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 25.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.general">[range.utility.conv.general]</a> as indicated:</p>

<blockquote>
<p>
-4- Let <code><i>container-appendable</i></code> be defined as follows:
</p>
<blockquote><pre>
template&lt;class Container, class Ref&gt;
constexpr bool <i>container-appendable</i> =         <i>// exposition only</i>
  requires(Container&amp; c, Ref&amp;&amp; ref) {
           requires (requires { c.emplace_back(std::forward&lt;Ref&gt;(ref)); } ||
                     requires { c.push_back(std::forward&lt;Ref&gt;(ref)); } ||
                     <del>requires { c.emplace(c.end(), std::forward&lt;Ref&gt;(ref)); } ||</del>
                     requires { c.insert(c.end(), std::forward&lt;Ref&gt;(ref)); });
};
</pre></blockquote>
<p>
-5- Let <code><i>container-append</i></code> be defined as follows:
</p>
<blockquote><pre>
template&lt;class Container&gt;
constexpr auto <i>container-append</i>(Container&amp; c) {     <i>// exposition only</i>
  return [&amp;c]&lt;class Ref&gt;(Ref&amp;&amp; ref) {
    if constexpr (requires { c.emplace_back(declval&lt;Ref&gt;()); })
      c.emplace_back(std::forward&lt;Ref&gt;(ref));
    else if constexpr (requires { c.push_back(declval&lt;Ref&gt;()); })
      c.push_back(std::forward&lt;Ref&gt;(ref));
    <del>else if constexpr (requires { c.emplace(c.end(), declval&lt;Ref&gt;()); })
      c.emplace(c.end(), std::forward&lt;Ref&gt;(ref));</del>
    else
      c.insert(c.end(), std::forward&lt;Ref&gt;(ref));
  };
};
</pre></blockquote>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2025-03-13; Jonathan provides improved wording for Tim's suggestion]</i></p>

<p>
It's true that for some cases it might be optimal to use <code class='backtick'>c.emplace(ref)</code>
instead of <code class='backtick'>c.emplace_hint(c.end(), ref)</code> but I don't think I care.
A bad hint is not expensive, it's just an extra comparison then the hint
is ignored.
And this code path isn't going to be used for <code class='backtick'>std::set</code> or <code class='backtick'>std::map</code>,
only for user-defined associative containers that don't have a <code class='backtick'>from_range_t</code>
constructor or a <code class='backtick'>C(Iter,Sent)</code> constructor.
I think just fixing the original issue is all we need,
rather than trying to handle every possible way to insert elements.
</p>
<p>
This is a simpler, portable reproducer that doesn't depend on the current
implementation status of <code class='backtick'>std::set</code> in libstdc++:
</p>
<blockquote><pre><code>
#include &lt;ranges&gt;
#include &lt;set&gt;
struct Set : std::set&lt;int&gt; {
  Set() { }; // No other constructors
};
int main() {
  int a[1];
  auto okay = std::ranges::to&lt;std::set&lt;int&gt;&gt;(a);
  auto ohno = std::ranges::to&lt;Set&gt;(a);
}
</code></pre></blockquote>



<p id="res-4121"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 25.5.7.1 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.general">[range.utility.conv.general]</a> as indicated:</p>

<blockquote>
<p>
-4- Let <code><i>container-appendable</i></code> be defined as follows:
</p>
<blockquote><pre>
template&lt;class Container, class Ref&gt;
constexpr bool <i>container-appendable</i> =         <i>// exposition only</i>
  requires(Container&amp; c, Ref&amp;&amp; ref) {
           requires (requires { c.emplace_back(std::forward&lt;Ref&gt;(ref)); } ||
                     requires { c.push_back(std::forward&lt;Ref&gt;(ref)); } ||
                     <ins>requires { c.emplace_hint(c.end(), std::forward&lt;Ref&gt;(ref)); } ||</ins>
                     requires { c.emplace(c.end(), std::forward&lt;Ref&gt;(ref)); } ||
                     requires { c.insert(c.end(), std::forward&lt;Ref&gt;(ref)); });
};
</pre></blockquote>
<p>
-5- Let <code><i>container-append</i></code> be defined as follows:
</p>
<blockquote><pre>
template&lt;class Container&gt;
constexpr auto <i>container-append</i>(Container&amp; c) {     <i>// exposition only</i>
  return [&amp;c]&lt;class Ref&gt;(Ref&amp;&amp; ref) {
    if constexpr (requires { c.emplace_back(declval&lt;Ref&gt;()); })
      c.emplace_back(std::forward&lt;Ref&gt;(ref));
    else if constexpr (requires { c.push_back(declval&lt;Ref&gt;()); })
      c.push_back(std::forward&lt;Ref&gt;(ref));
    <ins>else if constexpr (requires { c.emplace_hint(c.end(), declval&lt;Ref&gt;()); })
      c.emplace_hint(c.end(), std::forward&lt;Ref&gt;(ref));</ins>
    else if constexpr (requires { c.emplace(c.end(), declval&lt;Ref&gt;()); })
      c.emplace(c.end(), std::forward&lt;Ref&gt;(ref));
    else
      c.insert(c.end(), std::forward&lt;Ref&gt;(ref));
  };
};
</pre></blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4122"><a href="4122">4122</a>. Ill-formed <code>operator&lt;=&gt;</code> can cause hard error when instantiating <code>std::inplace_vector</code></h3>
<p><b>Section:</b> 23.3.16.1 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.overview">[inplace.vector.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-07-20 <b>Last modified:</b> 2024-08-02</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is almost the same problem as LWG <a href="4071" title="reference_wrapper comparisons are not SFINAE-friendly (Status: WP)">4071</a> except that it happens to <code>std::inplace_vector</code>. 
As the <code>operator&lt;=&gt;</code> overload for <code>std::inplace_vector</code> is a non-template function whose return 
type (<code><i>synth-three-way-result</i>&lt;T&gt;</code>) is not deduced, when the return type is ill-formed, hard 
error occurs in the instantiation of the enclosing <code>std::inplace_vector&lt;T, N&gt;</code>.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p id="res-4122"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 23.3.16.1 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.overview">[inplace.vector.overview]</a>, class template <code>std::inplace_vector</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T, size_t N&gt;
  class inplace_vector {
  public:
    [&hellip;]
    constexpr friend bool operator==(const inplace_vector&amp; x,
                                     const inplace_vector&amp; y);
    constexpr friend <del><i>synth-three-way-result</i>&lt;T&gt;</del><ins>auto</ins>
      operator&lt;=&gt;(const inplace_vector&amp; x, const inplace_vector&amp; y)<del>;</del><ins>
        requires requires (const T t) { <i>synth-three-way</i>(t, t); } 
      {
        return lexicographical_compare_three_way(x.begin(), x.end(), y.begin(), y.end(),
                                                 <i>synth-three-way</i>);
      }</ins>
    constexpr friend void swap(inplace_vector&amp; x, inplace_vector&amp; y)
      noexcept(N == 0 || (is_nothrow_swappable_v&lt;T&gt; &amp;&amp;
                          is_nothrow_move_constructible_v&lt;T&gt;))
    { x.swap(y); }
  };
};
</pre>
</blockquote>

</li>
</ol>





<hr>
<h3 id="4123"><a href="4123">4123</a>. Container effects use "the assignment operator or move assignment operator"</h3>
<p><b>Section:</b> 23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a>, 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>, 23.3.16.5 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.modifiers">[inplace.vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-07-25 <b>Last modified:</b> 2024-12-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#deque.modifiers">active issues</a> in [deque.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#deque.modifiers">issues</a> in [deque.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The spec for <code class='backtick'>deque::erase</code> talks about a exception
"thrown by the assignment operator of <code class='backtick'>T</code>" but it's unclear which
assignment operator this means.
Arguably, this is fine because it means "the assignment operator that
is used when repositioning the remaining elements".
However, <code class='backtick'>deque::append_range</code>, <code class='backtick'>vector::append_range</code>, <code class='backtick'>vector::erase</code>,
<code class='backtick'>inplace_vector::append_range</code>, and <code class='backtick'>inplace_vector::erase</code> talk about
"the assignment operator or move assignment operator" which is just odd.
In C++03 this just said "the assignment operator" and move semantics
added "or the move assignment operator" but we could improve it.
</p>

<p>
What we should talk about is "an assignment operator", or "the assignment
operator selected by overload resolution for the assignment expressions
performed by the operation", or something like that.
</p>

<p>
This is potentially a bigger issue than just assignment:
for <code class='backtick'>append_range</code> we say
"If an exception is thrown other than by the copy constructor,
move constructor, assignment operator, or move assignment operator [...]"
and there's no guarantee that the constructor used for initializing a
<i>Cpp17CopyInsertable</i> type is a copy constructor or move constructor.
It could be some templated constructor that is a better match than any
of the special member functions.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Arthur to draft wording.
</p>

<p><i>[2024-12-06; LWG telecon]</i></p>

<p>
23.3.11.4 <a href="https://timsong-cpp.github.io/cppwp/list.modifiers">[list.modifiers]</a> p1 says:
<blockquote>
<i>Complexity</i>:
Insertion of a single element into a list takes constant time and exactly
one call to a constructor of <code class='backtick'>T</code>.
Insertion of multiple elements into a list is linear in the number of elements inserted,
and the number of calls to the copy constructor or move constructor of <code class='backtick'>T</code>
is exactly equal to the number of elements inserted.
</blockquote>
In addition to incorrectly talking about "the copy constructor or move
constructor", it should not should not talk about any "call to a constructor"
because scalars do not have constructors at all.
We should talk about calls to <code class='backtick'>allocator_traits::construct</code> not constructors,
or objects being constructed.
</p>
<p>
Similarly, p5 says:
<blockquote>
<i>Complexity</i>:
Erasing a single element is a constant time operation with
a single call to the destructor of <code class='backtick'>T</code>.
Erasing a range in a list is linear time in the size of the range
and the number of calls to the destructor of type <code class='backtick'>T</code>
is exactly equal to the size of the range.
</blockquote>
This should talk about calls to <code class='backtick'>allocator_traits::destroy</code>,
or objects being destroyed.
</p>
<p>
23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a> is similar.
Look for similar problems elsewhere.
</p>

<p><i>[2024-12-06; Jonathan adds wording, incorporating Arthur's wording]</i></p>



<p id="res-4123"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages  C++">N4993</a>.
</p>

<ol>
<li>
<p>Modify 23.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a> as indicated:</p>
<blockquote>
<pre>void shrink_to_fit();</pre>
<p>
-5- <i>Preconditions</i>:
<code class='backtick'>T</code> is <i>CppMoveInsertable</i> into <code class='backtick'>deque</code>.
</p>
<p>
-6- <i>Effects</i>:
<code class='backtick'>shrink_to_fit</code> is a non-binding request to reduce memory use
but does not change the size of the sequence.
[<i>Note 1</i>:
The request is non-binding to allow latitude for
implementation-specific optimizations.
&mdash; <i>end note</i>]
If the size is equal to the old capacity, or
if an exception is thrown other than by the <del>move constructor</del>
<ins>move-construction of one object</ins>
of a non-<i>Cpp17CopyInsertable</i> <ins>type</ins> <code class='backtick'>T</code>
<ins>from another</ins>,
then there are no effects.
</p>
</blockquote>
</li>
<li>
<p>Modify 23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a> as indicated:</p>
<blockquote>
<pre>iterator insert(const_iterator position, const T&amp; x);
...
template&lt;<i>container-compatible-range</i>&lt;T&gt; R&gt;
  void append_range(R&amp;&amp; rg);</pre>
<p>
-1- <i>Effects</i>: [...]
</p>
<p>
-2- <i>Complexity</i>:
The complexity is linear in the number of elements inserted plus
the lesser of the distances to the beginning and end of the deque.
Inserting a single element at either the beginning or end of a deque
always takes constant time and 
<del>causes a single call to a constructor of T</del>
<ins>constructs a single object of type <code class='backtick'>T</code></ins>.
</p>
<p>
-3- <i>Remarks</i>:
If an exception is thrown other than by the
<del>copy constructor, move constructor,
assignment operator, or move assignment operator of <code class='backtick'>T</code>
</del>
<ins>
construction or assignment of one object of type <code class='backtick'>T</code> from another
</ins>,
there are no effects.
If an exception is thrown while inserting a single element at either end,
there are no effects.
Otherwise, if an exception is thrown by the
<del>move constructor of a</del>
<ins>move-construction of one object of</ins>
non-<i>Cpp17CopyInsertable</i>
<ins>type</ins>
<code class='backtick'>T</code> <ins>from another</ins>, the effects are unspecified.
<p>[...]</p>
-5- <i>Throws</i>:
Nothing unless an exception is thrown by
<del>the assignment operator of <code class='backtick'>T</code></del>
<ins>
the assignment of one object of type <code class='backtick'>T</code> from another
</ins>.
</p>
<pre>iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_front();
void pop_back();</pre>
<p>
-4- <i>Effects</i>:
An erase operation that erases the last element of a deque invalidates only
the past-the-end iterator
and all iterators and references to the erased elements.
An erase operation that erases the first element of a deque but not the last
element invalidates only iterators and references to the erased elements.
An erase operation that erases neither the first element nor the last element
of a deque invalidates the past-the-end iterator and all iterators and
references to all the elements of the deque.
</p>
<p>
[<i>Note 1</i>:
<code class='backtick'>pop_front</code> and <code class='backtick'>pop_back</code> are erase operations.
&mdash; <i>end note</i>]
</p>
<p>
-5- <i>Throws</i>:
Nothing unless an exception is thrown by <del>the</del><ins>an</ins>
assignment operator of <code class='backtick'>T</code>.
</p>
<p>
-6- <i>Complexity</i>:
The number of
<del>calls to the destructor of <code class='backtick'>T</code></del>
<ins>objects of type <code class='backtick'>T</code> destroyed</ins>
is the same as the number of
elements erased, but the number of calls to the assignment operator of <code class='backtick'>T</code>
is no more than the lesser of the number of elements before the erased
elements and the number of elements after the erased elements.
</p>
</blockquote>
</li>
<li>
<p>Modify 23.3.7.5 <a href="https://timsong-cpp.github.io/cppwp/forward.list.modifiers">[forward.list.modifiers]</a> as indicated:</p>
<blockquote>
<p>
-1- [...]
Inserting <code class='backtick'>n</code> elements into a <code class='backtick'>forward_list</code> is linear in
<code class='backtick'>n</code>, and the number of <del>calls to the copy or move constructor of</del>
<ins>objects of type</ins> <code class='backtick'>T</code> <ins>constructed</ins> is
exactly equal to <code class='backtick'>n</code>. Erasing <code class='backtick'>n</code> elements from a <code class='backtick'>forward_list</code> is
linear in <code class='backtick'>n</code> and the number of <del>calls to the destructor of</del>
<ins>objects of</ins> type <code class='backtick'>T</code> <ins>destroyed</ins> is exactly equal to <code class='backtick'>n</code>.
</p>
</blockquote>
</li>
<li>
<p>Modify 23.3.11.4 <a href="https://timsong-cpp.github.io/cppwp/list.modifiers">[list.modifiers]</a> as indicated:</p>
<blockquote>
<p>
-1- <i>Complexity</i>:
Insertion of a single element into a list takes constant time and
<ins>constructs</ins> exactly one
<del>call to a constructor of <code class='backtick'>T</code></del>
<ins>object of type <code class='backtick'>T</code></ins>.
Insertion of multiple elements into a list is linear in the number of
elements inserted and the number of
<del>calls to the copy constructor or move constructor of <code class='backtick'>T</code></del>
<ins>objects of type <code class='backtick'>T</code> constructed</ins>
is exactly equal to the number of elements inserted.
</p>
<p>
-2- <i>Remarks</i>:
Does not affect the validity of iterators and references.
If an exception is thrown, there are no effects.
</p>
<pre>iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void pop_front();
void pop_back();
void clear() noexcept;</pre>
<p>
-3- <i>Effects</i>:
Invalidates only the iterators and references to the erased elements.
</p>
<p>
-4- <i>Throws</i>: Nothing.
</p>
<p>
-5- <i>Complexity</i>:
Erasing a single element is a constant time operation with a single
<del>call to the destructor of <code class='backtick'>T</code></del>
<ins>object of type <code class='backtick'>T</code> destroyed</ins>.
Erasing a range in a list is linear time in the
size of the range and the number of
<del>calls to the destructor of type <code class='backtick'>T</code></del>
<ins>objects of type <code class='backtick'>T</code> destroyed</ins>
is exactly equal to the size of the range.
</p>
</blockquote>
</li>
<li>
<p>Modify 23.3.13.2 <a href="https://timsong-cpp.github.io/cppwp/vector.cons">[vector.cons]</a> as indicated:</p>
<blockquote>
<pre>template&lt;class InputIterator&gt;
  constexpr vector(InputIterator first, InputIterator last,
                   const Allocator&amp; = Allocator());</pre>
<p>
-9- <i>Effects</i>:
Constructs a <code class='backtick'>vector</code> equal to the range [<code class='backtick'>first</code>, <code class='backtick'>last</code>),
using the specified allocator.
</p>
<p>
-10- <i>Complexity</i>:
<del>Makes only <i>N</i> calls to the copy constructor of <code class='backtick'>T</code></del>
<ins>Initializes exactly <i>N</i> elements</ins>

(where <i>N</i> is the distance between <code class='backtick'>first</code> and <code class='backtick'>last</code>)
and no reallocations if iterators <code class='backtick'>first</code> and <code class='backtick'>last</code> are of forward,
bidirectional, or random access categories.
It <del>makes</del> <ins>initializes</ins> order
<i>N</i>
<del>calls to the copy constructor of <code class='backtick'>T</code></del>
<ins>elements</ins>
 and <ins>performs</ins>
order log <i>N</i> reallocations if they are just input iterators.
</p>
<pre>template&lt;<i>container-compatible-range</i>&lt;T&gt; R&gt;
  constexpr vector(from_range_t, R&amp;&amp; rg, const Allocator&amp; = Allocator());</pre>
<p>
-11- <i>Effects</i>:
Constructs a <code class='backtick'>vector</code> object with the elements of the range <code class='backtick'>rg</code>,
using the specified allocator.
</p>
<p>
-12- <i>Complexity</i>:
Initializes exactly <i>N</i> elements from the results of dereferencing
successive iterators of <code class='backtick'>rg</code>, where <i>N</i> is <code class='backtick'>ranges::distance(rg)</code>.
Performs no reallocations if <code class='backtick'>R</code> models <code class='backtick'>ranges::forward_range</code> or
<code class='backtick'>ranges::sized_range</code>; otherwise, performs order log <i>N</i> reallocations
and <ins>initializes</ins> order <i>N</i>
<del>calls to the copy or move constructor of <code class='backtick'>T</code></del>
<ins>elements</ins>.
</p>
</blockquote>
</li>
<li>
<p>Modify 23.3.13.3 <a href="https://timsong-cpp.github.io/cppwp/vector.capacity">[vector.capacity]</a> as indicated:</p>
<blockquote>
<pre>constexpr void reserve(size_type n);</pre>
<p>
-3- <i>Preconditions</i>:
<code class='backtick'>T</code> is <i>CppMoveInsertable</i> into <code class='backtick'>vector</code>.
</p>
<p>
-4- <i>Effects</i>:
A directive that informs a <code class='backtick'>vector</code> of a planned change in size,
so that it can manage the storage allocation accordingly.
After <code class='backtick'>reserve&lt;del&gt;()&lt;/del&gt;</code>, <code class='backtick'>capacity()</code> is greater or equal to
the argument of <code class='backtick'>reserve</code> if reallocation happens;
and equal to the previous value of <code class='backtick'>capacity()</code> otherwise.
Reallocation happens at this point if and only if
the current capacity is less than the argument of <code class='backtick'>reserve&lt;del&gt;()&lt;/del&gt;</code>.
If an exception is thrown other than by the
<del>move constructor of a</del>
<ins>move-construction of one object of</ins>
non-<i>Cpp17CopyInsertable</i>
<ins>type</ins> <code class='backtick'>T</code> <ins>from another</ins>, there are no effects.
</p>
<p>[...]</p>
<pre>constexpr shrink_to_fit();</pre>
<p>
-8- <i>Preconditions</i>:
<code class='backtick'>T</code> is <i>CppMoveInsertable</i> into <code class='backtick'>vector</code>.
</p>
<p>
-9- <i>Effects</i>:
<code class='backtick'>shrink_to_fit</code> is a non-binding request to reduce <code class='backtick'>capacity()</code> to <code class='backtick'>size()</code>.
[<i>Note 2</i>:
The request is non-binding to allow latitude for
implementation-specific optimizations.
&mdash; <i>end note</i>]
It does not increase <code class='backtick'>capacity()</code>, but may reduce <code class='backtick'>capacity()</code> by causing
reallocation.
If an exception is thrown other than by the <del>move constructor</del>
<ins>move-construction of one object</ins>
of a non-<i>Cpp17CopyInsertable</i> <ins>type</ins> <code class='backtick'>T</code>
<ins>from another</ins>,
there are no effects.
</p>
<p>[...]</p>
<pre>constexpr void resize(size_type sz);</pre>
<p>
-14- <i>Preconditions</i>:
<code class='backtick'>T</code> is <i>Cpp17MoveInsertable</i> and <i>Cpp17DefaultInsertable</i> into
<code class='backtick'>vector</code>.
</p>
<p>
-15- <i>Effects</i>: [...]
</p>
<p>
-16- <i>Remarks</i>:
If an exception is thrown other than by the <del>move constructor</del>
<ins>move-construction of one object</ins>
of a non-<i>Cpp17CopyInsertable</i> <ins>type</ins> <code class='backtick'>T</code>
<ins>from another</ins>,
there are no effects.
</p>
</blockquote>
</li>
<li>
<p>Modify 23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> as indicated:</p>
<blockquote>
<pre>iterator insert(const_iterator position, const T&amp; x);
...
template&lt;<i>container-compatible-range</i>&lt;T&gt; R&gt;
  void append_range(R&amp;&amp; rg);</pre>
<p>
-1- <i>Complexity</i>: [...]
</p>
<p>
-2- <i>Remarks</i>:
Causes reallocation if the new size is greater than the old capacity.
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence, as well as the past-the-end iterator.
If no reallocation happens, then
references, pointers, and iterators
before the insertion point remain valid
but those at or after the insertion point,
including the past-the-end iterator,
are invalidated.
If an exception is thrown other than by the
<del>copy constructor, move constructor,
assignment operator, or move assignment operator of
<code class='backtick'>T</code> or by any \tcode{InputIterator} operation</del>
<ins>the construction or assignment of one object of type <code class='backtick'>T</code> from another,
or by any <code class='backtick'>InputIterator</code> operation</ins>,
there are no effects.
If an exception is thrown while inserting a single element at the end and
<code class='backtick'>T</code> is <i>Cpp17CopyInsertable</i> or
<code>is_nothrow_move_constructible_v&lt;T&gt;</code> is <code class='backtick'>true</code>,
there are no effects.
Otherwise, if an exception is thrown by the
<del>move constructor of a</del>
<ins>move-construction of one object of</ins>
non-<i>Cpp17CopyInsertable</i>
<ins>type</ins>
<code class='backtick'>T</code> <ins>from another</ins>, the effects are unspecified.
</p>
<pre>constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();</pre>
<p>
-3- <i>Effects</i>:
Invalidates iterators and references at or after the point of the erase.
</p>
<p>
-4- <i>Throws</i>:
Nothing unless an exception is thrown by the
<del>assignment operator or move assignment operator of <code class='backtick'>T</code></del>
<ins>construction or assignment of one object of type <code class='backtick'>T</code> from another</ins>.
</p>
<p>
-5- <i>Complexity</i>:
The
<del>destructor of <code class='backtick'>T</code> is called the number of times</del>
<ins>number of objects of type <code class='backtick'>T</code> destroyed is</ins>
equal to the number of the elements erased,
but <del>the</del><ins>an</ins>
assignment operator of <code class='backtick'>T</code> is called the number of times equal to
the number of elements in the vector after the erased elements.
</p>
</blockquote>
</li>
<li>
<p>Modify 23.3.16.5 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.modifiers">[inplace.vector.modifiers]</a> as indicated:</p>
<blockquote>
<pre>constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();</pre>
<p>
-29- <i>Complexity</i>:
The
<del>destructor of <code class='backtick'>T</code> is called the number of times</del>
<ins>number of objects of type <code class='backtick'>T</code> destroyed is</ins>
equal to the number of the elements erased,
but <del>the</del><ins>an</ins>
assignment operator of <code class='backtick'>T</code> is called the number of times equal to
the number of elements after the erased elements.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4125"><a href="4125">4125</a>. <code>move_iterator</code>'s default constructor should be constrained</h3>
<p><b>Section:</b> 24.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/move.iterator">[move.iterator]</a>, 24.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/move.iter.cons">[move.iter.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-07-22 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#move.iterator">active issues</a> in [move.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#move.iterator">issues</a> in [move.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Although it is unclear why <a href="https://wg21.link/P2325" title=" Views should not be required to be default constructible">P2325</a> did not apply to <code>move_iterator</code>, there is 
implementation divergence among the current libraries (<a href="https://godbolt.org/z/WdoPcjjv4">demo</a>):
</p>
<blockquote><pre>
#include &lt;istream&gt;
#include &lt;iterator&gt;
#include &lt;ranges&gt;

using R = std::ranges::istream_view&lt;int&gt;;
using I = std::ranges::iterator_t&lt;R&gt;;
using MI = std::move_iterator&lt;I&gt;;
static_assert(std::default_initializable&lt;MI&gt;); // <span  style="color:#C80000;font-weight:bold">libstdc++ passes, libc++ fails</span>
</pre></blockquote>
<p>
As libc++ additionally requires that its default constructors satisfy <code>is_constructible_v&lt;Iterator&gt;</code>.
<p/>
Although this is not current standard-conforming behavior, such constraint does make sense since <code>move_iterator</code> 
only requires the underlying iterator to be <code>input_iterator</code> which may not be <code>default_initializable</code>.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Six P0 (tentatively ready) votes but one for NAD:
"design change, needs paper. Not constraining this seems to be intended by
<a href="https://wg21.link/P2325R3" title=" Views should not be required to be default constructible">P2325R3</a>. Even if we want to constrain it,
why <code class='backtick'>default_initializable</code> rather than just <code class='backtick'>is_constructible_v</code>?"
Author of <a href="https://wg21.link/P2325R3" title=" Views should not be required to be default constructible">P2325R3</a> had no such intent and voted P0.
Issue submitter used <code class='backtick'>default_initializable</code> to align with <code class='backtick'>forward_iterator</code>
requirements, but would not object to implementers using <code class='backtick'>is_constructible_v</code>
for backported DRs.
</p>



<p id="res-4125"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 24.5.4.2 <a href="https://timsong-cpp.github.io/cppwp/move.iterator">[move.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Iterator&gt;
  class move_iterator {
  public:
    [&hellip;]
    constexpr move_iterator() <ins>requires default_initializable&lt;Iterator&gt; = default</ins>;
    [&hellip;]
  private:
    Iterator current <ins>= Iterator()</ins>;   // <i>exposition only</i>
  };
}
</pre>
</blockquote>

</li>

<li><p>Modify 24.5.4.4 <a href="https://timsong-cpp.github.io/cppwp/move.iter.cons">[move.iter.cons]</a> as indicated:</p>

<blockquote>
<pre>
<del>constexpr move_iterator();</del>
</pre>
<blockquote>
<p>
<del>-1- <i>Effects</i>: Value-initializes <code>current</code>.</del>
</p>
</blockquote>
</blockquote>

</li>
</ol>





<hr>
<h3 id="4127"><a href="4127">4127</a>. The Standard Library should not use predicates of the form <code>pred(*i) != false</code></h3>
<p><b>Section:</b> 22.10.18.3 <a href="https://timsong-cpp.github.io/cppwp/func.search.bm">[func.search.bm]</a>, 22.10.18.4 <a href="https://timsong-cpp.github.io/cppwp/func.search.bmh">[func.search.bmh]</a>, 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a>, 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, 26.6.6 <a href="https://timsong-cpp.github.io/cppwp/alg.find">[alg.find]</a>, 26.6.9 <a href="https://timsong-cpp.github.io/cppwp/alg.find.first.of">[alg.find.first.of]</a>, 26.6.10 <a href="https://timsong-cpp.github.io/cppwp/alg.adjacent.find">[alg.adjacent.find]</a>, 26.6.11 <a href="https://timsong-cpp.github.io/cppwp/alg.count">[alg.count]</a>, 26.6.12 <a href="https://timsong-cpp.github.io/cppwp/alg.mismatch">[alg.mismatch]</a>, 26.6.15 <a href="https://timsong-cpp.github.io/cppwp/alg.search">[alg.search]</a>, 26.8.1 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting.general">[alg.sorting.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-07-25 <b>Last modified:</b> 2024-08-05</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.search.bm">active issues</a> in [func.search.bm].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.search.bm">issues</a> in [func.search.bm].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code><i>boolean-testable</i></code> concept introduced in <a href="https://wg21.link/P1964R2" title=" Wording for boolean-testable">P1964R2</a> 
places appropriate constraints on boolean-ish types, so that <code>!pred(x)</code> or 
<code>i != last &amp;&amp; pred(*i)</code> always has a valid definition.
<p/>
Subsequently, <a href="https://wg21.link/P2167R3" title=" Improved Proposed Wording for LWG 2114 (contextually convertible to bool)">P2167R3</a> applied this concept to 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> 
p6, requiring that <code>decltype(pred(*first))</code> should model <code><i>boolean-testable</i></code>.
<p/>
However, <code><i>boolean-testable</i></code> does not guarantee that 
<code>pred(*i) != false</code> is valid, because the type may overload <code>operator==</code>.
It is necessary to replace this form of expression with an appropriate one as we do in 
<a href="https://wg21.link/P1964R2#wording">P1964R2</a>.
</p>

<p><i>[2024-07-27; Daniel comments]</i></p>

<p>
I would recommend to add a wrapping "<code><ins>bool(</ins>pred([&hellip;])<ins>)</ins></code>" and possibly 
even extend to "<code><ins>bool(</ins>pred([&hellip;])<ins>)</ins></code> <ins>is <code>true</code></ins>"
following our usual wording convention, since an English phrase of the form "if <code>pred([&hellip;])</code>" 
where <code>pred([&hellip;])</code> is potential non-<code>bool</code> and the English "if" is not a C++ language 
<code>if</code> (with built-in conversion semantics) doesn't sound like a meaningful phrase to me.
</p>

<p><i>[2024-08-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. "Needs more 'is <code class='backtick'>true</code>' added".
"Would prefer not to have explicit conversions to <code class='backtick'>bool</code> unless
<i><code class='backtick'>boolean-testable</code></i> requires that.
The 'Let E be' lists don't need an 'is true' there,
but the use of 'E' should say 'is true'".
[alg.search] and [func.search.bm] have changed editorially in the draft,
the proposed resolution needs updating.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 22.10.18.3 <a href="https://timsong-cpp.github.io/cppwp/func.search.bm">[func.search.bm]</a> as indicated:</p>

<blockquote>
<pre>
boyer_moore_searcher(RandomAccessIterator1 pat_first,
                     RandomAccessIterator1 pat_last,
                     Hash hf = Hash(),
                     BinaryPredicate pred = BinaryPredicate());
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: The value type of <code>RandomAccessIterator1</code> meets the
<i>Cpp17DefaultConstructible</i>, the <i>Cpp17CopyConstructible</i>, and the 
<i>Cpp17CopyAssignable</i> requirements.
<p/>
-2- Let <code>V</code> be <code>iterator_traits&lt;RandomAccessIterator1&gt;::value_type</code>.
For any two values <code>A</code> and <code>B</code> of type <code>V</code>, if
<code>pred(A, B) <del>== true</del></code>, then <code>hf(A) == hf(B)</code> is 
<code>true</code>.
</p>
[&hellip;]
<p>
-7- <i>Returns</i>: A pair of iterators <code>i</code> and <code>j</code> such that
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; <code>i</code> is the first iterator in the range [<code>first</code>,
<code>last - (pat_last_ - pat_first_)</code>) such that for every non-negative integer 
<code>n</code> less than <code>pat_last_ - pat_first_</code> the following condition holds: 
<code>pred(*(i + n), *(pat_first_ + n)) <del>!= false</del></code>, and
</p>
</li>
<li>
<p>[&hellip;]</p>
</li>
</ol>
</blockquote>
</blockquote>

</li>

<li><p>Modify 22.10.18.4 <a href="https://timsong-cpp.github.io/cppwp/func.search.bmh">[func.search.bmh]</a> as indicated:</p>

<blockquote>
<pre>
boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first,
                              RandomAccessIterator1 pat_last,
                              Hash hf = Hash(),
                              BinaryPredicate pred = BinaryPredicate());
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: The value type of <code>RandomAccessIterator1</code> meets the
<i>Cpp17DefaultConstructible</i>, <i>Cpp17CopyConstructible</i>, and <i>Cpp17CopyAssignable</i>
requirements.
<p/>
-2- Let <code>V</code> be <code>iterator_traits&lt;RandomAccessIterator1&gt;::value_type</code>.
For any two values <code>A</code> and <code>B</code> of type <code>V</code>, if  
<code>pred(A, B) <del>== true</del></code>, then <code>hf(A) == hf(B)</code> is <code>true</code>.
</p>
[&hellip;]
<p>
-7- <i>Returns</i>: A pair of iterators <code>i</code> and <code>j</code> such that
</p>
<ol style="list-style-type: none">
<li><p>
(7.1) &mdash; <code>i</code> is the first iterator in the range [<code>first</code>,
<code>last - (pat_last_ - pat_first_)</code>) such that for every non-negative integer <code>n</code> 
less than <code>pat_last_ - pat_first_</code> the following condition holds: 
<code>pred(*(i + n), *(pat_first_ + n)) <del>!= false</del></code>, and 
</p></li>
<li>
<p>[&hellip;]</p>
</li>
</ol>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a> as indicated:</p>

<blockquote>
<p>
-3- The phrase "equivalence of keys" means the equivalence relation imposed by the comparison object.
That is, two keys <code>k1</code> and <code>k2</code> are considered to be equivalent if for the 
comparison object <code>comp</code>, <code><ins>!</ins>comp(k1, k2) <del>== false</del> &amp;&amp; 
<ins>!</ins>comp(k2, k1) <del>== false</del></code>.
</p>
[&hellip;]
<p>
-177- The fundamental property of iterators of associative containers is that they iterate through 
the containers in the non-descending order of keys where non-descending is defined by the comparison 
that was used to construct them. For any two dereferenceable iterators <code>i</code> and <code>j</code> 
such that distance from <code>i</code> to <code>j</code> is positive, the following condition holds:
</p>
<pre><blockquote><ins>!</ins>value_comp(*j, *i) <del>== false</del></blockquote></pre>
<p>
-178- For associative containers with unique keys the stronger condition holds:
</p>
<pre><blockquote>value_comp(*i, *j) <del>!= false</del></blockquote></pre>
</blockquote>

</li>

<li><p>Modify 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> as indicated:</p>

<blockquote>
<pre>
size_type remove(const T&amp; value);
template&lt;class Predicate&gt; size_type remove_if(Predicate pred);
</pre>
<blockquote>
<p>
-15- <i>Effects</i>: Erases all the elements in the list referred to by a list iterator 
<code>i</code> for which the following conditions hold: <code>*i == value, pred(*i) 
<del>!= false</del></code>. Invalidates only the iterators and references to
the erased elements.
<p/>
-16- <i>Returns</i>: The number of elements erased.
<p/>
-17- <i>Throws</i>: Nothing unless an exception is thrown by <code>*i == value</code> or
<code>pred(*i) <del>!= false</del></code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 26.6.6 <a href="https://timsong-cpp.github.io/cppwp/alg.find">[alg.find]</a> as indicated:</p>

<blockquote>
<p>
-1- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li>
<p>(1.1) &mdash; <code>*i == value</code> for <code>find</code>;</p>
</li>
<li>
<p>(1.2) &mdash; <code>pred(*i) <del>!= false</del></code> for <code>find_if</code>;</p>
</li>
<li>
<p>(1.3) &mdash; <code><ins>!</ins>pred(*i) <del>== false</del></code> for <code>find_if_not</code>;
</p>
[&hellip;]
</li>
</ol>
</blockquote>

</li>

<li><p>Modify 26.6.9 <a href="https://timsong-cpp.github.io/cppwp/alg.find.first.of">[alg.find.first.of]</a> as indicated:</p>

<blockquote>
<p>
-1- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li><p>
(1.1) &mdash; <code>*i == *j</code> for the overloads with no parameter <code>pred</code>;
</p></li>
<li><p>
(1.2) &mdash; <code>pred(*i, *j) <del>!= false</del></code> for the overloads with a parameter
<code>pred</code> and no parameter <code>proj1</code>;
</p>
[&hellip;]
</li>
</ol>
</blockquote>

</li>

<li><p>Modify 26.6.10 <a href="https://timsong-cpp.github.io/cppwp/alg.adjacent.find">[alg.adjacent.find]</a> as indicated:</p>

<blockquote>
<p>
-1- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li><p>
(1.1) &mdash; <code>*i == *(i + 1)</code> for the overloads with no parameter <code>pred</code>;
</p></li>
<li><p>
(1.2) &mdash; <code>pred(*i, *(i + 1)) <del>!= false</del></code> for the overloads with a 
parameter <code>pred</code> and no parameter <code>proj1</code>;
</p>
[&hellip;]
</li>
</ol>
</blockquote>

</li>

<li><p>Modify 26.6.11 <a href="https://timsong-cpp.github.io/cppwp/alg.count">[alg.count]</a> as indicated:</p>

<blockquote>
<p>
-1- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li><p>
(1.1) &mdash; <code>*i == value</code> for the overloads with no parameter <code>pred</code> 
or <code>proj</code>;
</p></li>
<li><p>
(1.2) &mdash; <code>pred(*i) <del>!= false</del></code> for the overloads with a parameter
<code>pred</code> but no parameter <code>proj</code>;
</p>
[&hellip;]
</li>
</ol>
</blockquote>

</li>

<li><p>Modify 26.6.12 <a href="https://timsong-cpp.github.io/cppwp/alg.mismatch">[alg.mismatch]</a> as indicated:</p>

<blockquote>
<p>
-2- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li><p>
(2.1) &mdash; <code>!(*(first1 + n) == *(first2 + n))</code> for the overloads with no 
parameter <code>pred</code>;
</p></li>
<li><p>
(2.2) &mdash; <code><ins>!</ins>pred(*(first1 + n), *(first2 + n)) <del>== false</del></code> 
for the overloads with a parameter <code>pred</code> and no parameter <code>proj1</code>;
</p>
[&hellip;]
</li>
</ol>
</blockquote>

</li>

<li><p>Modify 26.6.15 <a href="https://timsong-cpp.github.io/cppwp/alg.search">[alg.search]</a> as indicated:</p>

<blockquote>
<p>
-1- <i>Returns</i>: The first iterator <code>i</code> in the range [<code>first1</code>,
<code>last1 - (last2-first2)</code>) such that for every non-negative integer <code>n</code> 
less than <code>last2 - first2</code> the following corresponding conditions hold:
<code>*(i + n) == *(first2 + n), pred(*(i + n), *(first2 + n)) <del>!= false</del></code>.
Returns <code>first1</code> if [<code>first2</code>, <code>last2</code>) is empty, otherwise 
returns <code>last1</code> if no such iterator is found.
</p>
[&hellip;]
<p>
-6- <i>Returns</i>: The first iterator <code>i</code> in the range [<code>first</code>,
<code>last-count</code>) such that for every non-negative integer <code>n</code> less than 
<code>count</code> the following corresponding conditions hold: <code>*(i + n) == value, 
pred(*(i + n), value) <del>!= false</del></code>. Returns <code>last</code> if no such 
iterator is found.
</p>
</blockquote>

</li>

<li><p>Modify 26.8.1 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting.general">[alg.sorting.general]</a> as indicated:</p>

<blockquote>
<p>
-3- For all algorithms that take <code>Compare</code>, there is a version that uses 
<code>operator&lt;</code> instead. That is, <code>comp(*i, *j) <del>!= false</del></code> 
defaults to <code>*i &lt; *j <del>!= false</del></code>. For algorithms other than those 
described in 26.8.4 <a href="https://timsong-cpp.github.io/cppwp/alg.binary.search">[alg.binary.search]</a>, <code>comp</code> shall induce a strict 
weak ordering on the values.
</p>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2024-08-03; Daniel provides improved wording]</i></p>

<p>
The current wording is inconsistent in regard to explicit conversion to <code>bool</code>
and lack of them in cases of expressions whose value is required to satisfy the
<code><i>boolean-testable</i></code> constraints. To realize consistent results for
all subclause references touched by the changes required by this issue I decided
that every <i>E</i> <b>definition</b> remains unconverted but and that every <i>E</i>
<b>evaluation</b> is interpreted as if an implied <code>bool</code> conversion has
been applied based on the reflector preference for that simplified approach.
<p/>
Nonetheless, during the wording preparation I noticed that the wording in the 
<i>Throws</i>: element 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> p17 is seriously <b>missing</b> the 
additional extra conversion to <code>bool</code> for both expressions, because the 
<code><i>boolean-testable</i></code> requirements do not impose a no-throw requirement for 
that conversion, and they must therefore be included here.
<p/>
This problem will be handled by a separate issue (LWG <a href="4132" title="Throws specifications need to include boolean-testable operations (Status: New)">4132</a>), because the 
rationale for this change is different from the actual target of this issue and not 
related to the other consistency adjustments done by the wording below.
</p>


<p id="res-4127"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 22.10.18.3 <a href="https://timsong-cpp.github.io/cppwp/func.search.bm">[func.search.bm]</a> as indicated:</p>

<blockquote>
<pre>
boyer_moore_searcher(RandomAccessIterator1 pat_first,
                     RandomAccessIterator1 pat_last,
                     Hash hf = Hash(),
                     BinaryPredicate pred = BinaryPredicate());
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: The value type of <code>RandomAccessIterator1</code> meets the
<i>Cpp17DefaultConstructible</i>, <i>Cpp17CopyConstructible</i>, and 
<i>Cpp17CopyAssignable</i> requirements.
<p/>
-2- Let <code>V</code> be <code>iterator_traits&lt;RandomAccessIterator1&gt;::value_type</code>.
For any two values <code>A</code> and <code>B</code> of type <code>V</code>, if
<code>pred(A, B) <del>== true</del></code> <ins>is <code>true</code></ins>, then 
<code>hf(A) == hf(B)</code> is <code>true</code>.
</p>
[&hellip;]
</blockquote>
<pre>
template&lt;class RandomAccessIterator2&gt;
  pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
    operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Returns</i>: A pair of iterators <code>i</code> and <code>j</code> such that
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; <code>i</code> is the first iterator in the range [<code>first</code>,
<code>last - (pat_last_ - pat_first_)</code>) such that for every non-negative integer 
<code>n</code> less than <code>pat_last_ - pat_first_</code> the following condition holds: 
<code>pred(*(i + n), *(pat_first_ + n)) <del>!= false</del></code> <ins>is <code>true</code></ins>, and
</p>
</li>
<li><p>(7.2) &mdash; <code>j == next(i, distance(pat_first_, pat_last_))</code> <ins>is <code>true</code></ins>.
</p>
</li>
</ol>
</blockquote>
</blockquote>

</li>

<li><p>Modify 22.10.18.4 <a href="https://timsong-cpp.github.io/cppwp/func.search.bmh">[func.search.bmh]</a> as indicated:</p>

<blockquote>
<pre>
boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first,
                              RandomAccessIterator1 pat_last,
                              Hash hf = Hash(),
                              BinaryPredicate pred = BinaryPredicate());
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: The value type of <code>RandomAccessIterator1</code> meets the
<i>Cpp17DefaultConstructible</i>, <i>Cpp17CopyConstructible</i>, and <i>Cpp17CopyAssignable</i>
requirements.
<p/>
-2- Let <code>V</code> be <code>iterator_traits&lt;RandomAccessIterator1&gt;::value_type</code>.
For any two values <code>A</code> and <code>B</code> of type <code>V</code>, if  
<code>pred(A, B) <del>==</del> <ins>is</ins> true</code>, then <code>hf(A) == hf(B)</code> is 
<code>true</code>.
</p>
[&hellip;]
</blockquote>
<pre>
template&lt;class RandomAccessIterator2&gt;
  pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
    operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Returns</i>: A pair of iterators <code>i</code> and <code>j</code> such that
</p>
<ol style="list-style-type: none">
<li><p>
(7.1) &mdash; <code>i</code> is the first iterator in the range [<code>first</code>,
<code>last - (pat_last_ - pat_first_)</code>) such that for every non-negative integer <code>n</code> 
less than <code>pat_last_ - pat_first_</code> the following condition holds: 
<code>pred(*(i + n), *(pat_first_ + n)) <del>!= false</del></code> <ins>is <code>true</code></ins>, and 
</p></li>
<li><p>(7.2) &mdash; <code>j == next(i, distance(pat_first_, pat_last_))</code> <ins>is <code>true</code></ins>.
</p>
</li>
</ol>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a> as indicated:</p>

<blockquote>
<p>
-3- The phrase "equivalence of keys" means the equivalence relation imposed by the comparison object.
That is, two keys <code>k1</code> and <code>k2</code> are considered to be equivalent if for the 
comparison object <code>comp</code>, <code><ins>!</ins>comp(k1, k2) <del>== false</del> &amp;&amp; 
<ins>!</ins>comp(k2, k1) <del>== false</del></code> <ins>is <code>true</code></ins>.
</p>
[&hellip;]
<p>
-177- The fundamental property of iterators of associative containers is that they iterate through 
the containers in the non-descending order of keys where non-descending is defined by the comparison 
that was used to construct them. For any two dereferenceable iterators <code>i</code> and <code>j</code> 
such that distance from <code>i</code> to <code>j</code> is positive, the following condition holds:
</p>
<blockquote><p><code><ins>!</ins>value_comp(*j, *i) <del>== false</del></code> <ins>is <code>true</code>.</ins></p></blockquote>
<p>
-178- For associative containers with unique keys the stronger condition holds:
</p>
<blockquote><p><code>value_comp(*i, *j) <del>!= false</del></code> <ins>is <code>true</code>.</ins></p></blockquote>
</blockquote>

</li>

<li><p>Modify 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> as indicated:</p>

<blockquote>
<pre>
size_type remove(const T&amp; value);
template&lt;class Predicate&gt; size_type remove_if(Predicate pred);
</pre>
<blockquote>
<p>
-15- <i>Effects</i>: Erases all the elements in the list referred to by a list iterator 
<code>i</code> for which the following conditions hold: <code>*i == value</code> 
<ins>is <code>true</code></ins>, <code>pred(*i) <del>!= false</del></code> <ins>is <code>true</code></ins>. 
Invalidates only the iterators and references to the erased elements.
<p/>
-16- <i>Returns</i>: The number of elements erased.
<p/>
-17- <i>Throws</i>: Nothing unless an exception is thrown by <code>*i == value</code> or
<code>pred(*i) <del>!= false</del></code>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 26.6.6 <a href="https://timsong-cpp.github.io/cppwp/alg.find">[alg.find]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: Sub-bullets (1.4), (1.5), and (1.6) below regarding
<code>invoke</code> expressions are similarly required model <code><i>boolean-testable</i></code>,
as specified by concept <code>predicate</code> (18.7.4 <a href="https://timsong-cpp.github.io/cppwp/concept.predicate">[concept.predicate]</a>), therefore
the explicit conversion is removed here for consistency]
</p>
</blockquote>

<blockquote>
<p>
-1- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li>
<p>(1.1) &mdash; <code>*i == value</code> for <code>find</code>;</p>
</li>
<li>
<p>(1.2) &mdash; <code>pred(*i) <del>!= false</del></code> for <code>find_if</code>;</p>
</li>
<li>
<p>(1.3) &mdash; <code><ins>!</ins>pred(*i) <del>== false</del></code> for <code>find_if_not</code>;</p>
</li>
<li>
<p>(1.4) &mdash; <code><del>bool(</del>invoke(proj, *i) == value<del>)</del></code> for <code>ranges::find</code>;</p>
</li>
<li>
<p>(1.5) &mdash; <code><del>bool(</del>invoke(pred, invoke(proj, *i))<del>)</del></code> for <code>ranges::find_if</code>;</p>
</li>
<li>
<p>(1.6) &mdash; <code><del>bool(</del>!invoke(pred, invoke(proj, *i))<del>)</del></code> for <code>ranges::find_if_not</code>.</p>
</li>
</ol>
<p>
-2- <i>Returns</i>: The first iterator <code>i</code> in the range <code>[first, last)</code> for which 
<i>E</i> is <code>true</code>. Returns <code>last</code> if no such iterator is found.
</p>
</blockquote>

</li>

<li><p>Modify 26.6.9 <a href="https://timsong-cpp.github.io/cppwp/alg.find.first.of">[alg.find.first.of]</a> as indicated:</p>

<blockquote>
<p>
-1- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li><p>
(1.1) &mdash; <code>*i == *j</code> for the overloads with no parameter <code>pred</code>;
</p></li>
<li><p>
(1.2) &mdash; <code>pred(*i, *j) <del>!= false</del></code> for the overloads with a parameter
<code>pred</code> and no parameter <code>proj1</code>;
</p></li>
<li><p>
(1.3) &mdash; <code><del>bool(</del>invoke(pred, invoke(proj1, *i), invoke(proj2, *j))<del>)</del></code> 
for the overloads with parameters <code>pred</code> and <code>proj1</code>.
</p>
</li>
</ol>
<p>
[&hellip;]
<p/>
-3- <i>Returns</i>: The first iterator <code>i</code> in the range <code>[first1, last1)</code> such that 
for some iterator <code>j</code> in the range <code>[first2, last2)</code> <i>E</i> <del>holds</del> 
<ins>is <code>true</code></ins>. Returns <code>last1</code> if <code>[first2, last2)</code> is empty or if no 
such iterator is found.
</p>
</blockquote>

</li>

<li><p>Modify 26.6.10 <a href="https://timsong-cpp.github.io/cppwp/alg.adjacent.find">[alg.adjacent.find]</a> as indicated:</p>

<blockquote>
<p>
-1- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li><p>
(1.1) &mdash; <code>*i == *(i + 1)</code> for the overloads with no parameter <code>pred</code>;
</p></li>
<li><p>
(1.2) &mdash; <code>pred(*i, *(i + 1)) <del>!= false</del></code> for the overloads with a 
parameter <code>pred</code> and no parameter <code>proj</code>;
</p></li>
<li><p>
(1.3) &mdash; <code><del>bool(</del>invoke(pred, invoke(proj, *i), invoke(proj, *(i + 1)))<del>)</del></code> 
for the overloads with both parameters <code>pred</code> and <code>proj</code>.
</p></li>
</ol>
<p>
-2- <i>Returns</i>: The first iterator <code>i</code> such that both <code>i</code> and <code>i + 1</code> are 
in the range <code>[first, last)</code> for which <i>E</i> <del>holds</del> <ins>is <code>true</code></ins>.
Returns <code>last</code> if no such iterator is found.
</p>
</blockquote>

</li>

<li><p>Modify 26.6.11 <a href="https://timsong-cpp.github.io/cppwp/alg.count">[alg.count]</a> as indicated:</p>

<blockquote>
<p>
-1- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li><p>
(1.1) &mdash; <code>*i == value</code> for the overloads with no parameter <code>pred</code> 
or <code>proj</code>;
</p></li>
<li><p>
(1.2) &mdash; <code>pred(*i) <del>!= false</del></code> for the overloads with a parameter
<code>pred</code> but no parameter <code>proj</code>;
</p></li>
<li><p>
(1.3) &mdash; <code>invoke(proj, *i) == value</code> for the overloads with a parameter <code>proj</code> 
but no parameter <code>pred</code>;
</p></li>
<li><p>
(1.4) &mdash; <code><del>bool(</del>invoke(pred, invoke(proj, *i))<del>)</del></code> for the 
overloads with both parameters <code>proj</code> and <code>pred</code>.
</p></li>
</ol>
<p>
-2- <i>Effects</i>: Returns the number of iterators <code>i</code> in the range <code>[first, last)</code> 
for which <i>E</i> <del>holds</del> <ins>is <code>true</code></ins>.
</p>
</blockquote>

</li>

<li><p>Modify 26.6.12 <a href="https://timsong-cpp.github.io/cppwp/alg.mismatch">[alg.mismatch]</a> as indicated:</p>

<blockquote>
<p>
-2- Let <i>E</i> be:
</p>
<ol style="list-style-type: none">
<li><p>
(2.1) &mdash; <code>!(*(first1 + n) == *(first2 + n))</code> for the overloads with no 
parameter <code>pred</code>;
</p></li>
<li><p>
(2.2) &mdash; <code><ins>!</ins>pred(*(first1 + n), *(first2 + n)) <del>== false</del></code> 
for the overloads with a parameter <code>pred</code> and no parameter <code>proj1</code>;
</p></li>
<li><p>
(2.3) &mdash; <code>!invoke(pred, invoke(proj1, *(first1 + n)), invoke(proj2, *(first2 + n)))</code> 
for the overloads with both parameters <code>pred</code> and <code>proj1</code>.
</p></li>
</ol>
<p>
[&hellip;]
<p/>
-4- <i>Returns</i>: <code>{ first1 + n, first2 + n }</code>, where <code>n</code> is the smallest integer 
in [<code>0</code>, <i>N</i>) such that <i>E</i> <del>holds</del> <ins>is <code>true</code></ins>,
or <i>N</i> if no such integer exists.
</p>
</blockquote>

</li>

<li><p>Modify 26.6.15 <a href="https://timsong-cpp.github.io/cppwp/alg.search">[alg.search]</a> as indicated:</p>

<blockquote>
<p>
-1- <i>Returns</i>: The first iterator <code>i</code> in the range [<code>first1</code>,
<code>last1 - (last2-first2)</code>) such that for every non-negative integer <code>n</code> 
less than <code>last2 - first2</code> the following corresponding conditions hold:
<code>*(i + n) == *(first2 + n)</code> <ins>is <code>true</code></ins>, 
<code>pred(*(i + n), *(first2 + n)) <del>!= false</del></code> <ins>is <code>true</code></ins>.
Returns <code>first1</code> if [<code>first2</code>, <code>last2</code>) is empty, otherwise 
returns <code>last1</code> if no such iterator is found.
</p>
[&hellip;]
<p>
-6- Let <i>E</i> be <code>pred(*(i + n), value) <del>!= false</del></code> for the overloads with 
a parameter <code>pred</code>, and <code>*(i + n) == value</code> otherwise.
<p/>
-7- <i>Returns</i>: The first iterator <code>i</code> in the range <code>[first, last - count)</code> 
such that for every non-negative integer <code>n</code> less than <code>count</code> the condition <i>E</i> 
is <code>true</code>. Returns <code>last</code> if no such iterator is found.
</p>
</blockquote>

</li>

<li><p>Modify 26.8.1 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting.general">[alg.sorting.general]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording below does not require extra "is <code>true</code>" added to
the adjusted expressions. This is comparable to the <i>E</i> cases above, since
26.8.1 <a href="https://timsong-cpp.github.io/cppwp/alg.sorting.general">[alg.sorting.general]</a> p2 already points out:
</p>
<blockquote><p>
The return value of the function call operation applied to an object of type <code>Compare</code>,
when converted to <code>bool</code>, yields <code>true</code> if the first argument of the call is 
less than the second, and <code>false</code> otherwise.
</p></blockquote>
<p>
]
</p>
</blockquote>

<blockquote>
<p>
-3- For all algorithms that take <code>Compare</code>, there is a version that uses 
<code>operator&lt;</code> instead. That is, <code>comp(*i, *j) <del>!= false</del></code> 
defaults to <code>*i &lt; *j <del>!= false</del></code>. For algorithms other than those 
described in 26.8.4 <a href="https://timsong-cpp.github.io/cppwp/alg.binary.search">[alg.binary.search]</a>, <code>comp</code> shall induce a strict 
weak ordering on the values.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4128"><a href="4128">4128</a>. Allocator requirements should not allow rebinding conversions to be explicit</h3>
<p><b>Section:</b> 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-08-02 <b>Last modified:</b> 2024-08-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements.general">active issues</a> in [allocator.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements.general">issues</a> in [allocator.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <i>Cpp17Allocator</i> requirements require a non-explicit copy constructor,
but do not require a non-explicit converting constructor used for rebinding.
</p>
<p>
Since C++14 it has been clearly stated that
"An allocator type <code class='backtick'>X</code> shall satisfy the requirements of CopyConstructible".
That requires <code class='backtick'>X u = a;</code> to work as well as <code class='backtick'>X u(a);</code>,
but only when the type of <code class='backtick'>a</code> is <code class='backtick'>X</code>.
Constructing a rebound allocator from another specialization of the same
allocator class template is only required to work using direct-initialization,
<code class='backtick'>X u(b);</code>.
This means it's permitted to make the converting constructor explicit, so that <code class='backtick'>X u = b;</code> is ill-formed.
There seems to be no good reason to allow allocators to make that ill-formed.
</p>
<p>
In fact, there seems to be a good reason to <i>not</i> allow it.
The <code class='backtick'>uses_allocator</code> trait is defined in terms of <code class='backtick'>is_convertible</code>,
not <code class='backtick'>is_constructible</code>, which means that if <code>Alloc&lt;T&gt;</code>
has an explicit converting constructor,
then <code>uses_allocator_v&lt;X, Alloc&lt;T&gt;&gt;</code> will be false
for a type with <code>X::allocator_type = Alloc&lt;U&gt;</code>,
because you would need to explicitly convert an <code>Alloc&lt;T&gt;</code> to
<code>Alloc&lt;U&gt;</code> before passing it to <code>X</code>'s constructor.
</p>
<p>
That is at least consistent:
the trait gives the right answer even for allocators with explicit conversions.
It doesn't seem very useful though, and if users don't carefully check
<code class='backtick'>uses_allocator</code> with exactly the right types they might get errors unless
they carefully rebind and convert their allocators explicitly.
Or worse, if they rely on other library components to check <code class='backtick'>uses_allocator</code>,
they might silently get the wrong behaviour.
For example, trying to construct an <code>X</code> with an <code>Alloc&lt;T&gt;</code>
(e.g. via <code class='backtick'>make_obj_using_allocator</code>)
could silently fail to pass the allocator to the constructor
because there's no implicit conversion to <code class='backtick'>X::allocator_type</code>,
even though you're providing an allocator of the right "family"
and trying to use it. So a constructor without an allocator argument could be
chosen when you thought you were supplying an allocator for the object to use.
</p>
<p>
There seemed to be consensus when LWG discussed it that we should just 
require conversions to be implicit, so that allocators are not
silently ignored because they cannot be implicitly converted.
</p>
<p>
During the discussion it was noted that assigning allocators is only needed
when the propagation trait is true,
but such assignments are always done between objects of the same allocator type.
So the allocator requirements do not need to require converting assignments
to work.
</p>

<p><i>[2024-08-21; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Jonathan to add an Annex C entry about the change.
</p>



<p id="res-4128"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>
<ol>
<li><p>Modify 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> as indicated:</p>

<blockquote>
<pre>
X u(a);
X u = a;
</pre>
<p>-63-
<i>Postconditions</i>: <code class='backtick'>u == a</code> <ins>is <code class='backtick'>true</code>.</ins>
</p>
<p>-64-
<i>Throws</i>: Nothing.
</p>
<pre>
X u(b);
<ins>X u = b;</ins>
</pre>
<p>-65-
<i>Postconditions</i>: <code class='backtick'>Y(u) == b</code> and <code class='backtick'>u == X(b)</code> <ins>are both <code class='backtick'>true</code></ins>.
</p>
<p>-66-
<i>Throws</i>: Nothing.
</p>
<pre>
X u(std::move(a));
X u = std::move(a);
</pre>
<p>-67-
<i>Postconditions</i>: The value of <code class='backtick'>a</code> is unchanged and is equal to <code class='backtick'>u</code>.
</p>
<p>-68-
<i>Throws</i>: Nothing.
</p>
<pre>
X u(std::move(b));
<ins>X u = std::move(b);</ins>
</pre>
<p>-69-
<i>Postconditions</i>: <code class='backtick'>u</code> is equal to the prior value of <code class='backtick'>X(b)</code>.
</p>
<p>-70-
<i>Throws</i>: Nothing.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4129"><a href="4129">4129</a>. Possibly incorrect wording for data race avoidance</h3>
<p><b>Section:</b> 16.4.6.10 <a href="https://timsong-cpp.github.io/cppwp/res.on.data.races">[res.on.data.races]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-07-30 <b>Last modified:</b> 2024-08-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#res.on.data.races">active issues</a> in [res.on.data.races].</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.data.races">issues</a> in [res.on.data.races].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From PR <a href="https://github.com/cplusplus/draft/pull/6748">cplusplus/draft#6748</a> 
which was closed as non-editorial.
<p/>
Currently, 16.4.6.10 <a href="https://timsong-cpp.github.io/cppwp/res.on.data.races">[res.on.data.races]</a> is talking about arguments and "including <code>this</code>", 
but <code>this</code> is not a function argument. Moreover, it seems more appropriate to say that a function 
accesses some object via a parameter.
<p/>
It might need to be considered whether we should use the more general term "range" instead of "container", 
which will cover <code>std::span</code>, etc.
</p>


<p id="res-4129"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 16.4.6.10 <a href="https://timsong-cpp.github.io/cppwp/res.on.data.races">[res.on.data.races]</a> as indicated:</p>

<blockquote>
<p>
-2- A C++ standard library function shall not directly or indirectly access objects 
(6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>) accessible by threads other than the current thread 
unless the objects are accessed directly or indirectly via the function's 
<del>arguments</del><ins>parameters</ins>, including <del><code>this</code></del><ins>the 
object parameter (if any)</ins>.
<p/>
-3- A C++ standard library function shall not directly or indirectly modify objects 
(6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>) accessible by threads other than the current thread 
unless the objects are accessed directly or indirectly via the function's non-const
<del>arguments</del><ins>parameters</ins>, including <del><code>this</code></del><ins>the 
object parameter (if any)</ins>.
<p/>
[&hellip;]
<p/>
-5- A C++ standard library function shall not access objects indirectly accessible via 
its <del>arguments</del><ins>parameters</ins> or via elements of its container 
<del>arguments</del><ins>parameters</ins> except by invoking functions required by its 
specification on those container elements.
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4130"><a href="4130">4130</a>. Preconditions for <code>std::launder</code> might be overly strict</h3>
<p><b>Section:</b> 17.6.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-07-30 <b>Last modified:</b> 2024-11-19</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.launder">issues</a> in [ptr.launder].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From issue <a href="https://github.com/cplusplus/draft/issues/4553">cplusplus/draft#4553</a>
which is considered non-editorial.
<p/>
Currently, <code>std::launder</code> has a precondition that the pointed to object must be within
its lifetime. However, per the example added by <a href="https://wg21.link/P0593R6" title=" Implicit creation of objects for low-level object manipulation">P0593R6</a>, it's probably intended
that the result of <code>std::launder</code> should be allowed to point to an array element
subobject whose lifetime has not started yet.
</p>

<p><i>[2024-10-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Needs review by Core.
</p>

<p><i>[Wrocaw 2024-11-18; approved by Core]</i></p>




<p id="res-4130"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 17.6.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.launder">[ptr.launder]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt; [[nodiscard]] constexpr T* launder(T* p) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>!is_function_v&lt;T&gt; &amp;&amp; !is_void_v&lt;T&gt;</code> is <code>true</code>.
<p/>
-2- <i>Preconditions</i>: <code>p</code> represents the address <i>A</i> of a byte in memory.
An object <i>X</i> <del>that is within its lifetime (6.8.4 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>) and</del>
whose type is similar (7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to <code>T</code> is located at the address
<i>A</i><ins>, and is either within its lifetime (6.8.4 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>) or is an array
element subobject whose containing array object is within its lifetime</ins>. All bytes of storage
that would be reachable through (6.9.4 <a href="https://timsong-cpp.github.io/cppwp/basic.compound">[basic.compound]</a>) the result are reachable through
<code>p</code>.
<p/>
-3- <i>Returns</i>: A value of type <code>T*</code> that points to <i>X</i>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4131"><a href="4131">4131</a>. Including <code>&lt;optional&gt;</code> doesn't provide <code>std::begin/end</code></h3>
<p><b>Section:</b> 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-08-02 <b>Last modified:</b> 2024-08-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since <code>optional</code> now provides <code>begin/end</code> members, it is reasonable
to ensure the validity of <code>std::begin/end</code> after including <code>&lt;optional&gt;</code>.
</p>

<p><i>[2024-08-21; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"I would like to hear opinion of <a href="https://wg21.link/P3168" title=" Give std::optional Range Support">P3168</a> authors,
or have the change discussed as a part of <a href="https://wg21.link/P3016" title=" Resolve inconsistencies in begin/end for valarray and braced initializer lists">P3016</a>.
</p>



<p id="res-4131"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> as indicated:</p>

<blockquote>
<p>
-1- In addition to being available via inclusion of the <code>&lt;iterator&gt;</code> header, the function
templates in 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> are available when any of the following headers are included: 
<code>&lt;array&gt;</code> (23.3.2 <a href="https://timsong-cpp.github.io/cppwp/array.syn">[array.syn]</a>), 
<code>&lt;deque&gt;</code> (23.3.4 <a href="https://timsong-cpp.github.io/cppwp/deque.syn">[deque.syn]</a>), 
<code>&lt;flat_map&gt;</code> (23.6.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.syn">[flat.map.syn]</a>), 
<code>&lt;flat_set&gt;</code> (23.6.10 <a href="https://timsong-cpp.github.io/cppwp/flat.set.syn">[flat.set.syn]</a>), 
<code>&lt;forward_list&gt;</code> (23.3.6 <a href="https://timsong-cpp.github.io/cppwp/forward.list.syn">[forward.list.syn]</a>), 
<code>&lt;inplace_vector&gt;</code> (23.3.15 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.syn">[inplace.vector.syn]</a>),
<code>&lt;list&gt;</code> (23.3.10 <a href="https://timsong-cpp.github.io/cppwp/list.syn">[list.syn]</a>), 
<code>&lt;map&gt;</code> (23.4.2 <a href="https://timsong-cpp.github.io/cppwp/associative.map.syn">[associative.map.syn]</a>), 
<ins><code>&lt;optional&gt;</code> (22.5.2 <a href="https://timsong-cpp.github.io/cppwp/optional.syn">[optional.syn]</a>),</ins> 
<code>&lt;regex&gt;</code> (28.6.3 <a href="https://timsong-cpp.github.io/cppwp/re.syn">[re.syn]</a>), 
<code>&lt;set&gt;</code> (23.4.5 <a href="https://timsong-cpp.github.io/cppwp/associative.set.syn">[associative.set.syn]</a>), 
<code>&lt;span&gt;</code> (23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a>), 
<code>&lt;string&gt;</code> (27.4.2 <a href="https://timsong-cpp.github.io/cppwp/string.syn">[string.syn]</a>), 
<code>&lt;string_view&gt;</code> (27.3.2 <a href="https://timsong-cpp.github.io/cppwp/string.view.synop">[string.view.synop]</a>), 
<code>&lt;unordered_map&gt;</code> (23.5.2 <a href="https://timsong-cpp.github.io/cppwp/unord.map.syn">[unord.map.syn]</a>), 
<code>&lt;unordered_set&gt;</code> (23.5.5 <a href="https://timsong-cpp.github.io/cppwp/unord.set.syn">[unord.set.syn]</a>), 
and <code>&lt;vector&gt;</code> (23.3.12 <a href="https://timsong-cpp.github.io/cppwp/vector.syn">[vector.syn]</a>).
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4132"><a href="4132">4132</a>. <i>Throws</i> specifications need to include <code><i>boolean-testable</i></code> operations</h3>
<p><b>Section:</b> 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a>, 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a>, 23.3.7.6 <a href="https://timsong-cpp.github.io/cppwp/forward.list.ops">[forward.list.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2024-08-03 <b>Last modified:</b> 2024-10-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts.general">active issues</a> in [associative.reqmts.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts.general">issues</a> in [associative.reqmts.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard provides various <i>Throws</i>: elements whose specification refers to boolean-like 
expressions, for example 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> says:
</p>
<blockquote><p>
-17- <i>Throws</i>: Nothing unless an exception is thrown by <code>*i == value</code> or
<code>pred(*i) != false</code>.
</p></blockquote>
<p>
The expressions <code>*i == value</code> (by [tab:cpp17.equalitycomparable]) and <code>pred(*i)</code> 
(by 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>) both require to have a type that models 
<code><i>boolean-testable</i></code>, so their actual evaluation potentially requires an additional 
conversion to <code>bool</code> (The part "<code>!= false</code>" was not guaranteed to realize that as 
pointed out by LWG <a href="4127" title="The Standard Library should not use predicates of the form pred(*i) != false (Status: New)">4127</a> and will therefore be removed by that issue).
<p/>
The <code><i>boolean-testable</i></code> requirements (18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) doesn't 
say anything about potential exceptions thrown by this conversion, so we must assume that this 
conversion allows an exception to be thrown.
<p/>
An additional problem arises by the fact that the <code><i>boolean-testable</i></code> requirements
do not require that the implicit and explicit conversion to <code>bool</code> have to behave 
consistently in regard to exceptions. 18.4.4 <a href="https://timsong-cpp.github.io/cppwp/concept.convertible">[concept.convertible]</a> only says 
that "The implicit and explicit conversions are required to produce equal results". But
since we don't want to restrict implementations to a specific <code>bool</code> conversion,
the <i>Throws</i> wording should include it in a manner that applies to any form.
<p/>
Besides the obviously necessary conversion to <code>bool</code> we should not restrict 
implementations in regard to the potential usage of other <code><i>boolean-testable</i></code> 
operations, e.g. negation, which could potentially also throw an exception.
<p/>
Therefore the wording for the affected <i>Throws</i>: elements somehow needs to mention 
<code><i>boolean-testable</i></code> operations to cover the effective operation that is 
involved here without actually restricting existing implementations unnecessarily.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a> as indicated:</p>

<blockquote>
<pre>
a.merge(a2)
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-116- <i>Throws</i>: Nothing unless the <ins>evaluation of the</ins> comparison object 
<ins>including every selected <code><i>boolean-testable</i></code> (18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) 
operation</ins> throws.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.7.6 <a href="https://timsong-cpp.github.io/cppwp/forward.list.ops">[forward.list.ops]</a> as indicated:</p>

<blockquote>
<pre>
size_type remove(const T&amp; value);
template&lt;class Predicate&gt; size_type remove_if(Predicate pred);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Throws</i>: Nothing unless an exception is thrown by the equality comparison or the 
predicate <ins>evaluation including every selected <code><i>boolean-testable</i></code> 
(18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) operation</ins>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
size_type unique();
template&lt;class BinaryPredicate&gt; size_type unique(BinaryPredicate binary_pred);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-22- <i>Throws</i>: Nothing unless an exception is thrown by the predicate 
<ins>evaluation including every selected <code><i>boolean-testable</i></code> 
(18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) operation</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The adjustment of p17 is presented as if issue LWG <a href="4127" title="The Standard Library should not use predicates of the form pred(*i) != false (Status: New)">4127</a> 
proposed wording has already been applied]
</p>
</blockquote>

<blockquote>
<pre>
size_type remove(const T&amp; value);
template&lt;class Predicate&gt; size_type remove_if(Predicate pred);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-17- <i>Throws</i>: Nothing unless an exception is thrown by <code>*i == value</code> or
<code>pred(*i)</code> <ins>including every selected <code><i>boolean-testable</i></code> 
(18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) operation</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
size_type unique();
template&lt;class BinaryPredicate&gt; size_type unique(BinaryPredicate binary_pred);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-24- <i>Throws</i>: Nothing unless an exception is thrown by the predicate 
<ins>evaluation including every selected <code><i>boolean-testable</i></code> 
(18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) operation</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2024-09-07; Daniel comments and improves wording]</i></p>

<p>
During LWG reflector discussion it has been proposed to add similar wording to the 
throwing prohibition in <i>Cpp17NullablePointer</i> and <code><i>nothrow-sentinel-for</i></code>, too.
Furthermore, the existing wording changes are becoming now more harmonized in their
stylistic forms.
</p>

<p><i>[2024-10-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4132"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 16.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/nullablepointer.requirements">[nullablepointer.requirements]</a> as indicated:</p>

<blockquote>
<p>
-4- No operation which is part of the <i>Cpp17NullablePointer</i> requirements<ins>, including each 
of its <code><i>boolean-testable</i></code> (18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) operations,</ins> 
shall exit via an exception.
</p>
</blockquote>
</li>

<li><p>Modify 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a> as indicated:</p>

<blockquote>
<pre>
a.merge(a2)
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-116- <i>Throws</i>: Nothing unless <ins>an exception is thrown by evaluation of</ins> the comparison 
object<ins>, including any selected <code><i>boolean-testable</i></code> (18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) 
operations</ins><del>throws</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.7.6 <a href="https://timsong-cpp.github.io/cppwp/forward.list.ops">[forward.list.ops]</a> as indicated:</p>

<blockquote>
<pre>
size_type remove(const T&amp; value);
template&lt;class Predicate&gt; size_type remove_if(Predicate pred);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Throws</i>: Nothing unless an exception is thrown by the equality comparison 
<ins>(for <code>remove()</code>)</ins> or the predicate <ins>(for <code>remove_if()</code>), 
including any selected <code><i>boolean-testable</i></code> (18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) 
operations</ins>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
size_type unique();
template&lt;class BinaryPredicate&gt; size_type unique(BinaryPredicate binary_pred);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-22- <i>Throws</i>: Nothing unless an exception is thrown by <ins>evaluation of</ins> 
the predicate<ins>, including any selected <code><i>boolean-testable</i></code> 
(18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) operations</ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.11.5 <a href="https://timsong-cpp.github.io/cppwp/list.ops">[list.ops]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The adjustment of p17 is presented as if issue LWG <a href="4127" title="The Standard Library should not use predicates of the form pred(*i) != false (Status: New)">4127</a> 
proposed wording has already been applied]
</p>
</blockquote>

<blockquote>
<pre>
size_type remove(const T&amp; value);
template&lt;class Predicate&gt; size_type remove_if(Predicate pred);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-17- <i>Throws</i>: Nothing unless an exception is thrown by <del><code>*i == value</code> or
<code>pred(*i)</code></del><ins>the equality comparison (for <code>remove()</code>) or evaluation 
of the predicate (for <code>remove_if()</code>), including any selected <code><i>boolean-testable</i></code> 
(18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) operations</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
size_type unique();
template&lt;class BinaryPredicate&gt; size_type unique(BinaryPredicate binary_pred);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-24- <i>Throws</i>: Nothing unless an exception is thrown by <ins>evaluation of</ins> the 
predicate<ins>, including any selected <code><i>boolean-testable</i></code> 
(18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) operations</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.11.2 <a href="https://timsong-cpp.github.io/cppwp/special.mem.concepts">[special.mem.concepts]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class S, class I&gt;
concept <i>nothrow-sentinel-for</i> = sentinel_for&lt;S, I&gt;; // <i>exposition only</i>
</pre>
<blockquote>
<p>
-4- Types <code>S</code> and <code>I</code> model <code><i>nothrow-sentinel-for</i></code> only if no exceptions 
are thrown from copy construction, move construction, copy assignment, move assignment, or comparisons 
<ins>, including each of its <code><i>boolean-testable</i></code> (18.5.2 <a href="https://timsong-cpp.github.io/cppwp/concept.booleantestable">[concept.booleantestable]</a>) 
operations,</ins> between valid values of type <code>I</code> and <code>S</code>.
<p/>
-5- [<i>Note 2</i>: This concept allows some <code>sentinel_for</code> (24.3.4.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.sentinel">[iterator.concept.sentinel]</a>) 
operations to throw exceptions. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4133"><a href="4133">4133</a>. <code><i>awaitable-receiver</i></code>'s members are potentially throwing</h3>
<p><b>Section:</b> 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2024-07-30 <b>Last modified:</b> 2024-08-21</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.as.awaitable">active issues</a> in [exec.as.awaitable].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.as.awaitable">issues</a> in [exec.as.awaitable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code><i>awaitable-receiver</i></code> in 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a>/p4 
as of <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a> is not taking into consideration the fact that the <code>resume()</code> 
and <code>promise()</code> member functions on <code>coroutine_handle&lt;P&gt;</code> are not marked <code>noexcept</code>. 
<code><i>awaitable-receiver</i></code>'s member functions must all be <code>noexcept</code>, but they are 
specified as being "equivalent to" statement that call <code>resume()</code> and <code>promise()</code> 
outside of <code>try</code>/<code>catch</code> blocks.
</p>

<p><i>[2024-08-21; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>
<p>
<code class='backtick'>promise()</code> can probably be <i>Throws</i>: Nothing
(along with a bunch of other coroutine_handle members),
but <code class='backtick'>resume()</code> certainly can throw.
Also AS-EXCEPT-PTR can throw for the <code class='backtick'>error_code</code> case
(that might be worth a separate issue though).
</p>



<p id="res-4133"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4136"><a href="4136">4136</a>. Specify behavior of [linalg] Hermitian algorithms on diagonal with nonzero imaginary part</h3>
<p><b>Section:</b> 29.9.3 <a href="https://timsong-cpp.github.io/cppwp/linalg.general">[linalg.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mark Hoemmen <b>Opened:</b> 2024-08-09 <b>Last modified:</b> 2024-08-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Mathematically, the diagonal elements of a Hermitian matrix must all
have zero imaginary part (if they are complex numbers). 29.9.3 <a href="https://timsong-cpp.github.io/cppwp/linalg.general">[linalg.general]</a> 
paragraphs 3 and 4 govern the behavior of [linalg]
functions that operate on "symmetric," "Hermitian," or "triangular"
matrices. All such functions only access the specified triangle
(lower or upper) of the matrix. Whatever is in the other triangle of
the matrix doesn't matter; it's not even accessed. That gives
well-defined behavior for "symmetric" and "triangular" matrices.
However, both triangles include the diagonal. What should the
"Hermitian" functions do if they encounter a diagonal element with
nonzero imaginary part?
<p/>
The current wording says that both the operation performed and the
matrix itself are Hermitian, but does not clarify what happens if the
latter is not true. For example, 29.9.14.3 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas2.hemv">[linalg.algs.blas2.hemv]</a> 
says that <code>hermitian_matrix_vector_product</code> performs a 
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Hermitian matrix-vector product, taking into account the <code>Triangle</code> 
parameter that applies to the Hermitian matrix <code>A</code> (29.9.3 <a href="https://timsong-cpp.github.io/cppwp/linalg.general">[linalg.general]</a>).
</p>
</blockquote>
<p>
Language like this appears in the specifications of all the functions 
whose names start with <code>hermitian</code>. The implication is that if 
the diagonal has an element with nonzero imaginary part, then the matrix 
is not Hermitian and therefore a precondition of the function has been violated.  
The result is undefined behavior.
<p/>
We can get rid of this undefined behavior by defining what happens in
this case. It turns out that Chapter 2 of the BLAS Standard already
does this: It says that the Hermitian algorithms do not access the
imaginary parts of diagonal elements. The reference Fortran BLAS
implementations of <code>CHEMV</code> (single-precision Complex HErmitian
Matrix-Vector product) and <code>ZHEMV</code> (double-precision complex 
HErmitian Matrix-Vector product) follow the BLAS Standard. <code>CHEMV</code> 
uses <code>real(A(j,j))</code> and <code>ZHEMV</code> uses <code>dble(A(j,j))</code>, 
which means that the BLAS routines only access the real part of each diagonal 
element.
<p/>
The clear design intent of <a href="https://wg21.link/P1673R13" title=" A free function linear algebra interface based on the BLAS">P1673R13</a> was to imitate the 
behavior of the BLAS Standard and reference BLAS unless otherwise specified.  
Thus, we propose to specify this behavior in the wording; we do not think 
this requires LEWG re-review.
<p/>
In my view, it's fine to retain the existing wording like that in
29.9.14.3 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas2.hemv">[linalg.algs.blas2.hemv]</a>, that refers to a "Hermitian matrix".  
The matrix defined by the revised [linalg.general] instructions is
unambiguously a Hermitian matrix. Just like the "other triangle" of a
symmetric or triangular matrix does not affect the behavior of
[linalg] symmetric resp. triangular algorithms, the wording fix here
will ensure that any imaginary parts of diagonal elements will not
affect the behavior of [linalg] Hermitian algorithms.
</p>


<p id="res-4136"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>

<li><p>Modify 29.9.3 <a href="https://timsong-cpp.github.io/cppwp/linalg.general">[linalg.general]</a> as indicated:</p>

<blockquote>
<p>
-4- For any function <code>F</code> that takes a parameter named <code>t</code>, <code>t</code> 
applies to accesses done through the parameter preceding <code>t</code> in the parameter 
list of <code>F</code>. Let <code>m</code> be such an access-modified function parameter. 
<code>F</code> will only access the triangle of <code>m</code> specified by <code>t</code>. 
<ins>For accesses of diagonal elements <code>m[i, i]</code>, <code>F</code> will use the value
<code><i>real-if-needed</i>(m[i, i])</code> if the name of <code>F</code> starts with 
<code>hermitian</code>.</ins>
For accesses <code>m[i, j]</code> outside the triangle specified by <code>t</code>, <code>F</code> 
will use the value [&hellip;]
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4138"><a href="4138">4138</a>. <code>is_within_lifetime</code> should mandate <code>is_object</code></h3>
<p><b>Section:</b> 21.3.12 <a href="https://timsong-cpp.github.io/cppwp/meta.const.eval">[meta.const.eval]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Corentin <b>Opened:</b> 2024-08-09 <b>Last modified:</b> 2024-08-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><pre>
int f();
std::is_within_lifetime&lt;int()&gt;(f);
</pre></blockquote>
<p>
This is currently well-formed, and only fails when evaluated because 
<code>is_within_lifetime</code> is not constrained. However talking of lifetime 
of a non-object does not make sense, and the lack of constraint makes the 
implementation and use of that function and underlying built-in more 
convoluted than necessary.
</p>


<p id="res-4138"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>

<li><p>Modify 21.3.3 <a href="https://timsong-cpp.github.io/cppwp/meta.type.synop">[meta.type.synop]</a>, header <code>&lt;type_traits&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
// <i>21.3.12 <a href="https://timsong-cpp.github.io/cppwp/meta.const.eval">[meta.const.eval]</a>, constant evaluation context</i>
constexpr bool is_constant_evaluated() noexcept;
<ins>template&lt;class T&gt;</ins>
consteval bool is_within_lifetime(const <ins>T</ins><del>auto</del>*) noexcept;
</pre>
</blockquote>

</li>


<li><p>Modify 21.3.12 <a href="https://timsong-cpp.github.io/cppwp/meta.const.eval">[meta.const.eval]</a> as indicated:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
consteval bool is_within_lifetime(const <ins>T</ins><del>auto</del>* p) noexcept;
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates</i>: <code>is_object_v&lt;T&gt;</code> is <code>true</code>.</ins>
<p/>
-3- <i>Returns</i>: <code>true</code> if <code>p</code> is a pointer to an object that is 
within its lifetime (6.8.4 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>); otherwise, <code>false</code>.
<p/>
-4- <i>Remarks</i>: During the evaluation of an expression <code>E</code> as a core 
constant expression, a call to this function is ill-formed unless <code>p</code> 
points to an object that is usable in constant expressions or whose complete
object's lifetime began within <code>E</code>.
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4139"><a href="4139">4139</a>. &sect;[time.zone.leap] recursive constraint in <code>&lt;=&gt;</code></h3>
<p><b>Section:</b> 30.11.8 <a href="https://timsong-cpp.github.io/cppwp/time.zone.leap">[time.zone.leap]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Corentin <b>Opened:</b> 2024-08-18 <b>Last modified:</b> 2024-08-21</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.zone.leap">issues</a> in [time.zone.leap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider
</p>
<blockquote><pre>
decltype(std::declval&lt;std::chrono::leap_second&amp;>() &lt;=&gt; std::chrono::system_clock::now())
</pre></blockquote>
<p>
There is a <code>&lt;=&gt;</code> operator for leap second defined as
</p>
<blockquote><pre>
template&lt;class Duration&gt;
  requires three_way_comparable_with&lt;sys_seconds, sys_time&lt;Duration&gt;&gt;
  constexpr auto operator&lt;=&gt;(const leap_second&amp; x, const sys_time&lt;Duration&gt;&amp; y) noexcept;
</pre></blockquote>
<p>
In order to resolve this overload, we need to check the constraints.
<code>three_way_comparable_with</code> will end up checking that <code>sys_seconds{} &lt; sys_time&lt;Duration&gt;{}</code> 
is a valid expression. 
To do that, we run overload resolution, find a bunch of <code>operator&lt;=&gt;</code>, including the <code>leap_second</code> 
overload mentioned above.
We check its constraints... and we find ourselves doing that recursively.
<p/>
This problem currently doesn't manifest in production compilers because of a number of 
<a href="https://lists.isocpp.org/core/2023/03/14041.php">non-conforming behaviors of 
all implementations</a>, but surfaced while fixing some of these issues in clang.
<p/>
libstdc++ also does not suffer from this issue because <code>leap_seconds</code> comparisons operators are all hidden 
friends (in fact, libstdc++ define hidden friends comparison operators for most of the objects in chrono, which is 
nice!)
<p/>
Suggested resolution:
<p/>
Specify that <code>leap_seconds</code> operators are hidden friends. This would avoid the recursion, and would be easier 
on compilers.
</p>

<p><i>[2024-08-21; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Support for changing all relational ops for calendar types to hidden friends,
but only doing it for <code class='backtick'>leap_second</code> would be in scope for this issue.
</p>



<p id="res-4139"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4143"><a href="4143">4143</a>. <code>execution::set_value/set_error/set_stopped/start</code> should always return <code>void</code></h3>
<p><b>Section:</b> 33.7.2 <a href="https://timsong-cpp.github.io/cppwp/exec.set.value">[exec.set.value]</a>, 33.7.3 <a href="https://timsong-cpp.github.io/cppwp/exec.set.error">[exec.set.error]</a>, 33.7.4 <a href="https://timsong-cpp.github.io/cppwp/exec.set.stopped">[exec.set.stopped]</a>, 33.8.2 <a href="https://timsong-cpp.github.io/cppwp/exec.opstate.start">[exec.opstate.start]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-08-20 <b>Last modified:</b> 2024-09-18</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In editorial issue <a href="https://github.com/cplusplus/draft/issues/7222">#7222</a>,
it was observed that currently <code>execution::start</code> may have a non-<code>void</code>
return value, which possibly interacts with overloaded <code>operator,</code>. But the
return value of <code>execution::start</code> doesn't seem used anywhere.
<p/>
In addition to <code>execution::start</code>, the return values of <code>execution::set_value</code>,
<code>execution::set_error</code>, and <code>execution::set_stopped</code> also seem never used,
and the return type of these CPOs are always <code>void</code> in
<a href="https://github.com/NVIDIA/stdexec">stdexec</a>. Perhaps it would be better to
specified in the standard that these CPOs always return <code>void</code>.
</p>

<p><i>[2024-09-18; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
Should require the expressions to have type <code class='backtick'>void</code>,
rather than just discarding anything that is returned.
</p>



<p id="res-4143"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 33.7.2 <a href="https://timsong-cpp.github.io/cppwp/exec.set.value">[exec.set.value]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>set_value</code> is a value completion function (33.3 <a href="https://timsong-cpp.github.io/cppwp/exec.async.ops">[exec.async.ops]</a>).
Its associated completion tag is <code>set_value_t</code>. The expression <code>set_value(rcvr, vs...)</code>
for a subexpression <code>rcvr</code> and pack of subexpressions <code>vs</code> is ill-formed if
<code>rcvr</code> is an lvalue or an rvalue of const type. Otherwise, it is expression-equivalent to
<code><i>MANDATE-NOTHROW</i>(<ins>void(</ins>rcvr.set_value(vs...)<ins>)</ins>)</code>.
</p>
</blockquote>
</li>

<li><p>Modify 33.7.3 <a href="https://timsong-cpp.github.io/cppwp/exec.set.error">[exec.set.error]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>set_error</code> is an error completion function (33.3 <a href="https://timsong-cpp.github.io/cppwp/exec.async.ops">[exec.async.ops]</a>).
Its associated completion tag is <code>set_error_t</code>. The expression <code>set_error(rcvr, err)</code>
for some subexpressions <code>rcvr</code> and <code>err</code> is ill-formed if <code>rcvr</code> is an
lvalue or an rvalue of const type. Otherwise, it is expression-equivalent to
<code><i>MANDATE-NOTHROW</i>(<ins>void(</ins>rcvr.set_error(err)<ins>)</ins>)</code>.
</p>
</blockquote>
</li>

<li><p>Modify 33.7.4 <a href="https://timsong-cpp.github.io/cppwp/exec.set.stopped">[exec.set.stopped]</a> as indicated:</p>

<blockquote>
<p>
-1- <code>set_stopped</code> is a stopped completion function (33.3 <a href="https://timsong-cpp.github.io/cppwp/exec.async.ops">[exec.async.ops]</a>).
Its associated completion tag is <code>set_stopped_t</code>. The expression <code>set_stopped(rcvr)</code>
for a subexpression <code>rcvr</code> is ill-formed if <code>rcvr</code> is an lvalue or an rvalue of
const type. Otherwise, it is expression-equivalent to
<code><i>MANDATE-NOTHROW</i>(<ins>void(</ins>rcvr.set_stopped()<ins>)</ins>)</code>.
</p>
</blockquote>
</li>

<li><p>Modify 33.8.2 <a href="https://timsong-cpp.github.io/cppwp/exec.opstate.start">[exec.opstate.start]</a> as indicated:</p>

<blockquote>
<p>
-1- The name <code>start</code> denotes a customization point object that starts (33.3 <a href="https://timsong-cpp.github.io/cppwp/exec.async.ops">[exec.async.ops]</a>)
the asynchronous operation associated with the operation state object. For a subexpression <code>op</code>,
the expression <code>start(op)</code> is ill-formed if <code>op</code> is an rvalue. Otherwise, it is
expression-equivalent to <code><i>MANDATE-NOTHROW</i>(<ins>void(</ins>op.start()<ins>)</ins>)</code>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4145"><a href="4145">4145</a>. Unclear how [res.on.data.races] apply to templated functions</h3>
<p><b>Section:</b> 16.4.6.10 <a href="https://timsong-cpp.github.io/cppwp/res.on.data.races">[res.on.data.races]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2024-08-22 <b>Last modified:</b> 2024-10-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#res.on.data.races">active issues</a> in [res.on.data.races].</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.data.races">issues</a> in [res.on.data.races].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It's unclear how 16.4.6.10 <a href="https://timsong-cpp.github.io/cppwp/res.on.data.races">[res.on.data.races]</a> applies to templated functions that 
invoke user-supplied operations. In particular, there's no way to meet those requirements 
when a user-supplied operation can perform arbitrary operations.
<p/>
Perhaps we need to exclude the invocation of such operations from the scope of the requirements.
</p>

<p><i>[2024-10-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4145"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4146"><a href="4146">4146</a>. &sect;[format.formatter.spec]/3 unconditionally enables nonlocking for container adaptors</h3>
<p><b>Section:</b> 28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a>, 23.6.13 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.format">[container.adaptors.format]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2024-08-31 <b>Last modified:</b> 2024-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.formatter.spec">active issues</a> in [format.formatter.spec].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.formatter.spec">issues</a> in [format.formatter.spec].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a>/3 says that the library provides a specialization of 
<code class='backtick'>enable_nonlocking_formatter_optimization</code> with value <code class='backtick'>true</code> corresponding to each library-provided 
specialization of <code class='backtick'>formatter</code>, unless otherwise specified. Although it actually states 
"for each type <code class='backtick'>T</code>", the intent is that partial specializations are also provided corresponding to 
library-provided partial specializations of formatter.
<p/>
23.6.13 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.format">[container.adaptors.format]</a>/1 says the library provides a partial specialization of 
<code class='backtick'>formatter</code> for each of the container adaptor templates <code class='backtick'>priority_queue</code>, <code class='backtick'>queue</code>, and <code class='backtick'>stack</code>. 
Together with 28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a>/3, that means that e.g. 
<code>enable_nonlocking_formatter_optimization&lt;stack&lt;T&gt;&gt; == true</code>. Formatting a stack of 
that type will enable the nonlocking optimization even if 
<code>enable_nonlocking_formatter_optimization&lt;T&gt; == false</code>. To avoid this, the author of <code class='backtick'>T</code> 
must partially specialize <code class='backtick'>enable_nonlocking_formatter_optimization</code> to <code class='backtick'>false</code> for all container 
adaptors when they adapt a container of <code class='backtick'>T</code>.
<p/>
It is clearly not the design intent that programmers must explicitly opt out of the nonlocking 
optimization, so this is a defect that LWG should correct. Since <a href="https://wg21.link/P3235R3" title=" std::print more types faster with less memory">P3235R3</a> was applied 
as a Defect Report to C++23, the resolution of this issue should be so applied as well.
<p/>
<b>Suggested Resolution:</b>
<p/>
LEWG was reticent to apply the optimization to general ranges &mdash; ostensibly due to the possibility 
of deadlock in program-defined iterator operations &mdash; but apparently unconcerned about the iterators 
of program-defined containers nor the fancy pointers of program-defined allocators. It seems consistent 
with that design to ignore the "container" part of "container adaptors" and only pay attention to the 
elements that are going to be formatted. (I have prototyped this resolution on MSVCSTL, albeit slightly 
modified since neither MSVC nor Clang like this partial specialization form.)
</p>


<p id="res-4146"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 23.6.13 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.format">[container.adaptors.format]</a> as indicated:</p>

<blockquote>
<p>
-1- For each of <code>queue</code>, <code>priority_queue</code>, and <code>stack</code>, the library provides the 
following <del>formatter</del> specialization<ins>s</ins> where <code><i>adaptor-type</i></code> is the 
name of the template:
</p>
<blockquote><pre>
namespace std {
  template&lt;class charT, class T, formattable&lt;charT&gt; Container, class... U&gt;
  struct formatter&lt;<i>adaptor-type</i>&lt;T, Container, U...&gt;, charT&gt; {
    [&hellip;]
  };

  <ins>template&lt;class T, class Container, class... U&gt;</ins>
  <ins>constexpr bool enable_nonlocking_formatter_optimization&lt;<i>adaptor-type</i>&lt;T, Container, U...&gt;&gt; =</ins>
    <ins>enable_nonlocking_formatter_optimization&lt;T&gt;;</ins>
}
</pre></blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4149"><a href="4149">4149</a>. User defined macros without standard headers (294 redux)</h3>
<p><b>Section:</b> 16.4.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-09-05 <b>Last modified:</b> 2024-09-05</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#macro.names">active issues</a> in [macro.names].</p>
<p><b>View all other</b> <a href="lwg-index.html#macro.names">issues</a> in [macro.names].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="294" title="User defined macros and standard headers (Status: CD1)">294</a> changed 16.4.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> from:
<blockquote>
A translation unit that includes a header shall not contain any macros that
define names declared or defined in that header. Nor shall such a translation
unit define macros for names lexically identical to keywords.
</blockquote>
to:
<blockquote>
A translation unit that includes a standard library header shall not
<code class='backtick'>#define</code> or <code class='backtick'>#undef</code> names declared in any standard library header.
<p>
A translation unit shall not <code class='backtick'>#define</code> or <code class='backtick'>#undef</code> names lexically identical
to keywords.
</p>
</blockquote>
</p>
<p>
Note that the second sentence of the original says "such a translation unit"
when prohibiting things like <code class='backtick'>#define while</code>. This means the prohibition only
applies to "a translation unit that includes a header".
The replacement has the prohibition in a separate paragraph and does not
clearly say that it only applies when a header is included.
</p>
<p>
The issue discussion seems clear that the concern is about C++ headers
including other unspecified headers, which is allowed in C++ (though not in C).
There is no justification for broadening the second sentence to apply
unconditionally. Such a rule would belong in 15 <a href="https://timsong-cpp.github.io/cppwp/cpp">[cpp]</a> anyway,
not in library wording. That overreach doesn't appear to have been intended,
and we should clarify what the library is prohibiting.
</p>
<p>
It was pointed out on the reflector that it's not enough to only prohibit
defining such macros <i>after</i> including headers, because in some cases
that could still break the library header. For example, the library macro
<code class='backtick'>assert</code> typically uses <code class='backtick'>void</code> and so <code class='backtick'>#define void ...</code> would break <code class='backtick'>assert</code>
even if it happens after including <code>&lt;cassert&gt;</code>.
</p>


<p id="res-4149"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4986" title=" Working Draft, Programming Languages  C++">N4986</a>.
</p>

<ol>
<li><p>Modify 16.4.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/macro.names">[macro.names]</a> as indicated:</p>

<blockquote>
<p>
-1- A translation unit that includes a standard library header shall not
<code class='backtick'>#define</code> or <code class='backtick'>#undef</code> names declared in any standard library header.
</p>
<p>
-2- A translation unit
<ins>that includes a standard library header</ins>
shall not <code class='backtick'>#define</code> or <code class='backtick'>#undef</code> names lexically identical to keywords,
to the identifiers listed in Table 4,
or to the <i>attribute-tokens</i> described in 9.13 <a href="https://timsong-cpp.github.io/cppwp/dcl.attr">[dcl.attr]</a>,
except that the names <code class='backtick'>likely</code> and <code class='backtick'>unlikely</code> may be defined as
function-like macros (15.7 <a href="https://timsong-cpp.github.io/cppwp/cpp.replace">[cpp.replace]</a>).
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4151"><a href="4151">4151</a>. Precondition of <code>inplace_vector::swap</code></h3>
<p><b>Section:</b> 23.3.16.5 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.modifiers">[inplace.vector.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2024-09-07 <b>Last modified:</b> 2024-09-18</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Right now <code>inplace_vector::swap</code> has only a declaration in the class synopsis; it doesn't
specify what the behavior of <code>swap</code> for <code>inplace_vector</code>s actually is. So I think
the behavior ends up being governed by 23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a>, which are written from
the point of view of a container that manages an external heap allocation so that swapping
containers doesn't touch the elements at all, just changes their ownership.
<p/>
<code>inplace_vector::swap</code> actually works more like <code>array::swap</code>, which has its own
specification in 23.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/array.members">[array.members]</a>, where it is defined in terms of <code>std::swap_ranges</code>.
The <code>std::swap_ranges</code> algorithm (26.7.3 <a href="https://timsong-cpp.github.io/cppwp/alg.swap">[alg.swap]</a>) has a precondition! This
precondition is missing from <code>inplace_vector::swap</code>.
<p/>
That is, I think we currently have no wording that explains why
</p>
<blockquote><pre>
std::pmr::monotonic_buffer_resource mr1;
std::inplace_vector&lt;std::pmr::vector&lt;int&gt;, 2&gt; v1, v2;
v1.emplace_back(1, &amp;mr1);
v2.emplace_back(1);
v1.swap(v2);
</pre></blockquote>
<p>
is undefined behavior. The current spec seems to say this Just Works, even though it physically
cannot work because <code>v1[0]</code> and <code>v2[0]</code> don't dynamically meet the semantic requirements
of being "swappable with" each other, and <code>v1.swap(v2)</code> is necessarily going to try to swap them.
</p>

<p><i>[2024-09-18; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
The <i>Preconditions</i>: (but not the <i>Effects</i>:) would be changed
again if <a href="https://wg21.link/P3160R2" title=" An allocator-aware `inplace_vector`">P3160R2</a> is approved.
</p>



<p id="res-4151"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 23.3.16.5 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.modifiers">[inplace.vector.modifiers]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: It is suggested to add the new wording to the end of the existing
subclause]
</p>
</blockquote>

<blockquote><pre>
<ins>constexpr void swap(inplace_vector&amp; x) noexcept(N == 0 ||
  (is_nothrow_swappable_v&lt;T&gt; &amp;&amp; is_nothrow_move_constructible_v&lt;T&gt;));</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Preconditions</i>: Let <code><i>M</i></code> be <code>min(size(), x.size())</code>. For each
non-negative integer <code><i>n</i> &lt; <i>M</i></code>, <code>(*this)[<i>n</i>]</code> is swappable with
(16.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/swappable.requirements">[swappable.requirements]</a>) <code>x[<i>n</i>]</code>.</ins>
<p/>
<ins>-?- <i>Effects</i>: Exchanges the contents of <code>*this</code> and <code>x</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4152"><a href="4152">4152</a>. The primary template of <code>std::char_traits</code> is totally underspecified</h3>
<p><b>Section:</b> 27.2.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.require">[char.traits.require]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-09-08 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#char.traits.require">active issues</a> in [char.traits.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.require">issues</a> in [char.traits.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, only explicit specializations of <code>std::char_traits</code> are specified in the standard. 
Nothing is specified for the primary template except that it's not marked "not defined".
<p/>
Given some implementations provide the definition of the primary template (perhaps as an extension), 
it might be better to explicitly say that instantiation of the primary template has unspecified effect.
Also, it seems outdated to say "explicit specializations" as partial specializations are possible 
since C++20.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p>
27.2.1 <a href="https://timsong-cpp.github.io/cppwp/char.traits.general">[char.traits.general]</a>/1 says that the subclause
"defines a class template <code>char_traits&lt;charT&gt;</code>",
but we never provided a definition.
</p>
<p>
"Libc++ started to warn that the primary template is deprecated and will
be removed. The proposed resolution doesn't improve matters though."
</p>
<p>
"The definition should be cross-platform. Unspecified doesn't help."
</p>



<p id="res-4152"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 27.2.2 <a href="https://timsong-cpp.github.io/cppwp/char.traits.require">[char.traits.require]</a> as indicated:</p>

<blockquote>
<p>
-2- The class template
</p>
<blockquote><pre>
template&lt;class charT&gt; struct char_traits;
</pre></blockquote>
<p>
is provided in the header <code>&lt;string&gt;</code> as a basis for explicit <ins>and partial</ins> 
specializations. <ins>The effect of instantiating the primary template of <code>char_traits</code> is unspecified 
and possibly makes the program ill-formed.</ins>
</p>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4155"><a href="4155">4155</a>. <i>Cpp17NullablePointer</i> should require that some expression can be contextually converted to bool</h3>
<p><b>Section:</b> 16.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/nullablepointer.requirements">[nullablepointer.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-09-18 <b>Last modified:</b> 2024-10-02</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#nullablepointer.requirements">issues</a> in [nullablepointer.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, 16.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/nullablepointer.requirements">[nullablepointer.requirements]</a>/3 requires
"An object <code class='backtick'>p</code> of type <code class='backtick'>P</code> can be contextually converted to <code class='backtick'>bool</code>",
while the core language wording (7.3.1 <a href="https://timsong-cpp.github.io/cppwp/conv.general">[conv.general]</a>/4) only says
some expressions can be contextually converted to <code class='backtick'>bool</code>.
Moreover, the value category and cv-qualification are not mentioned,
presumably both non-const and const <code class='backtick'>P</code>,
together with all value categories are expected.
</p>

<p><i>[2024-10-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"This is an improvement, but judging from
<a href="https://github.com/microsoft/STL/issues/4964">microsoft/STL 4964</a>,
I think we actually want to define a "contextually-boolean-testable" for this."
</p>



<p id="res-4155"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 16.4.4.4 <a href="https://timsong-cpp.github.io/cppwp/nullablepointer.requirements">[nullablepointer.requirements]</a> as indicated:</p>
<blockquote>
<p>
<del>-3- An object <code class='backtick'>p</code> of type <code class='backtick'>P</code> can be contextually converted to <code class='backtick'>bool</code>.
The effect shall be as if <code class='backtick'>p != nullptr</code> had been evaluated in place of <code class='backtick'>p</code>.
</del>
</p>
</blockquote>
</li>
<li><p>Add a row to the bottom of [tab:cpp17.nullablepointer]:</p>
<blockquote>
<table style="border: 1px solid; border-spacing: 1.5em">
<thead style="text-align: center">
<tr><th>Expression</th><th>Return type</th><th>Operational semantics</th></tr>
</thead>
<tbody>
<tr> <td>...</td> <td>...</td> <td>...</td> </tr>
<tr>
<td><ins><code class='backtick'>a ? true : false</code></ins></td>
<td><ins><code class='backtick'>bool</code></ins></td>
<td><ins><code class='backtick'>a != np</code></ins></td>
</tr>
</tbody>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4156"><a href="4156">4156</a>. <code>error_category</code> messages have unspecified encoding</h3>
<p><b>Section:</b> 19.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.virtuals">[syserr.errcat.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#SG16">SG16</a>
 <b>Submitter:</b> Victor Zverovich <b>Opened:</b> 2024-09-18 <b>Last modified:</b> 2025-03-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG16">SG16</a> status.</p>
<p><b>Discussion:</b></p>
<p>
19.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.overview">[syserr.errcat.overview]</a> says:
<blockquote>
The class <code class='backtick'>error_category</code> serves as a base class for types used to identify
the source and encoding of a particular category of error code.
</blockquote>
</p>
<p>
However, this doesn't seem to be referring to a character encoding,
just something about how an error is encoded into an integer value.
The definition of <code class='backtick'>error_category::message</code>
(19.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.virtuals">[syserr.errcat.virtuals]</a> p5) just says:
<blockquote>
<pre><code>virtual string message(int ev) const = 0;</code></pre>
<p>
<i>Returns</i>:
A string that describes the error condition denoted by <code class='backtick'>ev</code>.
</p>
</blockquote>
This says nothing about character encoding either.
</p>
<p>
There is also implementation divergence:
some implementations use variants of <code class='backtick'>strerror</code> which return messages
in the current C locale encoding,
but at least one major implementation doesn't use the current C locale:
<a href="https://github.com/microsoft/STL/issues/4711">MSVC STL issue 4711</a>.
</p>
<p>
Using the current C locale is obviously problematic.
First, it is inconsistent with other C++ APIs that normally use C++ locales.
Second, because it is a global state, it may change
(possibly from another thread)
between the time the message is obtained and the time it needs to be consumed,
which may lead to mojibake.
At the very least there should be a mechanism that captures the encoding
information in a race-free manner and communicates it to the caller
if the locale encoding is used
although it is better not to use it in the first place.
</p>
<p>
This is somewhat related to LWG <a href="4087" title="Standard exception messages have unspecified encoding (Status: SG16)">4087</a>
but should probably be addressed first because it may affect
how some exceptions are defined.
</p>
<p>
The proposed resolution is similar to the one of LWG <a href="4087" title="Standard exception messages have unspecified encoding (Status: SG16)">4087</a>.
</p>

<p><i>[2024-09-18; Jonathan comments]</i></p>

<p>It might make sense to stop using the word "encoding" in
19.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.overview">[syserr.errcat.overview]</a>.
</p>


<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"Do we need to say something about <code class='backtick'>name()</code> too? Does this requirement apply
to user overrides? If it does, what's the consequence of a violation? UB?
This 'encoding for strings returned by the library' questions feels like it
should be comprehensively addressed in a paper rather than as a patchwork of
individual issues."
</p>

<p><i>[2025-03-12; update from SG16]</i></p>

<p>Would be resolved by <a href="https://wg21.link/P3395R1" title=" Fix encoding issues and add a formatter for std::error_code">P3395R1</a>.</p>



<p id="res-4156"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 19.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/syserr.errcat.virtuals">[syserr.errcat.virtuals]</a> as indicated:</p>
<blockquote>
<pre><code>virtual string message(int ev) const = 0;</code></pre>
<p>-5-
<i>Returns</i>:
A string <ins>in the ordinary literal encoding</ins>
that describes the error condition denoted by <code class='backtick'>ev</code>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4158"><a href="4158">4158</a>. <code>packaged_task::operator=</code> should abandon its shared state</h3>
<p><b>Section:</b> 32.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-09-19 <b>Last modified:</b> 2024-10-03</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code class='backtick'>packaged_task</code> move assignment operator is specified to release
the previous shared state. This means it releases ownership, but does
not make the shared state ready. Any future that shares ownership of the
shared state will never receive a result, because the provider is gone.
This means that any thread that waits on the future will block forever.
</p>
<p>
There is a note on <code class='backtick'>packaged_task::reset()</code> which claims that assignment
abandons the state, which is not supported by any normative wording:
</p>
<blockquote>
<pre>void reset();</pre>
<p>
-26- <i>Effects</i>:
As if <code class='backtick'>*this = packaged_task(std::move(f))</code>,
where <code class='backtick'>f</code> is the task stored in <code class='backtick'>*this</code>.
</p>
<p>
[<i>Note 2</i>:This constructs a new shared state for <code class='backtick'>*this</code>.
The old state is abandoned (32.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a>).
&mdash; <i>end note</i>]
</p>
</blockquote>
<p>
Presumably, the intended behaviour of assignment was to abandon the
shared state,
i.e.  make it ready with a <code class='backtick'>broken_promise</code> error, and then release it.
That is what the <code class='backtick'>std::promise</code> move assignment does
(see 32.10.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> p9).
Both libstdc++ and libc++ abandon the state, despite what the standard says.
</p>

<p><i>[2024-10-02; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>
<ol>
<li><p>Modify 32.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> as indicated:</p>
<blockquote>
<pre>
packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
</pre>
<p>-11- <i>Effects</i>:
<ol style="list-style-type: none">
<li>(11.1) &mdash;
<del>Releases</del> <ins>Abandons</ins>
any shared state (32.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a>);
</li>
<li>(11.2) &mdash;
calls <code class='backtick'>packaged_task(std::move(rhs)).swap(*this)</code>.
</li>
</ol>
</p>
<p><ins>-?- <i>Returns</i>: <code class='backtick'>*this</code>.</ins></p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2024-10-02; Jonathan provides improved wording]</i></p>

<p>
Following reflector discussion, remove the "Releases any shared state" text
completely.
The remaining effects imply that the state will be abandoned anyway.
This makes it safe against self-assignment.
</p>

<p><i>[2024-10-02; LWG telecon]</i></p>

<p>
Agreed to change <code class='backtick'>promise</code> the same way, which is safe for self-assignment
and matches what all three of libstdc++, libc++ and MSVC do today.
Ask SG1 to review.
</p>



<p id="res-4158"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>
<ol>

<li><p>Modify 32.10.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> as indicated:</p>
<blockquote>
<pre>
promise&amp; operator=(promise&amp;&amp; rhs) noexcept;
</pre>
<p>-9- <i>Effects</i>:
<del>
Abandons any shared state (32.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a>) and then as if
</del>
<ins>Equivalent to</ins>
<code class='backtick'>promise(std::move(rhs)).swap(*this)</code>.
</p>
<p>-10- <i>Returns</i>: <code class='backtick'>*this</code>.</p>
</blockquote>
</li>
<li><p>Modify 32.10.10.2 <a href="https://timsong-cpp.github.io/cppwp/futures.task.members">[futures.task.members]</a> as indicated:</p>
<blockquote>
<pre>
packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
</pre>
<p>-11- <i>Effects</i>:
<ol style="list-style-type: none">
<li><del>(11.1) &mdash;
Releases
any shared state (32.10.5 <a href="https://timsong-cpp.github.io/cppwp/futures.state">[futures.state]</a>);</del>
</li>
<li><del>(11.2) &mdash;
calls</del>
<ins>Equivalent to</ins>
<code class='backtick'>packaged_task(std::move(rhs)).swap(*this)</code>.
</li>
</ol>
</p>
<p><ins>-?- <i>Returns</i>: <code class='backtick'>*this</code>.</ins></p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4159"><a href="4159">4159</a>. Uses-allocator construction mechanisms should be opted out for node handles</h3>
<p><b>Section:</b> 23.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.node">[container.node]</a>, 20.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.trait">[allocator.uses.trait]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-09-21 <b>Last modified:</b> 2024-10-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, node handle types (23.2.5 <a href="https://timsong-cpp.github.io/cppwp/container.node">[container.node]</a>) have the member
<code>allocator_type</code> type alias, which makes <code>std::uses_allocator</code> report
<code>true</code> for them. However, they don't have allocator-extended constructors,
and it's unclear to me whether it's better to make them have such constructors.
<p/>
The status quo renders the following seemingly reasonable program ill-formed.
</p>
<blockquote><pre>
#include &lt;set&gt;
#include &lt;map&gt;

int main() {
  std::pmr::set&lt;int&gt; s{1};
  std::pmr::map&lt;int, decltype(s)::node_type&gt; m;
  m.emplace(1, s.extract(1));
}
</pre></blockquote>
<p>
Perhaps we should consistently treat node handles not uses-allocator-constructible.
</p>
<p><i>[2024-10-09; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"Strike the carve outs for program-defined specializations."
If it's broken for <code>uses_allocator&lt;NH, A&gt;</code> to be true
when <code class='backtick'>NH</code> is not a program-defined type, then we don't want to allow users
to make it true for a program-defined <code class='backtick'>A</code>, that would still be broken.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 23.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-4- If a user-defined specialization of <code>pair</code> exists for <code>pair&lt;const Key, T&gt;</code>
or <code>pair&lt;Key, T&gt;</code>, where <code>Key</code> is the container's <code>key_type</code> and
<code>T</code> is the container's <code>mapped_type</code>, the behavior of operations involving node handles
is undefined.
<p/>
<ins>-?- For each node handle type <code>NH</code> and any type <code>A</code>, if
<code>uses_allocator&lt;NH, A&gt;</code> is not a program-defined specialization, it meets the
<i>Cpp17BinaryTypeTrait</i> requirements (21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) and its base characteristic
is <code>false_type</code>.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2024-10-09; Adjust wording as requested in reflector poll]</i></p>





<p id="res-4159"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 23.2.5.1 <a href="https://timsong-cpp.github.io/cppwp/container.node.overview">[container.node.overview]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-4- If a user-defined specialization of <code>pair</code> exists for <code>pair&lt;const Key, T&gt;</code>
or <code>pair&lt;Key, T&gt;</code>, where <code>Key</code> is the container's <code>key_type</code> and
<code>T</code> is the container's <code>mapped_type</code>, the behavior of operations involving node handles
is undefined.
<p/>
<ins>-?- For each node handle type <code>NH</code> and any type <code>A</code>,
<code>uses_allocator&lt;NH, A&gt;</code> meets the
<i>Cpp17BinaryTypeTrait</i> requirements (21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>)
and its base characteristic is <code>false_type</code>.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4160"><a href="4160">4160</a>. <code>packaged_task</code> should reject rvalue reference return types</h3>
<p><b>Section:</b> 32.10.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.general">[futures.task.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2024-09-28 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>promise</code>, <code class='backtick'>future</code>, and <code class='backtick'>shared_future</code> all refuse rvalue reference types as template arguments 
(e.g., 32.10.6 <a href="https://timsong-cpp.github.io/cppwp/futures.promise">[futures.promise]</a> paragraphs 1 and 2), but <code>packaged_task&lt;meow&amp;&amp;()&gt;</code> 
violates no requirements. Its member <code class='backtick'>get_future</code> returns <code>future&lt;meow&amp;&amp;&gt;</code>, 
which is ill-formed, but the other member functions appear to be callable. Nonetheless, at least MSVCSTL, 
libc++, and libstdc++ all fail to compile simple uses of <code class='backtick'>packaged_task</code> with a function type that has 
an rvalue reference return type (see <a href="https://www.godbolt.org/z/5E18nn896">https://www.godbolt.org/z/5E18nn896</a>).
<p/>
Presumably the design intent &mdash; which the implementers all inferred &mdash; is that <code class='backtick'>packaged_task</code> 
should be ill-formed when <code class='backtick'>get_future</code> is not instantiable. The spec should say so explicitly rather than 
relying on the fact that one of the basis operations is unusable.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"Shouldn't it be ill-formed only if instantiated?"
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 32.10.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.general">[futures.task.general]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-2- When the <code>packaged_task</code> object is invoked, its stored task is invoked and the result 
(whether normal or exceptional) stored in the shared state. Any futures that share the shared state 
will then be able to access the stored result.
</p>
<blockquote>
<pre>
namespace std {
  template&lt;class&gt; class packaged_task; // <i>not defined</i>
  
  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
    [&hellip;]
  };
  
  template&lt;class R, class... ArgTypes&gt;
  packaged_task(R (*)(ArgTypes...)) -&gt; packaged_task&lt;R(ArgTypes...)&gt;;
  
  template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;
}
</pre>
</blockquote>
<p>
<ins>-?- The program is ill-formed if <code>R</code> is an rvalue reference type.</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2025-02-07; Jonathan provides improved wording]</i></p>




<p id="res-4160"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 32.10.10.1 <a href="https://timsong-cpp.github.io/cppwp/futures.task.general">[futures.task.general]</a> as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-2- When the <code>packaged_task</code> object is invoked, its stored task is invoked and the result 
(whether normal or exceptional) stored in the shared state. Any futures that share the shared state 
will then be able to access the stored result.
</p>
<blockquote>
<pre>
namespace std {
  template&lt;class&gt; class packaged_task; // <i>not defined</i>

  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
    [&hellip;]
  };

  template&lt;class R, class... ArgTypes&gt;
  packaged_task(R (*)(ArgTypes...)) -&gt; packaged_task&lt;R(ArgTypes...)&gt;;

  template&lt;class F&gt; packaged_task(F) -&gt; packaged_task&lt;<i>see below</i>&gt;;
}
</pre>
</blockquote>
<p>
<ins>-?-
If the definition of a specialization
<code>packaged_task&lt;R(Args...)&gt;</code> is instantiated for
an rvalue reference type <code class='backtick'>R</code>, the program is ill-formed.
</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4161"><a href="4161">4161</a>. Some free functions don't automatically work for program-defined <code>std::complex&lt;<i>NonFloatingPoint</i>&gt;</code></h3>
<p><b>Section:</b> 29.4 <a href="https://timsong-cpp.github.io/cppwp/complex.numbers">[complex.numbers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-09-29 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>std::complex&lt;<i>NonFloatingPoint</i>&gt;</code> is possibly a program-defined specialization and thus 
instantiation of such a specialization can have determined effect. However, it's improbable for implementations 
to ensure that some free functions, e.g. <code>abs</code>, <code>sin</code>, <code>exp</code>, work for such a specialization.
<p/>
Moreover, <a href="https://wg21.link/P2819R2" title=" Add tuple protocol to complex">P2819R2</a> made all <code>std::complex</code> specializations tuple-like types, despite that 
<code>std::get</code> overloads need to touch implementation details and thus don't work for program-defined specializations.
<p/>
It seems better to make only <code>complex&lt;floating-point&gt;</code> tuple-like types, and add <i>Constraints</i> 
to some free functions that can't be guaranteed to work to only accept cases where <code>T</code> is a <i>cv</i>-unqualified 
floating-point type. However, it's unclear to me how to handle cases where the implementation intentionally supports 
<code>complex&lt;X&gt;</code> (where <code>X</code> is not a program-defined type) as extension, and whether <i>Mandates</i> 
should be used.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"Program-defined specializations of <code class='backtick'>std::complex</code>
(i.e. explicit specializations and program-defined partial specializations)
seem unsupportably broken. We should say so explicitly until somebody writes
a paper to fix them."
</p>



<p id="res-4161"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4162"><a href="4162">4162</a>. Worst time complexity of non-parallel versions of <code>nth_element</code> is underspecified</h3>
<p><b>Section:</b> 26.8.3 <a href="https://timsong-cpp.github.io/cppwp/alg.nth.element">[alg.nth.element]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-09-29 <b>Last modified:</b> 2024-10-09</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.nth.element">issues</a> in [alg.nth.element].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, 26.8.3 <a href="https://timsong-cpp.github.io/cppwp/alg.nth.element">[alg.nth.element]</a> doesn't specify the worst time complexity for <code>nth_element</code>
without <code>ExecutionPolicy</code> parameter, which seemingly allows a complexity that is
<code>&#x1d4aa;(<i>N</i><sup>2</sup>)</code> or even worse. Presumably we should make the worst time complexity
consistent between parallel and non-parallel versions. For <code>sort</code>, LWG <a href="713" title="sort() complexity is too lax (Status: CD1)">713</a> already
strengthened complexity requirements.
</p>

<p><i>[2024-10-09; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"This seems to require changes to implementations for them to meet this
complexity guarantee."
</p>



<p id="res-4162"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>.
</p>

<ol>
<li><p>Modify 26.8.3 <a href="https://timsong-cpp.github.io/cppwp/alg.nth.element">[alg.nth.element]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class RandomAccessIterator&gt;
  constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                             RandomAccessIterator last);
template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
  void nth_element(ExecutionPolicy&amp;&amp; exec,
                   RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last);
template&lt;class RandomAccessIterator, class Compare&gt;
  constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                             RandomAccessIterator last, Compare comp);
template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
  void nth_element(ExecutionPolicy&amp;&amp; exec,
                   RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last, Compare comp);
template&lt;random_access_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,
         class Proj = identity&gt;
  requires sortable&lt;I, Comp, Proj&gt;
  constexpr I
    ranges::nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-5- <i>Complexity</i>: <del>For the overloads with no <code>ExecutionPolicy</code>, linear on average.
For the overloads with an <code>ExecutionPolicy</code>,</del> <code>&#x1d4aa;(<i>N</i>)</code> applications
of the predicate<del>,</del> and <code>&#x1d4aa;(<i>N</i> log <i>N</i>)</code> swaps, where <code><i>N</i> =
last - first</code>. <ins>For the overloads with no <code>ExecutionPolicy</code>, <code>&#x1d4aa;(<i>N</i>)</code>
on average.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4165"><a href="4165">4165</a>. Should swapping a built-in array or <code class='backtick'>std::array</code> with itself result in UB?</h3>
<p><b>Section:</b> 18.4.9 <a href="https://timsong-cpp.github.io/cppwp/concept.swappable">[concept.swappable]</a>, 22.2.2 <a href="https://timsong-cpp.github.io/cppwp/utility.swap">[utility.swap]</a>, 23.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/array.members">[array.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-10-13 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concept.swappable">active issues</a> in [concept.swappable].</p>
<p><b>View all other</b> <a href="lwg-index.html#concept.swappable">issues</a> in [concept.swappable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the <code class='backtick'>std::swap</code> overload for built-in arrays, the <code class='backtick'>swap</code> member function of 
<code class='backtick'>std::array</code>, the <code class='backtick'>std::swap</code> overload for <code class='backtick'>std::array</code>, and the expression-equivalent-to 
operation of <code class='backtick'>std::ranges::swap</code> for built-in arrays are specified to be equivalent to performing 
<code class='backtick'>std::(ranges::)swap_ranges</code>. As <code class='backtick'>swap_ranges</code> functions require that the swapped ranges shall 
not overlap (26.7.3 <a href="https://timsong-cpp.github.io/cppwp/alg.swap">[alg.swap]</a>/2), swapping a built-in array or a nonzero-length 
<code>std::array</code> with itself results in undefined behavior.
<p/>
It seems that no other swap operation in the standard library has precondition that both arguments 
don't refer to the same object. Should we make self-swapping of arrays well-defined? If so, 
perhaps we should change the semantics to plain loops that execute <code class='backtick'>swap</code> or <code class='backtick'>ranges::swap</code> on 
elements.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
Instead of a loop I'd prefer something like:
<blockquote>
<i>Effects</i>:
If <code class='backtick'>addressof(a) == addressof(b)</code>, no effects.
Otherwise, equivalent to <code class='backtick'>swap_ranges(begin(a), end(a), begin(b))</code>.
</blockquote>
</p>



<p id="res-4165"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4166"><a href="4166">4166</a>. <code class='backtick'>concat_view::end()</code> should be more constrained in order to support noncopyable iterators</h3>
<p><b>Section:</b> 25.7.18.2 <a href="https://timsong-cpp.github.io/cppwp/range.concat.view">[range.concat.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Yaito Kakeyama &amp; Nana Sakisaka <b>Opened:</b> 2024-10-13 <b>Last modified:</b> 2025-03-09</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.concat.view">active issues</a> in [range.concat.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.concat.view">issues</a> in [range.concat.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a case that <code class='backtick'>concat(a, b)</code> compiles but <code class='backtick'>concat(b, a)</code> does not.
</p>
<blockquote><pre>
auto range_copyable_it = std::vector&lt;int&gt;{1, 2, 3};

std::stringstream ss{"4 5 6"};
auto range_noncopyable_it = std::views::istream&lt;int&gt;(ss);

auto view1 = std::views::concat(range_copyable_it, range_noncopyable_it);
static_assert(std::ranges::range&lt;decltype(view1)&gt;);               // ok
assert(std::ranges::equal(view1, std::vector{1, 2, 3, 4, 5, 6})); // ok

auto view2 = std::views::concat(range_noncopyable_it, range_copyable_it);
// static_assert(std::ranges::range&lt;decltype(view2)&gt;);               // <span style="color:#C80000;font-weight:bolder">error</span>
// assert(std::ranges::equal(view2, std::vector{4, 5, 6, 1, 2, 3})); // <span style="color:#C80000;font-weight:bolder">error</span>
</pre></blockquote>
<p>
The reason behind this is as follows:
<p/>
Firstly, if all <code class='backtick'>Views...</code> satisfy the <code class='backtick'>std::ranges::range</code> concept, then <code class='backtick'>concat_view</code> should also satisfy it. 
However, if any of the <code class='backtick'>Views...</code> have a noncopyable iterator and the last view is <code class='backtick'>common_range</code>, the current 
<code class='backtick'>concat_view</code> fails to model a range.
<p/>
For <code class='backtick'>concat_view</code> to model a range, its sentinel must satisfy <code class='backtick'>std::semiregular</code>, but <code class='backtick'>concat_view::end()</code> 
returns a <code class='backtick'>concat_view::iterator</code>, which is noncopyable if the underlying iterator is noncopyable. This 
issue arises from the proposed implementation where the iterator uses <code class='backtick'>std::variant</code>. Although this 
specification is exposition-only, even if an alternative type-erasure mechanism is used, copying is still 
required if the user attempts to copy an iterator.
<p/>
To resolve the issue, <code class='backtick'>concat_view::end()</code> can and should fallback to returning <code class='backtick'>std::default_sentinel</code> 
in such cases.
<p/>
Unfortunately, as a side effect, this fix would prevent <code class='backtick'>concat_view</code> from being a <code class='backtick'>common_range</code> in certain 
situations. According to <a href="https://wg21.link/P2542R8" title=" views::concat">P2542R8</a>:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<code class='backtick'>concat_view</code> can be <code class='backtick'>common_range</code> if the last underlying range models <code class='backtick'>common_range</code>
</p>
</blockquote>
<p>
However, this is no longer true after applying our fix. That said, these two issues cannot be resolved 
simultaneously due to implementability. Therefore, we suggest applying our fix regardless and accepting 
that <code class='backtick'>concat_view</code> will not always inherit <code class='backtick'>common_range</code>. Note that the current draft (<a href="https://wg21.link/N4988" title=" Working Draft, Programming Languages  C++">N4988</a>) 
does not explicitly specify when <code class='backtick'>concat_view</code> can model <code class='backtick'>common_range</code>, so no addition is required for 
mentioning this point.
<p/>
A similar issue had been reported as <a href="3385" title="common_iterator is not sufficiently constrained for non-copyable iterators (Status: C++20)">3385</a>, which was eventually adopted as a C++20 DR. This 
DR indicates that LWG approved the decision to require <code class='backtick'>copyable</code> in order to model a <code class='backtick'>common_iterator</code>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages  C++">N4993</a>.
</p>

<ol>
<li><p>Modify 25.7.18.2 <a href="https://timsong-cpp.github.io/cppwp/range.concat.view">[range.concat.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto end() const
  requires (range&lt;const Views&gt; &amp;&amp; ...) &amp;&amp; <i>concatable</i>&lt;const Views...&gt;;
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Let <code><i>is-const</i></code> be <code class='backtick'>true</code> for the const-qualified overload, and <code class='backtick'>false</code> 
otherwise. Equivalent to:
</p>
<blockquote><pre>
constexpr auto N = sizeof...(Views);
if constexpr (<ins>(semiregular&lt;iterator_t&lt;<i>maybe-const</i>&lt;<i>is-const</i>, Views&gt;&gt;&gt; &amp;&amp; ...) &amp;&amp;</ins> 
              common_range&lt;<i>maybe-const</i>&lt;<i>is-const</i>, Views...[N - 1]&gt;&gt;) {
  return <i>iterator</i>&lt;<i>is-const</i>&gt;(this, in_place_index&lt;N - 1&gt;,
                            ranges::end(std::get&lt;N - 1&gt;(<i>views_</i>)));
} else {
  return default_sentinel;
}
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2025-03-05; Hewill Kang provides improved wording]</i></p>



<p id="res-4166"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 25.7.18.2 <a href="https://timsong-cpp.github.io/cppwp/range.concat.view">[range.concat.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto end() const
  requires (range&lt;const Views&gt; &amp;&amp; ...) &amp;&amp; <i>concatable</i>&lt;const Views...&gt;;
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Let <code><i>is-const</i></code> be <code class='backtick'>true</code> for the const-qualified overload, and <code class='backtick'>false</code> 
otherwise. Equivalent to:
</p>
<blockquote><pre>
constexpr auto N = sizeof...(Views);
if constexpr (<ins><i>all-forward</i>&lt;<i>is-const</i>, Views...&gt; &amp;&amp;</ins> 
              common_range&lt;<i>maybe-const</i>&lt;<i>is-const</i>, Views...[N - 1]&gt;&gt;) {
  return <i>iterator</i>&lt;<i>is-const</i>&gt;(this, in_place_index&lt;N - 1&gt;,
                            ranges::end(std::get&lt;N - 1&gt;(<i>views_</i>)));
} else {
  return default_sentinel;
}
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4167"><a href="4167">4167</a>. Use of "smaller" and "larger" in <code>min</code>,
<code>max</code>, and <code>minmax</code> is unclear</h3>
<p><b>Section:</b> 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2024-10-20 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://github.com/cplusplus/draft/issues/6747">Editorial issue #6747</a>
finds it inconsistent that
the wording for the <code>max</code>, <code>min</code>, and <code>minmax</code> algorithms
uses "larger" and "smaller"
- terms normally applied to physical quantities -
to refer to relationships between values
which we term "greater" and "lesser"
everywhere else in the Working Paper.
Using "greater" and "lesser" would make it no less (pun intended)
of a problem that we describe the ordering imposed by
an arbitrary binary predicate as if it is a less-than ordering.
</p><p>
For example, 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> para 2 says that
<code>std::ranges::min(13, 42, std::greater{})</code>
"<i>Returns</i>: The smaller value.
Returns the first argument when
the arguments are equivalent."
The smaller of 13 and 42 is 13, which is <em>not</em> what this call yields.
The reader is supposed to somehow know that "The smaller value" actually means
"the value we'd call the lesser if the arguments were numbers and
<code>comp</code> described a less-then ordering."
It would be clearer and more concise to simply say
it returns <code>b</code> if
<code>invoke(comp, invoke(proj, b), invoke(proj, a))</code> yields <code>true</code>
and <code>a</code> otherwise.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4167"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages  C++">N4993</a>.
</p>
<ol>
<li><p>Modify 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> as indicated:</p>
<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
template&lt;class T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr const T&amp; ranges::min(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>-?- Let <code>comp</code> be <code>less{}</code> and
<code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.</ins>
</p><p>
-1- <i>Preconditions</i>:
For the first form, <code>T</code> meets the
<code><i>Cpp17LessThanComparable</i></code> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-2- <del><i>Returns</i>: The smaller value.
Returns the first argument
when the arguments are equivalent.</del>
<ins><i>Effects</i>: Equivalent to:</ins>
</p>
<blockquote><pre><ins>
return invoke(comp, invoke(proj, b), invoke(proj, a)) ? b : a;
</ins></pre></blockquote>
<p><del>
-3- <i>Complexity</i>: Exactly one comparison
and two applications of the projection, if any.
</del></p><p>
-4- <i>Remarks</i>: An invocation may explicitly specify
an argument for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr T min(initializer_list&lt;T&gt; r);
template&lt;class T, class Compare&gt;
  constexpr T min(initializer_list&lt;T&gt; r, Compare comp);
template&lt;copyable T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr T ranges::min(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
  requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
  constexpr range_value_t&lt;R&gt;
    ranges::min(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>-?- Let <code>comp</code> be <code>less{}</code> and <code>proj</code> be
<code>identity{}</code> for the overloads with no parameters by those names.</ins>
</p><p>
-5- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>.
For the overloads in namespace <code>std</code>, <code>T</code> meets the
<i><code>Cpp17CopyConstructible</code></i> requirements
<ins>(Table [tab:cpp17.copyconstructible])</ins>.
For the first form, <code>T</code> meets the
<i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-6- <i>Returns</i>: <del>The smallest value in the input range.
Returns a copy of the leftmost element
when several elements are equivalent to the smallest.</del>
<ins>A copy of the leftmost element <code>e</code>
in the input range <code>r</code> for which
<code>bool(invoke(comp, invoke(proj, x), invoke(proj, e)))</code>
is <code>false</code> for all elements <code>x</code> in <code>r</code>.</ins>
</p><p>
-7- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons and
twice as many applications of the projection<del>, if any</del>.
</p><p>
-8- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
template&lt;class T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr const T&amp; ranges::max(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>
-?- Let <code>comp</code> be <code>less{}</code>
and <code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.
</ins>
</p><p>
-9- <i>Preconditions</i>: For the first form,
<code>T</code> meets the <i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-10- <del><i>Returns</i>: The larger value.
Returns the first argument when the arguments are equivalent.</del>
<ins><i>Effects</i>: Equivalent to:</ins>
<blockquote><pre><ins>
return invoke(comp, invoke(proj, a), invoke(proj, b)) ? b : a;
</ins></pre></blockquote>
</p><p>
<del>-11- <i>Complexity</i>: Exactly one comparison
and two applications of the projection, if any.</del>
</p><p>
-12- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr T max(initializer_list&lt;T&gt; r);
template&lt;class T, class Compare&gt;
  constexpr T max(initializer_list&lt;T&gt; r, Compare comp);
template&lt;copyable T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr T ranges::max(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
  requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
  constexpr range_value_t&lt;R&gt;
    ranges::max(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>
-?- Let <code>comp</code> be <code>less{}</code>
and <code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.
</ins>
</p><p>
-13- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>.
For the overloads in namespace <code>std</code>,
<code>T</code> meets the <i><code>Cpp17CopyConstructible</code></i> requirements
<ins>(Table [tab:cpp17.copyconstructible])</ins>.
For the first form, <code>T</code> meets
the <i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-14- <i>Returns</i>: <del>The largest value in the input range.
Returns a copy of the leftmost element
when several elements are equivalent to the largest.</del>
<ins>Returns a copy of the leftmost element <code>e</code>
in the input range <code>r</code> for which
<code>bool(invoke(comp, invoke(proj, e), invoke(proj, x)))</code>
is <code>false</code> for all elements <code>x</code> in <code>r</code>.</ins>
</p><p>
-15- <i>Complexity</i>: Exactly <code>ranges::distance(r) - 1</code> comparisons
and twice as many applications of the projection<del>, if any</del>.
</p><p>
-16- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
  constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
template&lt;class T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr ranges::minmax_result&lt;const T&amp;&gt;
    ranges::minmax(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>
-?- Let <code>comp</code> be <code>less{}</code>
and <code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.
</ins>
</p><p>
-17- <i>Preconditions</i>: For the first form,
<code>T</code> meets the <i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-18- <i>Returns</i>: <code>{b, a}</code>
if <del><code>b</code> is smaller than <code>a</code></del>
<ins>
<code>bool(invoke(comp, invoke(proj, b), invoke(proj, a)))</code> is <code>true</code>
</ins>,
and <code>{a, b}</code> otherwise.
</p><p>
-19- <i>Complexity</i>: Exactly one comparison
and two applications of the projection<del>, if any</del>.
</p><p>
-20- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.
</p>

<blockquote>
<pre><code>
template&lt;class T&gt;
  constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare&gt;
  constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);
template&lt;copyable T, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
  constexpr ranges::minmax_result&lt;T&gt;
    ranges::minmax(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
  requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;
  constexpr ranges::minmax_result&lt;range_value_t&lt;R&gt;&gt;
    ranges::minmax(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
</code></pre>
</blockquote>
<p>
<ins>
-?- Let <code>comp</code> be <code>less{}</code>
and <code>proj</code> be <code>identity{}</code>
for the overloads with no parameters by those names.
</ins>
</p><p>
-21- <i>Preconditions</i>: <code>ranges::distance(r) &gt; 0</code>.
For the overloads in namespace <code>std</code>,
<code>T</code> meets the <i><code>Cpp17CopyConstructible</code></i> requirements
<ins>(Table [tab:cpp17.copyconstructible])</ins>.
For the first form, <code>T</code> meets
the <i><code>Cpp17LessThanComparable</code></i> requirements
(Table [tab:cpp17.lessthancomparable]).
</p><p>
-22- <i>Returns</i>: Let <code>X</code> be the return type.
Returns <code>X{x, y}</code>,
where <code>x</code> is a copy of the leftmost element
<del>with the smallest value</del>
<ins>
in the input range <code>r</code> for which
<code>bool(invoke(comp, invoke(proj, e), invoke(proj, x)))</code>
is <code>false</code> for all elements <code>e</code> in <code>r</code>,
</ins>
and <code>y</code> <ins>is</ins> a copy of the rightmost element
<del>with the largest value in the input range</del>
<ins>
in <code>r</code> for which
<code>bool(invoke(comp, invoke(proj, y), invoke(proj, e)))</code>
is <code>false</code> for all elements <code>e</code> in <code>r</code>
</ins>
.
</p><p>
-23- <i>Complexity</i>: At most (3/2)<code>ranges::distance(r)</code>
<del>applications of the corresponding predicate</del><ins>comparisons</ins>
and twice as many applications of the projection<del>, if any</del>.
</p><p>
-24- <i>Remarks</i>: An invocation may explicitly specify an argument
for the template parameter <code>T</code>
of the overloads in namespace <code>std</code>.</p>
</li>
</ol>




<hr>
<h3 id="4168"><a href="4168">4168</a>. <code class='backtick'>std::start_lifetime_as</code> inadvertently has undefined behavior due to use of <code class='backtick'>std::bit_cast</code></h3>
<p><b>Section:</b> 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2024-10-23 <b>Last modified:</b> 2024-10-31</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#obj.lifetime">active issues</a> in [obj.lifetime].</p>
<p><b>View all other</b> <a href="lwg-index.html#obj.lifetime">issues</a> in [obj.lifetime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the motivating example from 
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2590r2.pdf">P2590R2: Explicit lifetime management</a>:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<pre>
struct X { int a, b; };

X* make_x() {
  X* p = std::start_lifetime_as&lt;X&gt;(myMalloc(sizeof(struct X));
  p-&gt;a = 1;
  p-&gt;b = 2;
  return p;
}
</pre>
</blockquote>
<p>
Assuming that <code class='backtick'>myMalloc</code> does not initialize the bytes of storage, this example has undefined behavior because 
the value of the resulting object of trivially copyable type <code class='backtick'>X</code> is determined as if by calling 
<code>std::bit_cast&lt;X&gt;(a)</code> for the implicitly-created object <code class='backtick'>a</code> of type <code class='backtick'>X</code> 
(20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> paragraph 3), whose object representation is filled with indeterminate bytes 
obtained from <code class='backtick'>myMalloc</code>. Such a call to <code class='backtick'>std::bit_cast</code> has undefined behavior because <code class='backtick'>std::bit_cast</code> 
does not tolerate the creation of an <code class='backtick'>int</code> where bits in the value representation are indeterminate 
(22.11.3 <a href="https://timsong-cpp.github.io/cppwp/bit.cast">[bit.cast]</a> paragraph 2), and such an <code class='backtick'>int</code> is the smallest enclosing object of some of the 
indeterminate bits.
</p>


<p id="res-4168"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages  C++">N4993</a>.
</p>

<ol>
<li><p>Modify 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The proposed resolution does not alter the behavior for erroneous bits. Therefore, 
a call to <code>std::start_lifetime_as</code> may have erroneous behavior when used on storage with indeterminate 
bits, despite not accessing that storage. An alternative resolution would be to produce objects whose value 
is erroneous.]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class T&gt;
  T* start_lifetime_as(void* p) noexcept;
template&lt;class T&gt;
  const T* start_lifetime_as(const void* p) noexcept;
template&lt;class T&gt;
  volatile T* start_lifetime_as(volatile void* p) noexcept;
template&lt;class T&gt;
  const volatile T* start_lifetime_as(const volatile void* p) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: [&hellip;]
<p/>
-2- <i>Preconditions</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: Implicitly creates objects (6.8.2 <a href="https://timsong-cpp.github.io/cppwp/intro.object">[intro.object]</a>) within the denoted region 
consisting of an object <code><i>a</i></code> of type <code class='backtick'>T</code> whose address is <code class='backtick'>p</code>, and objects nested within 
<code><i>a</i></code>, as follows: The object representation of <code><i>a</i></code> is the contents of the 
storage prior to the call to <code class='backtick'>start_lifetime_as</code>. The value of each created object <code><i>o</i></code> 
of trivially copyable type (6.9.1 <a href="https://timsong-cpp.github.io/cppwp/basic.types.general">[basic.types.general]</a>) <code class='backtick'>U</code> is determined in the same manner 
as for a call to <code>bit_cast&lt;U&gt;(E)</code> (22.11.3 <a href="https://timsong-cpp.github.io/cppwp/bit.cast">[bit.cast]</a>), where <code class='backtick'>E</code> is an lvalue of 
type <code class='backtick'>U</code> denoting <code><i>o</i></code>, except that the storage is not accessed <ins>and that 
for each indeterminate bit <code><i>b</i></code> in the value representation of the result, the smallest 
object containing that bit <code><i>b</i></code> has indeterminate value where the behavior would otherwise 
be undefined</ins>. The value of any other created object is unspecified.
</p>
</blockquote>
</blockquote>

</li>
</ol>




<hr>
<h3 id="4171"><a href="4171">4171</a>. P2609R3 breaks code that uses <code class='backtick'>views::zip</code> and <code>get&lt;T&gt;</code></h3>
<p><b>Section:</b> 24.3.6.3 <a href="https://timsong-cpp.github.io/cppwp/indirectcallable.indirectinvocable">[indirectcallable.indirectinvocable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2024-11-01 <b>Last modified:</b> 2024-11-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following use of <code class='backtick'>std::ranges::for_each</code> is valid before <a href="https://wg21.link/P2609R3" title=" Relaxing Ranges Just A Smidge">P2609R3</a> and invalid after that.
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;ranges&gt;
#include &lt;tuple&gt;
using namespace std::ranges;

void f() {
  int a[1];
  auto fun = [](auto t) {
    [[maybe_unused]] auto x = std::get&lt;int&amp;&gt;(t);
  };
  for_each(views::zip(a), fun);
}
</pre></blockquote>
<p>
The reason is that, <a href="https://wg21.link/P2609R3" title=" Relaxing Ranges Just A Smidge">P2609R3</a> requires <code class='backtick'>fun</code> to be <code class='backtick'>invocable</code> with <code>iter_value_t&lt;I&gt;&amp;</code>, 
which is <code>tuple&lt;int&gt;&amp;</code> when <code class='backtick'>I</code> is <code class='backtick'>zip_view</code>'s iterator, and <code>tuple&lt;int&gt;&amp;</code> 
doesn't support <code>std::get&lt;int&amp;&gt;(t)</code> because there isn't a <code>int&amp;</code> member.
<p/>
P2609R3 argues that "The actual consequence on user code seems small", but I believe that this code pattern is 
common enough, and it hurts if we cannot use <code>get&lt;int&amp;&gt;(t)</code> in the lambda body.
<p/>
Note that <code class='backtick'>for_each</code> doesn't actually call <code class='backtick'>fun</code> with <code>iter_value_t&lt;I&gt;</code>, as can be seen by adding 
an explicit return type to <code class='backtick'>fun</code>.
<p/>
Did LWG foresee this impact of <a href="https://wg21.link/P2609R3" title=" Relaxing Ranges Just A Smidge">P2609R3</a>? Could P2609R3 be reverted to unbreak this code pattern?
</p>


<p id="res-4171"><b>Proposed resolution:</b></p>




<hr>
<h3 id="4173"><a href="4173">4173</a>. Better term for "references, pointers and iterators to elements"</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-11-21 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Containers clause often uses "references, pointers, or iterators" which
is verbose, and needs to be said in full whenever talking about iterator
invalidation. It would be helpful to have a term of art that refers to all
of them, something like "element references" or to avoid any confusion with
actual references, "element indicators". Maybe "element handles" but that
could be confused with node handles for associative containers, and
(based on Wikipedia) has connotations of additional indirection, and something
which would <i>not</i> be invalidated when the underlying storage changes.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p>
"Maybe 'pointer to elements' or a longer phrase that includes the verb
'invalidates', which has special meaning in this section."
</p>
<p>
"Note that there are cases where we invalidate iterators but not pointers/references."
</p>
<p>
"Maybe define 'addresses' to mean 'pointers and references' since they're
always invalidated at the same time, but iterators are sometimes separate."
</p>
<p>
"Referential element accessors"
</p>
<p>
"Define 'pointer-invalidating' (for both pointers and references) and
'iterator-invalidating', and say that the former always implies the latter.
Maybe also introduce antonyms 'pointer-preserving' and 'iterator-preserving'."
</p>
<p>
"Should be defined in terms of affected elements, e.g.
'pointer-invalidating for any erased elements'."
</p>



<p id="res-4173"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4174"><a href="4174">4174</a>. How does [atomics.order] p3 apply when then modification is an initialization?</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2024-11-13 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider this example
</p>
<blockquote><pre>
std::atomic&lt;int&gt; v = 0;
// thread 1:
v.load(std::memory_order::seq_cst);
//thread 2:
v.store(1,std::memory_order::seq_cst);
</pre></blockquote>
<p>
If the load operation reads the value <code class='backtick'>0</code>, how are load and store operations ordered in the single total order? 
According to 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p3 (emphasize mine)
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
An atomic operation <i>A</i> on some atomic object <i>M</i> is <i>coherence-ordered before</i> 
another atomic operation <i>B</i> on <i>M</i> if
</p>
<ol style="list-style-type: none">
<li><p>[&hellip;]</p></li>
<li><p>(3.3) &mdash; <i>A</i> and <i>B</i> are not the same atomic read-modify-write operation, 
and there exists an <b>atomic modification <i>X</i></b> of <i>M</i> such that <i>A</i> reads the value stored by 
<i>X</i> and <i>X</i> precedes <i>B</i> in the modification order of <i>M</i>, or</p></li>
</ol>
</blockquote>
<p>
According to 32.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> p3 (emphasize mine)
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<i>Effects</i>: Initializes the object with the value <code>desired</code>. <b>Initialization is not an atomic operation</b> 
(6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>).
</blockquote>
<p>
So, how does 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p3 apply to this example such that the load operation precedes 
the store operation in the single total order <i>S</i>?
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll. Send to SG1.
</p>
<p>
LWG found the issue unclear and felt it was missing context that would
help understand it properly.
</p>
<p>
In
<a href="https://github.com/cplusplus/CWG/issues/641">cplusplus/CWG/issues/641</a>
the following example was given:
<blockquote>
<pre>
std::atomic&lt;bool&gt; a = false;
std::atomic&lt;bool&gt; b = false;
int v = 0;
// thread 1:
a.store(true, seq_cst);
if(b.load(seq_cst)== false){
   v = 1;  // #1
}
//thread 2:
b.store(true, seq_cst);
if(a.load(seq_cst)== false){
   v = 2; // #2
}
</pre>
To prove whether #1 and #2 can have data race, we should prove whether
it's possible that <code class='backtick'>a</code> and <code class='backtick'>b</code> simultaneously read <code class='backtick'>false</code>.
This proof equals whether there can be a valid single total order in this case.
To determine the order of <code class='backtick'>b.load</code> and <code class='backtick'>b.store</code> when <code class='backtick'>b.load</code> reads
the initialization value <code class='backtick'>false</code>, 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p3.3
should apply here.
However, the initialization is not an atomic modification
such that <code class='backtick'>X</code> cannot be that value.
</blockquote>
</p>

<p>
A possible fix is to amend 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a>/3.3 to say something
like this:
<blockquote>
(3.3) A and B are not the same atomic read-modify-write operation, and
<ins>either</ins>
<ol style="list-style-type: none">
<li><ins>(3.3.1)</ins>
there exists an atomic modification X of M such that A reads
the value stored by X and X precedes B in the modification order of M<ins>,
or</ins>
</li>
<li><ins>(3.3.2)
A reads the initial value of X and B modifies M</ins>, or
</li>
</ol>
</blockquote>
</p>



<p id="res-4174"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4176"><a href="4176">4176</a>. Refer back to container requirements when extending them</h3>
<p><b>Section:</b> 23 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2024-11-22 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We sometimes give detailed specifications of container members which add
additional specification to the common requirements in
23.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.requirements.general">[container.requirements.general]</a>, for example
23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a> defines <code class='backtick'>vector::erase</code> without actually
saying it erases any elements. The actual effects of <code class='backtick'>erase</code> are given in
23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>.
</p>
<p>
Authors of library wording often struggle with this non-local form of
specification, where we sometimes do spell out container member functions
in full, and sometimes rely on distant wording that applies to all containers.
It would be easier if <code class='backtick'>vector::erase</code> referred back to
23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-4176"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4177"><a href="4177">4177</a>. &sect;[atomics.order] p8 "circularly depend on their own computation" is unclear for loop</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2024-11-29 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p8 and p9 gave two paradigmatic examples of how "circularly depend on 
their own computation" means. However, consider this example:
</p>
<blockquote><pre>
std::atomic&lt;int&gt; x = 0, y = 2;

// thread 1:
if (y.load(relaxed) == 1) { // #1
  x.store(1, relaxed); // #2
}

//thread 2:
int pre = x.load(relaxed); // #3
while (pre != 0) {
  if (x.compare_exchange_strong(pre, pre + 1, acquire, relaxed)) {  // #4
    break;
  }
}
y.store(1, relaxed); // #5
</pre></blockquote>
<p>
when both <code class='backtick'>#1</code> and <code class='backtick'>#3</code> read <code class='backtick'>1</code>, is this a kind of OOTA? <code class='backtick'>#3</code> depends on <code class='backtick'>#2</code>, <code class='backtick'>#2</code> depends on <code class='backtick'>#1</code>, 
<code class='backtick'>#1</code> depends on <code class='backtick'>#5</code>, and the execution of <code class='backtick'>#5</code> depends on the exiting of the loop, which in turn initially 
depends on <code class='backtick'>pre</code>.
<p/>
The loop can never execute, exit after certain iterations, or be a long-time-running without exiting 
(i.e. <code class='backtick'>cmpxchg</code> keeps failing). So, it is unclear whether the execution of <code class='backtick'>#5</code> depends on the loop. 
However, it resembles the <code class='backtick'>spin-loop</code> (a failed <code class='backtick'>cmpxchg</code> is a pure load with a relaxed load), and the 
subsequent codes won't execute until the loop exits. So, the scenario of spin-lock seems to agree that 
the code after a loop depends on the loop(regardless of whether the loop can quickly exit or be a 
long-time-run loop).
<p/>
From this perspective, the <code class='backtick'>while</code> case is something like the <code class='backtick'>if</code>, for <code class='backtick'>if</code>, the condition is not 
<code class='backtick'>true</code>, and the code thereof cannot be executed. Similarly, a code after a while cannot be executed 
if the loop doesn't exit.
<p/>
<b>Suggested resolution:</b>
<p/>
 Either accurately specify what "circularly depend on their own computation" means, or add a paradigmatic 
 example regarding loop to indicate what it means.
</p>

<p><i>[Additional discussion from submitter:]</i></p>

<p>
I meant, that for a classic spin-lock, the code after the loop won't be
executed until the loop exits, and the operation is just a pure load with
relaxed memory order during the busy wait.
The loop for a spin-lock can have three possible cases:
<ol>
<li>CAS immediately succeeds </li>
<li>the loop exits after certain times of iterations</li>
<li>the loop cannot be exited(e.g. the lock is not released)</li>
</ol>
</p>
<p>
The compiler cannot assume which case the loop for the spin-lock is.
The code after the loop won't be reordered(during the busy waiting with
a relaxed memory order); otherwise, implementing the spin-lock would be
an issue based on the assumption that the codes after the loop wouldn't
be reached when the loop was busy waiting.
</p>
<p>
In this example, the loop has the same possible cases as the loop
in the spin-lock. So, the execution of <code class='backtick'>#5</code> seems to depend on the loop
and the loop depends on the <code class='backtick'>pre</code>. why I mention the spin-lock just is to
justify that the code after the loop won't be reordered in both compile-time
and runtime even though the condition of the loop is a pure load with a relaxed
memory order(otherwise, the foundation for which the busy-waiting of a
spink-lock is based on won't be true.). So, the loop has a similar effect
to the <code class='backtick'>if</code> statement on the control flow: the code in the block of
the <code class='backtick'>if</code> statement won't be executed if the condition is false, as well,
the code after the loop won't be executed if the loop hasn't yet exited.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll. Send to SG1.
</p>
<p>
"Should the example use <code class='backtick'>unsigned</code> so there's no chance of UB due to <code class='backtick'>int</code>
overflowing?"
</p>
<p>
"Contrived example showing well-known fact that OOTA prohibition is just
hand-waving. <a href="https://wg21.link/N3786" title=" Prohibiting &quot;out of thin air&quot; results in C++14">N3786</a> introduced the current wording and made
no secret of that. <a href="https://wg21.link/P1217" title=" Out-of-thin-air, revisited, again">P1217</a> explored the issue further,
as have other SG1 papers. Hard problems. Solutions welcome. Don't think this
is the place to focus however."
</p>



<p id="res-4177"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4180"><a href="4180">4180</a>. Inconsistent constraints on <code>flat_<i>foo</i>::emplace</code></h3>
<p><b>Section:</b> 23.6.12.5 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset.modifiers">[flat.multiset.modifiers]</a>, 23.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.modifiers">[flat.map.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2024-12-09 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern in 23 <a href="https://timsong-cpp.github.io/cppwp/containers">[containers]</a> is that <code class='backtick'>x.emplace(args...)</code> has a precondition 
(23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> p20, 23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a> p48) but no 
<i>Constraints</i> element. That is, <code class='backtick'>emplace</code> is not SFINAE-friendly. And it has only the one overload, 
so it doesn't need a constraint for purposes of overload resolution.
<p/>
No Constraints on <code class='backtick'>emplace</code>: <code class='backtick'>deque</code> (23.3.5.4 <a href="https://timsong-cpp.github.io/cppwp/deque.modifiers">[deque.modifiers]</a>), <code class='backtick'>list</code> (23.3.11.4 <a href="https://timsong-cpp.github.io/cppwp/list.modifiers">[list.modifiers]</a>), 
<code class='backtick'>vector</code> (23.3.13.5 <a href="https://timsong-cpp.github.io/cppwp/vector.modifiers">[vector.modifiers]</a>), <code class='backtick'>containers</code> (23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> p19), 
<code class='backtick'>associative containers</code> (23.2.7.1 <a href="https://timsong-cpp.github.io/cppwp/associative.reqmts.general">[associative.reqmts.general]</a> p47), 
<code class='backtick'>unordered containers</code> (23.2.8.1 <a href="https://timsong-cpp.github.io/cppwp/unord.req.general">[unord.req.general]</a> p78), <code class='backtick'>priority_queue</code> (23.6.4.4 <a href="https://timsong-cpp.github.io/cppwp/priqueue.members">[priqueue.members]</a> p5), 
<code class='backtick'>optional</code> (22.5.3.4 <a href="https://timsong-cpp.github.io/cppwp/optional.assign">[optional.assign]</a> p29).
<p/>
Constraints on <code class='backtick'>emplace</code>: <code class='backtick'>flat_map</code> (23.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.modifiers">[flat.map.modifiers]</a> p1), 
<code class='backtick'>flat_multiset</code> (23.6.12.5 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset.modifiers">[flat.multiset.modifiers]</a> p1), <code class='backtick'>any</code> (22.7.4.4 <a href="https://timsong-cpp.github.io/cppwp/any.modifiers">[any.modifiers]</a> p1), 
<code class='backtick'>expected</code> (22.8.6.4 <a href="https://timsong-cpp.github.io/cppwp/expected.object.assign">[expected.object.assign]</a> p16), <code class='backtick'>variant</code> (22.6.3.5 <a href="https://timsong-cpp.github.io/cppwp/variant.mod">[variant.mod]</a> p1).
<p/>
I believe a <i>Constraints</i> element was accidentally copy-pasted from the spec of <code>flat_map::insert(P&amp;&amp;)</code>
 &mdash; which does need the constraint because it's part of <code class='backtick'>insert</code>'s large overload set &mdash; to 
 <code class='backtick'>flat_map::emplace</code>, and then from there to <code class='backtick'>flat_multiset::emplace</code>. The constraint is already (correctly) absent 
 <code class='backtick'>from flat_set::emplace</code>.
<p/>
While we're touching this paragraph, also resolve the vague word "initializes" to "direct-non-list-initializes." 
Editorially, <code>pair&lt;&hellip;&gt;</code> is a verbose way to spell the <code class='backtick'>value_type</code> of a <code class='backtick'>flat_map</code>; we should 
be consistent and just say <code class='backtick'>value_type</code>.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
See reflector discussion for comments about proposed resolution.
</p>



<p id="res-4180"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4993" title=" Working Draft, Programming Languages  C++">N4993</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: 23.6.11.5 <a href="https://timsong-cpp.github.io/cppwp/flat.set.modifiers">[flat.set.modifiers]</a> is already OK as far as this issue is concerned: 
it has no wording for <code class='backtick'>emplace</code>.
<p/> 
[flat.multimap.modifiers] is already OK ditto: it does not exist. ]
</p>
</blockquote>

<ol>
<li><p>Modify 23.6.12.5 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... Args&gt; iterator emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i><ins>Mandates</ins><del>Constraints</del></i>: <code>is_constructible_v&lt;value_type, Args...&gt;</code> is <code>true</code>.
<p/>
-2- <i>Effects</i>: First, <ins>direct-non-list-</ins>initializes an object <code class='backtick'>t</code> of type <code class='backtick'>value_type</code> with 
<code>std::forward&lt;Args&gt;(args)...</code>, then inserts <code class='backtick'>t</code> as if by:
</p>
<blockquote><pre>
auto it = ranges::upper_bound(c, t, compare);
c.insert(it, std::move(t));
</pre></blockquote>
<p>
-3- <i>Returns</i>: An iterator that points to the inserted element.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.modifiers">[flat.map.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... Args&gt; pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i><ins>Mandates</ins><del>Constraints</del></i>: <code>is_constructible_v&lt;<ins>value_type</ins><del>pair&lt;key_type, mapped_type&gt;</del>, Args...&gt;</code> 
is <code>true</code>.
<p/>
-2- <i>Effects</i>: <ins>First, direct-non-list-i</ins><del>I</del>nitializes an object <code class='backtick'>t</code> of type 
<code><ins>value_type</ins><del>pair&lt;key_type, mapped_type&gt;</del></code> with <code>std::forward&lt;Args&gt;(args)...</code>; 
if the map already contains an element whose key is equivalent to <code class='backtick'>t.first</code>, <code class='backtick'>*this</code> is unchanged. Otherwise, equivalent to:
</p>
<blockquote><pre>
auto key_it = ranges::upper_bound(c.keys, t.first, compare);
auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);
c.keys.insert(key_it, std::move(t.first));
c.values.insert(value_it, std::move(t.second));
</pre></blockquote>
<p>
-3- <i>Returns</i>: The <code class='backtick'>bool</code> component of the returned pair is <code class='backtick'>true</code> if and only if the insertion took place, and
the iterator component of the pair points to the element with key equivalent to <code class='backtick'>t.first</code>.
</p>
</blockquote>
</blockquote>

</li>
</ol>





<hr>
<h3 id="4181"><a href="4181">4181</a>. Some ranges have negative <code class='backtick'>ssize</code></h3>
<p><b>Section:</b> 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a>, 25.3.11 <a href="https://timsong-cpp.github.io/cppwp/range.prim.ssize">[range.prim.ssize]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2024-12-13 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There exist range types <code class='backtick'>R</code> whose size is representable by neither <code class='backtick'>ptrdiff_t</code> nor 
<code><i>make-signed-like-t</i>&lt;ranges::range_size_t&lt;R&gt;&gt;</code>, specifically <code class='backtick'>views::iota(size_t(0), size_t(-1))</code>. 
It's unfortunate that <code class='backtick'>std::ssize</code> and <code class='backtick'>ranges::ssize</code> produce a negative size for such ranges even when their 
difference type is capable of representing their size (see <a href="https://www.godbolt.org/z/599z55Y4f">demo</a>). 
Perhaps the <code class='backtick'>ssize</code> overloads should return 
<code>static_cast&lt;common_type_t&lt;ptrdiff_t, iter_difference_t&lt;decltype(<i>meow</i>.begin())&gt;&gt;&gt;(<i>meow</i>.size())</code> 
instead when the argument <code><i>meow</i></code> models <code class='backtick'>range</code>?
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"The behaviour for Ranges regressed due to LWG <a href="3403" title="Domain of ranges::ssize(E) doesn't match ranges::size(E) (Status: C++23)">3403</a>.
It might have been a mistake to broaden the domain of <code class='backtick'>ranges::ssize</code> to match
that of <code class='backtick'>ranges::size</code>.  The latter includes some non-Range arguments to ease
the transition from <code class='backtick'>std::size</code>, but thjere was no existing body of pre-C++20
code calling <code class='backtick'>std::ssize</code> that needed a transition path."
</p>



<p id="res-4181"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4182"><a href="4182">4182</a>. Definition of <code class='backtick'>NULL</code> is too broad</h3>
<p><b>Section:</b> 17.2.3 <a href="https://timsong-cpp.github.io/cppwp/support.types.nullptr">[support.types.nullptr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Janet Cobb <b>Opened:</b> 2024-12-09 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
7.3.12 <a href="https://timsong-cpp.github.io/cppwp/conv.ptr">[conv.ptr]</a>/1 reads in part: "A <i>null pointer constant</i> is an integer literal (5.13.2 <a href="https://timsong-cpp.github.io/cppwp/lex.icon">[lex.icon]</a>) 
with value zero or a prvalue of type <code class='backtick'>std::nullptr_t</code>.".
<p/>
17.2.3 <a href="https://timsong-cpp.github.io/cppwp/support.types.nullptr">[support.types.nullptr]</a>/2 reads: "The macro <code class='backtick'>NULL</code> is an implementation-defined null pointer constant.".
<p/>
Together, these imply that <code class='backtick'>#define NULL (::std::unreachable(), nullptr)</code> is a conforming definition. The expression is 
a prvalue of type <code class='backtick'>std::nullptr_t</code>, so it is a null pointer constant. This makes it implementation-defined whether 
any program that evaluates <code class='backtick'>NULL</code> has undefined behavior.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>"I'd very much like to see <code class='backtick'>nullptr</code> added to the footnote."</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>


<ol>
<li><p>Modify 17.2.3 <a href="https://timsong-cpp.github.io/cppwp/support.types.nullptr">[support.types.nullptr]</a> as indicated:</p>

<blockquote>
<p>
-2- The macro <code class='backtick'>NULL</code> is an implementation-defined null pointer constant <ins>that is a literal 
(5.13.2 <a href="https://timsong-cpp.github.io/cppwp/lex.icon">[lex.icon]</a>, 5.13.8 <a href="https://timsong-cpp.github.io/cppwp/lex.nullptr">[lex.nullptr]</a>)</ins>.<sup>footnote 161</sup>
<p/>
<small>161) Possible definitions include <code class='backtick'>0</code> and <code class='backtick'>0L</code>, but not <code class='backtick'>(void*)0</code>.</small>
</p>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2025-02-07; Jonathan provides improved wording]</i></p>




<p id="res-4182"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 17.2.3 <a href="https://timsong-cpp.github.io/cppwp/support.types.nullptr">[support.types.nullptr]</a> as indicated:</p>

<blockquote>
<p>
-2- The macro <code class='backtick'>NULL</code> is an implementation-defined null pointer constant <ins>that is a literal 
(5.13.2 <a href="https://timsong-cpp.github.io/cppwp/lex.icon">[lex.icon]</a>, 5.13.8 <a href="https://timsong-cpp.github.io/cppwp/lex.nullptr">[lex.nullptr]</a>)</ins>.<sup>footnote 161</sup>
<p/>
<small>161) Possible definitions include <ins><code class='backtick'>nullptr</code>,</ins> <code class='backtick'>0</code> and <code class='backtick'>0L</code>,
but not <code class='backtick'>(void*)0</code>.</small>
</p>
</blockquote>

</li>

</ol>






<hr>
<h3 id="4183"><a href="4183">4183</a>. <code class='backtick'>subrange</code> should provide <code class='backtick'>data()</code></h3>
<p><b>Section:</b> 25.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.general">[range.subrange.general]</a>, 25.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.general">[range.subrange.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2024-12-16 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, only four view classes in <code>&lt;ranges&gt;</code> explicitly provide <code class='backtick'>data()</code> members.
</p>
<p>
Two of them are <code class='backtick'>empty_view</code> and <code class='backtick'>single_view</code>, because their <code class='backtick'>data()</code> is always valid
and can be marked <code class='backtick'>noexcept</code>.
</p>
<p>
The remaining two are <code class='backtick'>ref_view</code> and <code class='backtick'>owning_view</code> with constrained <code class='backtick'>data()</code>,
which is redundant since <code class='backtick'>data()</code> can always obtained from <code class='backtick'>view_interface</code>
when the underlying range is contiguous. I suspect this is because <code class='backtick'>ranges::data</code> 
is more efficient.
</p>
<p>
However, <code class='backtick'>subrange</code> does not have a <code class='backtick'>data()</code> member, which seems worth considering 
because this function can always be <code class='backtick'>noexcept</code> given that <code class='backtick'>to_address</code> is always <code class='backtick'>noexcept</code>.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>
<p>
Lots or NAD votes. "If we care about <code class='backtick'>data</code> being noexcept, we should add
conditional noexcept to <code class='backtick'>view_interface</code> overloads. Seems like design."
</p>
<p>
"I don't care about noexcept (impls can strengthen it if it matters),
but it's a good idea to avoid the extra iterator copy."
</p>



<p id="res-4183"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 25.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.general">[range.subrange.general]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S = I, subrange_kind K =
      sized_sentinel_for&lt;S, I&gt; ? subrange_kind::sized : subrange_kind::unsized&gt;
    requires (K == subrange_kind::sized || !sized_sentinel_for&lt;S, I&gt;)
  class subrange : public view_interface&lt;subrange&lt;I, S, K&gt;&gt; {
    [&hellip;]
    constexpr bool empty() const;
    constexpr <i>make-unsigned-like-t</i>&lt;iter_difference_t&lt;I&gt;&gt; size() const
      requires (K == subrange_kind::sized);
    <ins>constexpr auto data() const noexcept requires contiguous_iterator&lt;I&gt;;</ins>
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.access">[range.subrange.access]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>make-unsigned-like-t</i>&lt;iter_difference_t&lt;I&gt;&gt; size() const
    requires (K == subrange_kind::sized);
</pre>
<blockquote>
<p>
-5- <i>Effects</i>:
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
<ins>constexpr auto data() const noexcept requires contiguous_iterator&lt;I&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return to_address(<i>begin_</i>);</code></ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4185"><a href="4185">4185</a>. Ill-formed, no diagnostic required on runtime behavior</h3>
<p><b>Section:</b> 29.9.7 <a href="https://timsong-cpp.github.io/cppwp/linalg.helpers">[linalg.helpers]</a>, 18.4.9 <a href="https://timsong-cpp.github.io/cppwp/concept.swappable">[concept.swappable]</a>, 24.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.swap">[iterator.cust.swap]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2024-12-18 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Several exposition-only function objects in 29.9.7 <a href="https://timsong-cpp.github.io/cppwp/linalg.helpers">[linalg.helpers]</a> are specified with strange 
wording &mdash; "If the function selected by overload resolution does not return [&hellip;], the program 
is ill-formed, no diagnostic required;". These conditions don't seem to be static properties because what 
the selected function returns can be completely dependent on the runtime environment and input.
<p/>
Likewise, 18.4.9 <a href="https://timsong-cpp.github.io/cppwp/concept.swappable">[concept.swappable]</a> and 24.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.cust.swap">[iterator.cust.swap]</a> also contain such weird 
usage. Presumably we should say the behavior is undefined in these cases.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4185"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4187"><a href="4187">4187</a>. <code class='backtick'>bitset::reference</code> should be const-assignable</h3>
<p><b>Section:</b> 22.9.2 <a href="https://timsong-cpp.github.io/cppwp/template.bitset">[template.bitset]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2024-12-21 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3638" title="vector&lt;bool&gt;::swap(reference, reference) is useless (Status: New)">3638</a>, which proposes changes to <code>vector&lt;bool&gt;::reference</code>, is related. 
Should <code>vector&lt;bool&gt;::reference</code> and <code>bitset&lt;N&gt;::reference</code> behave differently 
in any respect? I think there's no good reason for them to behave differently, and good technical 
incentives to permit them to behave the same. We already have implementation divergence: libc++ makes 
<code class='backtick'>bitset::reference</code> const-assignable, whereas libstdc++ and MS STL do not. This means that libc++'s 
<code class='backtick'>bitset::reference</code> successfully avoids false positives from Arthur's proposed -Wassign-to-class-rvalue 
diagnostic, while libstdc++'s does not (See <a href="https://godbolt.org/z/4e96j7rvv">Godbolt</a>).
<p/>
The proposed resolution applies <a href="https://wg21.link/P2321#vectorboolreference">P2321</a>'s approach. We 
can't just insert <code class='backtick'>const</code> into the existing spec, because ABI. But also, since our goal is consistency 
with the post-P2321 <code>vector&lt;bool&gt;::reference</code>, we should do the same thing here as P2321, not invent anything novel.
<p/>
Open questions related to the current P/R:
</p>
<ol>
<li><p>LWG 3638 proposes to add these three <code class='backtick'>swap</code> overloads to <code>vector&lt;bool&gt;::reference</code>. 
Should we also, consistently, add them to <code class='backtick'>bitset::reference</code>? I think we should.</p>
<blockquote><pre>
friend constexpr void swap(reference x, reference y) noexcept;
friend constexpr void swap(reference x, bool&amp; y) noexcept;
friend constexpr void swap(bool&amp; x, reference y) noexcept;
</pre></blockquote>
</li>
<li><p>Both <code>vector&lt;bool&gt;::reference</code> and <code class='backtick'>bitset::reference</code> right now are specified with</p>
<blockquote><pre>
constexpr reference(const reference&amp;) = default;
</pre></blockquote>
<p>which is meaningless because we don't know the data members of <code class='backtick'>reference</code>. So this isn't actually 
specifying that the constructor is trivial, let alone that it's <code class='backtick'>noexcept</code>. I think we should re-specify 
both types' copy constructors as simply <code class='backtick'>constexpr</code> and <code class='backtick'>noexcept</code>; and then if we want them to be trivial, 
we should say so in English prose.</p>
</li>
</ol>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"Just const-quality the existing assignment operators."
"Would need to change the return type (breaking) or use <code class='backtick'>const_cast</code> (weird)."
"And it would be needlessly inconsistent with <code>vector&lt;bool&gt;::reference</code>."
</p>
<p>
"The <code class='backtick'>swap</code> part belongs in LWG <a href="3638" title="vector&lt;bool&gt;::swap(reference, reference) is useless (Status: New)">3638</a>."
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 22.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/template.bitset.general">[template.bitset.general]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t N&gt; class bitset {
  public:
    // <i>bit reference</i>
    class reference {
    public:
      constexpr reference(const reference&amp;) = default;
      constexpr ~reference();
      constexpr reference&amp; operator=(bool x) noexcept;           // <i>for b[i] = x;</i>
      constexpr reference&amp; operator=(const reference&amp;) noexcept; // <i>for b[i] = b[j];</i>
      <ins>constexpr const reference&amp; operator=(bool x) const noexcept;</ins>
      constexpr bool operator~() const noexcept;                 // <i>flips the bit</i>
      constexpr operator bool() const noexcept;                  // <i>for x = b[i];</i>
      constexpr reference&amp; flip() noexcept;                      // <i>for b[i].flip();</i>
      <ins>friend constexpr void swap(reference x, reference y) noexcept;
      friend constexpr void swap(reference x, bool&amp; y) noexcept;
      friend constexpr void swap(bool&amp; x, reference y) noexcept;</ins>      
    };
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>


</li>

</ol>
</blockquote>

<p><i>[2025-02-07; Jonathan provides improved wording]</i></p>

<p>Moved <code class='backtick'>swap</code> changes to LWG <a href="3638" title="vector&lt;bool&gt;::swap(reference, reference) is useless (Status: New)">3638</a>.</p>



<p id="res-4187"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 22.9.2.1 <a href="https://timsong-cpp.github.io/cppwp/template.bitset.general">[template.bitset.general]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t N&gt; class bitset {
  public:
    // <i>bit reference</i>
    class reference {
    public:
      constexpr reference(const reference&amp;) = default;
      constexpr ~reference();
      constexpr reference&amp; operator=(bool x) noexcept;           // <i>for b[i] = x;</i>
      constexpr reference&amp; operator=(const reference&amp;) noexcept; // <i>for b[i] = b[j];</i>
      <ins>constexpr const reference&amp; operator=(bool x) const noexcept;</ins>
      constexpr bool operator~() const noexcept;                 // <i>flips the bit</i>
      constexpr operator bool() const noexcept;                  // <i>for x = b[i];</i>
      constexpr reference&amp; flip() noexcept;                      // <i>for b[i].flip();</i>
    };
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4190"><a href="4190">4190</a>. Specification of <i>completion-signatures-for</i> in [exec.snd.expos]/p39 is recursive</h3>
<p><b>Section:</b> 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2025-01-02 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.snd.expos">active issues</a> in [exec.snd.expos].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.snd.expos">issues</a> in [exec.snd.expos].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a>/p39 reads:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
For a subexpression <code class='backtick'>sndr</code> let <code class='backtick'>Sndr</code> be <code class='backtick'>decltype((sndr))</code>. Let <code class='backtick'>rcvr</code> be a receiver with an associated
environment of type <code class='backtick'>Env</code> such that <code>sender_in&lt;Sndr, Env&gt;</code> is <code class='backtick'>true</code>. 
<code><i>completion-signatures-for</i>&lt;Sndr, Env&gt;</code> denotes a specialization of <code class='backtick'>completion_signatures</code>, 
the set of whose template arguments correspond to the set of completion operations that are potentially 
evaluated as a result of starting (33.3 <a href="https://timsong-cpp.github.io/cppwp/exec.async.ops">[exec.async.ops]</a>) the operation state that results from 
connecting <code class='backtick'>sndr</code> and <code class='backtick'>rcvr</code>. When <code>sender_in&lt;Sndr, Env&gt;</code> is <code class='backtick'>false</code>, the type denoted
by <code><i>completion-signatures-for</i>&lt;Sndr, Env&gt;</code>, if any, is not a specialization of 
<code class='backtick'>completion_signatures</code>.
</p>
</blockquote>
<p>
This paragraph is trying to specify the return type of <code><i>basic-sender</i>::get_completion_signatures</code>, 
but it immediately goes off the rails when it tests for the satisfaction of <code>sender_in&lt;Sndr, Env&gt;</code>. 
The <code>sender_in&lt;Sndr, Env&gt;</code> concept requires that <code>get_completion_signatures(sndr, env)</code> is 
well-formed and that its type is a specialization of <code>completion_signatures</code>. But the return type of 
<code class='backtick'>get_completion_signatures(sndr, env)</code> is exactly the thing this para is trying to define!
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
First sentence of p39 should be either "Let the type <code class='backtick'>Sndr</code> be ..." or
"Let <code class='backtick'>Sndr</code> be ...", but not "Let type <code class='backtick'>Sndr</code> be ...".
</p>



<p id="res-4190"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>

<li><p>Modify 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> as indicated:</p>

<blockquote><p>
-39- <ins>Let type <code class='backtick'>Sndr</code> be a (possibly <code class='backtick'>const</code>-qualified) specialization of <code><i>basic-sender</i></code> 
or an lvalue reference of such, and let <code class='backtick'>Rcvr</code> be the type of a receiver with an associated environment 
of type <code class='backtick'>Env</code>. If the type <code><i>basic-operation</i>&lt;Sndr, Rcvr&gt;</code> is well-formed, let <code class='backtick'>op</code> be 
an lvalue subexpression of that type.</ins><del>For a subexpression <code class='backtick'>sndr</code> let <code class='backtick'>Sndr</code> be <code class='backtick'>decltype((sndr))</code>. 
Let <code class='backtick'>rcvr</code> be a receiver with an associated environment of type <code class='backtick'>Env</code> such that <code>sender_in&lt;Sndr, Env&gt;</code> 
is <code class='backtick'>true</code>.</del> <code><i>completion-signatures-for</i>&lt;Sndr, Env&gt;</code> denotes a specialization of 
<code class='backtick'>completion_signatures</code>, the set of whose template arguments correspond to the set of completion operations 
that are potentially evaluated  <ins>(6.3 <a href="https://timsong-cpp.github.io/cppwp/basic.def.odr">[basic.def.odr]</a>)</ins> as a result of 
<ins>evaluating <code class='backtick'>op.start()</code>.</ins><del>starting (33.3 <a href="https://timsong-cpp.github.io/cppwp/exec.async.ops">[exec.async.ops]</a>) the operation state that results from 
connecting <code class='backtick'>sndr</code> and <code class='backtick'>rcvr</code>. When <code>sender_in&lt;Sndr, Env&gt;</code> is <code class='backtick'>false</code></del><ins>Otherwise</ins>, 
the type denoted by <code><i>completion-signatures-for</i>&lt;Sndr, Env&gt;</code>, if any, is not a 
specialization of <code class='backtick'>completion_signatures</code>.
<p/>
<i>Recommended practice</i>: When <ins>the type <code><i>basic-operation</i>&lt;Sndr, Rcvr&gt;</code> is 
ill-formed</ins><del><code>sender_in&lt;Sndr, Env&gt;</code> is <code class='backtick'>false</code></del>, implementations are encouraged 
to use the type denoted by <code><i>completion-signatures-for</i>&lt;Sndr, Env&gt;</code> to communicate to 
users why.

</p></blockquote>
</li>
</ol>






<hr>
<h3 id="4192"><a href="4192">4192</a>. &sect;[ios.base.cons] <code class='backtick'>ios_base</code> members may not have indeterminate values after construction</h3>
<p><b>Section:</b> 31.5.2.8 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a>, 31.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/ios.base.locales">[ios.base.locales]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2025-01-12 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base.cons">issues</a> in [ios.base.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
31.5.2.8 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a> specifies that
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Each <code class='backtick'>ios_base</code> member has an indeterminate value after construction.
</p>
</blockquote>
<p>
However
</p>
<ul>
<li><p>If the <code class='backtick'>ios_base</code> object has static storage duration, the members would have been zero-initialized.</p></li>
<li><p>If the <code class='backtick'>ios_base</code> object has automatic storage duration, the members would have erroneous values.</p></li>
</ul>
<p>
In either case, the constructor cannot cause the members to have indeterminate values after construction.
<p/>
A related problem is that 31.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/ios.base.locales">[ios.base.locales]</a> requires <code class='backtick'>ios_base::getloc</code> to return:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
If no locale has been imbued, a copy of the global C++ locale, <code class='backtick'>locale()</code>, in effect at the time of construction.
</p>
</blockquote>
<p>
However, according to 31.5.2.8 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a>, the corresponding member is not initialized 
until <code class='backtick'>basic_ios::init</code> is called.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"First part is NAD, can use e.g. placement new to force indeterminate values,
and it's not observable by well-defined progams anyway."
</p>



<p id="res-4192"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>

<li><p>Modify 31.5.2.4 <a href="https://timsong-cpp.github.io/cppwp/ios.base.locales">[ios.base.locales]</a> as indicated:</p>

<blockquote>
<pre>
ios_base();
</pre>
<blockquote><p>
-1- <i>Effects</i>: Each <code class='backtick'>ios_base</code> member has an <ins>unspecified (possibly</ins> indeterminate <ins>or erroneous)</ins> 
value after construction. The object's members shall be initialized by calling <code class='backtick'>basic_ios::init</code> before the object's 
first use or before it is destroyed, whichever comes first; otherwise the behavior is undefined.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 31.5.2.8 <a href="https://timsong-cpp.github.io/cppwp/ios.base.cons">[ios.base.cons]</a> as indicated:</p>

<blockquote>
<pre>
locale getloc() const;
</pre>
<blockquote><p>
-4- <i>Returns</i>: If no locale has been imbued, a copy of the global C++ locale, <code class='backtick'>locale()</code>, 
in effect at the time of <del>construction</del><ins>the last <code class='backtick'>basic_ios::init</code> call on the current 
object</ins>. Otherwise, returns the imbued locale, to be used to perform locale-dependent 
input and output operations.
</p></blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4193"><a href="4193">4193</a>. &sect;[time.zone.db] the specification uses the undefined term "thread-safe"</h3>
<p><b>Section:</b> 30.11.2 <a href="https://timsong-cpp.github.io/cppwp/time.zone.db">[time.zone.db]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2025-01-16 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a> 30.11.2.2 <a href="https://timsong-cpp.github.io/cppwp/time.zone.db.list">[time.zone.db.list]</a> p3:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Synchronization</i>: This operation is thread-safe with respect to <code class='backtick'>reload_tzdb()</code>.
</p>
</blockquote>
<p>
<a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a> 30.11.2.3 <a href="https://timsong-cpp.github.io/cppwp/time.zone.db.access">[time.zone.db.access]</a> p2:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Synchronization</i>: It is safe to call this function from multiple threads at one time.
</p>
</blockquote>
<p>
<a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a> 30.11.2.4 <a href="https://timsong-cpp.github.io/cppwp/time.zone.db.remote">[time.zone.db.remote]</a> p3:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Synchronization</i>: This function is thread-safe with respect to <code class='backtick'>get_tzdb_list().front()</code> and 
<code class='backtick'>get_tzdb_list().erase_after()</code>.
</p>
</blockquote>
<p>
The standard does not define what "thread-safe" means, which makes the meaning of these sentences unclear. 
Does it mean that "concurrent calls do not introduce data races", or does it additionally require a single 
total order on these operations? In either case, it should be specified clearly.
</p>


<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"We're missing a guarantee that <code class='backtick'>reload_tzdb()</code> strongly happens before
a call to <code class='backtick'>get_tzdb_list().front()</code> that retrieves a newly added element.
Otherwise accessing any <code class='backtick'>time_zone</code> obtained from <code class='backtick'>get_tzdb_list().front()</code>
could race with the call to <code class='backtick'>reload_tzdb()</code> that writes the front of the list."
</p>



<p id="res-4193"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4195"><a href="4195">4195</a>. <code>expected&lt;int, int&gt;</code> isn't specified to be trivially assignable</h3>
<p><b>Section:</b> 22.8.6.4 <a href="https://timsong-cpp.github.io/cppwp/expected.object.assign">[expected.object.assign]</a>, 22.8.7.4 <a href="https://timsong-cpp.github.io/cppwp/expected.void.assign">[expected.void.assign]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2025-01-21 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#expected.object.assign">active issues</a> in [expected.object.assign].</p>
<p><b>View all other</b> <a href="lwg-index.html#expected.object.assign">issues</a> in [expected.object.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, we specify that the copy constructor, move constructor, and destructor <code>expected&lt;int, int&gt;</code> 
are trivial operations. But we do not specify that the copy assignment operator or move assignment operator are. 
There is implementation divergence &mdash; MSVC's implementation is trivially copyable, but libstdc++'s and libc++'s 
are not (although, they are trivial for the purposes of calls, which is important for being able to return such a 
type in a register).
<p/>
I'm not sure there is any reason the assignment operators should not be trivial here. We should add the same kind 
of remarks in both cases: that the copy assignment operator is trivial if <code>T</code> and <code>E</code> are trivially 
copy assignable and the move assignment operator is trivial if <code>T</code> and <code>E</code> are trivially move assignable.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
"Needs to consider trivial constructors as well as assignment."
</p>
<p>
"This is an ABI break for something that shipped in C++23, NAD."
</p>



<p id="res-4195"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>

<li><p>Modify 22.8.6.4 <a href="https://timsong-cpp.github.io/cppwp/expected.object.assign">[expected.object.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr expected&amp; operator=(const expected&amp; rhs);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: [&hellip;]
<p/>
-3- <i>Returns</i>: <code>*this</code>.
<p/>
-4- <i>Remarks</i>: This operator is defined as deleted unless: 
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; [&hellip;]</p></li>
<li><p>(4.2) &mdash; [&hellip;]</p></li>
<li><p>(4.3) &mdash; [&hellip;]</p></li>
<li><p>(4.4) &mdash; [&hellip;]</p></li>
</ol>
<p>
<ins>-?- This operator is trivial if</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; <code>is_trivially_copy_assignable_v&lt;T&gt;</code> is <code>true</code> and</ins></p></li>
<li><p><ins>(?.2) &mdash; <code>is_trivially_copy_assignable_v&lt;E&gt;</code> is <code>true</code>.</ins></p></li>
</ol>
</blockquote>

<pre>
constexpr expected&amp; operator=(expected&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-5- <i>Constraints</i>: [&hellip;]
<p/>
-6- <i>Effects</i>: [&hellip;]
<p/>
-7- <i>Returns</i>: <code>*this</code>.
<p/>
-8- <i>Remarks</i>: The exception specification is equivalent to:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T&gt; &amp;&amp; is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp;
is_nothrow_move_assignable_v&lt;E&gt; &amp;&amp; is_nothrow_move_constructible_v&lt;E&gt;
</pre></blockquote>
<p>
<ins>-?- This operator is trivial if</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; <code>is_trivially_move_assignable_v&lt;T&gt;</code> is <code>true</code> and</ins></p></li>
<li><p><ins>(?.2) &mdash; <code>is_trivially_move_assignable_v&lt;E&gt;</code> is <code>true</code>.</ins></p></li>
</ol>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.8.7.4 <a href="https://timsong-cpp.github.io/cppwp/expected.void.assign">[expected.void.assign]</a> as indicated:</p>

<blockquote>
<pre>
constexpr expected&amp; operator=(const expected&amp; rhs);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: [&hellip;]
<p/>
-2- <i>Returns</i>: <code>*this</code>.
<p/>
-3- <i>Remarks</i>: This operator is defined as deleted unless <code>is_copy_assignable_v&lt;E&gt;</code> 
is <code>true</code> and <code>is_copy_constructible_v&lt;E&gt;</code> is <code>true</code>. 
<p/>
<ins>-?- This operator is trivial if <code>is_trivially_copy_assignable_v&lt;E&gt;</code> is <code>true</code>.</ins>
</p>
</blockquote>

<pre>
constexpr expected&amp; operator=(expected&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-4- <i>Constraints</i>: [&hellip;]
<p/>
-5- <i>Effects</i>: [&hellip;]
<p/>
-6- <i>Returns</i>: <code>*this</code>.
<p/>
-7- <i>Remarks</i>: The exception specification is equivalent to <code>is_nothrow_move_constructible_v&lt;E&gt; &amp;&amp; 
is_nothrow_move_assignable_v&lt;E&gt;</code>.
<p/>
<ins>-?- This operator is trivial if <code>is_trivially_move_assignable_v&lt;E&gt;</code> is <code>true</code>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4197"><a href="4197">4197</a>. Complexity of <code class='backtick'>std::visit</code> with immediate functions</h3>
<p><b>Section:</b> 22.6.7 <a href="https://timsong-cpp.github.io/cppwp/variant.visit">[variant.visit]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-01-26 <b>Last modified:</b> 2025-01-30</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#variant.visit">issues</a> in [variant.visit].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>std::visit</code> generally needs to be implemented with "vtables" that contain function pointers. 
When <code class='backtick'>std::visit</code> needs to call an immediate function (e.g. when passing a lambda whose 
<code class='backtick'>operator()</code> is <code class='backtick'>consteval</code>), the vtable will contain a pointer to an immediate-escalated 
function, which forbids the vtable from being a <code class='backtick'>constexpr</code> variable.
<p/>
In order to properly handle immediate functions in <code class='backtick'>std::visit</code>, it seems necessary to form 
the vtable, or do some non-constant-time lookup each time when calling <code class='backtick'>std::visit</code>. In other words, 
22.6.7 <a href="https://timsong-cpp.github.io/cppwp/variant.visit">[variant.visit]</a>/8 seems to be unimplementable when an immediate function is involved.
</p>

<p><i>[2025-01-01; <a href="https://wg21.link/P3603R0" title=" Consteval-only Values and Consteval Variables">P3603R0</a> addresses this]</i></p>



<p><i>[2025-01-30; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p id="res-4197"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>

<li><p>Modify 22.6.7 <a href="https://timsong-cpp.github.io/cppwp/variant.visit">[variant.visit]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Visitor, class... Variants&gt;
  constexpr <i>see below</i> visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);
template&lt;class R, class Visitor, class... Variants&gt;
  constexpr R visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);
</pre>
<blockquote>
<p>
-1- [&hellip;] Let <code><i>n</i></code> be <code class='backtick'>sizeof...(Variants)</code>. [&hellip;]
<p/>
[&hellip;]
<p/>
-8- <i>Complexity</i>: <ins>If <code><i>n</i> &gt; 1</code> or any of the aforementioned <code><i>INVOKE</i></code> 
operations calls an immediate function, the invocation of the callable object has no complexity requirements. 
Otherwise</ins><del>For <code><i>n</i> &le; 1</code></del>, the invocation of the callable object is 
implemented in constant time, i.e., for <code><i>n</i> = 1</code>, it does not depend on the number 
of alternative types of <code>V<sub>0</sub></code>. <del>For <code><i>n</i> &gt; 1</code>, the invocation of 
the callable object has no complexity requirements.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4199"><a href="4199">4199</a>. constraints on user customizations of standard sender algorithms are incorrectly specified</h3>
<p><b>Section:</b> 33.9.1 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.general">[exec.snd.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2025-02-03 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Imported from <a href="https://github.com/cplusplus/sender-receiver/issues/308">cplusplus/sender-receiver #308</a>.
</p>
<p>
33.9.1 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.general">[exec.snd.general]</a>/p1 reads:

<blockquote>
Subclauses 33.9.11 <a href="https://timsong-cpp.github.io/cppwp/exec.factories">[exec.factories]</a> and 33.9.12 <a href="https://timsong-cpp.github.io/cppwp/exec.adapt">[exec.adapt]</a> define
customizable algorithms that return senders.
Each algorithm has a default implementation.
Let <code class='backtick'>sndr</code> be the result of an invocation of such an algorithm
or an object equal to the result (18.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>),
and let <code class='backtick'>Sndr</code> be <code class='backtick'>decltype((sndr))</code>.
Let <code class='backtick'>rcvr</code> be a receiver of type <code class='backtick'>Rcvr</code> with associated environment <code class='backtick'>env</code>
of type <code class='backtick'>Env</code> such that <code>sender_to&lt;Sndr, Rcvr&gt;</code> is <code class='backtick'>true</code>.
For the default implementation of the algorithm that produced <code class='backtick'>sndr</code>,
connecting <code class='backtick'>sndr</code> to <code class='backtick'>rcvr</code> and starting the resulting operation state
(33.3 <a href="https://timsong-cpp.github.io/cppwp/exec.async.ops">[exec.async.ops]</a>) necessarily results in the potential evaluation
(6.3 <a href="https://timsong-cpp.github.io/cppwp/basic.def.odr">[basic.def.odr]</a>) of a set of completion operations
whose first argument is a subexpression equal to <code class='backtick'>rcvr</code>.
Let <code class='backtick'>Sigs</code> be a pack of completion signatures corresponding to this set
of completion operations.
<u><b>
Then the type of the expression <code class='backtick'>get_completion_signatures(sndr, env)</code>
is a specialization of the class template <code class='backtick'>completion_signatures</code>
( [exec.util.cmplsig]), the set of whose template arguments is <code class='backtick'>Sigs</code>.
</b></u>
If a user-provided implementation of the algorithm that produced <code class='backtick'>sndr</code>
is selected instead of the default, any completion signature that is in
the set of types denoted by
<code>completion_signatures_of_t&lt;Sndr, Env&gt;</code>
and that is not part of <code class='backtick'>Sigs</code>
shall correspond to error or stopped completion operations,
unless otherwise specified.
</blockquote>
The emphasized sentence is the problem. Since <a href="https://wg21.link/P2300" title=" `std::execution`">P2300</a>
got lazy customization,
the expression <code class='backtick'>get_completion_signatures(snd, env)</code>
could dispatch to a customization.
We should define a low-level exposition-only
<i><code class='backtick'>get-completion-signatures</code></i>
function that does the same as <code class='backtick'>get_completion_signatures</code>
except without the sender transformation.
Then we can express <code class='backtick'>get_completion_signatures</code> in terms of that.
</p>

<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>



<p id="res-4199"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4206"><a href="4206">4206</a>. Alias template <code class='backtick'>connect_result_t</code> should be constrained with <code class='backtick'>sender_to</code></h3>
<p><b>Section:</b> 99 [exec.syn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2025-02-04 <b>Last modified:</b> 2025-02-07</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Imported from <a href="https://github.com/cplusplus/sender-receiver/issues/320">cplusplus/sender-receiver #320</a>.
</p>
<p>
Since turning <code class='backtick'>execution::connect(sndr, rcvr)</code>'s <i>constraints</i>
to a <i>mandates</i>, the <code class='backtick'>connect</code> customization point is now unconstrained.
</p>
<p>
But there is at least one place in the algorithms (33.9.12.10 <a href="https://timsong-cpp.github.io/cppwp/exec.let">[exec.let]</a>)
that is using <code class='backtick'>connect_result_t</code> in an immediate context of a function template
with the expectation that <code>connect_result_t&lt;Sndr, Rcvr&gt;</code>
will be well-formed only when <code class='backtick'>Sndr</code> and <code class='backtick'>Rcvr</code> can actually be connected.
with the current definition, <code>connect_result_t&lt;Sndr, Rcvr&gt;</code>
could very well cause a hard error; it will never cuase a substitution failure.
</p>
<p>
The solution is to constrain the <code class='backtick'>connect_result_t</code> alias template.
Just as <code>completion_signatures_of_t&lt;Sndr, Env&gt;</code>
is constrained with <code>sender_in&lt;Sndr, Env&gt;</code>,
so too should <code>connect_result_t&lt;Sndr, Rcvr&gt;</code>
be constrained with <code>sender_to&lt;Sndr, Rcvr&gt;</code>.
</p>
<p>
For reference, the <code class='backtick'>sender_to</code> concept is defined as follows:

<pre><code>
template&lt;class Sndr, class Rcvr&gt;
    concept sender_to =
      sender_in&lt;Sndr, env_of_t&lt;Rcvr&gt;&gt; &amp;&amp;
      receiver_of&lt;Rcvr, completion_signatures_of_t&lt;Sndr, env_of_t&lt;Rcvr&gt;&gt;&gt; &amp;&amp;
      requires (Sndr&amp;&amp; sndr, Rcvr&amp;&amp; rcvr) {
        connect(std::forward&lt;Sndr&gt;(sndr), std::forward&lt;Rcvr&gt;(rcvr));
      };
</code></pre>
</p>


<p><i>[2025-02-07; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>



<p id="res-4206"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li>
Modify 99 [exec.syn] as indicated:
<blockquote>
<pre><code>
  template&lt;class Sndr, class Rcvr&gt;
    <ins>requires sender_to&lt;Sndr, Rcvr&gt;</ins>
    using connect_result_t =
      decltype(connect(declval&lt;Sndr&gt;(), declval&lt;Rcvr&gt;()));
</code></pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4207"><a href="4207">4207</a>. Point of reference for <code class='backtick'>source_location</code> is not specified when used in an default template argument</h3>
<p><b>Section:</b> 17.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/support.srcloc.cons">[support.srcloc.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Cassio Neri <b>Opened:</b> 2025-02-07 <b>Last modified:</b> 2025-02-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.srcloc.cons">issues</a> in [support.srcloc.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/support.srcloc.cons">[support.srcloc.cons]</a>/2 in <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a> says nothing
about using <code class='backtick'>source_location::current()</code> in an initializer of a template
parameter. The example below suggests that gcc, clang and msvc seem to agree
on this case. It would be nice if the Standard legitimized current practice.
</p>
<pre><code>
#include &lt;source_location&gt;

template &lt;int i = std::source_location::current().line()&gt; // line 3
struct A {
  static constexpr int value = i;
};

template &lt;int i = std::source_location::current().line()&gt; // line 8
constexpr int f() {
  return i;
}

static_assert(A&lt;&gt;::value == 3); // passes
static_assert(f() == 8); // passes
</code></pre>

<p><i>[2025-02-07; Jonathan provides wording]</i></p>

<p>
For a default argument of a function parameter, <code class='backtick'>current()</code> is recommended
to return the location of the caller that makes use of that default argument.
For a default template argument, the location would be determined by the
template's point of instantiation (13.8.4.1 <a href="https://timsong-cpp.github.io/cppwp/temp.point">[temp.point]</a>) which would
not always do what users expect. Using the location of the default template
argument in the template declaration seems sensible and predictable,
and matches existing practice. Arguably, this doesn't need to be stated
because it's just "exactly where the <code class='backtick'>current()</code> call appear in the source".
The other cases in the Remarks paragraph are situations where the preferred
location is different, because we want to know where it's used, not defined.
</p>


<p id="res-4207"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li>
Modify 17.8.2.2 <a href="https://timsong-cpp.github.io/cppwp/support.srcloc.cons">[support.srcloc.cons]</a> as indicated:
<blockquote>
-2- <i>Remarks</i>:
Any call to <code class='backtick'>current</code> that appears as a default member initializer
(11.4 <a href="https://timsong-cpp.github.io/cppwp/class.mem">[class.mem]</a>), or as a subexpression thereof,
should correspond to the location of the constructor definition
or aggregate initialization that uses the default member initializer.
Any call to <code class='backtick'>current</code> that appears as a default argument
(9.3.4.7 <a href="https://timsong-cpp.github.io/cppwp/dcl.fct.default">[dcl.fct.default]</a>), or as a subexpression thereof,
should correspond to the location of the invocation of the function that
uses the default argument (7.6.1.3 <a href="https://timsong-cpp.github.io/cppwp/expr.call">[expr.call]</a>).
<ins>
Any call to <code class='backtick'>current</code> that appears as a default template argument
(13.2 <a href="https://timsong-cpp.github.io/cppwp/temp.param">[temp.param]</a>), or as a subexpression thereof,
should correspond to the location where the default template argument
is specified.
</ins>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4210"><a href="4210">4210</a>. Issue with <code>cache_latest_view::<i>iterator</i></code>'s reference type </h3>
<p><b>Section:</b> 25.7.34.3 <a href="https://timsong-cpp.github.io/cppwp/range.cache.latest.iterator">[range.cache.latest.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-02-09 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>cache_latest_view::<i>iterator</i></code> can be roughly regarded as an iterator that
transforms the original iterator's reference, because its reference is <i>always</i> an lvalue 
which is <code>range_reference_t&lt;V&gt;&amp;</code>, even if the original iterator returns 
an rvalue.
<p/>
In this case, it seems a bit odd to still specialize <code>iter_move</code> and return the rvalue 
reference type of the original iterator, because the original reference has changed, so the former 
may not form a valid common reference with the original rvalue reference.
<p/>
That is, in some rare cases even if the <code>cache_latest_view</code> can be legally constructed, 
it may not be an <code>input_range</code> as <code>indirectly_readable</code> is not satisfied.
<p/>
A contrived example could be:
</p>
<blockquote><pre>
struct I {
  using value_type = int;
  using difference_type = int;

  struct move_only_ref {
    move_only_ref(const int&amp;);
    move_only_ref(move_only_ref&amp;&amp;) = default;
  };

  move_only_ref operator*() const;
  I&amp; operator++();
  void operator++(int);
};

using R = ranges::cache_latest_view&lt;ranges::subrange&lt;I, unreachable_sentinel_t&gt;&gt;; // ok

static_assert(input_iterator&lt;I&gt;);
static_assert(ranges::input_range&lt;R&gt;); // failed
</pre></blockquote>
<p>
It's unclear whether we should change the reference type to <code>range_reference_t&lt;V&gt;&amp;&amp;</code> 
to preserve the original ref-qualifiers as much as possible (I don't see any discussion of this option 
in the original paper), or not provide a specialized <code>iter_move</code>, since it's intuitive to have 
the default <code>iter_move</code> return an rvalue when it always returns an lvalue.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4210"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4211"><a href="4211">4211</a>. IANA time zone database allows links to refer to links</h3>
<p><b>Section:</b> 30.11.2.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.db.tzdb">[time.zone.db.tzdb]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-02-22 <b>Last modified:</b> 2025-02-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since
<a href="https://github.com/eggert/tz/commit/4878b644b25020568d4dda346c5cea91826c0c7c">October 2022</a>
the IANA Time Zone Database's <code class='backtick'>tzfile</code> data format allows a Link to refer
to another Link, instead of referring directly to a Zone.
The <a href="https://man7.org/linux/man-pages/man8/zic.8.html#FILES">zic(8)</a>
man page says:
<blockquote>
The TARGET field should appear as the NAME field in some zone line
or as the LINK-NAME field in some link line.
The LINK-NAME  field  is  used as an alternative name for that zone;
it has the same syntax as a zone line's NAME field.
Links can chain together, although the behavior is unspecified if
a chain of one or more links does not terminate in a Zone name.
</blockquote>
Because chains of links were introduced to <code class='backtick'>tzfile</code> after <code class='backtick'>chrono::tzdb</code>
was standardized, C++ does not properly support chains of links.
</p>
<p>
The <code class='backtick'>time_zone_link::target()</code> member function is required to return
"The name of the <code class='backtick'>time_zone</code> for which this <code class='backtick'>time_zone_link</code> provides
an alternative name."
This doesn't allow returning the name of another <code class='backtick'>time_zone_link</code>,
which implies that the implementation should flatten a series of links so
that the target is a <code class='backtick'>time_zone</code>. However, this discards information which
is present in the <code class='backtick'>tzdb</code>, so that the information exposed to a C++ program
does not preserve the original structure of a chain of links.
</p>
<p>
The standard could be adjusted to support chains of links by allowing
<code class='backtick'>time_zone_link::target()</code> to refer to another link, and then altering the
algorithm used by <code class='backtick'>tzdb::locate_zone(string_view)</code> to find a <code class='backtick'>time_zone</code> from
a name that might be a zone or a link.
</p>


<p id="res-4211"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li>
Modify 30.11.2.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.db.tzdb">[time.zone.db.tzdb]</a> as indicated:
<blockquote>
<pre><code>
const time_zone* locate_zone(string_view tz_name) const;
</code></pre>
<p>
-2- <i>Returns</i>:
<ol style="list-style-type:none">
<li>
(2.1) &mdash;
If <code class='backtick'>zones</code> contains an element <code class='backtick'>tz</code> for which <code class='backtick'>tz.name() == tz_name</code>,
a pointer to <code class='backtick'>tz</code>;
</li>
<li>
(2.2) &mdash;
otherwise, if <code class='backtick'>links</code> contains an element <code class='backtick'>tz_l</code> for which
<code class='backtick'>tz_l.name() == tz_name</code>, then
<del>a pointer to the element <code class='backtick'>tz</code> of zones for which
<code class='backtick'>tz.name() == tz_l.target()</code></del>
<ins>
the result of <code class='backtick'>locate_zone(tz_l.target())</code>.
</ins>.
</li>
</ol>
</p>
<p>
[<i>Note 1</i>:A <code class='backtick'>time_zone_link</code> specifies an alternative name for a
<code class='backtick'>time_zone</code>. &mdash; <i>end note</i>]
</p>
<p>
-3- <i>Throws</i>:
If a <code class='backtick'>const time_zone*</code> cannot be found as described in the <i>Returns</i>:
element, throws a <code class='backtick'>runtime_error</code>.
</p>
<p>
[<i>Note 2</i>:On non-exceptional return, the return value is always a
pointer to a valid <code class='backtick'>time_zone</code>. &mdash; <i>end note</i>]
</p>
<p>
<ins>
-?- <i>Remarks</i>:
If both <code class='backtick'>zones</code> and <code class='backtick'>links</code> contain elements that match <code class='backtick'>tz_name</code> then
it is unspecified whether <code>&amp;tz</code>
or <code>locate_zone(tz_l.target())</code> is returned.
</ins>
</p>
<blockquote class="note">[<i>Drafting note</i>:
This gives flexibility how to implement the lookup in <code class='backtick'>locate_zone</code>.]
</blockquote>
</blockquote>
</li>
<li>
Modify 30.11.9.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.link.overview">[time.zone.link.overview]</a> as indicated:
<blockquote>
<p>
-1-
A <code class='backtick'>time_zone_link</code> specifies an alternative name for a <code class='backtick'>time_zone</code>.
<code class='backtick'>time_zone_links</code> are constructed when the time zone database is initialized.
<ins>
The name of a <code class='backtick'>time_zone_link</code> can be used as an argument to
<code class='backtick'>tzdb::locate_zone</code> (30.11.2.1 <a href="https://timsong-cpp.github.io/cppwp/time.zone.db.tzdb">[time.zone.db.tzdb]</a>).
A <code class='backtick'>time_zone_link</code> can refer directly to a <code class='backtick'>time_zone</code>,
or to another <code class='backtick'>time_zone_link</code>, forming a chain of links.
</ins>
</p>
</blockquote>
</li>
<li>
Modify 30.11.9.2 <a href="https://timsong-cpp.github.io/cppwp/time.zone.link.members">[time.zone.link.members]</a> as indicated:
<blockquote>
<pre><code>
string_view name() const noexcept;
</code></pre>
-1- <i>Returns</i>:
The alternative name for the time zone.
<pre><code>
string_view target() const noexcept;
</code></pre>
<p>
-2- <i>Returns</i>:
The name of the <code class='backtick'>time_zone</code>
for which this <code class='backtick'>time_zone_link</code> provides an alternative name
<ins>or the name of another <code class='backtick'>time_zone_link</code></ins>.
</p>
<p>
<ins>
[<i>Note 1</i>:
<code class='backtick'>tzdb::locate_zone</code> follows a chain of links formed when
a link's target is the name of a <code class='backtick'>time_zone_link</code>,
throwing an exception if the
chain of links does not terminate in a <code class='backtick'>time_zone</code>.
&mdash; <i>end note</i>]
</ins>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4212"><a href="4212">4212</a>. Make the round states in [rand.eng.philox] explicit</h3>
<p><b>Section:</b> 29.5.4.5 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.philox">[rand.eng.philox]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas Kppe <b>Opened:</b> 2025-02-12 <b>Last modified:</b> 2025-08-19</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.eng.philox">issues</a> in [rand.eng.philox].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current wording that specifies the operation of the Philox random bit generator seems needlessly vague. 
We can add precision by defining a few more terms, instead of requiring the reader to fill in the blanks.
<p/>
Concretely, the variable <math><mi>X</mi><mi>'</mi></math> is only vaguely defined at the moment, and the definition of the 
"r-round network", "rounds", and how they fit together, is somewhat informal and imprecise. The statement 
that <code class='backtick'>Philox</code> "returns the sequence <math><mi>Y</mi></math> = <math><mi>X</mi><mi>'</mi></math>" is needlessly 
ambiguous (what is <math><mi>X</mi><mi>'</mi></math> here?).
<p/>
I propose the change that I drafted at <a href="https://github.com/cplusplus/draft/pull/7152">draft/pull/7152</a>: 
Namely, spell out the meaning of the "rounds" and create a distinct name for every value in every round. 
This allows us to state the result precisely, and makes it clear how each round computes a new value from the 
values of the previous rounds.
<p/>
It seems convenient to change the round counter <math><mi>q</mi></math> to be 1-based (and 
<math><msup><mi>X</mi><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow></msup></math>
is an alias for the initial value, <math><mi>X</mi></math>), so that the final result is 
<math><msup><mi>X</mi><mrow><mo>(</mo><mi>r</mi><mo>)</mo></mrow></msup></math>.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 29.5.4.5 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.philox">[rand.eng.philox]</a> as indicated:</p>

<blockquote>
<p>
-2- The generation algorithm returns <math><msub><mi>Y</mi><mrow><mi>i</mi></mrow></msub></math>, the value stored in 
the <math><msup><mi>i</mi><mtext>th</mtext></msup></math> element of <math><mi>Y</mi></math> after applying the 
transition algorithm.
<p/>
-3- The state transition is performed as if by the following algorithm:
</p>
<blockquote><pre>
<math><mi>i</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></math>
<code>if (<math><mi>i</mi></math> == <math><mi>n</mi></math>) {</code>
  <math><mi>Y</mi><mo>=</mo></math><code>Philox</code>(<math><mi>K</mi></math>, <math><mi>X</mi></math>) <i>// see below</i>
  <math><mi>Z</mi><mo>=</mo><mi>Z</mi><mo>+</mo><mn>1</mn></math>         <ins><i>// this updates <math><mi>X</mi></math></i></ins>
  <math><mi>i</mi><mo>=</mo><mn>0</mn></math>
}
</pre></blockquote>
<p>
-4- The <code>Philox</code> function maps the length-<math><mi>n</mi></math>/2 sequence <math><mi>K</mi></math> 
and the length-<math><mi>n</mi></math> sequence <math><mi>X</mi></math> into a length-<math><mi>n</mi></math> output
sequence <del><math><mi>Y</mi></math></del>. Philox applies an <math><mi>r</mi></math>-round substitution-permutation network to 
the values in <math><mi>X</mi></math>. <del>A single round of the generation algorithm performs the following steps:</del>
<ins>That is, there are intermediate values <math><msup><mi>X</mi><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow></msup></math>,
<math><msup><mi>X</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msup></math>, &hellip;,
<math><msup><mi>X</mi><mrow><mo>(</mo><mi>r</mi><mo>)</mo></mrow></msup></math>, where 
<math><msup><mi>X</mi><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow></msup><mo>:=</mo><mi>X</mi></math>, and for each round
<math><mi>q</mi></math> (with <math><mi>q</mi><mo>=</mo><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>r</mi></math>),
<math><msup><mi>X</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msup></math> is computed from
<math><msup><mi>X</mi><mrow><mo>(</mo><mi>q</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msup></math> as follows. The output sequence
is <math><msup><mi>X</mi><mrow><mo>(</mo><mi>r</mi><mo>)</mo></mrow></msup></math>.</ins>
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <del>The output sequence <math><mi>X</mi><mi>'</mi></math> of the previous round (<math><mi>X</mi></math> 
in case of the first round) is permuted to obtain the intermediate state <math><mi>V</mi></math>:</del></p>
<blockquote><pre>
<del><math><msub><mi>V</mi><mrow><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>X</mi><mi>'</mi><mrow><msub><mi>f</mi><mrow><mi>n</mi></mrow></msub><mo>(</mo><mi>j</mi><mo>)</mo></mrow></msub></math></del>
</pre></blockquote>
<p>
<ins>An intermediate state <math><msup><mi>V</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msup></math> is obtained
by permuting the previous output, 
<math><msubsup><mi>V</mi><mi>j</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup><mo>:=</mo><msubsup><mi>X</mi><mrow><msub><mi>f</mi><mrow><mi>n</mi></mrow></msub><mo>(</mo><mi>j</mi><mo>)</mo></mrow><mrow><mo>(</mo><mi>q</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msubsup></math>,</ins>
where <math><mi>j</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi><mo></mo><mn>1</mn></math><ins>,</ins> and 
<math><msub><mi>f</mi><mrow><mi>n</mi></mrow></msub><mo>(</mo><mi>j</mi><mo>)</mo></math> is defined in Table 124.
</p>
</li>
<li><p>(4.2) &mdash; <del>The following computations are applied to the elements of the <math><mi>V</mi></math> sequence:</del>
<ins>The next output <math><msup><mi>X</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msup></math> is computed from the elements of the
<math><msup><mi>V</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msup></math> as follows. For <math><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi><mo>/</mo><mn>2</mn><mo>-</mo><mn>1</mn><mo>,</mo></math></ins></p>
<ol style="list-style-type: none">
<li><p><ins>(4.2.?) &mdash; <math><msubsup><mi>X</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>0</mn></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math> = mulhi(<math><msubsup><mi>V</mi><mrow><mn>2</mn><mi>k</mi></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math>,<math><msub><mi>M</mi><mi>k</mi></msub></math>,<i>w</i>) xor <math><msubsup><mi>K</mi><mi>k</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math> xor <math><msubsup><mi>V</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math>, and</ins><del><math><msub><mi>X</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>0</mn></mrow></msub></math> = mulhi(<math><msub><mi>V</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></math>,<math><msub><mi>M</mi><mi>k</mi></msub></math>,<i>w</i>) xor <math><msubsup><mi style="font-style: italic">key</mi><mi>k</mi><mi>q</mi></msubsup></math> xor <math><msub><mi>V</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math></del></p></li>
<li><p><ins>(4.2.?) &mdash; <math><msubsup><mi>X</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math> = mullo(<math><msubsup><mi>V</mi><mrow><mn>2</mn><mi>k</mi></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math>,<math><msub><mi>M</mi><mi>k</mi></msub></math>,<i>w</i>),</ins><del><math><msub><mi>X</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math> = mullo(<math><msub><mi>V</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></math>,<math><msub><mi>M</mi><mi>k</mi></msub></math>,<i>w</i>)</del></p></li>
</ol>
<p>
where<del>:</del>
</p>
<ol style="list-style-type: none">
<li><p>(4.2.1) &mdash; mullo(<math><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>w</mi></math>) is the low half of the modular multiplication of 
<math><mi>a</mi></math> and <math><mi>b</mi></math>: <math><mo>(</mo><mi>a</mi><mo>&#8901;</mo><mi>b</mi><mo>)</mo><mo>mod</mo><msup><mn>2</mn><mi>w</mi></msup></math>,</p></li>
<li><p>(4.2.2) &mdash; mulhi(<math><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>w</mi></math>) is the high half of the modular multiplication of 
<math><mi>a</mi></math> and <math><mi>b</mi></math>: <math><mo>(</mo><mo>&#x230A;</mo><mo>(</mo><mi>a</mi><mo>&#8901;</mo><mi>b</mi><mo>)</mo><mo>/</mo><msup><mn>2</mn><mi>w</mi></msup><mo>&#x230B;</mo><mo>)</mo></math>,</p></li>
<li><p>(4.2.3) &mdash; 
<del><math><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi><mo>/</mo><mn>2</mn><mo></mo><mn>1</mn></math> is the index in the sequences,</del>
<ins><math><msubsup><mi>K</mi><mi>k</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math> is the
<math><msup><mi>k</mi><mtext>th</mtext></msup></math> round key for round <math><mi>q</mi></math>,
<math><msubsup><mi>K</mi><mi>k</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup><mo>:=</mo><mo>(</mo><msub><mi>K</mi><mi>k</mi></msub><mo>+</mo><mo>(</mo><mi>q</mi><mo>-</mo><mn>1</mn><mo>)</mo><mo>&#8901;</mo><msub><mi>C</mi><mi>k</mi></msub><mo>)</mo><mo>mod</mo><msup><mn>2</mn><mi>w</mi></msup></math>,</ins></p></li>
<li><p>(4.2.4) &mdash; <del><math><mi>q</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>r</mi><mo></mo><mn>1</mn></math> is the index of the round,</del>
<ins><math><msub><mi>K</mi><mi>k</mi></msub></math> is the <math><msup><mi>k</mi><mtext>th</mtext></msup></math> element of the key sequence
<math><mi>K</mi></math>,</ins></p></li>
<li><p><del>(4.2.5) &mdash; <math><msubsup><mi style="font-style: italic">key</mi><mi>k</mi><mi>q</mi></msubsup></math> is the 
<math><msup><mi>k</mi><mtext>th</mtext></msup></math> round key for round <math><mi>q</mi></math>, 
<math><msubsup><mi style="font-style: italic">key</mi><mi>k</mi><mi>q</mi></msubsup><mo>:=</mo><mo>(</mo><msub><mi>K</mi><mi>k</mi></msub><mo>+</mo><mi>q</mi><mo>&#8901;</mo><msub><mi>C</mi><mi>k</mi></msub><mo>)</mo><mo>mod</mo><msup><mn>2</mn><mi>w</mi></msup></math>,</del></p></li>
<li><p><del>(4.2.6) &mdash; <math><msub><mi>K</mi><mi>k</mi></msub></math> are the elements of the key sequence <math><mi>K</mi></math>,</del></p></li>
<li><p>(4.2.7) &mdash; <math><msub><mi>M</mi><mi>k</mi></msub></math> is <code>multipliers[<math><mi>k</mi></math>]</code>, and</p></li>
<li><p>(4.2.8) &mdash; <math><msub><mi>C</mi><mi>k</mi></msub></math> is <code>round_consts[<math><mi>k</mi></math>]</code>.</p></li>
</ol>
</li>

</ol>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2025-08-08; Matt Stephanson comments and makes wording improvements with Thomas Kppe]</i></p>

<ol>
<li><p>For what it's worth, I believe the new wording correctly describes the algorithm and does not make any substantive changes.</p></li>
<li><p>As for the wording itself:</p>
<ol style="list-style-type:lower-alpha">
<li><p>Paragraphs 1, 2, and 3 still refer to the output sequence as <code><i>Y</i></code>, so I don't think 
it should be removed from the end of the first sentence in p4. On the contrary, to maintain the connection 
and parallel the "$X^{(0)} := X$" wording, I think the final sentence should also be 
"The output sequence is $X^{(r)} := Y$".</p></li>
<li><p>I can't explain why, but my intuition is that, in bullet (4.2), "the elements of $V^{(q)}$"  
sounds better than "the elements of the $V^{(q)}$". The second "the" worked with the original wording 
"the <code><i>V</i></code> sequence", but "sequence" is omitted in the proposed resolution.</p></li>
<li><p>The use of <code><i>K</i></code> for both the fixed key sequence and the round keys seems potentially 
confusing. Maybe <code><i>R</i></code> for "round key" is better?</p></li>
</ol>
</li>
</ol>
<p>
After discussion with Thomas Kppe there was agreement that (a) should be applied with the modification 
that we should write it as definition of <code><i>Y</i></code> and not the other way around, that (b) should 
be applied as suggested, and that there was no real consensus for proposal (c).
</p>


<p id="res-4212"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>
<li><p>Modify 29.5.4.5 <a href="https://timsong-cpp.github.io/cppwp/rand.eng.philox">[rand.eng.philox]</a> as indicated:</p>

<blockquote>
<p>
-2- The generation algorithm returns <math><msub><mi>Y</mi><mrow><mi>i</mi></mrow></msub></math>, the value stored in 
the <math><msup><mi>i</mi><mtext>th</mtext></msup></math> element of <math><mi>Y</mi></math> after applying the 
transition algorithm.
<p/>
-3- The state transition is performed as if by the following algorithm:
</p>
<blockquote><pre>
<math><mi>i</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></math>
<code>if (<math><mi>i</mi></math> == <math><mi>n</mi></math>) {</code>
  <math><mi>Y</mi><mo>=</mo></math><code>Philox</code>(<math><mi>K</mi></math>, <math><mi>X</mi></math>) <i>// see below</i>
  <math><mi>Z</mi><mo>=</mo><mi>Z</mi><mo>+</mo><mn>1</mn></math>         <ins><i>// this updates <math><mi>X</mi></math></i></ins>
  <math><mi>i</mi><mo>=</mo><mn>0</mn></math>
}
</pre></blockquote>
<p>
-4- The <code>Philox</code> function maps the length-<math><mi>n</mi></math>/2 sequence <math><mi>K</mi></math> 
and the length-<math><mi>n</mi></math> sequence <math><mi>X</mi></math> into a length-<math><mi>n</mi></math> output
sequence <del><math><mi>Y</mi></math></del>. Philox applies an <math><mi>r</mi></math>-round substitution-permutation network to 
the values in <math><mi>X</mi></math>. <del>A single round of the generation algorithm performs the following steps:</del>
<ins>That is, there are intermediate values <math><msup><mi>X</mi><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow></msup></math>,
<math><msup><mi>X</mi><mrow><mo>(</mo><mn>1</mn><mo>)</mo></mrow></msup></math>, &hellip;,
<math><msup><mi>X</mi><mrow><mo>(</mo><mi>r</mi><mo>)</mo></mrow></msup></math>, where 
<math><msup><mi>X</mi><mrow><mo>(</mo><mn>0</mn><mo>)</mo></mrow></msup><mo>:=</mo><mi>X</mi></math>, and for each round
<math><mi>q</mi></math> (with <math><mi>q</mi><mo>=</mo><mn>1</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>r</mi></math>),
<math><msup><mi>X</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msup></math> is computed from
<math><msup><mi>X</mi><mrow><mo>(</mo><mi>q</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msup></math> as follows. The output sequence
is <math><mi>Y</mi><mo>:=</mo><msup><mi>X</mi><mrow><mo>(</mo><mi>r</mi><mo>)</mo></mrow></msup></math>.</ins>
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <del>The output sequence <math><mi>X</mi><mi>'</mi></math> of the previous round (<math><mi>X</mi></math> 
in case of the first round) is permuted to obtain the intermediate state <math><mi>V</mi></math>:</del></p>
<blockquote><pre>
<del><math><msub><mi>V</mi><mrow><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>X</mi><mi>'</mi><mrow><msub><mi>f</mi><mrow><mi>n</mi></mrow></msub><mo>(</mo><mi>j</mi><mo>)</mo></mrow></msub></math></del>
</pre></blockquote>
<p>
<ins>An intermediate state <math><msup><mi>V</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msup></math> is obtained
by permuting the previous output, 
<math><msubsup><mi>V</mi><mi>j</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup><mo>:=</mo><msubsup><mi>X</mi><mrow><msub><mi>f</mi><mrow><mi>n</mi></mrow></msub><mo>(</mo><mi>j</mi><mo>)</mo></mrow><mrow><mo>(</mo><mi>q</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow></msubsup></math>,</ins>
where <math><mi>j</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi><mo></mo><mn>1</mn></math><ins>,</ins> and 
<math><msub><mi>f</mi><mrow><mi>n</mi></mrow></msub><mo>(</mo><mi>j</mi><mo>)</mo></math> is defined in Table 129.
</p>
</li>
<li><p>(4.2) &mdash; <del>The following computations are applied to the elements of the <math><mi>V</mi></math> sequence:</del>
<ins>The next output <math><msup><mi>X</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msup></math> is computed from the elements of
<math><msup><mi>V</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msup></math> as follows. For <math><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi><mo>/</mo><mn>2</mn><mo>-</mo><mn>1</mn><mo>,</mo></math></ins></p>
<ol style="list-style-type: none">
<li><p><ins>(4.2.?) &mdash; <math><msubsup><mi>X</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>0</mn></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math> = mulhi(<math><msubsup><mi>V</mi><mrow><mn>2</mn><mi>k</mi></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math>,<math><msub><mi>M</mi><mi>k</mi></msub></math>,<i>w</i>) xor <math><msubsup><mi>K</mi><mi>k</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math> xor <math><msubsup><mi>V</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math>, and</ins><del><math><msub><mi>X</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>0</mn></mrow></msub></math> = mulhi(<math><msub><mi>V</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></math>,<math><msub><mi>M</mi><mi>k</mi></msub></math>,<i>w</i>) xor <math><msubsup><mi style="font-style: italic">key</mi><mi>k</mi><mi>q</mi></msubsup></math> xor <math><msub><mi>V</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math></del></p></li>
<li><p><ins>(4.2.?) &mdash; <math><msubsup><mi>X</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math> = mullo(<math><msubsup><mi>V</mi><mrow><mn>2</mn><mi>k</mi></mrow><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math>,<math><msub><mi>M</mi><mi>k</mi></msub></math>,<i>w</i>),</ins><del><math><msub><mi>X</mi><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math> = mullo(<math><msub><mi>V</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></math>,<math><msub><mi>M</mi><mi>k</mi></msub></math>,<i>w</i>)</del></p></li>
</ol>
<p>
where<del>:</del>
</p>
<ol style="list-style-type: none">
<li><p>(4.2.1) &mdash; mullo(<math><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>w</mi></math>) is the low half of the modular multiplication of 
<math><mi>a</mi></math> and <math><mi>b</mi></math>: <math><mo>(</mo><mi>a</mi><mo>&#8901;</mo><mi>b</mi><mo>)</mo><mo>mod</mo><msup><mn>2</mn><mi>w</mi></msup></math>,</p></li>
<li><p>(4.2.2) &mdash; mulhi(<math><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>w</mi></math>) is the high half of the modular multiplication of 
<math><mi>a</mi></math> and <math><mi>b</mi></math>: <math><mo>(</mo><mo>&#x230A;</mo><mo>(</mo><mi>a</mi><mo>&#8901;</mo><mi>b</mi><mo>)</mo><mo>/</mo><msup><mn>2</mn><mi>w</mi></msup><mo>&#x230B;</mo><mo>)</mo></math>,</p></li>
<li><p>(4.2.3) &mdash; 
<del><math><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>n</mi><mo>/</mo><mn>2</mn><mo></mo><mn>1</mn></math> is the index in the sequences,</del>
<ins><math><msubsup><mi>K</mi><mi>k</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup></math> is the
<math><msup><mi>k</mi><mtext>th</mtext></msup></math> round key for round <math><mi>q</mi></math>,
<math><msubsup><mi>K</mi><mi>k</mi><mrow><mo>(</mo><mi>q</mi><mo>)</mo></mrow></msubsup><mo>:=</mo><mo>(</mo><msub><mi>K</mi><mi>k</mi></msub><mo>+</mo><mo>(</mo><mi>q</mi><mo>-</mo><mn>1</mn><mo>)</mo><mo>&#8901;</mo><msub><mi>C</mi><mi>k</mi></msub><mo>)</mo><mo>mod</mo><msup><mn>2</mn><mi>w</mi></msup></math>,</ins></p></li>
<li><p>(4.2.4) &mdash; <del><math><mi>q</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>&hellip;</mo><mo>,</mo><mi>r</mi><mo></mo><mn>1</mn></math> is the index of the round,</del>
<ins><math><msub><mi>K</mi><mi>k</mi></msub></math> is the <math><msup><mi>k</mi><mtext>th</mtext></msup></math> element of the key sequence
<math><mi>K</mi></math>,</ins></p></li>
<li><p><del>(4.2.5) &mdash; <math><msubsup><mi style="font-style: italic">key</mi><mi>k</mi><mi>q</mi></msubsup></math> is the 
<math><msup><mi>k</mi><mtext>th</mtext></msup></math> round key for round <math><mi>q</mi></math>, 
<math><msubsup><mi style="font-style: italic">key</mi><mi>k</mi><mi>q</mi></msubsup><mo>:=</mo><mo>(</mo><msub><mi>K</mi><mi>k</mi></msub><mo>+</mo><mi>q</mi><mo>&#8901;</mo><msub><mi>C</mi><mi>k</mi></msub><mo>)</mo><mo>mod</mo><msup><mn>2</mn><mi>w</mi></msup></math>,</del></p></li>
<li><p><del>(4.2.6) &mdash; <math><msub><mi>K</mi><mi>k</mi></msub></math> are the elements of the key sequence <math><mi>K</mi></math>,</del></p></li>
<li><p>(4.2.7) &mdash; <math><msub><mi>M</mi><mi>k</mi></msub></math> is <code>multipliers[<math><mi>k</mi></math>]</code>, and</p></li>
<li><p>(4.2.8) &mdash; <math><msub><mi>C</mi><mi>k</mi></msub></math> is <code>round_consts[<math><mi>k</mi></math>]</code>.</p></li>
</ol>
</li>

</ol>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4213"><a href="4213">4213</a>. Sender spec depends on unspecified order of evaluation</h3>
<p><b>Section:</b> 33.9 <a href="https://timsong-cpp.github.io/cppwp/exec.snd">[exec.snd]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Frank Birbacher <b>Opened:</b> 2025-02-14 <b>Last modified:</b> 2025-02-23</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In certain clauses for defining senders the unspecified order of evaluation of function arguments can 
lead to retrieving values from a move-from state of a sender. An example is 33.9.12.6 <a href="https://timsong-cpp.github.io/cppwp/exec.continues.on">[exec.continues.on]</a> 
where paragraph 3 states:
</p>
<blockquote><pre>
transform_sender(<i>get-domain-early</i>(sndr), <i>make-sender</i>(continues_on, sch, sndr))
</pre></blockquote>
<p>
In this expression the evaluation of <code><i>get-domain-early</i>(sndr)</code> can happen before or after 
the <code><i>make-sender</i></code>. The latter can steal the value from <code class='backtick'>sndr</code> by moving from it. So 
<code><i>get-domain-early</i></code> may see the moved-from state of <code class='backtick'>sndr</code> and fail to obtain anything.
<p/>
Repetitions are at least in:
</p>
<ol>
<li><p>33.9.12.9 <a href="https://timsong-cpp.github.io/cppwp/exec.then">[exec.then]</a> p3</p></li>
<li><p>33.9.12.10 <a href="https://timsong-cpp.github.io/cppwp/exec.let">[exec.let]</a> p4</p></li>
<li><p>33.9.12.11 <a href="https://timsong-cpp.github.io/cppwp/exec.bulk">[exec.bulk]</a> p2</p></li>
<li><p> [exec.split] p4</p></li>
<li><p>33.9.12.12 <a href="https://timsong-cpp.github.io/cppwp/exec.when.all">[exec.when.all]</a> p3</p></li>
<li><p>33.9.12.13 <a href="https://timsong-cpp.github.io/cppwp/exec.into.variant">[exec.into.variant]</a> p3</p></li>
<li><p>33.9.12.14 <a href="https://timsong-cpp.github.io/cppwp/exec.stopped.opt">[exec.stopped.opt]</a> p2</p></li>
<li><p>33.9.12.15 <a href="https://timsong-cpp.github.io/cppwp/exec.stopped.err">[exec.stopped.err]</a> p2</p></li>
<li><p>33.9.13.2 <a href="https://timsong-cpp.github.io/cppwp/exec.sync.wait.var">[exec.sync.wait.var]</a> p1</p></li>
</ol>


<p id="res-4213"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4214"><a href="4214">4214</a>. Missing <i>Preconditions</i> for <code>take</code>/<code>drop</code> adaptor</h3>
<p><b>Section:</b> 25.7.10.1 <a href="https://timsong-cpp.github.io/cppwp/range.take.overview">[range.take.overview]</a>, 25.7.12.1 <a href="https://timsong-cpp.github.io/cppwp/range.drop.overview">[range.drop.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-02-15 <b>Last modified:</b> 2025-02-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.take.overview">active issues</a> in [range.take.overview].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.take.overview">issues</a> in [range.take.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>take</code>/<code>drop</code> adaptor does not explicitly require <i>N</i> to be non-negative (although
the view class does), which makes it possible for some specialized cases to be well-defined when <i>N</i> is negative, 
since no <i>Preconditions</i> are violated:</p>
<blockquote><pre>
auto e = std::views::empty&lt;int&gt; 
       | std::views::take(-1);   // []
auto i = std::views::iota(1, 5)
       | std::views::drop(-1);   // [0, 1, 2, 3, 4]
auto r = std::views::repeat('a', 2)
       | std::views::drop(-1);   // ['a', 'a', 'a']
</pre></blockquote>
<p>
This is not the intention, we should ban these cases.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 25.7.10.1 <a href="https://timsong-cpp.github.io/cppwp/range.take.overview">[range.take.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::take</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Let <code>E</code> and <code>F</code> be expressions, let <code>T</code> be
<code>remove_cvref_t&lt;decltype((E))&gt;</code>, and let <code>D</code> be 
<code>range_difference_t&lt;decltype((E))&gt;</code>.
If <code>decltype((F))</code> does not model <code>convertible_to&lt;D&gt;</code>,
<code>views::take(E, F)</code> is ill-formed. Otherwise, the expression <code>views::take(E, F)</code> 
is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.?) <ins>&mdash; <i>Preconditions</i>: <code>static_cast&lt;D&gt;(F) &gt;= 0</code> is <code>true</code>.</ins>
</p></li>
<li><p>(2.1) &mdash; if <code>T</code> is a specialization of <code>empty_view</code> (25.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.empty.view">[range.empty.view]</a>),
then <code>((void)F, <i>decay-copy</i>(E))</code>, except that the evaluations of <code>E</code>
and <code>F</code> are indeterminately sequenced.
</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify 25.7.12.1 <a href="https://timsong-cpp.github.io/cppwp/range.drop.overview">[range.drop.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::drop</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Let <code>E</code> and <code>F</code> be expressions, let <code>T</code> be
<code>remove_cvref_t&lt;decltype((E))&gt;</code>, and let <code>D</code> be 
<code>range_difference_t&lt;decltype((E))&gt;</code>.
If <code>decltype((F))</code> does not model <code>convertible_to&lt;D&gt;</code>,
<code>views::drop(E, F)</code> is ill-formed. Otherwise, the expression <code>views::drop(E, F)</code> 
is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.?) <ins>&mdash; <i>Preconditions</i>: <code>static_cast&lt;D&gt;(F) &gt;= 0</code> is <code>true</code>.</ins>
</p></li>
<li><p>(2.1) &mdash; if <code>T</code> is a specialization of <code>empty_view</code> (25.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.empty.view">[range.empty.view]</a>),
then <code>((void)F, <i>decay-copy</i>(E))</code>, except that the evaluations of <code>E</code>
and <code>F</code> are indeterminately sequenced.
</p></li>
</ol>
</blockquote>
</li>

</ol>

</blockquote>

<p><i>[2025-02-24]</i></p>

<p>
Upon reflector discussion many preferred to use instead the new <i>Hardened preconditions:</i> element which 
have been introduced by the recently voted in <a href="https://wg21.link/P3471R4" title=" Standard Library Hardening">P3471R4</a>.
</p>


<p id="res-4214"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a> plus additions from <a href="https://wg21.link/P3471R4" title=" Standard Library Hardening">P3471R4</a>.
</p>

<ol>
<li><p>Modify 25.7.10.1 <a href="https://timsong-cpp.github.io/cppwp/range.take.overview">[range.take.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::take</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Let <code>E</code> and <code>F</code> be expressions, let <code>T</code> be
<code>remove_cvref_t&lt;decltype((E))&gt;</code>, and let <code>D</code> be 
<code>range_difference_t&lt;decltype((E))&gt;</code>.
If <code>decltype((F))</code> does not model <code>convertible_to&lt;D&gt;</code>,
<code>views::take(E, F)</code> is ill-formed. Otherwise, the expression <code>views::take(E, F)</code> 
is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.?) <ins>&mdash; <i>Hardened preconditions</i>: <code>static_cast&lt;D&gt;(F) &gt;= 0</code> is <code>true</code>.</ins>
</p></li>
<li><p>(2.1) &mdash; if <code>T</code> is a specialization of <code>empty_view</code> (25.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.empty.view">[range.empty.view]</a>),
then <code>((void)F, <i>decay-copy</i>(E))</code>, except that the evaluations of <code>E</code>
and <code>F</code> are indeterminately sequenced.
</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify 25.7.12.1 <a href="https://timsong-cpp.github.io/cppwp/range.drop.overview">[range.drop.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::drop</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Let <code>E</code> and <code>F</code> be expressions, let <code>T</code> be
<code>remove_cvref_t&lt;decltype((E))&gt;</code>, and let <code>D</code> be 
<code>range_difference_t&lt;decltype((E))&gt;</code>.
If <code>decltype((F))</code> does not model <code>convertible_to&lt;D&gt;</code>,
<code>views::drop(E, F)</code> is ill-formed. Otherwise, the expression <code>views::drop(E, F)</code> 
is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.?) <ins>&mdash; <i>Hardened preconditions</i>: <code>static_cast&lt;D&gt;(F) &gt;= 0</code> is <code>true</code>.</ins>
</p></li>
<li><p>(2.1) &mdash; if <code>T</code> is a specialization of <code>empty_view</code> (25.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/range.empty.view">[range.empty.view]</a>),
then <code>((void)F, <i>decay-copy</i>(E))</code>, except that the evaluations of <code>E</code>
and <code>F</code> are indeterminately sequenced.
</p></li>
</ol>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4215"><a href="4215">4215</a>. <code class='backtick'>run_loop::finish</code> should be <code class='backtick'>noexcept</code></h3>
<p><b>Section:</b> 33.12.1 <a href="https://timsong-cpp.github.io/cppwp/exec.run.loop">[exec.run.loop]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2025-02-13 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Imported from <a href="https://github.com/cplusplus/sender-receiver/issues/329">cplusplus/sender-receiver #329</a>.
</p>
<p>
<code class='backtick'>run_loop::finish</code> puts the <code class='backtick'>run_loop</code> into the <code><i>finishing</i></code> state so that the next 
time the work queue is empty, <code class='backtick'>run_loop::run</code> will return instead of waiting for more work.
<p/>
Calling <code class='backtick'>.finish()</code> on a <code class='backtick'>run_loop</code> instance can potentially throw (<code class='backtick'>finish()</code> is not marked <code class='backtick'>noexcept</code>), 
that is because one valid implementation involves acquiring a lock on a <code class='backtick'>std::mutex</code> &mdash; a potentially throwing operation.
<p/>
But failing to put the <code class='backtick'>run_loop</code> into the <code><i>finishing</i></code> state is problematic in the same way 
that a failing destructor is problematic: shutdown and clean-up code depends on it succeeding.
<p/>
Consider <code class='backtick'>sync_wait</code>'s use of <code class='backtick'>run_loop</code>:
</p>
<blockquote><pre>
<i>sync-wait-state</i>&lt;Sndr&gt; state;
auto op = connect(sndr, <i>sync-wait-receiver</i>&lt;Sndr&gt;{&amp;state});
start(op);

state.loop.run();
if (state.error) {
  rethrow_exception(std::move(state.error));
}
return std::move(state.result);
</pre></blockquote>
<p>
It is the job of <code><i>sync-wait-receiver</i></code> to put the <code class='backtick'>run_loop</code> into the <code><i>finishing</i></code> state 
so that the invocation of <code class='backtick'>state.loop.run()</code> will return. It does that in its completion functions, like so:
</p>
<blockquote><pre>
void set_stopped() &amp;&amp; noexcept;
</pre>
<blockquote>
<p>
<i>Effects</i>: Equivalent to <code>state-&gt;loop.finish()</code>.
</p>
</blockquote>
</blockquote>
<p>
Here we are not handling the fact that <code>state-&gt;loop.finish()</code> is potentially throwing. Given that this 
function is <code class='backtick'>noexcept</code>, this will lead to the application getting terminated. Not good.
<p/>
But even if we handle the exception and save it into <code class='backtick'>state.result</code> to be rethrown later, we still have a problem. 
Since <code class='backtick'>run_loop::finish()</code> threw, the <code class='backtick'>run_loop</code> has not been placed into the <code><i>finishing</i></code> state. 
That means that <code class='backtick'>state.loop.run()</code> will never return, and <code class='backtick'>sync_wait</code> will hang forever.
<p/>
Simply put, <code class='backtick'>run_loop::finish()</code> has to be <code class='backtick'>noexcept</code>. The implementation must find a way to put the <code class='backtick'>run_loop</code> 
into the <code><i>finishing</i></code> state. If it cannot, it should terminate. Throwing an exception and foisting the 
problem on the caller &mdash; who has no recourse &mdash; is simply wrong.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
"If this can call <code class='backtick'>terminate()</code>, we should explicitly say so
(c.f. 32.7.4 <a href="https://timsong-cpp.github.io/cppwp/thread.condition.condvar">[thread.condition.condvar]</a> p11)"
</p>



<p id="res-4215"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 33.12.1.1 <a href="https://timsong-cpp.github.io/cppwp/exec.run.loop.general">[exec.run.loop.general]</a> as indicated:</p>

<blockquote><pre>
namespace std::execution {
  class run_loop {
    <i>// 33.12.1.2 <a href="https://timsong-cpp.github.io/cppwp/exec.run.loop.types">[exec.run.loop.types]</a>, associated types</i>
    class <i>run-loop-scheduler</i>; <i>// exposition only</i>
    class <i>run-loop-sender</i>;    <i>// exposition only</i>
    struct <i>run-loop-opstate-base</i> { <i>// exposition only</i>
      virtual void <i>execute</i>() = 0;  <i>// exposition only</i>
      run_loop* <i>loop</i>;              <i>// exposition only</i>
      run-loop-opstate-base* <i>next</i>; <i>// exposition only</i>
    };
    template&lt;class Rcvr&gt;
      using <i>run-loop-opstate</i> = <i>unspecified</i>; <i>// exposition only</i>

    <i>// 33.12.1.4 <a href="https://timsong-cpp.github.io/cppwp/exec.run.loop.members">[exec.run.loop.members]</a>, member functions</i>
    <i>run-loop-opstate-base</i>* <i>pop-front</i>(); <i>// exposition only</i>
    void <i>push-back</i>(<i>run-loop-opstate-base</i>*); <i>// exposition only</i>

  public:
    <i>// 33.12.1.3 <a href="https://timsong-cpp.github.io/cppwp/exec.run.loop.ctor">[exec.run.loop.ctor]</a>, constructor and destructor</i>
    run_loop() noexcept;
    run_loop(run_loop&amp;&amp;) = delete;
    ~run_loop();

    <i>// 33.12.1.4 <a href="https://timsong-cpp.github.io/cppwp/exec.run.loop.members">[exec.run.loop.members]</a>, member functions</i>
    <i>run-loop-scheduler</i> get_scheduler();
    void run();
    void finish() <ins>noexcept</ins>;
  };
}
</pre></blockquote>
</li>

<li><p>Modify 33.12.1.4 <a href="https://timsong-cpp.github.io/cppwp/exec.run.loop.members">[exec.run.loop.members]</a> as indicated:</p>

<blockquote>
<pre>
void finish() <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-8- <i>Preconditions</i>: <code><i>state</i></code> is either <code><i>starting</i></code> or <code><i>running</i></code>.
<p/>
-9- <i>Effects</i>: Changes <code><i>state</i></code> to <code><i>finishing</i></code>.
<p/>
-10- <i>Synchronization</i>: <code class='backtick'>finish</code> synchronizes with the <code><i>pop-front</i></code> operation that returns <code>nullptr</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4216"><a href="4216">4216</a>. <code class='backtick'>num_put::do_put</code> and <code class='backtick'>void</code> pointers</h3>
<p><b>Section:</b> 28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nikolas Klauser <b>Opened:</b> 2025-02-26 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code class='backtick'>num_put::do_put</code> overloads are defined in terms of <code class='backtick'>printf</code>.
However, it is not clear what the intended behaviour of pointers is.
<p/>
While the <code class='backtick'>num_put</code> wording makes a quite clear statement that it should
be whatever <code class='backtick'>printf("%p", ptr)</code> would be, <code class='backtick'>num_get</code> is entirely silent
on which function should be used. This makes it entirely unclear whether
round-tripping is supposed to work. It's also not clear whether
<code class='backtick'>num_put</code> was just simple to specify via <code class='backtick'>printf</code> or whether the intent
was that the output matches in all cases. Round-tripping between
<code class='backtick'>num_put</code> and <code class='backtick'>num_get</code> was broken in libc++ until recently. However, to
fix that, the output of <code class='backtick'>num_put::do_put</code> no longer matches the libc's
<code class='backtick'>printf</code> in all cases. libstdc++ had this behaviour since at least two
decades, indicating that nobody seems to have a problem with
<code class='backtick'>num_put::do_put</code> and <code class='backtick'>printf</code> having different results in some rare cases.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
We could emphasize that calling <code class='backtick'>printf</code> isn't actually intended:
<blockquote>
The representations at the end of stage 1 consists of the <code class='backtick'>char</code>'s
that would be printed by a call of <code class='backtick'>printf(s, val)</code>
<ins>in a hypothetical implementation</ins>,
where <code class='backtick'>s</code> is the conversion specifier determined above.
</blockquote>
</p>
<p>
Why is there an apostrophe in <code class='backtick'>char</code>'s?
</p>



<p id="res-4216"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 28.3.4.3.3.3 <a href="https://timsong-cpp.github.io/cppwp/facet.num.put.virtuals">[facet.num.put.virtuals]</a> as indicated:</p>

<blockquote>
<pre>
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill, long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill, long long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill, unsigned long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill, unsigned long long val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill, double val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill, long double val) const;
iter_type do_put(iter_type out, ios_base&amp; str, char_type fill, const void* val) const;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: [&hellip;]
<p/>
-2- The details of this operation occur in several stages: [&hellip;]
<p/>
-3- Detailed descriptions of each stage follow.
<p/>
-4- <i>Returns</i>: <code>out</code>.
<p/>
<b>Stage 1</b>: The first action of stage 1 is to determine a conversion specifier. [&hellip;]
<p/>
For conversion from <code class='backtick'>void*</code> the specifier is <code class='backtick'>%p</code>.
<p/>
The representations at the end of stage 1 consists of the <code class='backtick'>char</code>'s that would be printed by a call of
<code class='backtick'>printf(s, val)</code> where <code class='backtick'>s</code> is the conversion specifier determined above<ins>, except that any 
implementation-defined behavior of <code class='backtick'>printf</code> may be different from a call to <code class='backtick'>printf</code></ins>.
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4218"><a href="4218">4218</a>. Constraint recursion in <code class='backtick'>basic_const_iterator</code>'s relational operators due to ADL + CWG 2369</h3>
<p><b>Section:</b> 24.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.ops">[const.iterators.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Patrick Palka <b>Opened:</b> 2025-03-03 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the example (devised by Hewill Kang)
</p>
<blockquote><pre>
using RCI = reverse_iterator&lt;basic_const_iterator&lt;vector&lt;int&gt;::iterator&gt;&gt;;
static_assert(std::totally_ordered&lt;RCI&gt;);
</pre></blockquote>
<p>
Checking <code class='backtick'>RCI</code> is <code class='backtick'>totally_ordered</code> entails checking
</p>
<blockquote><pre>
requires (RCI x) { x <i>RELOP</i> x; } for each <i>RELOP</i> in {&lt;, &gt;, &lt;=, &gt;=}
</pre></blockquote>
<p>
which we expect to be straightforwardly satisfied by <code class='backtick'>reverse_iterator</code>'s
namespace-scope operators (24.5.1.8 <a href="https://timsong-cpp.github.io/cppwp/reverse.iter.cmp">[reverse.iter.cmp]</a>):
</p>
<blockquote><pre>
template&lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;Iterator1&gt;&amp; x,
    const reverse_iterator&lt;Iterator2&gt;&amp; y);
// etc
</pre></blockquote>
<p>
But due to ADL we find ourselves also considering the <code class='backtick'>basic_const_iterator</code>
relop friends (24.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.ops">[const.iterators.ops]</a>/24).
</p>
<blockquote><pre>
template&lt;input_iterator Iterator&gt;
class basic_const_iterator {
  template&lt;<i>not-a-const-iterator</i> I&gt;
    friend constexpr bool operator&lt;(const I&amp; x, const basic_const_iterator&amp; y)
      requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;
  // etc
};
</pre></blockquote>
<p>
Before <a href="https://wg21.link/cwg2369">CWG 2369</a> these candidates would quickly get 
discarded since for the second operand RCI clearly isn't convertible to <code class='backtick'>basic_const_iterator</code>.  
But after CWG 2369 implementations must first check these operators' constraints
(with <code>Iterator = vector&lt;int&gt;::iterator</code> and <code>I = RCI</code>), which entails 
checking <code>totally_ordered&lt;RCI&gt;</code> recursively, causing the example to be ill-formed.
<p/>
The constraint recursion is diagnosed by GCC (<a href="https://godbolt.org/z/dr1dK1dnj">See godbolt demo</a>).
Other compilers accept the example because they don't implement CWG 2369, as
far as I know.
<p/>
GCC trunk works around this issue by giving these friend relational operators
a dependent second operand of the form <code>basic_const_iterator&lt;J&gt;</code> where <code class='backtick'>J</code> is
constrained to match <code class='backtick'>Iterator</code>:
</p>
<blockquote><pre>
template&lt;<i>not-a-const-iterator</i> I, same_as&lt;Iterator&gt; J>
  friend constexpr bool operator&lt;(const I&amp; x, const basic_const_iterator&lt;J&gt;&amp; y)
    requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;
// etc
</pre></blockquote>
<p>
So that deduction fails earlier, before constraints get checked, for a second
operand that isn't a specialization of <code class='backtick'>basic_const_iterator</code> (or derived from one).
<p/>
LWG <a href="3769" title="basic_const_iterator::operator== causes infinite constraint recursion (Status: C++23)">3769</a> is an earlier issue about constraint recursion in <code class='backtick'>basic_const_iterator</code>'s
operators, but there the recursion was independent of CWG 2369.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p id="res-4218"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>
<li><p>Modify 24.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.iterator">[const.iterators.iterator]</a>, class template <code class='backtick'>basic_const_iterator</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  template&lt;input_iterator Iterator&gt;
  class basic_const_iterator {
    [&hellip;]
    template&lt;<i>not-a-const-iterator</i> I<ins>, same_as&lt;Iterator&gt; J</ins>&gt;
      friend constexpr bool operator&lt;(const I&amp; x, const basic_const_iterator<ins>&lt;J&gt;</ins>&amp; y)
        requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;;
    template&lt;<i>not-a-const-iterator</i> I<ins>, same_as&lt;Iterator&gt; J</ins>&gt;
      friend constexpr bool operator&gt;(const I&amp; x, const basic_const_iterator<ins>&lt;J&gt;</ins>&amp; y)
        requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;;
    template&lt;<i>not-a-const-iterator</i> I<ins>, same_as&lt;Iterator&gt; J</ins>&gt;
      friend constexpr bool operator&lt;=(const I&amp; x, const basic_const_iterator<ins>&lt;J&gt;</ins>&amp; y)
        requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;;
    template&lt;<i>not-a-const-iterator</i> I<ins>, same_as&lt;Iterator&gt; J</ins>&gt;
      friend constexpr bool operator&gt;=(const I&amp; x, const basic_const_iterator<ins>&lt;J&gt;</ins>&amp; y)
        requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 24.5.3.5 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.ops">[const.iterators.ops]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>not-a-const-iterator</i> I<ins>, same_as&lt;Iterator&gt; J</ins>&gt;
  friend constexpr bool operator&lt;(const I&amp; x, const basic_const_iterator<ins>&lt;J&gt;</ins>&amp; y)
    requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;;
template&lt;<i>not-a-const-iterator</i> I<ins>, same_as&lt;Iterator&gt; J</ins>&gt;
  friend constexpr bool operator&gt;(const I&amp; x, const basic_const_iterator<ins>&lt;J&gt;</ins>&amp; y)
    requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;;
template&lt;<i>not-a-const-iterator</i> I<ins>, same_as&lt;Iterator&gt; J</ins>&gt;
  friend constexpr bool operator&lt;=(const I&amp; x, const basic_const_iterator<ins>&lt;J&gt;</ins>&amp; y)
    requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;;
template&lt;<i>not-a-const-iterator</i> I<ins>, same_as&lt;Iterator&gt; J</ins>&gt;
  friend constexpr bool operator&gt;=(const I&amp; x, const basic_const_iterator<ins>&lt;J&gt;</ins>&amp; y)
    requires random_access_iterator&lt;Iterator&gt; &amp;&amp; totally_ordered_with&lt;Iterator, I&gt;;
</pre>
<blockquote>
<p>
-23- Let <code><i>op</i></code> be the operator.
<p/>
-24- <i>Effects</i>: Equivalent to: <code>return x <i>op</i> y.<i>current_</i>;</code>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4219"><a href="4219">4219</a>. <code>std::vector::erase[_if]</code> should be based on ranges <code class='backtick'>remove</code></h3>
<p><b>Section:</b> 23.3.13.6 <a href="https://timsong-cpp.github.io/cppwp/vector.erasure">[vector.erasure]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Kasting <b>Opened:</b> 2025-03-05 <b>Last modified:</b> 2025-03-09</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C++20 added <code>std::vector::erase[_if]</code>. Per 23.3.13.6 <a href="https://timsong-cpp.github.io/cppwp/vector.erasure">[vector.erasure]</a>, these are equivalent 
to a call to <code>std::remove[_if]</code> followed by an appropriate <code>erase</code>.
<p/>
This is unfortunate, because <code class='backtick'>std::remove_if</code> is specified (by 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>) as invoking 
its predicate as <code class='backtick'>pred(*i)</code>, while <code class='backtick'>std::ranges::remove_if</code> uses the more flexible 
<code class='backtick'>invoke(pred, invoke(proj, *i))</code>. Disregarding the projection, the latter allows the use of member function 
pointers as predicates, while the former does not.
<p/>
I assume the committee intentionally did not change the non-ranges version to use <code class='backtick'>invoke</code> because it 
caused a backwards-compatibility risk. (If I am mistaken and this was an oversight, perhaps this and 
other non-ranges algorithms that take predicates should be updated to use invoke() to invoke them.)
<p/>
If that's true, though, it's perplexing why a new-to-c++20 function like <code class='backtick'>std::vector::erase_if</code> 
should suffer the same drawback.
</p>


<p id="res-4219"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>

<li><p>Modify 23.3.13.6 <a href="https://timsong-cpp.github.io/cppwp/vector.erasure">[vector.erasure]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class Allocator, class U = T&gt;
  constexpr typename vector&lt;T, Allocator&gt;::size_type
    erase(vector&lt;T, Allocator&gt;&amp; c, const U&amp; value);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto <ins>r</ins><del>it</del> = <ins>ranges::</ins>remove(c<del>.begin(), c.end()</del>, value);
<del>auto r = distance(it, c.end());</del>
c.erase(<ins>r.begin()</ins><del>it</del>, <ins>r</ins><del>c</del>.end());
return r<ins>.size()</ins>;
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class Allocator, class Predicate&gt;
  constexpr typename vector&lt;T, Allocator&gt;::size_type
    erase_if(vector&lt;T, Allocator&gt;&amp; c, Predicate pred);
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto <ins>r</ins><del>it</del> = <ins>ranges::</ins>remove_if(c<del>.begin(), c.end()</del>, pred);
<del>auto r = distance(it, c.end());</del>
c.erase(<ins>r.begin()</ins><del>it</del>, <ins>r</ins><del>c</del>.end());
return r<ins>.size()</ins>;
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4220"><a href="4220">4220</a>. <code>join_view</code> incorrectly stores inner range</h3>
<p><b>Section:</b> 25.7.14.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.view">[range.join.view]</a>, 25.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.view">[range.join.with.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-03-06 <b>Last modified:</b> 2025-03-09</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.view">active issues</a> in [range.join.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.view">issues</a> in [range.join.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When the inner range is a prvalue, <code>join_view</code> removes its <i>cv</i>-qualifiers
and stores it in the <code><i>propagating-cache</i></code>, which is not quite right as the inner range may
only be const-iterable (<a href="https://godbolt.org/z/qY1bhExzG">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

struct R {
  int* begin() = delete;
  int* end() = delete;
  const int* begin() const;
  const int* end() const;
};

int main() {
  auto r = std::views::iota(0, 5)
         | std::views::transform([](int) -> const R { return {}; })
         | std::views::join;
  auto b = r.begin(); // <span style="color:red;font-weight:bolder">hard error</span>
}
</pre></blockquote>
<p>
The proposed resolution preserves the inner range's original qualifiers, which is consistent with how
<code>cache_latest_view</code> stores the reference when it is a prvalue.
The same goes for <code>join_with_view</code>.
</p>


<p id="res-4220"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<ol>

<li><p>Modify 25.7.14.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.view">[range.join.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;&gt;
  class join_view : public view_interface&lt;join_view&lt;V&gt;&gt; {
  private:
    using <i>InnerRng</i> = range_reference_t&lt;V&gt;;                  // <i>exposition only</i>
    [&hellip;]
    <i>non-propagating-cache</i>&lt;<del>remove_cv_t&lt;</del><i>InnerRng</i><del>&gt;</del>&gt; <i>inner_</i>;    // <i>exposition only, present only</i>
                                                            // <i>if is_reference_v&lt;<i>InnerRng</i>&gt; is false</i>

  public:
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.view">[range.join.with.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt;
          &amp;&amp; <i>concatable</i>&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  class join_with_view : public view_interface&lt;join_with_view&lt;V, Pattern&gt;&gt; {
    using <i>InnerRng</i> = range_reference_t&lt;V&gt;;                 // <i>exposition only</i>
    [&hellip;]
    <i>non-propagating-cache</i>&lt;<del>remove_cv_t&lt;</del><i>InnerRng</i><del>&gt;</del>&gt; <i>inner_</i>;   // <i>exposition only, present only</i>
                                                           // <i>if is_reference_v&lt;<i>InnerRng</i>&gt; is false</i>

    [&hellip;]
  public:
    [&hellip;]
  };
  [&hellip;]
}

</pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4221"><a href="4221">4221</a>. Cannot format const-iterable only ranges</h3>
<p><b>Section:</b> 28.5.7 <a href="https://timsong-cpp.github.io/cppwp/format.range">[format.range]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-03-06 <b>Last modified:</b> 2025-03-09</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard does not explicitly prohibit ranges that are only const-iterable, i.e. a range with
<code>const begin()</code> and deleted or invalid non-<code>const begin()</code>.
</p>
<p>
Unfortunately, those ranges cannot be formatted because the <code>R</code> in
<code>formatter&lt;R&gt;</code> is always without the <code>const</code>-qualifier,
which makes it never satisfy the <code>range</code> concept
(<a href="https://godbolt.org/z/68T6EjKG4">demo</a>):
</p>
<blockquote><pre>
#include &lt;print&gt;
#include &lt;ranges&gt;

struct R {
  int* begin() = delete;
  int* end() = delete;
  const int* begin() const;
  const int* end() const;
};

int main() {
  const R r;
  static_assert(std::ranges::contiguous_range&lt;decltype(r)&gt;);

  for (auto&amp;&amp; elem : r)
    std::print("{} ", elem); // ok

  std::ranges::for_each(
    r, [](auto&amp;&amp; elem) { std::print("{} ", elem); }
  );                         // ok

  std::print("{}", r);       // <span style="color:red;font-weight:bolder">not ok</span>
}
</pre></blockquote>
<p>
Although such type might be relatively rare, it does reflect an inconsistency in the general usage of formatting
ranges, which do not support all valid ranges.
</p>


<p id="res-4221"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4223"><a href="4223">4223</a>. Deduction guides for maps are mishandling tuples and references</h3>
<p><b>Section:</b> 23.4.1 <a href="https://timsong-cpp.github.io/cppwp/associative.general">[associative.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kaminski <b>Opened:</b> 2025-03-14 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code class='backtick'>from_range</code> deduction guide for maps currently do not handle ranges of tuple of two elements:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v;
auto zv = std::views::zip(v, v);
std::map m4(std::from_range, zv); // <span style="color:red;font-weight:bolder">Ill-formed, no-deduction guide</span>
</pre></blockquote>
<p>
This seems to be result of merge conflict between <a href="https://wg21.link/P2165" title=" Compatibility between tuple, pair and tuple-like objects">P2165</a> (Compatibility between tuple, pair and tuple-like objects) 
and <a href="https://wg21.link/P1206R4" title=" Conversions from ranges to containers">P1206R4</a> (Conversions from ranges to containers): The helper <code><i>range-key-type</i></code> and 
<code><i>range-mapped-type</i></code> aliases introduced by the later use the old formulation of <code class='backtick'>::first_type</code>, 
<code class='backtick'>::second::type</code> instead of <code class='backtick'>tuple_element</code>.
<p/>
Furthermore, both iterator and range deduction guides do not correctly handle iterators with a pair of references as 
value types, and deduce key or value type as reference, which is ill-formed:
</p>
<blockquote><pre>
std::flat_map&lt;int, float&gt; fm; // iterator value_type is pair&lt;int, float&gt;
std::map m1(fm.begin(), fm.end()); // OK, deduces std::map&lt;int, float&gt;

auto tv = fm | std::views::transform(std::identity{}); // iterator value value_type is pair&lt;int const&amp;, float const&amp;&gt;
std::map m3(tv.begin(), tv.end()); // <span style="color:red;font-weight:bolder">Ill-formed, deduces std::map&lt;int const&amp;, float&amp;&gt;</span>
</pre></blockquote>


<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p id="res-4223"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5001" title=" Working Draft, Programming Languages  C++">N5001</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The proposed change also strips <code class='backtick'>const</code> from the value type of the <code class='backtick'>map</code>, 
changing the behavior of previously working code:
</p>
<blockquote><pre>
std::pair&lt;int const, float const&gt; tp[2];
std::map m(std::begin(tp), std::end(tp)); // Was std::map&lt;int, float const&gt;, now std::map&lt;int, float&gt;
</pre></blockquote>
]
</blockquote>

<ol>

<li><p>Modify 23.4.1 <a href="https://timsong-cpp.github.io/cppwp/associative.general">[associative.general]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator&gt;
  using <i>iter-value-type</i> =
    typename iterator_traits&lt;InputIterator&gt;::value_type; // <i>exposition only</i>

template&lt;class InputIterator&gt;
  using <i>iter-key-type</i> = <del>remove_const_t</del><ins>remove_cvref_t</ins>&lt;
    tuple_element_t&lt;0, <i>iter-value-type</i>&lt;InputIterator&gt;&gt;&gt;; // <i>exposition only</i>

template&lt;class InputIterator&gt;
  using <i>iter-mapped-type</i> = <ins>remove_cvref_t&lt;</ins>
    tuple_element_t&lt;1, <i>iter-value-type</i>&lt;InputIterator&gt;&gt;<ins>&gt;</ins>; // <i>exposition only</i>

template&lt;class InputIterator&gt;
  using <i>iter-to-alloc-type</i> = pair&lt;
    add_const_t&lt;
      <del>tuple_element_t&lt;0, <i>iter-value-type</i>&lt;InputIterator&gt;&gt;</del>
      <ins><i>iter-key-type</i>&lt;InputIterator&gt;</ins>
    &gt;,
    <del>tuple_element_t&lt;1, <i>iter-value-type</i>&lt;InputIterator&gt;&gt;</del>
    <ins><i>iter-mapped-type</i>&lt;InputIterator&gt;</ins>
    &gt;; // <i>exposition only</i>

template&lt;ranges::input_range Range&gt;
  using <i>range-key-type</i> =
    <del>remove_const_t&lt;typename ranges::range_value_t&lt;Range&gt;::first_type&gt;</del>
    <ins>remove_cvref_t&lt;tuple_element_t&lt;0, ranges::range_value_t&lt;Range&gt;&gt;&gt;</ins>; // <i>exposition only</i>

template&lt;ranges::input_range Range&gt;
  using <i>range-mapped-type</i> = 
    <del>typename ranges::range_value_t&lt;Range&gt;::second_type</del>
    <ins>remove_cvref_t&lt;tuple_element_t&lt;1, ranges::range_value_t&lt;Range&gt;&gt;&gt;</ins>; // <i>exposition only</i>

template&lt;ranges::input_range Range&gt;
  using <i>range-to-alloc-type</i> =
    pair&lt;add_const_t&lt;
      <del>typename ranges::range_value_t&lt;Range&gt;::first_type</del>
      <ins><i>range-key-type</i>&lt;Range&gt;</ins>
    &gt;,
    <del>typename ranges::range_value_t&lt;Range&gt;::second_type</del>
    <ins><i>range-mapped-type</i>&lt;Range&gt;</ins>
    &gt;; // <i>exposition only</i>
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4225"><a href="4225">4225</a>. What should happen when an exception is thrown on resizing <code class='backtick'>std::deque</code>, <code class='backtick'>std::forward_list</code>, or <code class='backtick'>std::list</code>?</h3>
<p><b>Section:</b> 23.3.5.3 <a href="https://timsong-cpp.github.io/cppwp/deque.capacity">[deque.capacity]</a>, 23.3.7.5 <a href="https://timsong-cpp.github.io/cppwp/forward.list.modifiers">[forward.list.modifiers]</a>, 23.3.11.3 <a href="https://timsong-cpp.github.io/cppwp/list.capacity">[list.capacity]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-03-15 <b>Last modified:</b> 2025-03-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#deque.capacity">issues</a> in [deque.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>std::vector</code> and <code class='backtick'>std::inplace_vector</code>'s <code class='backtick'>resize</code> functions are specified to have no effects 
on the container when an exception is throwing on appending. However, such specification seem to be missing 
for <code class='backtick'>std::deque</code>, <code class='backtick'>std::forward_list</code>, and <code class='backtick'>std::list</code>.
<p/>
Is such difference intented? Do we want to roll back the status of container when the appending is partially done?
<p/>
<b>Daniel:</b>
<p/>
The specific <code class='backtick'>resize</code> exception guarantee for <code class='backtick'>std::vector</code> came from resolving LWG <a href="2033" title="Preconditions of reserve, shrink_to_fit, and resize functions (Status: C++14)">2033</a> and were
later effectively copied to <code class='backtick'>std::inplace_vector</code> because that container's specification should resemble 
as much as possible that of <code class='backtick'>std::vector</code>.
</p>


<p id="res-4225"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4226"><a href="4226">4226</a>. <code>to_input_view::<i>iterator</i></code> cannot be compared to its <code class='backtick'>const</code> sentinel</h3>
<p><b>Section:</b> 25.7.35 <a href="https://timsong-cpp.github.io/cppwp/range.to.input">[range.to.input]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-03-15 <b>Last modified:</b> 2025-06-13</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>to_input_view</code> was recently added to the working draft by <a href="https://wg21.link/P3137R3" title=" views::to_input">P3137R3</a>.
<p/>
Consider: (<a href="https://godbolt.org/z/7s1hPscrG">demo</a>):
</p>
<blockquote><pre>
#include &lt;ranges&gt;

int main() {
  auto r = std::views::single(0)
         | std::views::chunk(1)
         | std::views::to_input;

  r.begin() == std::as_const(r).end(); // <span style="color:red;font-weight:bolder">#1, error</span>
  r.begin() ==               r.cend(); // <span style="color:red;font-weight:bolder">#2, error</span>
}
</pre></blockquote>
<p>
In <code>#1</code>, <code>r.begin()</code> returns <code>to_input_view&lt;chunk_view&gt;::<i>iterator</i>&lt;false&gt;</code>,
while the latter returns <code>chunk_view::<i>iterator</i>&lt;true&gt;</code>.
Since the former can only be compared with <code>chunk_view::<i>iterator</i>&lt;false&gt;</code> that cannot
be converted from <code>chunk_view::<i>iterator</i>&lt;true&gt;</code>, the two are incomparable.
<p/>
This can be fixed by adding the following overload to <code>to_input_view::<i>iterator</i></code>:
</p>
<blockquote><pre>
template&lt;bool OtherConst = !Const&gt;
  requires sentinel_for&lt;sentinel_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;, iterator_t&lt;<i>Base</i>&gt;&gt;
friend constexpr bool operator==(const <i>iterator</i>&amp; x, const sentinel_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&amp; y)
{ return x.<i>current_</i> == y; }
</pre></blockquote>
<p>
Unfortunately, it still doesn't resolve <code>#2</code>, because <code>r.cend()</code> returns
<code>basic_const_iterator&lt;chunk_view::iterator&lt;true&gt;&gt;</code>, which cannot be compared to any
non-copyable iterators as its <code>operator==(const S&amp; s)</code> requires <code>S</code> to be a 
sentinel type, which rules out <code>to_input_view::<i>iterator</i></code>, so the constraint is not satisfied.
<p/>
I believe we may need to introduce a custom sentinel class for <code>to_input_view</code>.
</p>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p id="res-4226"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 25.7.35.2 <a href="https://timsong-cpp.github.io/cppwp/range.to.input.view">[range.to.input.view]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt;
  class to_input_view : public view_interface&lt;to_input_view&lt;V&gt;&gt; {
    V <i>base_</i> = V();                          // <i>exposition only</i>

    template&lt;bool Const&gt;
    class <i>iterator</i>;                         // <i>exposition only</i>
    <ins>template&lt;bool Const&gt;
    class <i>sentinel</i>;                         // <i>exposition only</i></ins>
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr auto end() requires (!<i>simple-view</i>&lt;V&gt;);
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to:</ins>
</p>
<pre>
<ins>return <i>sentinel</i>&lt;false&gt;(ranges::end(<i>base_</i>));</ins>
</pre>
</blockquote>
<pre>
constexpr auto end() const requires range&lt;const V&gt;;
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: Equivalent to:
</p>
<pre>
return <ins><i>sentinel</i>&lt;true&gt;(</ins>ranges::end(<i>base_</i>)<ins>)</ins>;
</pre>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.35.3 <a href="https://timsong-cpp.github.io/cppwp/range.to.input.iterator">[range.to.input.iterator]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt;
  template&lt;bool Const&gt;
  class to_input_view&lt;V&gt;::<i>iterator</i> {
    [&hellip;]
    <del>friend constexpr bool operator==(const <i>iterator</i>&amp; x, const sentinel_t&lt;<i>Base</i>&gt;&amp; y);

    friend constexpr difference_type operator-(const sentinel_t&lt;<i>Base</i>&gt;&amp; y, const <i>iterator</i>&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>Base</i>&gt;&gt;;
    friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const sentinel_t&lt;<i>Base</i>&gt;&amp; y)
      requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>Base</i>&gt;&gt;;</del>
    [&hellip;]
  };
}
</pre>
</blockquote>
[&hellip;]
<pre><del>
friend constexpr bool operator==(const <i>iterator</i>&amp; x, const sentinel_t&lt;<i>Base</i>&gt;&amp; y);</del>
</pre>
<blockquote>
<p>
<del>-7- <i>Returns</i>: <code>x.<i>current_</i> == y</code>.</del>
</p>
</blockquote>
<pre><del>
friend constexpr difference_type operator-(const sentinel_t&lt;<i>Base</i>&gt;&amp; y, const <i>iterator</i>&amp; x)
  requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>Base</i>&gt;&gt;;</del>
</pre>
<blockquote>
<p>
<del>-8- <i>Returns</i>: <code>y - x.<i>current_</i></code>.</del>
</p>
</blockquote>
<pre><del>
friend constexpr difference_type operator-(const <i>iterator</i>&amp; x, const sentinel_t&lt;<i>Base</i>&gt;&amp; y)
  requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>Base</i>&gt;&gt;;</del>
</pre>
<blockquote>
<p>
<del>-9- <i>Returns</i>: <code>x.<i>current_</i> - y</code>.</del>
</p>
</blockquote>
</blockquote>
</li>


<li><p>Add [range.to.input.sentinel] after [range.to.input.iterator] as indicated:</p>

<blockquote>
<blockquote>
<pre><ins>
namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt;
  template&lt;bool Const&gt;
  class to_input_view&lt;V&gt;::<i>sentinel</i> {
    using <i>Base</i> = <i>maybe-const</i>&lt;Const, V&gt;;                         // <i>exposition only</i>
    sentinel_t&lt;<i>Base</i>&gt; <i>end_</i> = sentinel_t&lt;<i>Base</i>&gt;();                 // <i>exposition only</i>
    constexpr explicit <i>sentinel</i>(sentinel_t&lt;<i>Base</i>&gt; end);          // <i>exposition only</i>

  public:
    <i>sentinel</i>() = default;
    constexpr <i>sentinel</i>(<i>sentinel</i>&lt;!Const&gt; other)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;<i>Base</i>&gt;&gt;;

    constexpr sentinel_t&lt;Base&gt; base() const;

    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const <i>iterator</i>&lt;OtherConst&gt;&amp; x, const <i>sentinel</i>&amp; y);

    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;
      operator-(const <i>iterator</i>&lt;OtherConst&gt;&amp; x, const <i>sentinel</i>&amp; y);

    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;
      operator-(const <i>sentinel</i>&amp; x, const <i>iterator</i>&lt;OtherConst&gt;&amp; y);
  };
}</ins>
</pre>
</blockquote>
<pre><ins>
constexpr explicit <i>sentinel</i>(sentinel_t&lt;<i>Base</i>&gt; end);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes <code><i>end_</i></code> with <code>std::move(end)</code>.</ins>
</p>
</blockquote>
<pre><ins>
constexpr <i>sentinel</i>(<i>sentinel</i>&lt;!Const&gt; other)
  requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;<i>Base</i>&gt;&gt;;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes <code><i>end_</i></code> with <code>std::move(other.<i>end_</i>)</code>.</ins>
</p>
</blockquote>
<pre><ins>
constexpr sentinel_t&lt;Base&gt; base() const;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return <i>end_</i>;</code></ins>
</p>
</blockquote>
<pre><ins>
template&lt;bool OtherConst&gt;
  requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
friend constexpr bool operator==(const <i>iterator</i>&lt;OtherConst&gt;&amp; x, const <i>sentinel</i>&amp; y);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return x.<i>current_</i> == y.<i>end_</i>;</code></ins>
</p>
</blockquote>
<pre><ins>
template&lt;bool OtherConst&gt;
  requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
friend constexpr range_difference_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;
  operator-(const <i>iterator</i>&lt;OtherConst&gt;&amp; x, const <i>sentinel</i>&amp; y);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return x.<i>current_</i> - y.<i>end_</i>;</code></ins>
</p>
</blockquote>
<pre><ins>
template&lt;bool OtherConst&gt;
  requires sized_sentinel_for&lt;sentinel_t&lt;<i>Base</i>&gt;, iterator_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;&gt;
friend constexpr range_difference_t&lt;<i>maybe-const</i>&lt;OtherConst, V&gt;&gt;
  operator-(const <i>sentinel</i>&amp; x, const <i>iterator</i>&lt;OtherConst&gt;&amp; y);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Equivalent to: <code>return x.<i>end_</i> - y.<i>current_</i>;</code></ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4229"><a href="4229">4229</a>. <code class='backtick'>std::ranges::to</code> with union return type</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a>, 25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-03-20 <b>Last modified:</b> 2025-03-22</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="3847" title="ranges::to can still return views (Status: C++23)">3847</a> made <code class='backtick'>std::ranges::to</code> require the return type (or the target type for the overload 
returning range adaptor closure object) to be a <i>cv</i>-unqualified class type. Although the term 
"class type" in core language specification also covers union types, implementations (libstdc++ and MSVC STL) 
tend to implement this part of the <i>Mandates</i> only with <code class='backtick'>std::is_class_v</code>, which rejects union types.
<p/>
E.g. the following program is rejected by libstdc++ and MSVC STL 
(<a href="https://godbolt.org/z/MnsY4Tzen">https://godbolt.org/z/MnsY4Tzen</a>):
</p>
<blockquote><pre>
#include &lt;memory&gt;
#include &lt;ranges&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template&lt;class T, class A = std::allocator&lt;T&gt;&gt;
union weird_vector {
  std::vector&lt;T, A&gt; vec_;

  constexpr weird_vector() : vec_() {}
  constexpr weird_vector(const weird_vector&amp; other) : vec_(other.vec_) {}
  constexpr weird_vector(weird_vector&amp;&amp; other) noexcept : vec_(std::move(other.vec_)) {}

  template&lt;class U&gt;
    requires (!std::same_as&lt;std::remove_cvref_t&lt;U&gt;, weird_vector&gt;) &amp;&amp;
      (!std::same_as&lt;std::remove_cvref_t&lt;U&gt;, std::vector&lt;T, A&gt;&gt;) &amp;&amp;
      requires(U&amp;&amp; u) { std::vector&lt;T, A&gt;(std::forward&lt;U&gt;(u)); }
  constexpr explicit weird_vector(U&amp;&amp; u) : vec_(std::forward&lt;U&gt;(u)) {}

  template&lt;class T1, class T2, class... Ts&gt;
    requires requires(T1&amp;&amp; t1, T2&amp;&amp; t2, Ts&amp;&amp;... ts) {
      std::vector&lt;T, A&gt;(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2), std::forward&lt;Ts&gt;(ts)...);
    }
  constexpr weird_vector(T1&amp;&amp; t1, T2&amp;&amp; t2, Ts&amp;&amp;... ts)
    : vec_(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2), std::forward&lt;Ts&gt;(ts)...) {}

  constexpr weird_vector&amp; operator=(const weird_vector&amp; other) {
    vec_ = other.vec_;
    return *this;
  }
  constexpr weird_vector&amp; operator=(weird_vector&amp;&amp; other)
    noexcept(std::is_nothrow_move_assignable_v&lt;std::vector&lt;T, A&gt;&gt;) {
    vec_ = std::move(other.vec_);
    return *this;
  }

  constexpr ~weird_vector() {
    vec_.~vector();
  }
};

int main() {
  int arr[]{42, 1729};
  auto v [[maybe_unused]] = std::ranges::to&lt;weird_vector&lt;int&gt;&gt;(arr);
}
</pre></blockquote>
<p>
Although libc++ currently accepts this example, the acceptance seems to be a bug, because libc++ hasn't 
implemented the "class" part in the <i>Mandates</i> at all 
(<a href="https://github.com/llvm/llvm-project/issues/132133">llvm/llvm-project#132133</a>).
<p/>
It's unclear whether union types were intended to be accepted. Perhaps we should follow implementations' 
choices and reject them.
</p>


<p id="res-4229"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code class='backtick'>C</code> is a cv-unqualified <ins>non-union</ins> class type.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.5.7.3 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.adaptors">[range.utility.conv.adaptors]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class C, class... Args&gt; requires (!view&lt;C&gt;)
  constexpr auto to(Args&amp;&amp;... args);
template&lt;template&lt;class...&gt; class C, class... Args&gt;
  constexpr auto to(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: For the first overload, <code class='backtick'>C</code> is a cv-unqualified <ins>non-union</ins> class type.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4230"><a href="4230">4230</a>. <code>simd&lt;complex&gt;::real/imag</code> is overconstrained</h3>
<p><b>Section:</b> 29.10.8.4 <a href="https://timsong-cpp.github.io/cppwp/simd.complex.access">[simd.complex.access]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matthias Kretz <b>Opened:</b> 2025-03-18 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.10.8.4 <a href="https://timsong-cpp.github.io/cppwp/simd.complex.access">[simd.complex.access]</a> overconstrains the arguments to <code class='backtick'>real</code> and <code class='backtick'>imag</code>.
<code>complex&lt;T&gt;::real/imag</code> allows conversions to <code class='backtick'>T</code> whereas <code>simd&lt;complex&lt;T&gt;&gt;</code>
requires basically an exact match (<code>same_as&lt;simd&lt;T&gt;&gt;</code> modulo ABI tag differences).
</p>
<blockquote><pre>
complex&lt;double&gt; c = {};
c.real(1.f); // OK

simd&lt;complex&lt;double&gt;&gt; sc = {};
sc.real(simd&lt;float&gt;(1.f)); // <span style="color:red;font-weight:bolder">ill-formed, should be allowed</span>
</pre></blockquote>
<p>
The design intent was to match the <code>std::complex&lt;T&gt;</code> interface. In which case
the current wording doesn't match that intent. <code class='backtick'>complex</code> doesn't say <code>real(same_as&lt;T&gt; auto)</code> 
but 'real(T)', which allows conversions.
<p/>
This issue is also present in the <code class='backtick'>basic_simd(real, imag)</code> constructor. It deduces the type for the 
real/imag arguments instead of using a dependent type derived from <code class='backtick'>value_type</code> and ABI tag.
</p>
<blockquote><pre>
// OK:
complex&lt;double&gt; c{1., 1.f};

// <span style="color:red;font-weight:bolder">Ill-formed, should be allowed</span>:
simd&lt;complex&lt;double&gt;&gt; sc0(1., 1.);
simd&lt;complex&lt;double&gt;, 4&gt; sc1(simd&lt;double, 4&gt;(1.), simd&lt;float, 4&gt;(1.f));
</pre></blockquote>

<p><i>[2025-06-13; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 29.10.7.1 <a href="https://timsong-cpp.github.io/cppwp/simd.overview">[simd.overview]</a>, class template <code class='backtick'>basic_simd</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::datapar {
  template&lt;class T, class Abi&gt; class basic_simd {
  public:
    using value_type = T;
    using mask_type = basic_simd_mask&lt;sizeof(T), Abi&gt;;
    using abi_type = Abi;
    
    <ins>using <i>real-type</i> = rebind_t&lt;typename T::value_type, basic_simd&gt; <i>// exposition-only</i></ins>
    
    <i>// 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a>, basic_simd constructors</i>   
    [&hellip;]
    <del>template&lt;<i>simd-floating-point</i> V&gt;</del>
      constexpr explicit(<i>see below</i>) basic_simd(const <ins><i>real-type</i></ins><del>V</del>&amp; reals, const <ins><i>real-type</i></ins><del>V</del>&amp; imags = {}) noexcept;
    [&hellip;]
    <i>// 29.10.8.4 <a href="https://timsong-cpp.github.io/cppwp/simd.complex.access">[simd.complex.access]</a>, basic_simd complex-value accessors</i>
    constexpr <ins><i>real-type</i></ins><del>auto</del> real() const noexcept;
    constexpr <ins><i>real-type</i></ins><del>auto</del> imag() const noexcept;
    <del>template&lt;<i>simd-floating-point</i> V&gt;</del>
      constexpr void real(const <ins><i>real-type</i></ins><del>V</del>&amp; v) noexcept;
    <del>template&lt;<i>simd-floating-point</i> V&gt;</del>
      constexpr void imag(const <ins><i>real-type</i></ins><del>V</del>&amp; v) noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
<del>template&lt;<i>simd-floating-point</i> V&gt;</del>
  constexpr explicit(<i>see below</i>) basic_simd(const <ins><i>real-type</i></ins><del>V</del>&amp; reals, const <ins><i>real-type</i></ins><del>V</del>&amp; imags = {}) noexcept;
</pre>
<blockquote>
<p>
-19- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(19.1) &mdash;</del> <code><i>simd-complex</i>&lt;basic_simd&gt;</code> is modeled<ins>.</ins><del>, and</del></p></li>
<li><p><del>(19.2) &mdash; <code class='backtick'>V::size() == size()</code> is <code class='backtick'>true</code>.</del></p></li>
</ol>
<p>
[&hellip;]
<p/>
-21- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> evaluates to <code class='backtick'>false</code> if and only if the 
floating-point conversion rank of <code class='backtick'>T::value_type</code> is greater than or equal to the floating-point 
conversion rank of <code><ins><i>real-type</i></ins><del>V</del>::value_type</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 29.10.8.4 <a href="https://timsong-cpp.github.io/cppwp/simd.complex.access">[simd.complex.access]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <ins><i>real-type</i></ins><del>auto</del> real() const noexcept;
constexpr <ins><i>real-type</i></ins><del>auto</del> imag() const noexcept;
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <code><i>simd-complex</i>&lt;basic_simd&gt;</code> is modeled.
<p/>
-2- <i>Returns</i>: An object of type <code><ins><i>real-type</i></ins><del>rebind_t&lt;typename T::value_type, basic_simd&gt;</del></code> 
where the <code><i>i</i></code><sup>th</sup> element is initialized to the result of 
<code><i>cmplx-func</i>(operator[](<i>i</i>))</code> for all <code><i>i</i></code> in the range 
<code class='backtick'>[0, size())</code>, where <code><i>cmplx-func</i></code> is the corresponding function from 
<code>&lt;complex&gt;</code>.
</p>
</blockquote>
<pre>
<del>template&lt;<i>simd-floating-point</i> V&gt;</del>
  constexpr void real(const <ins><i>real-type</i></ins><del>V</del>&amp; v) noexcept;
<del>template&lt;<i>simd-floating-point</i> V&gt;</del>
  constexpr void imag(const <ins><i>real-type</i></ins><del>V</del>&amp; v) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(3.1) &mdash;</del> <code><i>simd-complex</i>&lt;basic_simd&gt;</code> is modeled<ins>.</ins><del>,</del></p></li>
<li><p><del>(3.2) &mdash; <code>same_as&lt;typename V::value_type, typename T::value_type&gt;</code> is modeled, and</del></p></li>
<li><p><del>(3.3) &mdash; <code class='backtick'>V::size() == size()</code> is <code class='backtick'>true</code>.</del></p></li>
</ol>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-07-21; Matthias Kretz comments]</i></p>

<p>
The currently shown P/R says:
</p>
<blockquote><p>
<i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> evaluates to <code class='backtick'>false</code> if and only if
the floating-point conversion rank of <code class='backtick'>T::value_type</code> is greater than or equal
to the floating-point conversion rank of <code><i>real-type</i>::value_type</code>.
</p></blockquote>
<p>
But, by construction, <code><i>real-type</i>::value_type</code> is the same as <code class='backtick'>T::value_type</code>. 
So we get an elaborately worded <code class='backtick'>explicit(false)</code> here (which is correct).
Consequently, the proposed resolution needs to strike <code class='backtick'>explicit(&lt;i&gt;see below&lt;/i&gt;)</code>
from 29.10.7.1 <a href="https://timsong-cpp.github.io/cppwp/simd.overview">[simd.overview]</a> and 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> and drop the Remarks paragraph (21).
</p>


<p id="res-4230"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>


<ol>

<li><p>Modify 29.10.7.1 <a href="https://timsong-cpp.github.io/cppwp/simd.overview">[simd.overview]</a>, class template <code class='backtick'>basic_vec</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;class T, class Abi&gt; class basic_vec {
  public:
    using value_type = T;
    using mask_type = basic_mask&lt;sizeof(T), Abi&gt;;
    using abi_type = Abi;
    using iterator = <i>simd-iterator</i>&lt;basic_vec&gt;;
    using const_iterator = <i>simd-iterator</i>&lt;const basic_vec&gt;;
    
    <ins>using <i>real-type</i> = rebind_t&lt;typename T::value_type, basic_vec&gt; <i>// exposition-only</i></ins>
    
    <i>// 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a>, basic_vec constructors</i>   
    [&hellip;]
    <del>template&lt;<i>simd-floating-point</i> V&gt;</del>
      constexpr <del>explicit(<i>see below</i>)</del> basic_vec(const <ins><i>real-type</i></ins><del>V</del>&amp; reals, const <ins><i>real-type</i></ins><del>V</del>&amp; imags = {}) noexcept;
    [&hellip;]
    <i>// 29.10.8.4 <a href="https://timsong-cpp.github.io/cppwp/simd.complex.access">[simd.complex.access]</a>, basic_vec complex-value accessors</i>
    constexpr <ins><i>real-type</i></ins><del>auto</del> real() const noexcept;
    constexpr <ins><i>real-type</i></ins><del>auto</del> imag() const noexcept;
    <del>template&lt;<i>simd-floating-point</i> V&gt;</del>
      constexpr void real(const <ins><i>real-type</i></ins><del>V</del>&amp; v) noexcept;
    <del>template&lt;<i>simd-floating-point</i> V&gt;</del>
      constexpr void imag(const <ins><i>real-type</i></ins><del>V</del>&amp; v) noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
<del>template&lt;<i>simd-floating-point</i> V&gt;</del>
  constexpr <del>explicit(<i>see below</i>)</del> 
    basic_vec(const <ins><i>real-type</i></ins><del>V</del>&amp; reals, const <ins><i>real-type</i></ins><del>V</del>&amp; imags = {}) noexcept;
</pre>
<blockquote>
<p>
-19- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(19.1) &mdash;</del> <code><i>simd-complex</i>&lt;basic_vec&gt;</code> is modeled<ins>.</ins><del>, and</del></p></li>
<li><p><del>(19.2) &mdash; <code class='backtick'>V::size() == size()</code> is <code class='backtick'>true</code>.</del></p></li>
</ol>
<p>
[&hellip;]
<p/>
<del>-21- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> evaluates to <code class='backtick'>false</code> if and only if the 
floating-point conversion rank of <code class='backtick'>T::value_type</code> is greater than or equal to the floating-point 
conversion rank of <code>V::value_type</code>.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 29.10.8.4 <a href="https://timsong-cpp.github.io/cppwp/simd.complex.access">[simd.complex.access]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <ins><i>real-type</i></ins><del>auto</del> real() const noexcept;
constexpr <ins><i>real-type</i></ins><del>auto</del> imag() const noexcept;
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <code><i>simd-complex</i>&lt;basic_vec&gt;</code> is modeled.
<p/>
-2- <i>Returns</i>: An object of type <code><ins><i>real-type</i></ins><del>rebind_t&lt;typename T::value_type, basic_vec&gt;</del></code> 
where the <code><i>i</i></code><sup>th</sup> element is initialized to the result of 
<code><i>cmplx-func</i>(operator[](<i>i</i>))</code> for all <code><i>i</i></code> in the range 
<code class='backtick'>[0, size())</code>, where <code><i>cmplx-func</i></code> is the corresponding function from 
<code>&lt;complex&gt;</code>.
</p>
</blockquote>
<pre>
<del>template&lt;<i>simd-floating-point</i> V&gt;</del>
  constexpr void real(const <ins><i>real-type</i></ins><del>V</del>&amp; v) noexcept;
<del>template&lt;<i>simd-floating-point</i> V&gt;</del>
  constexpr void imag(const <ins><i>real-type</i></ins><del>V</del>&amp; v) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(3.1) &mdash;</del> <code><i>simd-complex</i>&lt;basic_vec&gt;</code> is modeled<ins>.</ins><del>,</del></p></li>
<li><p><del>(3.2) &mdash; <code>same_as&lt;typename V::value_type, typename T::value_type&gt;</code> is modeled, and</del></p></li>
<li><p><del>(3.3) &mdash; <code class='backtick'>V::size() == size()</code> is <code class='backtick'>true</code>.</del></p></li>
</ol>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4237"><a href="4237">4237</a>. The standard library iterator adaptor does not handle <code>iterator_category</code> correctly</h3>
<p><b>Section:</b> 24.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/const.iterators.iterator">[const.iterators.iterator]</a>, 25.7 <a href="https://timsong-cpp.github.io/cppwp/range.adaptors">[range.adaptors]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-03-27 <b>Last modified:</b> 2025-06-12</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#const.iterators.iterator">active issues</a> in [const.iterators.iterator].</p>
<p><b>View all other</b> <a href="lwg-index.html#const.iterators.iterator">issues</a> in [const.iterators.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code>basic_const_iterator</code>, and several range adaptors such as 
<code>filter_view</code>'s iterators provide <code>iterator_category</code> only when the 
underlying iterator models <code>forward_iterator</code>, implying that they expect those 
iterators should have a valid <code>iterator_category</code>.
</p>
<p>
However, this is incorrect because being a <code>forward_iterator</code> does not 
necessarily mean it is a <i>Cpp17InputIterator</i>, it just means that it <i>probably</i> 
meets the syntactic requirements of <i>Cpp17InputIterator</i>.
</p>
<p>
Any iterator that specializes <code>iterator_traits</code> and provides only
<code>iterator_concept</code> without <code>iterator_category</code> is not a
<i>Cpp17InputIterator</i>, for example, <code>common_iterator</code> with a 
<code>difference_type</code> of integer-class type.
</p>
<p>
In this case, instantiating these iterator adaptors will result in a hard error because the
<code>iterator_category</code> they expect does not exist. The following illustrates the 
problem (<a href="https://godbolt.org/z/j7x8bKzo4">demo</a>):
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;ranges&gt;

int main() {
  auto r = std::views::iota(0ULL)
         | std::views::take(5)
         | std::views::common;

  static_assert(std::ranges::forward_range&lt;decltype(r)&gt;);
  
  std::basic_const_iterator ci(r.begin()); // <span style="color:red;font-weight:bolder">'iterator_category': is not a member of 'std::iterator_traits'</span>

  auto f = r | std::views::filter([](auto) { return true; });
  auto b = f.begin();                      // <span style="color:red;font-weight:bolder">'iterator_category': is not a member of 'std::iterator_traits'</span>
}
</pre></blockquote>
<p>
I believe that checking if the underlying iterator is a <code>forward_iterator</code> is not an appropriate
mechanism to provide <code>iterator_category</code>, but rather checking if its <code>iterator_traits</code> 
specialization provides <code>iterator_category</code>.
</p>
<p>
This issue is somewhat related to LWG <a href="3763" title="Should range adaptor iterators only provide iterator_category when its 
difference_type is not an integer-class type? (Status: New)">3763</a>, which is a further consideration after LWG 
<a href="3749" title="common_iterator should handle integer-class difference types (Status: WP)">3749</a> has been resolved.
</p>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4237"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4238"><a href="4238">4238</a>. <code>simd_mask&lt;complex&lt;double&gt;&gt;::operator+/-/~</code> return a disabled <code class='backtick'>simd</code> specialization</h3>
<p><b>Section:</b> 29.10.9.4 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.unary">[simd.mask.unary]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matthias Kretz <b>Opened:</b> 2025-03-27 <b>Last modified:</b> 2025-06-12</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.mask.unary">active issues</a> in [simd.mask.unary].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.mask.unary">issues</a> in [simd.mask.unary].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote><pre>
simd&lt;complex&lt;double&gt;&gt; c = {};
simd_mask&lt;complex&lt;double&gt;&gt; k = (c == c); // sizeof(complex&lt;double&gt;) == 16
auto i = -k; // simd&lt;__int128&gt; !
</pre></blockquote>
<p>
<code class='backtick'>basic_simd_mask</code> unary <code class='backtick'>+</code>, <code class='backtick'>-</code>, and <code class='backtick'>~</code> return <code>basic_simd&lt;<i>integer-from</i>&lt;Bytes, Abi&gt;&gt;</code>.
29.10.2.1 <a href="https://timsong-cpp.github.io/cppwp/simd.expos.defn">[simd.expos.defn]</a>/2 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<code><i>integer-from</i>&lt;Bytes&gt;</code> is an alias for a signed integer type <code class='backtick'>T</code> such that <code class='backtick'>sizeof(T)</code> equals <code class='backtick'>Bytes</code>.
</p>
</blockquote>
<p>
But <code class='backtick'>__int128</code> isn't a vectorizable type. Consequently, <code>simd&lt;__int128&gt;</code> currently
is a disabled specialization. So it seems <code>simd&lt;complex&lt;double&gt;&gt;</code> wants <code class='backtick'>__int128</code>
to be added to the list of vectorizable types.
<p/>
<b>Options:</b>
</p>
<ol style="list-style-type:lower-alpha">
<li><p>"Specialize" <code>basic_simd_mask&lt;16, Abi&gt;</code> to return 
<code>rebind_t&lt;<i>integer-from</i>&lt;8&gt;, basic_simd_mask&lt;<i>integer-from</i>&lt;16&gt;, Abi&gt;&gt;</code> 
(reduces a 128-bit value of a vector-mask to a 64-bit value in the simd)</p></li>
<li><p>"Specialize" <code>basic_simd_mask&lt;16, Abi&gt;</code> to return 
<code>resize_t&lt;size() * 2, rebind_t&lt;<i>integer-from</i>&lt;8&gt;, 
basic_simd_mask&lt;<i>integer-from</i>&lt;16&gt;, Abi&gt;&gt;&gt;</code> 
(duplicates a 128-bit value of a vector-mask to two 64-bit values in the simd)</p></li>
<li><p>delete unary <code class='backtick'>+</code>, <code class='backtick'>-</code>, and <code class='backtick'>~</code> for <code>basic_simd_mask&lt;16, Abi&gt;</code> 
(closest to the status quo)</p></li>
</ol>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>



<p id="res-4238"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 29.10.9.4 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.unary">[simd.mask.unary]</a> as indicated:</p>

<blockquote>
<pre>
constexpr basic_simd_mask operator!() const noexcept;
constexpr basic_simd&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt; operator+() const noexcept;
constexpr basic_simd&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt; operator-() const noexcept;
constexpr basic_simd&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt; operator~() const noexcept;
</pre>
<blockquote>
<p>
-1- Let <code><i>op</i></code> be the operator.
<p/>
-2- <i>Returns</i>: A data-parallel object where the <code><i>i</i></code><sup>th</sup> element 
is initialized to the results of applying <code><i>op</i></code> to <code>operator[](<i>i</i>)</code> 
for all <code><i>i</i></code> in the range of <code>[0, size())</code>.
<p/>
<ins>-?- <i>Remarks</i>: If <code>Bytes</code> is greater than <code>8</code>, <code class='backtick'>operator+()</code>, <code class='backtick'>operator-()</code>, and
<code class='backtick'>operator~()</code> are deleted.
</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4240"><a href="4240">4240</a>. The formattable type is not a <code>formattable</code> type</h3>
<p><b>Section:</b> 28.5.6.3 <a href="https://timsong-cpp.github.io/cppwp/format.formattable">[format.formattable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-04-06 <b>Last modified:</b> 2025-06-12</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.formattable">active issues</a> in [format.formattable].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.formattable">issues</a> in [format.formattable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
User-specific <code>formatter</code>s usually have the following form:
</p>
<blockquote><pre>
template &lt;&gt; struct std::formatter&lt;T&gt; {
  constexpr auto parse(format_parse_context&amp; ctx)
    -> format_parse_context::iterator;

  auto format(const T&amp; value, format_context&amp; ctx) const
    -> format_context::iterator;
};
</pre></blockquote>
<p>
This is reflected in wording examples such as 28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> bullet 8 or
28.5.6.7 <a href="https://timsong-cpp.github.io/cppwp/format.context">[format.context]</a> bullet 9:
</p>
<blockquote><pre>
#include &lt;format&gt;
#include &lt;string&gt;

enum color { red, green, blue };
const char* color_names[] = { "red", "green", "blue" };

template&lt;&gt; struct std::formatter&lt;color&gt; : std::formatter&lt;const char*&gt; {
  auto format(color c, format_context&amp; ctx) const {
    return formatter&lt;const char*&gt;::format(color_names[c], ctx);
  }
};
</pre></blockquote>
<p>
which allows us to format <code>color</code> with <code>std::format("{}", red)</code>.
Unfortunately, even so, the <code>color</code> still does not satisfy <code>std::formattable</code>.
<p/>
This is because the concept <code>formattable</code> is currently defined as follows:
</p>
<blockquote><pre>
template&lt;class T, class Context,
         class Formatter = typename Context::template formatter_type&lt;remove_const_t&lt;T&gt;&gt;&gt;
  concept <i>formattable-with</i> =                // <i>exposition only</i>
    semiregular&lt;Formatter&gt; &amp;&amp;
    requires(Formatter&amp; f, const Formatter&amp; cf, T&amp;&amp; t, Context fc,
             basic_format_parse_context&lt;typename Context::char_type&gt; pc)
    {
      { f.parse(pc) } -> same_as&lt;typename decltype(pc)::iterator&gt;;
      { cf.format(t, fc) } -> same_as&lt;typename Context::iterator&gt;;
    };

template&lt;class T, class charT&gt;
  concept formattable =
    <i>formattable-with</i>&lt;remove_reference_t&lt;T&gt;, basic_format_context&lt;<i>fmt-iter-for</i>&lt;charT&gt;, charT&gt;&gt;;
</pre></blockquote>
<p>
where <code><i>fmt-iter-for</i>&lt;charT&gt;</code> is an unspecified type that can write
<code>charT</code>, which for <code>char</code> is <code>back_insert_iterator&lt;string&gt;</code> 
and <code>char*</code> in libstdc++ and libc++, respectively.
</p>
<p>
That is, for <code>color</code> to satisfy <code>formattable</code>, it is
necessary to ensure that <code>cf.format(t, fc)</code> is well-formed.
</p>
<p>
However, the <code>format()</code> function in the above example takes a <code>format_context</code>
whose <code>Out</code> parameter is internal iterator type, namely
<code>__format::_Sink_iter&lt;char&gt;</code> and 
<code>back_insert_iterator&lt;__format::__output_buffer&lt;char&gt;&gt;</code> in 
libstdc++ and libc++, respectively. 
Since <code>basic_format_context</code> with different <code>Out</code> parameters cannot be converted to
each other, the constraint is not satisfied.
</p>
<p>
The reason <code>color</code> can still be formatted is that <code>basic_format_arg</code>
checks for <code><i>formattable-with</i>&lt;Context&gt;</code> where <code>Context</code> 
has been correctly specified as <code>format_context</code>.
</p>
<p>
And since <code>color</code> is formattable but not <code>formattable</code>, this further
prevents formatting a range with elements of <code>color</code>, because the <code>formatter</code> 
specialization for ranges requires that the element type must be <code>formattable</code>. 
This leads to some inconsistencies (<a href="https://godbolt.org/z/Y8a6WTrK1">demo</a>):
</p>
<blockquote><pre>
std::println("{}", red); // ok
static_assert(std::formattable&lt;color, char&gt;); // <span  style="color:#C80000;font-weight:bold">fires</span>

std::vector&lt;color&gt; v;
std::println("{}", v); // <span  style="color:#C80000;font-weight:bold">not ok</span>
</pre></blockquote>
<p>
The workaround is to turn the custom <code>format()</code> into a template function 
such as <code>format(color c, auto&amp; ctx)</code> or 
<code>format(color c, basic_format_context&lt;Out, charT&gt;&amp; ctx)</code>,
However, this seems mandate users to always declare <code>format()</code> as the template 
function for the best practice, which in my opinion defeats the purpose of introducing 
<code>format_context</code> in the first place.
</p>
<p>
Also, since <code><i>fmt-iter-for</i>&lt;charT&gt;</code> is unspecified, if it is specified 
in some library implementation as the same type as <code>format_context</code>'s <code>Out</code> 
parameters, then <code>color</code> will suddenly become <code>formattable</code>. This lack 
of guarantee about <code>formattable</code> can bring unnecessary confusion.
</p>
<p>
I think we should ensure that <code>color</code> is <code>formattable</code>, because it is formattable.
</p>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
"This change would prevent future evolution of the API."
"Maybe <code class='backtick'>formatter</code> is not useful and <code class='backtick'>formattable_with</code> should always be used."
</p>



<p id="res-4240"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 28.5.6.3 <a href="https://timsong-cpp.github.io/cppwp/format.formattable">[format.formattable]</a> as indicated:</p>

<blockquote>
<p>
-1- <del>Let <code><i>fmt-iter-for</i>&lt;charT&gt;</code> be an unspecified type that models
<code>output_iterator&lt;const charT&amp;&gt;</code> (24.3.4.10 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.output">[iterator.concept.output]</a>)</del>.
</p>
<blockquote><pre>
[&hellip;]
template&lt;class T, class charT&gt;
  concept formattable =
    <i>formattable-with</i>&lt;remove_reference_t&lt;T&gt;, <ins>conditional_t&lt;same_as&lt;charT, char&gt;, format_context, wformat_context&gt;</ins><del>basic_format_context&lt;<i>fmt-iter-for</i>&lt;charT&gt;, charT&gt;</del>&gt;;
</pre></blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4241"><a href="4241">4241</a>. <code class='backtick'>ranges::for_each(_n)</code> should be less constrained</h3>
<p><b>Section:</b> 26.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-04-08 <b>Last modified:</b> 2025-04-13</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.foreach">active issues</a> in [alg.foreach].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>ranges::for_each(_n)</code> are constrained with <code class='backtick'>indirectly_unary_invocable</code>, 
which doesn't meet the actual use of the range elements. These algorithms are only 
expected to invoke the callable object with the possibly projected elements, and not 
to use any element as the value type. Moreover, <code class='backtick'>indirectly_unary_invocable</code> requires 
the callable object to be copy constructible, which might be undesired because the 
corresponding <code class='backtick'>std::for_each(_n)</code> only require move constructibilty.
<p/>
LWG <a href="4171" title="P2609R3 breaks code that uses views::zip and get&lt;T&gt; (Status: New)">4171</a> talked about the breakage around <code class='backtick'>ranges::for_each</code> introduced 
by <a href="https://wg21.link/P2609R3" title=" Relaxing Ranges Just A Smidge">P2609R3</a>. P2609R3 looks like a reasonable fix as long as the affected 
algorithms potentially use the intermediate element values copied as 
<code>std::iter_value_t&lt;I&gt;</code>. However, when the algorithm is not expected to or 
even required not to do this, P2609R3 can bring unexpected impacts. It seems that 
constraints around <code class='backtick'>iter_value_t</code> should be avoided for such an algorithm.
</p>


<p id="res-4241"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 26.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a>, header <code>&lt;algorithm&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace ranges {
  template&lt;class I, class F&gt;
  using for_each_result = in_fun_result&lt;I, F&gt;;
  
  template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
           <del>indirectly_unary_invocable&lt;projected&lt;I, Proj&gt;&gt;</del><ins>move_constructible</ins> Fun&gt;
    <ins>requires invocable&lt;Fun&amp;, iter_reference_t&lt;projected&lt;I, Proj&gt;&gt;&gt;</ins>
    constexpr for_each_result&lt;I, Fun&gt;
      for_each(I first, S last, Fun f, Proj proj = {});
  template&lt;input_range R, class Proj = identity,
           <del>indirectly_unary_invocable&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;</del><ins>move_constructible</ins> Fun&gt;
    <ins>requires invocable&lt;Fun&amp;, iter_reference_t&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;</ins>
    constexpr for_each_result&lt;borrowed_iterator_t&lt;R&gt;, Fun&gt;
      for_each(R&amp;&amp; r, Fun f, Proj proj = {});
}
[&hellip;]
namespace ranges {
  template&lt;class I, class F&gt;
  using for_each_n_result = in_fun_result&lt;I, F&gt;;

  template&lt;input_iterator I, class Proj = identity,
           <del>indirectly_unary_invocable&lt;projected&lt;I, Proj&gt;&gt;</del><ins>move_constructible</ins> Fun&gt;
     <ins>requires invocable&lt;Fun&amp;, iter_reference_t&lt;projected&lt;I, Proj&gt;&gt;&gt;</ins>
    constexpr for_each_n_result&lt;I, Fun&gt;
      for_each_n(I first, iter_difference_t&lt;I&gt; n, Fun f, Proj proj = {});
}
[&hellip;]
</pre>
</blockquote>

</li>

<li><p>Modify 26.6.5 <a href="https://timsong-cpp.github.io/cppwp/alg.foreach">[alg.foreach]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,
         <del>indirectly_unary_invocable&lt;projected&lt;I, Proj&gt;&gt;</del><ins>move_constructible</ins> Fun&gt;
  <ins>requires invocable&lt;Fun&amp;, iter_reference_t&lt;projected&lt;I, Proj&gt;&gt;&gt;</ins>
  constexpr ranges::for_each_result&lt;I, Fun&gt;
    ranges::for_each(I first, S last, Fun f, Proj proj = {});
template&lt;input_range R, class Proj = identity,
         <del>indirectly_unary_invocable&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;</del><ins>move_constructible</ins> Fun&gt;
  <ins>requires invocable&lt;Fun&amp;, iter_reference_t&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;</ins>
  constexpr ranges::for_each_result&lt;borrowed_iterator_t&lt;R&gt;, Fun&gt;
    ranges::for_each(R&amp;&amp; r, Fun f, Proj proj = {});
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<del>-15- [<i>Note 6</i>: The overloads in namespace <code class='backtick'>ranges</code> require <code class='backtick'>Fun</code> to model <code class='backtick'>copy_constructible</code>. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
template&lt;input_iterator I, class Proj = identity,
         <del>indirectly_unary_invocable&lt;projected&lt;I, Proj&gt;&gt;</del><ins>move_constructible</ins> Fun&gt;
  <ins>requires invocable&lt;Fun&amp;, iter_reference_t&lt;projected&lt;I, Proj&gt;&gt;&gt;</ins>
  constexpr ranges::for_each_n_result&lt;I, Fun&gt;
    ranges::for_each_n(I first, iter_difference_t&lt;I&gt; n, Fun f, Proj proj = {});
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<del>-30- [<i>Note 11</i>: The overload in namespace <code class='backtick'>ranges</code> requires <code class='backtick'>Fun</code> to model <code class='backtick'>copy_constructible</code>. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4244"><a href="4244">4244</a>. Whether the spuriously failed comparison applies to <code class='backtick'>compare_exchange_strong</code> is unclear</h3>
<p><b>Section:</b> 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a>, 32.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2025-04-17 <b>Last modified:</b> 2025-04-21</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.ref.ops">active issues</a> in [atomics.ref.ops].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.ref.ops">issues</a> in [atomics.ref.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both <code class='backtick'>compare_exchange_strong</code> and <code class='backtick'>compare_exchange_weak</code> share the same specified rule
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
If and only if the comparison is <code class='backtick'>false</code> then, after the atomic operation, the value in 
<code class='backtick'>expected</code> is replaced by the value read from the value referenced by <code class='backtick'>*ptr</code> during the 
atomic comparison.
</p>
</blockquote>
<p>
However, there is a remark for the weak version
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
A weak compare-and-exchange operation may fail spuriously.
</p>
</blockquote>
<p>
That is, even when the contents of memory referred to by <code class='backtick'>expected</code> and <code class='backtick'>ptr</code> are equal, 
it may return <code class='backtick'>false</code> and store back to expected the same memory contents that were 
originally there.
<p/>
However, we don't explicitly say whether the strong version can have the spuriously failed 
comparison. The status quo is that we can only infer the point from the name, namely, the 
strong version should have a stronger guarantee than the weak version.
<p/>
<b>Suggested resolution:</b>
<p/>
Explicitly specify whether <code class='backtick'>compare_exchange_strong</code> can have the spurious failed comparison.
</p>


<p id="res-4244"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4248"><a href="4248">4248</a>. Late domain-based dispatching of <code class='backtick'>schedule_from</code> and <code class='backtick'>continues_on</code> are flipped</h3>
<p><b>Section:</b> 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2025-04-26 <b>Last modified:</b> 2025-06-12</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.snd.expos">active issues</a> in [exec.snd.expos].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.snd.expos">issues</a> in [exec.snd.expos].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The reason for having two different customization points for transitioning between two execution contexts 
is described in 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> bullet (14.1) Note 1, to wit:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
[<i>Note 1</i>: The <code class='backtick'>continues_on</code> algorithm works in tandem with <code class='backtick'>schedule_from</code> 
(33.9.12.7 <a href="https://timsong-cpp.github.io/cppwp/exec.schedule.from">[exec.schedule.from]</a>) to give scheduler authors a way to customize 
both how to transition onto (<code class='backtick'>continues_on</code>) and off of (<code class='backtick'>schedule_from</code>) a given 
execution context. Thus, <code class='backtick'>continues_on</code> ignores the domain of the predecessor and 
uses the domain of the destination scheduler to select a customization, a property 
that is unique to <code class='backtick'>continues_on</code>. That is why it is given special treatment here. 
&mdash; <i>end note</i>]
</p>
</blockquote>
<p>
The exposition-only <code><i>get-domain-late</i></code> function treats <code class='backtick'>continues_on</code> 
senders specially to make sure the correct domain (that of the destination scheduler) 
is used to find customizations at connect time.
<p/>
However, customizations are also searched for early when the sender is first constructed. 
And here the dispatching of <code class='backtick'>continues_on</code> and <code class='backtick'>schedule_from</code> are reversed.
<p/>
<code class='backtick'>continues_on(sndr, sch)</code> is defined as (33.9.12.6 <a href="https://timsong-cpp.github.io/cppwp/exec.continues.on">[exec.continues.on]</a>):
</p>
<blockquote><pre>
transform_sender(<i>get-domain-early</i>(sndr), <i>make-sender</i>(continues_on, sch, sndr))
</pre></blockquote>
<p>
which is using the domain of the predecessor rather than ignoring it as 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> p14.1 
says it does. And <code class='backtick'>schedule_from(sch, sndr)</code> is currently defined as (33.9.12.7 <a href="https://timsong-cpp.github.io/cppwp/exec.schedule.from">[exec.schedule.from]</a>):
</p>
<blockquote><pre>
transform_sender(
  <i>query-or-default</i>(get_domain, sch, default_domain()),
  <i>make-sender</i>(schedule_from, sch, sndr))
</pre></blockquote>
<p>
which is using the domain of the destination scheduler to find customizations. The logic for 
determining the domain to use for early customization of these two algorithms are opposite 
what they are for late customization. This is a bug. They should be consistent.
<p/>
"Lazy" customization (at connect time) was added to <a href="https://wg21.link/P2300" title=" `std::execution`">P2300</a> later in the process, 
and this inconsistency was a mistake on my part. The correct thing to do is to change 
<code><i>get-domain-late</i></code> to treat <code class='backtick'>schedule_from</code> as special, not <code class='backtick'>continues_on</code>.
</p>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>
<p>
"Names are a bit misleading but the change looks right."
</p>



<p id="res-4248"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Sndr, class Env&gt;
  constexpr auto <i>get-domain-late</i>(const Sndr&amp; sndr, const Env&amp; env) noexcept;
</pre>
<blockquote>
<p>
-14- <i>Effects</i>: Equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(14.1) &mdash; If <code><i>sender-for</i>&lt;Sndr, <del>continues_on_t</del><ins>schedule_from_t</ins>&gt;</code> is <code class='backtick'>true</code>, then</p>
<blockquote><pre>
return Domain();
</pre></blockquote>
<p>
where <code class='backtick'>Domain</code> is the type of the following expression:
</p>
<blockquote><pre>
[] {
  auto [_, sch, _] = sndr;
  return <i>query-or-default</i>(get_domain, sch, default_domain());
}();
</pre></blockquote>
<p>
[<i>Note 1</i>: The <code><del>continues_on</del><ins>schedule_from</ins></code> algorithm 
works in tandem with <code><del>schedule_from</del><ins>continues_on</ins></code> 
(<del>33.9.12.7 <a href="https://timsong-cpp.github.io/cppwp/exec.schedule.from">[exec.schedule.from]</a></del><ins>33.9.12.6 <a href="https://timsong-cpp.github.io/cppwp/exec.continues.on">[exec.continues.on]</a></ins>) 
to give scheduler authors a way to customize both how to transition onto 
(<code><del>continues_on</del><ins>schedule_from</ins></code>) and off of 
(<code><del>schedule_from</del><ins>continues_on</ins></code>) a given execution context. 
Thus, <code><del>continues_on</del><ins>schedule_from</ins></code> ignores the domain of the 
predecessor and uses the domain of the destination scheduler to select a customization, 
a property that is unique to <code><del>continues_on</del><ins>schedule_from</ins></code>. 
That is why it is given special treatment here. &mdash; <i>end note</i>]
</p>
</li>
<li><p>[&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4249"><a href="4249">4249</a>. The past end issue for <code class='backtick'>lazy_split_view</code></h3>
<p><b>Section:</b> 25.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.outer">[range.lazy.split.outer]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-04-26 <b>Last modified:</b> 2025-04-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.lazy.split.outer">active issues</a> in [range.lazy.split.outer].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.lazy.split.outer">issues</a> in [range.lazy.split.outer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider (<a href="https://godbolt.org/z/eeMe8aTqv">demo</a>):
</p>
<blockquote><pre>
#include &lt;print&gt;
#include &lt;ranges&gt;
#include &lt;sstream&gt;

int main() {
  std::istringstream is{"1 0 2 0 3"};
  auto r = std::views::istream&lt;int&gt;(is)
         | std::views::lazy_split(0)
         | std::views::stride(2);
  std::println("{}", r); // should print [[1], [3]]
}
</pre></blockquote>
<p>
The above leads to SIGSEGV in libstdc++, the reason is that we are iterating over the nested
range as:
</p>
<blockquote><pre>
for (auto&amp;&amp; inner : r) {
  for (auto&amp;&amp; elem : inner) {
    // [&hellip;]
  }
}
</pre></blockquote>
<p>
which is disassembled as:
</p>
<blockquote><pre>
auto outer_it = r.begin();
std::default_sentinel_t out_end = r.end();
for(; outer_it != out_end; ++outer_it) {
  auto&amp;&amp; inner_r = *outer_it;
  auto inner_it = inner_r.begin();
  std::default_sentinel_t inner_end = inner_r.end();
  for(; inner_it != inner_end; ++inner_it) {
    auto&amp;&amp; elem = *inner_it;
    // [&hellip;]
  }
}
</pre></blockquote>
<p>
Since <code class='backtick'>inner_it</code> and <code class='backtick'>output_it</code> actually update the same iterator,
when we back to the outer loop, <code>lazy_split_view::<i>outer-iterator</i></code> 
is now equal to <code class='backtick'>default_sentinel</code>, which makes <code class='backtick'>output_it</code> reach the end,
so <code class='backtick'>++outer_it</code> will increment the iterator past end, triggering the assertion.
</p>
<p>
Note that this <a href="https://godbolt.org/z/6Tx61eeq8">also happens</a> in MSVC-STL 
when <code class='backtick'>_ITERATOR_DEBUG_LEVEL</code> is turned on.
</p>
<p>
It seems that extra flags are needed to fix this issue because <code class='backtick'>output_it</code> should not 
be considered to reach the end when we back to the outer loop.
</p>


<p id="res-4249"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 25.7.16.3 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.outer">[range.lazy.split.outer]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
             (forward_range&lt;V&gt; || <i>tiny-range</i>&lt;Pattern&gt;)
  template&lt;bool Const&gt;
  struct lazy_split_view&lt;V, Pattern&gt;::<i>outer-iterator</i> {
  private:
    using <i>Parent</i> = <i>maybe-const</i>&lt;Const, lazy_split_view&gt;;     // <i>exposition only</i>
    using <i>Base</i> = <i>maybe-const</i>&lt;Const, V&gt;;                     // <i>exposition only</i>
    <i>Parent</i>* <i>parent_</i> = nullptr;                              // <i>exposition only</i>

    iterator_t&lt;<i>Base</i>&gt; <i>current_</i> = iterator_t&lt;<i>Base</i>&gt;();         // <i>exposition only, present only</i>
                                                            // <i>if V models forward_range</i>

    bool <i>trailing_empty_</i> = false;                           // <i>exposition only</i>
    <ins>bool <i>has_next_</i> = false;                                 // <i>exposition only, present only</i></ins>
                                                            <ins>// <i>if forward_range&lt;<i>V</i>&gt; is false</i></ins>
  public:
    [&hellip;]
  };
}
</pre>
</blockquote>
[&hellip;]
<pre>
constexpr explicit <i>outer-iterator</i>(<i>Parent</i>&amp; parent)
  requires (!forward_range&lt;<i>Base</i>&gt;);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i> Initializes <code><i>parent_</i></code> with <code class='backtick'>addressof(parent)</code> <ins>and
<code><i>has_next_</i></code> with <code><i>current</i> != ranges::end(<i>parent_</i>-&gt;<i>base_</i>)</code></ins>.
</p>
</blockquote>
[&hellip;]
<pre>
constexpr <i>outer-iterator</i>&amp; operator++();
</pre>
<blockquote>
<p>
-6- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
const auto end = ranges::end(<i>parent_</i>-&gt;<i>base_</i>);
if (<i>current</i> == end) {
  <i>trailing_empty_</i> = false;
  <ins>if constexpr (!forward_range&lt;V&gt;)
    <i>has_next_</i> = false;</ins>
  return <code>*this</code>;
}
const auto [pbegin, pend] = subrange{<i>parent_</i>-&gt;<i>pattern_</i>};
if (pbegin == pend) ++<i>current</i>;
else if constexpr (<i>tiny-range</i>&lt;Pattern&gt;) {
  <i>current</i> = ranges::find(std::move(<i>current</i>), end, *pbegin);
  if (<i>current</i> != end) {
    ++<i>current</i>;
    if (<i>current</i> == end)
      <i>trailing_empty_</i> = true;
  }
}
else {
  do {
    auto [b, p] = ranges::mismatch(<i>current</i>, end, pbegin, pend);
    if (p == pend) {
      <i>current</i> = b;
      if (<i>current</i> == end)
        <i>trailing_empty_</i> = true;
      break;            <i>// The pattern matched; skip it</i>
    }
  } while (++<i>current</i> != end);
}
<ins>if constexpr (!forward_range&lt;V&gt;)
  if (<i>current</i> == end)
    <i>has_next_</i> = false;</ins>
return *this;
</pre></blockquote>
</blockquote>
[&hellip;]
<pre>
friend constexpr bool operator==(const <i>outer-iterator</i>&amp; x, default_sentinel_t);
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<ins>if constexpr (!forward_range&lt;V&gt;)
  return !x.<i>has_next_</i> &amp;&amp; !x.<i>trailing_empty_</i>;
else</ins>
  return x.<i>current</i> == ranges::end(x.<i>parent_</i>-&gt;<i>base_</i>) &amp;&amp; !x.<i>trailing_empty_</i>;
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4250"><a href="4250">4250</a>. <code class='backtick'>swap</code> overloads for <code class='backtick'>indirect</code> and <code class='backtick'>polymorphic</code> only found by ADL</h3>
<p><b>Section:</b> 20.4.1.7 <a href="https://timsong-cpp.github.io/cppwp/indirect.swap">[indirect.swap]</a>, 20.4.2.7 <a href="https://timsong-cpp.github.io/cppwp/polymorphic.swap">[polymorphic.swap]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-05-01 <b>Last modified:</b> 2025-05-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The non-member <code class='backtick'>swap</code> overloads for <code class='backtick'>std::indirect</code> and <code class='backtick'>std::polymorphic</code>
are defined as hidden friends, so are only available via ADL.
This means that calling <code class='backtick'>std::swap(i1, i2)</code> will always use the generic
<code class='backtick'>std::swap</code> instead of the custom overload for <code class='backtick'>std::indirect</code>.
</p>


<p id="res-4250"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 20.2.2 <a href="https://timsong-cpp.github.io/cppwp/memory.syn">[memory.syn]</a> as indicated:</p>

<blockquote>
<pre><code>
// 20.4.1, class template indirect
template&lt;class T, class Allocator = allocator&lt;T&gt;&gt;
  class indirect;
<ins>
template&lt;class T, class Allocator&gt;
constexpr void swap(indirect&lt;T, Allocator&gt;&amp; lhs, indirect&lt;T, Allocator&gt;&amp; rhs) noexcept(<i>see below</i>);
</ins>
// 20.4.1.10, hash support
template&lt;class T, class Alloc&gt; struct hash&lt;indirect&lt;T, Alloc&gt;&gt;;

// 20.4.2, class template polymorphic
template&lt;class T, class Allocator = allocator&lt;T&gt;&gt;
  class polymorphic;
<ins>
template&lt;class T, class Allocator&gt;
constexpr void swap(polymorphic&lt;T, Allocator&gt;&amp; lhs, polymorphic&lt;T, Allocator&gt;&amp; rhs) noexcept(<i>see below</i>);
</ins>
</code></pre>
</blockquote>
</li>

<li><p>Modify 20.4.1.2 <a href="https://timsong-cpp.github.io/cppwp/indirect.syn">[indirect.syn]</a> as indicated:</p>
<blockquote>
<pre><code>
// 20.4.1.7, swap
constexpr void swap(indirect&amp; other) noexcept(<i>see below</i>);
<del>friend constexpr void swap(indirect&amp; lhs, indirect&amp; rhs) noexcept(<i>see below</i>);</del>
</code></pre>
</blockquote>
</li>

<li><p>Modify 20.4.1.7 <a href="https://timsong-cpp.github.io/cppwp/indirect.swap">[indirect.swap]</a> as indicated:</p>
<blockquote>
<pre><code>
<ins>template&lt;class T, class Allocator&gt;</ins>
constexpr void swap(indirect<ins>&lt;T, Allocator&gt;</ins>&amp; lhs, indirect<ins>&lt;T, Allocator&gt;</ins>&amp; rhs) noexcept(noexcept(lhs.swap(rhs)));
</code></pre>
<blockquote>-3- <i>Effects</i>: Equivalent to <code class='backtick'>lhs.swap(rhs)</code>.</blockquote>
</blockquote>
</li>

<li><p>Modify 20.4.2.2 <a href="https://timsong-cpp.github.io/cppwp/polymorphic.syn">[polymorphic.syn]</a> as indicated:</p>
<blockquote>
<pre><code>
// 20.4.2.7, swap
constexpr void swap(polymorphic&amp; other) noexcept(<i>see below</i>);
<del>friend constexpr void swap(polymorphic&amp; lhs, polymorphic&amp; rhs) noexcept(<i>see below</i>);</del>
</code></pre>
</blockquote>
</li>

<li><p>Modify 20.4.2.7 <a href="https://timsong-cpp.github.io/cppwp/polymorphic.swap">[polymorphic.swap]</a> as indicated:</p>
<blockquote>
<pre><code>
<ins>template&lt;class T, class Allocator&gt;</ins>
constexpr void swap(polymorphic<ins>&lt;T, Allocator&gt;</ins>&amp; lhs, polymorphic<ins>&lt;T, Allocator&gt;</ins>&amp; rhs) noexcept(noexcept(lhs.swap(rhs)));
</code></pre>
<blockquote>-3- <i>Effects</i>: Equivalent to <code class='backtick'>lhs.swap(rhs)</code>.</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4251"><a href="4251">4251</a>. Move assignment for <code class='backtick'>indirect</code> unnecessarily requires copy construction</h3>
<p><b>Section:</b> 99 [indirect.asgn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-05-01 <b>Last modified:</b> 2025-06-12</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The move assignment operator for <code class='backtick'>indirect</code> says:
<blockquote>
<i>Mandates</i>: <code>is_copy_constructible_t&lt;T&gt;</code> is <code class='backtick'>true</code>.
</blockquote>

However, the only way it ever construct an object is:
<blockquote>
constructs a new owned object with the owned object of <code class='backtick'>other</code> as the argument
as an rvalue
</blockquote>
and that only ever happens when <code><i>alloc</i> == other.<i>alloc</i></code>
is false.
</p>
<p>
It seems like we should require <code class='backtick'>is_move_constructible_v</code> instead,
and only if the allocator traits mean we need to construct an object.
(Technically move-constructible might not be correct, because the allocator's
<code class='backtick'>construct</code> member might use a different constructor).
</p>
<p>
Additionally, the noexcept-specifier for the move assignment doesn't match
the effects. The noexcept-specifier says it can't throw if POCMA is true,
but nothing in the effects says that ownership can be transferred in that case;
we only do a non-throwing transfer when the allocators are equal.
I think we <i>should</i> transfer ownership when POCMA is true,
which would make the noexcept-specifier correct.
</p>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>
<p>
Similar change needed for <code class='backtick'>std::polymorphic</code>.
</p>



<p id="res-4251"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 99 [indirect.asgn] as indicated:</p>
<blockquote>
<pre><code>
constexpr indirect&amp; operator=(indirect&amp;&amp; other)
  noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
           allocator_traits&lt;Allocator&gt;::is_always_equal::value);
</code></pre>
<blockquote>
<p>
-5- <i>Mandates</i>:
<ins>
If
<code>allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value</code>
is <code class='backtick'>false</code>
and
<code>allocator_traits&lt;Allocator&gt;::is_always_equal::value</code>
is <code class='backtick'>false</code>,
</ins>
<code>is_<del>copy</del><ins>move</ins>_constructible_t&lt;T&gt;</code> is <code class='backtick'>true</code>.
</p>
<p>
-6- <i>Effects</i>:
If <code class='backtick'>addressof(other) == this</code> is <code class='backtick'>true</code>, there are no effects.
Otherwise:
<ol style="list-style-type:none">
<li>(6.1) &mdash;
The allocator needs updating if
<code>allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value</code>
is <code class='backtick'>true</code>.
</li>
<li>(6.2) &mdash;
If <code class='backtick'>other</code> is valueless, <code class='backtick'>*this</code> becomes valueless<del> and the owned object
in <code class='backtick'>*this</code>, if any, is destroyed using
<code>allocator_traits&lt;Allocator&gt;::destroy</code>
and then the storage is deallocated</del>.
</li>
<li>(6.3) &mdash;
Otherwise,
<ins>if the allocator needs updating or</ins>
if <code><i>alloc</i> == other.<i>alloc</i></code> is <code class='backtick'>true</code>,
<del>
swaps the owned objects in <code class='backtick'>*this</code> and <code class='backtick'>other</code>;
the owned object in <code class='backtick'>other</code>, if any, is then destroyed using
<code>allocator_traits&lt;Allocator&gt;::destroy</code>
and then the storage is deallocated
</del>
<ins><code class='backtick'>*this</code> takes ownership of the owned object of <code class='backtick'>other</code></ins>.
</li>
<li>(6.4) &mdash;
Otherwise, constructs a new owned object with the owned object of <code class='backtick'>other</code>
as the argument as an rvalue, using either the allocator in <code class='backtick'>*this</code>
or the allocator in <code class='backtick'>other</code> if the allocator needs updating.
</li>
<li>(6.5) &mdash;
The previously owned object in <code class='backtick'>*this</code>, if any, is destroyed using
<code>allocator_traits&lt;Allocator&gt;::destroy</code>
and then the storage is deallocated.
</li>
<li>(6.6) &mdash;
If the allocator needs updating,
the allocator in <code class='backtick'>*this</code> is replaced with a copy of the allocator in <code class='backtick'>other</code>.
</li>
</ol>
</p>
<p>-7- <i>Postcondition</i>: <code class='backtick'>other</code> is valueless.</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4252"><a href="4252">4252</a>. Are exposition-only classes considered specified for the purpose of <code class='backtick'>final</code>?</h3>
<p><b>Section:</b> 16.4.6.13 <a href="https://timsong-cpp.github.io/cppwp/derivation">[derivation]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-04-28 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#derivation">issues</a> in [derivation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, iterator and sentinel types of several views are exposition-only in the standard wording, 
and none of them is specified to be <code class='backtick'>final</code>. These types are arguably required to be non-final due to 
16.4.6.13 <a href="https://timsong-cpp.github.io/cppwp/derivation">[derivation]</a> p4 because it's possible to say they are specified except for names.
<p/>
However, libc++ marks <code class='backtick'>join_view</code>'s iterator <code class='backtick'>final</code> for some reasons 
(<a href="https://reviews.llvm.org/D142811#inline-1383022">https://reviews.llvm.org/D142811#inline-1383022</a>). 
Perhaps we should clarify that the <code class='backtick'>final</code>-ity of exposition-only class is unspecified.
</p>

<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
Votes for P2 (due to implementation divergence), NAD, and LEWG.
</p>



<p id="res-4252"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 16.4.6.13 <a href="https://timsong-cpp.github.io/cppwp/derivation">[derivation]</a> as indicated:</p>

<blockquote>
<p>
-4- All types specified in the C++ standard library shall be non-<code class='backtick'>final</code> types unless otherwise specified.
<ins>Exposition-only classes (16.3.3.2 <a href="https://timsong-cpp.github.io/cppwp/expos.only.entity">[expos.only.entity]</a>) are not considered specified for the purpose 
of <code class='backtick'>final</code>.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4254"><a href="4254">4254</a>. <code>stride_view::<i>iterator</i></code> should provide <code>operator-&gt;</code></h3>
<p><b>Section:</b> 25.7.32.3 <a href="https://timsong-cpp.github.io/cppwp/range.stride.iterator">[range.stride.iterator]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-05-01 <b>Last modified:</b> 2025-05-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, only <code>filter_view::<i>iterator</i></code> and <code>join_view::<i>InnerIter</i></code> in
<code>&lt;ranges&gt;</code> provide <code>operator-&gt;</code>, which makes sense since their <code class='backtick'>operator*</code>
simply dereferences the underlying iterator.
<p/>
It turns out this is also true for <code>stride_view::<i>iterator</i></code>, suggesting that providing
<code>operator-&gt;</code> does is the intuitive thing to do, e.g. when wrapping pointers, keeping 
<code>operator-&gt;</code> valid so that users can continue to use <code>it-&gt;foo()</code>.
<p/>
There is no reason to give up this convenience because <code>stride_view::<i>iterator</i></code> is intended 
to preserve the nature of the underlying iterator.
</p>


<p id="res-4254"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 25.7.32.3 <a href="https://timsong-cpp.github.io/cppwp/range.stride.iterator">[range.stride.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt;
  template&lt;bool Const&gt;
  class stride_view&lt;V&gt;::<i>iterator</i> {
    using <i>Parent</i> = <i>maybe-const</i>&lt;Const, stride_view&gt;;                      // <i>exposition only</i>
    using <i>Base</i> = <i>maybe-const</i>&lt;Const, V&gt;;                                  // <i>exposition only</i>

    iterator_t&lt;<i>Base</i>&gt; <i>current_</i> = iterator_t&lt;<i>Base</i>&gt;();                      // <i>exposition only</i>
    sentinel_t&lt;<i>Base</i>&gt; <i>end_</i> = sentinel_t&lt;<i>Base</i>&gt;();                          // <i>exposition only</i>
    range_difference_t&lt;<i>Base</i>&gt; <i>stride_</i> = 0;                                // <i>exposition only</i>
    range_difference_t&lt;<i>Base</i>&gt; <i>missing_</i> = 0;                               // <i>exposition only</i>

    constexpr iterator(<i>Parent</i>* parent, iterator_t&lt;<i>Base</i>&gt; current,        // <i>exposition only</i>
                       range_difference_t&lt;<i>Base</i>&gt; missing = 0);
  public:
    [&hellip;]
  
    constexpr decltype(auto) operator*() const { return *<i>current_</i>; }
    <ins>constexpr auto operator-&gt;() const
      requires <i>has-arrow</i>&lt;iterator_t&lt;<i>Base</i>&gt;&gt; &amp;&amp; copyable&lt;iterator_t&lt;<i>Base</i>&gt;&gt;
    { return <i>current_</i>; }</ins>
  
    [&hellip;]
  };
}</pre>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4255"><a href="4255">4255</a>. <code class='backtick'>move_only_function</code> constructor should recognize empty <code class='backtick'>copyable_function</code>s</h3>
<p><b>Section:</b> 22.10.17.4.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.move.ctor">[func.wrap.move.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2025-05-12 <b>Last modified:</b> 2025-05-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.move.ctor">active issues</a> in [func.wrap.move.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.move.ctor">issues</a> in [func.wrap.move.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard currently requires that constructing <code>move_only_function</code>
from empty <code>copyable_function</code>, creates an non-empty <code>move_only_function</code>,
that contains an empty <code>copyable_function</code> as the target. For example:
</p>
<blockquote><pre>
std::copyable_function&lt;int(int)&gt; ce;
std::move_only_function&lt;int(int)&gt; me(ce);
</pre></blockquote>
<p>
We require that invoking <code>me(1)</code> is undefined behavior (as it leads to call to the
<code>ce(1)</code>), however it cannot be detected in the user code, as <code>me != nullptr</code>
is true.
</p>
<p>
We should require the <code>move_only_function(F&amp;&amp; f)</code> constructor to create an
empty object, if <code>f</code> is an instantiation of <code>copyable_function</code> and
<code>f == nullptr</code> is true, i.e. <code class='backtick'>f</code> does not contain target object.
</p>
<p>
This simplifies implementing avoidance of double wrapping per 22.10.17.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.general">[func.wrap.general]</a> p2,
as transferring the target produces an empty functor.
</p>
<p>
The <code>copyable_function</code> cannot be constructed from <code>move_only_function</code>,
as it requires functor to be copyable. Invoking an empty <code>std::function</code> has well
defined behavior (throws <code>bad_function_call</code>), and wrapping such object into
other functors should reproduce that behavior.
</p>


<p id="res-4255"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 22.10.17.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.general">[func.wrap.general]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F&gt; move_only_function(F&amp;&amp; f);
</pre>
<blockquote>
[&hellip;]
<p>
-8- <i>Postconditions:</i>: <code>*this</code> has no target object if any of the following hold:
</p>
<ol style="list-style-type: none">
<li><p>(8.1) &mdash; <code>f</code> is a null function pointer value, <del>or</del></p></li>
<li><p>(8.2) &mdash; <code>f</code> is a null member pointer value, or</p></li>
<li><p>(8.2) &mdash; <code>remove_cvref_t&lt;F&gt;</code> is a specialization of the <code>move_only_function</code>
     <ins>or <code>copyable_function</code></ins> class template, and <code>f</code> has no target object.</p></li>
</ol>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4256"><a href="4256">4256</a>. Incorrect constrains for <code>function_ref</code> constructors from <code>nontype_t</code></h3>
<p><b>Section:</b> 22.10.17.6.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.ref.ctor">[func.wrap.ref.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2025-05-14 <b>Last modified:</b> 2025-06-09</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For the following class:
</p>
<pre>
struct M
{
   void operator()();
};
</pre>
<p>
The constructor of <code>function_ref&lt;void()&gt;</code> from <code>nontype_t</code>
is considered to be valid candidate 
(<code>is_constructible_v&lt;function_ref&lt;void()&gt;, nontype_t&lt;M{}&gt;&gt;</code> 
is <code>true</code>), despite the fact that the corresponding invocation of template 
argument object, that is const lvalue, is ill-formed. As consequence we produce a hard 
error from inside of this constructor.
</p>
<p>
This is caused by the fact that for constructors with non-type <code>auto f</code> parameter,
we are checking if <code><i>is-invocable-using</i>&lt;F&gt;</code> is <code>true</code>,
where <code>F</code> is <code>decltype(f)</code> i.e. <code>M</code> for the example.
We should use <code>const F&amp;</code> or <code>decltype((f))</code>.
</p>



<p id="res-4256"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 22.10.17.6.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.ref.ctor">[func.wrap.ref.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;auto f&gt; constexpr function_ref(nontype_t&lt;f&gt;) noexcept;
</pre>
<blockquote>
<p>-8- Let <code>F</code> be <code>decltype(f)</code>.</p>
<p>-9- <i>Constraints</i>: <code><i>is-invocable-using</i>&lt;<ins>const </ins>F<ins>&amp;</ins>&gt;</code> is <code>true</code>.</p>
[&hellip;]
</blockquote>

<pre>
template&lt;auto f, class U&gt; constexpr function_ref(nontype_t&lt;f&gt;, U&amp;&amp; obj) noexcept;
</pre>
<blockquote>
<p>-12- Let <code>T</code> be <code>remove_reference_t&lt;U&gt;</code> and <code>F</code> be <code>decltype(f)</code>.</p>
<p>-13- <i>Constraints:</i>:</p>
<ol style="list-style-type: none">
<li><p>(13.1) &mdash; <code>is_rvalue_reference_v&lt;U&amp;&amp;&gt;</code> is false, and</p></li>
<li><p>(13.2) &mdash; <code><i>is-invocable-using</i>&lt;<ins>const </ins>F<ins>&amp;</ins>, T <i>cv</i>&amp;&gt;</code> is <code>true</code>.</p></li>
</ol>
[&hellip;]
</blockquote>

<pre>
template&lt;auto f, class T&gt; constexpr function_ref(nontype_t&lt;f&gt;, T <i>cv</i>* obj) noexcept;
</pre>
<blockquote>
<p>-17- Let <code>F</code> be <code>decltype(f)</code>.</p>
<p>-16- <i>Constraints</i>: <code><i>is-invocable-using</i>&lt;<ins>const </ins>F<ins>&amp;</ins>, T <i>cv</i>*&gt;</code> is <code>true</code>.</p>
[&hellip;]
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3 id="4258"><a href="4258">4258</a>. Size type mismatch in constraints involving <i>Cpp17Allocator</i></h3>
<p><b>Section:</b> 16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-05-05 <b>Last modified:</b> 2025-05-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements.general">active issues</a> in [allocator.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements.general">issues</a> in [allocator.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems assumed that a <code class='backtick'>size_t</code> value can be passed to an allocator's <code class='backtick'>allocate</code> member 
function per the <code><i>simple-allocator</i></code> exposition-only concept in 
16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a> and the minimal constraints for 
allocator types in 23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a>.
<p/>
However, it is not exactly required that a type meeting the <i>Cpp17Allocator</i> requirements 
can be used with <code class='backtick'>size_t</code> values, because only <code>allocator_traits&lt;A&gt;::size_type</code>, 
which is possibly not <code class='backtick'>size_t</code>, is required to be usable with the allocator.
<p/>
Do we want to change these constraints, or change the <i>Cpp17Allocator</i> requirements to 
require accepting <code class='backtick'>size_t</code> values?
</p>


<p id="res-4258"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4259"><a href="4259">4259</a>. P1148R0 changed the return values of searching functions of <code class='backtick'>std::basic_string</code> on some platforms</h3>
<p><b>Section:</b> 27.4.3.8.2 <a href="https://timsong-cpp.github.io/cppwp/string.find">[string.find]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-05-05 <b>Last modified:</b> 2025-06-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.find">active issues</a> in [string.find].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.find">issues</a> in [string.find].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P1148R0" title=" Cleaning up Clause 20">P1148R0</a> respecified the searching functions of <code class='backtick'>std::basic_string</code> to return 
corresponding string view type's <code class='backtick'>npos</code> member constant (equal to <code class='backtick'>std::size_t(-1)</code>), converted 
to the string type <code class='backtick'>S</code>'s member <code class='backtick'>S::size_type</code>, when the search fails. Before the change, 
<code class='backtick'>S::npos</code> (equal to <code class='backtick'>S::size_type(-1)</code>) was returned on failure.
<p/>
On platforms where <code class='backtick'>std::size_t</code> isn't the widest unsigned integer type (e.g. on usual 32-bit 
platforms), the return value can change. Because there can be an allocator with a wider size_type, 
and when the basic_string type <code class='backtick'>S</code> uses such an allocator, <code class='backtick'>S::size_type</code> is specified to be that 
type, which in turn makes <code class='backtick'>S::size_type(std::size_t(-1))</code> not equal to <code class='backtick'>S::size_type(-1)</code>.
<p/>
Do we want to restore the old return values?
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 27.4.3.8.2 <a href="https://timsong-cpp.github.io/cppwp/string.find">[string.find]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr size_type find(const T&amp; t, size_type pos = 0) const noexcept(<i>see below</i>);
[&hellip;]
template&lt;class T&gt;
  constexpr size_type find_last_not_of(const T&amp; t, size_type pos = npos) const noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- <i>Constraints</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: Let <code><i>G</i></code> be the name of the function. Equivalent to:
</p>
<blockquote><pre>
basic_string_view&lt;charT, traits&gt; s = *this, sv = t;
<del>return s.<i>G</i>(sv, pos);</del>
<ins>if (auto result = s.<i>G</i>(sv, pos); result == size_t(-1))
  return npos;
else
  return result;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2025-06-10, reflector discussion]</i></p>

<p>
During reflector discussion of this issue there was a preference to adjust the
proposed wording to use <code class='backtick'>s.npos</code> instead of <code class='backtick'>size_t(-1)</code>. 
</p>


<p id="res-4259"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 27.4.3.8.2 <a href="https://timsong-cpp.github.io/cppwp/string.find">[string.find]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr size_type find(const T&amp; t, size_type pos = 0) const noexcept(<i>see below</i>);
[&hellip;]
template&lt;class T&gt;
  constexpr size_type find_last_not_of(const T&amp; t, size_type pos = npos) const noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- <i>Constraints</i>: [&hellip;]
<p/>
-3- <i>Effects</i>: Let <code><i>G</i></code> be the name of the function. Equivalent to:
</p>
<blockquote><pre>
basic_string_view&lt;charT, traits&gt; s = *this, sv = t;
<del>return s.<i>G</i>(sv, pos);</del>
<ins>if (auto result = s.<i>G</i>(sv, pos); result == s.npos)
  return npos;
else
  return result;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4260"><a href="4260">4260</a>. Query objects must be default constructible</h3>
<p><b>Section:</b> 33.2.1 <a href="https://timsong-cpp.github.io/cppwp/exec.queryable.general">[exec.queryable.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2025-05-07 <b>Last modified:</b> 2025-05-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Imported from <a href="https://github.com/cplusplus/sender-receiver/issues/333">cplusplus/sender-receiver #333</a>. 
<p/>
We require the types of query objects such as <code class='backtick'>get_scheduler</code> to be customization point objects. 
16.3.3.3.5 <a href="https://timsong-cpp.github.io/cppwp/customization.point.object">[customization.point.object]</a> requires them to be <code class='backtick'>semiregular</code> but that concept 
does not require default constructability. Much of <code class='backtick'>std::execution</code> assumes query object types 
to be default constructible.
<p/>
I propose adding a (nothrow) default-constructibility requirement.
</p>


<p id="res-4260"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 33.2.1 <a href="https://timsong-cpp.github.io/cppwp/exec.queryable.general">[exec.queryable.general]</a> as indicated:</p>

<blockquote>
<p>
-1- A <i>queryable object</i> is a read-only collection of key/value pair where each key is a 
customization point object known as a <i>query object</i>. 
<ins>The type of a query object satisfies <code class='backtick'>default_initializable</code>, and its default constructor 
is not potentially throwing.</ins>
A <i>query</i> is an invocation of a query object with a queryable object as its first
argument and a (possibly empty) set of additional arguments. 
A query imposes syntactic and semantic requirements on its invocations.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4261"><a href="4261">4261</a>. P1206R7 broke uses of container adaptors with old custom sequence containers</h3>
<p><b>Section:</b> 27.4.3.8.2 <a href="https://timsong-cpp.github.io/cppwp/string.find">[string.find]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-05-07 <b>Last modified:</b> 2025-05-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.find">active issues</a> in [string.find].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.find">issues</a> in [string.find].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P1206R7" title=" Conversions from ranges to containers">P1206R7</a> added some requirements for sequence containers, including program-defined ones.
<p/>
These requirements mean that if a custom C++20 sequence container type has no newly required member 
functions added in C++23 mode, it is no longer a sequence container, and uses of it with 
<code class='backtick'>std::stack</code>, <code class='backtick'>std::queue</code>, or <code class='backtick'>std::priority_queue</code> possibly have undefined behavior or 
make the program ill-formed. Additionally, some users want to use C++23 flat container adaptors 
with old sequence containers (<a href="https://github.com/llvm/llvm-project/issues/136656">llvm/llvm-project#136656</a>), 
it is unclear whether such uses are intentionally rejected.
<p/>
Perhaps the requirements on <code class='backtick'>from_range_t</code> constructor, <code class='backtick'>insert_range</code> and <code class='backtick'>assign_range</code> should be made optional, 
although these operations should have specified semantics whenever being well-formed in immediate contexts.
</p>


<p id="res-4261"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4262"><a href="4262">4262</a>. <code class='backtick'>copy_if</code>, <code class='backtick'>remove_copy</code>, <code class='backtick'>remove_copy_if</code>, <code class='backtick'>unique_copy</code> have too strong preconditions</h3>
<p><b>Section:</b> 26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>, 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>, 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alex Guteniev <b>Opened:</b> 2025-05-12 <b>Last modified:</b> 2025-05-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in [alg.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in [alg.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>/16 , 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>/11, 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a>/8.1 all say:
</p>
<blockquote>
<p>
<i>Preconditions</i>: The ranges <code class='backtick'>[first, last)</code> and <code class='backtick'>[result, result + (last - first))</code> do not overlap.
</p>
</blockquote>
<p>
These algorithms may produce fewer elements than <code class='backtick'>(last - first)</code>. If this is known in advance, 
a smaller output range may be used, so that the precondition will not be satisfied.
<p/>
Example from LLVM test suite 
(<a href="https://github.com/llvm/llvm-project/blob/79210feb2993ff9a79ef11f8a7016a527d4fcf22/libcxx/test/std/algorithms/alg.modifying.operations/alg.copy/ranges.copy_if.pass.cpp#L160-L162">
/libcxx/test/std/algorithms/alg.modifying.operations/alg.copy/ranges.copy_if.pass.cpp</a>):
</p>
<blockquote><pre>
std::array&lt;S, 4&gt; in = {{{4, 2}, {1, 3}, {3, 4}, {3, 5}}};
std::array&lt;S, 2&gt; out;
auto ret = std::ranges::copy_if(in.begin(), in.end(), out.begin(), [](int i) { return i == 3; }, &amp;S::val);
</pre></blockquote>
<p>
I think there should be a weaker precondition, like 26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a>/2:
</p>
<blockquote>
<p>
<i>Preconditions</i>: <code class='backtick'>result</code> is not in the range <code class='backtick'>[first, last)</code>.
</p>
</blockquote>


<p id="res-4262"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 26.7.1 <a href="https://timsong-cpp.github.io/cppwp/alg.copy">[alg.copy]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
  constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                   OutputIterator result, Predicate pred);
[&hellip;]
template&lt;input_range R, weakly_incrementable O, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
  constexpr ranges::copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
    ranges::copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});
</pre>
<blockquote>
<p>
-15- Let <code><i>E</i></code> be: [&hellip;]
<p/>
-16 <i>Preconditions</i>: <ins><code class='backtick'>result</code> is not in the range <code class='backtick'>[first, last)</code></ins><del>The ranges <code class='backtick'>[first, last)</code> and <code class='backtick'>[result, result + (last - first))</code> do not overlap</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class OutputIterator,
         class T = iterator_traits&lt;InputIterator&gt;::value_type>
  constexpr OutputIterator
    remove_copy(InputIterator first, InputIterator last,
                OutputIterator result, const T&amp; value);
[&hellip;]
template&lt;input_range R, weakly_incrementable O, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;
  constexpr ranges::remove_copy_if_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
    ranges::remove_copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});
</pre>
<blockquote>
<p>
-8- Let <code><i>E</i></code> be [&hellip;]
<p/>
[&hellip;]
<p/>
-11 <i>Preconditions</i>: <ins><code class='backtick'>result</code> is not in the range <code class='backtick'>[first, last)</code></ins><del>The ranges <code class='backtick'>[first, last)</code> and <code class='backtick'>[result, result + (last - first))</code> do not overlap</del>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class OutputIterator&gt;
  constexpr OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result);
[&hellip;]
template&lt;input_range R, weakly_incrementable O, class Proj = identity,
         indirect_equivalence_relation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&gt;
  requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
          (forward_iterator&lt;iterator_t&lt;R&gt;&gt; ||
          (input_iterator&lt;O&gt; &amp;&amp; same_as&lt;range_value_t&lt;R&gt;, iter_value_t&lt;O&gt;&gt;) ||
          indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, O&gt;)
  constexpr ranges::unique_copy_result&lt;borrowed_iterator_t&lt;R&gt;, O&gt;
    ranges::unique_copy(R&amp;&amp; r, O result, C comp = {}, Proj proj = {});
</pre>
<blockquote>
<p>
-6- Let <code class='backtick'>pred</code> be [&hellip;]
<p/>
-7- <i>Mandates</i>: [&hellip;]
<p/>
-8 <i>Preconditions</i>:
</p>
<ol style="list-style-type: none">
<li><p>(8.1) &mdash; <ins><ins><code class='backtick'>result</code> is not in the range <code class='backtick'>[first, last)</code></ins></ins><del>The ranges <code class='backtick'>[first, last)</code> and <code class='backtick'>[result, result + (last - first))</code> do not overlap</del>.</p></li>
<li><p>(8.2) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4263"><a href="4263">4263</a>. What should <code class='backtick'>std::format_to</code> etc. behave when the output is overlong?</h3>
<p><b>Section:</b> 28.5 <a href="https://timsong-cpp.github.io/cppwp/format">[format]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-05-14 <b>Last modified:</b> 2025-05-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format">active issues</a> in [format].</p>
<p><b>View all other</b> <a href="lwg-index.html#format">issues</a> in [format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems permitted to write overly long contents via an (C++20) output iterator with 
<code class='backtick'>std::format_to(_n)</code>, where the length isn't representable in <code class='backtick'>size_t</code> or <code class='backtick'>ptrdiff_t</code>, 
especially when the implementation provides integer-class types. However, currently 
some implementation can't properly handle content whose length is greater than 
<code class='backtick'>PTRDIFF_MAX</code>. Presumably we don't want UB in such cases. Should we explicitly allow 
throwing exception and/or silent truncation?
<p/>
Additionally, given that the return type of <code class='backtick'>std::formatted_size</code> is <code class='backtick'>std::size_t</code>, 
even if the implementation supports formatted contents whose lengths are greater than 
<code class='backtick'>SIZE_MAX</code>, the length can't be correctly returned. Perhaps we need to either precisely 
specify the return value as modulo arithmetic seems undesired, or specify that an 
exception is thrown.
</p>


<p id="res-4263"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4264"><a href="4264">4264</a>. Skipping indirection is not allowed for <code>function_ref</code></h3>
<p><b>Section:</b> 22.10.17.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.general">[func.wrap.general]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2025-05-15 <b>Last modified:</b> 2025-06-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the wording in 22.10.17.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.general">[func.wrap.general]</a> allows implementation
to avoid double indirection when constructing owning functions wrappers from another one:
</p>
<blockquote>
<p>
-2- Let <code>t</code> be an object of a type that is a specialization of <code>function</code>,
<code>copyable_function</code>, or <code>move_only_function</code>, such that the target object
<code>x</code> of <code>t</code> has a type that is a specialization of <code>function</code>,
<code>copyable_function</code>, or <code>move_only_function</code>.
Each argument of the invocation of <code>x</code> evaluated as part of the invocation of <code>t</code>
may alias an argument in the same position in the invocation of <code>t</code> that has the same type,
even if the corresponding parameter is not of reference type.
</p>
</blockquote>
<p>
However, the wording does not cover a <code>function_ref</code>, disallowing implementation to perform
this optimization when signatures are compatible, for example:
</p>
<blockquote><pre>
std::function_ref&lt;void() noexcept&gt; f1(ptr);
std::function_ref&lt;void()&gt; f1(f2);
</pre></blockquote>
<p>
We should include <code>function_ref</code> in the list. Note that this allows, but does not require,
an implementation to perform such an optimization. As a consequence, it is acceptable
to specify the allowance for all combinations of polymorphic wrappers, even for creating an
owning wrapper from a non-owning one, where implementing such an optimization may not be possible.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 22.10.17.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.general">[func.wrap.general]</a> as indicated:</p>

<blockquote>
<p>
-2- Let <code>t</code> be an object of a type that is a specialization of <code>function</code>,
<code>copyable_function</code>, <del>or</del> <code>move_only_function</code><ins>, or <code>function_ref</code></ins>,
such that the target object <code>x</code> of <code>t</code> has a type that is a specialization of <code>function</code>,
<code>copyable_function</code>, <del>or</del><code>move_only_function</code><ins>, or <code>function_ref</code></ins>.
Each argument of the invocation of <code>x</code> evaluated as part of the invocation of <code>t</code>
may alias an argument in the same position in the invocation of <code>t</code> that has the same type,
even if the corresponding parameter is not of reference type.
</p>
</blockquote>

</li>
</ol>

</blockquote>

<p><i>[2024-05-21; Tomasz's comment and upates proposed resolution]</i></p>


<p>
After implementing double indirection avoidance in the libstdc++, I have realized
that above wording change is insufficient to cover all user observable effects of
the change. Revelant quote from the <a href="https://gcc.gnu.org/pipermail/libstdc++/2025-May/061561.html">
Avoid double indirection in function_ref</a>  from libstdc++ mailing lists:
</p>

<blockquote>
<p>
To avoidance of double indirection requires that constructed <code>function_ref</code>,
refers directly to the target function of the source, instead of source,
and this is visible after the assigment:
</p>

<pre>
void foo() noexcept;
void bar() noexcept;

std::function_ref&lt;void() noexcept&gt; sr(&amp;foo);
std::function_ref&lt;void()&gt; dr(sr);
dr(); // calls <code class='backtick'>foo</code> regardless of implementation

sr = &amp;bar;
sr(); // calls <code class='backtick'>bar</code>
dr(); // still calls <code class='backtick'>foo</code> if we avoid indirection,
      // calls <code class='backtick'>bar</code> if we do not
</pre>

<p>
Similary for <code>move_only_function</code>/<code>copyable_function</code> source:
</p>

<pre>
std::move_only_function&lt;void()&gt; sm;
std::function_ref&lt;void()&gt; dm(sm);

dm(); // UB because <code class='backtick'>sm</code> is empty

sm = &amp;foo;

dm(); // remains UB if we avoid indirection,
      // calls <code class='backtick'>bar</code> if we do not.
</pre>

<p>
While we may want to allow skipping indirection for function_ref,
as this produces same behavior as in case for copy constructor (matching
signatures):
</p>

<pre>
void foo() noexcept;
void bar() noexcept;

std::function_ref&lt;void() noexcept&gt; sr(&amp;foo);
std::function_ref&lt;void() noexcept&gt; dr(sr); // copy-cosntructor
dr(); // calls <code class='backtick'>foo</code> regardless of implementation

sr = &amp;bar;
sr(); // calls <code class='backtick'>bar</code>
dr(); // still calls <code class='backtick'>foo</code> if we avoid indirection
</pre>


<p>
I do not think this is acceptable for <code>move_only_function</code>.
&hellip;
</p>

<p>
Note that for the same reason, implementations are not free to avoid
dangling when constructing <code>function_ref</code> from <code>reference_wrapper</code>:
</p>

<pre>
auto srw = std::ref(&amp;foo);
std::function_ref&lt;void()&gt; drw(srw);
drw(); // calls <code class='backtick'>foo</code>

srw = std::ref(&amp;bar);
drw(); // calls <code class='backtick'>foo</code> if we unwrap referenc wrapper,
       // calls <code class='backtick'>bar</code> otherwise.
</pre>

<p>
Note that this is limited to <code>function_ref</code> due reference nature of this
wrapper.
</p>

</blockquote>

<p>
The updated resolution allows indirection but making it unspecified if
<code>function_ref</code> constructed from other <code>function_ref</code> specialization,
will refer to source object or its target.
</p>



<p id="res-4264"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 22.10.17.1 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.general">[func.wrap.general]</a> as indicated:</p>

<blockquote>
<p>
-2- Let <code>t</code> be an object of a type that is a specialization of <code>function</code>,
<code>copyable_function</code>, <del>or</del> <code>move_only_function</code><ins>, or <code>function_ref</code></ins>,
such that the target object <code>x</code> of <code>t</code> has a type that is a specialization of <code>function</code>,
<code>copyable_function</code>, <del>or</del><code>move_only_function</code><ins>, or <code>function_ref</code></ins>.
Each argument of the invocation of <code>x</code> evaluated as part of the invocation of <code>t</code>
may alias an argument in the same position in the invocation of <code>t</code> that has the same type,
even if the corresponding parameter is not of reference type.
</p>
</blockquote>

</li>

<li><p>Modify 22.10.17.6.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.ref.ctor">[func.wrap.ref.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F&gt; constexpr function_ref(F&amp;&amp;) noexcept;
</pre>
<blockquote>
[&hellip;]
<p>
-7- <i>Effects</i>: 
Initializes <code><i>bound-entity</i></code> with <code>addressof(f)</code>
and <code><i>thunk-ptr</i></code> with the address of a function <code><i>thunk</i></code> such that 
<code><i>thunk</i>(<i>bound-entity</i>, <i>call-args</i>...)</code> is expression-equivalent
(3.22 <a href="https://timsong-cpp.github.io/cppwp/defns.expression.equivalent">[defns.expression.equivalent]</a>) to 
<code>invoke_r&lt;R&gt;(static_cast&lt;cv T&amp;&gt;(f), <i>call-args</i>...)</code>.
</p>
<p>
<ins>-?- <i>Remarks</i>:
If <code>remove_cveref_t&lt;F&gt;</code> is a specialization of <code>function_ref</code> an implementation
may initialize <code><i>bound-entity</i></code> with <code><i>bound-entity</i></code> of <code>f</code>.
[<i>Example:</i>:</ins>
</p>
<pre>
<ins>void f1() noexcept;
void f2() noexcept;

function_ref&lt;void() noexcept&gt; r1(&amp;r1);
function_ref&lt;void()&gt; r2(r1);
r1 = &amp;f2;
f2(); // it is unspecified if <code class='backtick'>f1</code> or <code class='backtick'>f2</code> is invoked</ins>
</pre>
<p> 
<ins>&mdash; <i>end example</i>]</ins>
</p>
</blockquote>
</blockquote>

</li>
</ol>







<hr>
<h3 id="4265"><a href="4265">4265</a>. <code class='backtick'>std::midpoint</code> should not accept <code class='backtick'>const bool</code></h3>
<p><b>Section:</b> 26.10.16 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.midpoint">[numeric.ops.midpoint]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2025-05-21 <b>Last modified:</b> 2025-05-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.ops.midpoint">issues</a> in [numeric.ops.midpoint].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The constraints of the first overload of <code class='backtick'>std::midpoint</code> are as follows:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
  constexpr T midpoint(T a, T b) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <code class='backtick'>T</code> is an arithmetic type other than <code class='backtick'>bool</code>.
</p>
</blockquote>
</blockquote>
<p>
It does not appear intentional that <code class='backtick'>const bool</code> is supported considering that 
26.10.14 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.gcd">[numeric.ops.gcd]</a> excludes <i>cv</i> <code class='backtick'>bool</code>.
<p/>
More generally, it is questionable that <i>cv</i>-qualified arithmetic types aren't 
excluded in general, considering that 26.10.17 <a href="https://timsong-cpp.github.io/cppwp/numeric.sat">[numeric.sat]</a> excludes them with 
the "signed or unsigned integer type" constraint. However, tightening the constraints 
for these other functions seems evolutionary, not like fixing an obvious oversight, 
and so it likely requires a separate issue.
</p>



<p id="res-4265"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 26.10.16 <a href="https://timsong-cpp.github.io/cppwp/numeric.ops.midpoint">[numeric.ops.midpoint]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr T midpoint(T a, T b) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <code class='backtick'>T</code> is an arithmetic type other than <ins><i>cv</i></ins> <code class='backtick'>bool</code>.
</p>
</blockquote>
</blockquote>

</li>

</ol>






<hr>
<h3 id="4267"><a href="4267">4267</a>. Uses-allocator construction is meaningless for tuple of references</h3>
<p><b>Section:</b> 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-05-24 <b>Last modified:</b> 2025-05-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Per 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>/1, uses-allocator construction is only defined for objects. 
And presumably, an attempt to construct <code class='backtick'>std::tuple</code> of reference from an <code class='backtick'>allocator_arg_t</code> constructor 
causes a hard error.
<p/>
Since C++23/<a href="https://wg21.link/P2255R2" title=" A type trait to detect reference binding to temporary">P2255R2</a>, it seems that these <code class='backtick'>allocator_arg_t</code> constructors are conditionally 
deleted according to 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>/33. However, it's confusing that these constructors are 
sometimes non-deleted when the tuple contains a reference, while there are hard errors in an instantiation 
instead.
</p>


<p id="res-4267"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>
<ol>

<li><p>Modify 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Alloc&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a);
[&hellip;]
template&lt;class Alloc, tuple-like UTuple&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, UTuple&amp;&amp;);
</pre>
<blockquote>
<p>
-32- <i>Preconditions</i>: <code class='backtick'>Alloc</code> meets the <i>Cpp17Allocator</i> requirements (16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a>).
<p/>
-33- <i>Effects</i>: Equivalent to the preceding constructors except that each element is constructed with uses-allocator
construction (20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>).
<p/>
<ins>-?- <i>Remarks</i>: These constructors are defined as deleted if <code>is_reference_v&lt;T<sub><i>i</i></sub>&gt;</code> 
is <code class='backtick'>true</code> for at least one <code>T<sub><i>i</i></sub></code>.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>






<hr>
<h3 id="4268"><a href="4268">4268</a>. <code>function&lt;void()&gt;</code> suppresses <code class='backtick'>nodiscard</code> warnings</h3>
<p><b>Section:</b> 22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-05-29 <b>Last modified:</b> 2025-05-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.require">active issues</a> in [func.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.require">issues</a> in [func.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<pre><code>struct [[nodiscard]] A { };
A f();
std::function&lt;void()&gt; func = f;
</code></pre>
<p>
Invoking <code class='backtick'>func()</code> will discard the return value of <code class='backtick'>f()</code>, but there will be
no warning. This is because <code><i>INVOKE</i>&lt;void&gt;(...)</code>
is defined in terms of <code>static_cast&lt;void&gt;(...)</code> and the
explicit cast to void suppresses <code class='backtick'>nodiscard</code> warnings.
This is in contast to <code><i>INVOKE</i>&lt;R&gt;(...)</code> where the
conversion to non-void <code class='backtick'>R</code> is implicit.
</p>

<p>
It seems right that <code>std::invoke_r&lt;void&gt;(f)</code> should not give
<code class='backtick'>nodiscard</code> warnings, because that's quite explicit about converting to void,
and similarly for <code>std::bind&lt;void&gt;(f)()</code>.
However, I think it's debatable whether all uses of <code><i>INVOKE</i>&lt;void&gt;</code> (and <code>std::function&lt;void()&gt;</code> in particular)
intend an explicit cast to void that ignores <code class='backtick'>nodiscard</code> types.
It's very easy to set <code class='backtick'>f</code> as the target of <code class='backtick'>func</code> and then lose its warning,
and there's no explicit use of <code class='backtick'>void</code> when you write <code class='backtick'>func = f; func();</code>.
</p>
<p>
We could consider defining <code><i>INVOKE</i>&lt;void&gt;(...)</code> to be
an expression of type void, without explicitly saying there's a cast to void.
For example, <code class='backtick'>(INVOKE(...), void())</code> would invoke the invocable and have type
<code class='backtick'>void</code>, but would not require any <code class='backtick'>nodiscard</code> warnings to be suppressed.
If we did that, some uses of <code><i>INVOKE</i>&lt;R&gt;</code> such as
<code>std::invoke_r</code> and <code>std::bind&lt;R&gt;</code> might need to
be adjusted to preserve the explicit conversion to void.
That would allow us to be selective about which uses of
<code><i>INVOKE</i>&lt;void&gt;</code> we consider to be explicit about
discarding results, and which we don't.
</p>


<p id="res-4268"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4269"><a href="4269">4269</a>. <code class='backtick'>unique_copy</code> passes arguments to its predicate backwards</h3>
<p><b>Section:</b> 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-05-29 <b>Last modified:</b> 2025-05-29</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.unique">active issues</a> in [alg.unique].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For the <code class='backtick'>unique</code> algorithms, 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> p1 says:
</p>
<blockquote>
1. Let <code class='backtick'>pred</code> be <code class='backtick'>equal_to{}</code> for the overloads with no parameter <code class='backtick'>pred</code>,
and let <i>E</i> be
<ol style="list-style-type: none">
<li> (1.1)
 &mdash; <code class='backtick'>bool(pred(*(i - 1), *i))</code> for the overloads in namespace <code class='backtick'>std</code>;
</li>
<li>(1.2)
 &mdash; <code class='backtick'>bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i)))</code>
 for the overloads in namespace <code class='backtick'>ranges</code>.
</li>
</ol>
</blockquote>
<p>
However for the <code class='backtick'>unique_copy</code> algorithms, 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> p6 says
that the arguments <code class='backtick'>*i</code> and <code class='backtick'>*(i-1)</code> should be reversed:
</p>
<blockquote>
6. Let <code class='backtick'>pred</code> be <code class='backtick'>equal_to{}</code> for the overloads with no parameter <code class='backtick'>pred</code>,
and let <i>E</i> be
<ol style="list-style-type: none">
<li> (6.1)
 &mdash; <code class='backtick'>bool(pred(*i, *(i - 1)))</code> for the overloads in namespace <code class='backtick'>std</code>;
</li>
<li>(6.2)
 &mdash; <code class='backtick'>bool(invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1))))</code>
 for the overloads in namespace <code class='backtick'>ranges</code>.
</li>
</ol>
</blockquote>
<p>
This reversed order is consistent with the documentation for
<a href="https://stl.boost.org/unique_copy.html">SGI STL <code class='backtick'>unique_copy</code></a>,
although the docs for 
<a href="https://stl.boost.org/unique_copy.html">SGI STL <code class='backtick'>unique</code></a>
show reversed arguments too, and the C++ standard doesn't match that.
</p>
<p>
A survey of known implementations shows that all three of libstdc++, libc++,
and MSVC STL use the <code class='backtick'>pred(*(i - 1), *i)</code> order for all of <code class='backtick'>std::unique</code>,
<code class='backtick'>std::unique_copy</code>, <code class='backtick'>ranges::unique</code>, and <code class='backtick'>ranges::unique_copy</code>. The range-v3
library did the same, and even the SGI STL did too (despite what its docs said).
Only two implementations were found which match the spec and use a different
argument order for <code class='backtick'>unique</code> and <code class='backtick'>unique_copy</code>, Casey Carter's (cmcstl2) and
Fraser Gordon's.
</p>
<p>
In the absence of any known rationale for <code class='backtick'>unique</code> and <code class='backtick'>unique_copy</code> to differ,
it seems sensible to make <code class='backtick'>unique_copy</code> more consistent with <code class='backtick'>unique</code>
(and with the majority of implementations stretching back three decades).
</p>


<p id="res-4269"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 26.7.9 <a href="https://timsong-cpp.github.io/cppwp/alg.unique">[alg.unique]</a> as indicated:</p>
<blockquote>
6. Let <code class='backtick'>pred</code> be <code class='backtick'>equal_to{}</code> for the overloads with no parameter <code class='backtick'>pred</code>,
and let <i>E</i> be
<ol style="list-style-type: none">
<li> (6.1)
 &mdash; <code>bool(pred(<del>*i,</del> *(i - 1))<ins>, *i</ins>)</code>
 for the overloads in namespace <code class='backtick'>std</code>;
</li>
<li>(6.2)
 &mdash; <code>bool(invoke(comp, <del>invoke(proj, *i),</del>
 invoke(proj, *(i - 1))<ins>, invoke(proj, *i)</ins>))</code>
 for the overloads in namespace <code class='backtick'>ranges</code>.
</li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4270"><a href="4270">4270</a>. Diagnose misuse of <code class='backtick'>std::projected::operator*</code></h3>
<p><b>Section:</b> 24.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/projected">[projected]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-05-30 <b>Last modified:</b> 2025-06-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#projected">issues</a> in [projected].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>std::projected::operator*</code> is only intentionally used for type calculation like <code class='backtick'>std::declval</code>. 
Currently, if one attempts to call it in a potentially evaluated expression, the program is ill-formed, 
no diagnostic required because the <code class='backtick'>operator*</code> is not defined.
<p/>
It seems better to diagnose such misuse, as we are already diagnosing misuse of <code class='backtick'>std::declval</code> 
(22.2.6 <a href="https://timsong-cpp.github.io/cppwp/declval">[declval]</a>/2). Implementation used to perform such misuse via <code class='backtick'>std::ranges::iter_move</code>, 
but libc++ and libstdc++ have already switched not to do this (see 
<a href="https://github.com/microsoft/STL/issues/5555">microsoft/STL#5555</a>).
</p>


<p id="res-4270"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 24.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/projected">[projected]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class I, class Proj&gt;
  struct <i>projected-impl</i> { <i>// exposition only</i>
    struct <i>type</i> { <i>// exposition only</i>
      [&hellip;]
      <i>// models weakly_incrementable</i>
      indirect_result_t&lt;Proj&amp;, I&gt; operator*() const; <del><i>// not defined</i></del>
    };
  };
  [&hellip;]
}
</pre>
<pre>
<ins>indirect_result_t&lt;Proj&amp;, I&gt; operator*() const;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates</i>: This function is not odr-used (6.3 <a href="https://timsong-cpp.github.io/cppwp/basic.def.odr">[basic.def.odr]</a>).</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4271"><a href="4271">4271</a>. Caching range views claim amortized amortized &#x1d4aa;(1) runtime
complexity for algorithms that are in fact &#x1d4aa;(n)</h3>
<p><b>Section:</b> 24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>, 25.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.approximately.sized">[range.approximately.sized]</a>, 25.4.1 <a href="https://timsong-cpp.github.io/cppwp/range.req.general">[range.req.general]</a>, 25.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.range">[range.range]</a>, 25.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a>, 25.7.8.2 <a href="https://timsong-cpp.github.io/cppwp/range.filter.view">[range.filter.view]</a>, 25.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a>, 25.7.13.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while.view">[range.drop.while.view]</a>, 25.7.17.2 <a href="https://timsong-cpp.github.io/cppwp/range.split.view">[range.split.view]</a>, 25.7.21.2 <a href="https://timsong-cpp.github.io/cppwp/range.reverse.view">[range.reverse.view]</a>, 25.7.30.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a>, 25.7.31.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.by.view">[range.chunk.by.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Andreas Weis <b>Opened:</b> 2025-06-02 <b>Last modified:</b> 2025-06-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements.general">issues</a> in [iterator.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently range views that cache the result of their operation claim an
amortized &#x1d4aa;(1) worst-case runtime complexity. This is inconsistent 
with the established practice in algorithm analysis, where the given
complexity bound must hold for all possible sequences of operations.
Caching is not sufficient to lower the complexity bound here, as the
sequence that contains only a single call to the operation will cause a
runtime cost linear in the size of the underlying range. Thus all of the
caching range operations are in fact &#x1d4aa;(n).
<p/>
Apart from the caching view operations, this also has secondary impacts
in other places that rely on the complexity of iterator functions, such
as the iterator requirements and functions for computing the size of a
range.
<p/>
It is unclear how desirable it is under these circumstances to continue
disallowing other kinds of &#x1d4aa;(n) behavior for iterator functions. 
While caching offers clear benefits in the context of lazy evaluation, it
cannot prevent losing the &#x1d4aa;(1) complexity guarantee. The proposed
changes below therefore do not address the issue that other types of
views (such as hypothetical non-caching variants of the affected views)
that were previously considered invalid will become valid with these
changes.
</p>


<p id="res-4271"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a> as indicated:</p>

<blockquote>
<p>
-14- All the categories of iterators require only those functions that are realizable 
for a given category in <del>constant time (amortized)</del><ins>linear time</ins>. 
Therefore, requirement tables and concept definitions for the iterators do not specify
complexity.
</p>
</blockquote>
</li>

<li><p>Modify 25.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.approximately.sized">[range.approximately.sized]</a> as indicated:</p>

<blockquote>
<p>
-1- The <code class='backtick'>approximately_sized_range</code> concept refines range with the requirement that 
an approximation of the number of elements in the range can be determined in 
<del>amortized constant</del><ins>linear</ins> time using <code class='backtick'>ranges::reserve_hint</code>.
</p>
</blockquote>
</li>

<li><p>Modify 25.4.1 <a href="https://timsong-cpp.github.io/cppwp/range.req.general">[range.req.general]</a> as indicated:</p>

<blockquote>
<p>
-2- The <code class='backtick'>range</code> concept requires that <code class='backtick'>ranges::begin</code> and <code class='backtick'>ranges::end</code> return an 
iterator and a sentinel, respectively. The <code class='backtick'>sized_range</code> concept refines range 
with the requirement that <code class='backtick'>ranges::size</code> be <del>amortized</del> &#x1d4aa;(<del>1</del><ins>n</ins>).
The <code class='backtick'>view</code> concept specifies requirements on a <code class='backtick'>range</code> type to provide operations 
with predictable complexity.
</p>
</blockquote>
</li>

<li><p>Modify 25.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.range">[range.range]</a> as indicated:</p>

<blockquote>
<p>
-2- Given an expression <code class='backtick'>t</code> such that <code class='backtick'>decltype((t))</code> is <code>T&amp;</code>, <code class='backtick'>T</code> models <code class='backtick'>range</code> 
only if
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>(2.2) &mdash; both <code class='backtick'>ranges::begin(t)</code> and <code class='backtick'>ranges::end(t)</code> are <del>amortized
constant</del><ins>linear</ins> time and non-modifying,
and</p></li>
<li><p>(2.3) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify 25.4.4 <a href="https://timsong-cpp.github.io/cppwp/range.sized">[range.sized]</a> as indicated:</p>

<blockquote>
<p>
-1- The <code class='backtick'>sized_range</code> concept refines <code class='backtick'>approximately_sized_range</code> with the 
requirement that the number of elements in the range can be determined in 
<del>amortized constant</del><ins>linear</ins> time using <code class='backtick'>ranges::size</code>.
</p>
<pre>
template&lt;class T&gt;
  concept sized_range =
    approximately_sized_range&lt;T&gt; &amp;&amp; requires(T&amp; t) { ranges::size(t); };
</pre>
<blockquote>
<p>
-2- Given an lvalue <code class='backtick'>t</code> of type <code>remove_reference_t&lt;T&gt;</code>, <code class='backtick'>T</code> models 
<code class='backtick'>sized_range</code> only if
</p>
</blockquote>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code class='backtick'>ranges::size(t)</code> is <del>amortized</del> &#x1d4aa;(<del>1</del><ins>n</ins>), 
does not modify <code class='backtick'>t</code>, and is equal to <code class='backtick'>ranges::distance(ranges::begin(t), ranges::end(t))</code>, 
and</p></li>
<li><p>(2.2) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify 25.7.8.2 <a href="https://timsong-cpp.github.io/cppwp/range.filter.view">[range.filter.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>iterator</i> begin();
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: [&hellip;]
<p/>
-4- <i>Returns</i>: [&hellip;]
<p/>
-5- <i>Remarks</i>: <del>In order to provide the amortized constant time complexity required 
by the <code class='backtick'>range</code> concept when <code class='backtick'>filter_view</code> models <code class='backtick'>forward_range</code>, this</del><ins>This</ins> 
function caches the result within the <code class='backtick'>filter_view</code> for use on subsequent calls.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto begin()
  requires (!(<i>simple-view</i>&lt;V&gt; &amp;&amp;
              random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;));
constexpr auto begin() const
  requires random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;;
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: [&hellip;]
<p/>
-4- <i>Remarks</i>: <del>In order to provide the amortized constant-time complexity 
required by the <code class='backtick'>range</code> concept when <code class='backtick'>drop_view</code> models <code class='backtick'>forward_range</code>, the</del><ins>The</ins> 
first overload caches the result within the <code class='backtick'>drop_view</code> for use on subsequent calls.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.13.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.while.view">[range.drop.while.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto begin();
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: [&hellip;]
<p/>
-4- <i>Returns</i>: [&hellip;]
<p/>
-5- <i>Remarks</i>: <del>In order to provide the amortized constant-time complexity 
required by the <code class='backtick'>range</code> concept when <code class='backtick'>drop_while_view</code> models <code class='backtick'>forward_range</code>, the</del><ins>The</ins> 
first call caches the result within the <code class='backtick'>drop_while_view</code> for use on subsequent calls.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.17.2 <a href="https://timsong-cpp.github.io/cppwp/range.split.view">[range.split.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>iterator</i> begin();
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: [&hellip;]
<p/>
-4- <i>Remarks</i>: <del>In order to provide the amortized constant time complexity 
required by the <code class='backtick'>range</code> concept, this</del><ins>This</ins> function caches the result 
within the <code class='backtick'>split_view</code> for use on subsequent calls.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.21.2 <a href="https://timsong-cpp.github.io/cppwp/range.reverse.view">[range.reverse.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; begin();
</pre>
<blockquote>
<p>
-2- <i>Returns</i>: [&hellip;]
<p/>
-3- <i>Remarks</i>: <del>In order to provide the amortized constant time complexity 
required by the <code class='backtick'>range</code> concept, this</del><ins>This</ins> function caches the 
result within the <code class='backtick'>reverse_view</code> for use on subsequent calls.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.30.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr auto begin()
  requires (!(<i>simple-view</i>&lt;V&gt; &amp;&amp; <i>slide-caches-nothing</i>&lt;const V&gt;));
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: [&hellip;]
<p/>
-4- <i>Remarks</i>: <del>In order to provide the amortized constant-time complexity 
required by the <code class='backtick'>range</code> concept, this</del><ins>This</ins> function caches the result 
within the <code class='backtick'>slide_view</code> for use on subsequent calls when <code class='backtick'>V</code> models
<code><i>slide-caches-first</i></code>.
</p>
</blockquote>
[&hellip;]
<pre>
constexpr auto end()
  requires (!(<i>simple-view</i>&lt;V&gt; &amp;&amp; <i>slide-caches-nothing</i>&lt;const V&gt;));
</pre>
<blockquote>
<p>
-6- <i>Returns</i>: [&hellip;]
<p/>
-7- <i>Remarks</i>: <del>In order to provide the amortized constant-time complexity 
required by the <code class='backtick'>range</code> concept, this</del><ins>This</ins> function caches the result 
within the <code class='backtick'>slide_view</code> for use on subsequent calls when <code class='backtick'>V</code> models
<code><i>slide-caches-first</i></code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 25.7.31.2 <a href="https://timsong-cpp.github.io/cppwp/range.chunk.by.view">[range.chunk.by.view]</a> as indicated:</p>

<blockquote>
<pre>
constexpr <i>iterator</i> begin();
</pre>
<blockquote>
<p>
-3- <i>Preconditions</i>: [&hellip;]
<p/>
-4- <i>Returns</i>: [&hellip;]
<p/>
-5- <i>Remarks</i>: <del>In order to provide the amortized constant-time complexity 
required by the <code class='backtick'>range</code> concept, this</del><ins>This</ins> function caches the result 
within the <code class='backtick'>chunk_by_view</code> for use on subsequent calls.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4272"><a href="4272">4272</a>. For <code class='backtick'>rank == 0</code>, <code class='backtick'>layout_stride</code> is atypically convertible</h3>
<p><b>Section:</b> 23.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout">[mdspan.layout]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Luc Grosheintz <b>Opened:</b> 2025-06-02 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#mdspan.layout">active issues</a> in [mdspan.layout].</p>
<p><b>View all other</b> <a href="lwg-index.html#mdspan.layout">issues</a> in [mdspan.layout].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Commonly, two layouts are considered convertible, if the underlying
<code class='backtick'>extent_types</code> are convertible.
<p/>
However, for the two ctors <code class='backtick'>layout_left::mapping(layout_stride::mapping)</code> and
<code class='backtick'>layout_right::mapping(layout_stride::mapping)</code>, the condition is <code>rank &gt; 0</code>. 
Therefore,
</p>
<blockquote><pre>
using E1 = std::extents&lt;int&gt;;
using E2 = std::extents&lt;unsigned int&gt;;

static_assert(std::is_convertible_v&lt;
    std::layout_stride::mapping&lt;E2&gt;,
    std::layout_right::mapping&lt;E1&gt;
  &gt;);
</pre></blockquote>
<p>
even though:
</p>
<blockquote><pre>
static_assert(!std::is_convertible_v&lt;E2, E1&gt;);
</pre></blockquote>
<p>
Moreover, for rank 0 <code class='backtick'>layout_stride</code> can be converted to any
specialization of <code class='backtick'>layout_left</code> or <code class='backtick'>layout_right</code>; but not to every
specialization of <code class='backtick'>layout_stride</code>.
</p>

<p><i>[2025-06-12; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: As drive-by fixes the edits for <code>layout_left_padded&lt;&gt;::mapping</code> and
<code>layout_right_padded&lt;&gt;::mapping</code> also correct an editorial asymmetry between class
header synopsis declaration form and prototype specification form of the corresponding
constructors and adjust to the correct formatting of the exposition-only data member <code><i>rank_</i></code>.]
</p>
</blockquote>

<ol>
<li><p>Modify 23.7.3.4.5.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.overview">[mdspan.layout.left.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Extents&gt;
  class layout_left::mapping {
    [&hellip;]
    <i>// 23.7.3.4.5.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.cons">[mdspan.layout.left.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    
    constexpr mapping&amp; operator=(const mapping&amp;) noexcept = default;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.5.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.cons">[mdspan.layout.left.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
-14- <i>Preconditions</i>: [&hellip;]
<p/>
-15- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(extents_type::rank() == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.overview">[mdspan.layout.right.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Extents&gt;
  class layout_right::mapping {
    [&hellip;]
    <i>// 23.7.3.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.cons">[mdspan.layout.right.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    
    constexpr mapping&amp; operator=(const mapping&amp;) noexcept = default;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.cons">[mdspan.layout.right.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
-14- <i>Preconditions</i>: [&hellip;]
<p/>
-15- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(extents_type::rank() == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.8.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t PaddingValue&gt;
  template&lt;class Extents&gt;
  class layout_left_padded&lt;PaddingValue&gt;::mapping {
    [&hellip;]
    <i>// 23.7.3.4.8.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.cons">[mdspan.layout.leftpad.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.8.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.cons">[mdspan.layout.leftpad.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-10- <i>Constraints</i>: [&hellip;]
<p/>
-11- <i>Preconditions</i>: [&hellip;]
<p/>
-12- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(<i>rank_</i> == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.9.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t PaddingValue&gt;
  template&lt;class Extents&gt;
  class layout_right_padded&lt;PaddingValue&gt;::mapping {
    [&hellip;]
    <i>// 23.7.3.4.9.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.cons">[mdspan.layout.rightpad.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.9.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.cons">[mdspan.layout.rightpad.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-10- <i>Constraints</i>: [&hellip;]
<p/>
-11- <i>Preconditions</i>: [&hellip;]
<p/>
-12- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(<i>rank_</i> == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-06-20, Luc Grosheintz provides further wording improvements]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: As drive-by fixes the edits for <code>layout_left_padded&lt;&gt;::mapping</code> and
<code>layout_right_padded&lt;&gt;::mapping</code> also correct an editorial asymmetry between class
header synopsis declaration form and prototype specification form of the corresponding
constructors and adjust to the correct formatting of the exposition-only data member <code><i>rank_</i></code>.]
</p>
</blockquote>

<ol>
<li><p>Modify 23.7.3.4.5.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.overview">[mdspan.layout.left.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Extents&gt;
  class layout_left::mapping {
    [&hellip;]
    <i>// 23.7.3.4.5.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.cons">[mdspan.layout.left.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    
    constexpr mapping&amp; operator=(const mapping&amp;) noexcept = default;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.5.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.cons">[mdspan.layout.left.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
-14- <i>Preconditions</i>: [&hellip;]
<p/>
-15- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(extents_type::rank() == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.overview">[mdspan.layout.right.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Extents&gt;
  class layout_right::mapping {
    [&hellip;]
    <i>// 23.7.3.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.cons">[mdspan.layout.right.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    
    constexpr mapping&amp; operator=(const mapping&amp;) noexcept = default;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.cons">[mdspan.layout.right.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
-14- <i>Preconditions</i>: [&hellip;]
<p/>
-15- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(extents_type::rank() == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.8.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t PaddingValue&gt;
  template&lt;class Extents&gt;
  class layout_left_padded&lt;PaddingValue&gt;::mapping {
    [&hellip;]
    <i>// 23.7.3.4.8.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.cons">[mdspan.layout.leftpad.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.8.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.cons">[mdspan.layout.leftpad.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-10- <i>Constraints</i>: [&hellip;]
<p/>
-11- <i>Preconditions</i>: [&hellip;]
<p/>
-12- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(<i>rank_</i> == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class LayoutLeftPaddedMapping&gt;
  constexpr explicit(<i>see below</i>)
    mapping(const LayoutLeftPaddedMapping&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-16- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:
</p>
<blockquote><pre>
<ins>!is_convertible_v&lt;typename LayoutLeftPaddedMapping::extents_type, extents_type&gt; &amp;&amp;</ins>
rank_&gt; 1 &amp;&amp;
(padding_value != dynamic_extent ||
 LayoutLeftPaddedMapping::padding_value == dynamic_extent)
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.9.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t PaddingValue&gt;
  template&lt;class Extents&gt;
  class layout_right_padded&lt;PaddingValue&gt;::mapping {
    [&hellip;]
    <i>// 23.7.3.4.9.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.cons">[mdspan.layout.rightpad.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.9.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.cons">[mdspan.layout.rightpad.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-10- <i>Constraints</i>: [&hellip;]
<p/>
-11- <i>Preconditions</i>: [&hellip;]
<p/>
-12- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(<i>rank_</i> == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class LayoutRightPaddedMapping&gt;
  constexpr explicit(<i>see below</i>)
    mapping(const LayoutRightPaddedMapping&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-17- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:
</p>
<blockquote><pre>
<ins>!is_convertible_v&lt;typename LayoutRightPaddedMapping::extents_type, extents_type&gt; &amp;&amp;</ins>
<i>rank_</i> &gt; 1 &amp;&amp;
(padding_value != dynamic_extent ||
LayoutRightPaddedMapping::padding_value == dynamic_extent)
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-09-27, Tomasz Kamiski fixes constraints in constructors from padded layouts]</i></p>



<p id="res-4272"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: As drive-by fixes the edits for <code>layout_left_padded&lt;&gt;::mapping</code> and
<code>layout_right_padded&lt;&gt;::mapping</code> also correct an editorial asymmetry between class
header synopsis declaration form and prototype specification form of the corresponding
constructors and adjust to the correct formatting of the exposition-only data member <code><i>rank_</i></code>.]
</p>
</blockquote>

<ol>
<li><p>Modify 23.7.3.4.5.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.overview">[mdspan.layout.left.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Extents&gt;
  class layout_left::mapping {
    [&hellip;]
    <i>// 23.7.3.4.5.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.cons">[mdspan.layout.left.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    
    constexpr mapping&amp; operator=(const mapping&amp;) noexcept = default;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.5.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.cons">[mdspan.layout.left.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
-14- <i>Preconditions</i>: [&hellip;]
<p/>
-15- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(extents_type::rank() == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.overview">[mdspan.layout.right.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class Extents&gt;
  class layout_right::mapping {
    [&hellip;]
    <i>// 23.7.3.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.cons">[mdspan.layout.right.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    
    constexpr mapping&amp; operator=(const mapping&amp;) noexcept = default;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.6.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.cons">[mdspan.layout.right.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
-14- <i>Preconditions</i>: [&hellip;]
<p/>
-15- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(extents_type::rank() == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.8.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t PaddingValue&gt;
  template&lt;class Extents&gt;
  class layout_left_padded&lt;PaddingValue&gt;::mapping {
    [&hellip;]
    <i>// 23.7.3.4.8.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.cons">[mdspan.layout.leftpad.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>extents_type::rank() &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.8.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.cons">[mdspan.layout.leftpad.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-10- <i>Constraints</i>: [&hellip;]
<p/>
-11- <i>Preconditions</i>: [&hellip;]
<p/>
-12- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(<i>rank_</i> == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class LayoutLeftPaddedMapping&gt;
  constexpr explicit(<i>see below</i>)
    mapping(const LayoutLeftPaddedMapping&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-16- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:
</p>
<blockquote><pre>
<ins>!is_convertible_v&lt;typename LayoutLeftPaddedMapping::extents_type, extents_type&gt; ||</ins>
rank_&gt; 1 &amp;&amp;
(padding_value != dynamic_extent ||
 LayoutLeftPaddedMapping::padding_value == dynamic_extent)
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.9.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;size_t PaddingValue&gt;
  template&lt;class Extents&gt;
  class layout_right_padded&lt;PaddingValue&gt;::mapping {
    [&hellip;]
    <i>// 23.7.3.4.9.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.cons">[mdspan.layout.rightpad.cons]</a>, constructors</i>
    [&hellip;]
    template&lt;class OtherExtents&gt;
      constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
        mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp;);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.4.9.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.cons">[mdspan.layout.rightpad.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherExtents&gt;
  constexpr explicit(<del>rank_ &gt; 0</del><ins><i>see below</i></ins>)
    mapping(const layout_stride::mapping&lt;OtherExtents&gt;&amp; other);
</pre>
<blockquote>
<p>
-10- <i>Constraints</i>: [&hellip;]
<p/>
-11- <i>Preconditions</i>: [&hellip;]
<p/>
-12- <i>Effects</i>: [&hellip;]
<p/>
<ins>-?- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!(<i>rank_</i> == 0 &amp;&amp; is_convertible_v&lt;OtherExtents, extents_type&gt;)</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class LayoutRightPaddedMapping&gt;
  constexpr explicit(<i>see below</i>)
    mapping(const LayoutRightPaddedMapping&amp; other);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
<p/>
-17- <i>Remarks</i>: The expression inside <code class='backtick'>explicit</code> is equivalent to:
</p>
<blockquote><pre>
<ins>!is_convertible_v&lt;typename LayoutRightPaddedMapping::extents_type, extents_type&gt; ||</ins>
<i>rank_</i> &gt; 1 &amp;&amp;
(padding_value != dynamic_extent ||
LayoutRightPaddedMapping::padding_value == dynamic_extent)
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4273"><a href="4273">4273</a>. Standard execution policy types should be conventional tag class types</h3>
<p><b>Section:</b> 26.3.6 <a href="https://timsong-cpp.github.io/cppwp/execpol">[execpol]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-06-03 <b>Last modified:</b> 2025-06-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Existing standard execution policy types don't hold any state, and mostly act as disambiguating tags 
in parallel algorithms. Perhaps it will be better to ensure them to be similar to construction tag types, 
which possibly enables more desired usages.
<p/>
Currently, libc++ makes these types non-movable, which is arguable undesired per the decision made in 
<a href="https://wg21.link/P3136R1" title=" Retiring niebloids">P3136R1</a>.
</p>


<p id="res-4273"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 26.3.6.3 <a href="https://timsong-cpp.github.io/cppwp/execpol.seq">[execpol.seq]</a> as indicated:</p>

<blockquote>
<pre>
class execution::sequenced_policy { <del><i>unspecified</i></del>
<ins>public:
  explicit sequenced_policy() = default;</ins> 
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/execpol.par">[execpol.par]</a> as indicated:</p>

<blockquote>
<pre>
class execution::parallel_policy { <del><i>unspecified</i></del>
<ins>public:
  explicit parallel_policy() = default;</ins> 
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.3.6.5 <a href="https://timsong-cpp.github.io/cppwp/execpol.parunseq">[execpol.parunseq]</a> as indicated:</p>

<blockquote>
<pre>
class execution::parallel_unsequenced_policy { <del><i>unspecified</i></del>
<ins>public:
  explicit parallel_unsequenced_policy() = default;</ins> 
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.3.6.6 <a href="https://timsong-cpp.github.io/cppwp/execpol.unseq">[execpol.unseq]</a> as indicated:</p>

<blockquote>
<pre>
class execution::unsequenced_policy { <del><i>unspecified</i></del>
<ins>public:
  explicit unsequenced_policy() = default;</ins> 
};
</pre>
</blockquote>
</li>

<li><p>Modify 26.3.6.7 <a href="https://timsong-cpp.github.io/cppwp/execpol.objects">[execpol.objects]</a> as indicated:</p>

<blockquote>
<pre>
inline constexpr execution::sequenced_policy execution::seq{ <del><i>unspecified</i></del> };
inline constexpr execution::parallel_policy execution::par{ <del><i>unspecified</i></del> };
inline constexpr execution::parallel_unsequenced_policy execution::par_unseq{ <del><i>unspecified</i></del> };
inline constexpr execution::unsequenced_policy execution::unseq{ <del><i>unspecified</i></del> };
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4275"><a href="4275">4275</a>. <code class='backtick'>std::dynamic_extent</code> should also be defined in <code>&lt;mdspan&gt;</code></h3>
<p><b>Section:</b> 23.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.syn">[mdspan.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Aiden Grossman <b>Opened:</b> 2025-06-06 <b>Last modified:</b> 2025-06-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#mdspan.syn">issues</a> in [mdspan.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>std::dynamic_extent</code> can be used in certain circumstances in <code class='backtick'>std::mdspan</code>, 
such as with padded layouts. However, <code class='backtick'>std::dynamic_extent</code> is currently only 
defined in <code>&lt;span&gt;</code> which necessitates including <code>&lt;span&gt;</code> 
solely for the <code class='backtick'>std::dynamic_extent</code> definition.
</p>
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 23.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.syn">[mdspan.syn]</a>, header <code>&lt;span&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
<i>// all freestanding</i>
namespace std {
  <ins><i>// constants</i></ins>
  <ins>inline constexpr size_t dynamic_extent = numeric_limits&lt;size_t&gt;::max();</ins>
  
  <i>// 23.7.3.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.extents">[mdspan.extents]</a>, class template extents</i>
  template&lt;class IndexType, size_t... Extents&gt;
  class extents;

  [&hellip;]
}
</pre>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-06-10; Jonathan provides improved wording]</i></p>




<p id="res-4275"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 23.7.1 <a href="https://timsong-cpp.github.io/cppwp/views.general">[views.general]</a> as indicated:</p>

<blockquote>
<p>
The header <code>&lt;span&gt;</code> (23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a>)
defines the view <code class='backtick'>span</code>.
The header <code>&lt;mdspan&gt;</code> (23.7.3.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.syn">[mdspan.syn]</a>)
defines the class template <code class='backtick'>mdspan</code> and other facilities for interacting
with these multidimensional views.
</p>
<p>
<ins>
-?-
In addition to being available via inclusion of the <code>&lt;span&gt;</code>
header,
<code class='backtick'>dynamic_extent</code> is available when the header <code>&lt;mdspan&gt;</code>
is included.
</ins>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4277"><a href="4277">4277</a>. &sect;[algorithms.requirements] It is unclear what an algorithm is</h3>
<p><b>Section:</b> 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2025-06-08 <b>Last modified:</b> 2025-06-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms.requirements">active issues</a> in [algorithms.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms.requirements">issues</a> in [algorithms.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> paragraph 15 states:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
The well-formedness and behavior of a call to an algorithm with an explicitly-specified 
template argument list is unspecified, except where explicitly stated otherwise.
</p>
</blockquote>
<p>
It is unclear what this applies to because "algorithm" is never defined. 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> 
paragraph 1 uses the term while mentioning iterators and containers, but  [algorithm] specifies 
function templates such as <code class='backtick'>std::gcd</code> which do not accept iterators.
<p/>
The <i>Remarks</i> specifications in 26.8.9 <a href="https://timsong-cpp.github.io/cppwp/alg.min.max">[alg.min.max]</a> providing exemptions from 
26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> paragraph 15 suggest that even function templates not 
accepting iterators are considered algorithms.
</p>


<p id="res-4277"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a> as indicated:</p>

<blockquote>
<p>
-15- The well-formedness and behavior of a call to <del>an algorithm</del><ins>a function template specified in Clause 
26 <a href="https://timsong-cpp.github.io/cppwp/algorithms">[algorithms]</a> (including call operators of algorithm function objects denoted as algorithms throughout Clause 
26.2 <a href="https://timsong-cpp.github.io/cppwp/algorithms.requirements">[algorithms.requirements]</a>)</ins> with an explicitly-specified template argument list is unspecified, 
except where explicitly stated otherwise.
<p/>
[<i>Note 3</i>: Consequently, an implementation can declare an algorithm with different template parameters than those
presented. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4278"><a href="4278">4278</a>. Consider changing how <code><i>get-domain-early</i>(sndr)</code> works</h3>
<p><b>Section:</b> 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-06-16 <b>Last modified:</b> 2025-06-21</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.snd.expos">active issues</a> in [exec.snd.expos].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.snd.expos">issues</a> in [exec.snd.expos].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During LWG review of <a href="https://wg21.link/P3481R3" title=" std::execution::bulk() issues">P3481R3</a> it was noted that we need to say "except that <code class='backtick'>sndr</code> 
is only evaluated once" because it's used in <code><i>get-domain-early</i>(sndr)</code>, but that 
exposition-only-function doesn't actually use its argument, it only cares about the type, and 
it default constructs a <code class='backtick'>Domain</code> of a type determined by using the type of <code class='backtick'>sndr</code>.
<p/>
If we had something like:
</p>
<blockquote><pre>
template&lt;class Sender&gt;
using <i>get-domain-early-t</i> = decltype(<i>get-domain-early</i>(declval&lt;const Sender&amp;&gt;()));
</pre></blockquote>
<p>
then we wouldn't need to use <code class='backtick'>sndr</code> twice in expressions that currently use <code><i>get-domain-early</i>(sndr)</code>.
</p>


<p id="res-4278"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4279"><a href="4279">4279</a>. &sect;[fs.op.absolute] Non-normative encouragement should be <i>Recommended practice</i></h3>
<p><b>Section:</b> 31.12.13.2 <a href="https://timsong-cpp.github.io/cppwp/fs.op.absolute">[fs.op.absolute]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-06-16 <b>Last modified:</b> 2025-06-21</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[fs.op.absolute] has a note giving strong encouragement, which should be normative:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
[Note <i>3</i>: Implementations are strongly encouraged to not query secondary storage, and not consider 
<code class='backtick'>!exists(p)</code> an error. &mdash; <i>end note</i>]
</p>
</blockquote>
<p>
The part about <code class='backtick'>!exists(p)</code> not being an error could definitely be a <i>Recommended practice</i> paragraph.  
Referring to "secondary storage" might need to be phrased differently to be normative (maybe with a note 
clarifying that the normative wording is referring to "secondary storage").
</p>


<p id="res-4279"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4281"><a href="4281">4281</a>. Inconsistency between <code class='backtick'>value_or()</code> and <code class='backtick'>error_or()</code> in <code class='backtick'>std::expected</code></h3>
<p><b>Section:</b> 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a>, 22.8.6.6 <a href="https://timsong-cpp.github.io/cppwp/expected.object.obs">[expected.object.obs]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hiroaki Ando <b>Opened:</b> 2025-06-27 <b>Last modified:</b> 2025-07-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.observe">active issues</a> in [optional.observe].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.observe">issues</a> in [optional.observe].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.8.6.6 <a href="https://timsong-cpp.github.io/cppwp/expected.object.obs">[expected.object.obs]</a>/19, the return value of <code class='backtick'>value_or()</code>
is specified as follows:
<blockquote>
<i>Returns</i>:
<code>has_value() ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v))</code>.
</blockquote>

Meanwhile, the return value of <code class='backtick'>error_or()</code> is specified as follows (22.8.6.6 <a href="https://timsong-cpp.github.io/cppwp/expected.object.obs">[expected.object.obs]</a>/23):
<blockquote>
<i>Returns</i>:
<code>std::forward&lt;G&gt;(e)</code> if <code>has_value()</code> is <code>true</code>, <code>error()</code> otherwise.
</blockquote>
Since these functions appear to be dual in nature,
it would be preferable to maintain consistent notation.
</p>
<p>
Jonathan adds:
The wording in <code class='backtick'>expected::error_or</code> is newer, having been added by
<a href="https://wg21.link/P2505R5" title=" Monadic Functions for std::expected">P2505R5</a>, and intentionally avoided a conditional expression
(the problems with conditional expressions explained in <a href="https://wg21.link/P3177R0" title=" const prvalues in the conditional operator">P3177R0</a>
don't actually affect these member functions, due to the non-const prvalue
return type, but determining that there are no pessimized copies in <code class='backtick'>value_or</code>
wouldn't be necessary if we didn't specify it with a conditional expression).
The <code class='backtick'>error_or</code> wording also avoids using an explicit conversion when the
<i>Mandates</i>: element requires implicit conversion to work anyway.
We might want to rephrase the <code class='backtick'>value_or</code> wording to match <code class='backtick'>error_or</code>,
or possibly make <code class='backtick'>value_or</code> and <code class='backtick'>error_or</code> even more explicit,
specifying them in terms of <code class='backtick'>if</code>-<code class='backtick'>else</code>:
:
</p>
<blockquote>
<i>Effects</i>: Equivalent to: <pre><code>
if (has_value())
  return **this;
else
  return std::forward&lt;U&gt;(v);
</code></pre>
</blockquote>


<p id="res-4281"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4282"><a href="4282">4282</a>. Imprecise <i>Throws</i>: clause in <code class='backtick'>std::relocate</code></h3>
<p><b>Section:</b> 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Giuseppe D'Angelo <b>Opened:</b> 2025-06-23 <b>Last modified:</b> 2025-06-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#obj.lifetime">active issues</a> in [obj.lifetime].</p>
<p><b>View all other</b> <a href="lwg-index.html#obj.lifetime">issues</a> in [obj.lifetime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <code class='backtick'>std::relocate</code> in 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> says
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Throws</i>: Nothing.
</p>
</blockquote>
<p>
This is imprecise. A trivially relocatable type may feature a throwing
move constructor (or a throwing destructor); for instance, a linked-list
implementation with an externally allocated sentinel node may have a
throwing move constructor, but still be trivially relocatable. Such a
type is nothrow relocatable (as per <code class='backtick'>is_nothrow_relocatable_v</code>, cf.
21.3.6.4 <a href="https://timsong-cpp.github.io/cppwp/meta.unary.prop">[meta.unary.prop]</a>) and therefore one can call <code class='backtick'>std::relocate</code> 
on objects of that type.
<p/>
During constant evaluation, a call to <code class='backtick'>std::relocate</code> is specified to
relocate objects via move construction and destruction.
(<code class='backtick'>std::trivially_relocate</code> is unavailable during constant evaluation.)
<p/>
Since <a href="https://wg21.link/P3068" title=" Allowing exception throwing in constant-evaluation">P3068</a> we are allowed to throw during constant evaluation, 
and therefore it's unclear whether <code class='backtick'>std::relocate</code> should propagate such an
exception to the caller or should instead make the evaluation not a
constant expression (and therefore make the program ill-formed, since by
construction we end up in this possibility during constant evaluation).
<p/>
Given the rationale brought forward for <code class='backtick'>std::relocate</code> in <a href="https://wg21.link/P2786" title=" Trivial Relocatability For C++26">P2786</a> 
is to be always a nofail operation, I'm proposing a resolution that goes in
that direction.
</p>


<p id="res-4282"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
  constexpr T* relocate(T* first, T* last, T* result);
</pre>
<blockquote>
<p>
-16- <i>Mandates</i>: [&hellip;]
<p/>
-17- <i>Preconditions</i>: [&hellip;]
<p/>
-18- <i>Effects</i>: [&hellip;]
<p/>
-19- <i>Returns</i>: <code class='backtick'>result + (last - first)</code>.
<p/>
-20- <i>Throws</i>: Nothing.
<p/>
<ins>-?- <i>Remarks</i>: If <code class='backtick'>relocate</code> is called during constant evaluation, and an
exception is thrown by a constructor or destructor of <code class='backtick'>T</code>, the call to <code class='backtick'>relocate</code> 
is not a core constant expression (7.7 <a href="https://timsong-cpp.github.io/cppwp/expr.const">[expr.const]</a>).</ins>
<p/>
[<i>Note 3</i>: Overlapping ranges are supported. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4283"><a href="4283">4283</a>. <code class='backtick'>std::trivially_relocate</code> needs stronger preconditions on "nested" objects with dynamic lifetime</h3>
<p><b>Section:</b> 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Giuseppe D'Angelo <b>Opened:</b> 2025-06-23 <b>Last modified:</b> 2025-07-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#obj.lifetime">active issues</a> in [obj.lifetime].</p>
<p><b>View all other</b> <a href="lwg-index.html#obj.lifetime">issues</a> in [obj.lifetime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> the <code class='backtick'>std::trivially_relocate</code> function 
is missing a precondition, that is, that any object alive in the range being
relocated is itself trivially relocatable.
<p/>
We know the objects in the range are trivially relocatable, because
there is a <i>Mandates</i>: element for this. The current draft has precise
rules to determine whether a type is trivially relocatable or not; in
general, subobjects are considered there (cf. 11.2 <a href="https://timsong-cpp.github.io/cppwp/class.prop">[class.prop]</a>, 
"eligible for trivial relocation", which discusses base classes and non-static
data members).
<p/>
However these rules do not take into account objects with dynamic
lifetime whose storage is being provided by (sub)objects in the range.
<p/>
For instance, given a <code class='backtick'>wrapper</code> type like:
</p>
<blockquote><pre>
// wraps a T
template&lt;typename T&gt;
struct wrapper {
  alignas(T) std::byte data[sizeof(T)];
};
</pre></blockquote>
<p>
then one can build a non-trivially relocatable object into <code class='backtick'>wrapper</code>
objects:
</p>
<blockquote><pre>
struct NTR { ~NTR() {} };
static_assert(not std::is_trivially_relocatable_v&lt;NTR&gt;);

using WS = wrapper&lt;NTR&gt;;
static_assert(std::is_trivially_relocatable_v&lt;WS&gt;); // OK
</pre></blockquote>
<p>
And now one can do this:
</p>
<blockquote><pre>
WS* ws = /* &hellip; */;     // create a wrapper
new (&amp;ws-&gt;data) NTR();  // create a NTR object into it

std::trivially_relocate(ws, ws+1, dest); // should be UB
</pre></blockquote>
<p>
Attempting to trivially relocate <code class='backtick'>*ws</code> should result in undefined
behavior because <code class='backtick'>NTR</code> isn't trivially relocatable. I don't believe that
this fact is correctly captured by the preconditions of
<code class='backtick'>std::trivially_relocate</code>.
<p/>
A similar issue is present for polymorphic types. In <a href="https://wg21.link/P2786" title=" Trivial Relocatability For C++26">P2786</a>'s 
design polymorphic types can be trivially relocatable (assuming all the other
conditions hold). Given a trivially relocatable polymorphic type <code class='backtick'>P</code>,
then this code:
</p>
<blockquote><pre>
struct P { virtual void f(); };
static_assert(std::is_trivially_relocatable_v&lt;P&gt;);

using WP = wrapper&lt;P&gt;;
WP* wp = /* &hellip; */;   // create a wrapper
new (&amp;wp-&gt;data) P();  // create a P object into it

std::trivially_relocate(wp, wp+1, dest); // implementation defined
</pre></blockquote>
<p>
is well-defined or UB, depending on the implementation. This is because
on some implementations trivially relocating a polymorphic type requires
patching its virtual table pointer; cf. the discussion in chapter 15.1
of <a href="https://wg21.link/P2786R13" title=" Trivial Relocatability For C++26">P2786R13</a>. However the "type erasure" done by 
<code>wrapper&lt;P&gt;</code> in the example (ultimately, it is just an array 
of bytes) does not allow implementations to do such patching, and the code 
is going to fail at runtime. Therefore this case also needs to be discussed by
<code class='backtick'>std::trivially_relocate</code>'s specification.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: For the general part of the issue (all objects in the range must be of
trivially relocatable type), we append another point at the end of the existing 
<i>Preconditions:</i> element of <code class='backtick'>trivially_relocate</code>.<br/>
For the specifics of polymorphic types, we amend at the end of the description the existing 
<i>Remarks</i>: element]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class T&gt;
  T* trivially_relocate(T* first, T* last, T* result);
</pre>
<blockquote>
<p>
-9- <i>Mandates</i>: [&hellip;]
<p/>
-10- <i>Preconditions</i>: 
</p>
<ol style="list-style-type: none">
<li><p>(10.1) &mdash; <code class='backtick'>[first, last)</code> is a valid range.</p></li>
<li><p>(10.2) &mdash; <code class='backtick'>[result, result + (last - first))</code> denotes a region of storage that is a subset of the region
reachable through <code class='backtick'>result</code> (6.9.4 <a href="https://timsong-cpp.github.io/cppwp/basic.compound">[basic.compound]</a>) and suitably aligned for the type <code class='backtick'>T</code>.</p></li>
<li><p>(10.3) &mdash; No element in the range <code class='backtick'>[first, last)</code> is a potentially-overlapping subobject.</p></li>
<li><p><ins>(10.?) &mdash; All objects whose storage is being provided for (6.8.2 <a href="https://timsong-cpp.github.io/cppwp/intro.object">[intro.object]</a>) by
objects in the <code class='backtick'>[first, last)</code> range are of trivially relocatable type.</ins></p></li>
</ol>
<p>
-11- <i>Postconditions</i>: [&hellip;]
<p/>
-12- <i>Returns</i>: <code class='backtick'>result + (last - first)</code>.
<p/>
-13- <i>Throws</i>: Nothing.
<p/>
-14- <i>Complexity</i>: Linear in the length of the source range.
<p/>
-15- <i>Remarks</i>: The destination region of storage is considered reused (6.8.4 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>). 
No constructors or destructors are invoked. <ins>If any polymorphic object (11.7.3 <a href="https://timsong-cpp.github.io/cppwp/class.virtual">[class.virtual]</a>) 
exists in storage provided for (6.8.2 <a href="https://timsong-cpp.github.io/cppwp/intro.object">[intro.object]</a>) by objects in the <code class='backtick'>[first, last)</code> range,
it is implementation-defined whether the behavior is undefined.</ins>
<p/>
[<i>Note 2</i>: Overlapping ranges are supported. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-07-01; Pablo and Giuseppe improve wording]</i></p>



<p id="res-4283"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 20.2.6 <a href="https://timsong-cpp.github.io/cppwp/obj.lifetime">[obj.lifetime]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: For the general part of the issue (all objects in the range must be of
trivially relocatable type), we append another point at the end of the existing 
<i>Preconditions:</i> element of <code class='backtick'>trivially_relocate</code>.<br/>
For the specifics of polymorphic types, we amend at the end of the description the existing 
<i>Remarks</i>: element]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class T&gt;
  T* trivially_relocate(T* first, T* last, T* result);
</pre>
<blockquote>
<p>
-9- <i>Mandates</i>: [&hellip;]
<p/>
-10- <i>Preconditions</i>: 
</p>
<ol style="list-style-type: none">
<li><p>(10.1) &mdash; <code class='backtick'>[first, last)</code> is a valid range.</p></li>
<li><p>(10.2) &mdash; <code class='backtick'>[result, result + (last - first))</code> denotes a region of storage that is a subset of the region
reachable through <code class='backtick'>result</code> (6.9.4 <a href="https://timsong-cpp.github.io/cppwp/basic.compound">[basic.compound]</a>) and suitably aligned for the type <code class='backtick'>T</code>.</p></li>
<li><p>(10.3) &mdash; No element in the range <code class='backtick'>[first, last)</code> is a potentially-overlapping subobject.</p></li>
<li><p><ins>(10.?) &mdash; All objects whose storage is being provided for (6.8.2 <a href="https://timsong-cpp.github.io/cppwp/intro.object">[intro.object]</a>) by
objects in the <code class='backtick'>[first, last)</code> range are of a type such that a union containing a non-static member of that type 
would be eligible for trivial relocation.</ins></p></li>
</ol>
<p>
-11- <i>Postconditions</i>: [&hellip;]
<p/>
-12- <i>Returns</i>: <code class='backtick'>result + (last - first)</code>.
<p/>
-13- <i>Throws</i>: Nothing.
<p/>
-14- <i>Complexity</i>: Linear in the length of the source range.
<p/>
-15- <i>Remarks</i>: The destination region of storage is considered reused (6.8.4 <a href="https://timsong-cpp.github.io/cppwp/basic.life">[basic.life]</a>). 
No constructors or destructors are invoked.
<p/>
[<i>Note 2</i>: Overlapping ranges are supported. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4284"><a href="4284">4284</a>. Integer-class types should be formattable</h3>
<p><b>Section:</b> 28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-06-27 <b>Last modified:</b> 2025-09-21</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#format.formatter.spec">active issues</a> in [format.formatter.spec].</p>
<p><b>View all other</b> <a href="lwg-index.html#format.formatter.spec">issues</a> in [format.formatter.spec].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following program doesn't compile with MSVC STL (<a href="https://godbolt.org/z/aazK6bhqM">Godbolt link</a>).
</p>
<blockquote><pre>
#include &lt;format&gt;
#include &lt;ranges&gt;

int main() {
  auto iv1 = std::views::iota(42ull, 1729ull);
  auto iv2 = std::views::iota(iv1.begin(), iv1.end());
  std::format("{}", iv2.size()); // <span style="color:red;font-weight:bolder">Error</span>
}
</pre></blockquote>
<p>
In MSVC STL, the type of <code class='backtick'>iv2.size()</code> is an integer-class type, and the standard hasn't guaranteed there're 
enabled formatter specializations for integer-class types. As a result, this program is not guaranteed to 
be well-formed.
<p/>
Perhaps we should require enabled <code class='backtick'>std::formatter</code> specializations for integer-class types to get rid of 
such uncertainty and inconsistency.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> as indicated:</p>

<blockquote>
<p>
-2- [&hellip;] Each header that declares the template
<code class='backtick'>formatter</code> provides the following enabled specializations:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>(2.2) &mdash; [&hellip;]</p></li>
<li><p>(2.3) &mdash; [&hellip;]</p></li>
<li><p><ins>(2.?) &mdash; For each <code class='backtick'>charT</code>, for each cv-unqualified integer-class type 
(24.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>) <code class='backtick'>IntegerClass</code>, a specialization</ins>
</p>
<blockquote><pre>
<ins>template&lt;&gt; struct formatter&lt;IntegerClass, charT&gt;;</ins>
</pre></blockquote>
</li>
<li><p>(2.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-09-18; Jiang An improves wording]</i></p>



<p id="res-4284"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>
<li><p>Modify 28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> as indicated:</p>

<blockquote>
<p>
-2- [&hellip;] Each header that declares the template
<code class='backtick'>formatter</code> provides the following enabled specializations:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>(2.2) &mdash; [&hellip;]</p></li>
<li><p>(2.3) &mdash; [&hellip;]</p></li>
<li><p><ins>(2.?) &mdash; For each <code class='backtick'>charT</code>, for each cv-unqualified integer-class type 
(24.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>) <code class='backtick'>IntegerClass</code>, a specialization</ins>
</p>
<blockquote><pre>
<ins>template&lt;&gt; struct formatter&lt;IntegerClass, charT&gt;;</ins>
</pre></blockquote>
</li>
<li><p>(2.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify 28.5.2.2 <a href="https://timsong-cpp.github.io/cppwp/format.string.std">[format.string.std]</a> as indicated:</p>

<blockquote>
<p>
-20- The meaning of some non-string presentation types is defined in terms of a call to 
<code class='backtick'>to_chars</code>. In such cases, let <code class='backtick'>[first, last)</code> be a range large enough to hold the 
<code class='backtick'>to_chars</code> output and <code class='backtick'>value</code> be the formatting argument value. <ins>If the formatting 
argument is of an integer-class type (24.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>), the 
formatting argument value is as-if converted to a hypothetical extended integer type 
of the same signedness and width as the integer-class type first.</ins> Formatting is done as if 
by calling <code class='backtick'>to_chars</code> as specified and copying the output through the output
iterator of the format context.
</p>

</blockquote>
</li>

<li><p>Modify  [tab:format.type.int] (Table 107) as indicated:</p>

<blockquote>
<p>
<b>Table 107 &mdash; Meaning of type options for integer <ins>and integer-class</ins> types [tab:format.type.int]</b>
</p>

</blockquote>
</li>
</ol>





<hr>
<h3 id="4285"><a href="4285">4285</a>. <code class='backtick'>time_get::do_get_date</code> is problematic even after LWG 461</h3>
<p><b>Section:</b> 28.3.4.6.2.2 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.members">[locale.time.get.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2025-06-27 <b>Last modified:</b> 2025-07-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Background: <a href="https://github.com/cplusplus/draft/pull/8009">https://github.com/cplusplus/draft/pull/8009</a>
<p/>
LWG <a href="461" title="time_get hard or impossible to implement (Status: CD1)">461</a> changed <code class='backtick'>time_get::do_get_date</code> to parse a set of fixed formats. For example, if 
<code class='backtick'>time_get::date_order()</code> is <code class='backtick'>no_order</code> or <code class='backtick'>mdy</code>, the format parsed by <code class='backtick'>do_get_date</code> is <code class='backtick'>%m/%d/%y</code>.
<p/>
This has several problems:
</p>
<ol>
<li><p>When the resolution of LWG <a href="461" title="time_get hard or impossible to implement (Status: CD1)">461</a> was applied to the draft standard, the slashes were lost. 
This could mislead people into implementing <code class='backtick'>do_get_date</code> using the incorrect formats. Fortunately, none 
of the standard library implementations are affected by this mistake.</p></li>
<li><p>Only 2-digit years are accepted due to the use of <code class='backtick'>%y</code>. This could lead to incorrect parse if 
<code class='backtick'>strftime</code> uses <code class='backtick'>%Y</code> for the locale's date format.</p></li>
<li><p><code class='backtick'>date_order()</code> might need additional locale facets to find out the date order, but it doesn't have an 
<code>ios_base&amp;</code> argument from which to get the locale.</p></li>
<li><p>Many locales do not use any of the specified formats. For example, <code class='backtick'>de_DE</code> uses <code class='backtick'>%d.%m.%Y</code>, <code class='backtick'>zh_CN</code> 
uses <code class='backtick'>%Y%m%d</code>. Although 28.3.4.6.2.3 <a href="https://timsong-cpp.github.io/cppwp/locale.time.get.virtuals">[locale.time.get.virtuals]</a>/5 gives an implementation the latitude 
to accept additional formats, ambiguity could arise if the locale's format disagrees with <code class='backtick'>date_order()</code>.</p></li>
</ol>
<p>
On POSIX systems, it is possible to query the locale's date format using <code class='backtick'>nl_langinfo(D_FMT)</code>. 
Maybe an implementation should be allowed to use that format <b>instead</b> of the one indicated by <code class='backtick'>date_order()</code>.
</p>


<p id="res-4285"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4286"><a href="4286">4286</a>. Some more feature-test macros for fully freestanding features are not marked freestanding</h3>
<p><b>Section:</b> 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a>, 20.2.2 <a href="https://timsong-cpp.github.io/cppwp/memory.syn">[memory.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Yihe Li <b>Opened:</b> 2025-06-17 <b>Last modified:</b> 2025-07-05</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#version.syn">active issues</a> in [version.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#version.syn">issues</a> in [version.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P1642R11" title=" Freestanding Library: Easy [utilities], [ranges], and [iterators]">P1642R11</a> (accepted in C++23) plus LWG <a href="4189" title="cache_latest_view should be freestanding (Status: WP)">4189</a> (accepted in Hagenberg) added nearly the entire 
<code>&lt;ranges&gt;</code> header to freestanding. 
However, the only feature-test macro being added to freestanding is <code class='backtick'>__cpp_lib_ranges_cache_latest</code>, which seems weird, 
since <code class='backtick'>views::enumerate</code> is also added to freestanding following the blanket comment strategy, but its feature-test 
macro remains not in freestanding. In retrospective, since all range algorithms are in freestanding via 
<a href="https://wg21.link/P2976" title=" Freestanding Library: algorithm, numeric, and random">P2976</a>, all <code class='backtick'>__cpp_lib_ranges_*</code> FTMs (except <code class='backtick'>__cpp_lib_ranges_generate_random</code> since 
<code class='backtick'>ranges::generate_random</code> is not in freestanding) should probably be marked as freestanding.
<p/>
Furthermore, LWG <a href="4126" title="Some feature-test macros for fully freestanding features are not yet marked freestanding (Status: WP)">4126</a> left out some other FTMs for fully freestanding features. They are also added 
in the following wording.
<p/>
A note about <code class='backtick'>is_sufficiently_aligned</code>: <a href="https://wg21.link/P2897R7" title=" aligned_accessor: An mdspan accessor expressing pointer overalignment">P2897R7</a> does indicate in 5.7.6.1 that the function should be 
freestanding, but somehow the wording didn't say so. The following wording includes the function and its FTM anyway 
since hopefully this is just an omission when wording the paper.
</p>


<p id="res-4286"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>
<li><p>Modify 17.3.2 <a href="https://timsong-cpp.github.io/cppwp/version.syn">[version.syn]</a>, header <code>&lt;version&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
#define __cpp_lib_aligned_accessor             202411L <i>// <ins>freestanding,</ins> also in &lt;mdspan&gt;</i>
[&hellip;]                                     
#define __cpp_lib_array_constexpr              201811L <i>// <ins>freestanding,</ins> also in &lt;iterator&gt;, &lt;array&gt;</i>
[&hellip;]                                     
#define __cpp_lib_clamp                        201603L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
[&hellip;]                                     
#define __cpp_lib_constexpr_numeric            201911L <i>// <ins>freestanding,</ins> also in &lt;numeric&gt;</i>
[&hellip;]                                     
#define __cpp_lib_function_ref                 202306L <i>// <ins>freestanding,</ins> also in &lt;functional&gt;</i>
#define __cpp_lib_gcd_lcm                      201606L <i>// <ins>freestanding,</ins> also in &lt;numeric&gt;</i>
[&hellip;]
#define __cpp_lib_integer_comparison_functions 202002L <i>// <ins>freestanding,</ins> also in &lt;utility&gt;</i>
[&hellip;]
#define __cpp_lib_is_sufficiently_aligned      202411L <i>// <ins>freestanding,</ins> also in &lt;memory&gt;</i>
[&hellip;]
#define __cpp_lib_ranges_contains              202207L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
#define __cpp_lib_ranges_enumerate             202302L <i>// <ins>freestanding,</ins> also in &lt;ranges&gt;</i>
#define __cpp_lib_ranges_find_last             202207L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
#define __cpp_lib_ranges_fold                  202207L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
[&hellip;]
#define __cpp_lib_ranges_iota                  202202L <i>// <ins>freestanding,</ins> also in &lt;numeric&gt;</i>
[&hellip;]
#define __cpp_lib_ranges_starts_ends_with      202106L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
[&hellip;]
#define __cpp_lib_robust_nonmodifying_seq_ops  201304L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
#define __cpp_lib_sample                       201603L <i>// <ins>freestanding,</ins> also in &lt;algorithm&gt;</i>
#define __cpp_lib_saturation_arithmetic        202311L <i>// <ins>freestanding,</ins> also in &lt;numeric&gt;</i>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 20.2.2 <a href="https://timsong-cpp.github.io/cppwp/memory.syn">[memory.syn]</a>, header <code>&lt;memory&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;size_t Alignment, class T&gt;
  bool is_sufficiently_aligned(T* ptr);      <ins><i>// freestanding</i></ins>
[&hellip;]
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4287"><a href="4287">4287</a>. &sect;[locale.codecvt.virtuals] <code class='backtick'>do_in</code> and <code class='backtick'>do_out</code> could do with better specification</h3>
<p><b>Section:</b> 28.3.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2025-06-18 <b>Last modified:</b> 2025-07-05</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#locale.codecvt.virtuals">active issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.codecvt.virtuals">issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Background: <a href="https://github.com/cplusplus/draft/pull/7347">https://github.com/cplusplus/draft/pull/7347</a>
<p/>
The specification of <code class='backtick'>codecvt::do_in</code> and <code class='backtick'>codecvt::do_out</code> is unclear, and possibly incorrect:
</p>
<ol>
<li><p>the meaning of <code class='backtick'>noconv</code> is specified twice (once in paragraph 3, once in Table 91 [tab:locale.codecvt.inout]);</p></li>
<li><p>the effect on <code class='backtick'>from_next</code> is not specified;</p></li>
<li><p>the specification talks about "the input sequence [from, from_next)", but <code class='backtick'>from_next</code> is supposed to be an out parameter. 
I think it should say "[from, from_end)" instead.</p></li>
</ol>


<p id="res-4287"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: This is modified from Jonathan Wakely's suggestion in 
<a href="https://github.com/cplusplus/draft/pull/7347#issuecomment-2549982495">https://github.com/cplusplus/draft/pull/7347#issuecomment</a>]
</p>
</blockquote>

<ol>
<li><p>In 28.3.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a> remove Table 91 [tab:locale.codecvt.inout] in its entirety:</p>

<blockquote>
<table border="1">
<caption><del>Table 91 &mdash; <code class='backtick'>do_in</code>/<code class='backtick'>do_out</code> result values [tab:locale.codecvt.inout]</del></caption>
<tr align="center">
<th><del>Value</del></th>
<th><del>Meaning</del></th>
</tr> 

<tr>
<td>
<del><code>ok</code></del>
</td>
<td>
<del>completed the conversion</del>
</td>
</tr>

<tr>
<td>
<del><code>partial</code></del>
</td>
<td>
<del>not all source characters converted</del>
</td>
</tr>

<tr>
<td>
<del><code>error</code></del>
</td>
<td>
<del>encountered a character in <code class='backtick'>[from, from_end)</code> that
cannot be converted</del>
</td>
</tr>

<tr>
<td>
<del><code>noconv</code></del>
</td>
<td>
<del><code class='backtick'>internT</code> and <code class='backtick'>externT</code> are the same type, and input
sequence is identical to converted sequence</del>
</td>
</tr>

</table>

</blockquote>

</li>

<li><p>Modify 28.3.4.2.5.3 <a href="https://timsong-cpp.github.io/cppwp/locale.codecvt.virtuals">[locale.codecvt.virtuals]</a> as indicated:</p>

<blockquote>
<pre>
result do_out(
  stateT&amp; state,
  const internT* from, const internT* from_end, const internT*&amp; from_next,
  externT* to, externT* to_end, externT*&amp; to_next) const;

result do_in(
  stateT&amp; state,
  const externT* from, const externT* from_end, const externT*&amp; from_next,
  internT* to, internT* to_end, internT*&amp; to_next) const;
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: [&hellip;]
<p/>
-2- <i>Effects</i>: Translates characters in the source range <code class='backtick'>[from, from_end)</code>, 
placing the results in sequential positions starting at destination to. Converts 
no more than <code class='backtick'>(from_end - from)</code> source elements, and stores no more than 
<code class='backtick'>(to_end - to)</code> destination elements.
<p/>
-3- <del>Stops if it encounters a character it cannot convert. It always leaves the 
<code class='backtick'>from_next</code> and <code class='backtick'>to_next</code> pointers pointing one beyond the last element successfully 
converted. If it returns <code class='backtick'>noconv</code>, <code class='backtick'>internT</code> and <code class='backtick'>externT</code> are the same type, and the 
converted sequence is identical to the input sequence <code class='backtick'>[from, from_next)</code>, <code class='backtick'>to_next</code> 
is set equal to <code class='backtick'>to</code>, the value of <code class='backtick'>state</code> is unchanged, and there are no changes to 
the values in <code class='backtick'>[to, to_end)</code>.</del>
<ins>If <code class='backtick'>internT</code> and <code class='backtick'>externT</code> are the same type 
and the converted sequence would be identical to the input sequence 
[<code class='backtick'>from</code>, <code class='backtick'>from_next</code>), then no elements are converted, the value of <code class='backtick'>state</code> is unchanged, 
there are no changes to the values in [<code class='backtick'>to</code>, <code class='backtick'>to_end</code>), and the result is <code class='backtick'>noconv</code>. 
Otherwise, if a character in [<code class='backtick'>from</code>,<code class='backtick'>from_end</code>) cannot be converted, conversion stops 
at that character and the result is <code class='backtick'>error</code>. Otherwise, if all input characters are 
successfully converted and placed in the output range, the result is <code class='backtick'>ok</code>. Otherwise, 
the result is <code class='backtick'>partial</code>. In all cases, <code class='backtick'>from_next</code> is set to point to the first element 
of the input that was not converted, <code class='backtick'>to_next</code> is set to point to the first unchanged 
element in the output. [<i>Note</i>: When the result is <code class='backtick'>noconv</code>, <code class='backtick'>from_next</code> points 
to <code class='backtick'>from</code> and <code class='backtick'>to_next</code> points to <code class='backtick'>to</code>. &mdash; <i>end note</i>]</ins>
<p/>
-4- A <code class='backtick'>codecvt</code> facet that is used by <code class='backtick'>basic_filebuf</code> [&hellip;]
<p/>
-5- <i>Returns</i>: <del>An enumeration value, as summarized in Table 91</del>
<ins>The result as described above</ins>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4288"><a href="4288">4288</a>. The <i>Constraints:</i> element in [time.clock.system.members] is probably wrong</h3>
<p><b>Section:</b> 30.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system.members">[time.clock.system.members]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-06-19 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the <i>Constraints:</i> element in 30.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system.members">[time.clock.system.members]</a> for the member typedef
<code class='backtick'>system_clock::rep</code> imposes a requirement for the implementation, without establishing any condition for user 
code. Perhaps it's wrong to use a <i>Constraints:</i> element there.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 30.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system.members">[time.clock.system.members]</a> as indicated:</p>

<blockquote>
<pre>
using system_clock::rep = <i>unspecified</i>;
</pre>
<blockquote>
<p>
-1- <del><i>Constraints:</i></del><ins>The implementation shall ensure that</ins> 
<code>system_clock::duration::min() &lt; system_clock::duration::zero()</code> is <code>true</code>.
[<i>Note 1</i>: This implies that <code class='backtick'>rep</code> is a signed type. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2025-07-15; Reflector discussion]</i></p>

<p>
The discussion revealed a preference to not insert the additional 
"The implementation shall ensure that", because its not really needed, 
since this is just a normal implementation requirement that falls out of
the specification. 
</p>

<p><i>[2025-08-21; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4288"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 30.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/time.clock.system.members">[time.clock.system.members]</a> as indicated:</p>

<blockquote>
<pre>
using system_clock::rep = <i>unspecified</i>;
</pre>
<blockquote>
<p>
-1- <del><i>Constraints:</i></del> <code>system_clock::duration::min() &lt; system_clock::duration::zero()</code> 
is <code>true</code>.
[<i>Note 1</i>: This implies that <code class='backtick'>rep</code> is a signed type. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4289"><a href="4289">4289</a>. Seed sequence is overspecified</h3>
<p><b>Section:</b> 29.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Magnus Fromreide <b>Opened:</b> 2025-06-22 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.seedseq">issues</a> in [rand.req.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on a seed sequence are so strict that it is forbidden to initialize a random number 
generator directly from a hardware random number generator without lots of boiler plate and intermediary objects.
<p/>
The main problem is that the seed sequence requirements state that a seed sequence must be "kind of copyable" 
and that calls to the copy must generate the same output as calls to the original.
<p/>
If one checks the uses of seed sequences then nothing makes use of this capability so I propose to just drop it.
<p/>
There has been a previous attempt to handle this issue using <a href="https://wg21.link/P0205" title=" Efficient Seeding of Random Number Engines">P0205</a> which preserved the old seed 
sequence and added a new concept that it used to seed generators. That effort stalled with the comment that 
it should be solved without the new <code class='backtick'>std::seed_adapter</code>. This DR sidesteps that whole issue by simply removing 
the unused requirements from the seed sequence concept.
<p/>
I will admit that I am unsure about the deletion of Note 1 but since it only seems to attempt to motivate the 
copyability I opted to let it go along with the requirements.
</p>

<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
This is a design change, send to LEWG.
</p>



<p id="res-4289"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 29.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a> as indicated:</p>

<blockquote>
<p>
-1- A <i>seed sequence</i> is an object that <del>consumes a sequence of integer-valued data and</del>
produces a requested number of unsigned integer values <code><i>i</i></code>, <code>0 = i &lt; 2<sup>32</sup></code><del>, 
based on the consumed data</del>.
<p/>
<del>[<i>Note 1</i>: Such an object provides a mechanism to avoid replication of streams of random variates. This can be 
useful, for example, in applications requiring large numbers of random number engines. &mdash; <i>end note</i>]</del>
<p/>
-2- A class <code class='backtick'>S</code> meets the requirements of a seed sequence if the expressions shown in 
Table 124  [tab:rand.req.seedseq] are valid and have the indicated semantics, and if <code class='backtick'>S</code> also meets 
all other requirements of 29.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/rand.req.seedseq">[rand.req.seedseq]</a>. In Table 124 [tab:rand.req.seedseq] and throughout
this subclause:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code class='backtick'>T</code> is the type named by <code class='backtick'>S</code>' s associated <code class='backtick'>result_type</code>;</p></li>
<li><p>(2.2) &mdash; <code class='backtick'>q</code> is a value of type <code class='backtick'>S</code> <del>and <code class='backtick'>r</code> is a value of type <code class='backtick'>S</code> or <code class='backtick'>const S</code></del>; <ins>and</ins></p></li>
<li><p><del>(2.3) &mdash; <code class='backtick'>ib</code> and <code class='backtick'>ie</code> are input iterators with an unsigned integer <code class='backtick'>value_type</code> of at least 32 bits;</del></p></li>
<li><p>(2.4) &mdash; <code class='backtick'>rb</code> and <code class='backtick'>re</code> are mutable random access iterators with an unsigned integer <code class='backtick'>value_type</code> of 
at least 32 bits<del>;</del><ins>.</ins></p></li>
<li><p><del>(2.5) &mdash; <code class='backtick'>ob</code> is an output iterator; and</del></p></li>
<li><p><del>(2.6) &mdash; <code class='backtick'>il</code> is a value of type <code>initializer_list&lt;T&gt;</code>.</del></p></li>
</ol>
<blockquote>
<table border="1">
<caption>Table 124 &mdash; Seed sequence requirements [tab:rand.req.seedseq]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Pre/post-condition</th>
<th align="center">Complexity</th>
</tr>

<tr>
<td>
<code class='backtick'>S::result_type</code>
</td>
<td>
<code class='backtick'>T</code>
</td>
<td>
<code class='backtick'>T</code> is an unsigned integer<br/>
type (6.9.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>) of at least 32 bits.
</td>
<td>
</td>
</tr>

<tr>
<td>
<del><code>S()</code></del>
</td>
<td>
<code></code>
</td>
<td>
<del>Creates a seed sequence with</del><br/>
<del>the same initial state as all</del><br/>
<del>other default-constructed seed</del><br/>
<del>sequences of type <code class='backtick'>S</code>.</del>
</td>
<td>
<del>constant</del>
</td>
</tr>

<tr>
<td>
<del><code class='backtick'>S(ib,ie)</code></del>
</td>
<td>
<code></code>
</td>
<td>
<del>Creates a seed sequence having</del><br/>
<del>internal state that depends on</del><br/>
<del>some or all of the bits of the</del><br/>
<del>supplied sequence <code class='backtick'>[ib, ie)</code>.</del>
</td>
<td>
<del>&#x1d4aa;(ie - ib)</del>
</td>
</tr>

<tr>
<td>
<del><code class='backtick'>S(il)</code></del>
</td>
<td>
<code></code>
</td>
<td>
<del>Same as <code>S(il.begin(), il.end())</code>.</del>
</td>
<td>
<del>same as <code>S(il.begin(), il.end())</code></del>
</td>
</tr>

<tr>
<td>
<code>q.generate(rb,re)</code>
</td>
<td>
<code>void</code>
</td>
<td>
Does nothing if <code class='backtick'>rb == re</code>.<br/>
Otherwise, fills the supplied<br/>
sequence <code class='backtick'>[rb, re)</code> with 32-bit<br/>
quantities <del>that depend on the</del><br/>
<del>sequence supplied to the</del><br/>
<del>constructor and possibly also</del><br/>
<del>depend on the history of</del><br/>
<del><code class='backtick'>generate</code>'s previous</del><br/>
<del>invocations</del>.
</td>
<td>
&#x1d4aa;(re - rb)
</td>
</tr>

<tr>
<td>
<del><code>r.size()</code></del>
</td>
<td>
<del><code>size_t</code></del>
</td>
<td>
<del>The number of 32-bit units that</del><br/>
<del>would be copied by a call to</del><br/>
<del><code class='backtick'>r.param</code>.</del>
</td>
<td>
<del>constant</del>
</td>
</tr>

<tr>
<td>
<del><code>r.param(ob)</code></del>
</td>
<td>
<del><code>void</code></del>
</td>
<td>
<del>Copies to the given destination</del><br/>
<del>a sequence of 32-bit units that</del><br/>
<del>can be provided to the</del><br/>
<del>constructor of a second object of</del><br/>
<del>type <code class='backtick'>S</code>, and that would</del><br/>
<del>reproduce in that second object</del><br/>
<del>a state indistinguishable from</del><br/>
<del>the state of the first object.</del>
</td>
<td>
<del>&#x1d4aa;(r.size())</del>
</td>
</tr>

</table>

</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4290"><a href="4290">4290</a>. Missing <i>Mandates</i> clauses on <code class='backtick'>is_sufficiently_aligned</code></h3>
<p><b>Section:</b> 20.2.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.align">[ptr.align]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Damien Lebrun-Grandie <b>Opened:</b> 2025-07-03 <b>Last modified:</b> 2025-07-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ptr.align">active issues</a> in [ptr.align].</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.align">issues</a> in [ptr.align].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>is_sufficiently_aligned</code> should mandate that the alignment template argument is a power of two 
and that it is greater equal to the byte alignment of its type template argument.
<p/>
In 20.2.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.align">[ptr.align]</a> <code class='backtick'>is_sufficiently_aligned</code> has no <i>Mandates</i> element. It is an 
oversight that we realized when implementing <a href="https://wg21.link/P2897R7" title=" aligned_accessor: An mdspan accessor expressing pointer overalignment">P2897R7</a> into libc++ 
(in <a href="https://github.com/llvm/llvm-project/pull/122603">https://github.com/llvm/llvm-project/pull/122603</a>). 
The function template was originally proposed as a static member function of the <code class='backtick'>aligned_accessor</code> 
class template which has these two <i>Mandates</i> clauses and therefore applied 
(see 23.7.3.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.accessor.aligned.overview">[mdspan.accessor.aligned.overview]</a> p1). It revision <a href="https://wg21.link/P2897R4" title=" aligned_accessor: An mdspan accessor expressing pointer overalignment">P2897R4</a>, 
<code class='backtick'>is_sufficiently_aligned</code> was moved out the class template definition to become the free function
 memory helper that was voted into C++26 but the <i>Mandates</i> were lost in the process.
<p/>
We propose to correct that oversight and reintroduce the following <i>Mandates</i> clauses right above 
20.2.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.align">[ptr.align]</a> p10.
</p>


<p id="res-4290"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5008" title=" Working Draft, Programming Languages  C++">N5008</a>.
</p>

<ol>

<li><p>Modify 20.2.5 <a href="https://timsong-cpp.github.io/cppwp/ptr.align">[ptr.align]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;size_t Alignment, class T&gt;
  bool is_sufficiently_aligned(T* ptr);
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates</i>:</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; <code class='backtick'>Alignment</code> is a power of two, and</ins></p></li>
<li><p><ins>(?.2) &mdash; <code>Alignment &gt;= alignof(T)</code> is <code class='backtick'>true</code>.</ins></p></li>
</ol>
<p>
-10- <i>Preconditions</i>: <code class='backtick'>p</code> points to an object <code class='backtick'>X</code> of a type similar 
(7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>) to <code class='backtick'>T</code>.
<p/>
-11- <i>Returns</i>: <code class='backtick'>true</code> if <code class='backtick'>X</code> has alignment at least <code class='backtick'>Alignment</code>, otherwise <code class='backtick'>false</code>.
<p/>
-12- <i>Throws</i>: Nothing.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4295"><a href="4295">4295</a>. [fund.ts.v3] <code class='backtick'>experimental::observer_ptr</code> should have more constexpr</h3>
<p><b>Section:</b> 8.2.6 [fund.ts.v3::memory.observer.ptr.special] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-07-14 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the Library Fundamentals TS, the <code class='backtick'>swap</code> overload, <code class='backtick'>make_observer_ptr</code>
function, and comparisons for <code class='backtick'>observer_ptr</code> could be constexpr, but are not.
The member <code class='backtick'>swap</code> is already constexpr in the TS, and the non-member <code class='backtick'>swap</code>
is constexpr in libc++ but not the comparisons. The proposed resolution has
been implemented and tested in libstdc++.
</p>
<p>
If we ever rebase the TS on a new C++ standard (or put <code class='backtick'>observer_ptr</code> into
the standard) the comparisons should all be updated like so:
</p>

<blockquote>
<pre><code>
template &lt;class W1, class W2&gt;
<ins>constexpr</ins> bool operator==(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</code></pre>
<blockquote>
<i>Returns</i>: <code class='backtick'>p1.get() == p2.get()</code>.
</blockquote>

<pre><code><del>bool operator!=(...);</del></code></pre>

<pre><code>
template &lt;class W&gt;
<ins>constexpr</ins> bool operator==(observer_ptr&lt;W&gt; p, nullptr_t) noexcept;
<del>bool operator==(...);</del>
</code></pre>
<blockquote>
<i>Returns</i>: <code class='backtick'>not p</code>.
</blockquote>

<pre><code><del>bool operator!=(...);
bool operator!=(...);</del></code></pre>

<pre><code>
template &lt;class W1, class W2&gt;
<ins>constexpr</ins> bool operator&lt;<ins>=&gt;</ins>(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</code></pre>
<blockquote>
<i>Returns</i>:
    <code><del>less&lt;W3&gt;</del><ins>compare_three_way</ins>()(p1.get(), p2.get())</code><del>,
    where <code class='backtick'>W3</code> is the composite pointer type (C++20 7) of <code class='backtick'>W1*</code> and <code class='backtick'>W2*</code></del>.
</blockquote>

<pre><code><del>bool operator&gt;(...);
bool operator&lt;=(...);
bool operator&gt;=(...);</del></code></pre>
</blockquote>


<p><i>[2025-08-21; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
Seven votes for P0 but one vote for NAD, so not made Tentatively Ready.
</p>



<p id="res-4295"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4939" title=" Working Draft, C++ Extensions for Library Fundamentals, Version 3">N4939</a>.
</p>

<ol>
<li>
Modify 8.1 [fund.ts.v3::memory.syn] as indicated:
<blockquote>
<pre><code>
#include &lt;memory&gt;

namespace std {
  namespace experimental::inline fundamentals_v3 {

    <i>// 8.2, Non-owning (observer) pointers</i>
    template &lt;class W&gt; class observer_ptr;

    <i>// 8.2.6, observer_ptr specialized algorithms</i>
    template &lt;class W&gt;
    <ins>constexpr</ins> void swap(observer_ptr&lt;W&gt;&amp;, observer_ptr&lt;W&gt;&amp;) noexcept;
    template &lt;class W&gt;
    <ins>constexpr</ins> observer_ptr&lt;W&gt; make_observer(W*) noexcept;
    <i>// (in)equality operators</i>
    template &lt;class W1, class W2&gt;
    <ins>constexpr</ins> bool operator==(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);

    template &lt;class W1, class W2&gt;
    <ins>constexpr</ins> bool operator!=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W&gt;
    <ins>constexpr</ins> bool operator==(observer_ptr&lt;W&gt;, nullptr_t) noexcept;
    template &lt;class W&gt;
    <ins>constexpr</ins> bool operator!=(observer_ptr&lt;W&gt;, nullptr_t) noexcept;
    template &lt;class W&gt;
    <ins>constexpr</ins> bool operator==(nullptr_t, observer_ptr&lt;W&gt;) noexcept;
    template &lt;class W&gt;
    <ins>constexpr</ins> bool operator!=(nullptr_t, observer_ptr&lt;W&gt;) noexcept;
    <i>// ordering operators</i>
    template &lt;class W1, class W2&gt;
    <ins>constexpr</ins> bool operator&lt;(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    <ins>constexpr</ins> bool operator&gt;(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    <ins>constexpr</ins> bool operator&lt;=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    <ins>constexpr</ins> bool operator&gt;=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);

  } <i>// namespace experimental::inline fundamentals_v3</i>

  <i>// 8.2.7, observer_ptr hash support</i>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt; struct hash&lt;experimental::observer_ptr&lt;T&gt;&gt;;

} <i>// namespace std</i>
</code></pre>
</blockquote>
</li>

<li>
Modify 8.2.6 [fund.ts.v3::memory.observer.ptr.special] as indicated:
<blockquote>


<pre><code>
template &lt;class W&gt;
  <ins>constexpr</ins> void swap(observer_ptr&lt;W&gt;&amp; p1, observer_ptr&lt;W&gt;&amp; p2) noexcept;
</code></pre>
<blockquote>
-2- <i>Effects</i>: <code class='backtick'>p1.swap(p2)</code>.
</blockquote>

<pre><code>
template &lt;class W&gt; <ins>constexpr</ins> observer_ptr&lt;W&gt; make_observer(W* p) noexcept;
</code></pre>
<blockquote>
-4- <i>Returns</i>: <code>observer_ptr&lt;W&gt;{p}</code>.
</blockquote>


<pre><code>
template &lt;class W1, class W2&gt;
  <ins>constexpr</ins> bool operator==(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</code></pre>
<blockquote>
-6- <i>Returns</i>: <code class='backtick'>p1.get() == p2.get()</code>.
</blockquote>

<pre><code>
template &lt;class W1, class W2&gt;
  <ins>constexpr</ins> bool operator!=(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</code></pre>
<blockquote>
-8- <i>Returns</i>: <code class='backtick'>not (p1 == p2)</code>.
</blockquote>

<pre><code>
template &lt;class W&gt;
  <ins>constexpr</ins> bool operator==(observer_ptr&lt;W&gt; p, nullptr_t) noexcept;
template &lt;class W&gt;
  <ins>constexpr</ins> bool operator==(nullptr_t, observer_ptr&lt;W&gt; p) noexcept;
</code></pre>
<blockquote>
-10- <i>Returns</i>: <code class='backtick'>not p</code>.
</blockquote>

<pre><code>
template &lt;class W&gt;
  <ins>constexpr</ins> bool operator!=(observer_ptr&lt;W&gt; p, nullptr_t) noexcept;
template &lt;class W&gt;
  <ins>constexpr</ins> bool operator!=(nullptr_t, observer_ptr&lt;W&gt; p) noexcept;
</code></pre>
<blockquote>
-12- <i>Returns</i>: <code class='backtick'>(bool)p</code>.
</blockquote>

<pre><code>
template &lt;class W1, class W2&gt;
  <ins>constexpr</ins> bool operator&lt;(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</code></pre>
<blockquote>
-14- <i>Returns</i>:
    <code>less&lt;W3&gt;()(p1.get(), p2.get())</code>,
    where <code class='backtick'>W3</code> is the composite pointer type (C++20 7) of <code class='backtick'>W1*</code> and <code class='backtick'>W2*</code>.
</blockquote>

<pre><code>
template &lt;class W1, class W2&gt;
  <ins>constexpr</ins> bool operator&gt;(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</code></pre>
<blockquote>
-16- <i>Returns</i>: <code>p2 &lt; p1</code>.
</blockquote>

<pre><code>
template &lt;class W1, class W2&gt;
  <ins>constexpr</ins> bool operator&lt;=(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</code></pre>
<blockquote>
-16- <i>Returns</i>: <code>not (p2 &lt; p1)</code>.
</blockquote>

<pre><code>
template &lt;class W1, class W2&gt;
  <ins>constexpr</ins> bool operator&gt;=(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);
</code></pre>
<blockquote>
-16- <i>Returns</i>: <code>not (p1 &lt; p2)</code>.
</blockquote>


</blockquote>
</li>
</ol>






<hr>
<h3 id="4296"><a href="4296">4296</a>. Clarify that Cpp17Hash does not imply stateless</h3>
<p><b>Section:</b> 16.4.4.5 <a href="https://timsong-cpp.github.io/cppwp/hash.requirements">[hash.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-07-18 <b>Last modified:</b> 2025-07-18</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#hash.requirements">issues</a> in [hash.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A colleague was mislead into thinking that the <i>Cpp17Hash</i> requirements
imply hash functions must be stateless, so that every <code class='backtick'>h</code> would produce the
same value for <code class='backtick'>h(k)</code>. The normative wording and the note can be interpreted
as saying that the value of <code class='backtick'>h</code> is not relevant, only <code class='backtick'>k</code> matters.
</p>
<blockquote>
The value returned shall depend only on the argument <code class='backtick'>k</code> for the duration
of the program.
<p>
[<i>Note 1</i>:Thus all evaluations of the expression <code class='backtick'>h(k)</code> with the same
value for <code class='backtick'>k</code> yield the same result for a given execution of the program.
&mdash; <i>end note</i>]
</p>
</blockquote>
<p>
I initially proposed changing it to "with the same values for <code class='backtick'>h</code> and <code class='backtick'>k</code>
but Jens observed that if <code class='backtick'>h(k)</code> is allowed to change <code class='backtick'>h</code> then a subsequent
call would not meet the condition "the same value of <code class='backtick'>h</code>".
We should also clarify that the evaluation of <code class='backtick'>h(k)</code> should not change <code class='backtick'>h</code>,
so that we have the same value of <code class='backtick'>h</code> each time.
</p>
<p>
Arguably, the wording in p2 "<code class='backtick'>h</code> is a value of type (possibly const) <code class='backtick'>H</code>"
already covers this. It suggests to me that the effects in the table are for
a particular value <code class='backtick'>h</code>, so for <i>that</i> value, the result of calling <code class='backtick'>h(k)</code>
depends only on the value of <code class='backtick'>k</code>
(and not on the current time, ambient temperature in Denmark,
or the output of a random number generator). And the fact that <code class='backtick'>h</code> can be
a value of type <code class='backtick'>const H</code> implies that calling <code class='backtick'>h(k)</code> doesn't change <code class='backtick'>h</code>.
</p>
<p>
Maybe we want to clarify it in terms of equality-preserving
18.2 <a href="https://timsong-cpp.github.io/cppwp/concepts.equality">[concepts.equality]</a>.
</p>


<p id="res-4296"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4297"><a href="4297">4297</a>. Missing <code class='backtick'>permutable</code> constraint for iterator overloads in Parallel Range Algorithms</h3>
<p><b>Section:</b> 26.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a>, 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>, 26.8.5 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ruslan Arutyunyan <b>Opened:</b> 2025-06-27 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithm.syn">active issues</a> in [algorithm.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithm.syn">issues</a> in [algorithm.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <a href="https://wg21.link/P3179R9" title=" C++ parallel range algorithms">P3179R9</a>: Parallel Range Algorithms paper was accepted to C++ working draft for C++ 26. 
Unfortunately, there is an oversight for three algorithms &mdash; <code class='backtick'>remove</code>, <code class='backtick'>remove_if</code> and <code class='backtick'>partition</code> &mdash; 
where the <code class='backtick'>permutable</code> constraint is missing. This applies to "Iterator and Sentinel" overloads only. The 
issue exists in 26.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a> as well as in per-algorithm sections: 
26.8.5 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> and 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a>.
</p>


<p id="res-4297"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>


<ol>

<li><p>Modify 26.4 <a href="https://timsong-cpp.github.io/cppwp/algorithm.syn">[algorithm.syn]</a>, header <code>&lt;algorithm&gt;</code>, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;<i>execution-policy</i> Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, class T = projected_value_t&lt;I, Proj&gt;&gt;
  requires <ins>permutable&lt;I&gt; &amp;&amp;</ins>
           indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
  subrange&lt;I&gt; remove(Ep&amp; exec, I first, S last, const T&amp; value,
                     Proj proj = {}); <i>// freestanding-deleted</i>
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         class T = projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
           indirect_binary_predicate&lt;ranges::equal_to,
                                     projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
  borrowed_subrange_t&lt;R&gt;
    remove(Ep&amp;&amp; exec, R&amp;&amp; r, const T&amp; value, Proj proj = {}); <i>// freestanding-deleted</i>                                     
[&hellip;]
template&lt;<i>execution-policy</i> Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  <ins>requires permutable&lt;I&gt;</ins>
  subrange&lt;I&gt;
    remove_if(Ep&amp; exec, I first, S last, Pred pred, Proj proj = {}); <i>// freestanding-deleted</i>
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt;
  borrowed_subrange_t&lt;R&gt;
    remove_if(Ep&amp; exec, R&amp; r, Pred pred, Proj proj = {}); <i>// freestanding-deleted</i>
[&hellip;]
template&lt;execution-policy Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  <ins>requires permutable&lt;I&gt;</ins>
  subrange&lt;I&gt;
    partition(Ep&amp;&amp; exec, I first, S last, Pred pred, Proj proj = {}); <i>// freestanding-deleted</i>
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt;
  borrowed_subrange_t&lt;R&gt;
    partition(Ep&amp;&amp; exec, R&amp;&amp; r, Pred pred, Proj proj = {}); <i>// freestanding-deleted</i>
[&hellip;]
</pre>
</blockquote>
</li>


<li><p>Modify 26.7.8 <a href="https://timsong-cpp.github.io/cppwp/alg.remove">[alg.remove]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;<i>execution-policy</i> Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, class T = projected_value_t&lt;I, Proj&gt;&gt;
  requires <ins>permutable&lt;I&gt; &amp;&amp;</ins>
           indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
  subrange&lt;I&gt; 
    ranges::remove(Ep&amp; exec, I first, S last, const T&amp; value, Proj proj = {});
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         class T = projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
           indirect_binary_predicate&lt;ranges::equal_to,
                                     projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
  borrowed_subrange_t&lt;R&gt;
    ranges::remove(Ep&amp;&amp; exec, R&amp;&amp; r, const T&amp; value, Proj proj = {});                                  
[&hellip;]
template&lt;<i>execution-policy</i> Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  <ins>requires permutable&lt;I&gt;</ins>
  subrange&lt;I&gt;
    ranges::remove_if(Ep&amp; exec, I first, S last, Pred pred, Proj proj = {});
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt;
  borrowed_subrange_t&lt;R&gt;
    ranges::remove_if(Ep&amp; exec, R&amp; r, Pred pred, Proj proj = {});
</pre>
<blockquote>
<p>
-1- Let <code><i>E</i></code> be [&hellip;]
</p>
</blockquote>
</blockquote>
</li>


<li><p>Modify 26.8.5 <a href="https://timsong-cpp.github.io/cppwp/alg.partitions">[alg.partitions]</a> as indicated:</p>

<blockquote>
<pre>
[&hellip;]
template&lt;execution-policy Ep, random_access_iterator I, sized_sentinel_for&lt;I&gt; S,
         class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  <ins>requires permutable&lt;I&gt;</ins>
  subrange&lt;I&gt;
    ranges::partition(Ep&amp;&amp; exec, I first, S last, Pred pred, Proj proj = {});
template&lt;<i>execution-policy</i> Ep, <i>sized-random-access-range</i> R, class Proj = identity,
         indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
  requires permutable&lt;iterator_t&lt;R&gt;&gt;
  borrowed_subrange_t&lt;R&gt;
    ranges::partition(Ep&amp;&amp; exec, R&amp;&amp; r, Pred pred, Proj proj = {});
</pre>
<blockquote>
<p>
-1- Let <code class='backtick'>proj</code> be <code class='backtick'>identity{}</code> for the overloads with no parameter named <code class='backtick'>proj</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4298"><a href="4298">4298</a>. &sect;[meta.reflection.extract] Malformed "<code class='backtick'>F noexcept</code>" type</h3>
<p><b>Section:</b> 21.4.12 <a href="https://timsong-cpp.github.io/cppwp/meta.reflection.extract">[meta.reflection.extract]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jan Schultke <b>Opened:</b> 2025-07-10 <b>Last modified:</b> 2025-08-28</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is a follow-up from <a href="https://github.com/cplusplus/draft/pull/8008#discussion_r2190652506">https://github.com/cplusplus/#8008</a>
<p/>
In 21.4.12 <a href="https://timsong-cpp.github.io/cppwp/meta.reflection.extract">[meta.reflection.extract]</a> paragraph 7, the type "<code class='backtick'>F noexcept</code>" is used, presumably 
with the intent that <code class='backtick'>noexcept</code> would be "injected" into the <i>parameters-and-qualifiers</i> of 
the declarator associated with <code class='backtick'>F</code>.
<p/>
However, the syntax <code class='backtick'>F noexcept</code> is ill-formed, and does not have that intended effect. There ought 
to be a better way to phrase that.
</p>

<p><i>[2025-08-27; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>
<p>
"phrase this in terms of the quoted type description in 9.3.4.6 <a href="https://timsong-cpp.github.io/cppwp/dcl.fct">[dcl.fct]</a>
(see before bullet 1.6, <q>The type of the declarator-id in D is...</q>)."
</p>



<p id="res-4298"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 21.4.12 <a href="https://timsong-cpp.github.io/cppwp/meta.reflection.extract">[meta.reflection.extract]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: In bullet (7.1) we apply an additional drive-by fix for the broken 
"<code class='backtick'>T</code> is" construction before the <code class='backtick'>is_convertible_v</code> condition]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class T&gt;
  consteval T <i>extract-member-or-function</i>(info r); <i>// exposition only</i>
</pre>
<blockquote>
<p>
<ins>-?- Given a function type <code class='backtick'>F</code>, let the type <code class='backtick'>F</code> <i>with</i> <code class='backtick'>noexcept</code> be the same type, 
except that the <i>parameters-and-qualifiers</i> in the <i>noptr-declarator</i> describing the 
type contain <code class='backtick'>noexcept(true)</code>.</ins>
<p/>
-6- <i>Returns</i>: [&hellip;]
<p/>
-7- <i>Throws</i>: <code class='backtick'>meta::exception</code> unless
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; <code class='backtick'>r</code> represents a non-static data member with type <code><i>X</i></code>, 
that is not a bit-field, that is a direct member of class <code class='backtick'>C</code>, <code class='backtick'>T</code> and <code class='backtick'>C</code> are similar types 
(7.3.6 <a href="https://timsong-cpp.github.io/cppwp/conv.qual">[conv.qual]</a>), and <del><code class='backtick'>T</code> is</del> <code>is_convertible_v&lt;<i>X</i> C::*, T&gt;</code> is <code class='backtick'>true</code>;</p></li>
<li><p>(7.2) &mdash; <code class='backtick'>r</code> represents an implicit object member function with type <code class='backtick'>F</code> or <code class='backtick'>F</code> <ins>with</ins> <code class='backtick'>noexcept</code> 
that is a direct member of a class <code class='backtick'>C</code>, and <code class='backtick'>T</code> is <code class='backtick'>F C::*</code>; or</p></li>
<li><p>(7.3) &mdash; <code class='backtick'>r</code> represents a non-member function, static member function, or explicit object
member function of function type <code class='backtick'>F</code> or <code class='backtick'>F</code> <ins>with</ins> <code class='backtick'>noexcept</code>, and <code class='backtick'>T</code> is <code class='backtick'>F*</code>.</p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4299"><a href="4299">4299</a>. Missing <i>Mandates:</i> part in <code>optional&lt;T&amp;&gt;::transform</code></h3>
<p><b>Section:</b> 22.5.4.7 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.monadic">[optional.ref.monadic]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Giuseppe D'Angelo <b>Opened:</b> 2025-07-15 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.ref.monadic">active issues</a> in [optional.ref.monadic].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.ref.monadic">issues</a> in [optional.ref.monadic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.5.4.7 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.monadic">[optional.ref.monadic]</a> the specification of <code>optional&lt;T&amp;&gt;::transform</code>
is missing an additional part of the <i>Mandates:</i> element compared to the primary template's
<code class='backtick'>transform</code> (in 22.5.3.8 <a href="https://timsong-cpp.github.io/cppwp/optional.monadic">[optional.monadic]</a> p8); that is, is missing to enforce that
the <code class='backtick'>U</code> type is a valid contained type for <code class='backtick'>optional</code>.
<p/>
The definition of "valid contained type" comes from <a href="https://wg21.link/P2988R12" title=" std::optional<T&amp;>">P2988R12</a>. The paper
amended the <i>Mandates:</i> element of the primary template's <code class='backtick'>transform</code> to
use this definition. The fact that the same wording has not been applied to 
<code>optional&lt;T&amp;&gt;::transform</code> as well looks like an oversight. I would
suggest to apply it.
</p>


<p id="res-4299"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.4.7 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.monadic">[optional.ref.monadic]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F&gt;
  constexpr optional&lt;remove_cv_t&lt;invoke_result_t&lt;F, T&amp;&gt;&gt;&gt; transform(F&amp;&amp; f) const;
</pre>
<blockquote>
<p>
-4- Let <code class='backtick'>U</code> be <code>remove_cv_t&lt;invoke_result_t&lt;F, T&amp;&gt;&gt;</code>.
<p/>
-5- <i>Mandates</i>: <ins><code class='backtick'>U</code> is a valid contained type for <code class='backtick'>optional</code>.</ins> The declaration
</p>
<blockquote><pre>
U u(invoke(std::forward&lt;F&gt;(f), *val ));
</pre></blockquote>
<p>
is well-formed for some invented variable <code class='backtick'>u</code>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4302"><a href="4302">4302</a>. Problematic <code class='backtick'>vector_sum_of_squares</code> wording</h3>
<p><b>Section:</b> 29.9.13.8 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.ssq">[linalg.algs.blas1.ssq]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mark Hoemmen <b>Opened:</b> 2025-07-23 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current wording for <code class='backtick'>vector_sum_of_squares</code>
29.9.13.8 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.ssq">[linalg.algs.blas1.ssq]</a> has three problems with its specification of the
value of <code class='backtick'>result.scaling_factor</code>.
</p>
<ol>
<li><p>The function permits <code class='backtick'>InVec::value_type</code> and <code class='backtick'>Scalar</code> to be any
linear algebra value types. However, computing
<code class='backtick'>result.scaling_factor</code> that satisfies both (3.1) and (3.2) requires
more operations, such as division. Even if those operations are
defined, they might not make <code class='backtick'>result.scaling_factor</code> satisfy the
required properties. For example, integers have division, but integer
division won't help here.</p></li>
<li><p>LAPACK's xLASSQ (the algorithm to which Note 1 in
29.9.13.8 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.ssq">[linalg.algs.blas1.ssq]</a> refers) changed its algorithm recently 
(see <a href="https://github.com/Reference-LAPACK/lapack/pull/494">Reference-LAPACK/lapack/pull/#494</a>) 
so that the scaling factor is no longer necessarily the maximum of the input
scaling factor and the absolute value of all the input elements. It's
a better algorithm and we would like to be able to use it.</p></li>
<li><p>
Both members of <code>sum_of_squares_result&lt;Scalar&gt;</code> have the same type,
<code class='backtick'>Scalar</code>. If the input <code class='backtick'>mdspan</code>'s <code class='backtick'>value_type</code> represents a quantity
with units, this would not be correct. For example, if <code class='backtick'>value_type</code>
has units of distance (say <code>[m]</code>), the sum of squares should have units
of area (<code>[m<sup>2</sup>]</code>), while the scaling factor should have units of
distance (<code>[m]</code>).
</p></li>
</ol>
<p>
Problem (1) means that the current wording is broken. I suggest two
different ways to fix this.
</p>
<ol>
<li><p>Remove <code class='backtick'>vector_sum_of_squares</code> entirely (both overloads from
29.9.2 <a href="https://timsong-cpp.github.io/cppwp/linalg.syn">[linalg.syn]</a>, and the entire 
29.9.13.8 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.ssq">[linalg.algs.blas1.ssq]</a>). That way, we
won't be baking an old, less good algorithm into the Standard. Remove
Note 3 from 29.9.13.9 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.nrm2">[linalg.algs.blas1.nrm2]</a>, which is the only 
other reference to <code class='backtick'>vector_sum_of_squares</code> in the Standard.</p></li>
<li><p>Fix 29.9.13.8 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.ssq">[linalg.algs.blas1.ssq]</a> by adding to the 
<i>Mandates</i> element (para 2) that <code class='backtick'>InVec::value_type</code> and <code class='backtick'>Scalar</code> 
are both floating-point types (so that we could fix this later if 
we want), and remove 29.9.13.8 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.ssq">[linalg.algs.blas1.ssq]</a> 3.1. 
Optionally add <i>Recommended Practice</i>, though Note 1 already 
suggests the intent.</p></li>
</ol>
<p>
I prefer just removing <code class='backtick'>vector_sum_of_squares</code>. Implementers who care
about QoI of <code class='backtick'>vector_two_norm</code> should already know what to do. If
somebody cares sufficiently, they can propose it back for C++29 and
think about how to make it work for generic number types.
</p>


<p id="res-4302"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The wording below implements option 1 of the issue discussion]
</p>
</blockquote>

<ol>

<li><p>Modify 29.9.2 <a href="https://timsong-cpp.github.io/cppwp/linalg.syn">[linalg.syn]</a>, header <code>&lt;linalg&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::linalg {
  [&hellip;]
  <del>// <i>29.9.13.8 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.ssq">[linalg.algs.blas1.ssq]</a>, scaled sum of squares of a vector's elements</i>
  template&lt;class Scalar&gt;
    struct sum_of_squares_result {
      Scalar scaling_factor;
    };
  template&lt;<i>in-vector</i> InVec, class Scalar&gt;
    sum_of_squares_result&lt;Scalar&gt;
      vector_sum_of_squares(InVec v, sum_of_squares_result&lt;Scalar&gt; init);
  template&lt;class ExecutionPolicy, <i>in-vector</i> InVec, class Scalar&gt;
    sum_of_squares_result&lt;Scalar&gt;
      vector_sum_of_squares(ExecutionPolicy&amp;&amp; exec,
                            InVec v, sum_of_squares_result&lt;Scalar&gt; init);</del> 
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Delete the entire 29.9.13.8 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.ssq">[linalg.algs.blas1.ssq]</a> as indicated:</p>

<blockquote>
<p>
<del><b>29.9.13.8 Scaled sum of squares of a vector's elements [linalg.algs.blas1.ssq]</b></del>
</p>
<pre>
<del>template&lt;<i>in-vector</i> InVec, class Scalar&gt;
  sum_of_squares_result&lt;Scalar&gt; vector_sum_of_squares(InVec v, sum_of_squares_result&lt;Scalar&gt; init);
template&lt;class ExecutionPolicy, <i>in-vector</i> InVec, class Scalar&gt;
  sum_of_squares_result&lt;Scalar&gt; vector_sum_of_squares(ExecutionPolicy&amp;&amp; exec,
                                                            InVec v, sum_of_squares_result&lt;Scalar&gt; init);</del>
</pre>
<blockquote>
<p>
<del>-1- [<i>Note 1</i>: These functions correspond to the LAPACK function xLASSQ[20]. &mdash; <i>end note</i>]</del>
<p/>
<del>-2- <i>Mandates</i>: <code>decltype(<i>abs-if-needed</i>(declval&lt;typename InVec::value_type&gt;()))</code> is convertible
to <code class='backtick'>Scalar</code>.</del>
<p/>
<del>-3- <i>Effects</i>: Returns a value <code class='backtick'>result</code> such that</del>
</p>
<ol style="list-style-type: none">
<li><p><del>(3.1) &mdash; <code class='backtick'>result.scaling_factor</code> is the maximum of <code class='backtick'>init.scaling_factor</code> and 
<code><i>abs-if-needed</i>(x[i])</code> for all <code class='backtick'>i</code> in the domain of <code class='backtick'>v</code>; and</del></p></li>
<li><p><del>(3.2) &mdash; let <code class='backtick'>s2init</code> be</del></p>
<blockquote><pre>
<del>init.scaling_factor * init.scaling_factor * init.scaled_sum_of_squares</del>
</pre></blockquote>
<p>
<del>then <code class='backtick'>result.scaling_factor * result.scaling_factor * result.scaled_sum_of_squares</code>
equals the sum of <code class='backtick'>s2init</code> and the squares of <code><i>abs-if-needed</i>(x[i])</code> for all <code class='backtick'>i</code> 
in the domain of <code class='backtick'>v</code>.</del></p></li>
</ol>
<p>
<del>-4- <i>Remarks</i>: If <code class='backtick'>InVec::value_type</code>, and <code class='backtick'>Scalar</code> are all floating-point types or specializations of 
<code class='backtick'>complex</code>, and if <code class='backtick'>Scalar</code> has higher precision than <code class='backtick'>InVec::value_type</code>, then intermediate terms in the sum 
use <code class='backtick'>Scalar</code>'s precision or greater.</del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 29.9.13.9 <a href="https://timsong-cpp.github.io/cppwp/linalg.algs.blas1.nrm2">[linalg.algs.blas1.nrm2]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>in-vector</i> InVec, class Scalar&gt;
  Scalar vector_two_norm(InVec v, Scalar init);
template&lt;class ExecutionPolicy, <i>in-vector</i> InVec, class Scalar&gt;
  Scalar vector_two_norm(ExecutionPolicy&amp;&amp; exec, InVec v, Scalar init);
</pre>
<blockquote>
<p>
-1- [<i>Note 1</i>: [&hellip;] ]
<p/>
-2- <i>Mandates</i>: [&hellip;]
<p/>
-3- <i>Returns</i>: [&hellip;]
<p/>
[<i>Note 2</i>: [&hellip;] ]
<p/>
-4- <i>Remarks</i>: [&hellip;]
<p/>
<del>[<i>Note 3</i>: An implementation of this function for floating-point types <code class='backtick'>T</code> 
can use the <code class='backtick'>scaled_sum_of_squares</code> result from 
<code class='backtick'>vector_sum_of_squares(x, {.scaling_factor=1.0, .scaled_sum_of_squares=init})</code>. 
&mdash; <i>end note</i>]</del>
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3 id="4303"><a href="4303">4303</a>. <code class='backtick'>std::decay_t</code> in the specification of <code class='backtick'>ranges::distance</code> is problematic</h3>
<p><b>Section:</b> 24.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.iter.op.distance">[range.iter.op.distance]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-07-24 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.iter.op.distance">issues</a> in [range.iter.op.distance].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is discovered when implementing the resolution LWG <a href="4242" title="ranges::distance does not work with volatile iterators (Status: WP)">4242</a>. 
Per LWG <a href="4242" title="ranges::distance does not work with volatile iterators (Status: WP)">4242</a>, it is intended to allow <code class='backtick'>ranges::distance</code> to handle 
<code class='backtick'>volatile</code>-qualified iterator values. 
However, the uses of <code class='backtick'>decay_t</code> (established per LWG <a href="3664" title="LWG 3392 broke std::ranges::distance(a, a+3) (Status: C++23)">3664</a>) are still problematic, 
because when <code>sized_sentinel_for&lt;S, decay_t&lt;I&gt;&gt;</code> is modeled, there's no 
semantic or syntactic requirement that <code class='backtick'>S</code> shall work with volatile-qualified <code class='backtick'>I</code>.
<p/>
If we implement the constraint as is, there will still be some underconstrained cases. E.g. 
When the <code class='backtick'>operator==</code> or <code class='backtick'>operator-</code> intendedly rejects volatile-qualified iterators. And 
even when they accept volatile-qualified iterators, the additional semantic requirements 
imposed by <code>sized_sentinel_for&lt;S, decay_t&lt;I&gt;&gt;</code> are still undesired.
<p/>
I think we should only decay arrays and keep <code class='backtick'>volatile</code> for non-array arguments.
</p>

<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set priority to 4 after reflector poll.
</p>



<p id="res-4303"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a>, header <code>&lt;iterator&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std: {
  [&hellip;]
  // <i>24.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.iter.op.distance">[range.iter.op.distance]</a>, ranges::distance</i>
 
  <ins>template&lt;class T&gt;
    using <i>distance-iterator-t</i> =               // <i>exposition only</i>
      conditional_t&lt;is_array_v&lt;remove_reference_t&lt;T&gt;&gt;,
        decay_t&lt;T&gt;, remove_const_t&lt;remove_reference_t&lt;T&gt;&gt;&gt;;
</ins>  
  template&lt;class I, sentinel_for&lt;I&gt; S&gt;
    requires (!sized_sentinel_for&lt;S, I&gt;)
    constexpr iter_difference_t&lt;I&gt; distance(I first, S last); // <i>freestanding</i>
  template&lt;class I, sized_sentinel_for&lt;<del>decay_t</del><ins><i>distance-iterator-t</i></ins>&lt;I&gt;&gt; S&gt;
    constexpr iter_difference_t&lt;<del>decay_t</del><ins><i>distance-iterator-t</i></ins>&lt;I&gt;&gt; distance(I&amp;&amp; first, S last); // <i>freestanding</i>
  template&lt;range R&gt;
    constexpr range_difference_t&lt;R&gt; distance(R&amp;&amp; r); // <i>freestanding</i>
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 24.4.4.3 <a href="https://timsong-cpp.github.io/cppwp/range.iter.op.distance">[range.iter.op.distance]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class I, sized_sentinel_for&lt;<del>decay_t</del><ins><i>distance-iterator-t</i></ins>&lt;I&gt;&gt; S&gt;
  constexpr iter_difference_t&lt;<del>decay_t</del><ins><i>distance-iterator-t</i></ins>&lt;I&gt;&gt; distance(I&amp;&amp; first, S last);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if constexpr (!is_array_v&lt;remove_reference_t&lt;I&gt;&gt;)
  return last - first;
else
  return last - static_cast&lt;decay_t&lt;I&gt;&gt;(first);
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4304"><a href="4304">4304</a>. <code>std::optional&lt;<i>NonReturnable</i>&amp;&gt;</code> is ill-formed due to <code class='backtick'>value_or</code></h3>
<p><b>Section:</b> 22.5.4.6 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.observe">[optional.ref.observe]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-07-25 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, if <code class='backtick'>T</code> is an array type or a function type, instantiation of <code>std::optional&lt;T&amp;&gt;</code> 
is still ill-formed, because the return type of its <code class='backtick'>value_or</code> member function is specified as 
<code>remove_cv_t&lt;T&gt;</code>, which is invalid as a return type.
<p/>
However, we don't exclude such <code>T&amp;</code> from valid contained types. Given only <code class='backtick'>value_or</code> is 
problematic here, perhaps we can avoid providing it if <code class='backtick'>T</code> is not returnable.
</p>


<p id="res-4304"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/optional.optional.ref.general">[optional.optional.ref.general]</a>, header <code>&lt;iterator&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T&gt;
  class optional&lt;T&amp;&gt; {
    [&hellip;]
    constexpr T&amp; value() const; // freestanding-deleted
    template&lt;class U = remove_cv_t&lt;T&gt;&gt;
      constexpr remove_cv_t&lt;T&gt; value_or(U&amp;&amp; u) const; <ins>// <i>not always present</i></ins>
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 22.5.4.6 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.observe">[optional.ref.observe]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr remove_cv_t&lt;T&gt; value_or(U&amp;&amp; u) const;
</pre>
<blockquote>
<p>
-8- Let <code class='backtick'>X</code> be <code>remove_cv_t&lt;T&gt;</code>.
<p/>
-9- <i>Mandates</i>: <code>is_constructible_v&lt;X, T&amp;&gt; &amp;&amp; is_convertible_v&lt;U, X&gt;</code> is <code class='backtick'>true</code>.
<p/>
-10- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
return has_value() ? *<i>val</i> : static_cast&lt;X&gt;(std::forward&lt;U&gt;(u));
</pre></blockquote>
<p>
<ins>-?- <i>Remarks</i>: This function template is present if and only if <code class='backtick'>T</code> is a non-array object type.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3 id="4305"><a href="4305">4305</a>. Missing user requirements on <code class='backtick'>type_order</code> template</h3>
<p><b>Section:</b> 17.12.7 <a href="https://timsong-cpp.github.io/cppwp/compare.type">[compare.type]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2025-07-27 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The recently approved paper <a href="https://wg21.link/P2830R10" title=" Standardized Constexpr Type Ordering">P2830R10</a> proposes to add the new <code class='backtick'>type_order</code>
type traits to 17.12 <a href="https://timsong-cpp.github.io/cppwp/cmp">[cmp]</a> (and thus outside of 21.3 <a href="https://timsong-cpp.github.io/cppwp/type.traits">[type.traits]</a>), 
which has the subtle and most likely unintended effect, that it doesn't fall under the 
general requirement expressed in 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a> p4,
</p>
<blockquote><p>
Unless otherwise specified, the behavior of a program that adds specializations for 
any of the templates specified in 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a> is undefined.
</p></blockquote>
<p>
and so in principle the explicit allowance specified in 16.4.5.2.1 <a href="https://timsong-cpp.github.io/cppwp/namespace.std">[namespace.std]</a> p2,
</p>
<blockquote><p>
Unless explicitly prohibited, a program may add a template specialization for any standard 
library class template to namespace <code class='backtick'>std</code> [&hellip;]
</p></blockquote>
<p>
holds. So we need to add extra wording to the <code class='backtick'>type_order</code> specification in 
17.12.7 <a href="https://timsong-cpp.github.io/cppwp/compare.type">[compare.type]</a> to prohibit such program specializations.
<p/>
This was reported shortly before the Sofia meeting 
<a href="https://lists.isocpp.org/lib/2025/06/31725.php">during reflector discussion</a>  
but seems to be forgotten before the final paper appeared on plenary. 
<p/>
During the reflector discussion two possible ways to solve this issue were pointed out:
</p>
<ol>
<li><p>The most simple one would mimic the wording in 21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a> p4
quoted above.</p></li>
<li><p>Instead of introducing just another undefined opportunity to run into undefined
behaviour it has been pointed out that we could follow the approach taken by <code class='backtick'>std::initializer_list</code>
and make the program ill-formed in this case, as specified in 17.11.2 <a href="https://timsong-cpp.github.io/cppwp/initializer.list.syn">[initializer.list.syn]</a> p2:
</p>
<blockquote><p>
If an explicit specialization or partial specialization of <code class='backtick'>initializer_list</code> is declared, 
the program is ill-formed.
</p></blockquote>
</li>
</ol>
Jonathan Wakely responded to the reflector discussion:
<blockquote><p>
I think ill-formed would be better. It shouldn't be difficult for implementations to have special cases that are disallowed. 
</p></blockquote>
<p>
Given the already existing experience with <code class='backtick'>std::initializer_list</code> the proposed wording below
therefore follows the ill-formed program approach.
</p>


<p id="res-4305"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 17.12.7 <a href="https://timsong-cpp.github.io/cppwp/compare.type">[compare.type]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt;
  struct type_order;
</pre>
<blockquote>
<p>
-2- The name <code class='backtick'>type_order</code> denotes a <i>Cpp17BinaryTypeTrait</i> (21.3.2 <a href="https://timsong-cpp.github.io/cppwp/meta.rqmts">[meta.rqmts]</a>) with a base 
characteristic of <code>integral_constant&lt;strong_ordering, <i>TYPE-ORDER</i>(T, U)&gt;</code>.
<p/>
<ins>-?- If an explicit specialization or partial specialization of <code class='backtick'>type_order</code> is declared, the program is ill-formed.</ins>
<p/>
-3- <i>Recommended practice</i>: The order should be lexicographical on parameter-type-lists and template
argument lists.
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4306"><a href="4306">4306</a>. Interaction between LWG 2259 and <i>Constraints</i> of member functions</h3>
<p><b>Section:</b> 16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-07-24 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#member.functions">active issues</a> in [member.functions].</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in [member.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>/2 seems to allow that even when the constraints are not met, 
such a default constructor can be selected, because no restriction is imposed when no overload 
is originally selected. Per the discussion in LWG <a href="2563" title="LWG 2259 relaxes requirements, perhaps unintentionally (Status: NAD)">2563</a> (closed as NAD), it even 
seems to allow the implementation to add a default constructor when there's originally none.
<p/>
However, we're constraining some member functions, e.g. default constructors of <code class='backtick'>unique_ptr</code>, 
<code class='backtick'>tuple</code>, and <code class='backtick'>variant</code>. Allowance of more permissive overload sets of constructors effectively 
renders the <i>Constraints</i> meaningless, because even if the implementation doesn't constrain 
the default constructors at all, it can still satisfy the restriction in 
16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>/2 since LWG <a href="2259" title="Issues in 17.6.5.5 rules for member functions (Status: C++17)">2259</a>.
<p/>
Consider the following example:
</p>
<blockquote><pre>
struct S 
{
  S() = delete;
};

static_assert(std::is_default_constructible_v&lt;std::tuple&lt;S&gt;&gt;);
std::tuple&lt;S&gt; t;
</pre></blockquote>
<p>
Even though currently the default constructor of <code class='backtick'>std::tuple</code> is constrained (22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a>/6), 
16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>/2 seemingly allows the implementation to add another overload that's also 
a default constructor, constrained by "<code>is_default_constructible_v&lt;T<sub><i>i</i></sub>&gt;</code> is <code class='backtick'>false</code> 
for at least one <code><i>i</i></code>", and then render the example well-formed or only error on actual 
instantiation of the "additional" default constructor. Note that such an additional overload effectively 
removes the <i>Constraints</i> element requirements.
<p/>
As shown by the example, the allowance in 16.4.6.5 <a href="https://timsong-cpp.github.io/cppwp/member.functions">[member.functions]</a>/2 can weaken or even invalidate 
<i>Constraints</i> of member functions.
<p/>
So perhaps some wording change is necessary to guarantee the <i>Constraints</i> of member functions to be meaningful.
</p>

<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set priority to 3 after reflector poll.
</p>



<p id="res-4306"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4307"><a href="4307">4307</a>. Make good use of <code><i>sized-random-access-range</i></code> and <code><i>bidirectional-common</i></code>
in <code>&lt;ranges&gt;</code></h3>
<p><b>Section:</b> 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, 25.4.6 <a href="https://timsong-cpp.github.io/cppwp/range.refinements">[range.refinements]</a>, 25.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/view.interface.general">[view.interface.general]</a>, 25.7.10.1 <a href="https://timsong-cpp.github.io/cppwp/range.take.overview">[range.take.overview]</a>, 25.7.12.1 <a href="https://timsong-cpp.github.io/cppwp/range.drop.overview">[range.drop.overview]</a>, 25.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a>, 25.7.14.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a>, 25.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.view">[range.join.with.view]</a>, 25.7.15.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.iterator">[range.join.with.iterator]</a>, 25.7.20.2 <a href="https://timsong-cpp.github.io/cppwp/range.common.view">[range.common.view]</a>, 25.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.view">[range.zip.view]</a>, 25.7.30.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a>, 25.7.33.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-07-28 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ranges.syn">active issues</a> in [ranges.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#ranges.syn">issues</a> in [ranges.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P3179" title=" C++ parallel range algorithms">P3179</a> introduces a new
exposition-only concept, <code><i>sized-random-access-range</i></code>, into <code>&lt;ranges&gt;</code> to simplify
the signature of parallel range algorithms.
However, this also applies more broadly to <code>&lt;ranges&gt;</code>, as we often need to determine whether a range satisfies
both <code>sized_range</code> and <code>random_access_range</code> in order to dispatch optimized branches.
<p/>
In addition, we often need to determine whether a range satisfies both <code>common_range</code> and
<code>bidirectional_range</code> to decide whether to provide backward traversal capabilities,
which is expressed by the exposition-only concept <code><i>bidirectional-common</i></code> introduced in 
<a href="https://wg21.link/P2441" title=" views::join_with">P2441</a>.
Unfortunately, this concept currently only applies to a single section.
<p/>
It would be much simpler and more readable if both concepts were available throughout <code>&lt;ranges&gt;</code>,
which would also allow newly introduced adapters or other library features to take advantage of them.
Note that since some of these simplifications change the order in which the concepts are spelled, they may not be
purely editorial.
</p>


<p id="res-4307"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>
<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code>
        synopsis, as indicated:</p>

<blockquote>
<pre>
// <i>mostly freestanding</i>
#include &lt;compare&gt;              // <i>see 17.12.1 <a href="https://timsong-cpp.github.io/cppwp/compare.syn">[compare.syn]</a></i>
#include &lt;initializer_list&gt;     // <i>see 17.11.2 <a href="https://timsong-cpp.github.io/cppwp/initializer.list.syn">[initializer.list.syn]</a></i>
#include &lt;iterator&gt;             // <i>see 24.2 <a href="https://timsong-cpp.github.io/cppwp/iterator.synopsis">[iterator.synopsis]</a></i>

namespace std::ranges {
  [&hellip;]
  template&lt;class T&gt;
    concept <i>sized-random-access-range</i> = <i>see below</i>;              // <i>exposition only</i>
  
  <ins>template&lt;class T&gt;
    concept <i>common-bidirectional-range</i> = <i>see below</i>;             // <i>exposition only</i></ins>
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.4.6 <a href="https://timsong-cpp.github.io/cppwp/range.refinements">[range.refinements]</a> as indicated:</p>

<blockquote>
[&hellip;]
<p>
-8- The exposition-only concept <code><i>sized-random-access-range</i></code> specifies the requirements 
of a <code>range</code> type that is sized and allows random access to its elements.
</p>
<pre>
template&lt;class T&gt;
  concept <i>sized-random-access-range</i> =           // <i>exposition only</i>
    random_access_range&lt;T&gt; &amp;&amp; sized_range&lt;T&gt;;
</pre>
<p>
[<i>Note 1</i>: This concept constrains some parallel algorithm overloads; see [algorithms]. &mdash; <i>end
    note</i>]
<p/>
<ins>-?- The exposition-only concept <code><i>common-bidirectional-range</i></code> specifies the
requirements of a <code>range</code> type that is bidirectional and whose iterator and sentinel types are
the same.</ins>
</p>
<pre>
<ins>template&lt;class T&gt;
  concept <i>common-bidirectional-range</i> =           // <i>exposition only</i>
    bidirectional_range&lt;T&gt; &amp;&amp; common_range&lt;T&gt;;</ins>
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.3.1 <a href="https://timsong-cpp.github.io/cppwp/view.interface.general">[view.interface.general]</a> as indicated:</p>

<blockquote>
<p>
-1- The class template <code>view_interface</code> is a helper for defining view-like types that offer a
  container-like interface. It is parameterized with the type that is derived from it.
</p>
<pre>
namespace std::ranges {
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface {
  private:
    [&hellip;]
  public:
    [&hellip;]
    constexpr decltype(auto) back() requires <del>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;</del><ins><i>common-bidirectional-range</i>&lt;D&gt;</ins>;
    constexpr decltype(auto) back() const
      requires <del>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;</del><ins><i>common-bidirectional-range</i>&lt;const D&gt;</ins>;
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.3.2 <a href="https://timsong-cpp.github.io/cppwp/view.interface.members">[view.interface.members]</a> as indicated:</p>

<blockquote>
 <pre>
constexpr decltype(auto) back() requires <del>bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;</del><ins><i>common-bidirectional-range</i>&lt;D&gt;</ins>;
constexpr decltype(auto) back() const
  requires <del>bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;</del><ins><i>common-bidirectional-range</i>&lt;const D&gt;</ins>;
</pre>
<blockquote>
<p>
-3- <i>Hardened preconditions</i>: <code>!empty()</code> is <code>true</code>.
<p/>
-4- <i>Effects</i>: Equivalent to: <code>return *ranges::prev(ranges::end(<i>derived</i>()));</code>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 25.7.10.1 <a href="https://timsong-cpp.github.io/cppwp/range.take.overview">[range.take.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::take</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Let <code>E</code> and <code>F</code> be expressions, let <code>T</code> be
<code>remove_cvref_t&lt;decltype((E))&gt;</code>, and let <code>D</code> be 
<code>range_difference_t&lt;decltype((E))&gt;</code>.
If <code>decltype((F))</code> does not model <code>convertible_to&lt;D&gt;</code>,
<code>views::take(E, F)</code> is ill-formed. Otherwise, the expression <code>views::take(E, F)</code> 
is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li>
[&hellip;]
</li>
<li>
<p>(2.2) &mdash; Otherwise, if <code>T</code> models <del><code>random_access_range</code> and
<code>sized_range</code></del><ins><code><i>sized-random-access-range</i></code></ins>
and is a specialization of <code>span</code> (23.7.2.2 <a href="https://timsong-cpp.github.io/cppwp/views.span">[views.span]</a>),
<code>basic_string_view</code> (27.3 <a href="https://timsong-cpp.github.io/cppwp/string.view">[string.view]</a>), or <code>ranges::subrange</code>
(25.5.4 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a>), then <code>U(ranges::begin(E), ranges::begin(E) + 
std::min&lt;D&gt;(ranges::distance(E), F))</code>, except that <code>E</code> is evaluated only once,
where <code>U</code> is a type determined as follows:
</p>
[&hellip;]
</li>
<li>
<p>(2.3) &mdash; otherwise, if <code>T</code> is a specialization of <code>iota_view</code>
(25.6.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.iota.view">[range.iota.view]</a>) that models <del><code>random_access_range</code> and
<code>sized_range</code></del><ins><code><i>sized-random-access-range</i></code></ins>, then
<code>iota_view(*ranges::begin(E), *(ranges::begin(E) + std::min&lt;D&gt;(ranges::distance(E), F)))</code>,
except that <code>E</code> is evaluated only once.
</p>
</li>
</ol>
</blockquote>

</li>

<li><p>Modify 25.7.12.1 <a href="https://timsong-cpp.github.io/cppwp/range.drop.overview">[range.drop.overview]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code>views::drop</code> denotes a range adaptor object (25.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.adaptor.object">[range.adaptor.object]</a>).
Let <code>E</code> and <code>F</code> be expressions, let <code>T</code> be
<code>remove_cvref_t&lt;decltype((E))&gt;</code>, and let <code>D</code> be 
<code>range_difference_t&lt;decltype((E))&gt;</code>.
If <code>decltype((F))</code> does not model <code>convertible_to&lt;D&gt;</code>,
<code>views::drop(E, F)</code> is ill-formed. Otherwise, the expression <code>views::drop(E, F)</code> 
is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li>
[&hellip;]
</li>
<li>
<p>(2.2) &mdash; Otherwise, if <code>T</code> models <del><code>random_access_range</code> and
<code>sized_range</code></del><ins><code><i>sized-random-access-range</i></code></ins> and is
</p>
[&hellip;]
</li>
<li>
<p>(2.3) &mdash; Otherwise, if <code>T</code> is a specialization of <code>subrange</code>
(25.5.4 <a href="https://timsong-cpp.github.io/cppwp/range.subrange">[range.subrange]</a>) that models <del><code>random_access_range</code> and
<code>sized_range</code></del><ins><code><i>sized-random-access-range</i></code></ins>, then
<code>T(ranges::begin(E) + std::min&lt;D&gt;(ranges::distance(E), F), ranges::end(E),
<i>to-unsigned-like</i>(ranges::distance(E) - std::min&lt;D&gt;(ranges::distance(E), F)))</code>,
except that <code>E</code> and <code>F</code> are each evaluated only once.
</p>
</li>
</ol>
</blockquote>

</li>

<li><p>Modify 25.7.12.2 <a href="https://timsong-cpp.github.io/cppwp/range.drop.view">[range.drop.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
  class drop_view : public view_interface&lt;drop_view&lt;V&gt;&gt; {
  public:
    [&hellip;]
    constexpr auto begin()
      requires (!(<i>simple-view</i>&lt;V&gt; &amp;&amp;
                  <del>random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;</del><ins><code><i>sized-random-access-range</i>&lt;const V&gt;</code></ins>));
    constexpr auto begin() const
      requires <del>random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;</del><ins><code><i>sized-random-access-range</i>&lt;const V&gt;</code></ins>;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
[&hellip;]
<pre>
constexpr auto begin()
  requires (!(<i>simple-view</i>&lt;V&gt; &amp;&amp;
              <del>random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;</del><ins><code><i>sized-random-access-range</i>&lt;const V&gt;</code></ins>));
constexpr auto begin() const
  requires <del>random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;</del><ins><code><i>sized-random-access-range</i>&lt;const V&gt;</code></ins>;
</pre>
<blockquote>
<p>
-3- <i>Returns</i>:
<code>ranges::next(ranges::begin(<i>base_</i>), <i>count_</i>, ranges::end(<i>base_</i>))</code>.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 25.7.14.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.iterator">[range.join.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  template&lt;bool Const&gt;
  struct join_view&lt;V&gt;::<i>iterator</i> {
  private:
    [&hellip;]
  public:
    [&hellip;]
    constexpr <i>iterator</i>&amp; operator--()
      requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
               <del>bidirectional_range&lt;range_reference_t&lt;<i>Base</i>&gt;&gt; &amp;&amp;
               common_range&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del><ins><i>common-bidirectional-range</i>&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</ins>;

    constexpr <i>iterator</i> operator--(int)
      requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
               <del>bidirectional_range&lt;range_reference_t&lt;<i>Base</i>&gt;&gt; &amp;&amp;
               common_range&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del><ins><i>common-bidirectional-range</i>&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</ins>;
    [&hellip;]
  };
}
</pre>
<p>
-1- <code><i>iterator</i>::iterator_concept</code> is defined as follows::
</p>
<ol style="list-style-type: none">
<li>
<p>(1.1) &mdash; If <code><i>ref-is-glvalue</i></code> is <code>true</code>, <code><i>Base</i></code> models
  <code>bidirectional_range</code>,
  and <code>range_reference_t&lt;<i>Base</i>&gt;</code> models <del>both <code>bidirectional_range</code>
    and <code>common_range</code></del><ins><code><i>common-bidirectional-range</i></code></ins>, then
  <code>iterator_concept</code> denotes <code>bidirectional_iterator_tag</code>.
</p>
[&hellip;]
</li>
</ol>
[&hellip;]
<pre>
constexpr <i>iterator</i>&amp; operator--()
  requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
           <del>bidirectional_range&lt;range_reference_t&lt;<i>Base</i>&gt;&gt; &amp;&amp;
           common_range&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del><ins><i>common-bidirectional-range</i>&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-16- <i>Effects</i>: Equivalent to:
</p>
[&hellip;]
</blockquote>
<pre>
constexpr <i>iterator</i> operator--(int)
  requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
           <del>bidirectional_range&lt;range_reference_t&lt;<i>Base</i>&gt;&gt; &amp;&amp;
           common_range&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</del><ins><i>common-bidirectional-range</i>&lt;range_reference_t&lt;<i>Base</i>&gt;&gt;</ins>;
</pre>
<blockquote>
<p>
-17- <i>Effects</i>: Equivalent to:
</p>
[&hellip;]
</blockquote>
</blockquote>

</li>

<li><p>Modify 25.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.view">[range.join.with.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  <del>template&lt;class R&gt;
  concept <i>bidirectional-common</i> = bidirectional_range&lt;R&gt; &amp;&amp; common_range&lt;R&gt;;    // <i>exposition only</i></del>
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.7.15.3 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.iterator">[range.join.with.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt; &amp;&amp; <i>concatable</i>&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  template&lt;bool Const&gt;
  class join_with_view&lt;V, Pattern&gt;::<i>iterator</i> {
  private:
    [&hellip;]
  public:
    [&hellip;]
    constexpr <i>iterator</i>&amp; operator--()
      requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
               <del><i>bidirectional-common</i></del><ins><i>common-bidirectional-range</i></ins>&lt;<i>InnerBase</i>&gt; &amp;&amp; <del><i>bidirectional-common</i></del><ins><i>common-bidirectional-range</i></ins>&lt;<i>PatternBase</i>&gt;;
    constexpr <i>iterator</i> operator--(int)
      requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
               <del><i>bidirectional-common</i></del><ins><i>common-bidirectional-range</i></ins>&lt;<i>InnerBase</i>&gt; &amp;&amp; <del><i>bidirectional-common</i></del><ins><i>common-bidirectional-range</i></ins>&lt;<i>PatternBase</i>&gt;;
    [&hellip;]
  };
}
</pre>
<p>
-1- <code><i>iterator</i>::iterator_concept</code> is defined as follows::
</p>
<ol style="list-style-type: none">
<li>
<p>(1.1) &mdash; If <code><i>ref-is-glvalue</i></code> is <code>true</code>, <code><i>Base</i></code> models
<code>bidirectional_range</code>, and <code><i>InnerBase</i></code> and <code><i>PatternBase</i></code>
each model <del><code><i>bidirectional-common</i></code></del><ins><code><i>common-bidirectional-range</i></code></ins>,
then <code>iterator_concept</code> denotes <code>bidirectional_iterator_tag</code>.
</p>
[&hellip;]
</li>
</ol>
[&hellip;]
<pre>
constexpr <i>iterator</i>&amp; operator--()
  requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
           <del><i>bidirectional-common</i></del><ins><i>common-bidirectional-range</i></ins>&lt;<i>InnerBase</i>&gt; &amp;&amp; <del><i>bidirectional-common</i></del><ins><i>common-bidirectional-range</i></ins>&lt;<i>PatternBase</i>&gt;;
</pre>
<blockquote>
<p>
-16- <i>Effects</i>: Equivalent to:
</p>
</blockquote>
[&hellip;]
<pre>
constexpr <i>iterator</i> operator--(int)
  requires <i>ref-is-glvalue</i> &amp;&amp; bidirectional_range&lt;<i>Base</i>&gt; &amp;&amp;
           <del><i>bidirectional-common</i></del><ins><i>common-bidirectional-range</i></ins>&lt;<i>InnerBase</i>&gt; &amp;&amp; <del><i>bidirectional-common</i></del><ins><i>common-bidirectional-range</i></ins>&lt;<i>PatternBase</i>&gt;;
</pre>
<blockquote>
<p>
-17- <i>Effects</i>: Equivalent to:
</p>
[&hellip;]
</blockquote>
</blockquote>

</li>

<li><p>Modify 25.7.20.2 <a href="https://timsong-cpp.github.io/cppwp/range.common.view">[range.common.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;view V&gt;
    requires (!common_range&lt;V&gt; &amp;&amp; copyable&lt;iterator_t&lt;V&gt;&gt;)
  class common_view : public view_interface&lt;common_view&lt;V&gt;&gt; {
  private:
    V <i>base_</i> = V();  // <i>exposition only</i>

  public:
    [&hellip;]
    constexpr auto begin() requires (!<i>simple-view</i>&lt;V&gt;) {
      if constexpr (<del>random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;</del><ins><code><i>sized-random-access-range</i>&lt;V&gt;</code></ins>)
        return ranges::begin(<i>base_</i>);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::begin(<i>base_</i>));
    }

    constexpr auto begin() const requires range&lt;const V&gt; {
      if constexpr (<del>random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;</del><ins><code><i>sized-random-access-range</i>&lt;const V&gt;</code></ins>)
        return ranges::begin(<i>base_</i>);
      else
        return common_iterator&lt;iterator_t&lt;const V&gt;, sentinel_t&lt;const V&gt;&gt;(ranges::begin(<i>base_</i>));
    }

    constexpr auto end() requires (!<i>simple-view</i>&lt;V&gt;) {
      if constexpr (<del>random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;</del><ins><code><i>sized-random-access-range</i>&lt;V&gt;</code></ins>)
        return ranges::begin(<i>base_</i>) + ranges::distance(<i>base_</i>);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::end(<i>base_</i>));
    }

    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (<del>random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;</del><ins><code><i>sized-random-access-range</i>&lt;const V&gt;</code></ins>)
        return ranges::begin(<i>base_</i>) + ranges::distance(<i>base_</i>);
      else
        return common_iterator&lt;iterator_t&lt;const V&gt;, sentinel_t&lt;const V&gt;&gt;(ranges::end(<i>base_</i>));
    }
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.7.25.2 <a href="https://timsong-cpp.github.io/cppwp/range.zip.view">[range.zip.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;class... Rs&gt;
  concept <i>zip-is-common</i> =                             // <i>exposition only</i>
    (sizeof...(Rs) == 1 &amp;&amp; (common_range&lt;Rs&gt; &amp;&amp; ...)) ||
    (!(bidirectional_range&lt;Rs&gt; &amp;&amp; ...) &amp;&amp; (common_range&lt;Rs&gt; &amp;&amp; ...)) ||
    (<del>(random_access_range&lt;Rs&gt; &amp;&amp; ...) &amp;&amp; (sized_range&lt;Rs&gt; &amp;&amp; ...)</del><ins><i>sized-random-access-range</i>&lt;Rs&gt; &amp;&amp; ...</ins>);
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.7.30.2 <a href="https://timsong-cpp.github.io/cppwp/range.slide.view">[range.slide.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;class V&gt;
  concept <i>slide-caches-nothing</i> = <del>random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;</del><ins><i>sized-random-access-range</i>&lt;V&gt;</ins>;       // <i>exposition only</i>
  
  template&lt;class V&gt;
  concept <i>slide-caches-last</i> =                                            // <i>exposition only</i>
    !<i>slide-caches-nothing</i>&lt;V&gt; &amp;&amp; <del>bidirectional_range&lt;V&gt; &amp;&amp; common_range&lt;V&gt;</del><ins><i>common-bidirectional-range</i>&lt;V&gt;</ins>;
  
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.7.33.2 <a href="https://timsong-cpp.github.io/cppwp/range.cartesian.view">[range.cartesian.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  template&lt;bool Const, class First, class... Vs&gt;
  concept <i>cartesian-product-is-random-access</i> =          // <i>exposition only</i>
    (random_access_range&lt;<i>maybe-const</i>&lt;Const, First&gt;&gt; &amp;&amp; ... &amp;&amp;
      <del>(random_access_range&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;
        &amp;&amp; sized_range&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;)</del><ins><i>sized-random-access-range</i>&lt;<i>maybe-const</i>&lt;Const, Vs&gt;&gt;</ins>);

  template&lt;class R&gt;
  concept <i>cartesian-product-common-arg</i> =                // <i>exposition only</i>
    common_range&lt;R&gt; || <del>(sized_range&lt;R&gt; &amp;&amp; random_access_range&lt;R&gt;)</del><ins><i>sized-random-access-range</i>&lt;R&gt;</ins>;
  [&hellip;]
}
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4308"><a href="4308">4308</a>. <code>std::optional&lt;T&amp;&gt;::iterator</code> can't be a contiguous iterator for some <code class='backtick'>T</code></h3>
<p><b>Section:</b> 22.5.4.5 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.iterators">[optional.ref.iterators]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-08-05 <b>Last modified:</b> 2025-08-29</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is related to LWG <a href="4304" title="std::optional&lt;NonReturnable&amp;&gt; is ill-formed due to value_or (Status: New)">4304</a>. When <code class='backtick'>T</code> is function type or an incomplete array type, 
it is impossible to implement all requirements in 22.5.4.5 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.iterators">[optional.ref.iterators]</a>/1.
<p/>
When <code class='backtick'>T</code> is an incomplete object type, we may want to support <code>std::optional&lt;T&amp;&gt;</code> 
as it's sometimes a replacement of <code class='backtick'>T*</code>. Perhaps we can require that the iterator type is always a 
random access iterator, and additional models <code class='backtick'>contiguous_iterator</code> when <code class='backtick'>T</code> is complete.
<p/>
When <code class='backtick'>T</code> is a function type, the possibly intended iterator would be not even an actual iterator. 
But it seems that range-for loop over such an <code>std::optional&lt;T&amp;&gt;</code> can work.
</p>

<p><i>[2025-08-29; Reflector poll]</i></p>

<p>
Set priority to 1 after reflector poll.
</p>
<p>
"How can <code class='backtick'>end()</code> work for a pointer to incomplete type? <code class='backtick'>begin</code>/<code class='backtick'>end</code> should
be constrained on object types, and Mandate complete object types.
The aliases shouldn't be defined for non-object types, but probably harmless."
</p>



<p id="res-4308"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.4.5 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.iterators">[optional.ref.iterators]</a> as indicated:</p>

<blockquote>
<pre>
using iterator = <i>implementation-defined</i>; 
</pre>
<blockquote>
<p>
-1- <del>T</del><ins>If <code class='backtick'>T</code> is an object type, t</ins>his type models <del><code class='backtick'>contiguous_iterator</code> 
(24.3.4.14 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.contiguous">[iterator.concept.contiguous]</a>)</del><ins><code class='backtick'>random_access_iterator</code> 
(24.3.4.13 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.random.access">[iterator.concept.random.access]</a>)</ins>, meets the 
<i>Cpp17RandomAccessIterator</i> requirements (24.3.5.7 <a href="https://timsong-cpp.github.io/cppwp/random.access.iterators">[random.access.iterators]</a>), and meets 
the requirements for constexpr iterators (24.3.1 <a href="https://timsong-cpp.github.io/cppwp/iterator.requirements.general">[iterator.requirements.general]</a>), with value 
type <code>remove_cv_t&lt;T&gt;</code>. The reference type is <code>T&amp;</code> for <code class='backtick'>iterator</code>.
<ins>When <code class='backtick'>T</code> is a complete object type, iterator additionally models <code class='backtick'>contiguous_iterator</code> 
(24.3.4.14 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.contiguous">[iterator.concept.contiguous]</a>).</ins><br/> 
<del>-2-</del> All requirements on container iterators (23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a>) apply to 
<code class='backtick'>optional::iterator</code>.
<p/>
<ins>-?-  If <code class='backtick'>T</code> is a function type, <code class='backtick'>iterator</code> supports all operators required by the 
<code class='backtick'>random_access_iterator</code> concept (24.3.4.13 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.random.access">[iterator.concept.random.access]</a>) along with the 
<code>&lt;=&gt;</code> operator as specified for container iterators (23.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/container.reqmts">[container.reqmts]</a>). 
<code class='backtick'>iterator</code> dereferences to a <code class='backtick'>T</code> lvalue. These operators behave as if <code class='backtick'>iterator</code> were an actual 
iterator iterating over a range of <code class='backtick'>T</code>, and result in constant subexpressions whenever the behavior 
is well-defined. [<i>Note ?</i>: Such an <code class='backtick'>optional::iterator</code> does not need to declare any member 
type because it is not an actual iterator type. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4309"><a href="4309">4309</a>. How are two <code class='backtick'>seq_cst</code> operations ordered in the single total order if these two operations are unsequenced?</h3>
<p><b>Section:</b> 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2025-08-06 <b>Last modified:</b> 2025-08-09</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider this snippet code:
</p>
<blockquote><pre>
std::atomic&lt;int&gt; flag = {0};
std::atomic&lt;int&gt; turn = {0};

if(flag + turn){}
</pre></blockquote>
<p>
The loads of <code class='backtick'>flag</code> and <code class='backtick'>turn</code> as the operands of <code class='backtick'>+</code> are unsequenced according to [intro.execution] p10.
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.
</p>
</blockquote>
<p>
However, 32.5.4 <a href="https://timsong-cpp.github.io/cppwp/atomics.order">[atomics.order]</a> p4 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
There is a single total order <i>S</i> on all <code class='backtick'>memory_order::seq_cst</code> operations, including fences, 
that satisfies the following constraints.
</p></blockquote>
<p>
Then, it says that:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
First, if <i>A</i> and <i>B</i> are <code class='backtick'>memory_order::seq_cst</code> operations and <i>A</i> strongly happens 
before <i>B</i>, then <i>A</i> precedes <i>B</i> in <i>S</i>.
</p></blockquote>
<p>
According to the first sentence, the load of <code class='backtick'>flag</code> and the load of <code class='backtick'>turn</code> do have an order in the single 
total order <i>S</i> since they are both <code class='backtick'>memory_order::seq_cst</code> operations. However, since they are unsequenced, 
the second sentence does not apply to them. So, what's the order of them in <i>S</i>? Is the order of them in 
<i>S</i> unspecified?
<p/>
<b>Suggested Resolution:</b>
<p/>
We may want to say the order of such operations is indeterminate in the single total order. That is,  
either <i>A</i> precedes <i>B</i> or <i>B</i> precedes <i>A</i>, but it is unspecified which.
</p>


<p id="res-4309"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4310"><a href="4310">4310</a>. Is "the completion of the invocation of the constructor" considered as an expression?</h3>
<p><b>Section:</b> 32.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.constr">[thread.thread.constr]</a>, 32.4.3.6 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.member">[thread.thread.member]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2025-08-06 <b>Last modified:</b> 2025-08-09</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.thread.constr">active issues</a> in [thread.thread.constr].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
32.4.3.3 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.constr">[thread.thread.constr]</a> p6 says
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
The completion of the invocation of the constructor synchronizes with the beginning of the invocation of the copy of <code class='backtick'>f</code>.
</p>
</blockquote>
<p>
The intended meaning is that "The completion of the invocation of the constructor" happens-before 
"the beginning of the invocation of the copy of <code class='backtick'>f</code>.", so we can infer other happen-before relationships 
based on this point. 
<p/>
However, according to the definition of "happens-before" (6.10.2.2 <a href="https://timsong-cpp.github.io/cppwp/intro.races">[intro.races]</a> p7),
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
An evaluation <i>A</i> <i>happens before</i> an evaluation <i>B</i> (or, equivalently, <i>B</i> 
happens after <i>A</i>) if either
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; [&hellip;]</p></li>
<li><p>(7.2) &mdash; <i>A</i> synchronizes with <i>B</i>, or</p></li>
</ol>
</blockquote>
<p>
That means <i>A</i> and <i>B</i> are first required to be expressions because the evaluation is 
in terms of expressions. 
<p/>
However, "The completion of the invocation of the constructor" and "the beginning of the invocation 
of the copy of <code class='backtick'>f</code>" are not expressions. 
<p/>
The similar issue is 32.4.3.6 <a href="https://timsong-cpp.github.io/cppwp/thread.thread.member">[thread.thread.member]</a> p4
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
The completion of the thread represented by <code class='backtick'>*this</code> synchronizes with (6.10.2 <a href="https://timsong-cpp.github.io/cppwp/intro.multithread">[intro.multithread]</a>) 
the corresponding successful <code class='backtick'>join()</code> return.
</p></blockquote>


<p id="res-4310"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4311"><a href="4311">4311</a>. Can <code class='backtick'>std::pmr::polymorphic_allocator::construct</code> just call <code class='backtick'>std::uninitialized_construct_using_allocator</code>?</h3>
<p><b>Section:</b> 20.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-08-06 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#mem.poly.allocator.mem">issues</a> in [mem.poly.allocator.mem].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is closely related to LWG <a href="3901" title="Is uses-allocator construction of a cv-qualified object type still well-formed after LWG 3870? (Status: NAD)">3901</a> but only affects arguably pathological cases.
<p/>
Uses-allocator construction for <i>cv</i>-qualified types needs to be well-formed, but it's 
questionable to require <code class='backtick'>polymorphic_allocator::construct</code> to support constructing objects via 
pointer to a <i>cv</i>-qualified type. LWG <a href="3870" title="Remove voidify (Status: C++23)">3870</a> banned such placement construction 
for <code class='backtick'>std::construct_at</code>, which is depended by <code class='backtick'>uninitialized_construct_using_allocator</code>.
<p/>
As a result, it seems non-conforming to just use <code class='backtick'>uninitialized_construct_using_allocator</code> in 
<code class='backtick'>polymorphic_allocator::construct</code> since C++20, because the latter is still required to handle 
<i>cv</i>-qualified target types. If the status quo is considered unintended and needed to be fixed, 
perhaps we can just respecify <code class='backtick'>polymorphic_allocator::construct</code> to use 
<code class='backtick'>uninitialized_construct_using_allocator</code>.
</p>


<p id="res-4311"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The <i>Mandates</i>: element allows implementations not to add constraints even if 
<code class='backtick'>uninitialized_construct_using_allocator</code> is constrained in the future. The <i>Throws</i>: element is made 
redundant by "<i>Effects</i>: Equivalent to", and it's already wrong because the exception can be thrown 
by a conversion function.]
</p>
</blockquote>

<ol>

<li><p>Modify 20.5.3.3 <a href="https://timsong-cpp.github.io/cppwp/mem.poly.allocator.mem">[mem.poly.allocator.mem]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-14- <i>Mandates</i>: <del>Uses-allocator construction of <code class='backtick'>T</code> with allocator <code class='backtick'>*this</code> (see 
20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>) and constructor arguments 
<code>std::forward&lt;Args&gt;(args)...</code></del><ins><code>uninitialized_construct_using_allocator(p, 
*this, std::forward&lt;Args&gt;(args)...)</code></ins> is well-formed.
<p/>
-15- <i>Effects</i>: <del>Constructs a <code class='backtick'>T</code> object in the storage whose address is represented by 
<code class='backtick'>p</code> by uses-allocator construction with allocator <code class='backtick'>*this</code> and constructor arguments 
<code>std::forward&lt;Args&gt;(args)...</code>.</del><ins>Equivalent to:</ins>
</p>
<blockquote><pre> 
<ins>uninitialized_construct_using_allocator(p, *this, std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<del>-16- <i>Throws</i>: Nothing unless the constructor for <code class='backtick'>T</code> throws.</del>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4312"><a href="4312">4312</a>. Const and value category mismatch for <code class='backtick'>allocator_arg_t</code>/<code class='backtick'>allocator_arg</code> in the description 
of uses-allocator construction</h3>
<p><b>Section:</b> 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-08-06 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.uses.construction">active issues</a> in [allocator.uses.construction].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.uses.construction">issues</a> in [allocator.uses.construction].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> bullet 2.2 states:
</p>
<blockquote><p>
Otherwise, if <code class='backtick'>T</code> has a constructor invocable as <code class='backtick'>T(allocator_arg, alloc, args...)</code> (leading-allocator convention), 
[&hellip;]
</p></blockquote>
<p>
However, when forming construction arguments in the utility functions, we're actually using <i>cv</i>-unqualified 
rvalue of <code class='backtick'>allocator_arg_t</code>, which can be inferred from using plain <code class='backtick'>allocator_arg_t</code> but not 
<code>const allocator_arg_t&amp;</code> in 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> bullet 5.2.
<p/>
It seems that such mismatch was present even since C++11 (per <a href="https://wg21.link/N3337" title=" Working Draft, Standard for Programming Language C++">N3337</a> [allocator.uses.construction]/1.2). 
If the use of plain <code class='backtick'>allocator_arg_t</code> is considered correct, I think we should fix the description.
</p>


<p id="res-4312"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a> as indicated:</p>

<blockquote>
<p>
-2- The following utility functions support three conventions for passing <code class='backtick'>alloc</code> to a constructor:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code class='backtick'>T</code> has a constructor invocable as 
<code>T(<del>allocator_arg</del><ins>allocator_arg_t{}</ins>, alloc, args...)</code> 
(leading-allocator convention), then uses-allocator construction chooses this constructor form.</p></li>
<li><p>(2.3) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4313"><a href="4313">4313</a>. Uses-allocator construction of <code class='backtick'>pair</code> in <code class='backtick'>tuple</code>'s <code class='backtick'>allocator_arg_t</code> constructors</h3>
<p><b>Section:</b> 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-08-07 <b>Last modified:</b> 2025-08-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Before <a href="https://wg21.link/P0591R4" title=" Utility functions to implement uses-allocator construction">P0591R4</a>, only <code class='backtick'>scoped_allocator_adaptor::construct</code> and 
<code class='backtick'>polymorphic_allocator::construct</code> specially handled <code class='backtick'>pair</code> for the purpose of uses-allocator 
construction. The primary definition of uses-allocator construction (in e.g., 
<a href="https://wg21.link/N4659" title=" Working Draft, Standard for Programming Language C++ Note:">N4659</a> [allocator.uses.construction]) did not specially handle <code class='backtick'>pair</code>. 
The <code class='backtick'>allocator_arg_t</code> constructors of <code class='backtick'>tuple</code>, which were specified to construct <code class='backtick'>tuple</code> 
elements with uses-allocator constructor (per e.g., <a href="https://wg21.link/N4659" title=" Working Draft, Standard for Programming Language C++ Note:">N4659</a> [tuple.cnstr] p26), 
did not specially handle <code class='backtick'>pair</code> either.
<p/>
<a href="https://wg21.link/P0591R4" title=" Utility functions to implement uses-allocator construction">P0591R4</a> redefined uses-allocator construction in terms of <code class='backtick'>make_obj_using_allocator</code> 
in [allocator.uses.construction] p1 as:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
When applied to the construction of an object of type <code class='backtick'>T</code>, it is equivalent to initializing it 
with the value of the expression <code>make_obj_using_allocator&lt;T&gt;(alloc, args...)</code>, described below.
</p>
</blockquote>
<p>
And the new definition does handle <code class='backtick'>pair</code>. As the specification of <code class='backtick'>allocator_arg_t</code> constructors of 
<code class='backtick'>tuple</code> (now in 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> p33) still refer to uses-allocator construction as-is, 
these constructors should construct a <code class='backtick'>pair</code> element in a way equivalent to <code class='backtick'>make_obj_using_allocator</code> now.
<p/>
The following example shows the behavioral difference.
</p>
<blockquote><pre>
#include &lt;cstddef&gt;
#include &lt;utility&gt;
#include &lt;tuple&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;

template&lt;class T&gt;
class payload_ator {
  int payload{};
   
public:
  using value_type = T;

  payload_ator() = default;

  constexpr explicit payload_ator(int n) noexcept : payload{n} {}

  template&lt;class U&gt;
  constexpr explicit payload_ator(payload_ator&lt;U&gt; a) noexcept : payload{a.payload} {}  

  friend bool operator==(payload_ator, payload_ator) = default;

  template&lt;class U&gt;
  friend constexpr bool operator==(payload_ator x, payload_ator&lt;U&gt; y) noexcept {
    return x.payload == y.payload;
  }  

  constexpr T* allocate(std::size_t n) { return std::allocator&lt;T&gt;{}.allocate(n); }

  constexpr void deallocate(T* p, std::size_t n) { return std::allocator&lt;T&gt;{}.deallocate(p, n); }  

  constexpr int get_payload() const noexcept { return payload; }
};

bool test() {
  constexpr int in_v = 42;
  using my_pair_t = std::pair&lt;int, std::vector&lt;int, payload_ator&lt;int&gt;&gt;&gt;;
  std::tuple&lt;my_pair_t&gt; t(std::allocator_arg, payload_ator&lt;int&gt;{in_v});
  auto out_v = std::get&lt;0&gt;(t).second.get_allocator().get_payload();
  return in_v == out_v;
}

int main() {
  assert(test()); // <span style="color:#C80000;font-weight:bold">passes only if allocator_arg_t constructors of tuple specially handle pair</span>
}
</pre></blockquote>
<p>
However, the behavioral changes of these constructors were not discussed in <a href="https://wg21.link/P0591R4" title=" Utility functions to implement uses-allocator construction">P0591R4</a>, 
and existing implementations that claim full implementation of <a href="https://wg21.link/P0591R4" title=" Utility functions to implement uses-allocator construction">P0591R4</a> (MSVC STL and libstdc++) 
did not change these constructors (<a href="https://godbolt.org/z/6vnP78nqW">demo</a>).
<p/>
Given that implementations did not recognize changes of <code class='backtick'>allocator_arg_t</code> constructors as part of the paper, 
and special handling of <code class='backtick'>pair</code> would significantly complicate these constructors, perhaps we should 
explicitly specify that these constructors behave as if special handling for <code class='backtick'>pair</code> were missing.
</p>

<p><i>[2025-08-17; Pablo comments]</i></p>

<p>
I don't agree with it or the PR. It seems like the implementations are simply lagging behind. 
Since <code class='backtick'>make_obj_using_allocator</code> is in the standard, <code class='backtick'>tuple</code> is easy enough to implement simply 
by delegating to that function. I regard the failure to handle <code class='backtick'>pair</code> in a general way to be a 
defect in the C++11 specification and that handling it correctly, though technically a change 
of behavior, is more likely to fix bugs than to create them. It is exactly this scattershot 
restatement of uses-allocator construction for <code class='backtick'>pair</code> that I hoped to fix with P0591, even 
though I missed <code class='backtick'>tuple</code> in my exposition.
</p>


<p id="res-4313"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/tuple.cnstr">[tuple.cnstr]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Alloc&gt;
  constexpr explicit(see below )
    tuple(allocator_arg_t, const Alloc&amp; a);
[&hellip;]
template&lt;class Alloc, class U1, class U2&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, pair&lt;U1, U2&gt;&amp;);
template&lt;class Alloc, class U1, class U2&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, const pair&lt;U1, U2&gt;&amp;);
template&lt;class Alloc, class U1, class U2&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, pair&lt;U1, U2&gt;&amp;&amp;);
template&lt;class Alloc, class U1, class U2&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, const pair&lt;U1, U2&gt;&amp;&amp;);
template&lt;class Alloc, tuple-like UTuple&gt;
  constexpr explicit(<i>see below</i>)
  tuple(allocator_arg_t, const Alloc&amp; a, UTuple&amp;&amp;);
</pre>
<blockquote>
<p>
-32- <i>Preconditions</i>: <code class='backtick'>Alloc</code> meets the <i>Cpp17Allocator</i> requirements 
(16.4.4.6.1 <a href="https://timsong-cpp.github.io/cppwp/allocator.requirements.general">[allocator.requirements.general]</a>).
<p/>
-33- <i>Effects</i>: Equivalent to the preceding constructors except that each element is constructed 
with uses-allocator construction (20.2.8.2 <a href="https://timsong-cpp.github.io/cppwp/allocator.uses.construction">[allocator.uses.construction]</a>)<ins>, except that the 
construction behaves as if there were only one <code class='backtick'>uses_allocator_construction_args</code> overload and the 
overload behaved the same as the first actual overload without <i>Constraints</i></ins>.
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4314"><a href="4314">4314</a>. Missing move in <code class='backtick'>mdspan</code> layout <code class='backtick'>mapping::operator()</code></h3>
<p><b>Section:</b> 23.7.3.4 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout">[mdspan.layout]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Luc Grosheintz <b>Opened:</b> 2025-08-13 <b>Last modified:</b> 2025-08-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#mdspan.layout">active issues</a> in [mdspan.layout].</p>
<p><b>View all other</b> <a href="lwg-index.html#mdspan.layout">issues</a> in [mdspan.layout].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Numerous template classes in <code>&lt;mdspan&gt;</code> have template parameter <code class='backtick'>IndexType</code>.
While this template parameter is restricted to be a signed or unsigned integer, 
these classes often accept user-defined classes that convert to <code class='backtick'>IndexType</code>.
<p/>
They're either passed as an array/span of <code class='backtick'>OtherIndexType</code>; or as a template parameter pack. 
When passed as a template parameter pack, the common pattern is
</p>
<blockquote><pre>
template&lt;class... OtherIndexTypes&gt;
  requires std::is_convertible_v&lt;OtherIndexTypes, IndexType> &amp;&amp; ...
  void <i>dummy</i>(OtherIndexTypes... indices)
  {
    <i>something</i>(static_cast&lt;IndexType&gt;(std::move(indices))...);
  }
</pre></blockquote>
<p>
This pattern allows passing in objects that convert to IndexType only as
an rvalue reference, e.g.
</p>
<blockquote><pre>
class RValueInt
{
  constexpr
  operator int() &amp;&amp; noexcept
  { return m_int; }

private:
  int m_int;
};
</pre></blockquote>
<p>
This pattern can be found in:
</p>
<ul>
<li><p>a ctor of <code class='backtick'>extents</code>,</p></li>
<li><p>a ctor of <code class='backtick'>mdspan</code>,</p></li>
<li><p><code class='backtick'>mdspan::operator[]</code>.</p></li>
</ul>
<p>
The five standardized layout mappings use a different pattern in their
operator(), namely,
</p>
<blockquote><pre>
static_cast&lt;IndexType&gt;(indices)...
</pre></blockquote>
<p>
This prevents the passing in objects of type <code class='backtick'>RValueInt</code>, because the
conversion isn't happening from an rvalue reference. This is addressed by
Items 1 - 5 in the Proposed Resolution.
<p/>
A different pattern can be found a ctor for <code class='backtick'>layout_{left,right}_padded</code>.
Namely, directly passing an object of type <code class='backtick'>OtherIndexType</code> to
<code><i>LEAST-MULTIPLE-AT-LEAST</i></code>. This is addressed in Items 6 and 7 
in the Proposed Resolution.
<p/>
This inconsistency was noticed while fixing 
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=121061">PR121061</a> 
and these changes have been applied to all layout mappings implemented in libstdc++.
</p>


<p id="res-4314"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.7.3.4.5.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.left.obs">[mdspan.layout.left.obs]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... Indices&gt;
  constexpr index_type operator()(Indices... i) const noexcept;
</pre>
<blockquote>
<p>
-2- <i>Constraints</i>: [&hellip;]
<p/>
-3- <i>Preconditions</i>: [&hellip;]
<p/>
-4- <i>Effects</i>: Let <code class='backtick'>P</code> be a parameter pack such that
</p>
<blockquote><pre>
is_same_v&lt;index_sequence_for&lt;Indices...&gt;, index_sequence&lt;P...&gt;&gt;
</pre></blockquote>
<p>
is <code class='backtick'>true</code>. Equivalent to:
</p>
<blockquote><pre>
return ((static_cast&lt;index_type&gt;(<ins>std::move(</ins>i<ins>)</ins>) * stride(P)) + ... + 0);
</pre></blockquote>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.6.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.right.obs">[mdspan.layout.right.obs]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... Indices&gt;
  constexpr index_type operator()(Indices... i) const noexcept;
</pre>
<blockquote>
<p>
-2- <i>Constraints</i>: [&hellip;]
<p/>
-3- <i>Preconditions</i>: [&hellip;]
<p/>
-4- <i>Effects</i>: Let <code class='backtick'>P</code> be a parameter pack such that
</p>
<blockquote><pre>
is_same_v&lt;index_sequence_for&lt;Indices...&gt;, index_sequence&lt;P...&gt;&gt;
</pre></blockquote>
<p>
is <code class='backtick'>true</code>. Equivalent to:
</p>
<blockquote><pre>
return ((static_cast&lt;index_type&gt;(<ins>std::move(</ins>i<ins>)</ins>) * stride(P)) + ... + 0);
</pre></blockquote>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.7.4 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.stride.obs">[mdspan.layout.stride.obs]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... Indices&gt;
  constexpr index_type operator()(Indices... i) const noexcept;
</pre>
<blockquote>
<p>
-2- <i>Constraints</i>: [&hellip;]
<p/>
-3- <i>Preconditions</i>: [&hellip;]
<p/>
-4- <i>Effects</i>: Let <code class='backtick'>P</code> be a parameter pack such that
</p>
<blockquote><pre>
is_same_v&lt;index_sequence_for&lt;Indices...&gt;, index_sequence&lt;P...&gt;&gt;
</pre></blockquote>
<p>
is <code class='backtick'>true</code>. Equivalent to:
</p>
<blockquote><pre>
return ((static_cast&lt;index_type&gt;(<ins>std::move(</ins>i<ins>)</ins>) * stride(P)) + ... + 0);
</pre></blockquote>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.8.4 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.obs">[mdspan.layout.leftpad.obs]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... Indices&gt;
  constexpr index_type operator()(Indices... idxs) const noexcept;
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: [&hellip;]
<p/>
-4- <i>Preconditions</i>: [&hellip;]
<p/>
-5- <i>Returns</i>: <code>((static_cast&lt;index_type&gt;(<ins>std::move(</ins>idxs<ins>)</ins>) * stride(P_rank)) + ... + 0)</code>.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.9.4 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.obs">[mdspan.layout.rightpad.obs]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... Indices&gt;
  constexpr index_type operator()(Indices... idxs) const noexcept;
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: [&hellip;]
<p/>
-4- <i>Preconditions</i>: [&hellip;]
<p/>
-5- <i>Returns</i>: <code>((static_cast&lt;index_type&gt;(<ins>std::move(</ins>idxs<ins>)</ins>) * stride(P_rank)) + ... + 0)</code>.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.8.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.cons">[mdspan.layout.leftpad.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherIndexType&gt;
constexpr mapping(const extents_type&amp; ext, OtherIndexType pad<ins>ding</ins>);
</pre>
<blockquote>
<p>
<ins><ins>Let <code>pad = static_cast&lt;index_type&gt;(std::move(padding))</code>.</ins></ins>
<p/>
-3- <i>Constraints</i>: [&hellip;]
<p/>
-4- <i>Preconditions</i>: 
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <code>pad<ins>ding</ins></code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(4.2) &mdash; <del><code>extents_type::<i>index-cast</i>(pad)</code></del><ins>pad</ins> is greater than zero.</p></li>
<li><p>(4.3) &mdash; If <code><i>rank_</i></code> is greater than one, then 
<code><i>LEAST-MULTIPLE-AT-LEAST</i>(pad, ext.extent(0))</code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(4.4) &mdash; If <code><i>rank_</i></code> is greater than one, then the product of 
<code><i>LEAST-MULTIPLE-AT-LEAST</i>(pad, ext.extent(0))</code> and all values <code>ext.extent(<i>k</i>)</code> with 
<code><i>k</i></code> in the range of <code>[1, <i>rank_</i>)</code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(4.5) &mdash; If <code class='backtick'>padding_value</code> is not equal to <code class='backtick'>dynamic_extent</code>, <code class='backtick'>padding_value</code> equals 
<code><del>extents_type::<i>index-cast</i>(pad)</del><ins>pad</ins></code>.</p></li>
</ol>
<p>
-5- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.9.3 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.cons">[mdspan.layout.rightpad.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class OtherIndexType&gt;
constexpr mapping(const extents_type&amp; ext, OtherIndexType pad<ins>ding</ins>);
</pre>
<blockquote>
<p>
<ins><ins>Let <code>pad = static_cast&lt;index_type&gt;(std::move(padding))</code>.</ins></ins>
<p/>
-3- <i>Constraints</i>: [&hellip;]
<p/>
-4- <i>Preconditions</i>: 
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <code>pad<ins>ding</ins></code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(4.2) &mdash; <del><code>extents_type::<i>index-cast</i>(pad)</code></del><ins>pad</ins> is greater than zero.</p></li>
<li><p>(4.3) &mdash; If <code><i>rank_</i></code> is greater than one, then 
<code><i>LEAST-MULTIPLE-AT-LEAST</i>(pad, ext.extent(<i>rank_</i> - 1))</code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(4.4) &mdash; If <code><i>rank_</i></code> is greater than one, then the product of 
<code><i>LEAST-MULTIPLE-AT-LEAST</i>(pad, ext.extent(<i>rank_</i> - 1))</code> and all values <code>ext.extent(<i>k</i>)</code> with 
<code><i>k</i></code> in the range of <code>[1, <i>rank_</i> - 1)</code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(4.5) &mdash; If <code class='backtick'>padding_value</code> is not equal to <code class='backtick'>dynamic_extent</code>, <code class='backtick'>padding_value</code> equals 
<code><del>extents_type::<i>index-cast</i>(pad)</del><ins>pad</ins></code>.</p></li>
</ol>
<p>
-5- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4316"><a href="4316">4316</a>. <code>{can_}substitute</code> specification is ill-formed</h3>
<p><b>Section:</b> 21.4.13 <a href="https://timsong-cpp.github.io/cppwp/meta.reflection.substitute">[meta.reflection.substitute]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matthias Wippich <b>Opened:</b> 2025-08-15 <b>Last modified:</b> 2025-08-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>can_substitute</code> and <code class='backtick'>substitute</code> are currently specified in terms of splices in a template argument list:
<p/>
21.4.13 <a href="https://timsong-cpp.github.io/cppwp/meta.reflection.substitute">[meta.reflection.substitute]</a> p3:
</p>
<blockquote><p>
<i>Returns</i>: <code class='backtick'>true</code> if <code>Z&lt;[:Args:]...&gt;</code> is a valid <i>template-id</i> (13.3 <a href="https://timsong-cpp.github.io/cppwp/temp.names">[temp.names]</a>) 
that does not name a function whose type contains an undeduced placeholder type. Otherwise, <code class='backtick'>false</code>.
</p></blockquote>
<p>
21.4.13 <a href="https://timsong-cpp.github.io/cppwp/meta.reflection.substitute">[meta.reflection.substitute]</a> p7:
</p>
<blockquote><p>
<i>Returns</i>: <code>^^Z&lt;[:Args:]...&gt;</code>.
</p></blockquote>
<p>
This wording was introduced in <a href="https://wg21.link/P2996R11" title=" Reflection for C++26">P2996R11</a>. However, merging in changes from 
<a href="https://wg21.link/P3687" title=" Final Adjustments to C++26 Reflection">P3687</a> "Final Adjustments to C++26 Reflection" in <a href="https://wg21.link/P2996R13" title=" Reflection for C++26">P2996R13</a> changed 
the rules for splices in this context. This makes <code class='backtick'>can_substitute</code> and <code class='backtick'>substitute</code> as specified 
currently ill-formed. We cannot use the given syntax to splice an arbitrary choice of values, 
types and templates anymore.
<p/>
While the intent seems clear, this should be rephrased to be more technically correct.
</p>


<p id="res-4316"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4317"><a href="4317">4317</a>. The meaning of "resource" in the <i>Cpp17Destructible</i> requirements is undefined</h3>
<p><b>Section:</b> 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-08-15 <b>Last modified:</b> 2025-08-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The meaning of "resource" in the <i>Cpp17Destructible</i> requirements cannot be inferred 
from the standard wording and it seems unlikely that the standard will determine its meaning 
in the future. What are considered as resources generally depends on users' intent, so the 
standard shouldn't determine the well-definedness of a program execution due to it. Moreover, 
the wording doesn't seem to consider shared ownership, which can be represented by <code class='backtick'>shared_ptr</code>.
</p>


<p id="res-4317"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 16.4.4.2 <a href="https://timsong-cpp.github.io/cppwp/utility.arg.requirements">[utility.arg.requirements]</a>, Table 35 [tab:cpp17.destructible] as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 35 &mdash; <code>Cpp17Destructible</code> requirements [tab:cpp17.destructible]</caption>
<tr>
<th>Expression</th>
<th>Post-condition</th>
</tr>
<tr>
<td>
<code>u.~T()</code>
</td>
<td>
<del>All resources owned by <code class='backtick'>u</code> are reclaimed, n</del><ins>N</ins>o exception is propagated.
</td>
</tr>
<tr>
<td colspan="2">
[<i>Note 3:</i> Array types and non-object types are not <i>Cpp17Destructible</i>. &mdash; <i>end note</i>]
</td>
</tr>
</table>

</blockquote>

</li>

</ol>





<hr>
<h3 id="4319"><a href="4319">4319</a>. Supporting copy-elision in function wrappers</h3>
<p><b>Section:</b> 22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kamiski <b>Opened:</b> 2025-08-19 <b>Last modified:</b> 2025-08-23</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.require">active issues</a> in [func.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.require">issues</a> in [func.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording for argument forwarding call wrappers in 22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a> p3,
</p>
<blockquote><p>
This forwarding step delivers rvalue arguments as rvalue references and lvalue arguments 
as lvalue references.
</p></blockquote>
<p>
requires that each wrapper binds a temporary to rvalue reference
(materializing it), and then pass that xvalue. This essentially
codifies an implementation where wrappers provide an <code class='backtick'>operator()</code> that
accepts <code>Args&amp;&amp;...</code>. This is fine for most of the wrappers.
<p/>
For some wrappers more efficient implementation strategies are possible:
</p>
<ul>
<li><p><code class='backtick'>bind_front(f)/bind_back(f)</code> without bound args could return a copy of <code class='backtick'>f</code></p></li>
<li><p><code>bind_front&lt;f&gt;()/bind_back&lt;f&gt;()</code> could produce a 
<code>__function_wrapper&lt;f&gt;</code>, that for function pointers can be invoked using 
a surrogate function call.</p></li>
</ul>
<p>
However, such implementation strategies are currently disallowed per
22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a> p3, as invoking the function wrapper with 
a prvalue <code class='backtick'>bind_front(f)(T())</code> requires a temporary to be materialized, 
and then moved into the parameter of <code class='backtick'>f</code>. For example:
</p>
<blockquote><pre>
struct M 
{
  M() { std::cout &lt;&lt; "Default" &lt; std::endl; }
  M(M&amp;&amp; m) { std::cout &lt;&lt; "Move" &lt; std::endl; }
};

struct F
{ 
  void operator()(M m) {} 
} f;
</pre></blockquote>
<p>
The call <code class='backtick'>f(M{})</code> will print only "<code class='backtick'>Default</code>" but <code class='backtick'>bind_front(f)(M{})</code> is
required to produce "<code class='backtick'>Default</code>" and "<code class='backtick'>Move</code>". We should allow
implementations to elide the move operations, but not require it.
</p>
<p>
The suggested changes by this issue have been 
<a href="https://gcc.gnu.org/pipermail/libstdc++/2025-August/062992.html">implemented in libstdc++</a>
for <code class='backtick'>bind_front/bind_back</code>.
</p>


<p id="res-4319"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.10.4 <a href="https://timsong-cpp.github.io/cppwp/func.require">[func.require]</a> as indicated:</p>

<blockquote>
<p>
-3- Every call wrapper (22.10.3 <a href="https://timsong-cpp.github.io/cppwp/func.def">[func.def]</a>) meets the <i>Cpp17MoveConstructible</i> and 
<i>Cpp17Destructible</i> requirements. An <i>argument forwarding call wrapper</i> is a call wrapper 
that can be called with an arbitrary argument list and delivers the arguments to the target object 
<del>as references</del>. This forwarding step delivers <del>rvalue arguments as rvalue references 
and lvalue arguments as lvalue references.</del><ins>:</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(3.?) &mdash; lvalue arguments as lvalues,</ins></p></li>
<li><p><ins>(3.?) &mdash; xvalue arguments as xvalues,</ins></p></li>
<li><p><ins>(3.?) &mdash; prvalue arguments as either prvalues or xvalues.</ins></p></li>
</ol>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4320"><a href="4320">4320</a>. <code class='backtick'>hive</code> operations involving insertion/erasure should have <code>&#x1d4aa;(log n)</code> time complexity</h3>
<p><b>Section:</b> 23.3.9 <a href="https://timsong-cpp.github.io/cppwp/hive">[hive]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Bentley <b>Opened:</b> 2025-08-19 <b>Last modified:</b> 2025-09-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Under 23.3.9.4 <a href="https://timsong-cpp.github.io/cppwp/hive.modifiers">[hive.modifiers]</a> p4 complexity is stated as "Constant.
Exactly one object of type <code class='backtick'>T</code> is constructed."
<p/>
However the approach to implementation necessary to support 8/16-bit
types without artificially widening the type storage, as described under
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0447r28.html#non_reference_implementations_info">
"Additional info for supporting small types" in P0447</a> basically specifies 
time complexity which is <code class='backtick'>Log(n)</code> (on most platforms, log64 or log32) in the 
capacity of the element block selected to insert into. This time complexity only occurs 
during the operation to find an erased element memory location within a block 
which is known to have one, and does not involve the elements themselves.
<p/>
This is both the simplest and fastest solution to supporting small types
in hive without artificial widening that I have come across.
<p/>
Further, I have discovered that this approach can be extended to larger
block capacities via 
<a href="https://plflib.org/matt_bentley_-_bitset_stacking.pdf">"bitset stacking"</a>
while retaining <code>&#x1d4aa;(log n)</code> intra-block lookup time complexity, 
regardless of block capacity. Overall this approach would be useful for embedded 
and other memory-scarse platforms as it reduces the 16-bit-per-element cost of the
reference implementation down to a 1-bit-per-element cost. For 64-bit and larger types, 
there are other ways to obtain this reduction without
losing <code>&#x1d4aa;(1)</code> lookup but it is unclear whether those methods would 
in fact be faster. For approaches involving bitset-stacking, the logarithmic 
complexity also occurs during erasure, specifically adding a couple of extra 
instructions for every 64x (i.e. bit-depth) increase in block capacity. But again 
this does not involve the elements and is logarithmic in the capacity of the block 
erased from.
<p/>
Regardless, the increased complexity during insertion is necessary for small-type support.
<p/>
There was ambiguity as to whether this should result in a change to <code>hive</code> 
time complexity when discussed on the reflector, as it is unrelated to element numbers (unless 
all elements fit within one block), but it is related to block capacities, which are defined 
as part of the <code class='backtick'>hive</code> technical specification.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> I am unclear on whether <code class='backtick'>assign()</code> and <code class='backtick'>assign_range()</code> operations 
would require specification since they also have the capability to reuse existing erased 
element memory spaces, but we do not currently supply time complexity wording for these 
in the standard in general and I'm unsure why that is.]
</p>
</blockquote>

<ol>

<li><p>Modify 23.3.9.1 <a href="https://timsong-cpp.github.io/cppwp/hive.overview">[hive.overview]</a> as indicated:</p>

<blockquote>
<p>
-1- A <code class='backtick'>hive</code> is a type of sequence container <del>that provides constant-time insertion and erasure 
operations. S</del><ins>where s</ins>torage is automatically managed in multiple memory blocks, referred 
to as element blocks. Insertion position is determined by the container, and <del>insertion</del> 
may re-use the memory locations of erased elements. <ins>Insertions are either constant time
or logarithmic in the capacity of the element block inserted into.</ins>
<p/>
-2- [&hellip;]
<p/>
-3- Erasures use unspecified techniques <del>of constant time complexity</del> to identify the memory 
locations of erased elements, which are subsequently skipped during iteration <ins>in constant time</ins>, 
as opposed to relocating subsequent elements during erasure. <ins>These techniques are either constant time 
or logarithmic in the capacity of the element block erased from.</ins>
</p>
</blockquote>

</li>

<li><p>Modify 23.3.9.2 <a href="https://timsong-cpp.github.io/cppwp/hive.cons">[hive.cons]</a> as indicated:</p>

<blockquote>
<pre>
hive&amp; operator=(const hive&amp; x);
</pre>
<blockquote>
<p>
-25- <i>Preconditions</i>: [&hellip;]
<p/>
-26- <i>Effects</i>: [&hellip;]
<p/>
-27- <i>Complexity</i>: Linear in <code class='backtick'>size() + x.size()</code>. <ins>Additionally at worst 
<code>&#x1d4aa;(log n)</code> in the capacity of each element block which an element 
is constructed within.</ins>
</p>
</blockquote>
<pre>
hive&amp; operator=(hive&amp;&amp; x)
  noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
           allocator_traits&lt;Allocator&gt;::is_always_equal::value);
</pre>
<blockquote>
<p>
-28- <i>Preconditions</i>: [&hellip;]
<p/>
-29- <i>Effects</i>: [&hellip;]
<p/>
-30- <i>Postconditions</i>: [&hellip;]
<p/>
-31- <i>Complexity</i>: Linear in <code class='backtick'>size()</code>. If
</p>
<blockquote><pre>
(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
get_allocator() == x.get_allocator())
</pre></blockquote>
<p>
is <code class='backtick'>false</code>, also linear in <code class='backtick'>x.size()</code> <ins>and additionally at worst 
<code>&#x1d4aa;(log n)</code> in the capacity of each element block which 
an element is constructed within</ins>.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.3.9.3 <a href="https://timsong-cpp.github.io/cppwp/hive.capacity">[hive.capacity]</a> as indicated:</p>

<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-8- <i>Preconditions</i>: [&hellip;]
<p/>
-9- <i>Effects</i>: [&hellip;]
<p/>
<p/>
-10- <i>Complexity</i>: If reallocation happens, linear in the size of the sequence 
<ins>and at worst <code>&#x1d4aa;(log n)</code> in the capacity of each element block which
elements are reallocated into</ins>.
<p/>
-11- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
void reshape(hive_limits block_limits);
</pre>
<blockquote>
<p>
-21- <i>Preconditions</i>: [&hellip;]
<p/>
-22- <i>Effects</i>: [&hellip;]
<p/>
-23- <i>Postconditions</i>: [&hellip;]
<p/>
-24- <i>Complexity</i>: Linear in the number of element blocks in <code class='backtick'>*this</code>. If reallocation happens, 
also linear in the number of elements reallocated <ins>and at worst <code>&#x1d4aa;(log n)</code> in 
the capacity of each element block which elements are reallocated into</ins>.
<p/>
-25- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.3.9.4 <a href="https://timsong-cpp.github.io/cppwp/hive.modifiers">[hive.modifiers]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... Args&gt; iterator emplace(Args&amp;&amp;... args);
template&lt;class... Args&gt; iterator emplace_hint(const_iterator hint, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: [&hellip;]
<p/>
-2- <i>Effects</i>: [&hellip;]
<p/>
-3- <i>Returns</i>: [&hellip;]
<p/>
-4- <i>Complexity</i>: <del>Constant</del><ins>At worst <code>&#x1d4aa;(log n)</code> in the capacity 
of the element block which the element is constructed within</ins>. Exactly one object of type <code class='backtick'>T</code> is constructed.
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
void insert(initializer_list&lt;T&gt; rg);
template&lt;<i>container-compatible-range</i>&lt;T&gt; R&gt;
  void insert_range(R&amp;&amp; rg);
</pre>
<blockquote>
<p>
-7- <i>Preconditions</i>: [&hellip;]
<p/>
-8- <i>Effects</i>: [&hellip;]
<p/>
<p/>
-9- <i>Complexity</i>: Linear in the number of elements inserted. <ins>Additionally at
worst <code>&#x1d4aa;(log n)</code> in the capacity of each element block which an element is
constructed within.</ins> Exactly one object of type <code class='backtick'>T</code> is constructed for each element 
inserted.
<p/>
-10- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>
<pre>
void insert(size_type n, const T&amp; x);
</pre>
<blockquote>
<p>
-11- <i>Preconditions</i>: [&hellip;]
<p/>
-12- <i>Effects</i>: [&hellip;]
<p/>
<p/>
-13- <i>Complexity</i>: Linear in <code class='backtick'>n</code>. <ins>Additionally at worst <code>&#x1d4aa;(log n)</code> 
in the capacity of each element block which an element is constructed within.</ins>. 
Exactly one object of type <code class='backtick'>T</code> is constructed for each element inserted.
<p/>
-14- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>
<p>
[&hellip;]
</p>
<pre>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>
-16- Complexity: Linear in the number of elements erased <ins>and for each
erased element at worst <code>&#x1d4aa;(log n)</code> in the capacity of the block
containing the element</ins>. Additionally, if any active blocks become empty of elements 
as a result of the function call, at worst linear in the number of 
element blocks.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 23.3.9.5 <a href="https://timsong-cpp.github.io/cppwp/hive.operations">[hive.operations]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> If issue LWG <a href="4323" title="hive::unique time complexity should incorporate potential block removal complexity (Status: New)">4323</a> is decided to be acted upon and 
the proposed solution accepted, the proposed complexity wording becomes:
</p>
<blockquote><p>
-11- <i>Complexity</i>: If <code class='backtick'>empty()</code> is <code class='backtick'>false</code>, exactly <code class='backtick'>size() - 1</code> applications 
of the corresponding predicate, otherwise no applications of the predicate. 
<ins>For each element erased as a result of this function call, at worst <code>&#x1d4aa;(log n)</code> 
in the capacity of the block containing the element. Additionally, if any active blocks become 
empty of elements as a result of the function call, at worst linear in the number of element 
blocks.</ins>
</p></blockquote>
<p>
]
</p>
</blockquote>

<blockquote>
<pre>
template&lt;class BinaryPredicate = equal_to&lt;T&gt;&gt;
  size_type unique(BinaryPredicate binary_pred = BinaryPredicate());
</pre>
<blockquote>
<p>
-7- <i>Preconditions</i>: [&hellip;]
<p/>
-8- <i>Effects</i>: [&hellip;]
<p/>
-9- <i>Returns</i>: [&hellip;]
<p/>
-10- <i>Throws</i>: [&hellip;]
<p/>
-11- <i>Complexity</i>: If <code class='backtick'>empty()</code> is <code class='backtick'>false</code>, exactly <code class='backtick'>size() - 1</code> applications 
of the corresponding predicate, otherwise no applications of the predicate. 
<ins>Additionally, for each element erased as a result of this function call,
at worst <code>&#x1d4aa;(log n)</code> in the capacity of each block containing the element.</ins>
<p/>
-12- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2025-09-26; Matt comments and provides improved wording]</i></p>

<p>
Past LWG/LEWG telecon discussion around this topic concluded that because elements are not involved, 
and the logarithmic action is within the capacity of a block (a fixed number), not the size of the 
sequence, and the actual performance cost is negligible, that the complexity of these actions are 
in fact constant. But there is some disagreement on this.
<p/>
One possibility is to add additional complexity data to each of the effected functions. This would 
impact on <code class='backtick'>emplace</code>, range <code class='backtick'>insert</code>, fill <code class='backtick'>insert</code>, <code class='backtick'>shrink_to_fit</code>, <code class='backtick'>reshape</code>, copy/move 
assignment operator, <code class='backtick'>erase</code> and <code class='backtick'>unique</code>. However I feel this is overkill and may confuse 
implementors as the log(n) complexity is not permitted to involve elements.
<p/>
Having looked into it and sought feedback I think a blanket note on 23.3.9.1 <a href="https://timsong-cpp.github.io/cppwp/hive.overview">[hive.overview]</a> p3 
would be sufficient, such that the time complexity is limited to "techniques to identify the memory 
locations of erased elements". Otherwise we need to stay with the previous resolution that this 
is in fact constant time behaviour.
</p>


<p id="res-4320"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.3.9.1 <a href="https://timsong-cpp.github.io/cppwp/hive.overview">[hive.overview]</a> as indicated:</p>

<blockquote>
<p>
-1- A <code class='backtick'>hive</code> is a type of sequence container that provides constant-time insertion and erasure 
operations. Storage is automatically managed in multiple memory blocks, referred 
to as element blocks. Insertion position is determined by the container, and  
may re-use the memory locations of erased elements.
<p/>
-2- [&hellip;]
<p/>
-3- Erasures use unspecified techniques <del>of constant time complexity</del> to identify the memory 
locations of erased elements, which are subsequently skipped during iteration <ins>in constant time</ins>, 
as opposed to relocating subsequent elements during erasure. <ins>The same or different techniques 
may be utilized to find and re-use these locations during subsequent insertions.</ins> 
<p/>
<ins>[<i>Note</i>: The techniques are permitted to be at worst logarithmic in the capacity of the 
element blocks being inserted into or erased from, while maintaining constant-time iteration, to allow 
latitude for implementation-specific optimizations. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4321"><a href="4321">4321</a>. How are evaluations occurring within a store and a load operation ordered where the store synchronized with the load</h3>
<p><b>Section:</b> 32.5.8.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.types.operations">[atomics.types.operations]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> jim x <b>Opened:</b> 2025-08-20 <b>Last modified:</b> 2025-08-25</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider this example:
</p>
<blockquote><pre>
std::atomic&lt;int&gt; v = 0;
// thread 1:
v.store(1, memory_order::release); // #1
// thread 2:
v.load(memory_order::acquire); // #2
</pre></blockquote>
<p>
Say, <code class='backtick'>#2</code> reads the value written by <code class='backtick'>#1</code>, <code class='backtick'>#1</code> synchronizes with <code class='backtick'>#2</code>. According to 6.10.2.2 <a href="https://timsong-cpp.github.io/cppwp/intro.races">[intro.races]</a> p7:
</p>
<blockquote>
<p>
 An evaluation <i>A</i> <i>happens before an evaluation</i> <i>B</i> (or, equivalently, <i>B</i> 
 happens after <i>A</i>) if either
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; [&hellip;]</p></li>
<li><p>(7.2) &mdash; <i>A</i> synchronizes with <i>B</i>, or</p></li>
<li><p>(7.3) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>
<p>
So, <code class='backtick'>#1</code> happens before <i>B</i>. However, 6.10.1 <a href="https://timsong-cpp.github.io/cppwp/intro.execution">[intro.execution]</a> p12 says:
</p>
<blockquote>
<p>
For each
</p>
<ol style="list-style-type: none">
<li><p>(12.1) &mdash; function invocation,</p></li>
<li><p>(12.2) &mdash; [&hellip;]</p></li>
<li><p>(12.3) &mdash; [&hellip;]</p></li>
</ol>
<p>
<i>F</i>, each evaluation that does not occur within <i>F</i> but is evaluated 
on the same thread and as part of the same signal handler (if any) is either 
sequenced before all evaluations that occur within <i>F</i> or sequenced after 
all evaluations that occur within <i>F</i>;
</p>
</blockquote>
<p>
Because both <code class='backtick'>v.store(...)</code> and <code class='backtick'>v.load(...)</code> are function invocations, and we can think that the member 
functions comprise some evaluations to form the operation, therefore, how are these evaluations that 
occur within the <code class='backtick'>store</code> ordered with those within the <code class='backtick'>load</code>?
<p/>
The rule only says the <code class='backtick'>store</code> synchronizes with the <code class='backtick'>load</code>, hence, the evaluation of the function 
call expression <code class='backtick'>v.store(...)</code> happens before the evaluation of the function call expression <code class='backtick'>v.load(...)</code>, 
but how about these evaluations occurring within these functions?
<p/>
A possible resolution might be: The order between all evaluations occurring within a function invocation 
and another evaluation <i>B</i> is determined by how the evaluation of the function call expression is 
ordered in relation to the expression <i>B</i>.
<p/>
For example, if <code class='backtick'>v.store()</code> happens-before <i>E</i>, then all evaluations occurring within the <code class='backtick'>store</code> 
happen-before <i>E</i>. As well, <code class='backtick'>v.store(...)</code> synchronizes with <code class='backtick'>v.load(...)</code>, then all evaluations 
occurring within <code class='backtick'>v.store(...)</code> synchronize with all evaluations occurring within <code class='backtick'>v.load(...)</code>.
</p>


<p id="res-4321"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4322"><a href="4322">4322</a>. Problematic <i>Constraints</i> on incomplete types in indirect and polymorphic</h3>
<p><b>Section:</b> 20.4 <a href="https://timsong-cpp.github.io/cppwp/mem.composite.types">[mem.composite.types]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan B. Coe <b>Opened:</b> 2025-08-20 <b>Last modified:</b> 2025-10-07</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class templates <code>indirect&lt;T&gt;</code> and <code>polymorphic&lt;T&gt;</code> allow the template argument <code class='backtick'>T</code> 
to be an incomplete type.
<p/>
Both classes can be instantiated when the type <code class='backtick'>T</code> is incomplete: constraints are written so that requirements 
on incomplete types are not evaluated at class instantiation time.
<p/>
For constructors with additional template parameters, there are currently constraints written on the potentially 
incomplete type <code class='backtick'>T</code> and the additional template parameters. Such constraints will not be evaluated at class 
instantiation time but could be explicitly evaluated in contexts where support for an incomplete <code class='backtick'>T</code> is required.
</p>
<blockquote><pre>
template&lt;typename U&gt;
class A {
  U u;
public:
  A(const <i>SomeType</i>&amp;) requires std::is_constructible_v&lt;U, <i>SomeType</i>&gt; 
  {
    // [&hellip;]
  }
};
</pre></blockquote>
<p>
when <code class='backtick'>U</code> is <code>indirect&lt;T&gt;</code> or <code>polymorphic&lt;T&gt;</code> for some type <code class='backtick'>T</code>, the existence 
of the requires clause will require that <code class='backtick'>T</code> is a complete type for constraints on indirect or polymorphic 
to be evaluated.
<p/>
<i>Constraints</i> on <code class='backtick'>T</code> should be converted to <i>Mandates</i> on <code class='backtick'>T</code> so that constraint evaluation 
does not require <code class='backtick'>T</code> to be a complete type.
</p>

<p><i>[2025-10-07; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>
<p>
"Do we have a concrete use case of an A-like type? Is making the traits give
wrong answers preferable to hard errors? I don't think the <code class='backtick'>polymorphic</code> part
makes sense. Since the constraints still require <code class='backtick'>U</code>/<code class='backtick'>UU</code> to be complete,
either <code class='backtick'>T</code> is a base class and it must be complete, or it is not and it doesn't
matter."
</p>
<p>
"The problematic members are non-template functions, so they are instantiated
early and the requires clauses are checked too soon. Think this can be solved
without giving up SFINAE-friendliness, by making the affected members
themselves templates."
</p>



<p id="res-4322"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 20.4.1.3 <a href="https://timsong-cpp.github.io/cppwp/indirect.ctor">[indirect.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = T&gt;
  constexpr explicit indirect(U&amp;&amp; u);
</pre>
<blockquote>
<p>
-17- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(17.1) &mdash; <code>is_same_v&lt;remove_cvref_t&lt;U&gt;, indirect&gt;</code> is <code class='backtick'>false</code>,</p></li>
<li><p>(17.2) &mdash; <code>is_same_v&lt;remove_cvref_t&lt;U&gt;, in_place_t&gt;</code> is <code class='backtick'>false</code>, <ins>and</ins></p></li>
<li><p><del>(17.3) &mdash; <code>is_constructible_v&lt;T, U&gt;</code> is <code class='backtick'>true</code>, and</del></p></li>
<li><p>(17.4) &mdash; <code>is_default_constructible_v&lt;Allocator&gt;</code> is <code class='backtick'>true</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>is_constructible_v&lt;T, U&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-18- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U = T&gt;
  constexpr explicit indirect(allocator_arg_t, const Allocator&amp; a, U&amp;&amp; u);
</pre>
<blockquote>
<p>
-19- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(19.1) &mdash; <code>is_same_v&lt;remove_cvref_t&lt;U&gt;, indirect&gt;</code> is <code class='backtick'>false</code>, <ins>and</ins></p></li>
<li><p>(19.2) &mdash; <code>is_same_v&lt;remove_cvref_t&lt;U&gt;, in_place_t&gt;</code> is <code class='backtick'>false</code><ins>.</ins><del>, and</del></p></li>
<li><p><del>(19.3) &mdash; <code>is_constructible_v&lt;T, U&gt;</code> is <code class='backtick'>true</code></del></p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>is_constructible_v&lt;T, U&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-20- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... Us&gt;
  constexpr explicit indirect(in_place_t, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-21- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(21.1) &mdash; <code>is_constructible_v&lt;T, Us...&gt;</code> is <code class='backtick'>true</code>, and</del></p></li>
<li><p><del>(21.2) &mdash;</del> <code>is_default_constructible_v&lt;Allocator&gt;</code> is <code class='backtick'>true</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>is_constructible_v&lt;T, Us...&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-22- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... Us&gt;
  constexpr explicit indirect(allocator_arg_t, const Allocator&amp; a,
                              in_place_t, Us&amp;&amp; ...us);
</pre>
<blockquote>
<p>
-23- <i><del>Constraints</del><ins>Mandates</ins></i>: <code>is_constructible_v&lt;T, Us...&gt;</code> is <code class='backtick'>true</code>
<p/>
-24- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class I, class... Us&gt;
  constexpr explicit indirect(in_place_t, initializer_list&lt;I&gt; ilist, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-25- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p><del>(25.1) &mdash; <code>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</code> is <code class='backtick'>true</code>, and</del></p></li>
<li><p><del>(25.2) &mdash;</del> <code>is_default_constructible_v&lt;Allocator&gt;</code> is <code class='backtick'>true</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
<p/>
-26- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class I, class... Us&gt;
  constexpr explicit indirect(allocator_arg_t, const Allocator&amp; a,
                              in_place_t, initializer_list&lt;I&gt; ilist, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-27- <i><del>Constraints</del><ins>Mandates</ins></i>: <code>is_constructible_v&lt;T, initializer_list&lt;I&gt;&amp;, Us...&gt;</code> 
is <code class='backtick'>true</code>
<p/>
-28- <i>Effects</i>: [&hellip;]
</p>
</blockquote>

</blockquote>

</li>

<li><p>Modify 20.4.2.3 <a href="https://timsong-cpp.github.io/cppwp/polymorphic.ctor">[polymorphic.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = T&gt;
  constexpr explicit polymorphic(U&amp;&amp; u);
</pre>
<blockquote>
<p>
-12- <i>Constraints</i>: Where <code class='backtick'>UU</code> is <code>remove_cvref_t&lt;U&gt;</code>,
</p>
<ol style="list-style-type: none">
<li><p>(12.1) &mdash; <code>is_same_v&lt;UU, polymorphic&gt;</code> is <code class='backtick'>false</code>,</p></li>
<li><p><del>(12.2) &mdash; <code>derived_from&lt;UU, T&gt;</code> is <code class='backtick'>true</code>,</del></p></li>
<li><p>(12.3) &mdash; <code>is_constructible_v&lt;UU, U&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p>(12.4) &mdash; <code>is_copy_constructible_v&lt;UU&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p>(12.5) &mdash; <code class='backtick'>UU</code> is not a specialization of <code class='backtick'>in_place_type_t</code>, and</p></li>
<li><p>(12.6) &mdash; <code>is_default_constructible_v&lt;Allocator&gt;</code> is <code class='backtick'>true</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>derived_from&lt;UU, T&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-13- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U = T&gt;
  constexpr explicit polymorphic(allocator_arg_t, const Allocator&amp; a, U&amp;&amp; u);
</pre>
<blockquote>
<p>
-14- <i>Constraints</i>: Where <code class='backtick'>UU</code> is <code>remove_cvref_t&lt;U&gt;</code>,
</p>
<ol style="list-style-type: none">
<li><p>(14.1) &mdash; <code>is_same_v&lt;UU, polymorphic&gt;</code> is <code class='backtick'>false</code>,</p></li>
<li><p><del>(14.2) &mdash; <code>derived_from&lt;UU, T&gt;</code> is <code class='backtick'>true</code>,</del></p></li>
<li><p>(14.3) &mdash; <code>is_constructible_v&lt;UU, U&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p>(14.4) &mdash; <code>is_copy_constructible_v&lt;UU&gt;</code> is <code class='backtick'>true</code>, and</p></li>
<li><p>(14.5) &mdash; <code class='backtick'>UU</code> is not a specialization of <code class='backtick'>in_place_type_t</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>derived_from&lt;UU, T&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-15- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class... Ts&gt;
  constexpr explicit polymorphic(in_place_type_t&lt;U&gt;, Ts&amp;&amp;... ts);
</pre>
<blockquote>
<p>
-16- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(16.1) &mdash; <code>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p><del>(16.2) &mdash; <code>derived_from&lt;U, T&gt;</code> is <code class='backtick'>true</code>,</del></p></li>
<li><p>(16.3) &mdash; <code>is_constructible_v&lt;U, Ts&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p>(16.4) &mdash; <code>is_copy_constructible_v&lt;U&gt;</code> is <code class='backtick'>true</code>, and</p></li>
<li><p>(16.5) &mdash; <code>is_default_constructible_v&lt;Allocator&gt;</code> is <code class='backtick'>true</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>derived_from&lt;U, T&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-17- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class... Ts&gt;
  constexpr explicit polymorphic(allocator_arg_t, const Allocator&amp; a,
                                 in_place_type_t&lt;U&gt;, Ts&amp;&amp;... ts);
</pre>
<blockquote>
<p>
-18- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(18.1) &mdash; <code>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p><del>(18.2) &mdash; <code>derived_from&lt;U, T&gt;</code> is <code class='backtick'>true</code>,</del></p></li>
<li><p>(18.3) &mdash; <code>is_constructible_v&lt;U, Ts&gt;</code> is <code class='backtick'>true</code>, and</p></li>
<li><p>(18.4) &mdash; <code>is_copy_constructible_v&lt;U&gt;</code> is <code class='backtick'>true</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>derived_from&lt;U, T&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-19- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class I, class... Us&gt;
  constexpr explicit polymorphic(in_place_type_t&lt;U&gt;, initializer_list&lt;I&gt; ilist, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-20- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(20.1) &mdash; <code>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p><del>(20.2) &mdash; <code>derived_from&lt;U, T&gt;</code> is <code class='backtick'>true</code>,</del></p></li>
<li><p>(20.3) &mdash; <code>is_constructible_v&lt;U, initializer_list&lt;I&gt;&amp;, Us...&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p>(20.4) &mdash; <code>is_copy_constructible_v&lt;U&gt;</code> is <code class='backtick'>true</code>, and</p></li>
<li><p>(20.5) &mdash; <code>is_default_constructible_v&lt;Allocator&gt;</code> is <code class='backtick'>true</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>derived_from&lt;U, T&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-21- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class I, class... Us&gt;
  constexpr explicit polymorphic(allocator_arg_t, const Allocator&amp; a, 
                                 in_place_type_t&lt;U&gt;, initializer_list&lt;I&gt; ilist, Us&amp;&amp;... us);
</pre>
<blockquote>
<p>
-22- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>(22.1) &mdash; <code>is_same_v&lt;remove_cvref_t&lt;U&gt;, U&gt;</code> is <code class='backtick'>true</code>,</p></li>
<li><p><del>(22.2) &mdash; <code>derived_from&lt;U, T&gt;</code> is <code class='backtick'>true</code>,</del></p></li>
<li><p>(22.3) &mdash; <code>is_constructible_v&lt;U, initializer_list&lt;I&gt;&amp;, Us...&gt;</code> is <code class='backtick'>true</code>, and</p></li>
<li><p>(22.4) &mdash; <code>is_copy_constructible_v&lt;U&gt;</code> is <code class='backtick'>true</code>.</p></li>
</ol>
<p>
<ins>-?- <i>Mandates:</i> <code>derived_from&lt;U, T&gt;</code> is <code class='backtick'>true</code>.</ins>
<p/>
-23- <i>Effects</i>: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4323"><a href="4323">4323</a>. <code class='backtick'>hive::unique</code> time complexity should incorporate potential block removal complexity</h3>
<p><b>Section:</b> 23.3.9.5 <a href="https://timsong-cpp.github.io/cppwp/hive.operations">[hive.operations]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Bentley <b>Opened:</b> 2025-08-24 <b>Last modified:</b> 2025-08-25</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently we specify for <code class='backtick'>erase</code> 23.3.9.4 <a href="https://timsong-cpp.github.io/cppwp/hive.modifiers">[hive.modifiers]</a> p16:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>
<i>Complexity:</i> Linear in the number of elements erased. Additionally, if
any active blocks become empty of elements as a result of the function
call, at worst linear in the number of element blocks.
</p></blockquote>
<p>
This is to allow for potential <code class='backtick'>hive</code> implementations as vectors of
pointers to blocks, as opposed to linked-lists of blocks (reference
implementation approach). In that scenario removing a block would
involve a vector erasure and subsequent pointer-to-block relocations.
swap-and-pop of block pointers would not work as this would re-arrange
the sequence during erasure. Anyway, we have neglected to apply this
same complexity to <code class='backtick'>hive::unique</code>. It would be rare that this would occur
for <code class='backtick'>unique</code>, as it would involve (1) a block <i>A</i> with only one non-erased
element left in it and (2) a block <i>B</i> preceding/following block 
<i>A</i> in the sequence, whose last/first element is equal to the element 
in block <i>A</i>. But it is possible, so the same consideration in terms 
of time complexity applies.
</p>
<blockquote class="note">
<p>
This is a separate but related issue to LWG <a href="4320" title="hive operations involving insertion/erasure should have &#x1d4aa;(log n) time complexity (Status: New)">4320</a>, but it would 
affect the outcome wording of that issue for <code class='backtick'>unique</code>.
</p>
</blockquote>


<p id="res-4323"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.3.9.5 <a href="https://timsong-cpp.github.io/cppwp/hive.operations">[hive.operations]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> If issue LWG <a href="4320" title="hive operations involving insertion/erasure should have &#x1d4aa;(log n) time complexity (Status: New)">4320</a> is decided to be acted upon and 
the proposed solution accepted, the proposed complexity wording becomes:
</p>
<blockquote><p>
-11- <i>Complexity</i>: If <code class='backtick'>empty()</code> is <code class='backtick'>false</code>, exactly <code class='backtick'>size() - 1</code> applications 
of the corresponding predicate, otherwise no applications of the predicate. 
<ins>For each element erased as a result of this function call, at worst <code>&#x1d4aa;(log n)</code> 
in the capacity of the block containing the element. Additionally, if any active blocks become 
empty of elements as a result of the function call, at worst linear in the number of element 
blocks.</ins>
</p></blockquote>
<p>
]
</p>
</blockquote>


<blockquote>
<pre>
template&lt;class BinaryPredicate = equal_to&lt;T&gt;&gt;
  size_type unique(BinaryPredicate binary_pred = BinaryPredicate());
</pre>
<blockquote>
<p>
-7- <i>Preconditions</i>: [&hellip;]
<p/>
-8- <i>Effects</i>: [&hellip;]
<p/>
-9- <i>Returns</i>: [&hellip;]
<p/>
-10- <i>Throws</i>: [&hellip;]
<p/>
-11- <i>Complexity</i>: If <code class='backtick'>empty()</code> is <code class='backtick'>false</code>, exactly <code class='backtick'>size() - 1</code> applications 
of the corresponding predicate, otherwise no applications of the predicate. 
<ins>Additionally, if any active blocks become empty of elements as a result of the 
function call, at worst linear in the number of element blocks.</ins>
<p/>
-12- <i>Remarks</i>: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4324"><a href="4324">4324</a>. <code>unique_ptr&lt;void&gt;::operator*</code> is not SFINAE-friendly</h3>
<p><b>Section:</b> 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-08-24 <b>Last modified:</b> 2025-08-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unique.ptr.single.observers">active issues</a> in [unique.ptr.single.observers].</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.observers">issues</a> in [unique.ptr.single.observers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="2762" title="unique_ptr operator*() should be noexcept (Status: C++23)">2762</a> added a conditional <code class='backtick'>noexcept</code> specification to <code class='backtick'>unique_ptr::operator*</code>
to make it consistent with <code class='backtick'>shared_ptr::operator*</code>:
</p>
<pre>
constexpr add_lvalue_reference_t&lt;T&gt; operator*() const <ins>noexcept(noexcept(*declval&lt;pointer&gt;()))</ins>;
</pre>
<p>
This unexpectedly makes <code>unique_ptr&lt;void&gt;::operator*</code> no longer SFINAE-friendly, 
<a href="https://godbolt.org/z/xd15jYPhz">for example</a>:
</p>
<blockquote><pre>
#include &lt;memory&gt;

template&lt;class T&gt; concept dereferenceable = requires(T&amp; t) { *t; };

static_assert( dereferenceable&lt;int *&gt;);
static_assert(!dereferenceable&lt;void*&gt;);

static_assert( dereferenceable&lt;std::shared_ptr&lt;int &gt;&gt;);
static_assert(!dereferenceable&lt;std::shared_ptr&lt;void&gt;&gt;);

static_assert( dereferenceable&lt;std::unique_ptr&lt;int &gt;&gt;);
static_assert( dereferenceable&lt;std::unique_ptr&lt;void&gt;&gt;); // <span  style="color:#C80000;font-weight:bold">hard error</span>
</pre></blockquote>
<p>
Given that the standard intends for <code class='backtick'>operator*</code> of <code class='backtick'>shared_ptr</code> and <code class='backtick'>unique_ptr</code> to be 
SFINAE-friendly based on 20.3.2.2.6 <a href="https://timsong-cpp.github.io/cppwp/util.smartptr.shared.obs">[util.smartptr.shared.obs]</a>, regardless of the value of 
<code class='backtick'>static_assert</code>, it is reasonable to assume that there should be no hard error here.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> as indicated:</p>

<blockquote>
<pre>
constexpr add_lvalue_reference_t&lt;T&gt; operator*() const noexcept(<del>noexcept(*declval&lt;pointer&gt;())</del><ins><i>see below</i></ins>);
</pre>
<blockquote>
<p>
-1- <i>Mandates</i>: <code>reference_converts_from_temporary_v&lt;add_lvalue_reference_t&lt;T&gt;, 
decltype(*declval&lt;pointer&gt;())&gt;</code> is <code class='backtick'>false</code>.
<p/>
-2- <i>Preconditions</i>: <code class='backtick'>get() != nullptr</code> is <code class='backtick'>true</code>.
<p/>
-3- <i>Returns</i>: <code class='backtick'>*get()</code>.
<p/>
<ins>-?- <i>Remarks:</i>: The exception specification is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>!requires { *declval&lt;pointer&gt;(); } || requires { { *declval&lt;pointer&gt;() } noexcept; }</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2025-08-26; Reflector discussion]</i></p>

<p>
During reflector triaging it had been pointed out that a better solution would be to constrain the 
<code class='backtick'>operator*</code> directly. The proposed wording has been updated to that effect.
</p>


<p id="res-4324"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 20.3.1.3.5 <a href="https://timsong-cpp.github.io/cppwp/unique.ptr.single.observers">[unique.ptr.single.observers]</a> as indicated:</p>

<blockquote>
<pre>
constexpr add_lvalue_reference_t&lt;T&gt; operator*() const noexcept(noexcept(*declval&lt;pointer&gt;()));
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints</i>: <code>*declval&lt;pointer&gt;()</code> is a well-formed expression.</ins>
<p/>
-1- <i>Mandates</i>: <code>reference_converts_from_temporary_v&lt;add_lvalue_reference_t&lt;T&gt;, 
decltype(*declval&lt;pointer&gt;())&gt;</code> is <code class='backtick'>false</code>.
<p/>
-2- <i>Preconditions</i>: <code class='backtick'>get() != nullptr</code> is <code class='backtick'>true</code>.
<p/>
-3- <i>Returns</i>: <code class='backtick'>*get()</code>.
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4325"><a href="4325">4325</a>. <code class='backtick'>std::indirect</code>'s <code class='backtick'>operator==</code> still does not support incomplete types</h3>
<p><b>Section:</b> 20.4.1.8 <a href="https://timsong-cpp.github.io/cppwp/indirect.relops">[indirect.relops]</a>, 20.4.1.9 <a href="https://timsong-cpp.github.io/cppwp/indirect.comp.with.t">[indirect.comp.with.t]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-08-24 <b>Last modified:</b> 2025-08-24</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>std::indirect</code>'s `operator== 
<a href="https://github.com/cplusplus/papers/issues/1680#issuecomment-2646604309">intentionally</a> 
uses <i>Mandates</i> instead of <i>Constraints</i> to support incomplete types. However, its 
function signature has the following <code class='backtick'>noexcept</code> specification:
</p>
<blockquote><pre>
template&lt;class U, class AA&gt;
  constexpr bool operator==(const indirect&amp; lhs, const indirect&lt;U, AA&gt;&amp; rhs)
    noexcept(noexcept(*lhs == *rhs));
</pre></blockquote>
<p>
That is, we check whether the expression <code class='backtick'>*lhs == *rhs</code> throws, which unfortunately leads to 
the following hard error:
</p>
<blockquote><pre>
struct Incomplete;
static_assert(std::equality_comparable&lt;std::indirect&lt;Incomplete&gt;&gt;);
// <span  style="color:#C80000;font-weight:bold">hard error, no match for 'operator==' (operand types are 'const Incomplete' and 'const Incomplete')</span>
</pre></blockquote>
<p>
This makes <code class='backtick'>operator==</code> not SFINAE-friendly for incomplete types, which defeats the purpose.
<p/>
Also, checking <code class='backtick'>noexcept(*lhs == *rhs)</code> seems insufficient because the result of <code class='backtick'>*lhs == *rhs</code> 
might still throw during conversion to <code class='backtick'>bool</code>.
</p>


<p id="res-4325"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i>: We introduce the exposition-only function <code><i>FUN</i></code> below to mimic
the implicit conversion to <code class='backtick'>bool</code>. As a drive-by effect this helps us simplifying (and clarifying, see
LWG <a href="484" title="Convertible to T (Status: Open)">484</a>) the existing <i>Mandates</i> element.
<p/>
Please note that the seemingly unresolved <code class='backtick'>T</code> in the <code class='backtick'>requires</code> expression below names the first template 
parameter of the <code class='backtick'>indirect</code> class template.
]
</p>
</blockquote>

<ol>

<li><p>Modify 20.4.1.8 <a href="https://timsong-cpp.github.io/cppwp/indirect.relops">[indirect.relops]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U, class AA&gt;
  constexpr bool operator==(const indirect&amp; lhs, const indirect&lt;U, AA&gt;&amp; rhs)
    noexcept(<del>noexcept(*lhs == *rhs)</del><ins><i>see below</i></ins>);
</pre>
<blockquote>
<p>
<ins>-?- Let <code><i>FUN</i></code> denote the exposition-only function</ins>
</p>
<blockquote><pre>
<ins>bool <i>FUN</i>(bool) noexcept;</ins>
</pre></blockquote>
<p>
-1- <i>Mandates</i>: The expression <code><ins><i>FUN</i>(</ins>*lhs == *rhs<ins>)</ins></code> is well-formed <del>and its result is convertible to <code class='backtick'>bool</code></del>.
<p/>
-2- <i>Returns</i>: If <code class='backtick'>lhs</code> is valueless or <code class='backtick'>rhs</code> is valueless, 
<code class='backtick'>lhs.valueless_after_move() == rhs.valueless_after_move()</code>; otherwise <code class='backtick'>*lhs == *rhs</code>.
<p/>
<ins>-?- <i>Remarks</i>: The exception specification is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>requires (const T&amp; lhs, const U&amp; rhs) { { <i>FUN</i>(lhs == rhs) } noexcept; }</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

<li><p>Modify 20.4.1.9 <a href="https://timsong-cpp.github.io/cppwp/indirect.comp.with.t">[indirect.comp.with.t]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U&gt;
  constexpr bool operator==(const indirect&amp; lhs, const U&amp; rhs) noexcept(<del>noexcept(*lhs == rhs)</del><ins><i>see below</i></ins>);
</pre>
<blockquote>
<p>
<ins>-?- Let <code><i>FUN</i></code> denote the exposition-only function</ins>
</p>
<blockquote><pre>
<ins>bool <i>FUN</i>(bool) noexcept;</ins>
</pre></blockquote>
<p>
-1- <i>Mandates</i>: The expression <code><ins><i>FUN</i>(</ins>*lhs == rhs<ins>)</ins></code> is well-formed <del>and its result is convertible to <code class='backtick'>bool</code></del>.
<p/>
-2- <i>Returns</i>: If <code class='backtick'>lhs</code> is valueless, <code class='backtick'>false</code>; otherwise <code class='backtick'>*lhs == rhs</code>.
<p/>
<ins>-?- <i>Remarks</i>: The exception specification is equivalent to:</ins>
</p>
<blockquote><pre>
<ins>requires (const T&amp; lhs, const U&amp; rhs) { { <i>FUN</i>(lhs == rhs) } noexcept; }</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4326"><a href="4326">4326</a>. Standard defined queries can't customize <code class='backtick'>forwarding_query_t</code> by inheriting from it</h3>
<p><b>Section:</b> 33.5.1 <a href="https://timsong-cpp.github.io/cppwp/exec.fwd.env">[exec.fwd.env]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-25 <b>Last modified:</b> 2025-08-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definition of the <code class='backtick'>forwarding_query_t</code> (33.5.1 <a href="https://timsong-cpp.github.io/cppwp/exec.fwd.env">[exec.fwd.env]</a>) states that a query 
is a forwarding-query if either the expression <code class='backtick'>q.query(forwarding_query)</code> is a constant expression 
that evaluates to <code class='backtick'>true</code> or the query type inherits from <code class='backtick'>forwarding_query_t</code>.
<p/>
However, all of the queries defined in 33 <a href="https://timsong-cpp.github.io/cppwp/exec">[exec]</a> are defined similar to the following:
</p>
<blockquote><pre>
struct get_allocator_t { <i>unspecified</i> };
</pre></blockquote>
<p>
While this definition allows for the members of the class to be unspecified, it still explicitly 
specifies that it has an empty list of base-classes and therefore cannot customize 
<code class='backtick'>forwarding_query_t</code> by inheriting from <code class='backtick'>forwarding_query_t</code>.
<p/>
We should consider whether we want to change the specification of queries that are to be 
forwarding-queries to allow inheritance from <code class='backtick'>forwarding_query_t</code> or otherwise remove the 
support for customizing <code class='backtick'>forwarding_query_t</code> by inheriting from it.
<p/>
<b>Proposed Approach:</b>
<p/>
Remove the rule that checks for inheritance from <code class='backtick'>forwarding_query_t</code>. Any query can already 
customize <code class='backtick'>forwarding_query_t</code> by defining a <code class='backtick'>query(forwarding_query_t)</code> member function, so 
there is no loss of functionality from doing this and it would simplify the design.
</p>


<p id="res-4326"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.5.1 <a href="https://timsong-cpp.github.io/cppwp/exec.fwd.env">[exec.fwd.env]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code class='backtick'>forwarding_query</code> denotes a query object. For some query object <code class='backtick'>q</code> of type <code class='backtick'>Q</code>, 
<code class='backtick'>forwarding_query(q)</code> is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code><i>MANDATE-NOTHROW</i>(q.query(forwarding_query))</code> if that expression is well-formed.
<p/>
<i>Mandates</i>: The expression above has type <code class='backtick'>bool</code> and is a core constant expression if <code class='backtick'>q</code> is a core constant
expression.
</p></li>
<li><p><del>(2.2) &mdash; Otherwise, <code class='backtick'>true</code> if <code>derived_from&lt;Q, forwarding_query_t&gt;</code> is <code class='backtick'>true</code>.</del></p></li>
<li><p>(2.3) &mdash; Otherwise, <code class='backtick'>false</code>.</p></li>
</ol>

</blockquote>

</li>

</ol>





<hr>
<h3 id="4327"><a href="4327">4327</a>. Equal schedulers should be required to have same behaviour</h3>
<p><b>Section:</b> 33.6 <a href="https://timsong-cpp.github.io/cppwp/exec.sched">[exec.sched]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-25 <b>Last modified:</b> 2025-08-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.sched">active issues</a> in [exec.sched].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.sched">issues</a> in [exec.sched].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording 33.6 <a href="https://timsong-cpp.github.io/cppwp/exec.sched">[exec.sched]</a> p4 says:
</p>
<blockquote><p>
For any two values <code class='backtick'>sch1</code> and <code class='backtick'>sch2</code> of some scheduler type <code class='backtick'>Sch</code>, <code class='backtick'>sch1 == sch2</code> shall return 
<code class='backtick'>true</code> only if both <code class='backtick'>sch1</code> and <code class='backtick'>sch2</code> share the same associated execution resource.
</p></blockquote>
<p>
However, I don't think this requirement is sufficient for schedulers to be considered equal 
as it is possible to have two different schedulers that share the same associated execution 
resource but that have different behaviour.
<p/>
For example, two schedulers of the same type and having the same associated execution resource 
but where one schedules items with high priority and others with low priority.
<p/>
Ideally we want two schedulers to be equal if and only if they can be used interchangeably 
such that using either scheduler to schedule work has the same behaviour.
<p/>
Note that some use cases may also want to compare two schedulers as to whether or not they 
share the same associated execution resource, independently of their scheduling behaviour, 
however this could be added as a separate operator later, e.g. 
<code class='backtick'>std::execution::same_resource(sch1, sch2)</code>.
<p/>
While the above wording does still permit implementations to return <code class='backtick'>false</code> even if the associated 
execution resources are the same, it is not clear how this definition applies to schedulers 
such as an <code class='backtick'>inline_scheduler</code> (added in <a href="https://wg21.link/P3552" title=" Add a Coroutine Task Type">P3552</a>) in which has no specific associated 
execution resource but where instances nevertheless have the same scheduling behaviour.
<p/>
One approach to improving this would be to change p4 to refer to the schedulers having the 
same scheduling behaviour rather than having the same associated execution resource.
<p/>
For example, modify 33.6 <a href="https://timsong-cpp.github.io/cppwp/exec.sched">[exec.sched]</a> p4 to refer to schedulers having the same 
scheduling behaviour rather than having the same associated execution resource.
</p>
<blockquote><p>
For any two values <code class='backtick'>sch1</code> and <code class='backtick'>sch2</code> of some scheduler type <code class='backtick'>Sch</code>, <code class='backtick'>sch1 == sch2</code> shall 
return <code class='backtick'>true</code> only if both <code class='backtick'>sch1</code> and <code class='backtick'>sch2</code> <del>share the same associated execution 
resource</del><ins>have the same scheduling behaviour</ins>.
</p></blockquote>
<p>
However, this then raises the question of exactly what "the same scheduling behaviour" is.
For example, what if two schedulers have the same associated execution resource and the 
same behaviour for a <code class='backtick'>schedule()</code> operation, but have different behaviours for customizations 
of the <code class='backtick'>bulk()</code> algorithm?
<p/>
Alternatively, we could talk about two schedulers being equal if and only if they can be used 
interchangeably throughout the program.
</p>


<p id="res-4327"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4328"><a href="4328">4328</a>. Remove note in &sect;[exec.sched] regarding waiting for completion of scheduled operations</h3>
<p><b>Section:</b> 33.6 <a href="https://timsong-cpp.github.io/cppwp/exec.sched">[exec.sched]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-25 <b>Last modified:</b> 2025-08-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.sched">active issues</a> in [exec.sched].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.sched">issues</a> in [exec.sched].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The note at the end of 33.6 <a href="https://timsong-cpp.github.io/cppwp/exec.sched">[exec.sched]</a> says:
</p>
<blockquote><p>
[<i>Note</i>: The ability to wait for completion of submitted function objects can be provided by the 
associated execution resource of the scheduler &mdash; <i>end note</i>]
</p></blockquote>
<p>
The suggestion that the execution resource should be used to join/wait on scheduled work is problematic 
in situations that may involve more than one execution context, as an execution resource having an empty 
queue of scheduled work does not necessarily imply that tasks currently running on another execution 
context will not later schedule additional work on this execution resource.
<p/>
With the introduction of <code class='backtick'>counting_scope</code> with <a href="https://wg21.link/P3149" title=" async_scope  Creating scopes for non-sequential concurrency">P3149</a> we now have a better recommended 
way of waiting for tasks that use a resource (including execution resources) to complete.
<p/>
The note as it stands represents bad guidance and should either be removed or updated to refer to 
<code class='backtick'>counting_scope</code> and <code class='backtick'>simple_counting_scope</code> (33.14.2 <a href="https://timsong-cpp.github.io/cppwp/exec.counting.scopes">[exec.counting.scopes]</a>).
</p>


<p id="res-4328"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.6 <a href="https://timsong-cpp.github.io/cppwp/exec.sched">[exec.sched]</a> as indicated:</p>

<blockquote>
<p>
-7- A scheduler type's destructor shall not block pending completion of any receivers connected to the sender
objects returned from schedule.
<p/>
<del>[<i>Note 1</i>: The ability to wait for completion of submitted function objects can be provided by 
the associated execution resource of the scheduler. &mdash; <i>end note</i>]</del>
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4329"><a href="4329">4329</a>. Customising affine_on for other algorithms</h3>
<p><b>Section:</b> 33.13.3 <a href="https://timsong-cpp.github.io/cppwp/exec.affine.on">[exec.affine.on]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-08-31</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.affine.on">active issues</a> in [exec.affine.on].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.affine.on">issues</a> in [exec.affine.on].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are no customisations of <code>affine_on</code> for other
algorithms specified. For example, <code>affine_on(just(), sched)</code>
can be equivalent to <code>just()</code> because <code>just()</code>
completes inline and, thus, on the correct execution context.
</p>


<p id="res-4329"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4330"><a href="4330">4330</a>. <code>affine_on</code> semantics</h3>
<p><b>Section:</b> 33.13.3 <a href="https://timsong-cpp.github.io/cppwp/exec.affine.on">[exec.affine.on]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.affine.on">active issues</a> in [exec.affine.on].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.affine.on">issues</a> in [exec.affine.on].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>affine_on</code> uses "current execution
resource" and it is unclear what that means exactly. Additionally,
it is unclear what the difference between <code>affine_on</code>
and <code>continues_on</code> is. The intended difference for
<code>affine_on</code> is to avoid unnecessary scheduling which
<code>continues_on</code> is already allowed to do in some cases,
too.
</p>
<p>
The intended semantics is that <code>affine_on</code> will either
complete inline on whatever execution agent it was started on or
it will complete asynchronously on the specified execution context.
With this formulation <code>affine_on</code> may complete on one
of two different execution context if it is started on an execution
context that is different from the one specified by the scheduler.
</p>


<p id="res-4330"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4331"><a href="4331">4331</a>. <code>affine_on</code> shape may be wrong</h3>
<p><b>Section:</b> 33.13.3 <a href="https://timsong-cpp.github.io/cppwp/exec.affine.on">[exec.affine.on]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.affine.on">active issues</a> in [exec.affine.on].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.affine.on">issues</a> in [exec.affine.on].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>affine_on</code> is specified to take a sender and a scheduler
as arguments. The scheduler is meant to match the scheduler obtained
from the <code>get_scheduler</code> query on the receiver's
environment.  Thus, the scheduler argument is redundant and the
semantics become weird if these two schedulers don't match. The
<code>affine_on</code> algorithm should only take the sender as
argument.
</p>


<p id="res-4331"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4332"><a href="4332">4332</a>. <code>affine_on</code> shouldn't forward the stop token to the scheduling operation</h3>
<p><b>Section:</b> 33.13.3 <a href="https://timsong-cpp.github.io/cppwp/exec.affine.on">[exec.affine.on]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.affine.on">active issues</a> in [exec.affine.on].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.affine.on">issues</a> in [exec.affine.on].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The main purpose of <code>affine_on</code> is to make sure work
resumes on a specific execution context. The scheduling operation
may take some time and work may be cancelled in the meantime. If
this cancellation causes the scheduling to be cancelled work cleaning
up after the cancellation would be executed on the wrong execution
context. Thus, the stop token from the receiver's environment should
only be forwarded when <code>connect</code>ing the sender but not
to the scheduling operation.
</p>


<p id="res-4332"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4333"><a href="4333">4333</a>. <code>task</code> uses unusual allocator customisation</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike <code>generator</code> the allocator customisation of
<code>task</code> constraints the allocator type used for the
coroutine to be convertible to the configured
<code>allocator_type</code>. This prevents easy use of an allocator
especially when no allocator is configured and the default
(<code>std::allocator&lt;std::byte&gt;</code>) is used. The reason
for this constraint is that the <code>get_allocator</code> is
forwarded to <code>co_await</code>ed senders and is intended to be
the same as the allocator used for the coroutine frame.
</p>
<p>
It may be reasonable to allow use of an arbitrary allocator when
there is no explicit configuration of the <code>allocator_type</code>.
In this case it may also be resonable to not support the
<code>get_allocator</code> query when <code>co_await</code>ing
senders.
</p>


<p id="res-4333"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4334"><a href="4334">4334</a>. <code>task&lt;...&gt;::promise_type</code> supports arbitrary <code>allocator_arg</code> position</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Normally the <code>allocator_arg</code> argument has to be the first
argument when present. For <code>task&lt;...&gt;::promise_type</code>
the <code>allocator_arg</code> can appear at an arbitrary position
(except the last because it always needs to be followed by the
allocator). This permission is inconsistent and the position of the
<code>allocator_arg</code> argument and the allocator should be
limited to come first.
</p>
<p>
For containers the optional support for allocators is implemented
once for every container.  For coroutines the optional support for
allocators is implemented once for every coroutine definition. To
support an optional allocator the coroutine definition needs to use
an allocator and either gets duplicated not using an allocator or
a forwarding function is added which adds the default allocator.
With the flexible allocator position optional allocator support can be provided
using a trailing argument list, i.e., adding <code>, auto&amp;&amp;...</code>.
Instead of constraining <code>task</code> it may be more reasonable
to add the flexibility to <code>generator</code>.
</p>


<p id="res-4334"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4335"><a href="4335">4335</a>. <code>task</code> shadows the environment's allocator</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Normally, the <code>get_allocator</code> query forwards the allocator
from the receiver's environment. For <code>task</code> the
<code>get_allocator</code> query used for <code>co_await</code>ed
senders uses the allocator passed when creating the coroutine or
the default if there was none. It should use the receiver's
environment, at least, if the receiver's environment supports a
<code>get_allocator</code> query.
</p>
<p>
Supporting the receiver's allocator isn't always possible: the used
allocator type needs to be known when the coroutine is created. At
that time the receiver isn't known, yet. As a result the receiver's
environment may provide an allocator which is incompatible with the
allocator type used by the coroutine. It may be possible to use the
receiver's allcoator if it is convertible to the allocator type
used by the coroutine and to produce a compile-time error otherwise.
</p>


<p id="res-4335"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4336"><a href="4336">4336</a>. <code>bulk</code> vs. <code>task_scheduler</code></h3>
<p><b>Section:</b> 33.13.5 <a href="https://timsong-cpp.github.io/cppwp/exec.task.scheduler">[exec.task.scheduler]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.task.scheduler">active issues</a> in [exec.task.scheduler].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.task.scheduler">issues</a> in [exec.task.scheduler].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Normally, the scheduler type used by an operation can be deduced
when a sender is <code>connect</code>ed to a receiver from the
receiver's environment. The body of a coroutine cannot know about
the receiver the <code>task</code> sender gets <code>connect</code>ed
to. The implication is that the type of the scheduler used by the
coroutine needs to be known when the <code>task</code> is created.
To still allow custom schedulers used when connecting, the type-erased
scheduler <code>task_scheduler</code> is used. However, that leads
to surprises when algorithms are customised for a scheduler as is,
e.g., the case for <code>bulk</code> when used with a
<code>parallel_scheduler</code>: if <code>bulk</code> is
<code>co_awaited</code> within a coroutine using
<code>task_scheduler</code> it will use the default implementation
of <code>bulk</code> which sequentially executes the work, even if
the <code>task_scheduler</code> was initialised with a
<code>parallel_scheduler</code> (the exact invocation may actually
be slightly different or need to use <code>bulk_chunked</code> or
<code>bulk_unchunked</code> but that isn't the point being made):
</p>

<pre>
struct env {
    auto query(ex::get_scheduler_t) const noexcept { return ex::parallel_scheduler(); }
};
struct work {
    auto operator()(std::size_t s){ /*...*/ };
};

ex::sync_wait(
    ex::write_env(ex::bulk(ex::just(), 16u, work{}),
    env{}
));
ex::sync_wait(ex::write_env(
    []()->ex::task&lt;void, ex::env&lt;&gt;>&gt;{ co_await ex::bulk(ex::just(), 16u, work{}); }(),
    env{}
));
</pre>

<p>
The two invocations should probably both execute the work in parallel
but the coroutine version doesnt: it uses the <code>task_scheduler</code>
which doesnt have a specialised version of <code>bulk</code> to
potentially delegate in a type-erased form to the underlying
scheduler. It is straight forward to move the <code>write_env</code>
wrapper inside the coroutine which fixes the problem in this case
but this need introduces the potential for a subtle performance
bug. The problem is sadly not limited to a particular scheduler or
a particular algorithm: any scheduler/algorithm combination which
may get specialised can suffer from the specialised algorithm not
being picked up.
</p>

<p>
There are a few ways this problem can be addressed (this list of
options is almost certainly incomplete):
</p>

<ul>
<li>Accept the situation as is and advise users to be careful about
customised algorithms like bulk when using
<code>task_scheduler</code>.</li>
<li>Extend the interface of <code>task_scheduler</code> to deal
with a set of algorithms for which it provides a type-erased
interface. The interface would likely be more constrained and it
would use virtual dispatch at run-time. However, the set of covered
algorithms would necessarily be limited in some form.</li>
<li>To avoid the trap, make the use of known algorithms incompatible
with the use of <code>task_scheduler</code>, i.e., customise these
algorithms for <code>task_scheduler</code> such that a compile-time
error is produced.</li>
</ul>
<p>
A user who knows that the main purpose of a coroutine is to executed
an algorithm customised for a certain scheduler can use <code>task&lt;T,
E&gt;</code> with an environment <code>E</code> specifying exactly
that scheduler type.  However, this use may be nested within some
sender being <code>co_awaited</code> and users need to be aware
that the customisation wouldnt be picked up. Any approach I'm
currently aware of will have the problem that customised versions
of an algorithm are not used for algorithms we are currently unaware
of.
</p>


<p id="res-4336"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4337"><a href="4337">4337</a>. <code>co_await change_coroutine_scheduler(s)</code> requires assignable</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>change_coroutine_scheduler(sched)</code> uses
<code>std::exchange</code> to put the scheduler into place
(in 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> paragraph 11).
The problem is that <code>std::exchange(x, v)</code> expects
<code>x</code> to be assignable from <code>v</code> but there is
no requirement for scheduler to be assignable.
</p>


<p id="res-4337"><b>Proposed resolution:</b></p>
<p>
Change the wording in 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> paragraph 11
to avoid the use of <code>std::exchange</code> and transfer the using
construction:
<blockquote>
<pre>
template&lt;class Sch&gt;
  auto await_transform(change_coroutine_scheduler&lt;Sch&gt; sch) noexcept;
</pre>
<p>
-11- <i>Effects</i>: Equivalent to:
</p>
<pre>
<del>return await_transform(just(exchange(SCHED(*this), scheduler_type(sch.scheduler))), *this);</del><ins>
auto* s{address_of(<i>SCHED</i>(*this))};
auto rc{std::move(*s)};
s->~scheduler_type();
new(s) scheduler_type(std::move(sch));
return std::move(rc);
</ins>
</pre>
</blockquote>
</p>





<hr>
<h3 id="4338"><a href="4338">4338</a>. sender unaware coroutines should be able to <code>co_await</code> a <code>task</code></h3>
<p><b>Section:</b> 33.13.6.2 <a href="https://timsong-cpp.github.io/cppwp/task.class">[task.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.class">active issues</a> in [task.class].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.class">issues</a> in [task.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code>task</code> type doesn't have an <code>operator
co_await()</code>.  Thus, a <code>task</code> can't be
<code>co_await</code>ed directly from a coroutine. Using
<code>as_awaitable</code> on the <code>task</code> object also
doesn't work because this function requires a reference to the
promise as second argument.
</p>
<p>
<code>task</code> could define an <code>operator co_await()</code> that
returns an awaitable object or directly provide an awaiter
interface. There are, however, two complications:
</p> 
<ol>  
<li>For scheduler affinity the <code>task</code> needs to get a
scheduler from the object starting the <code>task</code>. While
the promise can be obtained from the coroutine handle passed to
<code>await_suspend()</code> these normally wouldn't have an
associated environment supporting a <code>get_scheduler</code> query.
</li>
<li>
The approach to reporting cancellation is to call a function
<code>unhandled_stopped()</code> on the promise type which is
generally not available. It could be argued that cancellation isn't
really a problem because the it is unlikely that the environment
associated with the promise supports a <code>get_stop_token</code>
query.
</li>
</ol>  
<p>
It is worth noting that senders in general do not support an
<code>operator co_await()</code>, i.e., other senders are also not
awaitable directly. On the other hand, <code>task</code> could
become the generic adapater to make senders awaitable from
coroutines.
</p>


<p id="res-4338"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4339"><a href="4339">4339</a>. <code>task</code>'s coroutine frame may be released late</h3>
<p><b>Section:</b> 33.13.6 <a href="https://timsong-cpp.github.io/cppwp/exec.task">[exec.task]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-02</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>task</code> doesn't spell out when the
coroutine frame is destroyed (i.e., when <code>handle.destroy()</code>
is called). As a result the lifetime of arguments passed to the
coroutine and/or of local variables in the coroutine body may be
longer than expected.
</p>
<p>
The intention is that the coroutine frame is destroyed before any
of the completion functions is called. One implication of this
requirement is that the result and error objects can't be stored
in the <code>promise_type</code> when the completion function is
called although the exposition-only members <code><i>result</i></code>
and <code><i>errors</i></code> imply exactly that. Instead the data
needs to be stored in the operation state object or it needs to be
moved to a different place before calling <code>destroy()</code>.
</p>
<p>
The proposed resolution is to add a paragraph to the specification
of <code>promise_type</code> in 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> that spells
out that the coroutine frame is destroyed before any of the completion
functions is called. To actually do that the exposition-only members
<code><i>result</i></code> and <code><i>errors</i></code> can't
remain as members of the <code>promise_type</code>. While writing
the relevant change it turned out that <code><i>errors</i></code>
is a <code>variant</code> which only ever stores an
<code>exception_ptr</code> (the other potential errors are immediately
reported via the awaiter return from <code>yield_value</code>).
Thus, the <code>variant</code> can be replaced with an
<code>exception_ptr</code>.
</p>


<p id="res-4339"><b>Proposed resolution:</b></p>
<p>
In 33.13.6.4 <a href="https://timsong-cpp.github.io/cppwp/task.state">[task.state]</a>, add
exposition-only data members <code><i>result</i></code> and
<code><i>error</i></code> to the exposition-only  class
<code><i>state</i></code>:
<blockquote>
<pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  template&lt;receiver Rcvr&gt;
  class task&lt;T, Environment&gt;::<i>state</i> {           // <i>exposition only</i>
  ...
  Environment               <i>environment</i>;   // <i>exposition only</i>
  <ins>optional&lt;T&gt;               <i>result</i>;        // <i>exposition only; present only if</i> is_void_v&lt;T&gt; <i>is</i> false</ins>
  <ins>exception_ptr             <i>error</i>;         // <i>exposition-only</i></ins>
};
}
</pre>
</blockquote>
</p>
<p>
Remove the exposition-only data members
<code><i>result</i></code> and <code><i>errors</i></code> from
the class <code>promise_type</code> in
33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a>:
<blockquote>
<pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task&lt;T, Environment&gt;::promise_type {
  ...
  stop_token_type   <i>token</i>;  // <i>exposition only</i>
  <del>optional&lt;T&gt;       <i>result</i>; // <i>exposition only; present only if</i> is_void_v&lt;T&gt; <i>is</i> false</del>
  <del><i>error-variant</i>     <i>errors</i>; // <i>exposition only</i></del>
};
}
</pre>
</blockquote>
</p>
<p>
The definition of <code><i>error-variant</i></code> isn't needed, i.e., remove 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> paragraph 2:
<blockquote>
<p><del>
-2- <code><i>error-variant</i></code> is a <code>variant&lt;monostate, remove_cvref_t&lt;E&gt;...&gt;</code>, with duplicate types removed, where <code>E...</code> are template arguments of the specialization of <code>execution::completion_signatures</code> denoted by <code>error_types</code>.
</del></p>
</blockquote>
</p>
<p>
In 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> change paragraph 7 to use the members added to <code><i>state</i></code>:
<blockquote>
<pre>auto final_suspend() noexcept</pre>
<p>-7- <i>Returns</i>: An awaitable object of unspecified type (7.6.2.4 <a href="https://timsong-cpp.github.io/cppwp/expr.await">[expr.await]</a>) whose member functions arrange for the completion of the asynchronous operation associated with <code><i>STATE</i>(*this)</code><del> by invoking</del><ins>. Let <code>st</code> be a reference to <code><i>STATE</i>(*this)</code>. The asynchronous completion first destroys the coroutine frame using <code>st.<i>handle</i>.destroy()</code> and then invokes</ins>:</p>

<ul>
<li>-7.1- <code>set_error(std::move(<del><i>RCVR</i>(*this)</del><ins>st.<i>rcvr</i></ins>), std::move(<del>e</del><ins>st.<i>error</i></ins>))</code> if <del><code><i>errors</i>.index()</code> is greater than zero and <code>e</code> is the value held by <code><i>errors</i></code></del><ins><code>bool(st.<i>error</i>)</code> is <code>true</code></ins>, otherwise</li>
<li>-7.2- <code>set_value(std::move(<del><i>RCVR</i>(*this)</del><ins>st.<i>rcvr</i></ins>))</code> if <code>is_void&lt;T&gt;</code> is <code>true</code>, and otherwise</li>
<li>-7.3- <code>set_value(std::move(<del><i>RCVR</i>(*this)</del><ins>st.<i>rcvr</i></ins>), *<ins>st.</ins><i>result</i>)</code>.</li>
</ul>
</blockquote>
</p>
<p>
Change the specification of <code>yield_value</code> to destroy the coroutine frame before invoking the <code>set_error</code> completion, i.e., change 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> paragraph 9:
<blockquote>
<p>-9- <i>Returns</i>: An awaitable object of unspecified type ([expr.await]) whose member functions arrange for the calling coroutine to be suspended and then completes the asynchronous operation associated with <code><i>STATE</i>(*this)</code><del> by</del><ins>. Let <code>st</code> be a reference to <code><i>STATE</i>(*this)</code>. Then the asynchronous operation completes by first destroying the coroutine frame using <code>st.<i>handle</i>.destroy()</code> and then</ins> invoking <code>set_error(std::move(<del><i>RCVR</i>(*this)</del><ins>st.<i>rcvr</i></ins>), Cerr(std::move(err.error)))</code>.
</p>
</blockquote>
</p>
<p>
Change the specification of <code>unhandled_stopped</code> to destroy the coroutine frame before invoking the <code>set_stopped</code> completion, i.e., change 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> paragraph 13:
<blockquote>
<pre>coroutine_handle&lt;&gt; unhandled_stopped();</pre>
<p>-13- <i>Effects</i>: Completes the asynchronous operation associated with <code><i>STATE</i>(*this)</code><del> by</del><ins>. Let <code>st</code> be a reference to <code><i>STATE</i>(*this)</code>. The asynchronous operation is completed by first destroying the coroutine frame using <code>st.<i>handle</i>.destroy()</code> and then</ins> invoking <code>set_stopped(std::move(<del><i>RCVR</i>(*this)</del><ins>st.<i>rcvr</i></ins>))</code>.</p>
</blockquote>
</p>





<hr>
<h3 id="4340"><a href="4340">4340</a>. <code>task::promise_type::unhandled_stopped()</code> should be <code>noexcept</code></h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The function <code>task::promise_type::unhandled_stopped()</code>
is called from <code>set_stopped()</code> of a receiver and calls
<code>set_stopped</code> itself. These functions are required to
be <code>noexcept</code>. Thus, <code>unhandled_stopped()</code>
can't throw an exception and should be marked <code>noexcept</code>.
All other declarations of <code>unhandled_stopped()</code> are
already marked <code>noexcept</code> but
<code>task::promise_type::unhandled_stopped()</code> isn't.
</p>


<p id="res-4340"><b>Proposed resolution:</b></p>
<p>
In the synopsis in 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> add <code>noexcept</code>
to the declaration of <code>task::promise_type::unhandled_stopped()</code>:
<blockquote><pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task&lt;T, Environment&gt;::promise_type {
     ...
    coroutine_handle&lt;&gt; unhandled_stopped() <ins>noexcept</ins>;
    ...
  };
}
</pre></blockquote>
</p>
<p>
In the specification in 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> paragraph 13 add <code>noexcept</code>:
<blockquote>
<pre>
coroutine_handle&lt;&gt; unhandled_stopped() <ins>noexcept</ins>;
</pre>
<p>-13- <i>Effects</i>: Completes the asynchronous operation
associated with <code><i>STATE</i>(*this)</code> by invoking
<code>set_stopped(std::move(<i>RCVR</i>(*this)))</code>.</p>
</blockquote> 
</p>





<hr>
<h3 id="4341"><a href="4341">4341</a>. Missing rvalue reference qualification for <code>task::connect()</code></h3>
<p><b>Section:</b> 33.13.6.2 <a href="https://timsong-cpp.github.io/cppwp/task.class">[task.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.class">active issues</a> in [task.class].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.class">issues</a> in [task.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Coroutines can't be copied. Thus, a <code>task</code> can be
<code>connect()</code> just once.  To represent that
<code>task::connect()</code> should be rvalue reference qualified
but currently it isn't.
</p>


<p id="res-4341"><b>Proposed resolution:</b></p>
<p>
In the synopsis in 33.13.6.2 <a href="https://timsong-cpp.github.io/cppwp/task.class">[task.class]</a> add rvalue
reference qualification to <code>task::connect()</code>:
<blockquote><pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task {
    ...
    template&lt;receiver Rcvr&gt;
        <i>state</i>&lt;Rcvr&gt; connect(Rcvr&amp;&amp; rcvr) <ins>&amp;&amp;</ins>;
    ...
  }
}
</pre></blockquote>
</p>
<p>
In the specification in 33.13.6.3 <a href="https://timsong-cpp.github.io/cppwp/task.members">[task.members]</a> paragraph 3 add rvalue
reference qualification to <code>task::connect()</code>:
<blockquote>
<pre>
template&lt;receiver Rcvr&gt;
    <i>state</i>&lt;Rcvr&gt; connect(Rcvr&amp;&amp; rcvr) <ins>&amp;&amp;</ins>;
</pre>
<p>-3- <i>Precondition</i>: <code>bool(handle)</code> is <code>true</code>.</p>
<p>-4- <i>Effects</i>: Equivalent to:</p>
<pre>    return state&lt;Rcvr&gt;(exchange(handle, {}), std::forward&lt;Rcvr&gt;(recv));</pre>
</blockquote>
</p>





<hr>
<h3 id="4342"><a href="4342">4342</a>. Missing rvalue reference qualification for <code>task_scheduler::ts-sender::connect()</code></h3>
<p><b>Section:</b> 33.13.5 <a href="https://timsong-cpp.github.io/cppwp/exec.task.scheduler">[exec.task.scheduler]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.task.scheduler">active issues</a> in [exec.task.scheduler].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.task.scheduler">issues</a> in [exec.task.scheduler].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The result of <code>schedule(sched)</code> for a scheduler
<code>sched</code> is only required to be movable. An object of
this type may need to be forwarded to an operation state constructor
by <code>task_scheduler::<i>ts-sender</i>::connect</code>. Thus,
this function should be qualified with an rvalue reference.
</p>


<p id="res-4342"><b>Proposed resolution:</b></p>
<p>
Add an rvalue qualifier to the declaration of <code>connect</code> in 33.13.5 <a href="https://timsong-cpp.github.io/cppwp/exec.task.scheduler">[exec.task.scheduler]</a> paragraph 8:
<blockquote>
<pre>
namespace std::execution {
  class task_scheduler::ts-sender {     // exposition only
  public:
    using sender_concept = sender_t;

    template&lt;receiver Rcvr&gt;
      <i>state</i>&lt;Rcvr&gt; connect(Rcvr&amp;&amp; rcvr)<ins> &amp;&amp;</ins>;
  };
}
</pre>
</blockquote>
</p>
<p>
In the specification in 33.13.5 <a href="https://timsong-cpp.github.io/cppwp/exec.task.scheduler">[exec.task.scheduler]</a> paragraph 10 add an rvalue qualifier to <code>connect</code>:
<blockquote>
<pre>
template&lt;receiver Rcvr&gt;
  <i>state</i>&lt;Rcvr&gt; connect(Rcvr&amp;&amp; rcvr)<ins> &amp;&amp;</ins>;
</pre>
<p>-10- <i>Effects</i>: Let <i>r</i> be an object of a type that
models receiver and whose completion handlers result in invoking
the corresponding completion handlers of <code>rcvr</code> or copy thereof.
Returns an object of type <code><i>state</i>&lt;Rcvr&gt;</code> containing an operation state
object initialized with <code>connect(<i>SENDER</i>(*this), std::move(<i>r</i>))</code>.
</p>
</blockquote>
</p>





<hr>
<h3 id="4343"><a href="4343">4343</a>. Missing default template arguments for <code>task</code></h3>
<p><b>Section:</b> 33.13.6.2 <a href="https://timsong-cpp.github.io/cppwp/task.class">[task.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.class">active issues</a> in [task.class].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.class">issues</a> in [task.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The design discussion of <code>task</code> describes defaults for
the two template parameters <code>T</code> and <code>Environment</code>
of <code>task</code> but these defaults are not reflected in the
synopsis of 33.13.6.2 <a href="https://timsong-cpp.github.io/cppwp/task.class">[task.class]</a>.
This is an oversight and should be fixed.  The default for
<code>T</code> should be <code>void</code> and the default for
<code>Environment</code> should be <code>env&lt;&gt;</code> (the
design paper used <code>empty_env</code> but this <code>struct</code>
was replaced by the class template <code>env</code> by <a href="https://wg21.link/P3325R5" title=" A Utility for Creating Execution Environments">P3325R5</a>).
</p>
<p>
There could be a counter argument to defining a default for the
<code>Environment</code> template parameter: this type is used to
determine various customizations of <code>task</code>, e.g., the
<code>allocator_type</code>, the <code>scheduler_type</code>, and
the <code>stop_source_type</code>. Leaving the type a required
argument means that a future standard could choose a possibly better
default than the types determined when the <code>Environment</code>
doesn't define them. On the other hand, a future standard could
provide a suitable alias with modified types under a different
name and/or a different namespace. Based on the LEWG discussion
on 2025-08-26 the direction is to add the default arguments.
</p>


<p id="res-4343"><b>Proposed resolution:</b></p>
<p>
Add default template arguments for <code>task</code> for
<code>T = void</code> and <code>Environment = env&lt;&gt;</code>
in the synopsis of 33.13.6.2 <a href="https://timsong-cpp.github.io/cppwp/task.class">[task.class]</a>:
<blockquote><pre>
namespace std::execution {
  template&lt;class T <ins>= void</ins>, class Environment <ins>= env&lt;&gt;</ins>&gt;
  class task {
     ...
  };
}
</pre></blockquote>
</p>





<hr>
<h3 id="4344"><a href="4344">4344</a>. <code>affine_on</code> has no specification for the default</h3>
<p><b>Section:</b> 33.13.3 <a href="https://timsong-cpp.github.io/cppwp/exec.affine.on">[exec.affine.on]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.affine.on">active issues</a> in [exec.affine.on].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.affine.on">issues</a> in [exec.affine.on].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording of <code>affine_on</code> doesnt have a specification
for the default implementation. For other algorithms the default
implementation is specified.
</p>
<p>
The intention for <code>affine_on</code> was to all
optimisation/customisation in a way reducing the necessary scheduling:
if the implementation can determine if a sender completed already
on the correct execution agent it should be allowed to avoid
scheduling. A specification should provide enough lattitude to
allow that.
</p>


<p id="res-4344"><b>Proposed resolution:</b></p>
<p>
Add a new paragraph to the specification of <code>affine_on</code>
in 33.13.3 <a href="https://timsong-cpp.github.io/cppwp/exec.affine.on">[exec.affine.on]</a> providing
a specification for the default implementation:
</p>
<p>
<blockquote>
<p><ins>
-6- Let <code>sndr</code> and <code>env</code> be subexpressions
such that <code>Sndr</code> is <code>decltype((sndr))</code>. If
<code>sender-for&lt;Sndr, affine_on_t&gt;</code> is <code>false</code>, then the expression
<code>affine_on.transform_sender(sndr, env)</code> is ill-formed; otherwise, it
is equivalent to:
</ins>
</p>
<pre>
  <ins>
auto [_, sch, child] = sndr;
return transform_sender(
  <i>query-with-default</i>(get_domain, sch, default_domain()),
  continues_on(std::move(child), std::move(sch)));
</ins>
</pre>
<p><ins>except that <code>sch</code> is only evaluated once. </ins></p>
</blockquote>
</p>





<hr>
<h3 id="4345"><a href="4345">4345</a>. <code>task::promise_type::return_value</code> default template parameter</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The template parameter <code>V</code> of
<code>task::promise_type::return_value</code> doesn't have a default
template argument specified. Specifying a default template argument of <code>T</code>
would enable use of <code>co_return { ... }</code> which would be
consistent with normal <code>return</code> statements. This feature
was not discussed in the design paper but based on the LEWG discussion
on 2025-08-26 it is considered to be more a bug fix than a new feature.
</p>


<p id="res-4345"><b>Proposed resolution:</b></p>
<p>
Add a default template argument of <code>T</code> to the template
parameter <code>V</code> of <code>task::promise_type::return_value</code>
in the synopsis of 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a>:
<blockquote><pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task&lt;T, Environment&gt;::promise_type {
     ...
    template&lt;typename V <ins>= T</ins>&gt;
    void return_value(V&amp;&amp; value);
    ...
  };

}
</pre></blockquote>
</p>





<hr>
<h3 id="4346"><a href="4346">4346</a>. <code>task::promise_type::return_void</code>/<code>value</code> lack a specification</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis for <code>std::execution::task&lt;T,
E&gt;::promise_type</code> declares <code>return_void()</code> or
<code>return_value(V&amp;&amp;)</code>. However, there is no
specification of what these functions actually do.
<code>return_void()</code> doesnt need to do anything at all.
<code>return_value(V&amp;&amp; v)</code> needs to store <code>v</code>
into the <code><i>result</i></code>.
</p>


<p id="res-4346"><b>Proposed resolution:</b></p>
<p>
Insert the following paragraphs in 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a>
after the specification of <code>unhandled_stopped</code>:
</p>
<p>
<blockquote>
<pre>coroutine_handle&lt;&gt; unhandled_stopped();</pre>
<p>-13- <i>Effects</i>: Completes the asynchronous operation associated with <code><i>STATE</i>(*this)</code> by invoking <code>set_stopped(std::move(<i>RCVR</i>(*this)))</code>.</p>
<p>-14- <i>Returns</i>: <code>noop_coroutine()</code>.</p>
<pre><ins>void return_void();</ins></pre>
<p><ins>-15- <i>Effects</i>: does nothing.</ins></p>
<pre><ins>
template&lt;class V&gt;
  void return_value(V&amp;&amp; v);
</ins></pre>
<p><ins>-16- <i>Effects</i>: Equivalent to <code><i>result</i>.emplace(std::forward&lt;V&gt;(v))</code>.</ins></p>
<pre>unspecified get_env() const noexcept;</pre>
<p>-1<del>5</del><ins>7</ins>- <i>Returns</i>: An object <code>env</code> such that queries are forwarded as follows:</p>
</blockquote>
</p>





<hr>
<h3 id="4347"><a href="4347">4347</a>. <code>task</code>'s stop source is always created</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The type <code>task&lt;...&gt;::promise_type</code> has exposition-only
members <code><i>source</i></code> and <code><i>token</i></code>.
These can be interpreted as always existing which would be a
performance issue for former and an unnecessary constraints for the
latter (because stop tokens aren't required to be default constructible).
</p>
<p>
The intent is that the stop token obtained from the
<code>get_stop_token</code> query of the receiver's environment is
used. Only if this type is different from the <code>task</code>'s
<code>stop_token_type</code> a stop source of type
<code>stop_source_type</code> needs to be created when the
<code>get_stop_token</code> query is used on the promise type's
environment. The stop token doesn't need to be stored at all: it
can either be obtained from the receiver's environment or from the
stop source. The fix is to show the stop source as an optionally
present member of of the operation state and it should be of type
<code>std::optional&lt;stop_source_type&gt;</code> to imply that
it is only created when accessed.
</p>


<p id="res-4347"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4348"><a href="4348">4348</a>. <code>task</code> doesn't support symmetric transfer</h3>
<p><b>Section:</b> 33.13.6.2 <a href="https://timsong-cpp.github.io/cppwp/task.class">[task.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.class">active issues</a> in [task.class].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.class">issues</a> in [task.class].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <code>task</code> doesn't require symmetric
transfer which can help with stack overflow. Also, when another
<code>task</code> is <code>co_await</code>ed the scheduler on which
the <code>task</code> resumes is known and can be used to avoid
unnecessary scheduling by comparing the scheduler currently installed
by in two <code>task</code>s involved.
</p>


<p id="res-4348"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4349"><a href="4349">4349</a>. <code>task</code> is not actually started lazily</h3>
<p><b>Section:</b> 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2025-09-01 <b>Last modified:</b> 2025-09-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#task.promise">active issues</a> in [task.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#task.promise">issues</a> in [task.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording for <code>task&lt;...&gt;::promise_type::initial_suspend</code>
in 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> paragraph 6
(second bullet) may imply that a task is eagerly started, i.e., that the
awaiter return from <code>initial_suspend()</code> immediately starts
the scheduling operation and cause the <code>task</code> to be resumed. At
the very least the second bullet of the wording should be clarified such
that the scheduling operation is only started when the coroutine gets
resumed.
</p>
<p>
An alternative resolution it have <code>initial_suspend()</code>
return <code>std::suspend_always</code> implicitly requiring that
the <code>task</code> gets <code>start()</code>ed from the correct
execution context. This approach has the advantage of avoiding
unnecessary scheduling operations for the likely common case when
<code>task</code>s are started from the correct context.
</p>


<p id="res-4349"><b>Proposed resolution:</b></p>
<p>
Change the declaration of <code>initial_suspend()</code> in the synopsis
of 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> to use
<code>suspend_always</code>, directly provide a definition, and add
various qualifiers:
<blockquote>
<pre>
namespace std::execution {
  template&lt;class T, class Environment&gt;
  class task&lt;T, Environment&gt;::promise_type {
    ...
    <del>auto</del><ins>static constexpr suspend_always</ins> initial_suspend() noexcept<del>;</del><ins>{ return {}; }</ins>
    ...
  };

}
</pre>
</blockquote>
</p>
<p>
Remove 33.13.6.5 <a href="https://timsong-cpp.github.io/cppwp/task.promise">[task.promise]</a> paragraph 6 entirely:
<blockquote>
<pre><del>auto initial_suspend() noexcept;</del></pre>
<p><del>-6- <i>Returns:</i> An awaitable object of unspecified type ([expr.await]) whose member functions arrange for</del></p>
<p><del>-6.1- - the calling coroutine to be suspended,</del></p>
<p><del>-6.2- - the coroutine to be resumed on an execution agent of the execution resource associated with <code><i>SCHED</i>(*this)</code>.</del></p>
</blockquote>
</p>





<hr>
<h3 id="4350"><a href="4350">4350</a>. Should flat adaptors use <code class='backtick'>insert_range</code> when available?</h3>
<p><b>Section:</b> 23.6.8 <a href="https://timsong-cpp.github.io/cppwp/flat.map">[flat.map]</a>, 23.6.9 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap">[flat.multimap]</a>, 23.6.11 <a href="https://timsong-cpp.github.io/cppwp/flat.set">[flat.set]</a>, 23.6.12 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset">[flat.multiset]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-09-05 <b>Last modified:</b> 2025-09-05</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#flat.map">active issues</a> in [flat.map].</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map">issues</a> in [flat.map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As specified in 23.6.3.4 <a href="https://timsong-cpp.github.io/cppwp/queue.mod">[queue.mod]</a>,
<code class='backtick'>std::queue::push_range</code> is guaranteed to use <code class='backtick'>c.append_range</code> if that exists.
For <code class='backtick'>flat_map</code> and its flat friends, we only ever use <code class='backtick'>c.insert</code> and never try
to use <code class='backtick'>c.insert_range</code>, <code class='backtick'>c.append_range</code>, etc.
LWG thinks the "as if by" wording allows implementations to use <code class='backtick'>insert_range</code>
when the container type being adapted is <code class='backtick'>std::vector</code> but not for user-defined
containers.
Should the flat adaptors follow <code class='backtick'>std::queue</code> and guarantee that they will use
the <code class='backtick'>xxx_range</code> member if they exist?
That would mean that user containers need to ensure that any member functions
with those names must behave as expected, but we already require that for
<code class='backtick'>std::queue</code>.
</p>


<p id="res-4350"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4351"><a href="4351">4351</a>. <code><i>integral-constant-like</i></code> needs more <code class='backtick'>remove_cvref_t</code></h3>
<p><b>Section:</b> 23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-09-05 <b>Last modified:</b> 2025-09-07</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P2781R9" title=" std::constexpr_wrapper">P2781R9</a> tweaked the definition of
<code><i>integral-constant-like</i></code> to work with <code class='backtick'>constant_wrapper</code>,
like so:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
    concept <i>integral-constant-like</i> =                    <i>// exposition only</i>
      is_integral_v&lt;<ins>remove_cvref_t&lt;</ins>decltype(T::value)<ins>&gt;</ins>&gt; &amp;&amp;
      !is_same_v&lt;bool, remove_const_t&lt;decltype(T::value)&gt;&gt; &amp;&amp;
      convertible_to&lt;T, decltype(T::value)&gt; &amp;&amp;
      equality_comparable_with&lt;T, decltype(T::value)&gt; &amp;&amp;
      bool_constant&lt;T() == T::value&gt;::value &amp;&amp;
      bool_constant&lt;static_cast&lt;decltype(T::value)&gt;(T()) == T::value&gt;::value;
</pre>
</blockquote>
<p>
This was done so that <code>cw&lt;5&gt;</code> models the concept,
but it needs an additional tweak so that
<code>cw&lt;true&gt;</code> does not model it.
</p>


<p id="res-4351"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt;
    concept <i>integral-constant-like</i> =                    <i>// exposition only</i>
      is_integral_v&lt;remove_cvref_t&lt;decltype(T::value)&gt;&gt; &amp;&amp;
      !is_same_v&lt;bool, remove_<ins>cvref</ins><del>const</del>_t&lt;decltype(T::value)&gt;&gt; &amp;&amp;
      convertible_to&lt;T, decltype(T::value)&gt; &amp;&amp;
      equality_comparable_with&lt;T, decltype(T::value)&gt; &amp;&amp;
      bool_constant&lt;T() == T::value&gt;::value &amp;&amp;
      bool_constant&lt;static_cast&lt;decltype(T::value)&gt;(T()) == T::value&gt;::value;
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4352"><a href="4352">4352</a>. "operations on flat_multimap are equivalent to those of flat_map"</h3>
<p><b>Section:</b> 23.6.9.1 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap.overview">[flat.multimap.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2025-09-05 <b>Last modified:</b> 2025-09-05</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.6.9.1 <a href="https://timsong-cpp.github.io/cppwp/flat.multimap.overview">[flat.multimap.overview]</a> p4 says:
</p>
<blockquote>
Except as otherwise noted, operations on <code class='backtick'>flat_multimap</code> are equivalent to
those of <code class='backtick'>flat_map</code>, except that <code class='backtick'>flat_multimap</code> operations do not remove
or replace elements with equal keys.
<p>
[<i>Example 1</i>:<code class='backtick'>flat_multimap</code> constructors and emplace do not erase
non-unique elements after sorting them.
&mdash; <i>end example</i>]
</p>
</blockquote>

<p>
This doesn't really work, because there is no <code class='backtick'>flat_map</code> operation that is
equivalent to the constructors and <code class='backtick'>insert</code> and <code class='backtick'>insert_range</code> functions that
take a <code class='backtick'>sorted_equivalent_t</code> tag argument. The <code class='backtick'>flat_map</code> operations that the
wording intends to refer to take a <code class='backtick'>sorted_unique_t</code> tag argument.
It's a bit of a stretch to say they're equivalent when they don't even have
the same parameters, so we need some weasel words here.
</p>



<p id="res-4352"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4353"><a href="4353">4353</a>. Uses of <code><i>MANDATE-NOTHROW</i></code> in CPOs should not enclose CPO argument sub-expressions</h3>
<p><b>Section:</b> 33 <a href="https://timsong-cpp.github.io/cppwp/exec">[exec]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-25 <b>Last modified:</b> 2025-09-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are a number of CPOs defined in 33 <a href="https://timsong-cpp.github.io/cppwp/exec">[exec]</a> which have behaviour specified in terms of being 
expression-equivalent to a <code><i>MANDATE-NOTHROW</i></code> expression.
<p/>
The intent of this is that we want to make sure that the call that the CPO dispatches to is marked <code class='backtick'>noexcept</code>.
<p/>
However, the way that these CPOs are currently specified in terms of sub-expressions means that we are currently 
requiring that all of the expressions passed as arguments to the CPO are also <code class='backtick'>noexcept</code>. Outside of defining 
these CPOs as preprocessor macros, this is unimplementable &mdash; and also undesirable behaviour.
<p/>
For example, 33.7.2 <a href="https://timsong-cpp.github.io/cppwp/exec.set.value">[exec.set.value]</a> defines <code class='backtick'>set_value(rcvr, vs...)</code> to be equivalent to 
<code><i>MANDATE-NOTHROW</i>(rcvr.set_value(vs...))</code> for sub-expressions <code class='backtick'>rcvr</code> and pack of sub-expressions 
<code class='backtick'>vs</code>.
<p/>
In 33.1 <a href="https://timsong-cpp.github.io/cppwp/exec.general">[exec.general]</a> p5 we define <code><i>MANDATE-NOTHROW</i>(expr)</code> as expression-equivalent to 
<code class='backtick'>expr</code> but mandate that <code class='backtick'>noexcept(expr)</code> is <code class='backtick'>true</code>.
<p/>
So in the above definition of <code class='backtick'>set_value(rcvr, vs...)</code> we are actually requiring that the expression 
<code class='backtick'>noexcept(rcvr.set_value(vs...))</code> is <code class='backtick'>true</code>.
<p/>
This is only true if all of the sub-expressions are <code class='backtick'>noexcept</code>, i.e. all of the following expressions are <code class='backtick'>true</code>.
</p>
<ul>
<li><p><code>noexcept(rcvr)</code>,</p></li>
<li><p><code>(noexcept(vs) &amp;&amp; ...)</code>,</p></li>
<li><p>the member-function call to <code class='backtick'>rcvr.set_value(vs...)</code> including any implicit conversions of arguments.</p></li>
</ul>
<p>
This means that if, for example, one of the sub-expressions in the pack <code class='backtick'>vs</code> was a call to some potentially-throwing 
function then the overall <code class='backtick'>set_value</code> expression would be violating the mandates requirement.
<p/>
For example:
</p>
<blockquote><pre>
struct my_receiver 
{
  void set_value(int x) noexcept;
};

int get_value() noexcept(false);

my_receiver r;
std::execution::set_value(r, get_value()); // <span style="color:#C80000;font-weight:bold">fails MANDATE-NOTHROW mandates</span>
</pre></blockquote>
<p>
Instead, we need to redefine these CPOs as being expression-equivalent to something that does not require that the 
argument expressions to the CPO themselves are <code class='backtick'>noexcept</code> &mdash; only what will be in the body of the CPO function.
<p/>
For example, we could change 33.7.2 <a href="https://timsong-cpp.github.io/cppwp/exec.set.value">[exec.set.value]</a> to define <code class='backtick'>set_value(rcvr, vs...)</code> as expression-equivalent to:
</p>
<blockquote><pre>
[](auto&amp;&amp; rcvr2, auto&amp;&amp;... vs2) noexcept -&gt; 
  decltype(auto) requires requires { std::forward&lt;decltype(rcvr2)&gt;(rcvr2).set_value(std::forward&lt;decltype(vs2)&gt;(vs2)...); } 
{
  return <i>MANDATE-NOTHROW</i>(std::forward&lt;decltype(rcvr2)&gt;(rcvr2).set_value(std::forward&lt;decltype(vs2)&gt;(vs2)...));
}(rcvr, vs...)
</pre></blockquote>
<p>
The following sections all contain problematic uses of <code><i>MANDATE-NOTHROW</i></code>:
</p>
<ul>
<li><p>33.5.2 <a href="https://timsong-cpp.github.io/cppwp/exec.get.allocator">[exec.get.allocator]</a></p></li>
<li><p>33.5.3 <a href="https://timsong-cpp.github.io/cppwp/exec.get.stop.token">[exec.get.stop.token]</a></p></li>
<li><p>33.5.4 <a href="https://timsong-cpp.github.io/cppwp/exec.get.env">[exec.get.env]</a></p></li>
<li><p>33.5.5 <a href="https://timsong-cpp.github.io/cppwp/exec.get.domain">[exec.get.domain]</a></p></li>
<li><p>33.5.6 <a href="https://timsong-cpp.github.io/cppwp/exec.get.scheduler">[exec.get.scheduler]</a></p></li>
<li><p>33.5.7 <a href="https://timsong-cpp.github.io/cppwp/exec.get.delegation.scheduler">[exec.get.delegation.scheduler]</a></p></li>
<li><p>33.5.8 <a href="https://timsong-cpp.github.io/cppwp/exec.get.fwd.progress">[exec.get.fwd.progress]</a></p></li>
<li><p>33.5.9 <a href="https://timsong-cpp.github.io/cppwp/exec.get.compl.sched">[exec.get.compl.sched]</a></p></li>
<li><p>33.5.10 <a href="https://timsong-cpp.github.io/cppwp/exec.get.await.adapt">[exec.get.await.adapt]</a></p></li>
<li><p>33.7.2 <a href="https://timsong-cpp.github.io/cppwp/exec.set.value">[exec.set.value]</a></p></li>
<li><p>33.7.3 <a href="https://timsong-cpp.github.io/cppwp/exec.set.error">[exec.set.error]</a></p></li>
<li><p>33.7.4 <a href="https://timsong-cpp.github.io/cppwp/exec.set.stopped">[exec.set.stopped]</a></p></li>
<li><p>33.8.2 <a href="https://timsong-cpp.github.io/cppwp/exec.opstate.start">[exec.opstate.start]</a></p></li>
</ul>


<p id="res-4353"><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3 id="4354"><a href="4354">4354</a>. Reconsider <code class='backtick'>weakly_parallel</code> as the default <code class='backtick'>forward_progress_guarantee</code></h3>
<p><b>Section:</b> 33.5.8 <a href="https://timsong-cpp.github.io/cppwp/exec.get.fwd.progress">[exec.get.fwd.progress]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-25 <b>Last modified:</b> 2025-09-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code class='backtick'>get_forward_progress_guarantee</code> CPO is intended to allow querying a scheduler as for what sort of 
forward-progress guarantee it provides. Algorithms may use this to determine whether it is safe to execute 
certain operations on a given scheduler. If a scheduler does not customize this query, the query will 
fall back to returning a forward-progress guarantee of weakly_parallel.
<p/>
I think we should reconsider what this default should be returning and suggest it should instead return 
<code class='backtick'>parallel</code> by default, as this will be by far the most common kind of scheduler, i.e. a scheduler that 
executes on <code class='backtick'>std::thread</code>-like execution agents and that maintains a queue of scheduled tasks.
<p/>
I expect it to be common that authors of schedulers may forget to customize the 
<code class='backtick'>get_forward_progress_guarantee_t</code> query and just leave it at the default. This will likely leave their 
scheduler reporting a weaker guarantee than it actually provides and thus not being usable within generic 
algorithms that require at least parallel forward progress.
<p/>
For example, the <code class='backtick'>run_loop</code> execution context defined in 33.12.1 <a href="https://timsong-cpp.github.io/cppwp/exec.run.loop">[exec.run.loop]</a> does not define 
its scheduler to customize the <code class='backtick'>get_forward_progress_guarantee_t</code>. This means it will report the default 
value of <code class='backtick'>weakly_parallel</code>.
<p/>
However, the scheduled operations will run on the thread that calls <code class='backtick'>run_loop::run()</code> and thus will 
inherit its forward-progress guarantees. As this function might block and is therefore unsafe to invoke 
it from a thread/agent with <code class='backtick'>weakly_parallel</code> forward progress guarantees (which should probably be 
explicitly specified as having undefined-behaviour) we can safely assume that <code class='backtick'>run_loop</code>'s scheduler 
can provide parallel forward-progress guarantee.
<p/>
It's not clear whether the current <code class='backtick'>run_loop</code> specification defaulting to its scheduler having 
<code class='backtick'>weakly_parallel</code> forward progress guarantee is intentional or unintentional here. However, forgetting 
to define the <code class='backtick'>get_forward_progress_guarantee</code> query on a scheduler is something I expect to be fairly common.
<p/>
Schedulers that provide <code class='backtick'>weakly_parallel</code> (or in future, <code class='backtick'>concurrent</code>) forward progress guarantees require 
implementations to be much more aware of the fact that these are the guarantees they are providing and 
thus could be more expected to customize the <code class='backtick'>get_forward_progress_guarantee</code> query to return the 
respective values.
</p>


<p id="res-4354"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.5.8 <a href="https://timsong-cpp.github.io/cppwp/exec.get.fwd.progress">[exec.get.fwd.progress]</a> as indicated:</p>

<blockquote>
<p>
-2- The name <code class='backtick'>get_forward_progress_guarantee</code> denotes a query object. For a subexpression <code class='backtick'>sch</code>, let <code class='backtick'>Sch</code>
be <code class='backtick'>decltype((sch))</code>. If <code class='backtick'>Sch</code> does not satisfy <code class='backtick'>scheduler</code>, <code class='backtick'>get_forward_progress_guarantee</code> is ill-formed.
Otherwise, <code class='backtick'>get_forward_progress_guarantee(sch)</code> is expression-equivalent to:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; <code><i>MANDATE-NOTHROW</i>(<i>AS-CONST</i>(sch).query(get_forward_progress_guarantee))</code> 
if that expression is well-formed.
<p/>
<i>Mandates</i>: The type of the expression above is <code class='backtick'>forward_progress_guarantee</code>.
</p></li>
<li><p>(2.2) &mdash; Otherwise, <code>forward_progress_guarantee::<del>weakly_</del>parallel</code>.</p></li>
</ol>

</blockquote>

</li>

</ol>





<hr>
<h3 id="4355"><a href="4355">4355</a>. <code><i>connect-awaitable()</i></code> should mandate <code class='backtick'>rcvr</code> can receive all completion-signals rather than using constraints</h3>
<p><b>Section:</b> 33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-27 <b>Last modified:</b> 2025-09-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.connect">active issues</a> in [exec.connect].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.connect">issues</a> in [exec.connect].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a> p6, the wording for the <code class='backtick'>connect()</code> customization-point defines a case that is 
expression-equivalent to <code><i>connect-awaitable</i>(new_sndr, rcvr)</code>.
<p/>
The <code><i>connect-awaitable</i></code> function is specified in p5 as having the signature:
</p>
<blockquote><pre>
<i>operation-state-task</i> <i>connect-awaitable</i>(DS sndr, DR rcvr) requires receiver_of&lt;DR, Sigs&gt;;
</pre></blockquote>
<p>
The requires-clause constrains this overload to ensure that the receiver, <code class='backtick'>rcvr</code>, can accept all of the 
completion signatures listed in <code class='backtick'>Sigs</code>. This means that <code class='backtick'>connect()</code> will SFINAE out if the receiver cannot 
accept all of the completion signatures, rather than this being ill-formed.
<p/>
However, this seems inconsistent with the handling of the case that dispatches to <code>new-sndr.connect(rcvr)</code> 
which does not constrain on this. It is also redundant with the <i>Mandates</i> element in p6 which mandates 
that the following is satisfied:
</p>
<blockquote><pre>
receiver_of&lt;Rcvr, completion_signatures_of_t&lt;Sndr, env_of_t&lt;Rcvr&gt;&gt;&gt;
</pre></blockquote>
<p>
The constraint on <code><i>connect-awaitable</i></code> should either be removed or replaced with a 
<i>Mandates</i> element. As <code><i>connect-awaitable</i></code> is only used within the definition of 
<code>connect()</code> and as <code>connect()</code> already mandates that <code class='backtick'>receiver_of</code> is satisfied, 
it seems sufficient to just remove this constraint from <code><i>connect-awaitable</i></code>.
</p>


<p id="res-4355"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a> as indicated:</p>

<blockquote>
<p>
-5- Let <code class='backtick'>V</code> name the type <code><i>await-result-type</i>&lt;DS, <i>connect-awaitable-promise</i>&gt;</code>, 
let <code class='backtick'>Sigs</code> name the type
</p>
<blockquote><pre>
completion_signatures&lt;
  <i>SET-VALUE-SIG</i>(V), // <i>see 33.9.3 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.concepts">[exec.snd.concepts]</a></i>
  set_error_t(exception_ptr),
  set_stopped_t()&gt;
</pre></blockquote>
<p>
and let <code><i>connect-awaitable</i></code> be an exposition-only coroutine defined as follows:
</p>
<blockquote><pre>
namespace std::execution {
  [&hellip;]
  <i>operation-state-task</i> <i>connect-awaitable</i>(DS sndr, DR rcvr) <del>requires receiver_of&lt;DR, Sigs&gt;</del> {
    exception_ptr ep;
    try {
      if constexpr (same_as&lt;V, void&gt;) {
        co_await std::move(sndr);
        co_await <i>suspend-complete</i>(set_value, std::move(rcvr));
      } else {
        co_await <i>suspend-complete</i>(set_value, std::move(rcvr), co_await std::move(sndr));
      }
    } catch(...) {
      ep = current_exception();
    }
    co_await <i>suspend-complete</i>(set_error, std::move(rcvr), std::move(ep));
  }
}  
</pre></blockquote>
<p>
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4356"><a href="4356">4356</a>. <code class='backtick'>connect()</code> should use <code class='backtick'>get_allocator(get_env(rcvr))</code> to allocate the coroutine-state for a 
<code><i>connect-awaitable</i></code> coroutine</h3>
<p><b>Section:</b> 33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-27 <b>Last modified:</b> 2025-09-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.connect">active issues</a> in [exec.connect].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.connect">issues</a> in [exec.connect].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording for <code class='backtick'>connect()</code> (33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a>) handles passing awaitable types as the sender argument 
by calling the <code><i>connect-awaitable</i></code>() coroutine and having it execute a <code class='backtick'>co_await</code> expression.
<p/>
The <code><i>connect-awaitable</i></code>() coroutine will typically need to dynamically allocate storage for 
the coroutine state and, as specified, this currently just always uses the global default allocator.
This is because the <code><i>connect-awaitable-promise</i></code> type does not define any member operator 
<code class='backtick'>new/delete</code> overloads.
<p/>
It seems desirable for this facility to use the allocator obtained from the receiver, by calling 
<code class='backtick'>get_allocator(get_env(rcvr))</code>, in order to allocate storage for the coroutine-state instead of always 
using global operator <code class='backtick'>new</code>. This would give the user at least some level of control over how this 
allocation is performed.
</p>


<p id="res-4356"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note: </i> This should cover the design intent, although we may want to spell this out 
more explicitly in terms of the exact semantics in a similar way to 25.8.5 <a href="https://timsong-cpp.github.io/cppwp/coro.generator.promise">[coro.generator.promise]</a> p17, 
which lists overloads of operator <code class='backtick'>new()</code> and describes the rebound allocator type which allocates storage 
in chunks of size <code class='backtick'>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.]
</p>
</blockquote>

<blockquote>
<p>
-5- Let <code class='backtick'>V</code> name the type <code><i>await-result-type</i>&lt;DS, <i>connect-awaitable-promise</i>&gt;</code>, 
let <code class='backtick'>Sigs</code> name the type
</p>
<blockquote><pre>
[&hellip;]
</pre></blockquote>
<p>
and let <code><i>connect-awaitable</i></code> be an exposition-only coroutine defined as follows:
</p>
<blockquote><pre>
namespace std::execution {
  [&hellip;]
}  
</pre></blockquote>
<p>
<ins>Any dynamically allocated storage required for the coroutine state allocated by an invocation 
of the form <code><i>connect-awaitable</i>(sndr, rcvr)</code> is allocated using the allocator obtained 
from <code class='backtick'>get_allocator(get_env(rcvr))</code>.</ins>
<p/>
-6- [&hellip;]
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4357"><a href="4357">4357</a>. <code><i>connect-awaitable</i></code> should use <code class='backtick'>is_void_v</code> to check for result-type of 
<code class='backtick'>co_await</code> expression instead of <code>same_as&lt;void&gt;</code></h3>
<p><b>Section:</b> 33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-27 <b>Last modified:</b> 2025-09-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.connect">active issues</a> in [exec.connect].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.connect">issues</a> in [exec.connect].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording in 33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a> p5 defines the <code><i>connect-awaitable</i>()</code> function as follows:
</p>
<blockquote><pre>
<i>operation-state-task</i> <i>connect-awaitable</i>(DS sndr, DR rcvr) requires receiver_of&lt;DR, Sigs&gt; {
  exception_ptr ep;
  try {
    if constexpr (same_as&lt;V, void&gt;) {
      co_await std::move(sndr);
      co_await <i>suspend-complete</i>(set_value, std::move(rcvr));
    } else {
      co_await <i>suspend-complete</i>(set_value, std::move(rcvr), co_await std::move(sndr));
    }
  } catch(...) {
    ep = current_exception();
  }
  co_await <i>suspend-complete</i>(set_error, std::move(rcvr), std::move(ep));
}
</pre></blockquote>
<p>
The use of <code>same_as&lt;V, void&gt;</code> in the if-constexpr condition does not cover the case where the 
result of the <code class='backtick'>co_await</code> expression has type <i>cv</i> <code class='backtick'>void</code>. It should use <code>is_void_v&lt;V&gt;</code> 
instead to allow it to match all <code class='backtick'>void</code> types, not just unqualified <code class='backtick'>void</code>.
</p>



<p id="res-4357"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.9.10 <a href="https://timsong-cpp.github.io/cppwp/exec.connect">[exec.connect]</a> as indicated:</p>

<blockquote>
<p>
-5- Let <code class='backtick'>V</code> name the type <code><i>await-result-type</i>&lt;DS, <i>connect-awaitable-promise</i>&gt;</code>, 
let <code class='backtick'>Sigs</code> name the type
</p>
<blockquote><pre>
completion_signatures&lt;
  <i>SET-VALUE-SIG</i>(V), // <i>see 33.9.3 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.concepts">[exec.snd.concepts]</a></i>
  set_error_t(exception_ptr),
  set_stopped_t()&gt;
</pre></blockquote>
<p>
and let <code><i>connect-awaitable</i></code> be an exposition-only coroutine defined as follows:
</p>
<blockquote><pre>
namespace std::execution {
  [&hellip;]
  <i>operation-state-task</i> <i>connect-awaitable</i>(DS sndr, DR rcvr) requires receiver_of&lt;DR, Sigs&gt; {
    exception_ptr ep;
    try {
      if constexpr (<del>same_as&lt;V, void&gt;</del><ins>is_void_v&lt;V&gt;</ins>) {
        co_await std::move(sndr);
        co_await <i>suspend-complete</i>(set_value, std::move(rcvr));
      } else {
        co_await <i>suspend-complete</i>(set_value, std::move(rcvr), co_await std::move(sndr));
      }
    } catch(...) {
      ep = current_exception();
    }
    co_await <i>suspend-complete</i>(set_error, std::move(rcvr), std::move(ep));
  }
}  
</pre></blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4358"><a href="4358">4358</a>. &sect;[exec.as.awaitable] is using "Preconditions:" when it should probably be described in the constraint</h3>
<p><b>Section:</b> 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-27 <b>Last modified:</b> 2025-09-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.as.awaitable">active issues</a> in [exec.as.awaitable].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.as.awaitable">issues</a> in [exec.as.awaitable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> bullet 7.2 it states:
</p>
<blockquote>
<ol style="list-style-type: none">
<li><p>(7.2) &mdash; Otherwise, <code>(void(p), expr)</code> if <code><i>is-awaitable</i>&lt;Expr, U&gt;</code> is <code class='backtick'>true</code>, 
where <code class='backtick'>U</code> is an unspecified class type that is not <code class='backtick'>Promise</code> and that lacks a member named <code class='backtick'>await_transform</code>.
<p/>
<i>Preconditions</i>: <code><i>is-awaitable</i>&lt;Expr, Promise&gt;</code> is <code class='backtick'>true</code> and the expression 
<code class='backtick'>co_await expr</code> in a coroutine with promise type <code class='backtick'>U</code> is expression-equivalent to the same expression 
in a coroutine with promise type <code class='backtick'>Promise</code>.</p></li>
</ol>
</blockquote>
<p>
The "<i>Preconditions</i>:" sentence there refers to static properties of the program and so seems like a 
better fit for a <i>Mandates</i>: element or for folding into the constraint.
<p/>
Also, in the part of the precondition above which says "&hellip; and the expression <code class='backtick'>co_await expr</code> in a 
coroutine with promise type <code class='backtick'>U</code> is expression-equivalent to the same expression in a coroutine with promise 
type <code class='backtick'>Promise</code>" it is unclear how this can be satisfied, as the types involved are different and therefore 
the expression cannot be expression-equivalent.
<p/>
I think perhaps what is intended here is something along the lines of the first expression having 
"effects equivalent to" the second expression, instead of "expression-equivalent to"?
<p/>
However, I think there is a more direct way to express the intent here, by instead just requiring that 
<code>decltype(<i>GET-AWAITER</i>(expr))</code> satisfies <code><i>is-awaiter</i>&lt;Promise&gt;</code>.
This checks whether <code class='backtick'>expr</code> would be a valid type to return from a <code class='backtick'>Promise::await_transform()</code> function.
</p>



<p id="res-4358"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> as indicated:</p>

<blockquote>
<p>
-7- <code class='backtick'>as_awaitable</code> is a customization point object. For subexpressions <code class='backtick'>expr</code> and <code class='backtick'>p</code> where <code class='backtick'>p</code> 
is an lvalue, <code class='backtick'>Expr</code> names the type <code class='backtick'>decltype((expr))</code> and <code class='backtick'>Promise</code> names the type 
<code>decay_t&lt;decltype((p))&gt;</code>, <code class='backtick'>as_awaitable(expr, p)</code> is expression-equivalent to, 
except that the evaluations of <code class='backtick'>expr</code> and <code class='backtick'>p</code> are indeterminately sequenced:
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; <code class='backtick'>expr.as_awaitable(p)</code> if that expression is well-formed.
<p/>
<i>Mandates</i>: <code><i>is-awaitable</i>&lt;A, Promise&gt;</code> is <code class='backtick'>true</code>, where <code class='backtick'>A</code> is the type of 
the expression above.</p></li>
<li><p>(7.2) &mdash; Otherwise, <code>(void(p), expr)</code> if <ins><code>decltype(<i>GET-AWAITER</i>(expr))</code> 
satisfies <code><i>is-awaiter</i>&lt;Promise&gt;</code>.</ins><del><code><i>is-awaitable</i>&lt;Expr, U&gt;</code> is <code class='backtick'>true</code>, 
where <code class='backtick'>U</code> is an unspecified class type that is not <code class='backtick'>Promise</code> and that lacks a member named <code class='backtick'>await_transform</code>.</del>
<p/>
<del><i>Preconditions</i>: <code><i>is-awaitable</i>&lt;Expr, Promise&gt;</code> is <code class='backtick'>true</code> and the expression 
<code class='backtick'>co_await expr</code> in a coroutine with promise type <code class='backtick'>U</code> is expression-equivalent to the same expression 
in a coroutine with promise type <code class='backtick'>Promise</code>.</del></p></li>
<li><p>(7.3) &mdash; [&hellip;]</p></li>
<li><p>(7.4) &mdash; [&hellip;]</p></li>
<li><p>(7.5) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4359"><a href="4359">4359</a>. <code class='backtick'>as_awaitable(expr, p)</code> does not define semantics of call if <code class='backtick'>p</code> is not an lvalue</h3>
<p><b>Section:</b> 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-27 <b>Last modified:</b> 2025-09-17</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.as.awaitable">active issues</a> in [exec.as.awaitable].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.as.awaitable">issues</a> in [exec.as.awaitable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording in 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> p7 defines the semantics of a call to <code class='backtick'>as_awaitable(expr, p)</code> 
where <code class='backtick'>p</code> is an lvalue. However, it does not specify what the behaviour is if <code class='backtick'>p</code> is not an lvalue.
<p/>
We should probably say that <code class='backtick'>as_awaitable(expr, p)</code> is ill-formed if <code class='backtick'>p</code> is not an lvalue.
</p>



<p id="res-4359"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> as indicated:</p>

<blockquote>
<p>
-7- <code class='backtick'>as_awaitable</code> is a customization point object. For subexpressions <code class='backtick'>expr</code> and <code class='backtick'>p</code> where <del><code class='backtick'>p</code> 
is an lvalue,</del> <code class='backtick'>Expr</code> names the type <code class='backtick'>decltype((expr))</code> and <code class='backtick'>Promise</code> names the type 
<code>decay_t&lt;decltype((p))&gt;</code>, <ins>if <code class='backtick'>p</code> is not an lvalue, <code class='backtick'>as_awaitable(expr, p)</code> is 
ill-formed, otherwise</ins> <code class='backtick'>as_awaitable(expr, p)</code> is expression-equivalent to, 
except that the evaluations of <code class='backtick'>expr</code> and <code class='backtick'>p</code> are indeterminately sequenced:
</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4360"><a href="4360">4360</a>. <code><i>awaitable-sender</i></code> concept should qualify use of <code><i>awaitable-receiver</i></code> type</h3>
<p><b>Section:</b> 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-27 <b>Last modified:</b> 2025-09-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.as.awaitable">active issues</a> in [exec.as.awaitable].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.as.awaitable">issues</a> in [exec.as.awaitable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> p1 there is an exposition-only helper concept 
<code><i>awaitable-sender</i></code> defined as follows:
</p>
<blockquote><pre>
namespace std::execution {
  template&lt;class Sndr, class Promise&gt;
    concept <i>awaitable-sender</i> =
      <i>single-sender</i>&lt;Sndr, env_of_t&lt;Promise&gt;&gt; &amp;&amp;
      sender_to&lt;Sndr, <i>awaitable-receiver</i>&gt; &amp;&amp; // <i>see below</i>
      requires (Promise&amp; p) {
        { p.unhandled_stopped() } -> convertible_to&lt;coroutine_handle&lt;&gt;&gt;;
      };
}
</pre></blockquote>
<p>
The mention of the type <code><i>awaitable-receiver</i></code> here does not refer to any exposition-only type 
defined at namespace-scope. It seems to, instead, be referring to the nested member-type 
<code><i>sender-awaitable</i>&lt;Sndr, Promise&gt;::<i>awaitable-receiver</i></code> and so should be 
qualified as such.
</p>


<p id="res-4360"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> as indicated:</p>

<blockquote>
<p>
-1- <code class='backtick'>as_awaitable</code> transforms an object into one that is awaitable within a particular coroutine. 
Subclause 33.13 <a href="https://timsong-cpp.github.io/cppwp/exec.coro.util">[exec.coro.util]</a> makes use of the following exposition-only entities:
</p>
<blockquote><pre>
namespace std::execution {
  template&lt;class Sndr, class Promise&gt;
    concept <i>awaitable-sender</i> =
      <i>single-sender</i>&lt;Sndr, env_of_t&lt;Promise&gt;&gt; &amp;&amp;
      sender_to&lt;Sndr, <ins>typename <i>sender-awaitable</i>&lt;Sndr, Promise&gt;::</ins><i>awaitable-receiver</i>&gt; &amp;&amp; // <i>see below</i>
      requires (Promise&amp; p) {
        { p.unhandled_stopped() } -> convertible_to&lt;coroutine_handle&lt;&gt;&gt;;
      };
  [&hellip;]
}
</pre></blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4361"><a href="4361">4361</a>. <code><i>awaitable-receiver</i>::set_value</code> should use <i>Mandates</i> instead of constraints</h3>
<p><b>Section:</b> 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-28 <b>Last modified:</b> 2025-09-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#exec.as.awaitable">active issues</a> in [exec.as.awaitable].</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.as.awaitable">issues</a> in [exec.as.awaitable].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> bullet 4.1 the <code><i>awaitable-receiver</i>::set_value</code> member function 
is defined as having a constraint that the <code><i>result-type</i></code> is constructible from the values.
</p>
<blockquote>
<p>
If <code>constructible_from&lt;<i>result-type</i>, decltype((vs))...&gt;</code> is satisfied, the expression 
<code class='backtick'>set_value(rcvr, vs...)</code> is equivalent to:
</p>
<blockquote><pre>
try {
  rcvr.<i>result-ptr</i>-&gt;template emplace&lt;1&gt;(vs...);
} catch(...) {
  rcvr.<i>result-ptr</i>-&gt;template emplace&lt;2&gt;(current_exception());
}
rcvr.<i>continuation</i>.resume();
</pre></blockquote>
<p>
Otherwise, <code class='backtick'>set_value(rcvr, vs...)</code> is ill-formed.
</p>
</blockquote>
<p>
Should we be using mandates here instead of constraints (or alternatively just drop the constraint altogether)?
There shouldn't be any need to change behaviour based on whether or not the receiver's completion methods 
are well-formed or not.
<p/>
It is worth noting that there is inconsistent use of constraints on <code class='backtick'>set_value</code> methods in other receiver 
implementations throughout 33 <a href="https://timsong-cpp.github.io/cppwp/exec">[exec]</a>.
<p/>
For example:  The following <code class='backtick'>set_value</code> member function applies constraints:
</p>
<ul>
<li><p>In 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> <code><i>basic-receiver</i>::set_value</code> constrains that check that it can accept those specific value arguments</p></li>
</ul>
<p>
While the following <code class='backtick'>set_value</code> member functions do not apply constraints:
</p>
<ul>
<li><p>In 33.9.12.10 <a href="https://timsong-cpp.github.io/cppwp/exec.let">[exec.let]</a> <code><i>receiver2</i>::set_value</code></p></li>
<li><p>In 33.9.12.18 <a href="https://timsong-cpp.github.io/cppwp/exec.spawn.future">[exec.spawn.future]</a> <code><i>spawn-future-receiver</i>::set_value</code></p></li>
<li><p>in 33.9.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.sync.wait">[exec.sync.wait]</a> <code><i>sync-wait-receiver</i>::set_value</code></p></li>
</ul>
<p>
We should probably try to be consistent on whether or not <code class='backtick'>set_value</code> implementations 
should use constraints or mandates. Given that it is not allowed to form calls to the 
receiver unless that overload is present in the <code class='backtick'>completion_signatures</code>, it may be worth 
just making them all mandates. This would tend to make uses of the <code class='backtick'>receiver_of</code> concept 
less useful as satisfying <code>receiver_of&lt;R, Sig&gt;</code> would not necessarily 
guarantee that actually trying to call each of <code class='backtick'>R</code>'s corresponding completion functions 
will result in a well-formed program. It is arguable that this is already the status-quo, however.
</p>


<p id="res-4361"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.13.1 <a href="https://timsong-cpp.github.io/cppwp/exec.as.awaitable">[exec.as.awaitable]</a> as indicated:</p>

<blockquote>
<p>
-4- Let <code class='backtick'>rcvr</code> be an rvalue expression of type <code><i>awaitable-receiver</i></code>, let 
<code class='backtick'>crcvr</code> be a const lvalue that refers to <code class='backtick'>rcvr</code>, let <code class='backtick'>vs</code> be a pack of subexpressions, 
and let <code class='backtick'>err</code> be an expression of type <code class='backtick'>Err</code>. Then:
</p>
<ol style="list-style-type: none">
<li><p>(4.1) &mdash; <del>If <code>constructible_from&lt;<i>result-type</i>, decltype((vs))...&gt;</code> is satisfied, 
t</del><ins>T</ins>he expression <code class='backtick'>set_value(rcvr, vs...)</code> is equivalent to:
</p>
<blockquote><pre>
try {
  rcvr.<i>result-ptr</i>-&gt;template emplace&lt;1&gt;(vs...);
} catch(...) {
  rcvr.<i>result-ptr</i>-&gt;template emplace&lt;2&gt;(current_exception());
}
rcvr.<i>continuation</i>.resume();
</pre></blockquote>
<p>
<del>Otherwise, <code class='backtick'>set_value(rcvr, vs...)</code> is ill-formed</del><ins><i>Mandates:</i> 
<code>constructible_from&lt;<i>result-type</i>, decltype((vs))...&gt;</code> is satisfied</ins>.</p></li>
<li><p>(4.2) &mdash; [&hellip;]</p></li>
<li><p>(4.3) &mdash; [&hellip;]</p></li>
<li><p>(4.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>


<li><p>Modify 33.9.2 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.expos">[exec.snd.expos]</a> after p25 as indicated:</p>

<blockquote><pre>
[&hellip;]
template&lt;class Sndr, class Rcvr, class Index&gt;
  requires <i>valid-specialization</i>&lt;<i>env-type</i>, Index, Sndr, Rcvr&gt;
struct <i>basic-receiver</i> { // <i>exposition only</i>
  using receiver_concept = receiver_t;
  
  using <i>tag-t</i> = tag_of_t&lt;Sndr&gt;; // <i>exposition only</i>
  using <i>state-t</i> = <i>state-type</i>&lt;Sndr, Rcvr&gt;; // <i>exposition only</i>
  static constexpr const auto&amp; <i>complete</i> = <i>impls-for</i>&lt;<i>tag-t</i>&gt;::<i>complete</i>; // exposition only
  
  template&lt;class... Args&gt;
    <del>requires <i>callable</i>&lt;decltype(<i>complete</i>), Index, <i>state-t</i>&amp;, Rcvr&amp;, set_value_t, Args...&gt;</del>
  void set_value(Args&amp;&amp;... args) &amp;&amp; noexcept {
    <i>complete</i>(Index(), op-&gt;<i>state</i>, op-&gt;<i>rcvr</i>, set_value_t(), std::forward&lt;Args&gt;(args)...);
  }
  
  template&lt;class Error&gt;
    <del>requires <i>callable</i>&lt;decltype(<i>complete</i>), Index, <i>state-t</i>&amp;, Rcvr&amp;, set_error_t, Error&gt;</del>
  void set_error(Error&amp;&amp; err) &amp;&amp; noexcept {
    <i>complete</i>(Index(), op-&gt;<i>state</i>, op-&gt;<i>rcvr</i>, set_error_t(), std::forward&lt;Error&gt;(err));
  }
  
  void set_stopped() &amp;&amp; noexcept
    <del>requires <i>callable</i>&lt;decltype(<i>complete</i>), Index, <i>state-t</i>&amp;, Rcvr&amp;, set_stopped_t&gt;</del> {
    <i>complete</i>(Index(), op-&gt;<i>state</i>, op-&gt;<i>rcvr</i>, set_stopped_t());
  }
  
  auto get_env() const noexcept -&gt; <i>env-type</i>&lt;Index, Sndr, Rcvr&gt; {
    return <i>impls-for</i>&lt;tag-t&gt;::<i>get-env</i>(Index(), op-&gt;<i>state</i>, op-&gt;<i>rcvr</i>);
  }
  
  <i>basic-state</i>&lt;Sndr, Rcvr&gt;* <i>op</i>; // <i>exposition only</i>
};
[&hellip;]
</pre></blockquote>

</li>

</ol>





<hr>
<h3 id="4362"><a href="4362">4362</a>. Inconsistent usage of <code class='backtick'>constexpr</code> for <code class='backtick'>inplace_stop_token</code> and <code class='backtick'>inplace_stop_source</code></h3>
<p><b>Section:</b> 32.3.8 <a href="https://timsong-cpp.github.io/cppwp/stoptoken.inplace">[stoptoken.inplace]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-28 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code class='backtick'>inplace_stop_source::get_token()</code> member function is declared <code class='backtick'>constexpr</code>, 
but there are no <code class='backtick'>constexpr</code> member-functions declared on <code class='backtick'>inplace_stop_token</code>, 
making the utility of being able to call this member function during constant 
evaluation limited.
<p/>
Should the member functions of <code class='backtick'>inplace_stop_token</code> also be declared <code class='backtick'>constexpr</code>?
i.e. <code class='backtick'>operator==</code>, <code class='backtick'>swap()</code>, <code class='backtick'>stop_possible()</code> and <code class='backtick'>stop_requested()</code>.
<p/>
The <code class='backtick'>operator==</code> and <code class='backtick'>stop_possible()</code> and <code class='backtick'>swap()</code> member functions should be 
able to be made <code class='backtick'>constexpr</code> trivially as they are just required to compare/modify 
pointers to the associated stop source.
<p/>
The <code class='backtick'>stop_requested()</code> member function is specified to be equivalent to calling 
<code class='backtick'>stop_requested()</code> on the associated <code class='backtick'>inplace_stop_source</code> (if any), which is not 
currently declared <code class='backtick'>constexpr</code> primarily because its implementation requires 
synchronisation/atomic operations.
<p/>
Now that <code class='backtick'>std::atomic</code> operations are now <code class='backtick'>constexpr</code>, it may be possible/appropriate 
for <code class='backtick'>stop_requested()</code> on both <code class='backtick'>inplace_stop_source</code> and <code class='backtick'>inplace_stop_token</code> to also 
be declared <code class='backtick'>constexpr</code>.
</p>


<p id="res-4362"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i>: This is the minimum proposed wording change. Additionally, consider adding 
<code class='backtick'>constexpr</code> to the declaration of <code class='backtick'>inplace_stop_token::stop_requested()</code> (in 
32.3.8.1 <a href="https://timsong-cpp.github.io/cppwp/stoptoken.inplace.general">[stoptoken.inplace.general]</a> and 32.3.8.2 <a href="https://timsong-cpp.github.io/cppwp/stoptoken.inplace.mem">[stoptoken.inplace.mem]</a>) and to 
<code class='backtick'>inplace_stop_source::stop_requested()</code> (in 32.3.9.1 <a href="https://timsong-cpp.github.io/cppwp/stopsource.inplace.general">[stopsource.inplace.general]</a> and 
32.3.9.3 <a href="https://timsong-cpp.github.io/cppwp/stopsource.inplace.mem">[stopsource.inplace.mem]</a>)]
</p>
</blockquote>

<ol>

<li><p>Modify 32.3.8.1 <a href="https://timsong-cpp.github.io/cppwp/stoptoken.inplace.general">[stoptoken.inplace.general]</a>, class <code class='backtick'>inplace_stop_token</code> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  class inplace_stop_token {
  public:
    template&lt;class CallbackFn&gt;
      using callback_type = inplace_stop_callback&lt;CallbackFn&gt;;
    
    <ins>constexpr</ins> inplace_stop_token() = default;
    <ins>constexpr</ins> bool operator==(const inplace_stop_token&amp;) const = default;
    
    // <i>32.3.8.2 <a href="https://timsong-cpp.github.io/cppwp/stoptoken.inplace.mem">[stoptoken.inplace.mem]</a>, member functions</i>
    bool stop_requested() const noexcept;
    <ins>constexpr</ins> bool stop_possible() const noexcept;
    <ins>constexpr</ins> void swap(inplace_stop_token&amp;) noexcept;
    
  private:
    const inplace_stop_source* <i>stop-source</i> = nullptr; // <i>exposition only</i>
  };
}
</pre></blockquote>

</li>


<li><p>Modify 32.3.8.2 <a href="https://timsong-cpp.github.io/cppwp/stoptoken.inplace.mem">[stoptoken.inplace.mem]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i>: As a drive-by fix this adds the missing return type <code class='backtick'>bool</code> to the
<code class='backtick'>stop_possible()</code> prototype]
</p>
</blockquote>

<blockquote>
<pre>
<ins>constexpr</ins> void swap(inplace_stop_token&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Exchanges the values of <code><i>stop-source</i></code> and <code>rhs.<i>stop-source</i></code>.
</p>
</blockquote>
[&hellip;]
<pre>
<ins>constexpr bool</ins> stop_possible() const noexcept;
</pre>
<blockquote>
<p>
-4- <i>Returns</i>: <code><i>stop-source</i> != nullptr</code>.
</p>
</blockquote>

</blockquote>

</li>

</ol>





<hr>
<h3 id="4363"><a href="4363">4363</a>. <code class='backtick'>transform_sender</code> comparing types ignoring <i>cv</i>-qualifiers doesn't take into account differences in value category</h3>
<p><b>Section:</b> 33.9.6 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.transform">[exec.snd.transform]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lewis Baker <b>Opened:</b> 2025-08-28 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 33.9.6 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.transform">[exec.snd.transform]</a> p1, the specification for <code class='backtick'>transform_sender()</code> states:
</p>
<blockquote>
<p>
Let <code><i>transformed-sndr</i></code> be the expression
</p>
<blockquote><pre>
dom.transform_sender(std::forward&lt;Sndr&gt;(sndr), env...)
</pre></blockquote>
<p>
if that expression is well-formed; otherwise,
</p>
<blockquote><pre>
default_domain().transform_sender(std::forward&lt;Sndr&gt;(sndr), env...)
</pre></blockquote>
<p>
Let <code><i>final-sndr</i></code> be the expression <code><i>transformed-sndr</i></code> if 
<code><i>transformed-sndr</i></code> and <code><i>sndr</i></code> have the same type ignoring 
cv-qualifiers; otherwise, it is the expression <code>transform_sender(dom, <i>transformed-sndr</i>, env...)</code>.
</p>
</blockquote>
<p>
However, the use of the phrase "have the same type ignoring cv-qualifiers" asks to compare 
the types without <code class='backtick'>const</code> or <code class='backtick'>volatile</code> qualifiers, but doesn't take into account differences 
in value category of the types of these expressions.
<p/>
For example <code class='backtick'>sndr</code> might have type <code>T&amp;&amp;</code> and <code><i>transformed-sndr</i></code> 
might return a new prvalue of type <code class='backtick'>T</code>.
<p/>
My interpretation of the current wording is that I should apply the test 
<code>same_as&lt;remove_cv_t&lt;decltype(sndr)&gt;, remove_cv_t&lt;decltype(<i>transformed-sndr</i>)&gt;&gt;</code>.
<p/>
However, <code class='backtick'>remove_cv_t</code> does not remove reference-qualifiers from a type <code>Sndr&amp;&amp;</code> 
(which in the above example, is the type of <code class='backtick'>sndr</code>), and thus would compare as different to 
a <code><i>transform-sndr</i></code> type of <code class='backtick'>Sndr</code>.
<p/>
I believe the intention is that this should instead use 
<code>same_as&lt;remove_cvref_t&lt;decltype(sndr)&gt;, remove_cvref_t&lt;decltype(<i>transformed-sndr</i>)&gt;&gt;</code>. 
For example, the 
<a href="https://github.com/NVIDIA/stdexec/blob/4669060ad3b70508740449f9c30f06867a9bd890/include/stdexec/__detail/__transform_sender.hpp#L88">
implementation</a> in NVIDIA's stdexec repository uses <code>same_as&lt;decay_t&lt;T&gt;, decay_t&lt;U&gt;&gt;</code> 
for this check.
<p/>
The wording should be modified to use a phrase that removes both reference and cv-qualifiers when comparing types.
</p>


<p id="res-4363"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.9.6 <a href="https://timsong-cpp.github.io/cppwp/exec.snd.transform">[exec.snd.transform]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::execution {
  template&lt;class Domain, sender Sndr, <i>queryable</i>... Env&gt;
    requires (sizeof...(Env) &lt;= 1)
  constexpr sender decltype(auto) transform_sender(Domain dom, Sndr&amp;&amp; sndr, const Env&amp;... env)
    noexcept(<i>see below</i>);
}
</pre>
<blockquote>
<p>
-1- Let <code><i>transformed-sndr</i></code> be the expression
</p>
<blockquote><pre>
dom.transform_sender(std::forward&lt;Sndr&gt;(sndr), env...)
</pre></blockquote>
<p>
if that expression is well-formed; otherwise,
</p>
<blockquote><pre>
default_domain().transform_sender(std::forward&lt;Sndr&gt;(sndr), env...)
</pre></blockquote>
<p>
Let <code><i>final-sndr</i></code> be the expression <code><i>transformed-sndr</i></code> if 
<code><i>transformed-sndr</i></code> and <code><i>sndr</i></code> have the same <ins>decayed</ins>
type <del>ignoring cv-qualifiers</del>; otherwise, it is the expression 
<code>transform_sender(dom, <i>transformed-sndr</i>, env...)</code>.
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4364"><a href="4364">4364</a>. SFINAE-friendliness on <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> for unspecified I/O manipulators</h3>
<p><b>Section:</b> 31.7.7 <a href="https://timsong-cpp.github.io/cppwp/std.manip">[std.manip]</a>, 31.7.8 <a href="https://timsong-cpp.github.io/cppwp/ext.manip">[ext.manip]</a>, 31.7.9 <a href="https://timsong-cpp.github.io/cppwp/quoted.manip">[quoted.manip]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-09-05 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#std.manip">active issues</a> in [std.manip].</p>
<p><b>View all other</b> <a href="lwg-index.html#std.manip">issues</a> in [std.manip].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, it is unspecified whether any of <code>operator&lt;&lt;</code> or <code>operator&gt;&gt;</code> 
for the "<i>unspecified</i>" return type of an I/O manipulating function is SFINAE-friendly.
<p/>
There's implementation divergence. E.g. the following program is consistently rejected by 
implementations although the standard doesn't strictly require it to be ill-formed. Among 
the implementations, libstdc++ and libc++ make the failure SFINAE-friendly, while MSVC STL 
doesn't (<a href="https://godbolt.org/z/rWYszoYa8">demo</a>):
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() 
{
  std::cout &lt;&lt; std::setfill(L'*');
}
</pre></blockquote>
<p>
It seems better to eliminate such implementation divergence. Perhaps it's also better to 
require them to be SFINAE-friendly to reduce potential conflicts with user-provided operators.
<p/>
If it's intended to allow implementation divergence, perhaps we should clarify the intent.
</p>


<p id="res-4364"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4365"><a href="4365">4365</a>. <code class='backtick'>boyer_moore_searcher</code> and <code class='backtick'>boyer_moore_horspool_searcher</code> should be <code class='backtick'>constexpr</code>-friendly</h3>
<p><b>Section:</b> 22.10.18.3 <a href="https://timsong-cpp.github.io/cppwp/func.search.bm">[func.search.bm]</a>, 22.10.18.4 <a href="https://timsong-cpp.github.io/cppwp/func.search.bmh">[func.search.bmh]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-03 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.search.bm">active issues</a> in [func.search.bm].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.search.bm">issues</a> in [func.search.bm].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>boyer_moore_searcher</code> and <code class='backtick'>boyer_moore_horspool_searcher</code> are not
<code class='backtick'>constexpr</code>-friendly because their underlying implementation needs to precompute 
the shift table, which usually requires a <code class='backtick'>vector</code> or <code class='backtick'>unordered_map</code> to store.
<p/>
Thanks to <a href="https://wg21.link/P3372R3" title=" constexpr containers and adapters">P3372R3</a>, unordered containers are now <code class='backtick'>constexpr</code>-friendly. 
Although <code class='backtick'>std::hash</code> still lacks <code class='backtick'>constexpr</code> support, users can provide their own 
hash functions to use unordered containers at compile time.
<p/>
Given that both <code class='backtick'>boyer_moore_searcher</code> and <code class='backtick'>boyer_moore_horspool_searcher</code> can 
take a custom hash, it makes perfect sense that they could be <code class='backtick'>constexpr</code>-friendly.
<p/>
Not to mention that library implementations usually simply use arrays instead of 
hash tables for the common string case because characters only have 256 values, 
so <code class='backtick'>unordered_map</code> is not actually used.
</p>


<p id="res-4365"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.10.18.3 <a href="https://timsong-cpp.github.io/cppwp/func.search.bm">[func.search.bm]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class RandomAccessIterator1,
           class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator1&gt;::value_type&gt;,
           class BinaryPredicate = equal_to&lt;&gt;&gt;
  class boyer_moore_searcher {
  public:
    <ins>constexpr</ins> boyer_moore_searcher(RandomAccessIterator1 pat_first,
                                   RandomAccessIterator1 pat_last,
                                   Hash hf = Hash(),
                                   BinaryPredicate pred = BinaryPredicate());

    template&lt;class RandomAccessIterator2&gt;
      <ins>constexpr</ins> pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
        operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;

  private:
    RandomAccessIterator1 pat_first_;   // <i>exposition only</i>
    RandomAccessIterator1 pat_last_;    // <i>exposition only</i>
    Hash hash_;                         // <i>exposition only</i>
    BinaryPredicate pred_;              // <i>exposition only</i>
  };
}
</pre>
</blockquote>
<pre>
<ins>constexpr</ins> boyer_moore_searcher(RandomAccessIterator1 pat_first,
                               RandomAccessIterator1 pat_last,
                               Hash hf = Hash(),
                               BinaryPredicate pred = BinaryPredicate());
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: The value type of <code>RandomAccessIterator1</code> meets the
   <i>Cpp17DefaultConstructible</i>, <i>Cpp17CopyConstructible</i>, and <i>Cpp17CopyAssignable</i>
   requirements.
</p>
</blockquote>
<blockquote>
[&hellip;]
</blockquote>
<pre>
template&lt;class RandomAccessIterator2&gt;
  <ins>constexpr</ins> pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
    operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
</pre>
<blockquote>
<p>
-5- <i>Mandates</i>: <code>RandomAccessIterator1</code> and <code>RandomAccessIterator2</code>
have the same value type.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 22.10.18.4 <a href="https://timsong-cpp.github.io/cppwp/func.search.bmh">[func.search.bmh]</a> as indicated:</p>

<blockquote>
<blockquote>
<pre>
namespace std {
  template&lt;class RandomAccessIterator1,
           class Hash = hash&lt;typename iterator_traits&lt;RandomAccessIterator1&gt;::value_type&gt;,
           class BinaryPredicate = equal_to&lt;&gt;&gt;
  class boyer_moore_horspool_searcher {
  public:
   <ins>constexpr</ins> boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first,
                                           RandomAccessIterator1 pat_last,
                                           Hash hf = Hash(),
                                           BinaryPredicate pred = BinaryPredicate());

    template&lt;class RandomAccessIterator2&gt;
      <ins>constexpr</ins> pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
        operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;

  private:
    RandomAccessIterator1 pat_first_;   // <i>exposition only</i>
    RandomAccessIterator1 pat_last_;    // <i>exposition only</i>
    Hash hash_;                         // <i>exposition only</i>
    BinaryPredicate pred_;              // <i>exposition only</i>
  };
}
</pre>
</blockquote>
<pre>
<ins>constexpr</ins> boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first,
                                        RandomAccessIterator1 pat_last,
                                        Hash hf = Hash(),
                                        BinaryPredicate pred = BinaryPredicate());
</pre>
<blockquote>
<p>
-1- <i>Preconditions</i>: The value type of <code>RandomAccessIterator1</code> meets the
<i>Cpp17DefaultConstructible</i>, <i>Cpp17CopyConstructible</i>, and <i>Cpp17CopyAssignable</i>
requirements.
</p>
</blockquote>
<blockquote>
[&hellip;]
</blockquote>
<pre>
template&lt;class RandomAccessIterator2&gt;
  <ins>constexpr</ins> pair&lt;RandomAccessIterator2, RandomAccessIterator2&gt;
    operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
</pre>
<blockquote>
<p>
-5- <i>Mandates</i>: <code>RandomAccessIterator1</code> and <code>RandomAccessIterator2</code>
have the same value type.
</p>
</blockquote>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4366"><a href="4366">4366</a>. Heterogeneous comparison of <code class='backtick'>expected</code> may be ill-formed</h3>
<p><b>Section:</b> 22.8.6.8 <a href="https://timsong-cpp.github.io/cppwp/expected.object.eq">[expected.object.eq]</a>, 22.8.7.8 <a href="https://timsong-cpp.github.io/cppwp/expected.void.eq">[expected.void.eq]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-06 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
These comparison functions all explicitly <code class='backtick'>static_cast</code> the result of the underlying comparison to
<code class='backtick'>bool</code>. However, the <i>Constraints</i> only require the implicit conversion, not the explicit one 
(i.e., "convertible to <code class='backtick'>bool</code>" rather than "models <code><i>boolean-testable</i></code>").
<p/>
This means that in some pathological cases it will lead to hard errors 
(<a href="https://godbolt.org/z/b9ehzv3h4">demo</a>):
</p>
<blockquote><pre>
#include &lt;expected&gt;

struct E1 {};
struct E2 {};

struct Bool {
  operator bool() const;
  explicit operator bool() = delete;
};
Bool operator==(E1, E2);

int main() {
  std::unexpected e1{E1{}};
  std::unexpected e2{E2{}};
  return std::expected&lt;int, E1&gt;{e1} == e2; // <span style="color:#C80000;font-weight:bold">fire</span>
}
</pre></blockquote>
<p>
It is reasonable to specify return consistency with actual <i>Constraints</i>.
</p>


<p id="res-4366"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.8.6.8 <a href="https://timsong-cpp.github.io/cppwp/expected.object.eq">[expected.object.eq]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T2&gt; friend constexpr bool operator==(const expected&amp; x, const T2&amp; v);
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: <code class='backtick'>T2</code> is not a specialization of <code class='backtick'>expected</code>. The expression <code class='backtick'>*x == v</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
[<i>Note 1</i>: <code>T</code> need not be <i>Cpp17EqualityComparable</i>. &mdash; <i>end note</i>]
<p/>
-4- <i>Returns</i>: <ins>If</ins> <code class='backtick'>x.has_value()</code> <ins>is <code class='backtick'>true</code>,</ins>
<code><del>&amp;&amp; static_cast&lt;bool&gt;(</del>*x == v<del>)</del></code><ins>; otherwise <code class='backtick'>false</code></ins>.
</p>
</blockquote>
<pre>
template&lt;class E2&gt; friend constexpr bool operator==(const expected&amp; x, const unexpected&lt;E2&gt;&amp; e);
</pre>
<blockquote>
<p>
-5- <i>Constraints</i>: The expression <code class='backtick'>x.error() == e.error()</code> is well-formed and its result is convertible 
to <code class='backtick'>bool</code>.
<p/>
-6- <i>Returns</i>: <ins>If</ins> <code class='backtick'>!x.has_value()</code> <ins>is <code class='backtick'>true</code>,</ins>
<code><del>&amp;&amp; static_cast&lt;bool&gt;(</del>x.error() == e.error()<del>)</del></code><ins>; otherwise <code class='backtick'>false</code></ins>.
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 22.8.7.8 <a href="https://timsong-cpp.github.io/cppwp/expected.void.eq">[expected.void.eq]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T2, class E2&gt; requires is_void_v&lt;T2&gt;
  friend constexpr bool operator==(const expected&amp; x, const expected&lt;T2, E2&gt;&amp; y);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: The expression <code class='backtick'>x.error() == y.error()</code> is well-formed and its result 
is convertible to <code class='backtick'>bool</code>.
<p/>
-2- <i>Returns</i>: If <code class='backtick'>x.has_value()</code> does not equal <code class='backtick'>y.has_value()</code>, <code class='backtick'>false</code>; 
otherwise <ins>if</ins> <code class='backtick'>x.has_value()</code> <ins>is <code class='backtick'>true</code>, <code class='backtick'>true</code>; otherwise</ins>
<code><del>|| static_cast&lt;bool&gt;(</del>x.error() == y.error()<del>)</del></code>.
</p>
</blockquote>
<pre>
template&lt;class E2&gt;
  friend constexpr bool operator==(const expected&amp; x, const unexpected&lt;E2&gt;&amp; e);
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: The expression <code class='backtick'>x.error() == e.error()</code> is well-formed and its 
result is convertible to <code class='backtick'>bool</code>.
<p/>
-4- <i>Returns</i>: <ins>If</ins> <code class='backtick'>!x.has_value()</code> <ins>is <code class='backtick'>true</code>,</ins>
<code><del>&amp;&amp; static_cast&lt;bool&gt;(</del>x.error() == e.error()<del>)</del></code>
<ins>; otherwise <code class='backtick'>false</code></ins>.
</p>
</blockquote>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4367"><a href="4367">4367</a>. Improve <code>optional&lt;T&amp;&gt;::or_else</code></h3>
<p><b>Section:</b> 22.5.4.7 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.monadic">[optional.ref.monadic]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-07 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.ref.monadic">active issues</a> in [optional.ref.monadic].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.ref.monadic">issues</a> in [optional.ref.monadic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>optional&lt;T&amp;&gt;::or_else</code> currently returns <code>*<i>val</i></code> when it has a value,
which calls the <code>optional(U&amp;&amp;)</code> constructor which in turn calls 
<code><i>convert-ref-init-val</i></code> which in turn calls <code class='backtick'>addressof</code>.
<p/>
There's no reason to do that. It's much more efficient to call <code>optional&lt;T&amp;&gt;</code>'s 
default copy constructor to just copy a pointer.
</p>


<p id="res-4367"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.4.7 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.monadic">[optional.ref.monadic]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class F&gt; constexpr optional or_else(F&amp;&amp; f) const;
</pre>
<blockquote>
<p>
-7- <i>Constraints</i>: <code class='backtick'>F</code> models <code class='backtick'>invocable</code>.
<p/>
-8- <i>Mandates</i>: <code>is_same_v&lt;remove_cvref_t&lt;invoke_result_t&lt;F&gt;&gt;, optional&gt;</code> is <code class='backtick'>true</code>.
<p/>
-9- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
if (has_value()) {
  return *<ins>this</ins><del><i>val</i></del>;
} else {
  return std::forward&lt;F&gt;(f)();
}
</pre></blockquote></blockquote>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4368"><a href="4368">4368</a>. Potential dangling reference returned from <code class='backtick'>transform_sender</code></h3>
<p><b>Section:</b> 33.9.5 <a href="https://timsong-cpp.github.io/cppwp/exec.domain.default">[exec.domain.default]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#exec.domain.default">issues</a> in [exec.domain.default].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following has been reported by Trevor Gray to me:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
There is a potential stack-use-after-scope in <code class='backtick'>execution::transform_sender</code> 
with <code class='backtick'>execution::default_domain::transform_sender</code>.
<p/>
I'll give an example of the problem using <code class='backtick'>starts_on</code> with the <code class='backtick'>default_domain</code>.
<p/>
<code class='backtick'>starts_on</code> defines a <code class='backtick'>transform_sender</code> so <code class='backtick'>execution::transform_sender</code> will expand to:
</p>
<blockquote><pre>
return transform_sender(
    dom,
    dom.transform_sender(std::forward&lt;Sndr&gt;(sndr), env...),
    env...);
</pre></blockquote>
<p>
where <code class='backtick'>dom</code> is the <code class='backtick'>default_domain</code> and <code class='backtick'>sndr</code> is <code class='backtick'>starts_on</code>.
<p/>
Execution flow:
</p>
<ul>
<li><p><code>dom.transform_sender(std::forward&lt;Sndr&gt;(sndr), env...)</code> uses <code class='backtick'>default_domain</code> 
to invoke <code class='backtick'>start_on</code>'s <code class='backtick'>transform_sender</code>. The return type is <code class='backtick'>T</code> (where <code class='backtick'>T</code> is a <code class='backtick'>let_value</code> sender)</p></li>
<li><p><code>transform_sender(dom, declval&lt;T&gt;(), env...)</code> is then run which uses <code class='backtick'>default_domain</code> 
to just return <code>std::forward&lt;T&gt;(t)</code>.</p></li>
</ul>
<p>
This means the value returned from the entire expression is <code>T&amp;&amp;</code> which a reference 
to a temporary variable in the frame of <code class='backtick'>transform_sender</code> which is no longer valid after the return.
</p>
</blockquote>
<p>
In the reference implementation, this scenario does not create a dangling reference because 
its implementation of <code class='backtick'>default_domain::transform_sender</code> does not conform to the spec. By default, 
it returns an rvalue sender as a prvalue instead of an xvalue as the spec requires.
<p/>
The fix is for the spec to follow suit and return prvalues when an xvalue would otherwise be returned.
</p>


<p id="res-4368"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.9.5 <a href="https://timsong-cpp.github.io/cppwp/exec.domain.default">[exec.domain.default]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;sender Sndr, <i>queryable</i>... Env&gt;
  requires (sizeof...(Env) &lt;= 1)
constexpr sender decltype(auto) transform_sender(Sndr&amp;&amp; sndr, const Env&amp;... env)
  noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- Let <code class='backtick'>e</code> be the expression
</p>
<blockquote><pre>
tag_of_t&lt;Sndr&gt;().transform_sender(std::forward&lt;Sndr&gt;(sndr), env...)
</pre></blockquote>
<p>
if that expression is well-formed; otherwise, <code><ins>static_cast&lt;Sndr&gt;(</ins>std::forward&lt;Sndr&gt;(sndr)<ins>)</ins></code>.
<p/>
-3- <i>Returns</i>: <code class='backtick'>e</code>.
<p/>
-4- <i>Remarks</i>: The exception specification is equivalent to <code class='backtick'>noexcept(e)</code>.
</p>
</blockquote>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4369"><a href="4369">4369</a>. <code><i>check-types</i></code> function for <code class='backtick'>upon_error</code> and <code class='backtick'>upon_stopped</code> is wrong</h3>
<p><b>Section:</b> 33.9.12.9 <a href="https://timsong-cpp.github.io/cppwp/exec.then">[exec.then]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2025-08-31 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following has been reported by Trevor Gray:
</p>
<p>
In 33.9.12.9 <a href="https://timsong-cpp.github.io/cppwp/exec.then">[exec.then]</a> p5, the <code><i>impls-for</i>&lt;<i>decayed-typeof</i>&lt;<i>then-cpo</i>&gt;&gt;::<i>check-types</i></code> 
unction is specified as follows:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<pre>
template&lt;class Sndr, class... Env&gt;
  static consteval void <i>check-types</i>();
</pre>
<blockquote>
<p>
<i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
auto cs = get_completion_signatures&lt;<i>child-type</i>&lt;Sndr&gt;, <i>FWD-ENV-T</i>(Env)...&gt;();
auto fn = []&lt;class... Ts&gt;(set_value_t(*)(Ts...)) {
  if constexpr (!invocable&lt;remove_cvref_t&lt;<i>data-type</i>&lt;Sndr&gt;&gt;, Ts...&gt;)
    throw <i>unspecified-exception</i>();
};
cs.<i>for-each</i>(<i>overload-set</i>{fn, [](auto){}});
</pre></blockquote>
<p>
where <code><i>unspecified-exception</i></code> is a type derived from <code class='backtick'>exception</code>.
</p>
</blockquote>
</blockquote>
<p>
The line <code>auto fn = []&lt;class... Ts&gt;(set_value_t(*)(Ts...)) {</code> 
is correct when <code><i>then-cpo</i></code> is <code class='backtick'>then</code> but not when it is <code class='backtick'>upon_error</code> or <code class='backtick'>upon_stopped</code>.
<p/>
For <code class='backtick'>upon_error</code> it should be:
</p>
<blockquote><pre>
auto fn = []&lt;class... Ts&gt;(set_error_t(*)(Ts...)) {
</pre></blockquote>
<p>
and for <code class='backtick'>upon_stopped</code> it should be:
</p>
<blockquote><pre>
auto fn = []&lt;class... Ts&gt;(set_stopped_t(*)(Ts...)) {
</pre></blockquote>
<p>
We can achieve that by replacing <code class='backtick'>set_value_t</code> in the problematic line with <code><i>decayed-typeof</i>&lt;<i>set-cpo</i>&gt;</code>.
</p>


<p id="res-4369"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 33.9.12.9 <a href="https://timsong-cpp.github.io/cppwp/exec.then">[exec.then]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Sndr, class... Env&gt;
  static consteval void <i>check-types</i>();
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
auto cs = get_completion_signatures&lt;<i>child-type</i>&lt;Sndr&gt;, <i>FWD-ENV-T</i>(Env)...&gt;();
auto fn = []&lt;class... Ts&gt;(<del>set_value_t</del><ins><i>decayed-typeof</i>&lt;<i>set-cpo</i>&gt;</ins>(*)(Ts...)) {
  if constexpr (!invocable&lt;remove_cvref_t&lt;<i>data-type</i>&lt;Sndr&gt;&gt;, Ts...&gt;)
    throw <i>unspecified-exception</i>();
};
cs.<i>for-each</i>(<i>overload-set</i>{fn, [](auto){}});
</pre></blockquote>
<p>
where <code><i>unspecified-exception</i></code> is a type derived from <code class='backtick'>exception</code>.
</p>
</blockquote>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4370"><a href="4370">4370</a>. Comparison of <code>optional&lt;T&gt;</code> to <code>T</code> may be ill-formed</h3>
<p><b>Section:</b> 22.5.9 <a href="https://timsong-cpp.github.io/cppwp/optional.comp.with.t">[optional.comp.with.t]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-06 <b>Last modified:</b> 2025-09-15</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.comp.with.t">issues</a> in [optional.comp.with.t].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When comparing an <code class='backtick'>optional</code> with its value type, the current wording specifies that the result is the
ternary expression of <code class='backtick'>x.has_value() ? *x == v : false</code>, where <code class='backtick'>*x == v</code> returns a result that can be 
implicitly converted to <code class='backtick'>bool</code>.
<p/>
However, when the result can also be constructed using <code class='backtick'>bool</code> (which is common), the ternary operation
will be ill-formed due to ambiguity (<a href="https://godbolt.org/z/r55Wh51Y8">demo</a>):
</p>
<blockquote><pre>
#include &lt;optional&gt;

struct Bool {
  Bool(bool);
  operator bool() const;
};

struct S {
  Bool operator==(S) const;
};

int main() {
  return std::optional&lt;S&gt;{} == S{}; // <span style="color:#C80000;font-weight:bold">fire</span>
}
</pre></blockquote>


<p id="res-4370"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.9 <a href="https://timsong-cpp.github.io/cppwp/optional.comp.with.t">[optional.comp.with.t]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-1- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code class='backtick'>*x == v</code> is well-formed
   and its result is convertible to <code class='backtick'>bool</code>.
<p/>
[<i>Note 1</i>: <code class='backtick'>T</code> need not be <i>Cpp17EqualityComparable</i>. &mdash; end note]
<p/>
-2- <i>Effects</i>: Equivalent to: <del><code class='backtick'>return x.has_value() ? *x == v : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x == v;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator==(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code class='backtick'>v == *x</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-4- <i>Effects</i>: Equivalent to: <del><code class='backtick'>return x.has_value() ? v == *x : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v == *x;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-5- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code class='backtick'>*x != v</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-6- <i>Effects</i>: Equivalent to: <del><code class='backtick'>return x.has_value() ? *x != v : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x != v;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator!=(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-7- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code class='backtick'>v != *x</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-8- <i>Effects</i>: Equivalent to: <del><code class='backtick'>return x.has_value() ? v != *x : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v != *x;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-9- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>*x &lt; v</code> is well-formed
and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-10- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? *x &lt; v : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x &lt; v;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-11- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>v &lt; *x</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-12- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? v &lt; *x : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v &lt; *x;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-13- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>*x &gt; v</code> is 
well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-14- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? *x &gt; v : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x &gt; v;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-15- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>v &gt; *x</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-16- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? v &gt; *x : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v &gt; *x;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-17- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>*x &lt;= v</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-18- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? *x &lt;= v : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x &lt;= v;
return true;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&lt;=(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-19- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>v &lt;= *x</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-20- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? v &lt;= *x : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v &lt;= *x;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const U&amp; v);
</pre>
<blockquote>
<p>
-21- <i>Constraints</i>: <code class='backtick'>U</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>*x &gt;= v</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-22- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? *x &gt;= v : false;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return *x &gt;= v;
return false;</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class T, class U&gt; constexpr bool operator&gt;=(const T&amp; v, const optional&lt;U&gt;&amp; x);
</pre>
<blockquote>
<p>
-23- <i>Constraints</i>: <code class='backtick'>T</code> is not a specialization of <code class='backtick'>optional</code>. The expression <code>v &gt;= *x</code> 
is well-formed and its result is convertible to <code class='backtick'>bool</code>.
<p/>
-24- <i>Effects</i>: Equivalent to: <del><code>return x.has_value() ? v &gt;= *x : true;</code></del>
</p>
<blockquote><pre>
<ins>if (x.has_value())
  return v &gt;= *x;
return true;</ins>
</pre></blockquote>
</blockquote>

</blockquote>

</li>

</ol>




<hr>
<h3 id="4371"><a href="4371">4371</a>. Container adaptor's <code class='backtick'>empty</code>/<code class='backtick'>size</code> should be <code class='backtick'>noexcept</code></h3>
<p><b>Section:</b> 23.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/queue.defn">[queue.defn]</a>, 23.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/priqueue.overview">[priqueue.overview]</a>, 23.6.6.2 <a href="https://timsong-cpp.github.io/cppwp/stack.defn">[stack.defn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-09 <b>Last modified:</b> 2025-09-16</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#queue.defn">issues</a> in [queue.defn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C++23 container adaptors <code>flat_<i>meow</i></code> all have <code class='backtick'>noexcept</code> <code class='backtick'>size</code>/<code class='backtick'>empty</code> members.
<p/>
However, the <code class='backtick'>size</code>/<code class='backtick'>empty</code> members of other container adaptors are not mark <code class='backtick'>noexcept</code>, 
even though they behave the same as <code>flat_<i>meow</i></code> that returning the <code class='backtick'>size</code>/<code class='backtick'>empty</code> 
of the underlying container.
<p/>
It makes sense to make them <code class='backtick'>noexcept</code> as well for consistency. Although the standard doesn't
explicitly say those two members of the container must not throw, the fact that all standard 
containers and common third-party containers mark them as unconditionally <code class='backtick'>noexcept</code> implies 
that it's perfectly reasonable to assume that they never will.
</p>


<p id="res-4371"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.6.3.1 <a href="https://timsong-cpp.github.io/cppwp/queue.defn">[queue.defn]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T, class Container = deque&lt;T&gt;&gt;
  class queue {
  public:
    [&hellip;]
    constexpr bool              empty() const <ins>noexcept</ins> { return c.empty(); }
    constexpr size_type         size()  const <ins>noexcept</ins> { return c.size(); }
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 23.6.4.1 <a href="https://timsong-cpp.github.io/cppwp/priqueue.overview">[priqueue.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T, class Container = vector&lt;T&gt;,
           class Compare = less&lt;typename Container::value_type&gt;&gt;
  class priority_queue {
  public:
    [&hellip;]
    constexpr bool            empty() const <ins>noexcept</ins> { return c.empty(); }
    constexpr size_type       size()  const <ins>noexcept</ins> { return c.size(); }
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 23.6.6.2 <a href="https://timsong-cpp.github.io/cppwp/stack.defn">[stack.defn]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class T, class Container = deque&lt;T&gt;&gt;
  class stack {
  public:
    [&hellip;]
    constexpr bool              empty() const <ins>noexcept</ins> { return c.empty(); }
    constexpr size_type         size()  const <ins>noexcept</ins> { return c.size(); }
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4372"><a href="4372">4372</a>. Weaken <i>Mandates:</i> for dynamic padding values in padded layouts</h3>
<p><b>Section:</b> 23.7.3.4.8.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a>, 23.7.3.4.9.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Luc Grosheintz <b>Opened:</b> 2025-09-09 <b>Last modified:</b> 2025-09-19</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Two new layouts were added to <code>&lt;mdspan&gt;</code> in C++26. Both have a template
parameter <code class='backtick'>size_t PaddingValue</code>. This value is allowed to be <code class='backtick'>std::dynamic_extent</code> 
to signal that the padding value isn't known at compile time.
<p/>
A class <i>Mandates:</i> element (in 23.7.3.4.8.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a> (5.2)
and 23.7.3.4.9.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> (5.2), respectively) requires 
(unconditionally) that
</p>
<ul>
<li><p><code class='backtick'>PaddingValue</code> is representable as a value of <code class='backtick'>index_type</code>.</p></li>
</ul>
<p>
Since <code class='backtick'>std::dynamic_extent</code> is defined as <code class='backtick'>size_t(-1)</code> (in 23.7.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.syn">[span.syn]</a>)
this immediately prohibits all dynamically padded layout mappings for
any <code class='backtick'>index_type</code> for which:
</p>
<blockquote><pre>
numeric_limit&lt;index_type&gt;::max() &lt; numeric_limit&lt;size_t&gt;::max()
</pre></blockquote>
<p>
One example is <code class='backtick'>int</code> on a 64-bit system.
<p/>
The proposed resolution states that the modified representability
<i>Mandates:</i> element holds for <code>rank &lt;= 1</code>, even though in that case the 
<code class='backtick'>PaddingValue</code> has no other effect. Hence, the <i>Mandates:</i> element could 
be weakened further.
</p>


<p id="res-4372"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.7.3.4.8.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.leftpad.overview">[mdspan.layout.leftpad.overview]</a> as indicated:</p>

<blockquote>
<p>
-5- <i>Mandates</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; [&hellip;]</p></li>
<li><p>(5.2) &mdash; <ins>if <code class='backtick'>padding_value</code> is not equal to <code class='backtick'>dynamic_extent</code>, then</ins> 
<code class='backtick'>padding_value</code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(5.3) &mdash; [&hellip;]</p></li>
<li><p>(5.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>

<li><p>Modify 23.7.3.4.9.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.layout.rightpad.overview">[mdspan.layout.rightpad.overview]</a> as indicated:</p>

<blockquote>
<p>
-5- <i>Mandates</i>:
</p>
<ol style="list-style-type: none">
<li><p>(5.1) &mdash; [&hellip;]</p></li>
<li><p>(5.2) &mdash; <ins>if <code class='backtick'>padding_value</code> is not equal to <code class='backtick'>dynamic_extent</code>, then</ins> 
<code class='backtick'>padding_value</code> is representable as a value of type <code class='backtick'>index_type</code>.</p></li>
<li><p>(5.3) &mdash; [&hellip;]</p></li>
<li><p>(5.4) &mdash; [&hellip;]</p></li>
</ol>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4373"><a href="4373">4373</a>. <code class='backtick'>function_ref</code> should provide <code class='backtick'>result_type</code></h3>
<p><b>Section:</b> 22.10.17.6.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.ref.class">[func.wrap.ref.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-12 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>function</code>, <code class='backtick'>move_only_function</code>, and <code class='backtick'>copyable_function</code> all have a
type member <code class='backtick'>result_type</code>, but <code class='backtick'>function_ref</code> does not:
</p>
<blockquote>
<pre>
static_assert(is_same_v&lt;          function    &lt;int(int)&gt;::result_type, int&gt;);
static_assert(is_same_v&lt;move_only_function    &lt;int(int)&gt;::result_type, int&gt;);
static_assert(is_same_v&lt; copyable_function    &lt;int(int)&gt;::result_type, int&gt;);
static_assert(is_same_v&lt;          function_ref&lt;int(int)&gt;::result_type, int&gt;); // <span style="color:#C80000;font-weight:bold">error</span>
</pre>
</blockquote>
<p>
It seems worthwhile to also provide it for the latter, as it is consistent with the other
wrappers and allows the user to easily extract the return type.
</p>

<p><i>[2025-10-03; Hewill comments]</i></p>

<p>
Additionally, given that some third-party implementations also provide a mechanism for
extracting the return type, for example, <code class='backtick'>type_safe::function_ref</code> provides a public member
type alias
<a
   href="https://github.com/foonathan/type_safe/blob/cdf334cd8e5fcb5e21ab470decdfcbd190ef7347/include/type_safe/reference.hpp#L566">
<code>return_type</code></a>, and <code class='backtick'>llvm::function_ref</code> can work with
<a
   href="https://github.com/llvm/llvm-project/blob/cd32b9b6c3b2fda3a781d9ce0a0cf8e21c9d0137/llvm/include/llvm/ADT/STLExtras.h#L67">
<code>llvm::function_traits</code></a> to obtain the return type, providing such a member
type alias for <code class='backtick'>std::function_ref</code> meets user potential demands.
</p>


<p id="res-4373"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.10.17.6.2 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.ref.class">[func.wrap.ref.class]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class R, class... ArgTypes&gt;
  class function_ref&lt;R(ArgTypes...) <i>cv</i> noexcept(<i>noex</i>)&gt; {
  public:
    <ins>using result_type = R;</ins>

    // <i>22.10.17.6.3 <a href="https://timsong-cpp.github.io/cppwp/func.wrap.ref.ctor">[func.wrap.ref.ctor]</a>, constructors and assignment operators</i>
    template&lt;class F&gt; function_ref(F*) noexcept;
    [&hellip;]
  };

}
</pre>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4374"><a href="4374">4374</a>. <code>flat_<i>meow</i></code> range insertion behavior is unclear if in-place merge cannot allocate additional memory</h3>
<p><b>Section:</b> 23.6.8.7 <a href="https://timsong-cpp.github.io/cppwp/flat.map.modifiers">[flat.map.modifiers]</a>, 23.6.11.5 <a href="https://timsong-cpp.github.io/cppwp/flat.set.modifiers">[flat.set.modifiers]</a>, 23.6.12.5 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset.modifiers">[flat.multiset.modifiers]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2025-09-09 <b>Last modified:</b> 2025-09-19</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#flat.map.modifiers">active issues</a> in [flat.map.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#flat.map.modifiers">issues</a> in [flat.map.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The range insertion operations of <code class='backtick'>flat_map</code>/<code class='backtick'>multimap</code>/<code class='backtick'>set</code>/<code class='backtick'>multiset</code> have this <i>Remarks</i>: element: 
</p>
<blockquote><p>
Since this operation performs an in-place merge, it may allocate memory.
</p></blockquote>
<p>
It is not clear what happens if that allocation fails. If the <code class='backtick'>inplace_merge</code> algorithm is used, 
it will fall back to a less efficient <code>&#x1d4aa;(N log N)</code> algorithm, but this is not reflected 
in the <i>Complexity</i>: element. Alternatively, if the allocation failure is reported by an exception, 
that should be called out in the spec.
</p>


<p id="res-4374"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4375"><a href="4375">4375</a>. <code class='backtick'>std::simd::bit_ceil</code> should not be <code class='backtick'>noexcept</code></h3>
<p><b>Section:</b> 29.10.8.15 <a href="https://timsong-cpp.github.io/cppwp/simd.bit">[simd.bit]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matthias Kretz <b>Opened:</b> 2025-08-29 <b>Last modified:</b> 2025-09-19</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>std::simd::bit_ceil</code> is declared 'noexcept' in 29.10.3 <a href="https://timsong-cpp.github.io/cppwp/simd.syn">[simd.syn]</a> and 
29.10.8.15 <a href="https://timsong-cpp.github.io/cppwp/simd.bit">[simd.bit]</a>. But
</p>
<ol>
<li><p><code class='backtick'>std::bit_ceil</code> is not 'noexcept' (22.11.2 <a href="https://timsong-cpp.github.io/cppwp/bit.syn">[bit.syn]</a> and 22.11.5 <a href="https://timsong-cpp.github.io/cppwp/bit.pow.two">[bit.pow.two]</a>) and</p></li>
<li><p><code class='backtick'>std::simd::bit_ceil</code> has a precondition.</p></li>
</ol>


<p id="res-4375"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.3 <a href="https://timsong-cpp.github.io/cppwp/simd.syn">[simd.syn]</a>, header <code>&lt;simd&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  [&hellip;]
  // <i>29.10.8.15 <a href="https://timsong-cpp.github.io/cppwp/simd.bit">[simd.bit]</a>, bit manipulation</i>
  template&lt;<i>simd-vec-type</i> V&gt; constexpr V byteswap(const V&amp; v) noexcept;
  template&lt;<i>simd-vec-type</i> V&gt; constexpr V bit_ceil(const V&amp; v) <del>noexcept</del>;
  template&lt;<i>simd-vec-type</i> V&gt; constexpr V bit_floor(const V&amp; v) noexcept;  
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 29.10.8.15 <a href="https://timsong-cpp.github.io/cppwp/simd.bit">[simd.bit]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>simd-vec-type</i> V&gt; constexpr V bit_ceil(const V&amp; v) <del>noexcept</del>;
</pre>
<blockquote>
<p>
-3- <i>Constraints</i>: The type <code class='backtick'>V::value_type</code> is an unsigned integer type (6.9.2 <a href="https://timsong-cpp.github.io/cppwp/basic.fundamental">[basic.fundamental]</a>).
<p/>
-4- <i>Preconditions</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4376"><a href="4376">4376</a>. ABI tag in return type of [simd.mask.unary] is overconstrained</h3>
<p><b>Section:</b> 29.10.9.4 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.unary">[simd.mask.unary]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matthias Kretz <b>Opened:</b> 2025-09-15 <b>Last modified:</b> 2025-09-20</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.mask.unary">active issues</a> in [simd.mask.unary].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.mask.unary">issues</a> in [simd.mask.unary].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.10.9.4 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.unary">[simd.mask.unary]</a> spells out the return type with the ABI tag of 
the <code class='backtick'>basic_mask</code> specialization. That's problematic / overconstrained.
</p>
<ol>
<li><p>Consider Intel SandyBridge/IvyBridge-like targets:
</p>
<blockquote><pre>
vec&lt;float&gt;::size() -&gt; 8
vec&lt;int&gt;::size() -&gt; 4
mask&lt;float&gt;::size() -&gt; 8
</pre></blockquote>
<p>
The ABI tag in this case encodes for <code>vec&lt;float&gt;</code> that one object holds 8
elements and is passed via <em>one</em> register. <code>vec&lt;int&gt;</code> uses a 
different ABI tag that says 4 elements passed via <em>one</em> register. 
<code>vec&lt;int, 8&gt;</code>'s ABI tag says 8 elements passed via <em>two</em> registers.
<p/>
Now what should <code>+mask&lt;float&gt;()</code> return? The working draft says it must 
return a <code>basic_vec&lt;int, mask&lt;float&gt;::abi_type&gt;</code>. And 
<code>mask&lt;float&gt;::abi_type</code> is constrained to be the same as 
<code>vec&lt;float&gt;::abi_type</code>. The working draft thus makes it
impossible to implement ABI tags that encode number of elements + number of
registers (+ bit-masks vs. vector-masks, but that's irrelevant for this
issue). Instead, an ABI tag would have to encode the native SIMD width of all
vectorizable types. And that's unnecessarily making compatible types
incompatible. Also we make it harder to add to the set of vectorizable types
in the future.</p></li>
<li><p>The issue is even worse for an implementation that implements
<code>vec&lt;complex&lt;T&gt;&gt;</code> using different ABI tags. Encoding 
whether the value-type is complex into the ABI is useful because it impacts 
how the mask is stored (<code>mask&lt;complex&lt;float&gt;, 8&gt;</code> is 
internally stored as a 16-element bit-mask (for interleaved <code class='backtick'>complex</code>), while 
<code>mask&lt;double, 8&gt;</code> is stored as an 8-element bit-mask). The ABI 
tag can also be used to implement interleaved vs. contiguous storage, which 
is useful for different architectures. If we require 
<code>+mask&lt;complex&lt;float&gt;&gt;()</code> to be of a different type than 
any <code>vec&lt;long long&gt;</code> would ever be, that's just brittle and 
unnecessary template bloat.</p></li>
</ol>


<p id="res-4376"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> LWG <a href="4238" title="simd_mask&lt;complex&lt;double&gt;&gt;::operator+/-/~ return a disabled simd specialization (Status: New)">4238</a> is closely related.]
</p>
</blockquote>

<ol>

<li><p>Modify 29.10.2 <a href="https://timsong-cpp.github.io/cppwp/simd.expos">[simd.expos]</a> as indicated:</p>

<blockquote>
<pre>
using <i>simd-size-type</i> = <i>see below</i>;                      // <i>exposition only</i>
template&lt;size_t Bytes&gt; using <i>integer-from</i> = <i>see below</i>; // <i>exposition only</i>

template&lt;class T, class Abi&gt;
  constexpr <i>simd-size-type</i> <i>simd-size-v</i> = <i>see below</i>;               // <i>exposition only</i>
template&lt;class T&gt; constexpr size_t <i>mask-element-size</i> = <i>see below</i>; // <i>exposition only</i>

<ins>template &lt;size_t Bytes, class Abi&gt;
  using <i>simd-vec-from-mask-t</i> = <i>see below</i>;                         // <i>exposition only</i></ins>
[&hellip;]
</pre>
</blockquote>

</li>

<li><p>Modify 29.10.2.1 <a href="https://timsong-cpp.github.io/cppwp/simd.expos.defn">[simd.expos.defn]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class T&gt; constexpr size_t <i>mask-element-size</i> = <i>see below</i>; // <i>exposition only</i>
</pre>
<blockquote>
<p>
-4- <code><i>mask-element-size</i>&lt;basic_mask&lt;Bytes, Abi&gt;&gt;</code> has the value <code class='backtick'>Bytes</code>.
</p>
</blockquote>
<pre>
<ins>template &lt;size_t Bytes, class Abi&gt;
  using <i>simd-vec-from-mask-t</i> = <i>see below</i>;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <code><i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;</code> is an alias for an enabled 
specialization of <code class='backtick'>basic_vec</code> if and only if <code>basic_mask&lt;Bytes, Abi&gt;</code> is a 
data-parallel type and <code><i>integer-from</i>&lt;Bytes&gt;</code> is valid and a vectorizable type.</ins>
<p/>
<ins>-?- <code><i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;::size() == basic_mask&lt;Bytes, Abi&gt;::size()</code>
is <code class='backtick'>true</code>.</ins>
<p/>
<ins>-?- <code>typename <i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;::value_type</code> is 
<code><i>integer-from</i>&lt;Bytes&gt;</code></ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify 29.10.9.1 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.overview">[simd.mask.overview]</a>, class template <code class='backtick'>basic_mask overview</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;size_t Bytes, class Abi&gt; class basic_mask {
  public:
    [&hellip;]
    // <i>29.10.9.4 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.unary">[simd.mask.unary]</a>, basic_mask unary operators</i>
    constexpr basic_mask operator!() const noexcept;
    constexpr <del>basic_vec&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt;</del><ins><i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;</ins> operator+() const noexcept;
    constexpr <del>basic_vec&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt;</del><ins><i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;</ins> operator-() const noexcept;
    constexpr <del>basic_vec&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt;</del><ins><i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;</ins> operator~() const noexcept;    
    [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 29.10.9.4 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.unary">[simd.mask.unary]</a> as indicated:</p>

<blockquote>
<pre>
constexpr basic_mask operator!() const noexcept;
constexpr <del>basic_vec&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt;</del><ins><i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;</ins> operator+() const noexcept;
constexpr <del>basic_vec&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt;</del><ins><i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;</ins> operator-() const noexcept;
constexpr <del>basic_vec&lt;<i>integer-from</i>&lt;Bytes&gt;, Abi&gt;</del><ins><i>simd-vec-from-mask-t</i>&lt;Bytes, Abi&gt;</ins> operator~() const noexcept;    
</pre>
<blockquote>
<p>
-1- Let <code><i>op</i></code> be the operator.
<p/>
-2- <i>Returns</i>: [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>




<hr>
<h3 id="4377"><a href="4377">4377</a>. Misleading note about lock-free property of <code class='backtick'>std::atomic_ref</code></h3>
<p><b>Section:</b> 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Bi <b>Opened:</b> 2025-09-15 <b>Last modified:</b> 2025-09-20</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.ref.ops">active issues</a> in [atomics.ref.ops].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.ref.ops">issues</a> in [atomics.ref.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Note 1 to 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a> states:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
Hardware could require an object referenced by an <code class='backtick'>atomic_ref</code> to have stricter alignment 
(6.8.3 <a href="https://timsong-cpp.github.io/cppwp/basic.align">[basic.align]</a>) than other objects of type <code class='backtick'>T</code>. Further, whether operations 
on an <code class='backtick'>atomic_ref</code> are lock-free could depend on the alignment of the referenced object. 
For example, lock-free operations on <code>std::complex&lt;double&gt;</code> could be supported 
only if aligned to <code class='backtick'>2*alignof(double)</code>.
</p>
</blockquote>
<p>
By using the word "Further", the note misleadingly implies that <code class='backtick'>required_alignment</code> may 
need to be greater than <code class='backtick'>alignof(T)</code> even before considering lock freedom, i.e., that 
<code>std::atomic_ref&lt;T&gt;</code> may be completely unimplementable on given hardware if 
the stricter alignment requirement is not met. However, that can never be true because 
falling back to a lock-based implementation is always possible.
<p/>
The note could also be misinterpreted to imply that even though an object may be aligned to 
<code class='backtick'>required_alignment</code> and thus referenceable by an <code class='backtick'>atomic_ref</code>, operations could still fail 
to be lock-free because there is a stricter alignment requirement that the object does not 
meet. Such an interpretation is, however, at odds with p4.
<p/>
The example given by the note is also confusing in that it does not necessarily demonstrate 
a situation in which <code>std::atomic_ref&lt;T&gt;::required_alignment</code> is greater than 
<code class='backtick'>alignof(T)</code>.
<p/>
In conclusion, this note appears to be a convoluted way of saying that, in order to ensure 
that operations on <code>atomic_ref&lt;T&gt;</code> are lock-free, the implementation may 
define <code class='backtick'>required_alignment</code> to a value greater than <code class='backtick'>alignof(T)</code>. The note should be 
modified to say this much more clearly.
</p>


<p id="res-4377"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>


<li><p>Modify 32.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/atomics.ref.ops">[atomics.ref.ops]</a> as indicated:</p>

<blockquote>
<pre>
static constexpr size_t required_alignment;
</pre>
<blockquote>
<p>
-1- The alignment required for an object to be referenced by an atomic reference, which is at least
<code class='backtick'>alignof(T)</code>.
<p/>
-2- [<i>Note 1</i>: <del>Hardware could require an object referenced by an <code class='backtick'>atomic_ref</code> to have stricter 
alignment (6.8.3 <a href="https://timsong-cpp.github.io/cppwp/basic.align">[basic.align]</a>) than other objects of type <code class='backtick'>T</code>. Further, whether operations 
on an <code class='backtick'>atomic_ref</code> are lock-free could depend on the alignment of the referenced object. For example, 
lock-free operations on <code>std::complex&lt;double&gt;</code> could be supported only if aligned to 
<code class='backtick'>2*alignof(double)</code></del><ins>An implementation can choose to define 
<code>atomic_ref&lt;T&gt;::required_alignment</code> to a value greater than <code class='backtick'>alignof(T)</code> in order to 
ensure that operations on all objects of type <code>atomic_ref&lt;T&gt;</code> are lock-free</ins>. 
&mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4378"><a href="4378">4378</a>. Inconsistency between <code class='backtick'>std::basic_string</code>'s <code class='backtick'>data()</code> and <code class='backtick'>operator[]</code> specification</h3>
<p><b>Section:</b> 27.4.3.6 <a href="https://timsong-cpp.github.io/cppwp/string.access">[string.access]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Bindels <b>Opened:</b> 2025-09-16 <b>Last modified:</b> 2025-09-21</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.access">issues</a> in [string.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From the working draft <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>, the specification for <code class='backtick'>operator[]</code> in 27.4.3.6 <a href="https://timsong-cpp.github.io/cppwp/string.access">[string.access]</a> 
p2 says:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Returns</i>: <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>. Otherwise, returns a reference 
to an object of type <code class='backtick'>charT</code> with value <code class='backtick'>charT()</code>, where modifying the object to any value other than 
<code class='backtick'>charT()</code> leads to undefined behavior.
</p>
</blockquote>
<p>
The specification for data() in 27.4.3.8.1 <a href="https://timsong-cpp.github.io/cppwp/string.accessors">[string.accessors]</a> p1 (and p4) says, however:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Returns</i>: A pointer <code class='backtick'>p</code> such that <code class='backtick'>p + i == addressof(operator[](i))</code> for each <code class='backtick'>i</code> in <code class='backtick'>[0, size()]</code>.
</p>
</blockquote>
<p>
The former implies that <code class='backtick'>str[str.size()]</code> is allowed to be the address of any null terminator, 
while the latter restricts it to only being the null terminator belonging to the string.
<p/>
Suggested fix: Change wording around <code class='backtick'>operator[]</code> to
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
<i>Returns</i>: <code class='backtick'>*(begin() + pos)</code> if <code>pos &lt;= size()</code>. The program shall not modify the value 
stored at <code class='backtick'>size()</code> to any value other than <code class='backtick'>charT()</code>; otherwise, the behavior is undefined.
</p>
</blockquote>
<p>
This moves it inline with the <code class='backtick'>data()</code> specification. Given the hardened precondition that 
<code>pos &lt;= size()</code> this does not change behavior for any in-contract access, and we do 
not define what the feature does when called with broken preconditions. I have been looking at 
the latter but that will be an EWG paper instead.
</p>


<p id="res-4378"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>


<li><p>Modify 27.4.3.6 <a href="https://timsong-cpp.github.io/cppwp/string.access">[string.access]</a> as indicated:</p>

<blockquote>
<pre>
constexpr const_reference operator[](size_type pos) const;
constexpr       reference operator[](size_type pos);
</pre>
<blockquote>
<p>
-1- <i>Hardened preconditions</i>: <code>pos &lt;= size()</code> is <code class='backtick'>true</code>.
<p/>
-2- <i>Returns</i>: <code class='backtick'>*(begin() + pos)</code> if <code>pos &lt;<ins>=</ins> size()</code>. <del>Otherwise, returns a reference 
to an object of type <code class='backtick'>charT</code> with value <code class='backtick'>charT()</code>, where modifying the object to any value other 
than <code class='backtick'>charT()</code> leads to undefined behavior.</del>
<p/>
-3- <i>Throws</i>: Nothing.
<p/>
-4- <i>Complexity</i>: Constant time.
<p/>
<ins>-?- <i>Remarks</i> The program shall not modify the value stored at <code class='backtick'>size()</code> to any value other than <code class='backtick'>charT()</code>; 
otherwise, the behavior is undefined</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4379"><a href="4379">4379</a>. <code class='backtick'>hive::reserve()</code> needs <i>Throws:</i> element adjusted to match block min/max considerations</h3>
<p><b>Section:</b> 23.3.9.3 <a href="https://timsong-cpp.github.io/cppwp/hive.capacity">[hive.capacity]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Bentley <b>Opened:</b> 2025-09-17 <b>Last modified:</b> 2025-09-23</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#hive.capacity">active issues</a> in [hive.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#hive.capacity">issues</a> in [hive.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue comes from Bloomberg as part of their C++26 comments via Incits. To summarize their case, in a 
call to <code class='backtick'>reserve(n)</code>, 
</p>
<blockquote>
<pre>
if (n &gt; capacity() &amp;&amp; capacity() + <i>current-limits</i>.min &gt; max_size()),
</pre>
</blockquote>
<p>
<code class='backtick'>reserve</code> should throw, e.g when <code class='backtick'>max_size=100</code>, <code class='backtick'>capacity=80</code>, <code><i>current-limits</i>.min</code> and 
<code><i>current-limits</i>.max</code> are <code class='backtick'>40</code> and <code class='backtick'>n=90</code>. 
<p/>
In addition, in the above scenario if we increase <code class='backtick'>max_size()</code> to 140 and <code class='backtick'>n</code> to 130, 
we can see that although we could add one block with a capacity of <code><i>current-limits</i>.min</code>,
adding another would be impossible; we still cannot make <code>capacity &gt;= n</code> without also 
being <code>&gt; max_size</code>.
<p/>
This is currently not stated in the <i>Throws:</i> element. I've implemented the requested additional 
throws and they are easily achievable.
</p>


<p id="res-4379"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>


<li><p>Modify 23.3.9.3 <a href="https://timsong-cpp.github.io/cppwp/hive.capacity">[hive.capacity]</a> as indicated:</p>

<blockquote>
<pre>
void reserve(size_type n);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: If <code>n &lt;= capacity()</code> is <code class='backtick'>true</code>, there are no effects. Otherwise increases 
<code class='backtick'>capacity()</code> by allocating reserved blocks.
<p/>
-4- <i>Postconditions</i>: <code>capacity() &gt;= n</code> is <code class='backtick'>true</code>.
<p/>
-5- <i>Throws</i>: <code class='backtick'>length_error</code> if <del><code class='backtick'>n</code></del><ins><code class='backtick'>capacity()</code> cannot be made <code>&gt;= n</code> without 
being</ins> <code>&gt; max_size()</code>, as well as any exceptions thrown by the allocator.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4380"><a href="4380">4380</a>. <code class='backtick'>hive::reserve()</code> complexity does not reflect potential deallocation of blocks
</h3>
<p><b>Section:</b> 23.3.9.3 <a href="https://timsong-cpp.github.io/cppwp/hive.capacity">[hive.capacity]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Bentley <b>Opened:</b> 2025-09-23 <b>Last modified:</b> 2025-09-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#hive.capacity">active issues</a> in [hive.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#hive.capacity">issues</a> in [hive.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As noted by Arthur in issue <a href="4379" title="hive::reserve() needs Throws: element adjusted to match block min/max considerations (Status: New)">4379</a>, <code class='backtick'>reserve(n)</code> could choose to deallocate some 
reserved (empty) blocks if in doing so it could then allocate blocks which brought <code class='backtick'>capacity()</code> 
closer to <code class='backtick'>n</code>.
<p/>
For example if <code class='backtick'>capacity()</code> is <code class='backtick'>460</code>, <code class='backtick'>n</code> is <code class='backtick'>480</code>, the <code><i>current-limits</i>.min</code> is 
<code class='backtick'>40</code> and there is a reserved block of capacity <code class='backtick'>70</code>, the latter could be deallocated and a 
new reserved block allocated of capacity <code class='backtick'>90</code>, bringing total capacity to <code class='backtick'>480</code>. As opposed 
to allocating a new reserved block at the min capacity of <code class='backtick'>40</code>, bringing the total capacity 
to <code class='backtick'>500</code>.
<p/>
The implicit assumption in this issue is that we want <code class='backtick'>reserve()</code> to be able to deallocate. 
No-one has objected to this before, but if you want to, please speak up.
<p/>
Anyway, the <i>Complexity</i> of <code class='backtick'>reserve()</code> does not presently reflect this ability.
</p>


<p id="res-4380"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>


<li><p>Modify 23.3.9.3 <a href="https://timsong-cpp.github.io/cppwp/hive.capacity">[hive.capacity]</a> as indicated:</p>

<blockquote>
<pre>
void reserve(size_type n);
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: If <code>n &lt;= capacity()</code> is <code class='backtick'>true</code>, there are no effects. Otherwise increases 
<code class='backtick'>capacity()</code> by allocating reserved blocks.
<p/>
-4- <i>Postconditions</i>: <code>capacity() &gt;= n</code> is <code class='backtick'>true</code>.
<p/>
-5- <i>Throws</i>: <code class='backtick'>length_error</code> if <code class='backtick'>n</code> <code>&gt; max_size()</code>, as well as any exceptions 
thrown by the allocator.
<p/>
-6- <i>Complexity</i>: It does not change the size of the sequence and takes at most linear time in the number of
reserved blocks allocated <ins>and deallocated</ins>.
<p/>
-7- <i>Remarks</i>: All references, pointers, and iterators referring to elements in <code class='backtick'>*this</code>, as well as the 
past-the-end iterator, remain valid.
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4381"><a href="4381">4381</a>. <code class='backtick'>std::ranges::to specification</code> using CTAD not supported by core language
</h3>
<p><b>Section:</b> 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2025-09-23 <b>Last modified:</b> 2025-09-26</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.utility.conv.to">active issues</a> in [range.utility.conv.to].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.utility.conv.to">issues</a> in [range.utility.conv.to].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> p4 defines a <code><i>DEDUCE_EXPR</i></code> 
that attempts CTAD (class template argument deduction) on a template template 
parameter <code class='backtick'>C</code>.
<p/>
This is not supported by the core language; 
<a href="https://cplusplus.github.io/CWG/issues/3003.html">CWG 3003</a> will 
clarify the core wording accordingly.
<p/>
Suggested resolution: Remove 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> p3, p4, p5 
and the respective entry in the synopsis as unimplementable.
</p>


<p id="res-4381"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 25.2 <a href="https://timsong-cpp.github.io/cppwp/ranges.syn">[ranges.syn]</a>, header <code>&lt;ranges&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
namespace std::ranges {
  [&hellip;]
  // <i>25.5.7 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv">[range.utility.conv]</a>, range conversions</i>
  template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
    constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
  <del>template&lt;template&lt;class...&gt; class C, input_range R, class... Args&gt;
    constexpr auto to(R&amp;&amp; r, Args&amp;&amp;... args);</del>
  template&lt;class C, class... Args&gt; requires (!view&lt;C&gt;)
    constexpr auto to(Args&amp;&amp;... args);
  template&lt;template&lt;class...&gt; class C, class... Args&gt;
    constexpr auto to(Args&amp;&amp;... args);  
  [&hellip;]
}
</pre>
</blockquote>

</li>

<li><p>Modify 25.5.7.2 <a href="https://timsong-cpp.github.io/cppwp/range.utility.conv.to">[range.utility.conv.to]</a> as indicated:</p>

<blockquote>
<pre>
<del>template&lt;template&lt;class...&gt; class C, input_range R, class... Args&gt;
  constexpr auto to(R&amp;&amp; r, Args&amp;&amp;... args);</del>
</pre>
<blockquote>
<p>
<del>-3- Let <code><i>input-iterator</i></code> be an exposition-only type:</del>
</p>
<blockquote><pre><del>
struct <i>input-iterator</i> { <i>// exposition only</i>
  using iterator_category = input_iterator_tag;
  using value_type = range_value_t&lt;R&gt;;
  using difference_type = ptrdiff_t;
  using pointer = add_pointer_t&lt;range_reference_t&lt;R&gt;&gt;;
  using reference = range_reference_t&lt;R&gt;;
  reference operator*() const;
  pointer operator->() const;
  <i>input-iterator</i>&amp; operator++();
  <i>input-iterator</i> operator++(int);
  bool operator==(const <i>input-iterator</i>&amp;) const;
};
</del></pre></blockquote>
<p>
<del>[<i>Note 1</i>: <code><i>input-iterator</i></code> meets the syntactic requirements of 
<i>Cpp17InputIterator</i>. &mdash; <i>end note</i>]</del>
<p/>
<del>-4- Let <code><i>DEDUCE_EXPR</i></code> be defined as follows:</del>
</p>
<ol style="list-style-type: none">
<li><p><del>(4.1) &mdash; <code>C(declval&lt;R&gt;(), declval&lt;Args&gt;()...)</code> if that is a valid expression,</del></p></li>
<li><p><del>(4.2) &mdash; otherwise, <code>C(from_range, declval&lt;R&gt;(), declval&lt;Args&gt;()...)</code> if 
that is a valid expression,</del></p></li>
<li><p><del>(4.3) &mdash;  otherwise,</del></p>
<blockquote><pre><del>
C(declval&lt;<i>input-iterator</i>&gt;(), declval&lt;<i>input-iterator</i>&gt;(), declval&lt;Args&gt;()...)
</del></pre></blockquote>
<p><del>if that is a valid expression,</del></p>
</li>
<li><p><del>(4.4) &mdash; otherwise, the program is ill-formed.</del></p></li>
</ol>
<p>
<del>-5- <i>Returns</i>: <code>to&lt;decltype(<i>DEDUCE_EXPR</i>)>(std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)</code>.</del>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4382"><a href="4382">4382</a>. The <code>simd::basic_mask(bool)</code> overload needs to be more constrained
</h3>
<p><b>Section:</b> 29.10.9.2 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.ctor">[simd.mask.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matthias Kretz <b>Opened:</b> 2025-09-24 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.10.9.2 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.ctor">[simd.mask.ctor]</a> defines the overloads <code class='backtick'>basic_mask(bool)</code> and
<code class='backtick'>basic_mask(unsigned_integral auto)</code>. This leads to the following pitfall:
</p>
<blockquote><pre>
auto g0() {
  unsigned short k = 0xf;
  return simd::mask&lt;float, 8&gt;(k); // mov eax, 15
}

auto g1() {
  unsigned short k = 0xf;
  return simd::mask&lt;float, 8&gt;(k >> 1); // mov eax, -1 
}

auto g2() {
  unsigned int k = 0xf;
  return simd::mask&lt;float, 8&gt;(k >> 1); // mov eax, 7
}
</pre></blockquote>
<p>
In <code class='backtick'>g1</code>, <code class='backtick'>k</code> is promoted to <code class='backtick'>int</code>, shifted and then passed to 
the mask constructor. Instead of failing, <code class='backtick'>int(0x7)</code> is 
converted to <code class='backtick'>bool</code> and the mask thus initialized to all <code class='backtick'>true</code>.
<p/>
Also consider:
</p>
<ol>
<li><p><code>simd::mask&lt;float&gt;(true_type());</code></p></li>
<li><p><code>unsigned_integral&lt;bool&gt;</code> is <code class='backtick'>true</code> => 
<code>same_as&lt;bool&gt; auto</code> instead of 'bool' makes 
the overload set ambiguous</p></li>
<li><p><code class='backtick'>float</code> is convertible to <code class='backtick'>bool</code>, thus 
<code>simd::mask&lt;float&gt;(1.f)</code> continues to compile</p></li>
</ol>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">

<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.9.1 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.overview">[simd.mask.overview]</a>, <code>class template basic_mask</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;size_t Bytes, class Abi&gt; class basic_mask {
  public:
    [&hellip;]
    
    constexpr basic_mask() noexcept = default;
    
    // <i>29.10.9.2 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.ctor">[simd.mask.ctor]</a>, basic_mask constructors</i>
    constexpr explicit basic_mask(value_type) noexcept;
    template&lt;size_t UBytes, class UAbi&gt;
      constexpr explicit basic_mask(const basic_mask&lt;UBytes, UAbi&gt;&amp;) noexcept;
    template&lt;class G&gt;
      constexpr explicit basic_mask(G&amp;&amp; gen) noexcept;
    constexpr basic_mask(const bitset&lt;size()&gt;&amp; b) noexcept;
    constexpr explicit basic_mask(unsigned_integral auto val) noexcept;
    <ins>basic_mask(signed_integral auto) = delete;</ins>
    
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2025-10-06; Matthias Kretz improves wording after reflector discussion]</i></p>



<p id="res-4382"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.9.1 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.overview">[simd.mask.overview]</a>, <code>class template basic_mask</code> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;size_t Bytes, class Abi&gt; class basic_mask {
  public:
    [&hellip;]
    
    constexpr basic_mask() noexcept = default;
    
    // <i>29.10.9.2 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.ctor">[simd.mask.ctor]</a>, basic_mask constructors</i>
    constexpr explicit basic_mask(<ins>same_as&lt;</ins>value_type<ins>&gt; auto</ins>) noexcept;
    template&lt;size_t UBytes, class UAbi&gt;
      constexpr explicit basic_mask(const basic_mask&lt;UBytes, UAbi&gt;&amp;) noexcept;
    template&lt;class G&gt;
      constexpr explicit basic_mask(G&amp;&amp; gen) noexcept;
    <ins>template&lt;same_as&lt;bitset&lt;size()&gt;&gt; T&gt;</ins>
      constexpr basic_mask(const <ins>T</ins><del>bitset&lt;size()&gt;</del>&amp; b) noexcept;
    <ins>template&lt;unsigned_integral T&gt; requires (!same_as&lt;T, value_type&gt;)</ins>
      constexpr explicit basic_mask(<ins>T</ins><del>unsigned_integral auto</del> val) noexcept;
    
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Modify 29.10.9.2 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.ctor">[simd.mask.ctor]</a> as indicated:</p>

<blockquote>
<pre>
constexpr explicit basic_mask(<ins>same_as&lt;</ins>value_type<ins>&gt; auto</ins> x) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Initializes each element with <code class='backtick'>x</code>.
</p>
</blockquote>
[&hellip;]
<pre>
<ins>template&lt;same_as&lt;bitset&lt;size()&gt;&gt; T&gt;</ins>
  constexpr basic_mask(const <ins>T</ins><del>bitset&lt;size()&gt;</del>&amp; b) noexcept;
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Initializes the <code><i>i</i></code><sup>th</sup> element with <code>b[<i>i</i>]</code> 
for all <code><i>i</i></code> in the range <code class='backtick'>[0, size())</code>.
</p>
</blockquote>
<pre>
<ins>template&lt;unsigned_integral T&gt; requires (!same_as&lt;T, value_type&gt;)</ins>
  constexpr explicit basic_mask(<ins>T</ins><del>unsigned_integral auto</del> val) noexcept;
</pre>
<blockquote>
<p>
-8- <i>Effects</i>: Initializes the first <code><i>M</i></code> elements to the corresponding bit values 
in <code class='backtick'>val</code>, [&hellip;]
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4383"><a href="4383">4383</a>. <code class='backtick'>constant_wrapper</code>'s pseudo-mutators are underconstrained
</h3>
<p><b>Section:</b> 21.3.5 <a href="https://timsong-cpp.github.io/cppwp/const.wrap.class">[const.wrap.class]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-24 <b>Last modified:</b> 2025-09-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike other operators, <code class='backtick'>constant_wrapper</code>'s pseudo-mutators only require that the wrapped type has
corresponding mutators, but do not require them to be <code>constexpr</code> or to return a sensible value.
This inconsistency loses the SFINAE friendliness (<a href="https://godbolt.org/z/r4z1GGT6f">demo</a>):
</p>
<blockquote><pre>
#include &lt;type_traits&gt;

void test(auto t) {
  if constexpr (requires { +t; })  // ok
    +t;
  if constexpr (requires { -t; })  // ok
    -t;
  if constexpr (requires { ++t; }) // <span style="color:#C80000;font-weight:bold">hard error</span>
    ++t;
  if constexpr (requires { --t; }) // <span style="color:#C80000;font-weight:bold">hard error</span>
    --t;
}

struct S {
  /* constexpr */ int operator+() const { return 0; }
  /* constexpr */ int operator++() { return 0; }
  constexpr void operator-() const { }
  constexpr void operator--() { }
};

int main() {
  test(std::cw&lt;S{}&gt;);
}
</pre></blockquote>
<p>
Since these pseudo-mutators have constraints, it is reasonable to further require constant
expressions.
</p>


<p id="res-4383"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 21.3.5 <a href="https://timsong-cpp.github.io/cppwp/const.wrap.class">[const.wrap.class]</a>, class template <code>constant_wrapper</code> synopsis, as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The requires clause follows the form of <code class='backtick'>constant_wrapper</code>'s
function call operator.]
</p>
</blockquote>

<blockquote>
<pre>
struct <i>cw-operators</i> {                                                           // <i>exposition only</i>
  [&hellip;]
  // <i>pseudo-mutators</i>
  template&lt;<i>constexpr-param</i> T&gt;
    constexpr auto operator++(this T) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>++x<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto c = T::value; return ++c; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T&gt;
    constexpr auto operator++(this T, int) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x++<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto c = T::value; return c++; }()&gt;{}; }

  template&lt;<i>constexpr-param</i> T&gt;
    constexpr auto operator--(this T) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>--x<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto c = T::value; return --c; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T&gt;
    constexpr auto operator--(this T, int) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x--<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto c = T::value; return c--; }()&gt;{}; }

  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator+=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x += R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v += R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator-=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x -= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v -= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator*=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x *= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v *= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator/=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x /= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v /= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator%=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x %= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v %= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator&amp;=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x &amp;= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &amp;= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator|=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x |= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v |= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator^=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x ^= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v ^= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator&lt;&lt;=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x &lt;&lt;= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &lt;&lt;= R::value; }()&gt;{}; }
  template&lt;<i>constexpr-param</i> T, <i>constexpr-param</i> R&gt;
    constexpr auto operator&gt;&gt;=(this T, R) noexcept
      requires requires(T::value_type x) { <ins>constant_wrapper&lt;</ins>x &gt;&gt;= R::value<ins>&gt;()</ins>; }
        { return constant_wrapper&lt;[] { auto v = T::value; return v &gt;&gt;= R::value; }()&gt;{}; }
};
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4384"><a href="4384">4384</a>. <code class='backtick'>flat_set::erase(iterator)</code> is underconstrained
</h3>
<p><b>Section:</b> 23.6.11.2 <a href="https://timsong-cpp.github.io/cppwp/flat.set.defn">[flat.set.defn]</a>, 23.6.12.2 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset.defn">[flat.multiset.defn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-25 <b>Last modified:</b> 2025-09-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is a follow-up of LWG <a href="3704" title="LWG 2059 added overloads that might be ill-formed for sets (Status: C++23)">3704</a> since we now have <code class='backtick'>flat_set</code> and <code class='backtick'>flat_multiset</code>.
</p>


<p id="res-4384"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.6.11.2 <a href="https://timsong-cpp.github.io/cppwp/flat.set.defn">[flat.set.defn]</a> as indicated:</p>

<blockquote>
<pre>
iterator erase(iterator position) <ins>requires (!same_as&lt;iterator, const_iterator&gt;)</ins>;
iterator erase(const_iterator position);
</pre>
</blockquote>

</li>

<li><p>Modify 23.6.12.2 <a href="https://timsong-cpp.github.io/cppwp/flat.multiset.defn">[flat.multiset.defn]</a> as indicated:</p>

<blockquote>
<pre>
iterator erase(iterator position) <ins>requires (!same_as&lt;iterator, const_iterator&gt;)</ins>;
iterator erase(const_iterator position);
</pre>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4385"><a href="4385">4385</a>. Including <code>&lt;simd&gt;</code> doesn't provide <code class='backtick'>std::begin/end</code>
</h3>
<p><b>Section:</b> 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-26 <b>Last modified:</b> 2025-09-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>std::simd::basic_vec</code> and <code class='backtick'>std::simd::basic_mask</code> are ranges since <a href="https://wg21.link/P3480R6" title=" std::simd is a range">P3480R6</a>, 
it is reasonable to enable range access utilities when introducing <code>&lt;simd&gt;</code>.
</p>


<p id="res-4385"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> as indicated:</p>

<blockquote>
<p>
-1- In addition to being available via inclusion of the <code>&lt;iterator&gt;</code> header, the function
templates in 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> are available when any of the following headers are included: 
<code>&lt;array&gt;</code>,
<code>&lt;deque&gt;</code>, <code>&lt;flat_map&gt;</code>, <code>&lt;flat_set&gt;</code>,
<code>&lt;forward_list&gt;</code>,
<code>&lt;hive&gt;</code>,
<code>&lt;inplace_vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;map&gt;</code>,
<code>&lt;regex&gt;</code>, <code>&lt;set&gt;</code>, <ins><code>&lt;simd&gt;</code></ins>, 
<code>&lt;span&gt;</code>, <code>&lt;string&gt;</code>, <code>&lt;string_view&gt;</code>,
<code>&lt;unordered_map&gt;</code>, <code>&lt;unordered_set&gt;</code>, and <code>&lt;vector&gt;</code>.

</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4386"><a href="4386">4386</a>. <code>std::simd::select(bool c, const T&amp; a, const U&amp; b)</code> is underconstrained
</h3>
<p><b>Section:</b> 29.10.8.13 <a href="https://timsong-cpp.github.io/cppwp/simd.alg">[simd.alg]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-27 <b>Last modified:</b> 2025-09-27</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This function currently only requires that <code class='backtick'>c ? a : b</code> be a well-formed expression, which simply
returns <code class='backtick'>c ? a : b</code>.
<p/>
Given that it seems intended to work with <code class='backtick'>basic_vec</code>, <code class='backtick'>basic_mask</code>, or vectorizable type,
requiring <code class='backtick'>T</code> and <code class='backtick'>U</code> to be copyable seems reasonable since they are trivially copyable. 
It shouldn't take non-copyable objects and produce hard errors in the function body.
</p>


<p id="res-4386"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.3 <a href="https://timsong-cpp.github.io/cppwp/simd.syn">[simd.syn]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  [&hellip;]
  // <i>29.10.8.13 <a href="https://timsong-cpp.github.io/cppwp/simd.alg">[simd.alg]</a>, algorithms</i>
  [&hellip;]
  template&lt;<ins>copyable</ins><del>class</del> T, <ins>copyable</ins><del>class</del> U&gt;
    constexpr auto select(bool c, const T&amp; a, const U&amp; b)
    -&gt; remove_cvref_t&lt;decltype(c ? a : b)&gt;;
  [&hellip;]
};
</pre>
</blockquote>

</li>

<li><p>Modify 29.10.8.13 <a href="https://timsong-cpp.github.io/cppwp/simd.alg">[simd.alg]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<ins>copyable</ins><del>class</del> T, <ins>copyable</ins><del>class</del> U&gt;
  constexpr auto select(bool c, const T&amp; a, const U&amp; b)
    -&gt; remove_cvref_t&lt;decltype(c ? a : b)&gt;;
</pre>
<blockquote>
<p>
-9- <i>Effects</i>: Equivalent to: <code>return c ? a : b;</code>
</p>
</blockquote>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4387"><a href="4387">4387</a>. Including <code>&lt;stacktrace&gt;</code> doesn't provide <code class='backtick'>std::begin/end</code>
</h3>
<p><b>Section:</b> 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-27 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.range">active issues</a> in [iterator.range].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>basic_stacktrace</code> is explicitly specified as a reversible container, an allocator-aware container, 
and a const-qualified sequence container, with members <code class='backtick'>begin</code>/<code class='backtick'>end</code>, <code class='backtick'>rbegin</code>/<code class='backtick'>rend</code>,
<code class='backtick'>cbegin</code>/<code class='backtick'>cend</code>, <code class='backtick'>crbegin</code>/<code class='backtick'>crend</code>, <code class='backtick'>empty</code>, <code class='backtick'>size</code>, etc.
<p/>
Thus, it's worth making the corresponding free functions available when introducing
<code>&lt;stacktrace&gt;</code>, just like other containers.
</p>

<p><i>[2025-10-07; Reflector poll]</i></p>

<p>
Approved as Tentatively Ready, but this is a duplicate of <a href="3625" title="Should &lt;stacktrace&gt; provide range access function templates? (Status: Open)">3625</a>
which will be resolved by <a href="https://wg21.link/P3016R6" title=" Resolve inconsistencies in begin/end for valarray and braced initializer lists">P3016R6</a>. So move Status New &rarr; Open.
</p>



<p id="res-4387"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> as indicated:</p>

<blockquote>
<p>
-1- In addition to being available via inclusion of the <code>&lt;iterator&gt;</code> header, the function
templates in 24.7 <a href="https://timsong-cpp.github.io/cppwp/iterator.range">[iterator.range]</a> are available when any of the following headers are included: 
<code>&lt;array&gt;</code>,
<code>&lt;deque&gt;</code>, <code>&lt;flat_map&gt;</code>, <code>&lt;flat_set&gt;</code>,
<code>&lt;forward_list&gt;</code>,
<code>&lt;hive&gt;</code>,
<code>&lt;inplace_vector&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;map&gt;</code>,
<code>&lt;regex&gt;</code>, <code>&lt;set&gt;</code>,  
<code>&lt;span&gt;</code>, <ins><code>&lt;stacktrace&gt;</code></ins>, 
<code>&lt;string&gt;</code>, <code>&lt;string_view&gt;</code>,
<code>&lt;unordered_map&gt;</code>, <code>&lt;unordered_set&gt;</code>, and <code>&lt;vector&gt;</code>.

</p>
</blockquote>

</li>

</ol>





<hr>
<h3 id="4388"><a href="4388">4388</a>. Align new definition of <code class='backtick'>va_start</code> with C23</h3>
<p><b>Section:</b> 17.14.2 <a href="https://timsong-cpp.github.io/cppwp/cstdarg.syn">[cstdarg.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jakub Jelinek <b>Opened:</b> 2025-10-01 <b>Last modified:</b> 2025-10-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#cstdarg.syn">active issues</a> in [cstdarg.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdarg.syn">issues</a> in [cstdarg.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="https://wg21.link/P3348R4" title=" C++26 should refer to C23 not C17">P3348R4</a> changed the <code class='backtick'>va_start</code> macro to match C23,
but the following wording from C is not present in C++:
<blockquote>
If any additional arguments expand to include unbalanced parentheses,
or a preprocessing token that does not convert to a token,
the behavior is undefined.
</blockquote>
</p>
<p>
The importance of that wording was not realized during review of P3348R4.
The wording is intended to ensure that any discarded arguments to
<code class='backtick'>va_start</code> are actually lexable by the compiler,
rather than containing unbalanced parentheses or brackets.
It also makes the following undefined:
</p>
<pre><code>#define BAD ); format_disk(
va_start(ap, BAD);
</code></pre>


<p id="res-4388"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>
<li><p>Modify 17.14.2 <a href="https://timsong-cpp.github.io/cppwp/cstdarg.syn">[cstdarg.syn]</a> as indicated:</p>

<blockquote>
<p>
(1.2) &mdash;
<ins>
If more than one argument is present for <code class='backtick'>va_start</code>
and any of the second or subsequent arguments expands
to include unbalanced parentheses,
or a preprocessing token that does not convert to a token,
the program is ill-formed, no diagnostic required.
</ins>
The preprocessing tokens comprising the second and subsequent arguments to
<code class='backtick'>va_start</code> (if any) are discarded.
[<i>Note 1</i>: <code class='backtick'>va_start</code> accepts a second argument for compatibility with prior revisions of C++.
&mdash; <i>end note</i>]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4389"><a href="4389">4389</a>. <code class='backtick'>ranges::for_each</code> possibly behaves differently from range-based <code class='backtick'>for</code></h3>
<p><b>Section:</b> 25.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.range">[range.range]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jiang An <b>Opened:</b> 2025-09-28 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#range.range">issues</a> in [range.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It was found in the blog post 
<a href="https://quuxplusone.github.io/blog/2024/12/09/foreach-versus-for/">
"When <code class='backtick'>ranges::for_each</code> behaves differently from <code class='backtick'>for</code>"</a>  that <code class='backtick'>ranges::for_each</code> 
can behave differently from range-based <code class='backtick'>for</code>, because
</p>
<ol>
<li><p><code class='backtick'>ranges::begin</code> and <code class='backtick'>ranges::end</code> possibly use different rules, i.e. one calls a member 
and the other calls an ADL-found non-member function, and</p></li>
<li><p>these CPOs continue to perform ADL when a member <code class='backtick'>begin/end</code> is found but the 
function call is not valid, while the range-for stops and renders the program ill-formed.</p></li>
</ol>
<p>
Perhaps the intent of Ranges was that the <code class='backtick'>ranges::range</code> concept should be stricter than 
plain range-for and all range types can be iterated via range-for with the same semantics 
as <code class='backtick'>ranges::for_each</code>. However, it seems very difficult (if not impossible) for a library 
implementation to tell whether a class has member <code class='backtick'>begin/end</code> but the corresponding member 
call is ill-formed with C++20 core language rules, and such determination is critical for 
eliminating the semantic differences between <code class='backtick'>ranges::for_each</code> and range-for.
</p>


<p id="res-4389"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<blockquote class="note">
<p>
Two mutually exclusive resolutions are proposed here. One enforces semantic-identity checks, 
while the other doesn't and makes weird types satisfy but not model the range concept. I 
prefer the stricter one because the semantic-identity checks are fully static, but this probably 
requires compilers to add new intrinsics when reflection is absent.
</p>
</blockquote>

<p>
<b>Option A</b>: (stricter)
</p>

<ol>
<li><p>Modify 25.3.2 <a href="https://timsong-cpp.github.io/cppwp/range.access.begin">[range.access.begin]</a> as indicated:</p>

<blockquote>
<p>
-2- Given a subexpression <code class='backtick'>E</code> with type <code class='backtick'>T</code>, let <code class='backtick'>t</code> be an lvalue that denotes the reified object for <code class='backtick'>E</code>. Then:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code class='backtick'>E</code> is an rvalue and <code>enable_borrowed_range&lt;remove_cv_t&lt;T&gt;&gt;</code> is 
<code class='backtick'>false</code>, <code class='backtick'>ranges::begin(E)</code> is ill-formed.</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code class='backtick'>T</code> is an array type (9.3.4.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.array">[dcl.array]</a>) and 
<code>remove_all_extents_t&lt;T&gt;</code> is an incomplete type, <code class='backtick'>ranges::begin(E)</code> is 
ill-formed with no diagnostic required.</p></li>
<li><p>(2.3) &mdash; Otherwise, if <code class='backtick'>T</code> is an array type, <code class='backtick'>ranges::begin(E)</code> is 
expression-equivalent to <code class='backtick'>t + 0</code>.</p></li>
<li><p>(2.4) &mdash; Otherwise, if <code class='backtick'>auto(t.begin())</code> is a valid expression whose type models 
<code class='backtick'>input_or_output_iterator</code>, <code class='backtick'>ranges::begin(E)</code> is expression-equivalent to <code class='backtick'>auto(t.begin())</code>.</p></li>
<li><p><ins>(2.?) &mdash; Otherwise, if <code>remove_cvref_t&lt;T&gt;</code> is a class type and search for 
<code class='backtick'>begin</code> in the scope of that class finds at least one declaration, <code class='backtick'>ranges::begin(E)</code> is ill-formed.</ins></p></li>
<li><p>(2.5) &mdash; Otherwise, if <code class='backtick'>T</code> is a class or enumeration type and <code class='backtick'>auto(begin(t))</code> 
is a valid expression whose type models <code class='backtick'>input_or_output_iterator</code> where the meaning of <code class='backtick'>begin</code> 
is established as-if by performing argument-dependent lookup only (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>), 
then <code class='backtick'>ranges::begin(E)</code> is expression-equivalent to that expression.</p></li>
<li><p>(2.6) &mdash; Otherwise, <code class='backtick'>ranges::begin(E)</code> is ill-formed.</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify 25.3.3 <a href="https://timsong-cpp.github.io/cppwp/range.access.end">[range.access.end]</a> as indicated:</p>

<blockquote>
<p>
-2- Given a subexpression <code class='backtick'>E</code> with type <code class='backtick'>T</code>, let <code class='backtick'>t</code> be an lvalue that denotes the reified object for <code class='backtick'>E</code>. Then:
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; If <code class='backtick'>E</code> is an rvalue and <code>enable_borrowed_range&lt;remove_cv_t&lt;T&gt;&gt;</code> 
is <code class='backtick'>false</code>, <code class='backtick'>ranges::end(E)</code> is ill-formed.</p></li>
<li><p>(2.2) &mdash; Otherwise, if <code class='backtick'>T</code> is an array type (9.3.4.5 <a href="https://timsong-cpp.github.io/cppwp/dcl.array">[dcl.array]</a>) and 
<code>remove_all_extents_t&lt;T&gt;</code> is an incomplete type, <code class='backtick'>ranges::end(E)</code> is ill-formed 
with no diagnostic required.</p></li>
<li><p>(2.3) &mdash; Otherwise, if <code class='backtick'>T</code> is an array of unknown bound, <code class='backtick'>ranges::end(E)</code> is ill-formed.</p></li>
<li><p>(2.4) &mdash; Otherwise, if <code class='backtick'>T</code> is an array, <code class='backtick'>ranges::end(E)</code> is expression-equivalent to 
<code>t + extent_v&lt;T&gt;</code>.</p></li>
<li><p>(2.5) &mdash; Otherwise, if <code class='backtick'>auto(t.end())</code> is a valid expression whose type models 
<code>sentinel_for&lt;iterator_t&lt;T&gt;&gt;</code> then <code class='backtick'>ranges::end(E)</code> is expression-equivalent to 
<code class='backtick'>auto(t.end())</code>.</p></li>
<li><p><ins>(2.?) &mdash; Otherwise, if <code>remove_cvref_t&lt;T&gt;</code> is a class type and search for 
<code class='backtick'>end</code> in the scope of that class finds at least one declaration, <code class='backtick'>ranges::end(E)</code> is ill-formed.</ins></p></li>
<li><p>(2.6) &mdash; Otherwise, if <code class='backtick'>T</code> is a class or enumeration type and <code class='backtick'>auto(end(t))</code> 
is a valid expression whose type models <code>sentinel_for&lt;iterator_t&lt;T&gt;&gt;</code> 
where the meaning of end is established as-if by performing argument-dependent
lookup only (6.5.4 <a href="https://timsong-cpp.github.io/cppwp/basic.lookup.argdep">[basic.lookup.argdep]</a>), then <code class='backtick'>ranges::end(E)</code> is expression-equivalent 
to that expression.</p></li>
<li><p>(2.7) &mdash; Otherwise, <code class='backtick'>ranges::end(E)</code> is ill-formed.</p></li>
</ol>
</blockquote>
</li>

<li><p>Modify 25.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.range">[range.range]</a> as indicated:</p>

<blockquote>
<p>
-1- [&hellip;]
</p>
<pre>
template&lt;class T&gt;
  concept range =
    requires(T&amp; t) {
      ranges::begin(t);    // <i>sometimes equality-preserving (see below)</i>
      ranges::end(t);
    } <ins>&amp;&amp; <i>has-consistent-begin-end</i>&lt;T&gt;</ins>; <ins>// <i>see below</i></ins>
</pre>
<p>
-2- [&hellip;]
<p/>
-3- [&hellip;]
<p/>
<ins>-?- <code><i>has-consistent-begin-end</i>&lt;T&gt;</code> is a constant expression of type <code class='backtick'>bool</code>, 
and it is <code class='backtick'>true</code> if and only if for the <code class='backtick'>t</code> introduced in the requires-expression above, either</ins>
</p>
<ol style="list-style-type: none">
<li><p><ins>(?.1) &mdash; both <code class='backtick'>ranges::begin(t)</code> and <code class='backtick'>ranges::end(t)</code> are specified to select 
<code class='backtick'>auto(t.begin())</code> and <code class='backtick'>auto(t.end())</code> respectively, or</ins></p></li>
<li><p><ins>(?.2) &mdash; both <code class='backtick'>ranges::begin(t)</code> and <code class='backtick'>ranges::end(t)</code> are specified not 
to select <code class='backtick'>auto(t.begin())</code> and <code class='backtick'>auto(t.end())</code> respectively.</ins></p></li>
</ol>
</blockquote>
</li>
</ol>

<p>
<b>Option B</b>: (looser)
</p>

<ol>
<li><p>Modify 25.4.2 <a href="https://timsong-cpp.github.io/cppwp/range.range">[range.range]</a> as indicated:</p>

<blockquote>
<p>
-1- [&hellip;]
</p>
<pre>
template&lt;class T&gt;
  concept range =
    requires(T&amp; t) {
      ranges::begin(t);    // <i>sometimes equality-preserving (see below)</i>
      ranges::end(t);
    }
</pre>
<p>
-2- Given an expression <code class='backtick'>t</code> such that <code class='backtick'>decltype((t))</code> is <code>T&amp;</code>, <code class='backtick'>T</code> models <code class='backtick'>range</code> only if
</p>
<ol style="list-style-type: none">
<li><p>(2.1) &mdash; [&hellip;]</p></li>
<li><p>(2.2) &mdash; [&hellip;]</p></li>
<li><p>(2.3) &mdash; [&hellip;]</p></li>
<li><p><ins>(2.?) &mdash; The range-based <code class='backtick'>for</code> statement <code>for (auto&amp;&amp; x: t);</code> is well-formed, 
and variable definitions <code>auto <i>begin</i> = <i>begin-expr</i>;</code> and <code>auto <i>end</i> = <i>end-expr</i>;</code> 
in the equivalent form (8.6.5 <a href="https://timsong-cpp.github.io/cppwp/stmt.ranged">[stmt.ranged]</a>) of that statement are semantically equivalent to 
<code>auto <i>begin</i> = ranges::begin(t);</code> and <code>auto <i>end</i> = ranges::end(t);</code> respectively.</ins></p></li>
</ol>

</blockquote>
</li>
</ol>






<hr>
<h3 id="4390"><a href="4390">4390</a>. <code>simd::basic_vec(U&amp;&amp;)</code> default template parameter</h3>
<p><b>Section:</b> 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-29 <b>Last modified:</b> 2025-10-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.ctor">active issues</a> in [simd.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.ctor">issues</a> in [simd.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>simd::basic_vec</code> supports <code>complex</code> after <a href="https://wg21.link/P2663R7" title=" Proposal to support interleaved complex values in std::simd">P2663R7</a>, defaulting
the template parameter of its broadcast constructor seems to be reasonable, as this allows the 
intuitive spelling:
</p>
<pre>
simd::vec&lt;complex&lt;double&gt;&gt; sc1   ({-1.0, 0.5}); // <span style="color:#C80000;font-weight:bold">current ill-formed</span>
simd::vec&lt;complex&lt;double&gt;&gt; sc2 = {{-1.0, 0.5}}; // <span style="color:#C80000;font-weight:bold">current ill-formed</span></pre>


<p id="res-4390"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.7.1 <a href="https://timsong-cpp.github.io/cppwp/simd.overview">[simd.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;class T, class Abi&gt; class basic_vec {
  public:
    [&hellip;]
    template&lt;class U <ins>= T</ins>&gt;
      constexpr explicit(<i>see below</i>) basic_vec(U&amp;&amp; value) noexcept;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U <ins>= T</ins>&gt; constexpr explicit(<i>see below</i>) basic_vec(U&amp;&amp; value) noexcept;
</pre>
<blockquote>
<p>
-1- [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4391"><a href="4391">4391</a>. Ambiguities of <code class='backtick'>simd::basic_vec</code> constructor</h3>
<p><b>Section:</b> 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-29 <b>Last modified:</b> 2025-10-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.ctor">active issues</a> in [simd.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.ctor">issues</a> in [simd.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The broadcasting, generator-based, and range constructors of <code class='backtick'>simd::basic_vec</code> all take a single
argument, and their constraints are not mutually exclusive.
<p/>
This means that when a type satisfies both characteristics, such as a range that can be converted to a
<code class='backtick'>value_type</code>, this will lead to ambiguity:
</p>
<blockquote>
<pre>
#include &lt;simd&gt;

struct S {
  operator double() const;       // basic_vec(U&amp;&amp; value)
  
  double operator()(int) const;  // basic_vec(G&amp;&amp; gen)

  double* begin() const;         // basic_vec(R&amp;&amp; r, flags&lt;Flags...&gt; = {});
  double* end() const;
  constexpr static int size() { return 2; }
};

int main() {
  std::simd::vec&lt;double&gt; simd(S{}); // <span style="color:#C80000;font-weight:bold">error: call of overloaded 'basic_simd(S)' is ambiguous</span>
}
</pre>
</blockquote>
<p>
Do we need more constraints, similar to the one in <code>string_view(R&amp;&amp; r)</code> that requires
<code class='backtick'>R</code> not to be convertible to <code class='backtick'>const char*</code>, to make the above work, i.e., only invoke the
broadcasting constructor?
</p>


<p id="res-4391"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>


<li><p>Modify 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class G&gt; constexpr explicit basic_vec(G&amp;&amp; gen);
</pre>
<blockquote>
<p>
-8- Let <code>From<sub><i>i</i></sub></code> denote the type
   <code>decltype(gen(integral_constant&lt;<i>simd-size-type</i>, <i>i</i>&gt;()))</code>.
<p/>
-9- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
   <li><p>
   <ins>(9.?) &mdash; <code>constructible_from&lt;value_type, G&gt;</code> is <code>false</code>.</ins>
   </p></li>
   <li><p>
    <ins>(9.?) &mdash;</ins>
    <code>From<sub><i>i</i></sub></code> satisfies <code>convertible_to&lt;value_type&gt;</code> for all 
    <code><i>i</i></code> in the range of [<code>0, size()</code>). In addition, for all <i>i</i> in the range of
    [<code>0, size()</code>), if <code>From<sub><i>i</i></sub></code> is an arithmetic type, conversion from 
    <code>From<sub><i>i</i></sub></code> to <code>value_type</code> is value-preserving.</p>
   </li>
</ol>
</blockquote>
[&hellip;]
<pre>
template&lt;class R, class... Flags&gt;
  constexpr basic_vec(R&amp;&amp; r, flags&lt;Flags...&gt; = {});
template&lt;class R, class... Flags&gt;
  constexpr basic_vec(R&amp;&amp; r, const mask_type&amp; mask, flags&lt;Flags...&gt; = {});
</pre>
<blockquote>
<p>
-12- Let mask be <code class='backtick'>mask_type(true)</code> for the overload with no <code class='backtick'>mask</code> parameter.
<p/>
-13- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
   <li><p>
   (13.1) &mdash; <code class='backtick'>R</code> models <code class='backtick'>ranges::contiguous_range</code> and <code class='backtick'>ranges::sized_range</code>,
   </p></li>
   <li><p>
   (13.2) &mdash; <code class='backtick'>ranges::size(r)</code> is a constant expression, <del>and</del>
   </p></li>
   <li><p>
   (13.3) &mdash; <code class='backtick'>ranges::size(r)</code> is equal to <code class='backtick'>size()</code><del>.</del><ins>,</ins>
   </p></li>
   <li><p>
   <ins>(13.?) &mdash; <code>constructible_from&lt;value_type, R&gt;</code> is <code class='backtick'>false</code>, and</ins>
   </p></li>
   <li><p>
   <ins>(13.?) &mdash; <code>r(integral_constant&lt;<i>simd-size-type</i>, 0&gt;())</code> is not a valid
            expression.</ins>
   </p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4392"><a href="4392">4392</a>. <code class='backtick'>simd::unchecked_load</code> misses difference type casting</h3>
<p><b>Section:</b> 29.10.8.7 <a href="https://timsong-cpp.github.io/cppwp/simd.loadstore">[simd.loadstore]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-29 <b>Last modified:</b> 2025-10-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.loadstore">active issues</a> in [simd.loadstore].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.loadstore">issues</a> in [simd.loadstore].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>simd::unchecked_load</code>/<code class='backtick'>partial_load</code>/<code class='backtick'>unchecked_store</code>/<code class='backtick'>partial_store</code> construct a 
<code class='backtick'>span</code> via <code class='backtick'>span(first, n)</code> when taking an iterator <code class='backtick'>first</code> and its difference type <code class='backtick'>n</code>.
<p/>
However, the construction is ill-formed when the difference type is an integer-class type; we should perform
an explicit casting here.
</p>


<p id="res-4392"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>


<li><p>In subclause 29.10.8.7 <a href="https://timsong-cpp.github.io/cppwp/simd.loadstore">[simd.loadstore]</a> replace all occurrences of 
</p>
<blockquote><pre>
R(first, n)
</pre></blockquote>
<p>
by
</p>
<blockquote><pre>
R(first, <ins>static_cast&lt;size_t&gt;(</ins>n<ins>)</ins>)
</pre></blockquote>
</li>
</ol>






<hr>
<h3 id="4393"><a href="4393">4393</a>. <code class='backtick'>simd::unchecked_scatter_to</code> is underconstrained</h3>
<p><b>Section:</b> 29.10.8.11 <a href="https://timsong-cpp.github.io/cppwp/simd.permute.memory">[simd.permute.memory]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-29 <b>Last modified:</b> 2025-10-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both <code class='backtick'>simd::unchecked_scatter_to</code> and <code class='backtick'>simd::partial_scatter_to</code> are used to write a
<code class='backtick'>simd::vec</code> into a range <code class='backtick'>R</code>.
<p/>
However, they only require <code class='backtick'>R</code> to be <code class='backtick'>contiguous_range</code> and <code class='backtick'>sized_range</code>.
Requiring <code class='backtick'>R</code> to be <code class='backtick'>output_range</code> is also necessary; otherwise, the 
<code class='backtick'>constant_range</code> cannot be written.
</p>


<p id="res-4393"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.3 <a href="https://timsong-cpp.github.io/cppwp/simd.syn">[simd.syn]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  [&hellip;]
  template&lt;<i>simd-vec-type</i> V, ranges::contiguous_range R, <i>simd-integral</i> I, class... Flags&gt;
    requires ranges::sized_range&lt;R&gt; <ins>&amp;&amp; ranges::output_range&lt;R, typename V::value_type&gt;</ins>
    constexpr void
      unchecked_scatter_to(const V&amp; v, R&amp;&amp; out,
                           const I&amp; indices, flags&lt;Flags...&gt; f = {});
  template&lt;<i>simd-vec-type</i> V, ranges::contiguous_range R, <i>simd-integral</i> I, class... Flags&gt;
    requires ranges::sized_range&lt;R&gt; <ins>&amp;&amp; ranges::output_range&lt;R, typename V::value_type&gt;</ins>
    constexpr void
      unchecked_scatter_to(const V&amp; v, R&amp;&amp; out, const typename I::mask_type&amp; mask,
                           const I&amp; indices, flags&lt;Flags...&gt; f = {});

  template&lt;<i>simd-vec-type</i> V, ranges::contiguous_range R, <i>simd-integral</i> I, class... Flags&gt;
    requires ranges::sized_range&lt;R&gt; <ins>&amp;&amp; ranges::output_range&lt;R, typename V::value_type&gt;</ins>
    constexpr void
      partial_scatter_to(const V&amp; v, R&amp;&amp; out,
                         const I&amp; indices, flags&lt;Flags...&gt; f = {});
  template&lt;<i>simd-vec-type</i> V, ranges::contiguous_range R, <i>simd-integral</i> I, class... Flags&gt;
    requires ranges::sized_range&lt;R&gt; <ins>&amp;&amp; ranges::output_range&lt;R, typename V::value_type&gt;</ins>
    constexpr void
      partial_scatter_to(const V&amp; v, R&amp;&amp; out, const typename I::mask_type&amp; mask,
                         const I&amp; indices, flags&lt;Flags...&gt; f = {});
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 29.10.8.11 <a href="https://timsong-cpp.github.io/cppwp/simd.permute.memory">[simd.permute.memory]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>simd-vec-type</i> V, ranges::contiguous_range R, <i>simd-integral</i> I, class... Flags&gt;
  requires ranges::sized_range&lt;R&gt; <ins>&amp;&amp; ranges::output_range&lt;R, typename V::value_type&gt;</ins>
  constexpr void unchecked_scatter_to(const V&amp; v, R&amp;&amp; out, const I&amp; indices,
                                      flags&lt;Flags...&gt; f = {});
template&lt;<i>simd-vec-type</i> V, ranges::contiguous_range R, <i>simd-integral</i> I, class... Flags&gt;
  requires ranges::sized_range&lt;R&gt; <ins>&amp;&amp; ranges::output_range&lt;R, typename V::value_type&gt;</ins>
  constexpr void unchecked_scatter_to(const V&amp; v, R&amp;&amp; out, const typename I::mask_type&amp; mask,
                                      const I&amp; indices, flags&lt;Flags...&gt; f = {});
</pre>
<blockquote>
<p>
-10- Let <code class='backtick'>mask</code> be <code class='backtick'>typename I::mask_type(true)</code> for the overload with no <code class='backtick'>mask</code> parameter.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;<i>simd-vec-type</i> V, ranges::contiguous_range R, <i>simd-integral</i> I, class... Flags&gt;
  requires ranges::sized_range&lt;R&gt; <ins>&amp;&amp; ranges::output_range&lt;R, typename V::value_type&gt;</ins>
  constexpr void
  partial_scatter_to(const V&amp; v, R&amp;&amp; out, const I&amp; indices, flags&lt;Flags...&gt; f = {});
template&lt;<i>simd-vec-type</i> V, ranges::contiguous_range R, <i>simd-integral</i> I, class... Flags&gt;
  requires ranges::sized_range&lt;R&gt; <ins>&amp;&amp; ranges::output_range&lt;R, typename V::value_type&gt;</ins>
  constexpr void partial_scatter_to(const V&amp; v, R&amp;&amp; out, const typename I::mask_type&amp; mask,
                                    const I&amp; indices, flags&lt;Flags...&gt; f = {});
</pre>
<blockquote>
<p>
-13- Let <code class='backtick'>mask</code> be <code class='backtick'>typename I::mask_type(true)</code> for the overload with no <code class='backtick'>mask</code> parameter.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4394"><a href="4394">4394</a>. <code class='backtick'>simd::unchecked_load(I first, S last)</code> construct <code class='backtick'>span</code> maybe ill-formed</h3>
<p><b>Section:</b> 29.10.8.7 <a href="https://timsong-cpp.github.io/cppwp/simd.loadstore">[simd.loadstore]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-30 <b>Last modified:</b> 2025-10-03</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.loadstore">active issues</a> in [simd.loadstore].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.loadstore">issues</a> in [simd.loadstore].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>simd::unchecked_load</code>/<code class='backtick'>partial_load</code>/<code class='backtick'>unchecked_store</code>/<code class='backtick'>partial_store</code>
constructs a <code class='backtick'>span</code> via <code class='backtick'>span(first, last)</code> when taking an iterator-sentinel pair
<code class='backtick'>first</code> and <code class='backtick'>last</code>.
<p/>
However, the construction may not be well-behaved or well-formed when the sentinel type 
can be implicitly converted to an integer type. Consider:
</p>
<blockquote><pre>
struct I {
  using value_type = int;
  using difference_type = int;
  using iterator_category = std::contiguous_iterator_tag;
  // contiguous iterator operators
  // ...
 
  operator int() const;
};

int main() {
   std::simd::unchecked_load(I{}, I{});
}
</pre></blockquote>
<p>
Above, <code class='backtick'>unchecked_load</code> invokes <code class='backtick'>unchecked_load(I first, S last)</code> and we attempt to
construct <code class='backtick'>span</code> through <code class='backtick'>span(first, last)</code>.
However, this is invalid because the constructor requires that the sentinel type should not be convertible to
<code class='backtick'>size_t</code>, so we fall back into <code class='backtick'>span(first, n)</code> via implicitly converting <code class='backtick'>I</code> to <code class='backtick'>size_t</code>. Such
behavior is subtle and likely unintended.
<p/>
Now consider:
</p>
<blockquote><pre>
struct I {
  using value_type = int;
  using difference_type = int;
  using iterator_category = std::contiguous_iterator_tag;
  // contiguous iterator operators
  // ...

  operator int() &amp;&amp;;
};

int main() {
   std::simd::unchecked_load(I{}, I{});
}
</pre></blockquote>
<p>
We still attempt to construct the <code class='backtick'>span</code> by calling <code class='backtick'>span(first, last)</code>, which is invalid,
but because the lvalue sentinel cannot be converted to <code class='backtick'>size_t</code>, the call of <code class='backtick'>span(first, n)</code>
is also invalid. This makes the construction of the <code class='backtick'>span</code> ill-formed and leads to a hard error in
the function body.
</p>


<p id="res-4394"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>


<li><p>In subclause 29.10.8.7 <a href="https://timsong-cpp.github.io/cppwp/simd.loadstore">[simd.loadstore]</a> replace all occurrences of 
</p>
<blockquote><pre>
R(first, last)
</pre></blockquote>
<p>
by
</p>
<blockquote><pre>
R(first, <ins>static_cast&lt;size_t&gt;(</ins>last<ins> - first)</ins>)
</pre></blockquote>
</li>
</ol>






<hr>
<h3 id="4395"><a href="4395">4395</a>. <code class='backtick'>write_env</code> implementation-detail lambda should have explicit return type</h3>
<p><b>Section:</b> 33.9.12.3 <a href="https://timsong-cpp.github.io/cppwp/exec.write.env">[exec.write.env]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Robert A.H. Leahy <b>Opened:</b> 2025-09-29 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 33.9.12.3 <a href="https://timsong-cpp.github.io/cppwp/exec.write.env">[exec.write.env]</a> the impls for <code class='backtick'>std::execution::write_env</code> has <code><i>get-env</i></code> 
specified as:
</p>
<blockquote><pre>
static constexpr auto <i>get-env</i> =
  [](auto, const auto&amp; state, const auto&amp; rcvr) noexcept {
    return <i>see-below</i>;
  };
</pre></blockquote>
<p>
This uses automatic return type deduction which means that the body of the lambda is actually instantiated 
in a SFINAE-unfriendly way when attempting to compute various properties of the lambda (invocability, 
return type, et cetera). This is undesirable and surprising as has been discovered in actual use/deployment 
(see: <a href="https://github.com/NVIDIA/stdexec/pull/1654">https://github.com/NVIDIA/stdexec/pull/1654</a>).
<p/>
The fix is to explicitly provide a return type for the lambda which computes the type of the body.
<p/>
Note: This issue may indicate that the use of automatic return type deduction in the specification of
sender algorithms more generally ought to be reconsidered/-examined.
</p>


<p id="res-4395"><b>Proposed resolution:</b></p>





<hr>
<h3 id="4396"><a href="4396">4396</a>. Improve <code>inplace_vector(from_range_t, R&amp;&amp; rg)</code></h3>
<p><b>Section:</b> 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a>, 23.3.16.2 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.cons">[inplace.vector.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-01 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote><pre>
std::array&lt;int, 42&gt; a;
std::inplace_vector&lt;int, 5&gt; v(std::from_range, a);
</pre></blockquote>
<p>
The above throws <code class='backtick'>std::bad_alloc</code> at runtime because the size of <code class='backtick'>array</code> is larger than
capacity of <code class='backtick'>inplace_vector</code>. However, we should reject it at compile time since the 
<code class='backtick'>array</code> size is a constant expression.
<p/>
Given that we do a lot of compile-time size checking in <code>&lt;simd&gt;</code>,
it's worth applying that here as well. Compile-time errors are better than runtime ones.
</p>


<p id="res-4396"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.2.4 <a href="https://timsong-cpp.github.io/cppwp/sequence.reqmts">[sequence.reqmts]</a> as indicated:</p>

<blockquote>
<pre>
a.assign_range(rg)
</pre>
<blockquote>
<p>
-60- <i>Result</i>: <code>void</code>
<p/>
-61- <i>Mandates</i>: <code>assignable_from&lt;T&amp;, ranges::range_reference_t&lt;R&gt;&gt;</code> is modeled.
<ins>For <code class='backtick'>inplace_vector</code>, if <code class='backtick'>ranges::size(rg)</code> is a constant expression then <code class='backtick'>ranges::size(rg)</code>  <code class='backtick'>a.max_size()</code></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.16.2 <a href="https://timsong-cpp.github.io/cppwp/inplace.vector.cons">[inplace.vector.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>container-compatible-range</i>&lt;T&gt; R&gt;
  constexpr inplace_vector(from_range_t, R&amp;&amp; rg);
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates</i>: If <code class='backtick'>ranges::size(rg)</code> is a constant expression then <code class='backtick'>ranges::size(rg)</code>  <code class='backtick'>N</code>.</ins>
<p/>
-9- <i>Effects</i>: Constructs an <code class='backtick'>inplace_vector</code> with the elements of the range <code class='backtick'>rg</code>.
<p/>
-10- <i>Complexity</i>: Linear in <code class='backtick'>ranges::distance(rg)</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4397"><a href="4397">4397</a>. Improve <code>span(R&amp;&amp; r)</code></h3>
<p><b>Section:</b> 23.7.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/span.cons">[span.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-02 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#span.cons">issues</a> in [span.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is preferable to reject <code>span&lt;int, 42&gt;(views::empty&lt;int&gt;)</code>
at compile-time after <a href="https://wg21.link/P2280R4" title=" Using unknown references in constant expressions">P2280R4</a>, since applying <code class='backtick'>ranges::size</code> on those 
ranges is a constant expression now.
</p>


<p id="res-4397"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.7.2.2.2 <a href="https://timsong-cpp.github.io/cppwp/span.cons">[span.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R&gt; constexpr explicit(extent != dynamic_extent) span(R&amp;&amp; r);
</pre>
<blockquote>
<p>
<ins>-?- <i>Mandates</i>: If <code class='backtick'>extent</code> is not equal to <code class='backtick'>dynamic_extent</code> and <code class='backtick'>ranges::size(r)</code> is a
constant expression, then <code class='backtick'>ranges::size(r) == extent</code> is <code class='backtick'>true</code>.</ins>
<p/>
-16- <i>Constraints</i>: Let <code class='backtick'>U</code> be <code>remove_reference_t&lt;ranges::range_reference_t&lt;R&gt;&gt;</code>. 
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4398"><a href="4398">4398</a>. <code class='backtick'>enable_nonlocking_formatter_optimization</code> should be disabled for container adaptors</h3>
<p><b>Section:</b> 23.6.2 <a href="https://timsong-cpp.github.io/cppwp/queue.syn">[queue.syn]</a>, 23.6.5 <a href="https://timsong-cpp.github.io/cppwp/stack.syn">[stack.syn]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kamiski <b>Opened:</b> 2025-10-02 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As the standard currently defines formatters for <code class='backtick'>queue</code>, <code class='backtick'>prioriy_queue</code>, and <code class='backtick'>stack</code>  
<code class='backtick'>enable_nonlocking_formatter_optimization</code> is specialized to <code class='backtick'>true</code> for these adaptors per 
28.5.6.4 <a href="https://timsong-cpp.github.io/cppwp/format.formatter.spec">[format.formatter.spec]</a> p3:
</p>
<blockquote>
<p>
Unless specified otherwise, for each type <code class='backtick'>T</code> for which a formatter specialization is provided 
by the library, each of the headers provides the following specialization: 
</p>
<blockquote><pre>
template&lt;&gt; inline constexpr bool enable_nonlocking_formatter_optimization&lt;T&gt; = true;
</pre></blockquote>
</blockquote>
<p>
However, formatting an adaptor requires formatting of the underlying range
in terms of <code class='backtick'>ranges::ref_view</code>, and we disable the nonlocking_optimizations for all ranges, including <code class='backtick'>ranges::ref_view</code>.
<p/>
This problem does not occur for the <code class='backtick'>flat_set</code>, <code class='backtick'>flat_map</code> adaptors, which are
also ranges, but unlike <code class='backtick'>stack</code> etc. they do not have a specialized formatter.
They use the <code class='backtick'>formatter</code> specialization for ranges and we already disable the
optimization for that formatter.
<p/>
The proposed wording has recently been implemented in 
<a href="https://gcc.gnu.org/pipermail/libstdc++/2025-October/063758.html">gcc's libstdc++</a>.
</p>


<p id="res-4398"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.6.2 <a href="https://timsong-cpp.github.io/cppwp/queue.syn">[queue.syn]</a>, header <code>&lt;queue&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
// <i>23.6.13 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.format">[container.adaptors.format]</a>, formatter specialization for queue</i>
template&lt;class charT, class T, formattable&lt;charT&gt; Container&gt;
  struct formatter&lt;queue&lt;T, Container&gt;, charT&gt;;
  
<ins>template&lt;class T, class Container&gt;
  constexpr bool enable_nonlocking_formatter_optimization&lt;queue&lt;T, Container&gt;&gt; = false;</ins>

// <i>23.6.4 <a href="https://timsong-cpp.github.io/cppwp/priority.queue">[priority.queue]</a>, class template priority_queue</i>
template&lt;class T, class Container = vector&lt;T&gt;,
         class Compare = less&lt;typename Container::value_type&gt;&gt;
  class priority_queue;
[&hellip;]
// <i>23.6.13 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.format">[container.adaptors.format]</a>, formatter specialization for priority_queue</i>
template&lt;class charT, class T, formattable&lt;charT&gt; Container, class Compare&gt;
  struct formatter&lt;priority_queue&lt;T, Container, Compare&gt;, charT&gt;;
  
<ins>template&lt;class T, class Container, class Compare&gt;
  constexpr bool enable_nonlocking_formatter_optimization&lt;priority_queue&lt;T, Container, Compare&gt;&gt; = false;</ins>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Modify 23.6.5 <a href="https://timsong-cpp.github.io/cppwp/stack.syn">[stack.syn]</a>, header <code>&lt;stack&gt;</code> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]

// <i>23.6.13 <a href="https://timsong-cpp.github.io/cppwp/container.adaptors.format">[container.adaptors.format]</a>, formatter specialization for stack</i>
template&lt;class charT, class T, formattable&lt;charT&gt; Container&gt;
  struct formatter&lt;stack&lt;T, Container&gt;, charT&gt;;

<ins>template&lt;class T, class Container&gt;
  constexpr bool enable_nonlocking_formatter_optimization&lt;stack&lt;T, Container&gt;&gt; = false;</ins>

[&hellip;]
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4399"><a href="4399">4399</a>. <code class='backtick'>enable_nonlocking_formatter_optimization</code> for <code class='backtick'>pair</code> and <code class='backtick'>tuple</code> needs <code class='backtick'>remove_cvref_t</code></h3>
<p><b>Section:</b> 28.5.9 <a href="https://timsong-cpp.github.io/cppwp/format.tuple">[format.tuple]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kamiski <b>Opened:</b> 2025-10-02 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <code class='backtick'>enable_nonlocking_formatter_optimization</code> variable template is specialized only for <i>cv</i>-unqualified 
types. However, the specialization for <code class='backtick'>pair</code> and <code class='backtick'>tuple</code> does not remove the references and 
<i>cv</i>-qualifiers from the elements:
</p>
<blockquote><pre>
template&lt;class... Ts&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;<i>pair-or-tuple</i>&lt;Ts...&gt;&gt; = 
    (enable_nonlocking_formatter_optimization&lt;Ts&gt; &amp;&amp; ...);
</pre></blockquote>
<p>
As consequence <code>pair&lt;const std::string, int&gt;</code> or 
<code>pair&lt;const std::string&amp;, int&amp;&gt;</code> (<code class='backtick'>map</code> and <code class='backtick'>flat_map</code> reference types) 
will not use unbuffered prints.
<p/>
The proposed wording has recently been implemented in 
<a href="https://gcc.gnu.org/pipermail/libstdc++/2025-October/063758.html">gcc's libstdc++</a>.
</p>


<p id="res-4399"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 28.5.9 <a href="https://timsong-cpp.github.io/cppwp/format.tuple">[format.tuple]</a> as indicated:</p>

<blockquote>
<p>
-1- For each of <code class='backtick'>pair</code> and <code class='backtick'>tuple</code>, the library provides the following formatter specialization 
where <code><i>pair-or-tuple</i></code> is the name of the template:
</p>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  
  template&lt;class... Ts&gt; 
    constexpr bool enable_nonlocking_formatter_optimization&lt;<i>pair-or-tuple</i>&lt;Ts...&gt;&gt; = 
      (enable_nonlocking_formatter_optimization&lt;<ins>remove_cvref_t&lt;</ins>Ts<ins>&gt;</ins>&gt; &amp;&amp; ...);
}
</pre>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4400"><a href="4400">4400</a>. <code class='backtick'>enable_nonlocking_formatter_optimization</code> for durations with custom rep</h3>
<p><b>Section:</b> 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kamiski <b>Opened:</b> 2025-10-02 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.format">active issues</a> in [time.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.format">issues</a> in [time.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the <code class='backtick'>enable_nonlocking_formatter_optimization</code> is enabled for 
<code>duration&lt;Rep, Ratio&gt;</code> if it is enabled for <code class='backtick'>Rep</code>.
</p>
<blockquote><pre>
template&lt;class Rep, class Period&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::duration&lt;Rep, Period&gt;&gt;
    =  enable_nonlocking_formatter_optimization&lt;Rep&gt;;
</pre></blockquote>
<p>
However, this does not take into the consideration that for custom <code class='backtick'>Rep</code> types, the arithmetic 
operations on <code class='backtick'>Rep</code> may also lock the stream leading to deadlock (for example log on overflow).
Since they are required to handle the specifiers such as <code class='backtick'>%S</code> we should specialize 
<code class='backtick'>enable_nonlocking_formatter_optimization</code> only for built-in types:
</p>
<blockquote><pre>
template&lt;class Rep, class Period&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::duration&lt;Rep, Period&gt;&gt;
    =  is_arithmetic_v&lt;Rep&gt;;
</pre></blockquote>
<p>
Furtheremore, for all types that are currently templated on <code class='backtick'>Duration</code> (<code class='backtick'>hh_mm_ss</code>, <code class='backtick'>sys_time</code>, 
<code class='backtick'>local_time</code>, etc.), we <code class='backtick'>enable_nonlocking_formatter_optimization</code> by default. This again does 
not take into consideration the arithmetic operations performed as duration. We should specialize 
<code class='backtick'>enable_nonlocking_formatter_optimization</code> for all of them to be enabled if 
<code class='backtick'>enable_nonlocking_formatter_optimization</code> is enabled for <code class='backtick'>duration</code>:
</p>
<blockquote><pre>
template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::hh_mm_ss&lt;Duration&gt;&gt;
    =  enable_nonlocking_formatter_optimization&lt;Duration&gt;;
</pre></blockquote>
<p>
Note, that forwarding to <code class='backtick'>enable_nonlocking_formatter_optimization</code> on <code class='backtick'>Duration</code> instead of 
checking <code class='backtick'>Duration::rep</code> allows users to specialize <code class='backtick'>enable_nonlocking_formatter_optimization</code> for 
Durations with there custom representation types.
<p/>
The proposed wording has recently been implemented in 
<a href="https://gcc.gnu.org/pipermail/libstdc++/2025-October/063758.html">gcc's libstdc++</a>.
</p>


<p id="res-4400"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 30.12 <a href="https://timsong-cpp.github.io/cppwp/time.format">[time.format]</a> as indicated:</p>

<blockquote>
<p>
-8- For <code class='backtick'>chrono::duration</code><ins>, <code class='backtick'>chrono::hh_mm_ss</code>, <code class='backtick'>chrono::sys_time</code>, <code class='backtick'>chrono::utc_time</code>, 
<code class='backtick'>chrono::tai_time</code>, <code class='backtick'>chrono::gps_time</code>, <code class='backtick'>chrono::file_time</code>, <code class='backtick'>chrono::local_time</code>, 
<code>chrono::<i>local-time-format-t</i></code>, and <code class='backtick'>chrono::zoned_time</code></ins> the library only 
provides the following specialization<ins>s</ins> of <code class='backtick'>enable_nonlocking_formatter_optimization</code>:
</p>
<blockquote>
<pre>
template&lt;class Rep, class Period&gt;
  constexpr bool enable_nonlocking_formatter_optimization&lt;
    chrono::duration&lt;Rep, Period&gt;&gt; =
      <del>enable_nonlocking_formatter_optimization</del><ins>is_arithmetic_v</ins>&lt;Rep&gt;;
      
<ins>template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::hh_mm_ss&lt;Duration&gt;&gt; 
     = enable_nonlocking_formatter_optimization&lt;Duration&gt;;

template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::sys_time&lt;Duration&gt;&gt; 
     = enable_nonlocking_formatter_optimization&lt;Duration&gt;;

template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::utc_time&lt;Duration&gt;&gt; 
     = enable_nonlocking_formatter_optimization&lt;Duration&gt;;

template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::tai_time&lt;Duration&gt;&gt; 
     = enable_nonlocking_formatter_optimization&lt;Duration&gt;;

template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::gps_time&lt;Duration&gt;&gt; 
     = enable_nonlocking_formatter_optimization&lt;Duration&gt;;

template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::file_time&lt;Duration&gt;&gt; 
     = enable_nonlocking_formatter_optimization&lt;Duration&gt;;

template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::local_time&lt;Duration&gt;&gt; 
     = enable_nonlocking_formatter_optimization&lt;Duration&gt;;

template&lt;class Duration&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;chrono::<i>local-time-format-t</i>&lt;Duration&gt;&gt; 
     = enable_nonlocking_formatter_optimization&lt;Duration&gt;;</ins>
</pre>
</blockquote>
<p>
<del>-9- For <code class='backtick'>chrono::zoned_time</code> the library only provides the following specialization of 
<code class='backtick'>enable_nonlocking_formatter_optimization</code>:</del>
</p>
<blockquote>
<pre>
template&lt;class Duration&gt;
  constexpr bool enable_nonlocking_formatter_optimization&lt;
    chrono::zoned_time&lt;Duration, const std::chrono::time_zone*&gt;&gt; 
      = <del>true</del><ins>enable_nonlocking_formatter_optimization&lt;Duration&gt;</ins>;
</pre>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4401"><a href="4401">4401</a>. <code class='backtick'>join_view</code> should be <code class='backtick'>sized_range</code> when applied to ranges of <code class='backtick'>simd::vec</code></h3>
<p><b>Section:</b> 25.7.14.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.view">[range.join.view]</a>, 25.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.view">[range.join.with.view]</a>, 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-02 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#range.join.view">active issues</a> in [range.join.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#range.join.view">issues</a> in [range.join.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
<p/>
Collecting a <code class='backtick'>simd::vec</code> into a <code class='backtick'>vector</code> for output is a common use case. <a href="https://wg21.link/P3480R6" title=" std::simd is a range">P3480R6</a>
makes <code class='backtick'>simd::vec</code> a range so we can simply flatten it with <code class='backtick'>views::join</code> (original example from
the paper):
</p>
<blockquote><pre>
std::vector&lt;std::simd::vec&lt;float&gt;&gt; data;
auto range_of_float = data | std::views::join;
</pre></blockquote>
<p>
In this case, it makes sense for <code class='backtick'>join_view</code> to be <code class='backtick'>sized_range</code> because <code class='backtick'>simd::vec::size()</code> 
is a constant expression that can be multiplied by the original <code class='backtick'>vector</code> size to get the 
result size of the <code class='backtick'>join_view</code>.
<p/>
In <code>&lt;ranges&gt;</code>, we use the <code><i>tiny-range</i></code> concept
to consider types that can obtain static sizes specifically, and <code class='backtick'>simd::vec</code> 
seems to be a good fit.
</p>


<p id="res-4401"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 25.7.14.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.view">[range.join.view]</a> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The proposed wording follows the <code><i>tiny-range</i></code>'s way to check if
<code class='backtick'>R::size()</code> is a constant expression instead of further checking <code class='backtick'>ranges::size(r)</code> for simplicity.]
</p>
</blockquote>

<blockquote>
<pre>
namespace std::ranges {
  <ins>template&lt;auto&gt; struct <i>require-constant</i>;  // <i>exposition only</i>

  template&lt;class R&gt;
  concept <i>static-sized-range</i> =             // <i>exposition only</i>
    sized_range&lt;R&gt; &amp;&amp;
    requires { typename <i>require-constant</i>&lt;remove_reference_t&lt;R&gt;::size()&gt;; };</ins>

  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;&gt;
  class join_view : public view_interface&lt;join_view&lt;V&gt;&gt; {
  [&hellip;]
  public:
    [&hellip;]
    <ins>constexpr auto size()
      requires sized_range&lt;V&gt; &amp;&amp; <i>static-sized-range</i>&lt;<i>InnerRng</i>&gt; {
      using CT = common_type_t&lt;range_size_t&lt;V&gt;, range_size_t&lt;<i>InnerRng</i>&gt;&gt;;
      return CT(ranges::size(<i>base_</i>)) * CT(remove_reference_t&lt;<i>InnerRng</i>&gt;::size());
    }

    constexpr auto size() const
      requires sized_range&lt;const V&gt; &amp;&amp;
               <i>static-sized-range</i>&lt;range_reference_t&lt;const V&gt;&gt; {
      using <i>InnerConstRng</i> = range_reference_t&lt;const V&gt;;
      using CT = common_type_t&lt;range_size_t&lt;V&gt;, range_size_t&lt;<i>InnerConstRng</i>&gt;&gt;;
      return CT(ranges::size(<i>base_</i>)) * CT(remove_reference_t&lt;<i>InnerConstRng</i>&gt;::size());
    }</ins>
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.15.2 <a href="https://timsong-cpp.github.io/cppwp/range.join.with.view">[range.join.with.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  [&hellip;]
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt;
          &amp;&amp; <i>concatable</i>&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  class join_with_view : public view_interface&lt;join_with_view&lt;V, Pattern&gt;&gt; {
  [&hellip;]
  public:
    [&hellip;]
    <ins>constexpr auto size()
      requires sized_range&lt;V&gt; &amp;&amp; sized_range&lt;Pattern&gt; &amp;&amp;
               <i>static-sized-range</i>&lt;<i>InnerRng</i>&gt; {
      using CT = common_type_t&lt;
        range_size_t&lt;V&gt;, range_size_t&lt;<i>InnerRng</i>&gt;, range_size_t&lt;Pattern&gt;&gt;;
      const auto base_size = ranges::size(<i>base_</i>);
      if (base_size == 0)
        return CT(0);
      return CT(base_size) * CT(remove_reference_t&lt;<i>InnerRng</i>&gt;::size()) +
             CT(base_size - 1) * CT(ranges::size(<i>pattern_</i>));
    }

    constexpr auto size() const
      requires sized_range&lt;const V&gt; &amp;&amp; sized_range&lt;const Pattern&gt; &amp;&amp;
               <i>static-sized-range</i>&lt;range_reference_t&lt;const V&gt;&gt; {
      using <i>InnerConstRng</i> = range_reference_t&lt;const V&gt;;
      using CT = common_type_t&lt;
        range_size_t&lt;const V&gt;, range_size_t&lt;<i>InnerConstRng</i>&gt;, range_size_t&lt;const Pattern&gt;&gt;;
      const auto base_size = ranges::size(<i>base_</i>);
      if (base_size == 0)
        return CT(0);
      return CT(base_size) * CT(remove_reference_t&lt;<i>InnerConstRng</i>&gt;::size()) +
             CT(base_size - 1) * CT(ranges::size(<i>pattern_</i>));
    }</ins>
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 25.7.16.2 <a href="https://timsong-cpp.github.io/cppwp/range.lazy.split.view">[range.lazy.split.view]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::ranges {
  <del>template&lt;auto&gt; struct <i>require-constant</i>;                       // <i>exposition only</i></del>

  template&lt;class R&gt;
  concept <i>tiny-range</i> =                                          // <i>exposition only</i>
    <ins><i>static-sized-range</i>&lt;R&gt;</ins><del>sized_range&lt;R&gt; &amp;&amp;
    requires { typename <i>require-constant</i>&lt;remove_reference_t&lt;R&gt;::size()&gt;; }</del> &amp;&amp;
    (remove_reference_t&lt;R&gt;::size() &lt;= 1);
  
  [&hellip;]
}
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4402"><a href="4402">4402</a>. List-initialization of iterators in [simd.mask.overview]</h3>
<p><b>Section:</b> 29.10.9.1 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.overview">[simd.mask.overview]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2025-10-02 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.10.9.1 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.overview">[simd.mask.overview]</a> has
</p>
<blockquote><pre>
namespace std::simd {
 template&lt;class V&gt;
 class <i>simd-iterator</i> { // exposition only
  V* <i>data_</i> = nullptr; // exposition only
  <i>simd-size-type</i> <i>offset_</i> = 0; // exposition only
  <b>constexpr <i>simd-iterator</i>(V&amp; d, <i>simd-size-type</i> off) noexcept; // <i>exposition only</i></b>
  [&hellip;]
 };
[&hellip;]
 template&lt;size_t Bytes, class Abi&gt;
  class basic_mask {
  public:
   using value_type = bool;
   using abi_type = Abi;
   using iterator = <i>simd-iterator</i>&lt;basic_mask&gt;;
   using const_iterator = <i>simd-iterator</i>&lt;const basic_mask&gt;;
   <b>constexpr iterator begin() noexcept { return {*this, 0}; }</b>
   constexpr const_iterator begin() const noexcept { return {*this, 0}; }
   constexpr const_iterator cbegin() const noexcept { return {*this, 0}; }
   constexpr default_sentinel_t end() const noexcept { return {}; }
   constexpr default_sentinel_t cend() const noexcept { return {}; }
   [&hellip;]
</pre></blockquote>
<p>
It's unclear whether the "exposition-only" constructor is required to be present. If it is present, 
as written, without <code class='backtick'>explicit</code>, then <code class='backtick'>{someBasicMask, 0}</code> becomes a valid initializer for an iterator. 
Evidence in favor of its intentionality: the use of <code class='backtick'>return {*this, 0}</code> in <code class='backtick'>basic_mask::begin()</code>.
(The constructor is <code class='backtick'>private</code>, but it still participates in overload resolution and will ambiguate 
other possible conversions.) But this makes many expressions ambiguous that could be unambiguous to a human.
</p>
<blockquote><pre>
using Mask = std::simd::mask&lt;int&gt;;

void overloaded(std::string, std::pair&lt;Mask, int&gt; kv);
void overloaded(std::string, Mask::iterator it);

int main() {
  Mask m;
  overloaded("the pair is", {m, 0});  // ambiguous?
}
</pre></blockquote>
<p>
At the very least, we should say that this list-initialization is intentional, and add wording to 
class <code><i>simd-iterator</i></code> and/or remove the "exposition only" from <code><i>simd-iterator</i></code>'s 
constructor. That makes it clear that the above program is indeed intended to be ambiguous. But IMO 
we should instead simply make the above program valid.
</p>


<p id="res-4402"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.6 <a href="https://timsong-cpp.github.io/cppwp/simd.iterator">[simd.iterator]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;class V&gt;
  class <i>simd-iterator</i> {                                                  // <i>exposition only</i>
    V* <i>data_</i> = nullptr;                                                  // <i>exposition only</i>
    <i>simd-size-type</i> <i>offset_</i> = 0;                                          // <i>exposition only</i>
    constexpr <ins>explicit</ins> <i>simd-iterator</i>(V&amp; d, <i>simd-size-type</i> off) noexcept; // <i>exposition only</i>
    
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Modify 29.10.7.1 <a href="https://timsong-cpp.github.io/cppwp/simd.overview">[simd.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;size_t T, class Abi&gt; class basic_vec {
  public:
    using value_type = T;
    using mask_type = basic_mask&lt;sizeof(T), Abi&gt;;
    using abi_type = Abi;
    using iterator = <i>simd-iterator</i>&lt;basic_vec&gt;;
    using const_iterator = <i>simd-iterator</i>&lt;const basic_vec&gt;;

    constexpr iterator begin() noexcept { return <ins>iterator(</ins><del>{</del>*this, 0<del>}</del><ins>)</ins>; }
    constexpr const_iterator begin() const noexcept { return <ins>const_iterator(</ins><del>{</del>*this, 0<del>}</del><ins>)</ins>; }
    constexpr const_iterator cbegin() const noexcept { return <ins>const_iterator(</ins><del>{</del>*this, 0<del>}</del><ins>)</ins>; }
    constexpr default_sentinel_t end() const noexcept { return {}; }
    constexpr default_sentinel_t cend() const noexcept { return {}; }
    
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>
<li><p>Modify 29.10.9.1 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.overview">[simd.mask.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std::simd {
  template&lt;size_t Bytes, class Abi&gt; class basic_mask {
  public:
    using value_type = bool;
    using abi_type = Abi;
    using iterator = <i>simd-iterator</i>&lt;basic_mask&gt;;
    using const_iterator = <i>simd-iterator</i>&lt;const basic_mask&gt;;

    constexpr iterator begin() noexcept { return <ins>iterator(</ins><del>{</del>*this, 0<del>}</del><ins>)</ins>; }
    constexpr const_iterator begin() const noexcept { return <ins>const_iterator(</ins><del>{</del>*this, 0<del>}</del><ins>)</ins>; }
    constexpr const_iterator cbegin() const noexcept { return <ins>const_iterator(</ins><del>{</del>*this, 0<del>}</del><ins>)</ins>; }
    constexpr default_sentinel_t end() const noexcept { return {}; }
    constexpr default_sentinel_t cend() const noexcept { return {}; }
    
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4403"><a href="4403">4403</a>. <code class='backtick'>simd::basic_vec</code> CTAD misses difference type casting</h3>
<p><b>Section:</b> 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-04 <b>Last modified:</b> 2025-10-04</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.ctor">active issues</a> in [simd.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.ctor">issues</a> in [simd.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, <code class='backtick'>basic_vec</code> can take an object <code class='backtick'>r</code> of range type <code class='backtick'>R</code> whose size is a
constant expression and deduced to <code>vec&lt;ranges::range_value_t&lt;R&gt;, ranges::size(r)&gt;</code>.
<p/>
However, such a deduced type is ill-formed when <code class='backtick'>R</code> has a an integer-class type size which cannot
be implicitly converted to <code><i>simd-size-type</i></code>, which is a signed integer type.
<p/>
It is necessary to perform difference type casting here, and the narrowing
conversion will still correctly be rejected due to the constructor's constraints.
</p>


<p id="res-4403"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R, class... Ts&gt;
  basic_vec(R&amp;&amp; r, Ts...) -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-17- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
  <li><p>
  (17.1) &mdash; <code class='backtick'>R</code> models <code class='backtick'>ranges::contiguous_range</code> and <code class='backtick'>ranges::sized_range</code>, and
  </p></li>
  <li><p>
  (17.2) &mdash; <code class='backtick'>ranges::size(r)</code> is a constant expression.
  </p></li>
</ol>
<p>
-18- <i>Remarks</i>: The deduced type is equivalent to <code>
vec&lt;ranges::range_value_t&lt;R&gt;, <ins>static_cast&lt;<i>simd-size-type</i>&gt;(</ins>ranges::size(r)<ins>)</ins>&gt;
</code>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4404"><a href="4404">4404</a>. Should <code>span(R&amp;&amp;)</code> CTAD apply P2280?</h3>
<p><b>Section:</b> 23.7.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/span.deduct">[span.deduct]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-04 <b>Last modified:</b> 2025-10-05</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Thanks to <a href="https://wg21.link/P2280R4" title=" Using unknown references in constant expressions">P2280R4</a>, <code class='backtick'>simd::basic_vec</code>'s CTAD can specify template parameters 
directly through <code class='backtick'>ranges::size</code>:
</p>
<blockquote><pre>
basic_vec(R&amp;&amp; r, ...) -&gt; vec&lt;ranges::range_value_t&lt;R&gt;, ranges::size(r)&gt;
</pre></blockquote>
<p>
However, <code>span</code> with similar CTAD forms do not have this automatic static size optimization applied:
</p>
<blockquote><pre>
span(R&amp;&amp;) -&gt; span&lt;remove_reference_t&lt;ranges::range_reference_t&lt;R&gt;&gt;&gt;;
</pre></blockquote>
<p>
Do we need to do it for <code>span</code>?
<p/>
Note that the <code class='backtick'>span</code> constructor actually requires <code class='backtick'>R</code> to be a <code class='backtick'>contiguous_range</code> and a
<code class='backtick'>sized_range</code>. If it is further required that <code class='backtick'>ranges::size</code> be a constant expression, only raw array,
<code class='backtick'>array</code>, <code class='backtick'>span</code>, <code class='backtick'>ranges::empty_view</code>, and <code class='backtick'>ranges::single_view</code> satisfy this requirement. 
Given that <code class='backtick'>span</code> already has CTAD for raw arrays and <code class='backtick'>array</code>s, this improvement is not 
significant, but it still seems worthwhile as a compile-time optimization for certain
user-defined types or in some specialized cases (<a href="https://godbolt.org/z/vjPxKzdTf">demo</a>):
</p>
<blockquote><pre>
#include &lt;array&gt;
#include &lt;ranges&gt;

constexpr std::size_t N = 42;

auto to_span(auto&amp; r) { 
  static_assert(std::ranges::size(r) == N); // ok after P2280
  return std::span(r);
}

std::array&lt;int, N&gt; a;
auto s1 = to_span(a);
static_assert(std::same_as&lt;decltype(s1), std::span&lt;int, N&gt;&gt;);

auto r = std::array&lt;int, N&gt;{} | std::views::as_const; // as_const_view&lt;owning_view&lt;array&lt;int, N&gt;&gt;&gt;
auto s2 = to_span(r);
static_assert(std::same_as&lt;decltype(s2), std::span&lt;const int, N&gt;&gt;); // <span style="color:red;font-weight:bolder">fire, ok after this PR</span>
</pre></blockquote>


<p id="res-4404"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 23.7.2.2.1 <a href="https://timsong-cpp.github.io/cppwp/span.overview">[span.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class ElementType, size_t Extent = dynamic_extent&gt;
  class span {
    [&hellip;]
  };
  [&hellip;]
  template&lt;class R&gt;
    span(R&amp;&amp; <ins>r</ins>) -&gt; <ins><i>see below</i></ins><del>span&lt;remove_reference_t&lt;ranges::range_reference_t&lt;R&gt;&gt;&gt;</del>;
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.2.2.3 <a href="https://timsong-cpp.github.io/cppwp/span.deduct">[span.deduct]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R&gt;
  span(R&amp;&amp; <ins>r</ins>) -&gt; <ins><i>see below</i></ins><del>span&lt;remove_reference_t&lt;ranges::range_reference_t&lt;R&gt;&gt;&gt;</del>;
</pre>
<blockquote>
<p>
-2- <i>Constraints</i>: <code class='backtick'>R</code> satisfies <code class='backtick'>ranges::contiguous_range</code>.
<p/>
<ins>-?- <i>Remarks</i>: Let <code class='backtick'>T</code> denote the type <code>remove_reference_t&lt;ranges::range_reference_t&lt;R&gt;&gt;</code>.
The deduced type is equivalent to</ins>
</p>
<ol style="list-style-type: none">
  <li><p>
  <ins>(?.1) &mdash; <code>span&lt;T, static_cast&lt;size_t&gt;(ranges::size(r))&gt;</code>
if <code class='backtick'>R</code> satisfies <code class='backtick'>ranges::sized_range</code> and <code class='backtick'>ranges::size(r)</code> is a constant expression.</ins>
  </p></li>
  <li><p>
  <ins>(?.2) &mdash; <code>span&lt;T&gt;</code> otherwise.</ins>
  </p></li>
</ol>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4405"><a href="4405">4405</a>. <code class='backtick'>mdspan</code> constructor should disallow derived to base conversions</h3>
<p><b>Section:</b> 23.7.3.6.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.cons">[mdspan.mdspan.cons]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-05 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike <code class='backtick'>ranges::subrange</code> or <code class='backtick'>span</code>, <code class='backtick'>mdspan</code> syntactically allows a multidimensional
viewing base class via a derived class pointer (<a href="https://godbolt.org/z/c56h9fjs8">demo</a>):
</p>
<blockquote><pre>
#include &lt;span&gt;
#include &lt;ranges&gt;
#include &lt;mdspan&gt;

struct Base {};
struct Derived : Base {};
std::array&lt;Derived, 12&gt; arr;
std::ranges::subrange&lt;Base*&gt; s(arr); // error, slicing
std::span&lt;Base&gt; sp(arr.data(), arr.size()); // error, slicing
std::mdspan&lt;Base, std::dims&lt;1&gt;&gt; msp(arr.data(), arr.size()); // <span  style="color:#C80000;font-weight:bold">ok</span>
</pre></blockquote>
<p>
Given that we intend to reject object slicing for both <code class='backtick'>default_accessor</code> and
<code class='backtick'>aligned_accessor</code>, there seems no reason not to reject this invalid pointer 
arithmetic for <code class='backtick'>mdspan</code>.
</p>


<p id="res-4405"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> The exposition-only concept <code><i>convertible-to-non-slicing</i></code> comes from 
25.5.4.1 <a href="https://timsong-cpp.github.io/cppwp/range.subrange.general">[range.subrange.general]</a>.]
</p>
</blockquote>

<ol>

<li><p>Modify 23.7.3.6.1 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.overview">[mdspan.mdspan.overview]</a> as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class ElementType, class Extents, class LayoutPolicy = layout_right,
           class AccessorPolicy = default_accessor&lt;ElementType&gt;&gt;
  class mdspan {
  public:
    using extents_type = Extents;
    using layout_type = LayoutPolicy;
    using accessor_type = AccessorPolicy;
    using mapping_type = typename layout_type::template mapping&lt;extents_type&gt;;
    using element_type = ElementType;
    using value_type = remove_cv_t&lt;element_type&gt;;
    using index_type = typename extents_type::index_type;
    using size_type = typename extents_type::size_type;
    using rank_type = typename extents_type::rank_type;
    using data_handle_type = typename accessor_type::data_handle_type;
    using reference = typename accessor_type::reference;
    [&hellip;]
    template&lt;class... OtherIndexTypes&gt;
      constexpr explicit mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> ptr, OtherIndexTypes... exts);
    template&lt;class OtherIndexType, size_t N&gt;
      constexpr explicit(N != rank_dynamic())
        mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, span&lt;OtherIndexType, N&gt; exts);
    template&lt;class OtherIndexType, size_t N&gt;
      constexpr explicit(N != rank_dynamic())
        mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const array&lt;OtherIndexType, N&gt;&amp; exts);
    constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const extents_type&amp; ext);
    constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const mapping_type&amp; m);
    constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const mapping_type&amp; m, const accessor_type&amp; a);
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>
</li>

<li><p>Modify 23.7.3.6.2 <a href="https://timsong-cpp.github.io/cppwp/mdspan.mdspan.cons">[mdspan.mdspan.cons]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class... OtherIndexTypes&gt;
  constexpr explicit mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, OtherIndexTypes... exts);
</pre>
<blockquote>
<p>
-4- Let <code class='backtick'>N</code> be <code class='backtick'>sizeof...(OtherIndexTypes)</code>.
<p/>
-5- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class OtherIndexType, size_t N&gt;
  constexpr explicit(N != rank_dynamic())
    mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, span&lt;OtherIndexType, N&gt; exts);
template&lt;class OtherIndexType, size_t N&gt;
  constexpr explicit(N != rank_dynamic())
    mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const array&lt;OtherIndexType, N&gt;&amp; exts);
</pre>
<blockquote>
<p>
-8- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const extents_type&amp; ext);
</pre>
<blockquote>
<p>
-11- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const mapping_type&amp; m);
</pre>
<blockquote>
<p>
-14- <i>Constraints</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
constexpr mdspan(<ins><i>convertible-to-non-slicing</i>&lt;</ins>data_handle_type<ins>&gt; auto</ins> p, const mapping_type&amp; m, const accessor_type&amp; a);
</pre>
<blockquote>
<p>
-17- <i>Preconditions</i>: [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3 id="4406"><a href="4406">4406</a>. <code class='backtick'>optional::value_or</code> return statement is inconsistent with <i>Mandates</i></h3>
<p><b>Section:</b> 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a>, 22.5.4.6 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.observe">[optional.ref.observe]</a>, 22.8.6.6 <a href="https://timsong-cpp.github.io/cppwp/expected.object.obs">[expected.object.obs]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-09-06 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.observe">active issues</a> in [optional.observe].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.observe">issues</a> in [optional.observe].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code>optional&lt;T&gt;::value_or(U&amp;&amp;)</code> requires <code>is_convertible_v&lt;U&amp;&amp;, T&gt;</code> 
to ensure that <code class='backtick'>T</code> can be convert from <code class='backtick'>U</code> when <code class='backtick'>optional</code> has no value.
<p/>
However, the return statement explicitly constructs <code class='backtick'>T</code> by <code class='backtick'>static_cast</code>, which is not checked by 
<code class='backtick'>is_convertible_v</code> since it only checks for implicit conversions.
<p/>
This results in rare cases where <i>Mandates</i> may not be violated, but <code class='backtick'>value_or</code> is ill-formed 
(<a href="https://godbolt.org/z/z5jjhY7c4">demo</a>):
</p>
<blockquote><pre>
struct S {
  operator int() const;
  explicit operator int() = delete;
};

int main() {
   std::optional&lt;int&gt;{}.value_or(S{}); // <span style="color:#C80000;font-weight:bold">fire</span>
}
</pre></blockquote>
<p>
It is reasonable to create objects that stick to <i>Mandates</i>. The same goes for <code class='backtick'>expected::value_or</code>.
<p/>
<b>Daniel:</b>
<p/>
This issue has considerable overlap with LWG <a href="4281" title="Inconsistency between value_or() and error_or() in std::expected (Status: New)">4281</a>.
</p>


<p id="res-4406"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 22.5.3.7 <a href="https://timsong-cpp.github.io/cppwp/optional.observe">[optional.observe]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr T value_or(U&amp;&amp; v) const &amp;;
</pre>
<blockquote>
<p>
-15- <i>Mandates</i>: <code>is_copy_constructible_v&lt;T&gt; &amp;&amp; is_convertible_v&lt;U&amp;&amp;, T&gt;</code> 
is <code class='backtick'>true</code>.
<p/>
-16- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<del>return has_value() ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v));</del>
<ins>if (has_value())
  return **this;
return std::forward&lt;U&gt;(v);</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr T value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
-17- <i>Mandates</i>: <code>is_move_constructible_v&lt;T&gt; &amp;&amp; is_convertible_v&lt;U&amp;&amp;, T&gt;</code> 
is <code class='backtick'>true</code>.
<p/>
-18- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<del>return has_value() ? std::move(**this) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v));</del>
<ins>if (has_value())
  return std::move(**this);
return std::forward&lt;U&gt;(v);</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.5.4.6 <a href="https://timsong-cpp.github.io/cppwp/optional.ref.observe">[optional.ref.observe]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr remove_cv_t&lt;T&gt; value_or(U&amp;&amp; u) const;
</pre>
<blockquote>
<p>
-8- Let <code>X</code> be <code>remove_cv_t&lt;T&gt;</code>.
<p/>
-9- <i>Mandates</i>: <code>is_constructible_v&lt;X, T&amp;&gt; &amp;&amp; is_convertible_v&lt;U, X&gt;</code> 
is <code class='backtick'>true</code>.
<p/>
-10- <i>Effects</i>: Equivalent to:
</p>
<blockquote><pre>
<del>return has_value() ? *<i>val</i> : static_cast&lt;X&gt;(std::forward&lt;U&gt;(u));</del>
<ins>if (has_value())
  return *<i>val</i>;
return std::forward&lt;U&gt;(u);
</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 22.8.6.6 <a href="https://timsong-cpp.github.io/cppwp/expected.object.obs">[expected.object.obs]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr T value_or(U&amp;&amp; v) const &amp;;
</pre>
<blockquote>
<p>
-18- <i>Mandates</i>: <code>is_copy_constructible_v&lt;T&gt;</code> is <code class='backtick'>true</code> and 
<code>is_convertible_v&lt;U, T&gt;</code> is <code class='backtick'>true</code>.
<p/>
<del>-19- <i>Returns</i>: <code>has_value() ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v))</code>.</del>
<p/>
<ins>-?- <i>Effects</i>: Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>if (has_value())
  return **this;
return std::forward&lt;U&gt;(v);</ins>
</pre></blockquote>
</blockquote>
<pre>
template&lt;class U = remove_cv_t&lt;T&gt;&gt; constexpr T value_or(U&amp;&amp; v) &amp;&amp;;
</pre>
<blockquote>
<p>
-20- <i>Mandates</i>: <code>is_move_constructible_v&lt;T&gt;</code> is <code class='backtick'>true</code> and 
<code>is_convertible_v&lt;U, T&gt;</code> is <code class='backtick'>true</code>.
<p/>
<del>-21- <i>Returns</i>: <code>has_value() ? std::move(**this) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(v))</code>.</del>
<p/>
<ins>-?- <i>Effects</i>: Equivalent to:</ins>
</p>
<blockquote><pre>
<ins>if (has_value())
  return std::move(**this);
return std::forward&lt;U&gt;(v);</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4407"><a href="4407">4407</a>. <code><i>constexpr-wrapper-like</i></code> needs <code class='backtick'>remove_cvref_t</code> in <code class='backtick'>simd::basic_vec</code>
constructor</h3>
<p><b>Section:</b> 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-05 <b>Last modified:</b> 2025-10-10</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#simd.ctor">active issues</a> in [simd.ctor].</p>
<p><b>View all other</b> <a href="lwg-index.html#simd.ctor">issues</a> in [simd.ctor].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>decltype(From::value)</code> would be <code>const int&amp;</code> if <code class='backtick'>From</code> is a type of <code>std::cw&lt;42&gt;</code>, 
so the reference also needs to be removed for checking the arithmetic type.
</p>


<p id="res-4407"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class U&gt; constexpr explicit(<i>see below</i>) basic_vec(U&amp;&amp; value) noexcept;
</pre>
<blockquote>
<p>
-1- Let <code class='backtick'>From</code> denote the type <code>remove_cvref_t&lt;U&gt;</code>.
<p/>
[&hellip;]
<p/>
-4- <i>Remarks</i>:  The expression inside <code class='backtick'>explicit</code> evaluates to <code class='backtick'>false</code> if and only if <code class='backtick'>U</code> 
satisfies <code>convertible_to&lt;value_type&gt;</code>, and either
</p>
<ol style="list-style-type: none">
<li><p>
(4.1) &mdash; <code class='backtick'>From</code> is not an arithmetic type and does not satisfy <code><i>constexpr-wrapper-like</i></code>,
</p></li>
<li><p>
(4.2) &mdash; <code class='backtick'>From</code> is an arithmetic type and the conversion from <code class='backtick'>From</code> to <code class='backtick'>value_type</code> is 
value-preserving (29.10.1 <a href="https://timsong-cpp.github.io/cppwp/simd.general">[simd.general]</a>), or
</p></li>
<li><p> 
(4.3) &mdash; <code class='backtick'>From</code> satisfies <code><i>constexpr-wrapper-like</i></code>, 
<code><ins>remove_cvref_t</ins><del>remove_const_t</del>&lt;decltype(From::value)&gt;</code> 
is an arithmetic type, and <code class='backtick'>From::value</code> is representable by <code class='backtick'>value_type</code>.
</p></li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4408"><a href="4408">4408</a>. Hardening <code class='backtick'>simd::vec::operator[]</code></h3>
<p><b>Section:</b> 29.10.7.3 <a href="https://timsong-cpp.github.io/cppwp/simd.subscr">[simd.subscr]</a>, 29.10.9.3 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.subscr">[simd.mask.subscr]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hewill Kang <b>Opened:</b> 2025-10-07 <b>Last modified:</b> 2025-10-11</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<code class='backtick'>simd::vec::operator[]</code> satisfies the criteria in <a href="https://wg21.link/P3471R4" title=" Standard Library Hardening">P3471R4</a> and <a href="https://wg21.link/P3697R1" title=" Minor additions to C++26 standard library hardening">P3697R1</a> : 
"violating the precondition results in a memory safety issue", which means that hardening is reasonable.
</p>


<p id="res-4408"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.7.3 <a href="https://timsong-cpp.github.io/cppwp/simd.subscr">[simd.subscr]</a> as indicated:</p>

<blockquote>
<pre>
constexpr value_type operator[](<i>simd-size-type</i> i) const;
</pre>
<blockquote>
<p>
-1- <i><ins>Hardened </ins><del>P</del><ins>p</ins>reconditions</i>: <code>i &gt;= 0 &amp;&amp; i &lt; size()</code> is <code class='backtick'>true</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 29.10.9.3 <a href="https://timsong-cpp.github.io/cppwp/simd.mask.subscr">[simd.mask.subscr]</a> as indicated:</p>

<blockquote>
<pre>
constexpr value_type operator[](<i>simd-size-type</i> i) const;
</pre>
<blockquote>
<p>
-1- <i><ins>Hardened </ins><del>P</del><ins>p</ins>reconditions</i>: <code>i &gt;= 0 &amp;&amp; i &lt; size()</code> is <code class='backtick'>true</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3 id="4409"><a href="4409">4409</a>. Constant expression <code class='backtick'>ranges::size(r)</code> <i>Constraints</i> and <i>Mandates</i> in [simd]</h3>
<p><b>Section:</b> 29.10 <a href="https://timsong-cpp.github.io/cppwp/simd">[simd]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Lnrd Szolnoki <b>Opened:</b> 2025-10-10 <b>Last modified:</b> 2025-10-12</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Various <i>Constraints</i> and <i>Mandates</i> in 29.10 <a href="https://timsong-cpp.github.io/cppwp/simd">[simd]</a> are conditioned on <code class='backtick'>ranges::size(r)</code>, 
assuming that subsequent operations on the result are also constant expression. This is not a given, 
since <code class='backtick'>ranges::size(r)</code> is allowed to return an integer-class type, and it is not mandated that operations 
on integer-class types are usable in constant expressions.
<p/>
In particular:
</p>
<ol>
<li><p>
29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> p13:
</p>
<blockquote>
<p>
<i>Constraints</i>: 
</p>
<ul>
<li><p><code class='backtick'>R</code> models <code class='backtick'>ranges::contiguous_range</code> and <code class='backtick'>ranges::sized_range</code>,</p></li>
<li><p><code class='backtick'>ranges::size(r)</code> is a constant expression, and</p></li>
<li><p><code class='backtick'>ranges::size(r)</code> is equal to <code class='backtick'>size()</code>.</p></li>
</ul>
</blockquote>
<p>
Here <code class='backtick'>ranges::size(r) == size()</code> might not be a constant expression, even when <code class='backtick'>ranges::size(r)</code> 
is. Operations that are not accounted for:
</p>
<ul>
<li><p>Possible conversion from <code class='backtick'>range::size(r)</code> to <code><i>simd-size-type</i></code>.</p></li>
<li><p>Possible operator overloading on ==.</p></li>
</ul>
</li>

<li><p>
29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> p17+18:
</p>
<blockquote>
<p>
<i>Constraints</i>: 
</p>
<ul>
<li><p><code class='backtick'>R</code> models <code class='backtick'>ranges::contiguous_range</code> and <code class='backtick'>ranges::sized_range</code>, and</p></li>
<li><p><code class='backtick'>ranges::size(r)</code> is a constant expression</p></li>
</ul>
<p>
<i>Remarks:</i> The deduced type is equivalent to <code>vec&lt;ranges::range_value_t&lt;R&gt;, ranges::size(r)&gt;</code>.
</p>
</blockquote>
<p>
Here the second constraint is simply redundant, if failure to form the type is in the immediate context. 
If we want to type it out in the constraints then we should account for conversion to <code><i>simd-size-type</i></code> 
and narrowing.
</p>
</li>

<li><p>
29.10.8.7 <a href="https://timsong-cpp.github.io/cppwp/simd.loadstore">[simd.loadstore]</a> p2:
</p>
<blockquote>
<p>
<i>Mandates</i>: If <code class='backtick'>ranges::size(r)</code> is a constant expression then <code class='backtick'>ranges::size(r)</code>  <code class='backtick'>V::size()</code>. 
</p>
</blockquote>
<p>
Here <code>ranges::size(r) &gt;= V::size()</code> might not be a constant expression, even when 
<code class='backtick'>ranges::size(r)</code> is. It is unclear why a mathematical operator symbol is used here (and further 
down in the preconditions).
</p>
</li>
</ol>



<p id="res-4409"><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N5014" title=" Working Draft, Standard for Programming Language C++">N5014</a>.
</p>

<ol>

<li><p>Modify 29.10.7.2 <a href="https://timsong-cpp.github.io/cppwp/simd.ctor">[simd.ctor]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class R, class... Flags&gt;
  constexpr basic_vec(R&amp;&amp; r, flags&lt;Flags...&gt; = {});
template&lt;class R, class... Flags&gt;
  constexpr basic_vec(R&amp;&amp; r, const mask_type&amp; mask, flags&lt;Flags...&gt; = {});
</pre>
<blockquote>
<p>
-12- Let <code class='backtick'>mask</code> be <code class='backtick'>mask_type(true)</code> for the overload with no <code class='backtick'>mask</code> parameter.
<p/>
-13- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>
(13.1) &mdash; <code class='backtick'>R</code> models <code class='backtick'>ranges::contiguous_range</code> and <code class='backtick'>ranges::sized_range</code>, <ins>and</ins>
</p></li>
<li><p>
(13.2) &mdash; <code>ranges::size(r) <ins>== size()</ins></code> is a constant expression, and <ins>evaluates to <code class='backtick'>true</code>.</ins>
</p></li>
<li><p>
<del>(13.3) &mdash; <code class='backtick'>ranges::size(r)</code> is equal to <code class='backtick'>size()</code>.</del>
</p></li>
</ol>
[&hellip;]
</blockquote>
<pre>
template&lt;class R, class... Ts&gt;
  basic_vec(R&amp;&amp; r, Ts...) -&gt; <i>see below</i>;
</pre>
<blockquote>
<p>
-17- <i>Constraints</i>:
</p>
<ol style="list-style-type: none">
<li><p>
<del>(17.1) &mdash;</del> <code class='backtick'>R</code> models <code class='backtick'>ranges::contiguous_range</code> and <code class='backtick'>ranges::sized_range</code><del>, and</del><ins>.</ins>
</p></li>
<li><p>
<del>(17.2) &mdash; <code class='backtick'>ranges::size(r)</code> is a constant expression.</del>
</p></li>
</ol>
<p>
-18- <i>Remarks</i>: The deduced type is equivalent to <code>vec&lt;ranges::range_value_t&lt;R&gt;, ranges::size(r)&gt;</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 29.10.8.7 <a href="https://timsong-cpp.github.io/cppwp/simd.loadstore">[simd.loadstore]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class V = <i>see below</i>, ranges::contiguous_range R, class... Flags&gt;
  requires ranges::sized_range&lt;R&gt;
  constexpr V unchecked_load(R&amp;&amp; r, flags&lt;Flags...&gt; f = {});
[&hellip;]
template&lt;class V = <i>see below</i>, contiguous_iterator I, sized_sentinel_for&lt;I&gt; S, class... Flags&gt;
  constexpr V unchecked_load(I first, S last, const typename V::mask_type&amp; mask,
                             flags&lt;Flags...&gt; f = {});
</pre>
<blockquote>
<p>
-1- Let [&hellip;]
<p/>
-2- <i>Mandates</i>: If <code>ranges::size(r) <ins>&gt;= V::size()</ins></code> is a constant expression 
then <del><code class='backtick'>ranges::size(r)</code>  <code class='backtick'>V::size()</code></del><ins>it evaluates to <code class='backtick'>true</code></ins>.
</p>
</blockquote>
</blockquote>
</li>

</ol>






</body>
</html>
