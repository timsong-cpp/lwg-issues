<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 3645: resize_and_overwrite is overspecified to call its callback with lvalues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
  @media (prefers-color-scheme: dark) {
     html {
        color: #ddd;
        background-color: black;
     }
     ins {
        background-color: #225522
     }
     del {
        background-color: #662222
     }
     a {
        color: #6af
     }
     a:visited {
        color: #6af
     }
     blockquote.note
     {
        background-color: rgba(255, 255, 255, .10)
     }
  }
</style>
</head>
<body>
<hr>
<h3><a name="3645" href="lwg-active.html#3645">3645.</a> <tt>resize_and_overwrite</tt> is overspecified to call its callback with lvalues</h3>
<p><b>Section:</b> 23.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a> <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Arthur O'Dwyer <b>Opened:</b> 2021-11-28 <b>Last modified:</b> 2022-01-30 17:05:36 UTC</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.capacity">issues</a> in [string.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a> p7 says:
</p>
<ul>
<li><p>[Let] <tt><i>OP</i></tt> be the expression <tt>std::move(op)(p, n)</tt>.</p></li>
<li><p>[<i>Precondition:</i>] <tt><i>OP</i></tt> does not throw an exception or modify <tt>p</tt> or <tt>n</tt>.</p></li>
</ul>
<p>
Notice that <tt>p</tt> and <tt>n</tt> above are lvalue expressions.
<p/>
Discussed with Mark Zeren, Casey Carter, Jonathan Wakely. We observe that:
<p/>
A. This wording requires vendors to reject
</p>
<blockquote><pre>
s.resize_and_overwrite(100, [](char*&amp;&amp;, size_t&amp;&amp;){ return 0; });
</pre></blockquote>
<p>
which is surprising.
<p/>
B. This wording requires vendors to accept
</p>
<blockquote><pre>
s.resize_and_overwrite(100, [](char*&amp;, size_t&amp;){ return 0; });
</pre></blockquote>
<p>
which is even more surprising, and also threatens to allow the user to corrupt 
the internal state (which is why we need to specify the Precondition above).
<p/>
C. A user who writes
</p>
<blockquote><pre>
s.resize_and_overwrite(100, [](auto&amp;&amp;, auto&amp;&amp;){ return 0; });
</pre></blockquote>
<p>
can detect that they're being passed lvalues instead of rvalues. If we change 
the wording to permit implementations to pass either lvalues or rvalues (their choice), 
then this will be detectable by the user, so we don't want that if we can help it.
</p>
<ol style="list-style-type:none">
<li><p>X. We want to enable implementations to say <tt>move(op)(__p, __n)</tt> 
and then use <tt>__p</tt> and <tt>__n</tt>.</p></li>
<li><p>Y. We have one implementation which wants to say <tt>move(op)(data(), __n)</tt>, 
which is not currently allowed, but arguably should be.</p></li>
<li><p>Z. We have to do or say something about disallowing writes to any 
internal state to which <tt>Op</tt> might get a reference.</p></li>
</ol>
<p>
Given all of this, Mark and Arthur think that the simplest way out is to say that the 
arguments are prvalues. It prevents X, but fixes the surprises in A, B, Y, Z. We 
could do this in the Let bullets. Either like so:
</p>
<ul>
<li><p>[Let] <tt>p</tt> be a prvalue of type <tt>charT*</tt> &hellip;</p></li>
<li><p><tt>m</tt> be a prvalue of type <tt>size_type</tt> equal to <tt>n</tt>,</p></li>
<li><p><tt><i>OP</i></tt> be the expression <tt>std::move(op)(p, m)</tt>.</p></li>
</ul>
<p>
or (Arthur's preference) by specifying prvalues in the expression <tt><i>OP</i></tt> itself:
</p>
<ul>
<li><p>[Let] <tt><i>OP</i></tt> be the expression <tt>std::move(op)(auto(p), auto(n))</tt>.</p></li>
</ul>
<p>
No matter which specification approach we adopt, we can also simplify the Preconditions bullet to:
</p>
<ul>
<li><p>[<i>Precondition:</i>] <tt><i>OP</i></tt> does not throw an exception.</p></li>
</ul>
<p>
because once the user is receiving prvalue copies, it will no longer be physically possible for the 
user to modify the library's original variables <tt>p</tt> and <tt>n</tt>.
</p>

<p><i>[2021-11-29; Arthur O'Dwyer provides wording]</i></p>


<p><i>[2022-01-30; Reflector poll]</i></p>

<p>
Set priority to 2 after reflector poll.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="https://wg21.link/N4901">N4901</a>.
</p>

<ol>

<li><p>Modify 23.4.3.5 <a href="https://timsong-cpp.github.io/cppwp/string.capacity">[string.capacity]</a> as indicated:</p>

<blockquote>
<pre>
template&lt;class Operation&gt; constexpr void resize_and_overwrite(size_type n, Operation op);
</pre>
<blockquote>
<p>
-7- Let
</p>
<ol style="list-style-type:none">
<li><p>(7.1) &mdash; <tt>o = size()</tt> before the call to <tt>resize_and_overwrite</tt>.</p></li>
<li><p>(7.2) &mdash; <tt>k</tt> be <tt>min(o, n)</tt>.</p></li>
<li><p>(7.3) &mdash; <tt>p</tt> be a <tt>charT*</tt>, such that the range <tt>[p, p + n]</tt> is valid 
and <tt>this-&gt;compare(0, k, p, k) == 0</tt> is <tt>true</tt> before the call. The values in the range 
<tt>[p + k, p + n]</tt> may be indeterminate (6.7.4 <a href="https://timsong-cpp.github.io/cppwp/basic.indet">[basic.indet]</a>).</p></li>
<li><p>(7.4) &mdash; <tt><i>OP</i></tt> be the expression <tt>std::move(op)(<ins>auto(</ins>p<ins>)</ins>, <ins>auto(</ins>n<ins>)</ins>)</tt>.</p></li>
<li><p>(7.5) &mdash; <tt>r = <i>OP</i></tt>.</p></li>
</ol>
<p>
-8- <i>Mandates:</i> <tt><i>OP</i></tt> has an integer-like type (25.3.4.4 <a href="https://timsong-cpp.github.io/cppwp/iterator.concept.winc">[iterator.concept.winc]</a>).
<p/>
-9- <i>Preconditions:</i>
</p>
<ol style="list-style-type:none">
<li><p>(9.1) &mdash; <tt><i>OP</i></tt> does not throw an exception <del>or modify <tt>p</tt> or <tt>n</tt></del>.</p></li>
<li><p>(9.2) &mdash; <tt>r &ge; 0</tt>.</p></li>
<li><p>(9.3) &mdash; <tt>r &le; n</tt>.</p></li>
<li><p>(9.4) &mdash; After evaluating <tt><i>OP</i></tt> there are no indeterminate values in the range 
<tt>[p, p + r)</tt>.</p></li>
</ol>
<p>
-10- <i>Effects:</i> Evaluates <tt><i>OP</i></tt>, replaces the contents of <tt>*this</tt> with <tt>[p, p + r)</tt>, 
and invalidates all pointers and references to the range <tt>[p, p + n]</tt>.
<p/>
-11- <i>Recommended practice:</i> Implementations should avoid unnecessary copies and allocations by, for example,
making <tt>p</tt> a pointer into internal storage and by restoring <tt>*(p + r)</tt> to <tt>charT()</tt> 
after evaluating <tt><i>OP</i></tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





</body>
</html>
