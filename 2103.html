<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Issue 2103: std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<p>Revised 2016-11-28 at 17:11:30 UTC</p>
<hr>
<h3><a name="2103" href="2103">2103.</a> <tt>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment</tt></h3>
<p><b>Section:</b> 20.10.9 [default.allocator] <b>Status:</b> <a href="lwg-active.html#C++14">C++14</a>
 <b>Submitter:</b> Ai Azuma <b>Opened:</b> 2011-11-08 <b>Last modified:</b> 2016-01-28</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#default.allocator">issues</a> in [default.allocator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#C++14">C++14</a> status.</p>
<p><b>Discussion:</b></p>

<p>
&quot;<tt>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment::value</tt>&quot;
is specified as &quot;false&quot;, according to (20.10.9 [default.allocator]) and (20.10.8.1 [allocator.traits.types]).
However, according to (23.2.1 [container.requirements.general]), this specification leads to the unneeded requirements
(<tt>MoveInsertable</tt> and <tt>MoveAssignable</tt> of the value type) on the move assignment operator of containers
with the default allocator. 
<p/>
Proposed resolution:
<p/>
Either of the following two changes;  
</p>
<ol>
<li>
adding the nested typedef like
&quot;<tt>typedef std::true_type propagate_on_container_move_assignment;</tt>&quot;
in the definition of <tt>std::allocator</tt> class template,
</li>
<li>
adding the explicit partial specialization of
&quot;<tt>std::allocator_traits</tt>&quot; class template for &quot;<tt>std::allocator</tt>&quot;
class template, in which &quot;<tt>propagate_on_container_move_assignment</tt>&quot;
nested typedef is specified as &quot;<tt>std::true_type</tt>&quot;. 
</li>
</ol>
<p>
Pablo prefers the first resolution.
</p>

<p><i>[2011-12-02: Pablo comments]</i></p>


<p>
This issue has potentially some overlap with <a href="2108">2108</a>. Should the trait <tt>always_compare_equal</tt>
been added, this issue's resolution should be improved based on that.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Ready.
</p>

<p><i>[2012, Portland: applied to WP]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 20.10.9 [default.allocator], the class template <tt>allocator</tt> synopsis as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class T&gt; class allocator;

  <i>// specialize for <tt>void</tt>:</i>
  template &lt;&gt; class allocator&lt;void&gt; {
  public:
    typedef void* pointer;
    typedef const void* const_pointer;
    <i>// reference-to-<tt>void</tt> members are impossible.</i>
    typedef void value_type;
    template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
  };

  template &lt;class T&gt; class allocator {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T&amp; reference;
    typedef const T&amp; const_reference;
    typedef T value_type;
    template &lt;class U&gt; struct rebind { typedef allocator&lt;U&gt; other; };
    <ins>typedef true_type propagate_on_container_move_assignment;</ins>

    [&hellip;]
  };
}
</pre></blockquote>






</body>
</html>
